<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/zPageTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  */
23 
24 #include &quot;precompiled.hpp&quot;
25 #include &quot;gc/z/zAddress.inline.hpp&quot;
26 #include &quot;gc/z/zPage.inline.hpp&quot;
27 #include &quot;gc/z/zPageTable.inline.hpp&quot;
28 #include &quot;runtime/orderAccess.hpp&quot;
29 #include &quot;utilities/debug.hpp&quot;
30 
31 ZPageTable::ZPageTable() :
32     _map() {}
33 
34 ZPageTableEntry ZPageTable::get_entry(ZPage* page) const {
35   const uintptr_t addr = ZAddress::good(page-&gt;start());
36   return _map.get(addr);
37 }
38 
39 void ZPageTable::put_entry(ZPage* page, ZPageTableEntry entry) {
40   // Make sure a newly created page is globally visible before
41   // updating the pagetable.
42   OrderAccess::storestore();
43 
44   const uintptr_t start = ZAddress::good(page-&gt;start());
45   const uintptr_t end = start + page-&gt;size();
46   for (uintptr_t addr = start; addr &lt; end; addr += ZGranuleSize) {
47     _map.put(addr, entry);
48   }
49 }
50 
51 void ZPageTable::insert(ZPage* page) {
52   assert(get_entry(page).page() == NULL ||
53          get_entry(page).page() == page, &quot;Invalid entry&quot;);
54 
55   // Cached pages stays in the pagetable and we must not re-insert
56   // those when they get re-allocated because they might also be
57   // relocating and we don&#39;t want to clear their relocating bit.
58   if (get_entry(page).page() == NULL) {
59     ZPageTableEntry entry(page, false /* relocating */);
60     put_entry(page, entry);
61   }
62 
63   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
64 }
65 
66 void ZPageTable::remove(ZPage* page) {
67   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
68 
69   ZPageTableEntry entry;
70   put_entry(page, entry);
71 
72   assert(get_entry(page).page() == NULL, &quot;Invalid entry&quot;);
73 }
74 
75 void ZPageTable::set_relocating(ZPage* page) {
76   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
77   assert(!get_entry(page).relocating(), &quot;Invalid entry&quot;);
78 
79   ZPageTableEntry entry(page, true /* relocating */);
80   put_entry(page, entry);
81 
82   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
83   assert(get_entry(page).relocating(), &quot;Invalid entry&quot;);
84 }
85 
86 void ZPageTable::clear_relocating(ZPage* page) {
87   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
88   assert(get_entry(page).relocating(), &quot;Invalid entry&quot;);
89 
90   ZPageTableEntry entry(page, false /* relocating */);
91   put_entry(page, entry);
92 
93   assert(get_entry(page).page() == page, &quot;Invalid entry&quot;);
94   assert(!get_entry(page).relocating(), &quot;Invalid entry&quot;);
95 }
    </pre>
  </body>
</html>
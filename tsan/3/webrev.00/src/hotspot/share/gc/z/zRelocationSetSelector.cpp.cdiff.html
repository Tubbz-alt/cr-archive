<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zRelocationSetSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zRelocationSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocationSetSelector.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zRelocationSetSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,14 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zArray.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zRelocationSet.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zRelocationSetSelector.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
  ZRelocationSetSelectorGroup::ZRelocationSetSelectorGroup(const char* name,
                                                           size_t page_size,
                                                           size_t object_size_limit) :
      _name(name),
<span class="line-new-header">--- 23,24 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zArray.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zRelocationSet.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zRelocationSetSelector.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
<span class="line-added">+ </span>
<span class="line-added">+ ZRelocationSetSelectorGroupStats::ZRelocationSetSelectorGroupStats() :</span>
<span class="line-added">+     _npages(0),</span>
<span class="line-added">+     _total(0),</span>
<span class="line-added">+     _live(0),</span>
<span class="line-added">+     _garbage(0),</span>
<span class="line-added">+     _empty(0),</span>
<span class="line-added">+     _compacting_from(0),</span>
<span class="line-added">+     _compacting_to(0) {}</span>
  
  ZRelocationSetSelectorGroup::ZRelocationSetSelectorGroup(const char* name,
                                                           size_t page_size,
                                                           size_t object_size_limit) :
      _name(name),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,23 ***</span>
      _object_size_limit(object_size_limit),
      _fragmentation_limit(page_size * (ZFragmentationLimit / 100)),
      _registered_pages(),
      _sorted_pages(NULL),
      _nselected(0),
<span class="line-modified">!     _relocating(0),</span>
<span class="line-removed">-     _fragmentation(0) {}</span>
  
  ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(const ZPage*, _sorted_pages);</span>
  }
  
<span class="line-modified">! void ZRelocationSetSelectorGroup::register_live_page(const ZPage* page, size_t garbage) {</span>
    if (garbage &gt; _fragmentation_limit) {
      _registered_pages.add(page);
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _fragmentation += garbage;</span>
    }
  }
  
  void ZRelocationSetSelectorGroup::semi_sort() {
    // Semi-sort registered pages by live bytes in ascending order
    const size_t npartitions_shift = 11;
<span class="line-new-header">--- 48,39 ---</span>
      _object_size_limit(object_size_limit),
      _fragmentation_limit(page_size * (ZFragmentationLimit / 100)),
      _registered_pages(),
      _sorted_pages(NULL),
      _nselected(0),
<span class="line-modified">!     _stats() {}</span>
  
  ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(ZPage*, _sorted_pages);</span>
  }
  
<span class="line-modified">! void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {</span>
<span class="line-added">+   const uint8_t type = page-&gt;type();</span>
<span class="line-added">+   const size_t size = page-&gt;size();</span>
<span class="line-added">+   const size_t live = page-&gt;live_bytes();</span>
<span class="line-added">+   const size_t garbage = size - live;</span>
<span class="line-added">+ </span>
    if (garbage &gt; _fragmentation_limit) {
      _registered_pages.add(page);
    }
<span class="line-added">+ </span>
<span class="line-added">+   _stats._npages++;</span>
<span class="line-added">+   _stats._total += size;</span>
<span class="line-added">+   _stats._live += live;</span>
<span class="line-added">+   _stats._garbage += garbage;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {</span>
<span class="line-added">+   const size_t size = page-&gt;size();</span>
<span class="line-added">+ </span>
<span class="line-added">+   _stats._npages++;</span>
<span class="line-added">+   _stats._total += size;</span>
<span class="line-added">+   _stats._garbage += size;</span>
<span class="line-added">+   _stats._empty += size;</span>
  }
  
  void ZRelocationSetSelectorGroup::semi_sort() {
    // Semi-sort registered pages by live bytes in ascending order
    const size_t npartitions_shift = 11;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,17 ***</span>
  
    // Partition slots/fingers
    size_t partitions[npartitions];
  
    // Allocate destination array
<span class="line-modified">!   _sorted_pages = REALLOC_C_HEAP_ARRAY(const ZPage*, _sorted_pages, npages, mtGC);</span>
    debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));
  
    // Calculate partition slots
    memset(partitions, 0, sizeof(partitions));
<span class="line-modified">!   ZArrayIterator&lt;const ZPage*&gt; iter1(&amp;_registered_pages);</span>
<span class="line-modified">!   for (const ZPage* page; iter1.next(&amp;page);) {</span>
      const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
      partitions[index]++;
    }
  
    // Calculate partition fingers
<span class="line-new-header">--- 91,18 ---</span>
  
    // Partition slots/fingers
    size_t partitions[npartitions];
  
    // Allocate destination array
<span class="line-modified">!   assert(_sorted_pages == NULL, &quot;Already initialized&quot;);</span>
<span class="line-added">+   _sorted_pages = NEW_C_HEAP_ARRAY(ZPage*, npages, mtGC);</span>
    debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));
  
    // Calculate partition slots
    memset(partitions, 0, sizeof(partitions));
<span class="line-modified">!   ZArrayIterator&lt;ZPage*&gt; iter1(&amp;_registered_pages);</span>
<span class="line-modified">!   for (ZPage* page; iter1.next(&amp;page);) {</span>
      const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
      partitions[index]++;
    }
  
    // Calculate partition fingers
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,20 ***</span>
      partitions[i] = finger;
      finger += slots;
    }
  
    // Sort pages into partitions
<span class="line-modified">!   ZArrayIterator&lt;const ZPage*&gt; iter2(&amp;_registered_pages);</span>
<span class="line-modified">!   for (const ZPage* page; iter2.next(&amp;page);) {</span>
      const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
      const size_t finger = partitions[index]++;
      assert(_sorted_pages[finger] == NULL, &quot;Invalid finger&quot;);
      _sorted_pages[finger] = page;
    }
  }
  
  void ZRelocationSetSelectorGroup::select() {
    // Calculate the number of pages to relocate by successively including pages in
    // a candidate relocation set and calculate the maximum space requirement for
    // their live objects.
    const size_t npages = _registered_pages.size();
    size_t selected_from = 0;
<span class="line-new-header">--- 112,25 ---</span>
      partitions[i] = finger;
      finger += slots;
    }
  
    // Sort pages into partitions
<span class="line-modified">!   ZArrayIterator&lt;ZPage*&gt; iter2(&amp;_registered_pages);</span>
<span class="line-modified">!   for (ZPage* page; iter2.next(&amp;page);) {</span>
      const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
      const size_t finger = partitions[index]++;
      assert(_sorted_pages[finger] == NULL, &quot;Invalid finger&quot;);
      _sorted_pages[finger] = page;
    }
  }
  
  void ZRelocationSetSelectorGroup::select() {
<span class="line-added">+   if (_page_size == 0) {</span>
<span class="line-added">+     // Page type disabled</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Calculate the number of pages to relocate by successively including pages in
    // a candidate relocation set and calculate the maximum space requirement for
    // their live objects.
    const size_t npages = _registered_pages.size();
    size_t selected_from = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,90 ***</span>
  
    // Finalize selection
    _nselected = selected_from;
  
    // Update statistics
<span class="line-modified">!   _relocating = from_size;</span>
<span class="line-modified">!   for (size_t i = _nselected; i &lt; npages; i++) {</span>
<span class="line-removed">-     const ZPage* const page = _sorted_pages[i];</span>
<span class="line-removed">-     _fragmentation += page-&gt;size() - page-&gt;live_bytes();</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   log_debug(gc, reloc)(&quot;Relocation Set (%s Pages): &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot; skipped&quot;,</span>
                         _name, selected_from, selected_to, npages - _nselected);
  }
  
<span class="line-removed">- const ZPage* const* ZRelocationSetSelectorGroup::selected() const {</span>
<span class="line-removed">-   return _sorted_pages;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZRelocationSetSelectorGroup::nselected() const {</span>
<span class="line-removed">-   return _nselected;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZRelocationSetSelectorGroup::relocating() const {</span>
<span class="line-removed">-   return _relocating;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZRelocationSetSelectorGroup::fragmentation() const {</span>
<span class="line-removed">-   return _fragmentation;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  ZRelocationSetSelector::ZRelocationSetSelector() :
      _small(&quot;Small&quot;, ZPageSizeSmall, ZObjectSizeLimitSmall),
      _medium(&quot;Medium&quot;, ZPageSizeMedium, ZObjectSizeLimitMedium),
<span class="line-modified">!     _live(0),</span>
<span class="line-removed">-     _garbage(0),</span>
<span class="line-removed">-     _fragmentation(0) {}</span>
  
<span class="line-modified">! void ZRelocationSetSelector::register_live_page(const ZPage* page) {</span>
    const uint8_t type = page-&gt;type();
<span class="line-removed">-   const size_t live = page-&gt;live_bytes();</span>
<span class="line-removed">-   const size_t garbage = page-&gt;size() - live;</span>
  
    if (type == ZPageTypeSmall) {
<span class="line-modified">!     _small.register_live_page(page, garbage);</span>
    } else if (type == ZPageTypeMedium) {
<span class="line-modified">!     _medium.register_live_page(page, garbage);</span>
    } else {
<span class="line-modified">!     _fragmentation += garbage;</span>
    }
<span class="line-removed">- </span>
<span class="line-removed">-   _live += live;</span>
<span class="line-removed">-   _garbage += garbage;</span>
  }
  
<span class="line-modified">! void ZRelocationSetSelector::register_garbage_page(const ZPage* page) {</span>
<span class="line-modified">!   _garbage += page-&gt;size();</span>
  }
  
  void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {
    // Select pages to relocate. The resulting relocation set will be
    // sorted such that medium pages comes first, followed by small
    // pages. Pages within each page group will be semi-sorted by live
    // bytes in ascending order. Relocating pages in this order allows
    // us to start reclaiming memory more quickly.
  
<span class="line-modified">!   // Select pages from each group</span>
    _medium.select();
    _small.select();
  
    // Populate relocation set
    relocation_set-&gt;populate(_medium.selected(), _medium.nselected(),
                             _small.selected(), _small.nselected());
  }
  
<span class="line-modified">! size_t ZRelocationSetSelector::live() const {</span>
<span class="line-modified">!   return _live;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! size_t ZRelocationSetSelector::garbage() const {</span>
<span class="line-modified">!   return _garbage;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZRelocationSetSelector::relocating() const {</span>
<span class="line-removed">-   return _small.relocating() + _medium.relocating();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZRelocationSetSelector::fragmentation() const {</span>
<span class="line-removed">-   return _fragmentation + _small.fragmentation() + _medium.fragmentation();</span>
  }
<span class="line-new-header">--- 168,64 ---</span>
  
    // Finalize selection
    _nselected = selected_from;
  
    // Update statistics
<span class="line-modified">!   _stats._compacting_from = selected_from * _page_size;</span>
<span class="line-modified">!   _stats._compacting_to = selected_to * _page_size;</span>
  
<span class="line-modified">!   log_trace(gc, reloc)(&quot;Relocation Set (%s Pages): &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot; skipped&quot;,</span>
                         _name, selected_from, selected_to, npages - _nselected);
  }
  
  ZRelocationSetSelector::ZRelocationSetSelector() :
      _small(&quot;Small&quot;, ZPageSizeSmall, ZObjectSizeLimitSmall),
      _medium(&quot;Medium&quot;, ZPageSizeMedium, ZObjectSizeLimitMedium),
<span class="line-modified">!     _large(&quot;Large&quot;, 0 /* page_size */, 0 /* object_size_limit */) {}</span>
  
<span class="line-modified">! void ZRelocationSetSelector::register_live_page(ZPage* page) {</span>
    const uint8_t type = page-&gt;type();
  
    if (type == ZPageTypeSmall) {
<span class="line-modified">!     _small.register_live_page(page);</span>
    } else if (type == ZPageTypeMedium) {
<span class="line-modified">!     _medium.register_live_page(page);</span>
    } else {
<span class="line-modified">!     _large.register_live_page(page);</span>
    }
  }
  
<span class="line-modified">! void ZRelocationSetSelector::register_garbage_page(ZPage* page) {</span>
<span class="line-modified">!   const uint8_t type = page-&gt;type();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (type == ZPageTypeSmall) {</span>
<span class="line-added">+     _small.register_garbage_page(page);</span>
<span class="line-added">+   } else if (type == ZPageTypeMedium) {</span>
<span class="line-added">+     _medium.register_garbage_page(page);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _large.register_garbage_page(page);</span>
<span class="line-added">+   }</span>
  }
  
  void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {
    // Select pages to relocate. The resulting relocation set will be
    // sorted such that medium pages comes first, followed by small
    // pages. Pages within each page group will be semi-sorted by live
    // bytes in ascending order. Relocating pages in this order allows
    // us to start reclaiming memory more quickly.
  
<span class="line-modified">!   // Select pages from each group, except large</span>
    _medium.select();
    _small.select();
  
    // Populate relocation set
    relocation_set-&gt;populate(_medium.selected(), _medium.nselected(),
                             _small.selected(), _small.nselected());
  }
  
<span class="line-modified">! ZRelocationSetSelectorStats ZRelocationSetSelector::stats() const {</span>
<span class="line-modified">!   ZRelocationSetSelectorStats stats;</span>
<span class="line-modified">!   stats._small = _small.stats();</span>
<span class="line-modified">!   stats._medium = _medium.stats();</span>
<span class="line-modified">!   stats._large = _large.stats();</span>
<span class="line-modified">!   return stats;</span>
  }
</pre>
<center><a href="zRelocationSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocationSetSelector.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 
 29 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 30   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 31   for (ZMemory* area; iter.next(&amp;area);) {
 32     if (area-&gt;size() &gt;= size) {
 33       if (area-&gt;size() == size) {
 34         // Exact match, remove area
 35         const uintptr_t start = area-&gt;start();
 36         _freelist.remove(area);
 37         delete area;
 38         return start;
 39       } else {
 40         // Larger than requested, shrink area
 41         const uintptr_t start = area-&gt;start();
 42         area-&gt;shrink_from_front(size);
 43         return start;
 44       }
 45     }
 46   }
 47 
 48   // Out of memory
 49   return UINTPTR_MAX;
 50 }
 51 
 52 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
 53   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 54   for (ZMemory* area; iter.next(&amp;area);) {
 55     if (area-&gt;size() &gt;= size) {
 56       if (area-&gt;size() == size) {
 57         // Exact match, remove area
 58         const uintptr_t start = area-&gt;start();
 59         _freelist.remove(area);
 60         delete area;
 61         return start;
 62       } else {
 63         // Larger than requested, shrink area
 64         area-&gt;shrink_from_back(size);
 65         return area-&gt;end();
 66       }
 67     }
 68   }
 69 
 70   // Out of memory
 71   return UINTPTR_MAX;
 72 }
 73 
 74 void ZMemoryManager::free(uintptr_t start, size_t size) {
 75   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
 76   const uintptr_t end = start + size;
 77 
 78   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 79   for (ZMemory* area; iter.next(&amp;area);) {
 80     if (start &lt; area-&gt;start()) {
 81       ZMemory* const prev = _freelist.prev(area);
 82       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
 83         if (end == area-&gt;start()) {
 84           // Merge with prev and current area
 85           prev-&gt;grow_from_back(size + area-&gt;size());
 86           _freelist.remove(area);
 87           delete area;
 88         } else {
 89           // Merge with prev area
 90           prev-&gt;grow_from_back(size);
 91         }
 92       } else if (end == area-&gt;start()) {
 93         // Merge with current area
 94         area-&gt;grow_from_front(size);
 95       } else {
 96         // Insert new area before current area
 97         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
 98         ZMemory* new_area = new ZMemory(start, size);
 99         _freelist.insert_before(area, new_area);
100       }
101 
102       // Done
103       return;
104     }
105   }
106 
107   // Insert last
108   ZMemory* const last = _freelist.last();
109   if (last != NULL &amp;&amp; start == last-&gt;end()) {
110     // Merge with last area
111     last-&gt;grow_from_back(size);
112   } else {
113     // Insert new area last
114     ZMemory* new_area = new ZMemory(start, size);
115     _freelist.insert_last(new_area);
116   }
117 }
    </pre>
  </body>
</html>
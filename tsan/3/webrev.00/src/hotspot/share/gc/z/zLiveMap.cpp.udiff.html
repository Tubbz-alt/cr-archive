<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zLiveMap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zList.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zLiveMap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zLiveMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,53 +23,59 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
  #include &quot;gc/z/zLiveMap.inline.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/z/zThread.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/z/zThread.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  static const ZStatCounter ZCounterMarkSeqNumResetContention(&quot;Contention&quot;, &quot;Mark SeqNum Reset Contention&quot;, ZStatUnitOpsPerSecond);
  static const ZStatCounter ZCounterMarkSegmentResetContention(&quot;Contention&quot;, &quot;Mark Segment Reset Contention&quot;, ZStatUnitOpsPerSecond);
  
<span class="udiff-line-added">+ static size_t bitmap_size(uint32_t size, size_t nsegments) {</span>
<span class="udiff-line-added">+   // We need at least one bit per segment</span>
<span class="udiff-line-added">+   return MAX2&lt;size_t&gt;(size, nsegments) * 2;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  ZLiveMap::ZLiveMap(uint32_t size) :
      _seqnum(0),
      _live_objects(0),
      _live_bytes(0),
      _segment_live_bits(0),
      _segment_claim_bits(0),
<span class="udiff-line-modified-removed">-     // We need at least one bit per segment.</span>
<span class="udiff-line-modified-removed">-     _bitmap(MAX2&lt;size_t&gt;(size, nsegments) * 2),</span>
<span class="udiff-line-removed">-     _shift(exact_log2(segment_size())) {}</span>
<span class="udiff-line-modified-added">+     _bitmap(bitmap_size(size, nsegments)),</span>
<span class="udiff-line-modified-added">+     _segment_shift(exact_log2(segment_size())) {}</span>
  
  void ZLiveMap::reset(size_t index) {
    const uint32_t seqnum_initializing = (uint32_t)-1;
    bool contention = false;
  
    // Multiple threads can enter here, make sure only one of them
    // resets the marking information while the others busy wait.
<span class="udiff-line-modified-removed">-   for (uint32_t seqnum = _seqnum; seqnum != ZGlobalSeqNum; seqnum = _seqnum) {</span>
<span class="udiff-line-modified-added">+   for (uint32_t seqnum = Atomic::load_acquire(&amp;_seqnum);</span>
<span class="udiff-line-added">+        seqnum != ZGlobalSeqNum;</span>
<span class="udiff-line-added">+        seqnum = Atomic::load_acquire(&amp;_seqnum)) {</span>
      if ((seqnum != seqnum_initializing) &amp;&amp;
<span class="udiff-line-modified-removed">-         (Atomic::cmpxchg(seqnum_initializing, &amp;_seqnum, seqnum) == seqnum)) {</span>
<span class="udiff-line-modified-added">+         (Atomic::cmpxchg(&amp;_seqnum, seqnum, seqnum_initializing) == seqnum)) {</span>
        // Reset marking information
        _live_bytes = 0;
        _live_objects = 0;
  
        // Clear segment claimed/live bits
        segment_live_bits().clear();
        segment_claim_bits().clear();
  
<span class="udiff-line-removed">-       // Make sure the newly reset marking information is</span>
<span class="udiff-line-removed">-       // globally visible before updating the page seqnum.</span>
<span class="udiff-line-removed">-       OrderAccess::storestore();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Update seqnum</span>
        assert(_seqnum == seqnum_initializing, &quot;Invalid&quot;);
<span class="udiff-line-modified-removed">-       _seqnum = ZGlobalSeqNum;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+       // Make sure the newly reset marking information is ordered</span>
<span class="udiff-line-added">+       // before the update of the page seqnum, such that when the</span>
<span class="udiff-line-added">+       // up-to-date seqnum is load acquired, the bit maps will not</span>
<span class="udiff-line-added">+       // contain stale information.</span>
<span class="udiff-line-added">+       Atomic::release_store(&amp;_seqnum, ZGlobalSeqNum);</span>
        break;
      }
  
      // Mark reset contention
      if (!contention) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,14 +93,10 @@</span>
    bool contention = false;
  
    if (!claim_segment(segment)) {
      // Already claimed, wait for live bit to be set
      while (!is_segment_live(segment)) {
<span class="udiff-line-removed">-       // Busy wait. The loadload barrier is needed to make</span>
<span class="udiff-line-removed">-       // sure we re-read the live bit every time we loop.</span>
<span class="udiff-line-removed">-       OrderAccess::loadload();</span>
<span class="udiff-line-removed">- </span>
        // Mark reset contention
        if (!contention) {
          // Count contention once
          ZStatInc(ZCounterMarkSegmentResetContention);
          contention = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,8 +118,16 @@</span>
    } else {
      _bitmap.clear_range(start_index, end_index);
    }
  
    // Set live bit
<span class="udiff-line-modified-removed">-   const bool success = set_segment_live_atomic(segment);</span>
<span class="udiff-line-modified-added">+   const bool success = set_segment_live(segment);</span>
    assert(success, &quot;Should never fail&quot;);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ZLiveMap::resize(uint32_t size) {</span>
<span class="udiff-line-added">+   const size_t new_bitmap_size = bitmap_size(size, nsegments);</span>
<span class="udiff-line-added">+   if (_bitmap.size() != new_bitmap_size) {</span>
<span class="udiff-line-added">+     _bitmap.reinitialize(new_bitmap_size, false /* clear */);</span>
<span class="udiff-line-added">+     _segment_shift = exact_log2(segment_size());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="zList.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zLiveMap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/c2/zBarrierSetC2.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
 25 #define SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
 26 
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
 32 class LoadBarrierNode : public MultiNode {
 33 private:
 34   bool _weak;               // On strong or weak oop reference
 35   bool _writeback;          // Controls if the barrier writes the healed oop back to memory
 36                             // A swap on a memory location must never write back the healed oop
 37   bool _oop_reload_allowed; // Controls if the barrier are allowed to reload the oop from memory
 38                             // before healing, otherwise both the oop and the address must be
 39                             // passed to the barrier from the oop
 40 
 41   static bool is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n);
 42   void push_dominated_barriers(PhaseIterGVN* igvn) const;
 43 
 44 public:
 45   enum {
 46     Control,
 47     Memory,
 48     Oop,
 49     Address,
 50     Number_of_Outputs = Address,
 51     Similar,
 52     Number_of_Inputs
 53   };
 54 
 55   LoadBarrierNode(Compile* C,
 56                   Node* c,
 57                   Node* mem,
 58                   Node* val,
 59                   Node* adr,
 60                   bool weak,
 61                   bool writeback,
 62                   bool oop_reload_allowed);
 63 
 64   virtual int Opcode() const;
 65   virtual uint size_of() const;
 66   virtual uint cmp(const Node&amp; n) const;
 67   virtual const Type *bottom_type() const;
 68   virtual const TypePtr* adr_type() const;
 69   virtual const Type *Value(PhaseGVN *phase) const;
 70   virtual Node *Identity(PhaseGVN *phase);
 71   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 72   virtual uint match_edge(uint idx) const;
 73 
 74   LoadBarrierNode* has_dominating_barrier(PhaseIdealLoop* phase,
 75                                           bool linear_only,
 76                                           bool look_for_similar);
 77 
 78   void fix_similar_in_uses(PhaseIterGVN* igvn);
 79 
 80   bool has_true_uses() const;
 81 
 82   bool can_be_eliminated() const {
 83     return !in(Similar)-&gt;is_top();
 84   }
 85 
 86   bool is_weak() const {
 87     return _weak;
 88   }
 89 
 90   bool is_writeback() const {
 91     return _writeback;
 92   }
 93 
 94   bool oop_reload_allowed() const {
 95     return _oop_reload_allowed;
 96   }
 97 };
 98 
 99 class LoadBarrierSlowRegNode : public LoadPNode {
100 public:
101   LoadBarrierSlowRegNode(Node *c,
102                          Node *mem,
103                          Node *adr,
104                          const TypePtr *at,
105                          const TypePtr* t,
106                          MemOrd mo,
107                          ControlDependency control_dependency = DependsOnlyOnTest) :
108       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {
109     init_class_id(Class_LoadBarrierSlowReg);
110   }
111 
112   virtual const char * name() {
113     return &quot;LoadBarrierSlowRegNode&quot;;
114   }
115 
116   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
117     return NULL;
118   }
119 
120   virtual int Opcode() const;
121 };
122 
123 class LoadBarrierWeakSlowRegNode : public LoadPNode {
124 public:
125   LoadBarrierWeakSlowRegNode(Node *c,
126                              Node *mem,
127                              Node *adr,
128                              const TypePtr *at,
129                              const TypePtr* t,
130                              MemOrd mo,
131                              ControlDependency control_dependency = DependsOnlyOnTest) :
132       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {
133     init_class_id(Class_LoadBarrierWeakSlowReg);
134   }
135 
136   virtual const char * name() {
137     return &quot;LoadBarrierWeakSlowRegNode&quot;;
138   }
139 
140   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
141     return NULL;
142   }
143 
144   virtual int Opcode() const;
145 };
146 
147 class ZBarrierSetC2State : public ResourceObj {
148 private:
149   // List of load barrier nodes which need to be expanded before matching
150   GrowableArray&lt;LoadBarrierNode*&gt;* _load_barrier_nodes;
151 
152 public:
153   ZBarrierSetC2State(Arena* comp_arena);
154   int load_barrier_count() const;
155   void add_load_barrier_node(LoadBarrierNode* n);
156   void remove_load_barrier_node(LoadBarrierNode* n);
157   LoadBarrierNode* load_barrier_node(int idx) const;
158 };
159 
160 class ZBarrierSetC2 : public BarrierSetC2 {
161 private:
162   ZBarrierSetC2State* state() const;
163   Node* make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const;
164   Node* make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const;
165   void expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;
166   void expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const;
167   void expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;
168   const TypeFunc* load_barrier_Type() const;
169 
170 #ifdef ASSERT
171   void verify_gc_barriers(bool post_parse) const;
172 #endif
173 
174 protected:
175   virtual Node* load_at_resolved(C2Access&amp; access, const Type* val_type) const;
176   virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access,
177                                                Node* expected_val,
178                                                Node* new_val,
179                                                const Type* val_type) const;
180   virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access,
181                                                 Node* expected_val,
182                                                 Node* new_val,
183                                                 const Type* value_type) const;
184   virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access,
185                                         Node* new_val,
186                                         const Type* val_type) const;
187 
188 public:
189   Node* load_barrier(GraphKit* kit,
190                      Node* val,
191                      Node* adr,
192                      bool weak = false,
193                      bool writeback = true,
194                      bool oop_reload_allowed = true) const;
195 
196   virtual void* create_barrier_state(Arena* comp_arena) const;
197   virtual bool has_load_barriers() const { return true; }
198   virtual bool is_gc_barrier_node(Node* node) const;
199   virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const { }
200   virtual void eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const;
201   virtual void add_users_to_worklist(Unique_Node_List* worklist) const;
202   virtual void enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const;
203   virtual void register_potential_barrier_node(Node* node) const;
204   virtual void unregister_potential_barrier_node(Node* node) const;
205   virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const;
206   virtual Node* step_over_gc_barrier(Node* c) const;
207   // If the BarrierSetC2 state has kept barrier nodes in its compilation unit state to be
208   // expanded later, then now is the time to do so.
209   virtual bool expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const;
210 
211   static void find_dominating_barriers(PhaseIterGVN&amp; igvn);
212   static void loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round);
213 
214   virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const;
215 
216   virtual bool matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const;
217 
218 #ifdef ASSERT
219   virtual void verify_gc_barriers(Compile* compile, CompilePhase phase) const;
220 #endif
221 
222   virtual bool escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const;
223   virtual bool escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const;
224 };
225 
226 #endif // SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
    </pre>
  </body>
</html>
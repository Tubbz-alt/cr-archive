<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zCPU.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,48 ***</span>
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;gc/z/zCollectedHeap.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
  #include &quot;gc/z/zNMethod.hpp&quot;
  #include &quot;gc/z/zServiceability.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zUtils.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  
  ZCollectedHeap* ZCollectedHeap::heap() {
    CollectedHeap* heap = Universe::heap();
    assert(heap != NULL, &quot;Uninitialized access to ZCollectedHeap::heap()&quot;);
    assert(heap-&gt;kind() == CollectedHeap::Z, &quot;Invalid name&quot;);
    return (ZCollectedHeap*)heap;
  }
  
<span class="line-modified">! ZCollectedHeap::ZCollectedHeap(ZCollectorPolicy* policy) :</span>
<span class="line-removed">-     _collector_policy(policy),</span>
      _soft_ref_policy(),
      _barrier_set(),
      _initialize(&amp;_barrier_set),
      _heap(),
      _director(new ZDirector()),
      _driver(new ZDriver()),
      _stat(new ZStat()),
      _runtime_workers() {}
  
  CollectedHeap::Name ZCollectedHeap::kind() const {
    return CollectedHeap::Z;
  }
  
  const char* ZCollectedHeap::name() const {
<span class="line-modified">!   return ZGCName;</span>
  }
  
  jint ZCollectedHeap::initialize() {
    if (!_heap.is_initialized()) {
      return JNI_ENOMEM;
    }
  
<span class="line-modified">!   initialize_reserved_region((HeapWord*)ZAddressReservedStart(),</span>
<span class="line-removed">-                              (HeapWord*)ZAddressReservedEnd());</span>
  
    return JNI_OK;
  }
  
  void ZCollectedHeap::initialize_serviceability() {
<span class="line-new-header">--- 26,52 ---</span>
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;gc/z/zCollectedHeap.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
  #include &quot;gc/z/zNMethod.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zObjArrayAllocator.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/zOop.inline.hpp&quot;</span>
  #include &quot;gc/z/zServiceability.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zUtils.inline.hpp&quot;
<span class="line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  
  ZCollectedHeap* ZCollectedHeap::heap() {
    CollectedHeap* heap = Universe::heap();
    assert(heap != NULL, &quot;Uninitialized access to ZCollectedHeap::heap()&quot;);
    assert(heap-&gt;kind() == CollectedHeap::Z, &quot;Invalid name&quot;);
    return (ZCollectedHeap*)heap;
  }
  
<span class="line-modified">! ZCollectedHeap::ZCollectedHeap() :</span>
      _soft_ref_policy(),
      _barrier_set(),
      _initialize(&amp;_barrier_set),
      _heap(),
      _director(new ZDirector()),
      _driver(new ZDriver()),
<span class="line-added">+     _uncommitter(new ZUncommitter()),</span>
      _stat(new ZStat()),
      _runtime_workers() {}
  
  CollectedHeap::Name ZCollectedHeap::kind() const {
    return CollectedHeap::Z;
  }
  
  const char* ZCollectedHeap::name() const {
<span class="line-modified">!   return ZName;</span>
  }
  
  jint ZCollectedHeap::initialize() {
    if (!_heap.is_initialized()) {
      return JNI_ENOMEM;
    }
  
<span class="line-modified">!   Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);</span>
  
    return JNI_OK;
  }
  
  void ZCollectedHeap::initialize_serviceability() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,17 ***</span>
  }
  
  void ZCollectedHeap::stop() {
    _director-&gt;stop();
    _driver-&gt;stop();
    _stat-&gt;stop();
  }
  
<span class="line-removed">- CollectorPolicy* ZCollectedHeap::collector_policy() const {</span>
<span class="line-removed">-   return _collector_policy;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
    return &amp;_soft_ref_policy;
  }
  
  size_t ZCollectedHeap::max_capacity() const {
<span class="line-new-header">--- 79,14 ---</span>
  }
  
  void ZCollectedHeap::stop() {
    _director-&gt;stop();
    _driver-&gt;stop();
<span class="line-added">+   _uncommitter-&gt;stop();</span>
    _stat-&gt;stop();
  }
  
  SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
    return &amp;_soft_ref_policy;
  }
  
  size_t ZCollectedHeap::max_capacity() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,22 ***</span>
  
  size_t ZCollectedHeap::used() const {
    return _heap.used();
  }
  
  bool ZCollectedHeap::is_maximal_no_gc() const {
    // Not supported
    ShouldNotReachHere();
    return false;
  }
  
  bool ZCollectedHeap::is_in(const void* p) const {
<span class="line-modified">!   return is_in_reserved(p) &amp;&amp; _heap.is_in((uintptr_t)p);</span>
  }
  
<span class="line-modified">! bool ZCollectedHeap::is_in_closed_subset(const void* p) const {</span>
<span class="line-modified">!   return is_in(p);</span>
  }
  
  HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
    const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
    const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
<span class="line-new-header">--- 99,26 ---</span>
  
  size_t ZCollectedHeap::used() const {
    return _heap.used();
  }
  
<span class="line-added">+ size_t ZCollectedHeap::unused() const {</span>
<span class="line-added">+   return _heap.unused();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool ZCollectedHeap::is_maximal_no_gc() const {
    // Not supported
    ShouldNotReachHere();
    return false;
  }
  
  bool ZCollectedHeap::is_in(const void* p) const {
<span class="line-modified">!   return _heap.is_in((uintptr_t)p);</span>
  }
  
<span class="line-modified">! uint32_t ZCollectedHeap::hash_oop(oop obj) const {</span>
<span class="line-modified">!   return _heap.hash_oop(ZOop::to_address(obj));</span>
  }
  
  HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
    const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
    const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,10 ***</span>
<span class="line-new-header">--- 128,19 ---</span>
    }
  
    return (HeapWord*)addr;
  }
  
<span class="line-added">+ oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {</span>
<span class="line-added">+   if (!do_zero) {</span>
<span class="line-added">+     return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZObjArrayAllocator allocator(klass, size, length, THREAD);</span>
<span class="line-added">+   return allocator.allocate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
    const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
    return (HeapWord*)_heap.alloc_object(size_in_bytes);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,23 ***</span>
  GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
    return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
  }
  
  void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
<span class="line-modified">!   _heap.object_iterate(cl, true /* visit_referents */);</span>
  }
  
<span class="line-modified">! void ZCollectedHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-modified">!   _heap.object_iterate(cl, true /* visit_referents */);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- HeapWord* ZCollectedHeap::block_start(const void* addr) const {</span>
<span class="line-removed">-   return (HeapWord*)_heap.block_start((uintptr_t)addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZCollectedHeap::block_is_obj(const HeapWord* addr) const {</span>
<span class="line-removed">-   return _heap.block_is_obj((uintptr_t)addr);</span>
  }
  
  void ZCollectedHeap::register_nmethod(nmethod* nm) {
    ZNMethod::register_nmethod(nm);
  }
<span class="line-new-header">--- 242,15 ---</span>
  GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
    return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
  }
  
  void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
<span class="line-modified">!   _heap.object_iterate(cl, true /* visit_weaks */);</span>
  }
  
<span class="line-modified">! void ZCollectedHeap::keep_alive(oop obj) {</span>
<span class="line-modified">!   _heap.keep_alive(obj);</span>
  }
  
  void ZCollectedHeap::register_nmethod(nmethod* nm) {
    ZNMethod::register_nmethod(nm);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,21 ***</span>
  }
  
  void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
    tc-&gt;do_thread(_director);
    tc-&gt;do_thread(_driver);
    tc-&gt;do_thread(_stat);
    _heap.worker_threads_do(tc);
    _runtime_workers.threads_do(tc);
  }
  
  VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
<span class="line-modified">!   const size_t capacity_in_words = capacity() / HeapWordSize;</span>
<span class="line-removed">-   const size_t max_capacity_in_words = max_capacity() / HeapWordSize;</span>
<span class="line-removed">-   return VirtualSpaceSummary(reserved_region().start(),</span>
<span class="line-removed">-                              reserved_region().start() + capacity_in_words,</span>
<span class="line-removed">-                              reserved_region().start() + max_capacity_in_words);</span>
  }
  
  void ZCollectedHeap::safepoint_synchronize_begin() {
    SuspendibleThreadSet::synchronize();
  }
<span class="line-new-header">--- 276,18 ---</span>
  }
  
  void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
    tc-&gt;do_thread(_director);
    tc-&gt;do_thread(_driver);
<span class="line-added">+   tc-&gt;do_thread(_uncommitter);</span>
    tc-&gt;do_thread(_stat);
    _heap.worker_threads_do(tc);
    _runtime_workers.threads_do(tc);
  }
  
  VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
<span class="line-modified">!   return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());</span>
  }
  
  void ZCollectedHeap::safepoint_synchronize_begin() {
    SuspendibleThreadSet::synchronize();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,14 ***</span>
  }
  
  void ZCollectedHeap::print_on_error(outputStream* st) const {
    CollectedHeap::print_on_error(st);
  
<span class="line-removed">-   st-&gt;print_cr(&quot;Address Space&quot;);</span>
<span class="line-removed">-   st-&gt;print_cr( &quot;     Start:             &quot; PTR_FORMAT, ZAddressSpaceStart);</span>
<span class="line-removed">-   st-&gt;print_cr( &quot;     End:               &quot; PTR_FORMAT, ZAddressSpaceEnd);</span>
<span class="line-removed">-   st-&gt;print_cr( &quot;     Size:              &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZAddressSpaceSize, ZAddressSpaceSize);</span>
    st-&gt;print_cr( &quot;Heap&quot;);
    st-&gt;print_cr( &quot;     GlobalPhase:       %u&quot;, ZGlobalPhase);
    st-&gt;print_cr( &quot;     GlobalSeqNum:      %u&quot;, ZGlobalSeqNum);
    st-&gt;print_cr( &quot;     Offset Max:        &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZAddressOffsetMax, ZAddressOffsetMax);
    st-&gt;print_cr( &quot;     Page Size Small:   &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZPageSizeSmall, ZPageSizeSmall);
<span class="line-new-header">--- 305,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,22 ***</span>
  void ZCollectedHeap::print_gc_threads_on(outputStream* st) const {
    _director-&gt;print_on(st);
    st-&gt;cr();
    _driver-&gt;print_on(st);
    st-&gt;cr();
    _stat-&gt;print_on(st);
    st-&gt;cr();
    _heap.print_worker_threads_on(st);
    _runtime_workers.print_threads_on(st);
  }
  
  void ZCollectedHeap::print_tracing_info() const {
    // Does nothing
  }
  
  void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
    _heap.verify();
  }
  
  bool ZCollectedHeap::is_oop(oop object) const {
<span class="line-modified">!   return CollectedHeap::is_oop(object) &amp;&amp; _heap.is_oop(object);</span>
  }
<span class="line-new-header">--- 328,28 ---</span>
  void ZCollectedHeap::print_gc_threads_on(outputStream* st) const {
    _director-&gt;print_on(st);
    st-&gt;cr();
    _driver-&gt;print_on(st);
    st-&gt;cr();
<span class="line-added">+   _uncommitter-&gt;print_on(st);</span>
<span class="line-added">+   st-&gt;cr();</span>
    _stat-&gt;print_on(st);
    st-&gt;cr();
    _heap.print_worker_threads_on(st);
    _runtime_workers.print_threads_on(st);
  }
  
  void ZCollectedHeap::print_tracing_info() const {
    // Does nothing
  }
  
<span class="line-added">+ bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">+   return _heap.print_location(st, (uintptr_t)addr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
    _heap.verify();
  }
  
  bool ZCollectedHeap::is_oop(oop object) const {
<span class="line-modified">!   return _heap.is_oop(ZOop::to_address(object));</span>
  }
</pre>
<center><a href="zCPU.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
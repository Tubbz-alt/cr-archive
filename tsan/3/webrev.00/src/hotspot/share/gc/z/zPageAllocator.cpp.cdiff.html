<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zPageAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zPage.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zPageAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,24 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zAddress.inline.hpp&quot;
  #include &quot;gc/z/zCollectedHeap.hpp&quot;
  #include &quot;gc/z/zFuture.inline.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zLock.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageAllocator.hpp&quot;
  #include &quot;gc/z/zPageCache.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zPreMappedMemory.inline.hpp&quot;</span>
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zTracer.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  
  static const ZStatCounter       ZCounterAllocationRate(&quot;Memory&quot;, &quot;Allocation Rate&quot;, ZStatUnitBytesPerSecond);
  static const ZStatCriticalPhase ZCriticalPhaseAllocationStall(&quot;Allocation Stall&quot;);
  
  class ZPageAllocRequest : public StackObj {
    friend class ZList&lt;ZPageAllocRequest&gt;;
  
<span class="line-new-header">--- 20,32 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;</span>
  #include &quot;gc/z/zAddress.inline.hpp&quot;
  #include &quot;gc/z/zCollectedHeap.hpp&quot;
  #include &quot;gc/z/zFuture.inline.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zLock.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageAllocator.hpp&quot;
  #include &quot;gc/z/zPageCache.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zSafeDelete.inline.hpp&quot;</span>
  #include &quot;gc/z/zStat.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zTask.hpp&quot;</span>
  #include &quot;gc/z/zTracer.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zWorkers.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;runtime/init.hpp&quot;
<span class="line-added">+ #include &quot;runtime/java.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/debug.hpp&quot;</span>
  
  static const ZStatCounter       ZCounterAllocationRate(&quot;Memory&quot;, &quot;Allocation Rate&quot;, ZStatUnitBytesPerSecond);
<span class="line-added">+ static const ZStatCounter       ZCounterPageCacheFlush(&quot;Memory&quot;, &quot;Page Cache Flush&quot;, ZStatUnitBytesPerSecond);</span>
<span class="line-added">+ static const ZStatCounter       ZCounterUncommit(&quot;Memory&quot;, &quot;Uncommit&quot;, ZStatUnitBytesPerSecond);</span>
  static const ZStatCriticalPhase ZCriticalPhaseAllocationStall(&quot;Allocation Stall&quot;);
  
  class ZPageAllocRequest : public StackObj {
    friend class ZList&lt;ZPageAllocRequest&gt;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,11 ***</span>
  public:
    ZPageAllocRequest(uint8_t type, size_t size, ZAllocationFlags flags, unsigned int total_collections) :
        _type(type),
        _size(size),
        _flags(flags),
<span class="line-modified">!       _total_collections(total_collections) {}</span>
  
    uint8_t type() const {
      return _type;
    }
  
<span class="line-new-header">--- 60,13 ---</span>
  public:
    ZPageAllocRequest(uint8_t type, size_t size, ZAllocationFlags flags, unsigned int total_collections) :
        _type(type),
        _size(size),
        _flags(flags),
<span class="line-modified">!       _total_collections(total_collections),</span>
<span class="line-added">+       _node(),</span>
<span class="line-added">+       _result() {}</span>
  
    uint8_t type() const {
      return _type;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,10 ***</span>
<span class="line-new-header">--- 80,14 ---</span>
  
    unsigned int total_collections() const {
      return _total_collections;
    }
  
<span class="line-added">+   ZPage* peek() {</span>
<span class="line-added">+     return _result.peek();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    ZPage* wait() {
      return _result.get();
    }
  
    void satisfy(ZPage* page) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,41 ***</span>
    }
  };
  
  ZPage* const ZPageAllocator::gc_marker = (ZPage*)-1;
  
<span class="line-modified">! ZPageAllocator::ZPageAllocator(size_t min_capacity, size_t max_capacity, size_t max_reserve) :</span>
      _lock(),
<span class="line-modified">!     _virtual(),</span>
<span class="line-modified">!     _physical(max_capacity),</span>
      _cache(),
      _max_reserve(max_reserve),
<span class="line-modified">!     _pre_mapped(_virtual, _physical, try_ensure_unused_for_pre_mapped(min_capacity)),</span>
      _used_high(0),
      _used_low(0),
      _used(0),
      _allocated(0),
      _reclaimed(0),
      _queue(),
<span class="line-modified">!     _detached() {}</span>
  
  bool ZPageAllocator::is_initialized() const {
<span class="line-modified">!   return _physical.is_initialized() &amp;&amp;</span>
<span class="line-modified">!          _virtual.is_initialized() &amp;&amp;</span>
<span class="line-modified">!          _pre_mapped.is_initialized();</span>
  }
  
  size_t ZPageAllocator::max_capacity() const {
<span class="line-modified">!   return _physical.max_capacity();</span>
  }
  
<span class="line-modified">! size_t ZPageAllocator::current_max_capacity() const {</span>
<span class="line-modified">!   return _physical.current_max_capacity();</span>
  }
  
  size_t ZPageAllocator::capacity() const {
<span class="line-modified">!   return _physical.capacity();</span>
  }
  
  size_t ZPageAllocator::max_reserve() const {
    return _max_reserve;
  }
<span class="line-new-header">--- 95,147 ---</span>
    }
  };
  
  ZPage* const ZPageAllocator::gc_marker = (ZPage*)-1;
  
<span class="line-modified">! ZPageAllocator::ZPageAllocator(ZWorkers* workers,</span>
<span class="line-added">+                                size_t min_capacity,</span>
<span class="line-added">+                                size_t initial_capacity,</span>
<span class="line-added">+                                size_t max_capacity,</span>
<span class="line-added">+                                size_t max_reserve) :</span>
      _lock(),
<span class="line-modified">!     _virtual(max_capacity),</span>
<span class="line-modified">!     _physical(),</span>
      _cache(),
<span class="line-added">+     _min_capacity(min_capacity),</span>
<span class="line-added">+     _max_capacity(max_capacity),</span>
      _max_reserve(max_reserve),
<span class="line-modified">!     _current_max_capacity(max_capacity),</span>
<span class="line-added">+     _capacity(0),</span>
      _used_high(0),
      _used_low(0),
      _used(0),
      _allocated(0),
      _reclaimed(0),
      _queue(),
<span class="line-modified">!     _satisfied(),</span>
<span class="line-added">+     _safe_delete(),</span>
<span class="line-added">+     _uncommit(false),</span>
<span class="line-added">+     _initialized(false) {</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!_virtual.is_initialized() || !_physical.is_initialized()) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   log_info(gc, init)(&quot;Min Capacity: &quot; SIZE_FORMAT &quot;M&quot;, min_capacity / M);</span>
<span class="line-added">+   log_info(gc, init)(&quot;Initial Capacity: &quot; SIZE_FORMAT &quot;M&quot;, initial_capacity / M);</span>
<span class="line-added">+   log_info(gc, init)(&quot;Max Capacity: &quot; SIZE_FORMAT &quot;M&quot;, max_capacity / M);</span>
<span class="line-added">+   log_info(gc, init)(&quot;Max Reserve: &quot; SIZE_FORMAT &quot;M&quot;, max_reserve / M);</span>
<span class="line-added">+   log_info(gc, init)(&quot;Pre-touch: %s&quot;, AlwaysPreTouch ? &quot;Enabled&quot; : &quot;Disabled&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Warn if system limits could stop us from reaching max capacity</span>
<span class="line-added">+   _physical.warn_commit_limits(max_capacity);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Commit initial capacity</span>
<span class="line-added">+   _capacity = _physical.commit(initial_capacity);</span>
<span class="line-added">+   if (_capacity != initial_capacity) {</span>
<span class="line-added">+     log_error(gc)(&quot;Failed to allocate initial Java heap (&quot; SIZE_FORMAT &quot;M)&quot;, initial_capacity / M);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If uncommit is not explicitly disabled, max capacity is greater than</span>
<span class="line-added">+   // min capacity, and uncommit is supported by the platform, then we will</span>
<span class="line-added">+   // try to uncommit unused memory.</span>
<span class="line-added">+   _uncommit = ZUncommit &amp;&amp; (max_capacity &gt; min_capacity) &amp;&amp; _physical.supports_uncommit();</span>
<span class="line-added">+   if (_uncommit) {</span>
<span class="line-added">+     log_info(gc, init)(&quot;Uncommit: Enabled, Delay: &quot; UINTX_FORMAT &quot;s&quot;, ZUncommitDelay);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     log_info(gc, init)(&quot;Uncommit: Disabled&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Pre-map initial capacity</span>
<span class="line-added">+   prime_cache(workers, initial_capacity);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Successfully initialized</span>
<span class="line-added">+   _initialized = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ZPreTouchTask : public ZTask {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   const ZPhysicalMemoryManager* const _physical;</span>
<span class="line-added">+   volatile uintptr_t                  _start;</span>
<span class="line-added">+   const uintptr_t                     _end;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ZPreTouchTask(const ZPhysicalMemoryManager* physical, uintptr_t start, uintptr_t end) :</span>
<span class="line-added">+       ZTask(&quot;ZPreTouchTask&quot;),</span>
<span class="line-added">+       _physical(physical),</span>
<span class="line-added">+       _start(start),</span>
<span class="line-added">+       _end(end) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void work() {</span>
<span class="line-added">+     for (;;) {</span>
<span class="line-added">+       // Get granule offset</span>
<span class="line-added">+       const size_t size = ZGranuleSize;</span>
<span class="line-added">+       const uintptr_t offset = Atomic::fetch_and_add(&amp;_start, size);</span>
<span class="line-added">+       if (offset &gt;= _end) {</span>
<span class="line-added">+         // Done</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Pre-touch granule</span>
<span class="line-added">+       _physical-&gt;pretouch(offset, size);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::prime_cache(ZWorkers* workers, size_t size) {</span>
<span class="line-added">+   // Allocate physical memory</span>
<span class="line-added">+   const ZPhysicalMemory pmem = _physical.alloc(size);</span>
<span class="line-added">+   guarantee(!pmem.is_null(), &quot;Invalid size&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Allocate virtual memory</span>
<span class="line-added">+   const ZVirtualMemory vmem = _virtual.alloc(size, true /* alloc_from_front */);</span>
<span class="line-added">+   guarantee(!vmem.is_null(), &quot;Invalid size&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Allocate page</span>
<span class="line-added">+   ZPage* const page = new ZPage(vmem, pmem);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Map page</span>
<span class="line-added">+   map_page(page);</span>
<span class="line-added">+   page-&gt;set_pre_mapped();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (AlwaysPreTouch) {</span>
<span class="line-added">+     // Pre-touch page</span>
<span class="line-added">+     ZPreTouchTask task(&amp;_physical, page-&gt;start(), page-&gt;end());</span>
<span class="line-added">+     workers-&gt;run_parallel(&amp;task);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Add page to cache</span>
<span class="line-added">+   page-&gt;set_last_used();</span>
<span class="line-added">+   _cache.free_page(page);</span>
<span class="line-added">+ }</span>
  
  bool ZPageAllocator::is_initialized() const {
<span class="line-modified">!   return _initialized;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ size_t ZPageAllocator::min_capacity() const {</span>
<span class="line-added">+   return _min_capacity;</span>
  }
  
  size_t ZPageAllocator::max_capacity() const {
<span class="line-modified">!   return _max_capacity;</span>
  }
  
<span class="line-modified">! size_t ZPageAllocator::soft_max_capacity() const {</span>
<span class="line-modified">!   // Note that SoftMaxHeapSize is a manageable flag</span>
<span class="line-added">+   return MIN2(SoftMaxHeapSize, _current_max_capacity);</span>
  }
  
  size_t ZPageAllocator::capacity() const {
<span class="line-modified">!   return _capacity;</span>
  }
  
  size_t ZPageAllocator::max_reserve() const {
    return _max_reserve;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,10 ***</span>
<span class="line-new-header">--- 250,15 ---</span>
  
  size_t ZPageAllocator::used() const {
    return _used;
  }
  
<span class="line-added">+ size_t ZPageAllocator::unused() const {</span>
<span class="line-added">+   const ssize_t unused = (ssize_t)_capacity - (ssize_t)_used - (ssize_t)_max_reserve;</span>
<span class="line-added">+   return unused &gt; 0 ? (size_t)unused : 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  size_t ZPageAllocator::allocated() const {
    return _allocated;
  }
  
  size_t ZPageAllocator::reclaimed() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,174 ***</span>
    if (_used &lt; _used_low) {
      _used_low = _used;
    }
  }
  
<span class="line-removed">- size_t ZPageAllocator::max_available(bool no_reserve) const {</span>
<span class="line-removed">-   size_t available = current_max_capacity() - used();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (no_reserve) {</span>
<span class="line-removed">-     // The reserve should not be considered available</span>
<span class="line-removed">-     available -= MIN2(available, max_reserve());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return available;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZPageAllocator::try_ensure_unused(size_t size, bool no_reserve) {</span>
<span class="line-removed">-   // Ensure that we always have space available for the reserve. This</span>
<span class="line-removed">-   // is needed to avoid losing the reserve because of failure to map</span>
<span class="line-removed">-   // more memory before reaching max capacity.</span>
<span class="line-removed">-   _physical.try_ensure_unused_capacity(size + max_reserve());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   size_t unused = _physical.unused_capacity();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (no_reserve) {</span>
<span class="line-removed">-     // The reserve should not be considered unused</span>
<span class="line-removed">-     unused -= MIN2(unused, max_reserve());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return MIN2(size, unused);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ZPageAllocator::try_ensure_unused_for_pre_mapped(size_t size) {</span>
<span class="line-removed">-   // This function is called during construction, where the</span>
<span class="line-removed">-   // physical memory manager might have failed to initialied.</span>
<span class="line-removed">-   if (!_physical.is_initialized()) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return try_ensure_unused(size, true /* no_reserve */);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  ZPage* ZPageAllocator::create_page(uint8_t type, size_t size) {
<span class="line-removed">-   // Allocate physical memory</span>
<span class="line-removed">-   const ZPhysicalMemory pmem = _physical.alloc(size);</span>
<span class="line-removed">-   if (pmem.is_null()) {</span>
<span class="line-removed">-     // Out of memory</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Allocate virtual memory
    const ZVirtualMemory vmem = _virtual.alloc(size);
    if (vmem.is_null()) {
      // Out of address space
<span class="line-removed">-     _physical.free(pmem);</span>
      return NULL;
    }
  
    // Allocate page
    return new ZPage(type, vmem, pmem);
  }
  
<span class="line-modified">! void ZPageAllocator::flush_pre_mapped() {</span>
<span class="line-modified">!   if (_pre_mapped.available() == 0) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Detach the memory mapping.</span>
<span class="line-modified">!   detach_memory(_pre_mapped.virtual_memory(), _pre_mapped.physical_memory());</span>
  
<span class="line-modified">!   _pre_mapped.clear();</span>
  }
  
<span class="line-modified">! void ZPageAllocator::map_page(ZPage* page) {</span>
    // Map physical memory
    _physical.map(page-&gt;physical_memory(), page-&gt;start());
  }
  
<span class="line-modified">! void ZPageAllocator::detach_page(ZPage* page) {</span>
<span class="line-modified">!   // Detach the memory mapping.</span>
<span class="line-removed">-   detach_memory(page-&gt;virtual_memory(), page-&gt;physical_memory());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Add to list of detached pages</span>
<span class="line-removed">-   _detached.insert_last(page);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZPageAllocator::destroy_page(ZPage* page) {</span>
<span class="line-removed">-   assert(page-&gt;is_detached(), &quot;Invalid page state&quot;);</span>
  
<span class="line-modified">!   // Free virtual memory</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
<span class="line-removed">-     _virtual.free(page-&gt;virtual_memory());</span>
    }
  
<span class="line-modified">!   delete page;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZPageAllocator::flush_detached_pages(ZList&lt;ZPage&gt;* list) {</span>
<span class="line-removed">-   ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
<span class="line-removed">-   list-&gt;transfer(&amp;_detached);</span>
  }
  
<span class="line-modified">! void ZPageAllocator::flush_cache(size_t size) {</span>
<span class="line-modified">!   ZList&lt;ZPage&gt; list;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   _cache.flush(&amp;list, size);</span>
  
<span class="line-modified">!   for (ZPage* page = list.remove_first(); page != NULL; page = list.remove_first()) {</span>
<span class="line-modified">!     detach_page(page);</span>
    }
  }
  
<span class="line-modified">! void ZPageAllocator::check_out_of_memory_during_initialization() {</span>
<span class="line-modified">!   if (!is_init_completed()) {</span>
<span class="line-modified">!     vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;, &quot;Java heap too small&quot;);</span>
    }
  }
  
<span class="line-modified">! ZPage* ZPageAllocator::alloc_page_common_inner(uint8_t type, size_t size, ZAllocationFlags flags) {</span>
<span class="line-modified">!   const size_t max = max_available(flags.no_reserve());</span>
<span class="line-removed">-   if (max &lt; size) {</span>
      // Not enough free memory
      return NULL;
    }
  
<span class="line-modified">!   // Try allocating from the page cache</span>
<span class="line-modified">!   ZPage* const cached_page = _cache.alloc_page(type, size);</span>
<span class="line-modified">!   if (cached_page != NULL) {</span>
<span class="line-modified">!     return cached_page;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Try allocate from the pre-mapped memory</span>
<span class="line-removed">-   ZPage* const pre_mapped_page = _pre_mapped.alloc_page(type, size);</span>
<span class="line-removed">-   if (pre_mapped_page != NULL) {</span>
<span class="line-removed">-     return pre_mapped_page;</span>
    }
  
<span class="line-modified">!   // Flush any remaining pre-mapped memory so that</span>
<span class="line-modified">!   // subsequent allocations can use the physical memory.</span>
<span class="line-removed">-   flush_pre_mapped();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Try ensure that physical memory is available</span>
<span class="line-removed">-   const size_t unused = try_ensure_unused(size, flags.no_reserve());</span>
<span class="line-removed">-   if (unused &lt; size) {</span>
<span class="line-removed">-     // Flush cache to free up more physical memory</span>
<span class="line-removed">-     flush_cache(size - unused);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // Create new page and allocate physical memory</span>
    return create_page(type, size);
  }
  
  ZPage* ZPageAllocator::alloc_page_common(uint8_t type, size_t size, ZAllocationFlags flags) {
<span class="line-modified">!   ZPage* const page = alloc_page_common_inner(type, size, flags);</span>
    if (page == NULL) {
      // Out of memory
      return NULL;
    }
  
    // Update used statistics
    increase_used(size, flags.relocation());
  
    // Send trace event
<span class="line-modified">!   ZTracer::tracer()-&gt;report_page_alloc(size, used(), max_available(flags.no_reserve()), _cache.available(), flags);</span>
  
    return page;
  }
  
  ZPage* ZPageAllocator::alloc_page_blocking(uint8_t type, size_t size, ZAllocationFlags flags) {
    // Prepare to block
    ZPageAllocRequest request(type, size, flags, ZCollectedHeap::heap()-&gt;total_collections());
  
    _lock.lock();
<span class="line-new-header">--- 297,154 ---</span>
    if (_used &lt; _used_low) {
      _used_low = _used;
    }
  }
  
  ZPage* ZPageAllocator::create_page(uint8_t type, size_t size) {
    // Allocate virtual memory
    const ZVirtualMemory vmem = _virtual.alloc(size);
    if (vmem.is_null()) {
      // Out of address space
      return NULL;
    }
  
<span class="line-added">+   // Allocate physical memory</span>
<span class="line-added">+   const ZPhysicalMemory pmem = _physical.alloc(size);</span>
<span class="line-added">+   assert(!pmem.is_null(), &quot;Invalid size&quot;);</span>
<span class="line-added">+ </span>
    // Allocate page
    return new ZPage(type, vmem, pmem);
  }
  
<span class="line-modified">! void ZPageAllocator::destroy_page(ZPage* page) {</span>
<span class="line-modified">!   const ZVirtualMemory&amp; vmem = page-&gt;virtual_memory();</span>
<span class="line-modified">!   const ZPhysicalMemory&amp; pmem = page-&gt;physical_memory();</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Unmap memory</span>
<span class="line-added">+   _physical.unmap(pmem, vmem.start());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Free physical memory</span>
<span class="line-added">+   _physical.free(pmem);</span>
  
<span class="line-modified">!   // Free virtual memory</span>
<span class="line-modified">!   _virtual.free(vmem);</span>
  
<span class="line-modified">!   // Delete page safely</span>
<span class="line-added">+   _safe_delete(page);</span>
  }
  
<span class="line-modified">! void ZPageAllocator::map_page(const ZPage* page) const {</span>
    // Map physical memory
    _physical.map(page-&gt;physical_memory(), page-&gt;start());
  }
  
<span class="line-modified">! size_t ZPageAllocator::max_available(bool no_reserve) const {</span>
<span class="line-modified">!   size_t available = _current_max_capacity - _used;</span>
  
<span class="line-modified">!   if (no_reserve) {</span>
<span class="line-modified">!     // The reserve should not be considered available</span>
<span class="line-modified">!     available -= MIN2(available, _max_reserve);</span>
    }
  
<span class="line-modified">!   return available;</span>
  }
  
<span class="line-modified">! bool ZPageAllocator::ensure_available(size_t size, bool no_reserve) {</span>
<span class="line-modified">!   if (max_available(no_reserve) &lt; size) {</span>
<span class="line-modified">!     // Not enough free memory</span>
<span class="line-modified">!     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // We add the max_reserve to the requested size to avoid losing</span>
<span class="line-added">+   // the reserve because of failure to increase capacity before</span>
<span class="line-added">+   // reaching max capacity.</span>
<span class="line-added">+   size += _max_reserve;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Don&#39;t try to increase capacity if enough unused capacity</span>
<span class="line-added">+   // is available or if current max capacity has been reached.</span>
<span class="line-added">+   const size_t available = _capacity - _used;</span>
<span class="line-added">+   if (available &lt; size &amp;&amp; _capacity &lt; _current_max_capacity) {</span>
<span class="line-added">+     // Try to increase capacity</span>
<span class="line-added">+     const size_t commit = MIN2(size - available, _current_max_capacity - _capacity);</span>
<span class="line-added">+     const size_t committed = _physical.commit(commit);</span>
<span class="line-added">+     _capacity += committed;</span>
<span class="line-added">+ </span>
<span class="line-added">+     log_trace(gc, heap)(&quot;Make Available: Size: &quot; SIZE_FORMAT &quot;M, NoReserve: %s, &quot;</span>
<span class="line-added">+                         &quot;Available: &quot; SIZE_FORMAT &quot;M, Commit: &quot; SIZE_FORMAT &quot;M, &quot;</span>
<span class="line-added">+                         &quot;Committed: &quot; SIZE_FORMAT &quot;M, Capacity: &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-added">+                         size / M, no_reserve ? &quot;True&quot; : &quot;False&quot;, available / M,</span>
<span class="line-added">+                         commit / M, committed / M, _capacity / M);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (committed != commit) {</span>
<span class="line-added">+       // Failed, or partly failed, to increase capacity. Adjust current</span>
<span class="line-added">+       // max capacity to avoid further attempts to increase capacity.</span>
<span class="line-added">+       log_error(gc)(&quot;Forced to lower max Java heap size from &quot;</span>
<span class="line-added">+                     SIZE_FORMAT &quot;M(%.0f%%) to &quot; SIZE_FORMAT &quot;M(%.0f%%)&quot;,</span>
<span class="line-added">+                     _current_max_capacity / M, percent_of(_current_max_capacity, _max_capacity),</span>
<span class="line-added">+                     _capacity / M, percent_of(_capacity, _max_capacity));</span>
<span class="line-added">+ </span>
<span class="line-added">+       _current_max_capacity = _capacity;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   if (!no_reserve) {</span>
<span class="line-modified">!     size -= _max_reserve;</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   const size_t new_available = _capacity - _used;</span>
<span class="line-added">+   return new_available &gt;= size;</span>
  }
  
<span class="line-modified">! void ZPageAllocator::ensure_uncached_available(size_t size) {</span>
<span class="line-modified">!   assert(_capacity - _used &gt;= size, &quot;Invalid size&quot;);</span>
<span class="line-modified">!   const size_t uncached_available = _capacity - _used - _cache.available();</span>
<span class="line-added">+   if (size &gt; uncached_available) {</span>
<span class="line-added">+     flush_cache_for_allocation(size - uncached_available);</span>
    }
  }
  
<span class="line-modified">! ZPage* ZPageAllocator::alloc_page_common_inner(uint8_t type, size_t size, bool no_reserve) {</span>
<span class="line-modified">!   if (!ensure_available(size, no_reserve)) {</span>
      // Not enough free memory
      return NULL;
    }
  
<span class="line-modified">!   // Try allocate page from the cache</span>
<span class="line-modified">!   ZPage* const page = _cache.alloc_page(type, size);</span>
<span class="line-modified">!   if (page != NULL) {</span>
<span class="line-modified">!     return page;</span>
    }
  
<span class="line-modified">!   // Try flush pages from the cache</span>
<span class="line-modified">!   ensure_uncached_available(size);</span>
  
<span class="line-modified">!   // Create new page</span>
    return create_page(type, size);
  }
  
  ZPage* ZPageAllocator::alloc_page_common(uint8_t type, size_t size, ZAllocationFlags flags) {
<span class="line-modified">!   ZPage* const page = alloc_page_common_inner(type, size, flags.no_reserve());</span>
    if (page == NULL) {
      // Out of memory
      return NULL;
    }
  
    // Update used statistics
    increase_used(size, flags.relocation());
  
    // Send trace event
<span class="line-modified">!   ZTracer::tracer()-&gt;report_page_alloc(size, _used, max_available(flags.no_reserve()), _cache.available(), flags);</span>
  
    return page;
  }
  
<span class="line-added">+ void ZPageAllocator::check_out_of_memory_during_initialization() {</span>
<span class="line-added">+   if (!is_init_completed()) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;, &quot;Java heap too small&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ZPage* ZPageAllocator::alloc_page_blocking(uint8_t type, size_t size, ZAllocationFlags flags) {
    // Prepare to block
    ZPageAllocRequest request(type, size, flags, ZCollectedHeap::heap()-&gt;total_collections());
  
    _lock.lock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,18 ***</span>
        // Wait for allocation to complete or fail
        page = request.wait();
      } while (page == gc_marker);
  
      {
<span class="line-modified">!       // Guard deletion of underlying semaphore. This is a workaround for a</span>
<span class="line-modified">!       // bug in sem_post() in glibc &lt; 2.21, where it&#39;s not safe to destroy</span>
        // the semaphore immediately after returning from sem_wait(). The
        // reason is that sem_post() can touch the semaphore after a waiting
        // thread have returned from sem_wait(). To avoid this race we are
        // forcing the waiting thread to acquire/release the lock held by the
        // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
        ZLocker&lt;ZLock&gt; locker(&amp;_lock);
      }
    }
  
    return page;
  }
<span class="line-new-header">--- 472,25 ---</span>
        // Wait for allocation to complete or fail
        page = request.wait();
      } while (page == gc_marker);
  
      {
<span class="line-modified">!       //</span>
<span class="line-modified">!       // We grab the lock here for two different reasons:</span>
<span class="line-added">+       //</span>
<span class="line-added">+       // 1) Guard deletion of underlying semaphore. This is a workaround for</span>
<span class="line-added">+       // a bug in sem_post() in glibc &lt; 2.21, where it&#39;s not safe to destroy</span>
        // the semaphore immediately after returning from sem_wait(). The
        // reason is that sem_post() can touch the semaphore after a waiting
        // thread have returned from sem_wait(). To avoid this race we are
        // forcing the waiting thread to acquire/release the lock held by the
        // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<span class="line-added">+       //</span>
<span class="line-added">+       // 2) Guard the list of satisfied pages.</span>
<span class="line-added">+       //</span>
        ZLocker&lt;ZLock&gt; locker(&amp;_lock);
<span class="line-added">+       _satisfied.remove(&amp;request);</span>
      }
    }
  
    return page;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,59 ***</span>
  
      // Allocation succeeded, dequeue and satisfy request. Note that
      // the dequeue operation must happen first, since the request
      // will immediately be deallocated once it has been satisfied.
      _queue.remove(request);
      request-&gt;satisfy(page);
    }
  }
  
<span class="line-modified">! void ZPageAllocator::detach_memory(const ZVirtualMemory&amp; vmem, ZPhysicalMemory&amp; pmem) {</span>
<span class="line-modified">!   const uintptr_t addr = vmem.start();</span>
  
<span class="line-modified">!   // Unmap physical memory</span>
<span class="line-modified">!   _physical.unmap(pmem, addr);</span>
  
<span class="line-modified">!   // Free physical memory</span>
<span class="line-modified">!   _physical.free(pmem);</span>
  
<span class="line-modified">!   // Clear physical mapping</span>
<span class="line-modified">!   pmem.clear();</span>
  }
  
<span class="line-modified">! void ZPageAllocator::flip_page(ZPage* page) {</span>
<span class="line-modified">!   const ZPhysicalMemory&amp; pmem = page-&gt;physical_memory();</span>
<span class="line-modified">!   const uintptr_t addr = page-&gt;start();</span>
  
<span class="line-modified">!   // Flip physical mapping</span>
<span class="line-modified">!   _physical.flip(pmem, addr);</span>
  }
  
<span class="line-modified">! void ZPageAllocator::flip_pre_mapped() {</span>
<span class="line-modified">!   if (_pre_mapped.available() == 0) {</span>
<span class="line-modified">!     // Nothing to flip</span>
<span class="line-modified">!     return;</span>
    }
  
<span class="line-modified">!   const ZPhysicalMemory&amp; pmem = _pre_mapped.physical_memory();</span>
<span class="line-modified">!   const ZVirtualMemory&amp; vmem = _pre_mapped.virtual_memory();</span>
  
<span class="line-modified">!   // Flip physical mapping</span>
<span class="line-modified">!   _physical.flip(pmem, vmem.start());</span>
  }
  
<span class="line-modified">! void ZPageAllocator::free_page(ZPage* page, bool reclaimed) {</span>
<span class="line-modified">!   ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
  
<span class="line-modified">!   // Update used statistics</span>
<span class="line-modified">!   decrease_used(page-&gt;size(), reclaimed);</span>
  
<span class="line-modified">!   // Cache page</span>
<span class="line-modified">!   _cache.free_page(page);</span>
  
<span class="line-modified">!   // Try satisfy blocked allocations</span>
<span class="line-modified">!   satisfy_alloc_queue();</span>
  }
  
  bool ZPageAllocator::is_alloc_stalled() const {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
    return !_queue.is_empty();
<span class="line-new-header">--- 548,212 ---</span>
  
      // Allocation succeeded, dequeue and satisfy request. Note that
      // the dequeue operation must happen first, since the request
      // will immediately be deallocated once it has been satisfied.
      _queue.remove(request);
<span class="line-added">+     _satisfied.insert_first(request);</span>
      request-&gt;satisfy(page);
    }
  }
  
<span class="line-modified">! void ZPageAllocator::free_page(ZPage* page, bool reclaimed) {</span>
<span class="line-modified">!   ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
  
<span class="line-modified">!   // Update used statistics</span>
<span class="line-modified">!   decrease_used(page-&gt;size(), reclaimed);</span>
  
<span class="line-modified">!   // Set time when last used</span>
<span class="line-modified">!   page-&gt;set_last_used();</span>
  
<span class="line-modified">!   // Cache page</span>
<span class="line-modified">!   _cache.free_page(page);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Try satisfy blocked allocations</span>
<span class="line-added">+   satisfy_alloc_queue();</span>
  }
  
<span class="line-modified">! size_t ZPageAllocator::flush_cache(ZPageCacheFlushClosure* cl) {</span>
<span class="line-modified">!   ZList&lt;ZPage&gt; list;</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Flush pages</span>
<span class="line-added">+   _cache.flush(cl, &amp;list);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t overflushed = cl-&gt;overflushed();</span>
<span class="line-added">+   if (overflushed &gt; 0) {</span>
<span class="line-added">+     // Overflushed, keep part of last page</span>
<span class="line-added">+     ZPage* const page = list.last()-&gt;split(overflushed);</span>
<span class="line-added">+     _cache.free_page(page);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // Destroy pages</span>
<span class="line-modified">!   size_t flushed = 0;</span>
<span class="line-added">+   for (ZPage* page = list.remove_first(); page != NULL; page = list.remove_first()) {</span>
<span class="line-added">+     flushed += page-&gt;size();</span>
<span class="line-added">+     destroy_page(page);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return flushed;</span>
  }
  
<span class="line-modified">! class ZPageCacheFlushForAllocationClosure : public ZPageCacheFlushClosure {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!   ZPageCacheFlushForAllocationClosure(size_t requested) :</span>
<span class="line-modified">!       ZPageCacheFlushClosure(requested) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual bool do_page(const ZPage* page) {</span>
<span class="line-added">+     if (_flushed &lt; _requested) {</span>
<span class="line-added">+       // Flush page</span>
<span class="line-added">+       _flushed += page-&gt;size();</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Don&#39;t flush page</span>
<span class="line-added">+     return false;</span>
    }
<span class="line-added">+ };</span>
  
<span class="line-modified">! void ZPageAllocator::flush_cache_for_allocation(size_t requested) {</span>
<span class="line-modified">!   assert(requested &lt;= _cache.available(), &quot;Invalid request&quot;);</span>
  
<span class="line-modified">!   // Flush pages</span>
<span class="line-modified">!   ZPageCacheFlushForAllocationClosure cl(requested);</span>
<span class="line-added">+   const size_t flushed = flush_cache(&amp;cl);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(requested == flushed, &quot;Failed to flush&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t cached_after = _cache.available();</span>
<span class="line-added">+   const size_t cached_before = cached_after + flushed;</span>
<span class="line-added">+ </span>
<span class="line-added">+   log_info(gc, heap)(&quot;Page Cache: &quot; SIZE_FORMAT &quot;M(%.0f%%)-&gt;&quot; SIZE_FORMAT &quot;M(%.0f%%), &quot;</span>
<span class="line-added">+                      &quot;Flushed: &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-added">+                      cached_before / M, percent_of(cached_before, max_capacity()),</span>
<span class="line-added">+                      cached_after / M, percent_of(cached_after, max_capacity()),</span>
<span class="line-added">+                      flushed / M);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Update statistics</span>
<span class="line-added">+   ZStatInc(ZCounterPageCacheFlush, flushed);</span>
  }
  
<span class="line-modified">! class ZPageCacheFlushForUncommitClosure : public ZPageCacheFlushClosure {</span>
<span class="line-modified">! private:</span>
<span class="line-added">+   const uint64_t _now;</span>
<span class="line-added">+   const uint64_t _delay;</span>
<span class="line-added">+   uint64_t       _timeout;</span>
  
<span class="line-modified">! public:</span>
<span class="line-modified">!   ZPageCacheFlushForUncommitClosure(size_t requested, uint64_t delay) :</span>
<span class="line-added">+       ZPageCacheFlushClosure(requested),</span>
<span class="line-added">+       _now(os::elapsedTime()),</span>
<span class="line-added">+       _delay(delay),</span>
<span class="line-added">+       _timeout(_delay) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual bool do_page(const ZPage* page) {</span>
<span class="line-added">+     const uint64_t expires = page-&gt;last_used() + _delay;</span>
<span class="line-added">+     const uint64_t timeout = expires - MIN2(expires, _now);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (_flushed &lt; _requested &amp;&amp; timeout == 0) {</span>
<span class="line-added">+       // Flush page</span>
<span class="line-added">+       _flushed += page-&gt;size();</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     // Record shortest non-expired timeout</span>
<span class="line-modified">!     _timeout = MIN2(_timeout, timeout);</span>
  
<span class="line-modified">!     // Don&#39;t flush page</span>
<span class="line-modified">!     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint64_t timeout() const {</span>
<span class="line-added">+     return _timeout;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ uint64_t ZPageAllocator::uncommit(uint64_t delay) {</span>
<span class="line-added">+   // Set the default timeout, when no pages are found in the</span>
<span class="line-added">+   // cache or when uncommit is disabled, equal to the delay.</span>
<span class="line-added">+   uint64_t timeout = delay;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!_uncommit) {</span>
<span class="line-added">+     // Disabled</span>
<span class="line-added">+     return timeout;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t capacity_before;</span>
<span class="line-added">+   size_t capacity_after;</span>
<span class="line-added">+   size_t uncommitted;</span>
<span class="line-added">+ </span>
<span class="line-added">+   {</span>
<span class="line-added">+     SuspendibleThreadSetJoiner joiner;</span>
<span class="line-added">+     ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Don&#39;t flush more than we will uncommit. Never uncommit</span>
<span class="line-added">+     // the reserve, and never uncommit below min capacity.</span>
<span class="line-added">+     const size_t needed = MIN2(_used + _max_reserve, _current_max_capacity);</span>
<span class="line-added">+     const size_t guarded = MAX2(needed, _min_capacity);</span>
<span class="line-added">+     const size_t uncommittable = _capacity - guarded;</span>
<span class="line-added">+     const size_t uncached_available = _capacity - _used - _cache.available();</span>
<span class="line-added">+     size_t uncommit = MIN2(uncommittable, uncached_available);</span>
<span class="line-added">+     const size_t flush = uncommittable - uncommit;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (flush &gt; 0) {</span>
<span class="line-added">+       // Flush pages to uncommit</span>
<span class="line-added">+       ZPageCacheFlushForUncommitClosure cl(flush, delay);</span>
<span class="line-added">+       uncommit += flush_cache(&amp;cl);</span>
<span class="line-added">+       timeout = cl.timeout();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Uncommit</span>
<span class="line-added">+     uncommitted = _physical.uncommit(uncommit);</span>
<span class="line-added">+     _capacity -= uncommitted;</span>
<span class="line-added">+ </span>
<span class="line-added">+     capacity_after = _capacity;</span>
<span class="line-added">+     capacity_before = capacity_after + uncommitted;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (uncommitted &gt; 0) {</span>
<span class="line-added">+     log_info(gc, heap)(&quot;Capacity: &quot; SIZE_FORMAT &quot;M(%.0f%%)-&gt;&quot; SIZE_FORMAT &quot;M(%.0f%%), &quot;</span>
<span class="line-added">+                        &quot;Uncommitted: &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-added">+                        capacity_before / M, percent_of(capacity_before, max_capacity()),</span>
<span class="line-added">+                        capacity_after / M, percent_of(capacity_after, max_capacity()),</span>
<span class="line-added">+                        uncommitted / M);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Update statistics</span>
<span class="line-added">+     ZStatInc(ZCounterUncommit, uncommitted);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return timeout;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::enable_deferred_delete() const {</span>
<span class="line-added">+   _safe_delete.enable_deferred_delete();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::disable_deferred_delete() const {</span>
<span class="line-added">+   _safe_delete.disable_deferred_delete();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::debug_map_page(const ZPage* page) const {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-added">+   _physical.debug_map(page-&gt;physical_memory(), page-&gt;start());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::debug_unmap_page(const ZPage* page) const {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-added">+   _physical.debug_unmap(page-&gt;physical_memory(), page-&gt;start());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZPageAllocator::pages_do(ZPageClosure* cl) const {</span>
<span class="line-added">+   ZListIterator&lt;ZPageAllocRequest&gt; iter(&amp;_satisfied);</span>
<span class="line-added">+   for (ZPageAllocRequest* request; iter.next(&amp;request);) {</span>
<span class="line-added">+     const ZPage* const page = request-&gt;peek();</span>
<span class="line-added">+     if (page != NULL) {</span>
<span class="line-added">+       cl-&gt;do_page(page);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   _cache.pages_do(cl);</span>
  }
  
  bool ZPageAllocator::is_alloc_stalled() const {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
    return !_queue.is_empty();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 505,9 ***</span>
        request-&gt;satisfy(gc_marker);
        return;
      }
  
      // Out of memory, fail allocation request
<span class="line-modified">!     _queue.remove_first();</span>
      request-&gt;satisfy(NULL);
    }
  }
<span class="line-new-header">--- 770,10 ---</span>
        request-&gt;satisfy(gc_marker);
        return;
      }
  
      // Out of memory, fail allocation request
<span class="line-modified">!     _queue.remove(request);</span>
<span class="line-added">+     _satisfied.insert_first(request);</span>
      request-&gt;satisfy(NULL);
    }
  }
</pre>
<center><a href="zPage.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
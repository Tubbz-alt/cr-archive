<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zPage.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zPage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zPage.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZPAGE_INLINE_HPP
 25 #define SHARE_GC_Z_ZPAGE_INLINE_HPP
 26 
 27 #include &quot;gc/z/zAddress.inline.hpp&quot;
<span class="line-removed"> 28 #include &quot;gc/z/zForwardingTable.inline.hpp&quot;</span>
 29 #include &quot;gc/z/zGlobals.hpp&quot;
 30 #include &quot;gc/z/zLiveMap.inline.hpp&quot;
 31 #include &quot;gc/z/zMark.hpp&quot;
 32 #include &quot;gc/z/zNUMA.hpp&quot;
 33 #include &quot;gc/z/zPage.hpp&quot;
 34 #include &quot;gc/z/zPhysicalMemory.inline.hpp&quot;
 35 #include &quot;gc/z/zVirtualMemory.inline.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;runtime/atomic.hpp&quot;

 38 #include &quot;utilities/align.hpp&quot;
 39 #include &quot;utilities/debug.hpp&quot;
 40 










 41 inline const char* ZPage::type_to_string() const {
 42   switch (type()) {
 43   case ZPageTypeSmall:
 44     return &quot;Small&quot;;
 45 
 46   case ZPageTypeMedium:
 47     return &quot;Medium&quot;;
 48 
 49   default:
 50     assert(type() == ZPageTypeLarge, &quot;Invalid page type&quot;);
 51     return &quot;Large&quot;;
 52   }
 53 }
 54 
 55 inline uint32_t ZPage::object_max_count() const {
 56   switch (type()) {
 57   case ZPageTypeLarge:
 58     // A large page can only contain a single
 59     // object aligned to the start of the page.
 60     return 1;
</pre>
<hr />
<pre>
 99 inline uintptr_t ZPage::start() const {
100   return _virtual.start();
101 }
102 
103 inline uintptr_t ZPage::end() const {
104   return _virtual.end();
105 }
106 
107 inline size_t ZPage::size() const {
108   return _virtual.size();
109 }
110 
111 inline uintptr_t ZPage::top() const {
112   return _top;
113 }
114 
115 inline size_t ZPage::remaining() const {
116   return end() - top();
117 }
118 
<span class="line-modified">119 inline ZPhysicalMemory&amp; ZPage::physical_memory() {</span>
120   return _physical;
121 }
122 
123 inline const ZVirtualMemory&amp; ZPage::virtual_memory() const {
124   return _virtual;
125 }
126 
127 inline uint8_t ZPage::numa_id() {
128   if (_numa_id == (uint8_t)-1) {
<span class="line-modified">129     _numa_id = (uint8_t)ZNUMA::memory_id(ZAddress::good(start()));</span>
130   }
131 
132   return _numa_id;
133 }
134 
<span class="line-removed">135 inline bool ZPage::inc_refcount() {</span>
<span class="line-removed">136   for (uint32_t prev_refcount = _refcount; prev_refcount &gt; 0; prev_refcount = _refcount) {</span>
<span class="line-removed">137     if (Atomic::cmpxchg(prev_refcount + 1, &amp;_refcount, prev_refcount) == prev_refcount) {</span>
<span class="line-removed">138       return true;</span>
<span class="line-removed">139     }</span>
<span class="line-removed">140   }</span>
<span class="line-removed">141   return false;</span>
<span class="line-removed">142 }</span>
<span class="line-removed">143 </span>
<span class="line-removed">144 inline bool ZPage::dec_refcount() {</span>
<span class="line-removed">145   assert(is_active(), &quot;Should be active&quot;);</span>
<span class="line-removed">146   return Atomic::sub(1u, &amp;_refcount) == 0;</span>
<span class="line-removed">147 }</span>
<span class="line-removed">148 </span>
<span class="line-removed">149 inline bool ZPage::is_in(uintptr_t addr) const {</span>
<span class="line-removed">150   const uintptr_t offset = ZAddress::offset(addr);</span>
<span class="line-removed">151   return offset &gt;= start() &amp;&amp; offset &lt; top();</span>
<span class="line-removed">152 }</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 inline uintptr_t ZPage::block_start(uintptr_t addr) const {</span>
<span class="line-removed">155   if (block_is_obj(addr)) {</span>
<span class="line-removed">156     return addr;</span>
<span class="line-removed">157   } else {</span>
<span class="line-removed">158     return ZAddress::good(top());</span>
<span class="line-removed">159   }</span>
<span class="line-removed">160 }</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 inline bool ZPage::block_is_obj(uintptr_t addr) const {</span>
<span class="line-removed">163   return ZAddress::offset(addr) &lt; top();</span>
<span class="line-removed">164 }</span>
<span class="line-removed">165 </span>
<span class="line-removed">166 inline bool ZPage::is_active() const {</span>
<span class="line-removed">167   return _refcount &gt; 0;</span>
<span class="line-removed">168 }</span>
<span class="line-removed">169 </span>
170 inline bool ZPage::is_allocating() const {
<span class="line-modified">171   return is_active() &amp;&amp; _seqnum == ZGlobalSeqNum;</span>
172 }
173 
174 inline bool ZPage::is_relocatable() const {
<span class="line-modified">175   return is_active() &amp;&amp; _seqnum &lt; ZGlobalSeqNum;</span>
<span class="line-removed">176 }</span>
<span class="line-removed">177 </span>
<span class="line-removed">178 inline bool ZPage::is_detached() const {</span>
<span class="line-removed">179   return _physical.is_null();</span>
180 }
181 
182 inline bool ZPage::is_mapped() const {
183   return _seqnum &gt; 0;
184 }
185 
186 inline void ZPage::set_pre_mapped() {
187   // The _seqnum variable is also used to signal that the virtual and physical
188   // memory has been mapped. So, we need to set it to non-zero when the memory
189   // has been pre-mapped.
190   _seqnum = 1;
191 }
192 
<span class="line-modified">193 inline bool ZPage::is_pinned() const {</span>
<span class="line-modified">194   return _pinned;</span>
<span class="line-removed">195 }</span>
<span class="line-removed">196 </span>
<span class="line-removed">197 inline void ZPage::set_pinned() {</span>
<span class="line-removed">198   _pinned = 1;</span>
199 }
200 
<span class="line-modified">201 inline bool ZPage::is_forwarding() const {</span>
<span class="line-modified">202   return !_forwarding.is_null();</span>
203 }
204 
<span class="line-modified">205 inline void ZPage::set_forwarding() {</span>
<span class="line-modified">206   assert(is_marked(), &quot;Should be marked&quot;);</span>
<span class="line-modified">207   _forwarding.setup(_livemap.live_objects());</span>
<span class="line-removed">208 }</span>
<span class="line-removed">209 </span>
<span class="line-removed">210 inline void ZPage::reset_forwarding() {</span>
<span class="line-removed">211   _forwarding.reset();</span>
<span class="line-removed">212   _pinned = 0;</span>
<span class="line-removed">213 }</span>
<span class="line-removed">214 </span>
<span class="line-removed">215 inline void ZPage::verify_forwarding() const {</span>
<span class="line-removed">216   _forwarding.verify(object_max_count(), _livemap.live_objects());</span>
217 }
218 
219 inline bool ZPage::is_marked() const {
220   assert(is_relocatable(), &quot;Invalid page state&quot;);
221   return _livemap.is_marked();
222 }
223 
224 inline bool ZPage::is_object_marked(uintptr_t addr) const {
225   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
226   return _livemap.get(index);
227 }
228 
229 inline bool ZPage::is_object_strongly_marked(uintptr_t addr) const {
230   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
231   return _livemap.get(index + 1);
232 }
233 
234 inline bool ZPage::is_object_live(uintptr_t addr) const {
235   return is_allocating() || is_object_marked(addr);
236 }
237 
238 inline bool ZPage::is_object_strongly_live(uintptr_t addr) const {
239   return is_allocating() || is_object_strongly_marked(addr);
240 }
241 
242 inline bool ZPage::mark_object(uintptr_t addr, bool finalizable, bool&amp; inc_live) {
243   assert(ZAddress::is_marked(addr), &quot;Invalid address&quot;);
244   assert(is_relocatable(), &quot;Invalid page state&quot;);
245   assert(is_in(addr), &quot;Invalid address&quot;);
246 
247   // Set mark bit
248   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
<span class="line-modified">249   return _livemap.set_atomic(index, finalizable, inc_live);</span>




250 }
251 
<span class="line-modified">252 inline void ZPage::inc_live_atomic(uint32_t objects, size_t bytes) {</span>
<span class="line-modified">253   _livemap.inc_live_atomic(objects, bytes);</span>

254 }
255 
256 inline size_t ZPage::live_bytes() const {
257   assert(is_marked(), &quot;Should be marked&quot;);
258   return _livemap.live_bytes();
259 }
260 
261 inline void ZPage::object_iterate(ObjectClosure* cl) {
262   _livemap.iterate(cl, ZAddress::good(start()), object_alignment_shift());
263 }
264 
265 inline uintptr_t ZPage::alloc_object(size_t size) {
266   assert(is_allocating(), &quot;Invalid state&quot;);
267 
268   const size_t aligned_size = align_up(size, object_alignment());
269   const uintptr_t addr = top();
270   const uintptr_t new_top = addr + aligned_size;
271 
272   if (new_top &gt; end()) {
273     // Not enough space left
</pre>
<hr />
<pre>
275   }
276 
277   _top = new_top;
278 
279   return ZAddress::good(addr);
280 }
281 
282 inline uintptr_t ZPage::alloc_object_atomic(size_t size) {
283   assert(is_allocating(), &quot;Invalid state&quot;);
284 
285   const size_t aligned_size = align_up(size, object_alignment());
286   uintptr_t addr = top();
287 
288   for (;;) {
289     const uintptr_t new_top = addr + aligned_size;
290     if (new_top &gt; end()) {
291       // Not enough space left
292       return 0;
293     }
294 
<span class="line-modified">295     const uintptr_t prev_top = Atomic::cmpxchg(new_top, &amp;_top, addr);</span>
296     if (prev_top == addr) {
297       // Success
298       return ZAddress::good(addr);
299     }
300 
301     // Retry
302     addr = prev_top;
303   }
304 }
305 
306 inline bool ZPage::undo_alloc_object(uintptr_t addr, size_t size) {
307   assert(is_allocating(), &quot;Invalid state&quot;);
308 
309   const uintptr_t offset = ZAddress::offset(addr);
310   const size_t aligned_size = align_up(size, object_alignment());
311   const uintptr_t old_top = top();
312   const uintptr_t new_top = old_top - aligned_size;
313 
314   if (new_top != offset) {
315     // Failed to undo allocation, not the last allocated object
</pre>
<hr />
<pre>
319   _top = new_top;
320 
321   // Success
322   return true;
323 }
324 
325 inline bool ZPage::undo_alloc_object_atomic(uintptr_t addr, size_t size) {
326   assert(is_allocating(), &quot;Invalid state&quot;);
327 
328   const uintptr_t offset = ZAddress::offset(addr);
329   const size_t aligned_size = align_up(size, object_alignment());
330   uintptr_t old_top = top();
331 
332   for (;;) {
333     const uintptr_t new_top = old_top - aligned_size;
334     if (new_top != offset) {
335       // Failed to undo allocation, not the last allocated object
336       return false;
337     }
338 
<span class="line-modified">339     const uintptr_t prev_top = Atomic::cmpxchg(new_top, &amp;_top, old_top);</span>
340     if (prev_top == old_top) {
341       // Success
342       return true;
343     }
344 
345     // Retry
346     old_top = prev_top;
347   }
348 }
349 
350 #endif // SHARE_GC_Z_ZPAGE_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZPAGE_INLINE_HPP
 25 #define SHARE_GC_Z_ZPAGE_INLINE_HPP
 26 
 27 #include &quot;gc/z/zAddress.inline.hpp&quot;

 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zLiveMap.inline.hpp&quot;
 30 #include &quot;gc/z/zMark.hpp&quot;
 31 #include &quot;gc/z/zNUMA.hpp&quot;
 32 #include &quot;gc/z/zPage.hpp&quot;
 33 #include &quot;gc/z/zPhysicalMemory.inline.hpp&quot;
 34 #include &quot;gc/z/zVirtualMemory.inline.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/atomic.hpp&quot;
<span class="line-added"> 37 #include &quot;runtime/os.hpp&quot;</span>
 38 #include &quot;utilities/align.hpp&quot;
 39 #include &quot;utilities/debug.hpp&quot;
 40 
<span class="line-added"> 41 inline uint8_t ZPage::type_from_size(size_t size) const {</span>
<span class="line-added"> 42   if (size == ZPageSizeSmall) {</span>
<span class="line-added"> 43     return ZPageTypeSmall;</span>
<span class="line-added"> 44   } else if (size == ZPageSizeMedium) {</span>
<span class="line-added"> 45     return ZPageTypeMedium;</span>
<span class="line-added"> 46   } else {</span>
<span class="line-added"> 47     return ZPageTypeLarge;</span>
<span class="line-added"> 48   }</span>
<span class="line-added"> 49 }</span>
<span class="line-added"> 50 </span>
 51 inline const char* ZPage::type_to_string() const {
 52   switch (type()) {
 53   case ZPageTypeSmall:
 54     return &quot;Small&quot;;
 55 
 56   case ZPageTypeMedium:
 57     return &quot;Medium&quot;;
 58 
 59   default:
 60     assert(type() == ZPageTypeLarge, &quot;Invalid page type&quot;);
 61     return &quot;Large&quot;;
 62   }
 63 }
 64 
 65 inline uint32_t ZPage::object_max_count() const {
 66   switch (type()) {
 67   case ZPageTypeLarge:
 68     // A large page can only contain a single
 69     // object aligned to the start of the page.
 70     return 1;
</pre>
<hr />
<pre>
109 inline uintptr_t ZPage::start() const {
110   return _virtual.start();
111 }
112 
113 inline uintptr_t ZPage::end() const {
114   return _virtual.end();
115 }
116 
117 inline size_t ZPage::size() const {
118   return _virtual.size();
119 }
120 
121 inline uintptr_t ZPage::top() const {
122   return _top;
123 }
124 
125 inline size_t ZPage::remaining() const {
126   return end() - top();
127 }
128 
<span class="line-modified">129 inline const ZPhysicalMemory&amp; ZPage::physical_memory() const {</span>
130   return _physical;
131 }
132 
133 inline const ZVirtualMemory&amp; ZPage::virtual_memory() const {
134   return _virtual;
135 }
136 
137 inline uint8_t ZPage::numa_id() {
138   if (_numa_id == (uint8_t)-1) {
<span class="line-modified">139     _numa_id = ZNUMA::memory_id(ZAddress::good(start()));</span>
140   }
141 
142   return _numa_id;
143 }
144 



































145 inline bool ZPage::is_allocating() const {
<span class="line-modified">146   return _seqnum == ZGlobalSeqNum;</span>
147 }
148 
149 inline bool ZPage::is_relocatable() const {
<span class="line-modified">150   return _seqnum &lt; ZGlobalSeqNum;</span>




151 }
152 
153 inline bool ZPage::is_mapped() const {
154   return _seqnum &gt; 0;
155 }
156 
157 inline void ZPage::set_pre_mapped() {
158   // The _seqnum variable is also used to signal that the virtual and physical
159   // memory has been mapped. So, we need to set it to non-zero when the memory
160   // has been pre-mapped.
161   _seqnum = 1;
162 }
163 
<span class="line-modified">164 inline uint64_t ZPage::last_used() const {</span>
<span class="line-modified">165   return _last_used;</span>




166 }
167 
<span class="line-modified">168 inline void ZPage::set_last_used() {</span>
<span class="line-modified">169   _last_used = os::elapsedTime();</span>
170 }
171 
<span class="line-modified">172 inline bool ZPage::is_in(uintptr_t addr) const {</span>
<span class="line-modified">173   const uintptr_t offset = ZAddress::offset(addr);</span>
<span class="line-modified">174   return offset &gt;= start() &amp;&amp; offset &lt; top();</span>









175 }
176 
177 inline bool ZPage::is_marked() const {
178   assert(is_relocatable(), &quot;Invalid page state&quot;);
179   return _livemap.is_marked();
180 }
181 
182 inline bool ZPage::is_object_marked(uintptr_t addr) const {
183   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
184   return _livemap.get(index);
185 }
186 
187 inline bool ZPage::is_object_strongly_marked(uintptr_t addr) const {
188   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
189   return _livemap.get(index + 1);
190 }
191 
192 inline bool ZPage::is_object_live(uintptr_t addr) const {
193   return is_allocating() || is_object_marked(addr);
194 }
195 
196 inline bool ZPage::is_object_strongly_live(uintptr_t addr) const {
197   return is_allocating() || is_object_strongly_marked(addr);
198 }
199 
200 inline bool ZPage::mark_object(uintptr_t addr, bool finalizable, bool&amp; inc_live) {
201   assert(ZAddress::is_marked(addr), &quot;Invalid address&quot;);
202   assert(is_relocatable(), &quot;Invalid page state&quot;);
203   assert(is_in(addr), &quot;Invalid address&quot;);
204 
205   // Set mark bit
206   const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
<span class="line-modified">207   return _livemap.set(index, finalizable, inc_live);</span>
<span class="line-added">208 }</span>
<span class="line-added">209 </span>
<span class="line-added">210 inline void ZPage::inc_live(uint32_t objects, size_t bytes) {</span>
<span class="line-added">211   _livemap.inc_live(objects, bytes);</span>
212 }
213 
<span class="line-modified">214 inline uint32_t ZPage::live_objects() const {</span>
<span class="line-modified">215   assert(is_marked(), &quot;Should be marked&quot;);</span>
<span class="line-added">216   return _livemap.live_objects();</span>
217 }
218 
219 inline size_t ZPage::live_bytes() const {
220   assert(is_marked(), &quot;Should be marked&quot;);
221   return _livemap.live_bytes();
222 }
223 
224 inline void ZPage::object_iterate(ObjectClosure* cl) {
225   _livemap.iterate(cl, ZAddress::good(start()), object_alignment_shift());
226 }
227 
228 inline uintptr_t ZPage::alloc_object(size_t size) {
229   assert(is_allocating(), &quot;Invalid state&quot;);
230 
231   const size_t aligned_size = align_up(size, object_alignment());
232   const uintptr_t addr = top();
233   const uintptr_t new_top = addr + aligned_size;
234 
235   if (new_top &gt; end()) {
236     // Not enough space left
</pre>
<hr />
<pre>
238   }
239 
240   _top = new_top;
241 
242   return ZAddress::good(addr);
243 }
244 
245 inline uintptr_t ZPage::alloc_object_atomic(size_t size) {
246   assert(is_allocating(), &quot;Invalid state&quot;);
247 
248   const size_t aligned_size = align_up(size, object_alignment());
249   uintptr_t addr = top();
250 
251   for (;;) {
252     const uintptr_t new_top = addr + aligned_size;
253     if (new_top &gt; end()) {
254       // Not enough space left
255       return 0;
256     }
257 
<span class="line-modified">258     const uintptr_t prev_top = Atomic::cmpxchg(&amp;_top, addr, new_top);</span>
259     if (prev_top == addr) {
260       // Success
261       return ZAddress::good(addr);
262     }
263 
264     // Retry
265     addr = prev_top;
266   }
267 }
268 
269 inline bool ZPage::undo_alloc_object(uintptr_t addr, size_t size) {
270   assert(is_allocating(), &quot;Invalid state&quot;);
271 
272   const uintptr_t offset = ZAddress::offset(addr);
273   const size_t aligned_size = align_up(size, object_alignment());
274   const uintptr_t old_top = top();
275   const uintptr_t new_top = old_top - aligned_size;
276 
277   if (new_top != offset) {
278     // Failed to undo allocation, not the last allocated object
</pre>
<hr />
<pre>
282   _top = new_top;
283 
284   // Success
285   return true;
286 }
287 
288 inline bool ZPage::undo_alloc_object_atomic(uintptr_t addr, size_t size) {
289   assert(is_allocating(), &quot;Invalid state&quot;);
290 
291   const uintptr_t offset = ZAddress::offset(addr);
292   const size_t aligned_size = align_up(size, object_alignment());
293   uintptr_t old_top = top();
294 
295   for (;;) {
296     const uintptr_t new_top = old_top - aligned_size;
297     if (new_top != offset) {
298       // Failed to undo allocation, not the last allocated object
299       return false;
300     }
301 
<span class="line-modified">302     const uintptr_t prev_top = Atomic::cmpxchg(&amp;_top, old_top, new_top);</span>
303     if (prev_top == old_top) {
304       // Success
305       return true;
306     }
307 
308     // Retry
309     old_top = prev_top;
310   }
311 }
312 
313 #endif // SHARE_GC_Z_ZPAGE_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zPage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
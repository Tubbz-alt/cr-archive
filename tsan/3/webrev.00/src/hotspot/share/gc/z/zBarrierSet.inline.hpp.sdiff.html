<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45   }
 46 }
 47 
 48 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 49 inline oop* ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::field_addr(oop base, ptrdiff_t offset) {
 50   assert(base != NULL, &quot;Invalid base&quot;);
 51   return reinterpret_cast&lt;oop*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + offset);
 52 }
 53 
 54 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 55 template &lt;typename T&gt;
 56 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::load_barrier_on_oop_field_preloaded(T* addr, oop o) {
 57   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
 58 
 59   if (HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 60     if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
 61       return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
 62     } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
 63       return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
 64     } else {

 65       return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
 66     }
 67   } else {
 68     if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
 69       return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
 70     } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
 71       return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
 72     } else {

 73       return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
 74     }
 75   }
 76 }
 77 
 78 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 79 template &lt;typename T&gt;
 80 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::load_barrier_on_unknown_oop_field_preloaded(oop base, ptrdiff_t offset, T* addr, oop o) {
 81   verify_decorators_present&lt;ON_UNKNOWN_OOP_REF&gt;();
 82 
 83   const DecoratorSet decorators_known_strength =
 84     AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset);
 85 
 86   if (HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 87     if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
 88       return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
 89     } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
 90       return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
 91     } else {

 92       return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
 93     }
 94   } else {
 95     if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
 96       return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
 97     } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
 98       return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
 99     } else {

100       return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
101     }
102   }
103 }
104 
105 //
106 // In heap
107 //
108 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
109 template &lt;typename T&gt;
110 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {
111   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
112 
113   const oop o = Raw::oop_load_in_heap(addr);
114   return load_barrier_on_oop_field_preloaded(addr, o);
115 }
116 
117 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
118 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap_at(oop base, ptrdiff_t offset) {
119   oop* const addr = field_addr(base, offset);
120   const oop o = Raw::oop_load_in_heap(addr);
121 
122   if (HasDecorator&lt;decorators, ON_UNKNOWN_OOP_REF&gt;::value) {
123     return load_barrier_on_unknown_oop_field_preloaded(base, offset, addr, o);
124   }
125 
126   return load_barrier_on_oop_field_preloaded(addr, o);
127 }
128 
129 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
130 template &lt;typename T&gt;
<span class="line-modified">131 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
132   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
133   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
134 
135   ZBarrier::load_barrier_on_oop_field(addr);
<span class="line-modified">136   return Raw::oop_atomic_cmpxchg_in_heap(new_value, addr, compare_value);</span>
137 }
138 
139 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">140 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
141   verify_decorators_present&lt;ON_STRONG_OOP_REF | ON_UNKNOWN_OOP_REF&gt;();
142   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
143 
144   // Through Unsafe.CompareAndExchangeObject()/CompareAndSetObject() we can receive
145   // calls with ON_UNKNOWN_OOP_REF set. However, we treat these as ON_STRONG_OOP_REF,
146   // with the motivation that if you&#39;re doing Unsafe operations on a Reference.referent
147   // field, then you&#39;re on your own anyway.
148   ZBarrier::load_barrier_on_oop_field(field_addr(base, offset));
<span class="line-modified">149   return Raw::oop_atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);</span>
150 }
151 
152 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
153 template &lt;typename T&gt;
<span class="line-modified">154 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
155   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
156   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
157 
<span class="line-modified">158   const oop o = Raw::oop_atomic_xchg_in_heap(new_value, addr);</span>
159   return ZBarrier::load_barrier_on_oop(o);
160 }
161 
162 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">163 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {</span>
164   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
165   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
166 
<span class="line-modified">167   const oop o = Raw::oop_atomic_xchg_in_heap_at(new_value, base, offset);</span>
168   return ZBarrier::load_barrier_on_oop(o);
169 }
170 
171 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
172 template &lt;typename T&gt;
173 inline bool ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
174                                                                                        arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
175                                                                                        size_t length) {
176   T* src = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
177   T* dst = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
178 
179   if (!HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value) {
180     // No check cast, bulk barrier and bulk copy
181     ZBarrier::load_barrier_on_oop_array(src, length);
182     return Raw::oop_arraycopy_in_heap(NULL, 0, src, NULL, 0, dst, length);
183   }
184 
185   // Check cast and copy each elements
186   Klass* const dst_klass = objArrayOop(dst_obj)-&gt;element_klass();
187   for (const T* const end = src + length; src &lt; end; src++, dst++) {
</pre>
<hr />
<pre>
201 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
202 inline void ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
203   ZBarrier::load_barrier_on_oop_fields(src);
204   Raw::clone_in_heap(src, dst, size);
205 }
206 
207 //
208 // Not in heap
209 //
210 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
211 template &lt;typename T&gt;
212 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {
213   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
214 
215   const oop o = Raw::oop_load_not_in_heap(addr);
216   return load_barrier_on_oop_field_preloaded(addr, o);
217 }
218 
219 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
220 template &lt;typename T&gt;
<span class="line-modified">221 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(oop new_value, T* addr, oop compare_value) {</span>
222   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
223   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
224 
<span class="line-modified">225   return Raw::oop_atomic_cmpxchg_not_in_heap(new_value, addr, compare_value);</span>
226 }
227 
228 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
229 template &lt;typename T&gt;
<span class="line-modified">230 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(oop new_value, T* addr) {</span>
231   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
232   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
233 
<span class="line-modified">234   return Raw::oop_atomic_xchg_not_in_heap(new_value, addr);</span>
235 }
236 
237 #endif // SHARE_GC_Z_ZBARRIERSET_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 45   }
 46 }
 47 
 48 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 49 inline oop* ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::field_addr(oop base, ptrdiff_t offset) {
 50   assert(base != NULL, &quot;Invalid base&quot;);
 51   return reinterpret_cast&lt;oop*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + offset);
 52 }
 53 
 54 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 55 template &lt;typename T&gt;
 56 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::load_barrier_on_oop_field_preloaded(T* addr, oop o) {
 57   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
 58 
 59   if (HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 60     if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
 61       return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
 62     } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
 63       return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
 64     } else {
<span class="line-added"> 65       assert((HasDecorator&lt;decorators, ON_PHANTOM_OOP_REF&gt;::value), &quot;Must be&quot;);</span>
 66       return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
 67     }
 68   } else {
 69     if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
 70       return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
 71     } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
 72       return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
 73     } else {
<span class="line-added"> 74       assert((HasDecorator&lt;decorators, ON_PHANTOM_OOP_REF&gt;::value), &quot;Must be&quot;);</span>
 75       return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
 76     }
 77   }
 78 }
 79 
 80 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 81 template &lt;typename T&gt;
 82 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::load_barrier_on_unknown_oop_field_preloaded(oop base, ptrdiff_t offset, T* addr, oop o) {
 83   verify_decorators_present&lt;ON_UNKNOWN_OOP_REF&gt;();
 84 
 85   const DecoratorSet decorators_known_strength =
 86     AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset);
 87 
 88   if (HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 89     if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
 90       return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
 91     } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
 92       return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
 93     } else {
<span class="line-added"> 94       assert(decorators_known_strength &amp; ON_PHANTOM_OOP_REF, &quot;Must be&quot;);</span>
 95       return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
 96     }
 97   } else {
 98     if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
 99       return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
100     } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
101       return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
102     } else {
<span class="line-added">103       assert(decorators_known_strength &amp; ON_PHANTOM_OOP_REF, &quot;Must be&quot;);</span>
104       return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
105     }
106   }
107 }
108 
109 //
110 // In heap
111 //
112 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
113 template &lt;typename T&gt;
114 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {
115   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
116 
117   const oop o = Raw::oop_load_in_heap(addr);
118   return load_barrier_on_oop_field_preloaded(addr, o);
119 }
120 
121 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
122 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap_at(oop base, ptrdiff_t offset) {
123   oop* const addr = field_addr(base, offset);
124   const oop o = Raw::oop_load_in_heap(addr);
125 
126   if (HasDecorator&lt;decorators, ON_UNKNOWN_OOP_REF&gt;::value) {
127     return load_barrier_on_unknown_oop_field_preloaded(base, offset, addr, o);
128   }
129 
130   return load_barrier_on_oop_field_preloaded(addr, o);
131 }
132 
133 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
134 template &lt;typename T&gt;
<span class="line-modified">135 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
136   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
137   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
138 
139   ZBarrier::load_barrier_on_oop_field(addr);
<span class="line-modified">140   return Raw::oop_atomic_cmpxchg_in_heap(addr, compare_value, new_value);</span>
141 }
142 
143 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">144 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
145   verify_decorators_present&lt;ON_STRONG_OOP_REF | ON_UNKNOWN_OOP_REF&gt;();
146   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
147 
148   // Through Unsafe.CompareAndExchangeObject()/CompareAndSetObject() we can receive
149   // calls with ON_UNKNOWN_OOP_REF set. However, we treat these as ON_STRONG_OOP_REF,
150   // with the motivation that if you&#39;re doing Unsafe operations on a Reference.referent
151   // field, then you&#39;re on your own anyway.
152   ZBarrier::load_barrier_on_oop_field(field_addr(base, offset));
<span class="line-modified">153   return Raw::oop_atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);</span>
154 }
155 
156 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
157 template &lt;typename T&gt;
<span class="line-modified">158 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
159   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
160   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
161 
<span class="line-modified">162   const oop o = Raw::oop_atomic_xchg_in_heap(addr, new_value);</span>
163   return ZBarrier::load_barrier_on_oop(o);
164 }
165 
166 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">167 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
168   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
169   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
170 
<span class="line-modified">171   const oop o = Raw::oop_atomic_xchg_in_heap_at(base, offset, new_value);</span>
172   return ZBarrier::load_barrier_on_oop(o);
173 }
174 
175 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
176 template &lt;typename T&gt;
177 inline bool ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
178                                                                                        arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
179                                                                                        size_t length) {
180   T* src = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
181   T* dst = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
182 
183   if (!HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value) {
184     // No check cast, bulk barrier and bulk copy
185     ZBarrier::load_barrier_on_oop_array(src, length);
186     return Raw::oop_arraycopy_in_heap(NULL, 0, src, NULL, 0, dst, length);
187   }
188 
189   // Check cast and copy each elements
190   Klass* const dst_klass = objArrayOop(dst_obj)-&gt;element_klass();
191   for (const T* const end = src + length; src &lt; end; src++, dst++) {
</pre>
<hr />
<pre>
205 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
206 inline void ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
207   ZBarrier::load_barrier_on_oop_fields(src);
208   Raw::clone_in_heap(src, dst, size);
209 }
210 
211 //
212 // Not in heap
213 //
214 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
215 template &lt;typename T&gt;
216 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {
217   verify_decorators_absent&lt;ON_UNKNOWN_OOP_REF&gt;();
218 
219   const oop o = Raw::oop_load_not_in_heap(addr);
220   return load_barrier_on_oop_field_preloaded(addr, o);
221 }
222 
223 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
224 template &lt;typename T&gt;
<span class="line-modified">225 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
226   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
227   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
228 
<span class="line-modified">229   return Raw::oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);</span>
230 }
231 
232 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
233 template &lt;typename T&gt;
<span class="line-modified">234 inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
235   verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
236   verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
237 
<span class="line-modified">238   return Raw::oop_atomic_xchg_not_in_heap(addr, new_value);</span>
239 }
240 
241 #endif // SHARE_GC_Z_ZBARRIERSET_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
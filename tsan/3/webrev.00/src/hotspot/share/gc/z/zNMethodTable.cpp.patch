diff a/src/hotspot/share/gc/z/zNMethodTable.cpp b/src/hotspot/share/gc/z/zNMethodTable.cpp
--- a/src/hotspot/share/gc/z/zNMethodTable.cpp
+++ b/src/hotspot/share/gc/z/zNMethodTable.cpp
@@ -28,40 +28,31 @@
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/barrierSetNMethod.hpp"
 #include "gc/z/zGlobals.hpp"
 #include "gc/z/zHash.inline.hpp"
 #include "gc/z/zLock.inline.hpp"
-#include "gc/z/zNMethodAllocator.hpp"
 #include "gc/z/zNMethodData.hpp"
 #include "gc/z/zNMethodTable.hpp"
 #include "gc/z/zNMethodTableEntry.hpp"
 #include "gc/z/zNMethodTableIteration.hpp"
 #include "gc/z/zOopClosures.inline.hpp"
+#include "gc/z/zSafeDelete.inline.hpp"
 #include "gc/z/zTask.hpp"
 #include "gc/z/zWorkers.hpp"
 #include "logging/log.hpp"
 #include "memory/allocation.hpp"
 #include "memory/iterator.hpp"
 #include "memory/resourceArea.hpp"
-#include "runtime/atomic.hpp"
-#include "runtime/orderAccess.hpp"
 #include "utilities/debug.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 ZNMethodTableEntry* ZNMethodTable::_table = NULL;
 size_t ZNMethodTable::_size = 0;
 size_t ZNMethodTable::_nregistered = 0;
 size_t ZNMethodTable::_nunregistered = 0;
 ZNMethodTableIteration ZNMethodTable::_iteration;
-
-ZNMethodTableEntry* ZNMethodTable::create(size_t size) {
-  void* const mem = ZNMethodAllocator::allocate(size * sizeof(ZNMethodTableEntry));
-  return ::new (mem) ZNMethodTableEntry[size];
-}
-
-void ZNMethodTable::destroy(ZNMethodTableEntry* table) {
-  ZNMethodAllocator::free(table);
-}
+ZSafeDeleteNoLock<ZNMethodTableEntry[]> ZNMethodTable::_safe_delete;
 
 size_t ZNMethodTable::first_index(const nmethod* nm, size_t size) {
   assert(is_power_of_2(size), "Invalid size");
   const size_t mask = size - 1;
   const size_t hash = ZHash::address_to_uint32((uintptr_t)nm);
@@ -119,29 +110,29 @@
 
   assert(is_power_of_2(new_size), "Invalid size");
 
   log_debug(gc, nmethod)("Rebuilding NMethod Table: "
                          SIZE_FORMAT "->" SIZE_FORMAT " entries, "
-                         SIZE_FORMAT "(%.0lf%%->%.0lf%%) registered, "
-                         SIZE_FORMAT "(%.0lf%%->%.0lf%%) unregistered",
+                         SIZE_FORMAT "(%.0f%%->%.0f%%) registered, "
+                         SIZE_FORMAT "(%.0f%%->%.0f%%) unregistered",
                          _size, new_size,
                          _nregistered, percent_of(_nregistered, _size), percent_of(_nregistered, new_size),
                          _nunregistered, percent_of(_nunregistered, _size), 0.0);
 
   // Allocate new table
-  ZNMethodTableEntry* const new_table = ZNMethodTable::create(new_size);
+  ZNMethodTableEntry* const new_table = new ZNMethodTableEntry[new_size];
 
   // Transfer all registered entries
   for (size_t i = 0; i < _size; i++) {
     const ZNMethodTableEntry entry = _table[i];
     if (entry.registered()) {
       register_entry(new_table, new_size, entry.method());
     }
   }
 
   // Free old table
-  ZNMethodTable::destroy(_table);
+  _safe_delete(_table);
 
   // Install new table
   _table = new_table;
   _size = new_size;
   _nunregistered = 0;
@@ -201,11 +192,11 @@
 
 void ZNMethodTable::wait_until_iteration_done() {
   assert(CodeCache_lock->owned_by_self(), "Lock must be held");
 
   while (_iteration.in_progress()) {
-    CodeCache_lock->wait(Monitor::_no_safepoint_check_flag);
+    CodeCache_lock->wait_without_safepoint_check();
   }
 }
 
 void ZNMethodTable::unregister_nmethod(nmethod* nm) {
   assert(CodeCache_lock->owned_by_self(), "Lock must be held");
@@ -215,27 +206,27 @@
   _nunregistered++;
   _nregistered--;
 }
 
 void ZNMethodTable::nmethods_do_begin() {
-  MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 
-  // Make sure we don't free data while iterating
-  ZNMethodAllocator::activate_deferred_frees();
+  // Do not allow the table to be deleted while iterating
+  _safe_delete.enable_deferred_delete();
 
   // Prepare iteration
   _iteration.nmethods_do_begin(_table, _size);
 }
 
 void ZNMethodTable::nmethods_do_end() {
-  MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 
   // Finish iteration
   _iteration.nmethods_do_end();
 
-  // Process deferred frees
-  ZNMethodAllocator::deactivate_and_process_deferred_frees();
+  // Allow the table to be deleted
+  _safe_delete.disable_deferred_delete();
 
   // Notify iteration done
   CodeCache_lock->notify_all();
 }
 

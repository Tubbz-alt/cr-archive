<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zCollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zCollectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zDebug.gdb.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zCollectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,57 ***</span>
  #define SHARE_GC_Z_ZCOLLECTEDHEAP_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/softRefPolicy.hpp&quot;
  #include &quot;gc/z/zBarrierSet.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zCollectorPolicy.hpp&quot;</span>
  #include &quot;gc/z/zDirector.hpp&quot;
  #include &quot;gc/z/zDriver.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zInitialize.hpp&quot;</span>
  #include &quot;gc/z/zHeap.hpp&quot;
  #include &quot;gc/z/zRuntimeWorkers.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  
  class ZCollectedHeap : public CollectedHeap {
    friend class VMStructs;
  
  private:
<span class="line-removed">-   ZCollectorPolicy* _collector_policy;</span>
    SoftRefPolicy     _soft_ref_policy;
    ZBarrierSet       _barrier_set;
    ZInitialize       _initialize;
    ZHeap             _heap;
    ZDirector*        _director;
    ZDriver*          _driver;
    ZStat*            _stat;
    ZRuntimeWorkers   _runtime_workers;
  
    virtual HeapWord* allocate_new_tlab(size_t min_size,
                                        size_t requested_size,
                                        size_t* actual_size);
  
  public:
    static ZCollectedHeap* heap();
  
<span class="line-modified">!   ZCollectedHeap(ZCollectorPolicy* policy);</span>
    virtual Name kind() const;
    virtual const char* name() const;
    virtual jint initialize();
    virtual void initialize_serviceability();
    virtual void stop();
  
<span class="line-removed">-   virtual CollectorPolicy* collector_policy() const;</span>
    virtual SoftRefPolicy* soft_ref_policy();
  
    virtual size_t max_capacity() const;
    virtual size_t capacity() const;
    virtual size_t used() const;
  
    virtual bool is_maximal_no_gc() const;
    virtual bool is_in(const void* p) const;
<span class="line-removed">-   virtual bool is_in_closed_subset(const void* p) const;</span>
  
    virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);
    virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
                                                         size_t size,
                                                         Metaspace::MetadataType mdtype);
    virtual void collect(GCCause::Cause cause);
<span class="line-new-header">--- 25,59 ---</span>
  #define SHARE_GC_Z_ZCOLLECTEDHEAP_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/softRefPolicy.hpp&quot;
  #include &quot;gc/z/zBarrierSet.hpp&quot;
  #include &quot;gc/z/zDirector.hpp&quot;
  #include &quot;gc/z/zDriver.hpp&quot;
  #include &quot;gc/z/zHeap.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zInitialize.hpp&quot;</span>
  #include &quot;gc/z/zRuntimeWorkers.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zUncommitter.hpp&quot;</span>
  
  class ZCollectedHeap : public CollectedHeap {
    friend class VMStructs;
  
  private:
    SoftRefPolicy     _soft_ref_policy;
    ZBarrierSet       _barrier_set;
    ZInitialize       _initialize;
    ZHeap             _heap;
    ZDirector*        _director;
    ZDriver*          _driver;
<span class="line-added">+   ZUncommitter*     _uncommitter;</span>
    ZStat*            _stat;
    ZRuntimeWorkers   _runtime_workers;
  
    virtual HeapWord* allocate_new_tlab(size_t min_size,
                                        size_t requested_size,
                                        size_t* actual_size);
  
  public:
    static ZCollectedHeap* heap();
  
<span class="line-modified">!   ZCollectedHeap();</span>
    virtual Name kind() const;
    virtual const char* name() const;
    virtual jint initialize();
    virtual void initialize_serviceability();
    virtual void stop();
  
    virtual SoftRefPolicy* soft_ref_policy();
  
    virtual size_t max_capacity() const;
    virtual size_t capacity() const;
    virtual size_t used() const;
<span class="line-added">+   virtual size_t unused() const;</span>
  
    virtual bool is_maximal_no_gc() const;
    virtual bool is_in(const void* p) const;
  
<span class="line-added">+   virtual uint32_t hash_oop(oop obj) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);</span>
    virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);
    virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
                                                         size_t size,
                                                         Metaspace::MetadataType mdtype);
    virtual void collect(GCCause::Cause cause);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,14 ***</span>
  
    virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
    virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
  
    virtual void object_iterate(ObjectClosure* cl);
<span class="line-removed">-   virtual void safe_object_iterate(ObjectClosure* cl);</span>
  
<span class="line-modified">!   virtual HeapWord* block_start(const void* addr) const;</span>
<span class="line-removed">-   virtual bool block_is_obj(const HeapWord* addr) const;</span>
  
    virtual void register_nmethod(nmethod* nm);
    virtual void unregister_nmethod(nmethod* nm);
    virtual void flush_nmethod(nmethod* nm);
    virtual void verify_nmethod(nmethod* nmethod);
<span class="line-new-header">--- 96,12 ---</span>
  
    virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
    virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
  
    virtual void object_iterate(ObjectClosure* cl);
  
<span class="line-modified">!   virtual void keep_alive(oop obj);</span>
  
    virtual void register_nmethod(nmethod* nm);
    virtual void unregister_nmethod(nmethod* nm);
    virtual void flush_nmethod(nmethod* nm);
    virtual void verify_nmethod(nmethod* nmethod);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,10 ***</span>
<span class="line-new-header">--- 120,11 ---</span>
    virtual void print_on(outputStream* st) const;
    virtual void print_on_error(outputStream* st) const;
    virtual void print_extended_on(outputStream* st) const;
    virtual void print_gc_threads_on(outputStream* st) const;
    virtual void print_tracing_info() const;
<span class="line-added">+   virtual bool print_location(outputStream* st, void* addr) const;</span>
  
    virtual void prepare_for_verify();
    virtual void verify(VerifyOption option /* ignored */);
    virtual bool is_oop(oop object) const;
  };
</pre>
<center><a href="zCollectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zDebug.gdb.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
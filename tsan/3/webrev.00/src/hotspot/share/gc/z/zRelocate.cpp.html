<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zRelocate.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zAddress.inline.hpp&quot;
 26 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 27 #include &quot;gc/z/zForwarding.inline.hpp&quot;
 28 #include &quot;gc/z/zHeap.hpp&quot;
 29 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 30 #include &quot;gc/z/zPage.hpp&quot;
 31 #include &quot;gc/z/zRelocate.hpp&quot;
 32 #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
 33 #include &quot;gc/z/zRootsIterator.hpp&quot;
 34 #include &quot;gc/z/zStat.hpp&quot;
 35 #include &quot;gc/z/zTask.hpp&quot;
 36 #include &quot;gc/z/zThread.inline.hpp&quot;
 37 #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
 38 #include &quot;gc/z/zWorkers.hpp&quot;
 39 #include &quot;logging/log.hpp&quot;
 40 
 41 static const ZStatCounter ZCounterRelocationContention(&quot;Contention&quot;, &quot;Relocation Contention&quot;, ZStatUnitOpsPerSecond);
 42 
 43 ZRelocate::ZRelocate(ZWorkers* workers) :
 44     _workers(workers) {}
 45 
 46 class ZRelocateRootsIteratorClosure : public ZRootsIteratorClosure {
 47 public:
 48   virtual void do_thread(Thread* thread) {
 49     // Update thread local address bad mask
 50     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
 51 
 52     // Relocate invisible root
 53     ZThreadLocalData::do_invisible_root(thread, ZBarrier::relocate_barrier_on_root_oop_field);
 54 
 55     // Remap TLAB
 56     ZThreadLocalAllocBuffer::remap(thread);
 57   }
 58 
 59   virtual bool should_disarm_nmethods() const {
 60     return true;
 61   }
 62 
 63   virtual void do_oop(oop* p) {
 64     ZBarrier::relocate_barrier_on_root_oop_field(p);
 65   }
 66 
 67   virtual void do_oop(narrowOop* p) {
 68     ShouldNotReachHere();
 69   }
 70 };
 71 
 72 class ZRelocateRootsTask : public ZTask {
 73 private:
 74   ZRootsIterator                _roots;
 75   ZRelocateRootsIteratorClosure _cl;
 76 
 77 public:
 78   ZRelocateRootsTask() :
 79       ZTask(&quot;ZRelocateRootsTask&quot;),
 80       _roots(true /* visit_jvmti_weak_export */) {}
 81 
 82   virtual void work() {
 83     // During relocation we need to visit the JVMTI
 84     // export weak roots to rehash the JVMTI tag map
 85     _roots.oops_do(&amp;_cl);
 86   }
 87 };
 88 
 89 void ZRelocate::start() {
 90   ZRelocateRootsTask task;
 91   _workers-&gt;run_parallel(&amp;task);
 92 }
 93 
 94 uintptr_t ZRelocate::relocate_object_inner(ZForwarding* forwarding, uintptr_t from_index, uintptr_t from_offset) const {
 95   ZForwardingCursor cursor;
 96 
 97   // Lookup forwarding entry
 98   const ZForwardingEntry entry = forwarding-&gt;find(from_index, &amp;cursor);
 99   if (entry.populated() &amp;&amp; entry.from_index() == from_index) {
100     // Already relocated, return new address
101     return entry.to_offset();
102   }
103 
104   assert(ZHeap::heap()-&gt;is_object_live(ZAddress::good(from_offset)), &quot;Should be live&quot;);
105 
106   if (forwarding-&gt;is_pinned()) {
107     // In-place forward
108     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);
109   }
110 
111   // Allocate object
112   const uintptr_t from_good = ZAddress::good(from_offset);
113   const size_t size = ZUtils::object_size(from_good);
114   const uintptr_t to_good = ZHeap::heap()-&gt;alloc_object_for_relocation(size);
115   if (to_good == 0) {
116     // Failed, in-place forward
117     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);
118   }
119 
120   // Copy object
121   ZUtils::object_copy(from_good, to_good, size);
122 
123   // Insert forwarding entry
124   const uintptr_t to_offset = ZAddress::offset(to_good);
125   const uintptr_t to_offset_final = forwarding-&gt;insert(from_index, to_offset, &amp;cursor);
126   if (to_offset_final == to_offset) {
127     // Relocation succeeded
128     return to_offset;
129   }
130 
131   // Relocation contention
132   ZStatInc(ZCounterRelocationContention);
133   log_trace(gc)(&quot;Relocation contention, thread: &quot; PTR_FORMAT &quot; (%s), forwarding: &quot; PTR_FORMAT
134                 &quot;, entry: &quot; SIZE_FORMAT &quot;, oop: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT,
135                 ZThread::id(), ZThread::name(), p2i(forwarding), cursor, from_good, size);
136 
137   // Try undo allocation
138   ZHeap::heap()-&gt;undo_alloc_object_for_relocation(to_good, size);
139 
140   return to_offset_final;
141 }
142 
143 uintptr_t ZRelocate::relocate_object(ZForwarding* forwarding, uintptr_t from_addr) const {
144   const uintptr_t from_offset = ZAddress::offset(from_addr);
145   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();
146   const uintptr_t to_offset = relocate_object_inner(forwarding, from_index, from_offset);
147 
148   if (from_offset == to_offset) {
149     // In-place forwarding, pin page
150     forwarding-&gt;set_pinned();
151   }
152 
153   return ZAddress::good(to_offset);
154 }
155 
156 uintptr_t ZRelocate::forward_object(ZForwarding* forwarding, uintptr_t from_addr) const {
157   const uintptr_t from_offset = ZAddress::offset(from_addr);
158   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();
159   const ZForwardingEntry entry = forwarding-&gt;find(from_index);
160 
161   assert(entry.populated(), &quot;Should be forwarded&quot;);
162   assert(entry.from_index() == from_index, &quot;Should be forwarded&quot;);
163 
164   return ZAddress::good(entry.to_offset());
165 }
166 
167 class ZRelocateObjectClosure : public ObjectClosure {
168 private:
169   ZRelocate* const   _relocate;
170   ZForwarding* const _forwarding;
171 
172 public:
173   ZRelocateObjectClosure(ZRelocate* relocate, ZForwarding* forwarding) :
174       _relocate(relocate),
175       _forwarding(forwarding) {}
176 
177   virtual void do_object(oop o) {
178     _relocate-&gt;relocate_object(_forwarding, ZOop::to_address(o));
179   }
180 };
181 
182 bool ZRelocate::work(ZRelocationSetParallelIterator* iter) {
183   bool success = true;
184 
185   // Relocate pages in the relocation set
186   for (ZForwarding* forwarding; iter-&gt;next(&amp;forwarding);) {
187     // Relocate objects in page
188     ZRelocateObjectClosure cl(this, forwarding);
189     forwarding-&gt;page()-&gt;object_iterate(&amp;cl);
190 
191     if (ZVerifyForwarding) {
192       forwarding-&gt;verify();
193     }
194 
195     if (forwarding-&gt;is_pinned()) {
196       // Relocation failed, page is now pinned
197       success = false;
198     } else {
199       // Relocation succeeded, release page
200       forwarding-&gt;release_page();
201     }
202   }
203 
204   return success;
205 }
206 
207 class ZRelocateTask : public ZTask {
208 private:
209   ZRelocate* const               _relocate;
210   ZRelocationSetParallelIterator _iter;
211   bool                           _failed;
212 
213 public:
214   ZRelocateTask(ZRelocate* relocate, ZRelocationSet* relocation_set) :
215       ZTask(&quot;ZRelocateTask&quot;),
216       _relocate(relocate),
217       _iter(relocation_set),
218       _failed(false) {}
219 
220   virtual void work() {
221     if (!_relocate-&gt;work(&amp;_iter)) {
222       _failed = true;
223     }
224   }
225 
226   bool failed() const {
227     return _failed;
228   }
229 };
230 
231 bool ZRelocate::relocate(ZRelocationSet* relocation_set) {
232   ZRelocateTask task(this, relocation_set);
233   _workers-&gt;run_concurrent(&amp;task);
234   return !task.failed();
235 }
    </pre>
  </body>
</html>
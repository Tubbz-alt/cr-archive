<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zUnload.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zTracer.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zUnload.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;code/codeBehaviours.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/dependencyContext.hpp&quot;
 30 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/z/zLock.inline.hpp&quot;
 33 #include &quot;gc/z/zNMethod.hpp&quot;
 34 #include &quot;gc/z/zOopClosures.hpp&quot;
 35 #include &quot;gc/z/zStat.hpp&quot;
 36 #include &quot;gc/z/zUnload.hpp&quot;
 37 #include &quot;oops/access.inline.hpp&quot;
 38 
<span class="line-modified"> 39 static const ZStatSubPhase ZSubPhaseConcurrentClassesUnload(&quot;Concurrent Classes Unload&quot;);</span>

 40 
 41 class ZIsUnloadingOopClosure : public OopClosure {
 42 private:
 43   ZPhantomIsAliveObjectClosure _is_alive;
 44   bool                         _is_unloading;
 45 
 46 public:
 47   ZIsUnloadingOopClosure() :
 48       _is_alive(),
 49       _is_unloading(false) {}
 50 
 51   virtual void do_oop(oop* p) {
 52     const oop o = RawAccess&lt;&gt;::oop_load(p);
 53     if (o != NULL &amp;&amp; !_is_alive.do_object_b(o)) {
 54       _is_unloading = true;
 55     }
 56   }
 57 
 58   virtual void do_oop(narrowOop* p) {
 59     ShouldNotReachHere();
 60   }
 61 
 62   bool is_unloading() const {
 63     return _is_unloading;
 64   }
 65 };
 66 
 67 class ZIsUnloadingBehaviour : public IsUnloadingBehaviour {
 68 public:
 69   virtual bool is_unloading(CompiledMethod* method) const {
 70     nmethod* const nm = method-&gt;as_nmethod();
 71     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 72     ZLocker&lt;ZReentrantLock&gt; locker(lock);
 73     ZIsUnloadingOopClosure cl;
<span class="line-modified"> 74     nm-&gt;oops_do(&amp;cl, true /* allow_zombie */);</span>
 75     return cl.is_unloading();
 76   }
 77 };
 78 
 79 class ZCompiledICProtectionBehaviour : public CompiledICProtectionBehaviour {
 80 public:
 81   virtual bool lock(CompiledMethod* method) {
 82     nmethod* const nm = method-&gt;as_nmethod();
 83     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 84     lock-&gt;lock();
 85     return true;
 86   }
 87 
 88   virtual void unlock(CompiledMethod* method) {
 89     nmethod* const nm = method-&gt;as_nmethod();
 90     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 91     lock-&gt;unlock();
 92   }
 93 
 94   virtual bool is_safe(CompiledMethod* method) {
</pre>
<hr />
<pre>
109     return;
110   }
111 
112   static ZIsUnloadingBehaviour is_unloading_behaviour;
113   IsUnloadingBehaviour::set_current(&amp;is_unloading_behaviour);
114 
115   static ZCompiledICProtectionBehaviour ic_protection_behaviour;
116   CompiledICProtectionBehaviour::set_current(&amp;ic_protection_behaviour);
117 }
118 
119 void ZUnload::prepare() {
120   if (!ClassUnloading) {
121     return;
122   }
123 
124   CodeCache::increment_unloading_cycle();
125   DependencyContext::cleaning_start();
126 }
127 
128 void ZUnload::unlink() {





129   SuspendibleThreadSetJoiner sts;
130   bool unloading_occurred;
131 
132   {
<span class="line-modified">133     MutexLockerEx ml(ClassLoaderDataGraph_lock);</span>
134     unloading_occurred = SystemDictionary::do_unloading(ZStatPhase::timer());
135   }
136 
137   Klass::clean_weak_klass_links(unloading_occurred);
<span class="line-removed">138 </span>
139   ZNMethod::unlink(_workers, unloading_occurred);
<span class="line-removed">140 </span>
141   DependencyContext::cleaning_end();
142 }
143 
144 void ZUnload::purge() {






145   {
146     SuspendibleThreadSetJoiner sts;
147     ZNMethod::purge(_workers);
148   }
149 
150   ClassLoaderDataGraph::purge();
151   CodeCache::purge_exception_caches();
152 }
153 
<span class="line-removed">154 class ZUnloadRendezvousClosure : public ThreadClosure {</span>
<span class="line-removed">155 public:</span>
<span class="line-removed">156   void do_thread(Thread* thread) {}</span>
<span class="line-removed">157 };</span>
<span class="line-removed">158 </span>
<span class="line-removed">159 void ZUnload::unload() {</span>
<span class="line-removed">160   if (!ClassUnloading) {</span>
<span class="line-removed">161     return;</span>
<span class="line-removed">162   }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164   ZStatTimer timer(ZSubPhaseConcurrentClassesUnload);</span>
<span class="line-removed">165 </span>
<span class="line-removed">166   // Unlink stale metadata and nmethods</span>
<span class="line-removed">167   unlink();</span>
<span class="line-removed">168 </span>
<span class="line-removed">169   // Make sure stale metadata and nmethods are no longer observable</span>
<span class="line-removed">170   ZUnloadRendezvousClosure cl;</span>
<span class="line-removed">171   Handshake::execute(&amp;cl);</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   // Purge stale metadata and nmethods that were unlinked</span>
<span class="line-removed">174   purge();</span>
<span class="line-removed">175 }</span>
<span class="line-removed">176 </span>
177 void ZUnload::finish() {
178   // Resize and verify metaspace
179   MetaspaceGC::compute_new_size();
180   MetaspaceUtils::verify_metrics();
181 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;code/codeBehaviours.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/dependencyContext.hpp&quot;
 30 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/z/zLock.inline.hpp&quot;
 33 #include &quot;gc/z/zNMethod.hpp&quot;
 34 #include &quot;gc/z/zOopClosures.hpp&quot;
 35 #include &quot;gc/z/zStat.hpp&quot;
 36 #include &quot;gc/z/zUnload.hpp&quot;
 37 #include &quot;oops/access.inline.hpp&quot;
 38 
<span class="line-modified"> 39 static const ZStatSubPhase ZSubPhaseConcurrentClassesUnlink(&quot;Concurrent Classes Unlink&quot;);</span>
<span class="line-added"> 40 static const ZStatSubPhase ZSubPhaseConcurrentClassesPurge(&quot;Concurrent Classes Purge&quot;);</span>
 41 
 42 class ZIsUnloadingOopClosure : public OopClosure {
 43 private:
 44   ZPhantomIsAliveObjectClosure _is_alive;
 45   bool                         _is_unloading;
 46 
 47 public:
 48   ZIsUnloadingOopClosure() :
 49       _is_alive(),
 50       _is_unloading(false) {}
 51 
 52   virtual void do_oop(oop* p) {
 53     const oop o = RawAccess&lt;&gt;::oop_load(p);
 54     if (o != NULL &amp;&amp; !_is_alive.do_object_b(o)) {
 55       _is_unloading = true;
 56     }
 57   }
 58 
 59   virtual void do_oop(narrowOop* p) {
 60     ShouldNotReachHere();
 61   }
 62 
 63   bool is_unloading() const {
 64     return _is_unloading;
 65   }
 66 };
 67 
 68 class ZIsUnloadingBehaviour : public IsUnloadingBehaviour {
 69 public:
 70   virtual bool is_unloading(CompiledMethod* method) const {
 71     nmethod* const nm = method-&gt;as_nmethod();
 72     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 73     ZLocker&lt;ZReentrantLock&gt; locker(lock);
 74     ZIsUnloadingOopClosure cl;
<span class="line-modified"> 75     ZNMethod::nmethod_oops_do(nm, &amp;cl);</span>
 76     return cl.is_unloading();
 77   }
 78 };
 79 
 80 class ZCompiledICProtectionBehaviour : public CompiledICProtectionBehaviour {
 81 public:
 82   virtual bool lock(CompiledMethod* method) {
 83     nmethod* const nm = method-&gt;as_nmethod();
 84     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 85     lock-&gt;lock();
 86     return true;
 87   }
 88 
 89   virtual void unlock(CompiledMethod* method) {
 90     nmethod* const nm = method-&gt;as_nmethod();
 91     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 92     lock-&gt;unlock();
 93   }
 94 
 95   virtual bool is_safe(CompiledMethod* method) {
</pre>
<hr />
<pre>
110     return;
111   }
112 
113   static ZIsUnloadingBehaviour is_unloading_behaviour;
114   IsUnloadingBehaviour::set_current(&amp;is_unloading_behaviour);
115 
116   static ZCompiledICProtectionBehaviour ic_protection_behaviour;
117   CompiledICProtectionBehaviour::set_current(&amp;ic_protection_behaviour);
118 }
119 
120 void ZUnload::prepare() {
121   if (!ClassUnloading) {
122     return;
123   }
124 
125   CodeCache::increment_unloading_cycle();
126   DependencyContext::cleaning_start();
127 }
128 
129 void ZUnload::unlink() {
<span class="line-added">130   if (!ClassUnloading) {</span>
<span class="line-added">131     return;</span>
<span class="line-added">132   }</span>
<span class="line-added">133 </span>
<span class="line-added">134   ZStatTimer timer(ZSubPhaseConcurrentClassesUnlink);</span>
135   SuspendibleThreadSetJoiner sts;
136   bool unloading_occurred;
137 
138   {
<span class="line-modified">139     MutexLocker ml(ClassLoaderDataGraph_lock);</span>
140     unloading_occurred = SystemDictionary::do_unloading(ZStatPhase::timer());
141   }
142 
143   Klass::clean_weak_klass_links(unloading_occurred);

144   ZNMethod::unlink(_workers, unloading_occurred);

145   DependencyContext::cleaning_end();
146 }
147 
148 void ZUnload::purge() {
<span class="line-added">149   if (!ClassUnloading) {</span>
<span class="line-added">150     return;</span>
<span class="line-added">151   }</span>
<span class="line-added">152 </span>
<span class="line-added">153   ZStatTimer timer(ZSubPhaseConcurrentClassesPurge);</span>
<span class="line-added">154 </span>
155   {
156     SuspendibleThreadSetJoiner sts;
157     ZNMethod::purge(_workers);
158   }
159 
160   ClassLoaderDataGraph::purge();
161   CodeCache::purge_exception_caches();
162 }
163 























164 void ZUnload::finish() {
165   // Resize and verify metaspace
166   MetaspaceGC::compute_new_size();
167   MetaspaceUtils::verify_metrics();
168 }
</pre>
</td>
</tr>
</table>
<center><a href="zTracer.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
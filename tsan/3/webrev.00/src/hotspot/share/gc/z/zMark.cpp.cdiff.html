<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zLock.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,10 ***</span>
<span class="line-new-header">--- 20,11 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;classfile/classLoaderDataGraph.hpp&quot;</span>
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
  #include &quot;gc/z/zMark.inline.hpp&quot;
  #include &quot;gc/z/zMarkCache.inline.hpp&quot;
  #include &quot;gc/z/zMarkStack.inline.hpp&quot;
  #include &quot;gc/z/zMarkTerminate.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,36 ***</span>
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zPageTable.inline.hpp&quot;
  #include &quot;gc/z/zRootsIterator.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zTask.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zThread.hpp&quot;</span>
  #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
  #include &quot;gc/z/zUtils.inline.hpp&quot;
  #include &quot;gc/z/zWorkers.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handshake.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ticks.hpp&quot;
  
  static const ZStatSubPhase ZSubPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkTryFlush(&quot;Concurrent Mark Try Flush&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkIdle(&quot;Concurrent Mark Idle&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkTryTerminate(&quot;Concurrent Mark Try Terminate&quot;);
  static const ZStatSubPhase ZSubPhaseMarkTryComplete(&quot;Pause Mark Try Complete&quot;);
  
<span class="line-modified">! ZMark::ZMark(ZWorkers* workers, ZPageTable* pagetable) :</span>
      _workers(workers),
<span class="line-modified">!     _pagetable(pagetable),</span>
      _allocator(),
      _stripes(),
      _terminate(),
      _work_terminateflush(true),
      _work_nproactiveflush(0),
<span class="line-new-header">--- 32,37 ---</span>
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zPageTable.inline.hpp&quot;
  #include &quot;gc/z/zRootsIterator.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zTask.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zThread.inline.hpp&quot;</span>
  #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
  #include &quot;gc/z/zUtils.inline.hpp&quot;
  #include &quot;gc/z/zWorkers.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handshake.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/safepointMechanism.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/ticks.hpp&quot;
  
  static const ZStatSubPhase ZSubPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkTryFlush(&quot;Concurrent Mark Try Flush&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkIdle(&quot;Concurrent Mark Idle&quot;);
  static const ZStatSubPhase ZSubPhaseConcurrentMarkTryTerminate(&quot;Concurrent Mark Try Terminate&quot;);
  static const ZStatSubPhase ZSubPhaseMarkTryComplete(&quot;Pause Mark Try Complete&quot;);
  
<span class="line-modified">! ZMark::ZMark(ZWorkers* workers, ZPageTable* page_table) :</span>
      _workers(workers),
<span class="line-modified">!     _page_table(page_table),</span>
      _allocator(),
      _stripes(),
      _terminate(),
      _work_terminateflush(true),
      _work_nproactiveflush(0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
  
  size_t ZMark::calculate_nstripes(uint nworkers) const {
    // Calculate the number of stripes from the number of workers we use,
    // where the number of stripes must be a power of two and we want to
    // have at least one worker per stripe.
<span class="line-modified">!   const size_t nstripes = ZUtils::round_down_power_of_2(nworkers);</span>
    return MIN2(nstripes, ZMarkStripesMax);
  }
  
  void ZMark::prepare_mark() {
    // Increment global sequence number to invalidate
<span class="line-new-header">--- 79,11 ---</span>
  
  size_t ZMark::calculate_nstripes(uint nworkers) const {
    // Calculate the number of stripes from the number of workers we use,
    // where the number of stripes must be a power of two and we want to
    // have at least one worker per stripe.
<span class="line-modified">!   const size_t nstripes = round_down_power_of_2(nworkers);</span>
    return MIN2(nstripes, ZMarkStripesMax);
  }
  
  void ZMark::prepare_mark() {
    // Increment global sequence number to invalidate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,14 ***</span>
<span class="line-new-header">--- 132,21 ---</span>
  
    virtual void do_thread(Thread* thread) {
      // Update thread local address bad mask
      ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
  
<span class="line-added">+     // Mark invisible root</span>
<span class="line-added">+     ZThreadLocalData::do_invisible_root(thread, ZBarrier::mark_barrier_on_invisible_root_oop_field);</span>
<span class="line-added">+ </span>
      // Retire TLAB
      ZThreadLocalAllocBuffer::retire(thread);
    }
  
<span class="line-added">+   virtual bool should_disarm_nmethods() const {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    virtual void do_oop(oop* p) {
      ZBarrier::mark_barrier_on_root_oop_field(p);
    }
  
    virtual void do_oop(narrowOop* p) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,11 ***</span>
  
  public:
    ZMarkRootsTask(ZMark* mark) :
        ZTask(&quot;ZMarkRootsTask&quot;),
        _mark(mark),
<span class="line-modified">!       _roots() {}</span>
  
    virtual void work() {
      _roots.oops_do(&amp;_cl);
  
      // Flush and free worker stacks. Needed here since
<span class="line-new-header">--- 162,11 ---</span>
  
  public:
    ZMarkRootsTask(ZMark* mark) :
        ZTask(&quot;ZMarkRootsTask&quot;),
        _mark(mark),
<span class="line-modified">!       _roots(false /* visit_jvmti_weak_export */) {}</span>
  
    virtual void work() {
      _roots.oops_do(&amp;_cl);
  
      // Flush and free worker stacks. Needed here since
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,11 ***</span>
    _nproactiveflush += _work_nproactiveflush;
    _nterminateflush += _work_nterminateflush;
  }
  
  bool ZMark::is_array(uintptr_t addr) const {
<span class="line-modified">!   return ZOop::to_oop(addr)-&gt;is_objArray();</span>
  }
  
  void ZMark::push_partial_array(uintptr_t addr, size_t size, bool finalizable) {
    assert(is_aligned(addr, ZMarkPartialArrayMinSize), &quot;Address misaligned&quot;);
    ZMarkThreadLocalStacks* const stacks = ZThreadLocalData::stacks(Thread::current());
<span class="line-new-header">--- 207,11 ---</span>
    _nproactiveflush += _work_nproactiveflush;
    _nterminateflush += _work_nterminateflush;
  }
  
  bool ZMark::is_array(uintptr_t addr) const {
<span class="line-modified">!   return ZOop::from_address(addr)-&gt;is_objArray();</span>
  }
  
  void ZMark::push_partial_array(uintptr_t addr, size_t size, bool finalizable) {
    assert(is_aligned(addr, ZMarkPartialArrayMinSize), &quot;Address misaligned&quot;);
    ZMarkThreadLocalStacks* const stacks = ZThreadLocalData::stacks(Thread::current());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
      obj-&gt;oop_iterate(&amp;cl);
    }
  }
  
  bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {
<span class="line-modified">!   ZPage* const page = _pagetable-&gt;get(addr);</span>
    if (page-&gt;is_allocating()) {
      // Newly allocated objects are implicitly marked
      return false;
    }
  
<span class="line-new-header">--- 314,11 ---</span>
      obj-&gt;oop_iterate(&amp;cl);
    }
  }
  
  bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {
<span class="line-modified">!   ZPage* const page = _page_table-&gt;get(addr);</span>
    if (page-&gt;is_allocating()) {
      // Newly allocated objects are implicitly marked
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,22 ***</span>
    if (partial_array) {
      follow_partial_array(entry, finalizable);
      return;
    }
  
<span class="line-modified">!   // Decode object address</span>
    const uintptr_t addr = entry.object_address();
  
    if (!try_mark_object(cache, addr, finalizable)) {
      // Already marked
      return;
    }
  
    if (is_array(addr)) {
<span class="line-modified">!     follow_array_object(objArrayOop(ZOop::to_oop(addr)), finalizable);</span>
    } else {
<span class="line-modified">!     follow_object(ZOop::to_oop(addr), finalizable);</span>
    }
  }
  
  template &lt;typename T&gt;
  bool ZMark::drain(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks, ZMarkCache* cache, T* timeout) {
<span class="line-new-header">--- 345,28 ---</span>
    if (partial_array) {
      follow_partial_array(entry, finalizable);
      return;
    }
  
<span class="line-modified">!   // Decode object address and follow flag</span>
    const uintptr_t addr = entry.object_address();
  
    if (!try_mark_object(cache, addr, finalizable)) {
      // Already marked
      return;
    }
  
    if (is_array(addr)) {
<span class="line-modified">!     // Decode follow flag</span>
<span class="line-added">+     const bool follow = entry.follow();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The follow flag is currently only relevant for object arrays</span>
<span class="line-added">+     if (follow) {</span>
<span class="line-added">+       follow_array_object(objArrayOop(ZOop::from_address(addr)), finalizable);</span>
<span class="line-added">+     }</span>
    } else {
<span class="line-modified">!     follow_object(ZOop::from_address(addr), finalizable);</span>
    }
  }
  
  template &lt;typename T&gt;
  bool ZMark::drain(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks, ZMarkCache* cache, T* timeout) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,17 ***</span>
  void ZMark::idle() const {
    ZStatTimer timer(ZSubPhaseConcurrentMarkIdle);
    os::naked_short_sleep(1);
  }
  
<span class="line-modified">! class ZMarkFlushAndFreeStacksClosure : public ThreadClosure {</span>
  private:
    ZMark* const _mark;
    bool         _flushed;
  
  public:
    ZMarkFlushAndFreeStacksClosure(ZMark* mark) :
        _mark(mark),
        _flushed(false) {}
  
    void do_thread(Thread* thread) {
      if (_mark-&gt;flush_and_free(thread)) {
<span class="line-new-header">--- 417,18 ---</span>
  void ZMark::idle() const {
    ZStatTimer timer(ZSubPhaseConcurrentMarkIdle);
    os::naked_short_sleep(1);
  }
  
<span class="line-modified">! class ZMarkFlushAndFreeStacksClosure : public HandshakeClosure {</span>
  private:
    ZMark* const _mark;
    bool         _flushed;
  
  public:
    ZMarkFlushAndFreeStacksClosure(ZMark* mark) :
<span class="line-added">+       HandshakeClosure(&quot;ZMarkFlushAndFreeStacks&quot;),</span>
        _mark(mark),
        _flushed(false) {}
  
    void do_thread(Thread* thread) {
      if (_mark-&gt;flush_and_free(thread)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,11 ***</span>
    return cl.flushed() || !_stripes.is_empty();
  }
  
  bool ZMark::try_flush(volatile size_t* nflush) {
    // Only flush if handshakes are enabled
<span class="line-modified">!   if (!ThreadLocalHandshakes) {</span>
      return false;
    }
  
    Atomic::inc(nflush);
  
<span class="line-new-header">--- 453,11 ---</span>
    return cl.flushed() || !_stripes.is_empty();
  }
  
  bool ZMark::try_flush(volatile size_t* nflush) {
    // Only flush if handshakes are enabled
<span class="line-modified">!   if (!SafepointMechanism::uses_thread_local_poll()) {</span>
      return false;
    }
  
    Atomic::inc(nflush);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,11 ***</span>
        _terminate.exit_stage0();
  
        // Flush before termination
        if (!try_flush(&amp;_work_nterminateflush)) {
          // No more work available, skip further flush attempts
<span class="line-modified">!         Atomic::store(false, &amp;_work_terminateflush);</span>
        }
  
        // Don&#39;t terminate, regardless of whether we successfully
        // flushed out more work or not. We&#39;ve already exited
        // termination stage 0, to allow other threads to continue
<span class="line-new-header">--- 491,11 ---</span>
        _terminate.exit_stage0();
  
        // Flush before termination
        if (!try_flush(&amp;_work_nterminateflush)) {
          // No more work available, skip further flush attempts
<span class="line-modified">!         Atomic::store(&amp;_work_terminateflush, false);</span>
        }
  
        // Don&#39;t terminate, regardless of whether we successfully
        // flushed out more work or not. We&#39;ve already exited
        // termination stage 0, to allow other threads to continue
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,18 ***</span>
  };
  
  
  class ZMarkConcurrentRootsTask : public ZTask {
  private:
<span class="line-modified">!   ZConcurrentRootsIterator            _roots;</span>
    ZMarkConcurrentRootsIteratorClosure _cl;
  
  public:
    ZMarkConcurrentRootsTask(ZMark* mark) :
        ZTask(&quot;ZMarkConcurrentRootsTask&quot;),
<span class="line-modified">!       _roots(true /* marking */),</span>
<span class="line-modified">!       _cl() {}</span>
  
    virtual void work() {
      _roots.oops_do(&amp;_cl);
    }
  };
<span class="line-new-header">--- 646,26 ---</span>
  };
  
  
  class ZMarkConcurrentRootsTask : public ZTask {
  private:
<span class="line-modified">!   SuspendibleThreadSetJoiner          _sts_joiner;</span>
<span class="line-added">+   ZConcurrentRootsIteratorClaimStrong _roots;</span>
    ZMarkConcurrentRootsIteratorClosure _cl;
  
  public:
    ZMarkConcurrentRootsTask(ZMark* mark) :
        ZTask(&quot;ZMarkConcurrentRootsTask&quot;),
<span class="line-modified">!       _sts_joiner(),</span>
<span class="line-modified">!       _roots(),</span>
<span class="line-added">+       _cl() {</span>
<span class="line-added">+     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~ZMarkConcurrentRootsTask() {</span>
<span class="line-added">+     ClassLoaderDataGraph_lock-&gt;unlock();</span>
<span class="line-added">+   }</span>
  
    virtual void work() {
      _roots.oops_do(&amp;_cl);
    }
  };
</pre>
<center><a href="zLock.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
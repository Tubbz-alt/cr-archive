<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zHeap.inline.hpp&quot;
 27 #include &quot;gc/z/zOop.inline.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;memory/iterator.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 
<a name="2" id="anc2"></a><span class="line-removed"> 34 bool ZBarrier::during_mark() {</span>
<span class="line-removed"> 35   return ZGlobalPhase == ZPhaseMark;</span>
<span class="line-removed"> 36 }</span>
<span class="line-removed"> 37 </span>
<span class="line-removed"> 38 bool ZBarrier::during_relocate() {</span>
<span class="line-removed"> 39   return ZGlobalPhase == ZPhaseRelocate;</span>
<span class="line-removed"> 40 }</span>
<span class="line-removed"> 41 </span>
 42 template &lt;bool finalizable&gt;
 43 bool ZBarrier::should_mark_through(uintptr_t addr) {
 44   // Finalizable marked oops can still exists on the heap after marking
 45   // has completed, in which case we just want to convert this into a
 46   // good oop and not push it on the mark stack.
 47   if (!during_mark()) {
 48     assert(ZAddress::is_marked(addr), &quot;Should be marked&quot;);
 49     assert(ZAddress::is_finalizable(addr), &quot;Should be finalizable&quot;);
 50     return false;
 51   }
 52 
 53   // During marking, we mark through already marked oops to avoid having
 54   // some large part of the object graph hidden behind a pushed, but not
 55   // yet flushed, entry on a mutator mark stack. Always marking through
 56   // allows the GC workers to proceed through the object graph even if a
 57   // mutator touched an oop first, which in turn will reduce the risk of
 58   // having to flush mark stacks multiple times to terminate marking.
 59   //
 60   // However, when doing finalizable marking we don&#39;t always want to mark
 61   // through. First, marking through an already strongly marked oop would
 62   // be wasteful, since we will then proceed to do finalizable marking on
 63   // an object which is, or will be, marked strongly. Second, marking
 64   // through an already finalizable marked oop would also be wasteful,
 65   // since such oops can never end up on a mutator mark stack and can
 66   // therefore not hide some part of the object graph from GC workers.
 67   if (finalizable) {
 68     return !ZAddress::is_marked(addr);
 69   }
 70 
 71   // Mark through
 72   return true;
 73 }
 74 
<a name="3" id="anc3"></a><span class="line-modified"> 75 template &lt;bool finalizable, bool publish&gt;</span>
 76 uintptr_t ZBarrier::mark(uintptr_t addr) {
 77   uintptr_t good_addr;
 78 
 79   if (ZAddress::is_marked(addr)) {
 80     // Already marked, but try to mark though anyway
 81     good_addr = ZAddress::good(addr);
 82   } else if (ZAddress::is_remapped(addr)) {
 83     // Already remapped, but also needs to be marked
 84     good_addr = ZAddress::good(addr);
 85   } else {
 86     // Needs to be both remapped and marked
 87     good_addr = remap(addr);
 88   }
 89 
 90   // Mark
 91   if (should_mark_through&lt;finalizable&gt;(addr)) {
<a name="4" id="anc4"></a><span class="line-modified"> 92     ZHeap::heap()-&gt;mark_object&lt;finalizable, publish&gt;(good_addr);</span>











 93   }
 94 
 95   return good_addr;
 96 }
 97 
 98 uintptr_t ZBarrier::remap(uintptr_t addr) {
 99   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
100   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<a name="5" id="anc5"></a><span class="line-modified">101 </span>
<span class="line-removed">102   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">103     // Forward</span>
<span class="line-removed">104     return ZHeap::heap()-&gt;forward_object(addr);</span>
<span class="line-removed">105   }</span>
<span class="line-removed">106 </span>
<span class="line-removed">107   // Remap</span>
<span class="line-removed">108   return ZAddress::good(addr);</span>
109 }
110 
111 uintptr_t ZBarrier::relocate(uintptr_t addr) {
112   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
113   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<a name="6" id="anc6"></a><span class="line-modified">114 </span>
<span class="line-removed">115   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">116     // Relocate</span>
<span class="line-removed">117     return ZHeap::heap()-&gt;relocate_object(addr);</span>
<span class="line-removed">118   }</span>
<span class="line-removed">119 </span>
<span class="line-removed">120   // Remap</span>
<span class="line-removed">121   return ZAddress::good(addr);</span>
122 }
123 
124 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
<a name="7" id="anc7"></a><span class="line-modified">125   return during_relocate() ? relocate(addr) : mark&lt;Strong, Publish&gt;(addr);</span>
126 }
127 
128 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
129   return during_relocate() ? relocate(addr) : remap(addr);
130 }
131 
132 //
133 // Load barrier
134 //
135 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
136   return relocate_or_mark(addr);
137 }
138 
139 void ZBarrier::load_barrier_on_oop_fields(oop o) {
<a name="8" id="anc8"></a><span class="line-modified">140   assert(ZOop::is_good(o), &quot;Should be good&quot;);</span>
141   ZLoadBarrierOopClosure cl;
142   o-&gt;oop_iterate(&amp;cl);
143 }
144 
145 //
146 // Weak load barrier
147 //
148 uintptr_t ZBarrier::weak_load_barrier_on_oop_slow_path(uintptr_t addr) {
149   return ZAddress::is_weak_good(addr) ? ZAddress::good(addr) : relocate_or_remap(addr);
150 }
151 
152 uintptr_t ZBarrier::weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr) {
153   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
154   if (ZHeap::heap()-&gt;is_object_strongly_live(good_addr)) {
155     return good_addr;
156   }
157 
158   // Not strongly live
159   return 0;
160 }
161 
162 uintptr_t ZBarrier::weak_load_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
163   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
164   if (ZHeap::heap()-&gt;is_object_live(good_addr)) {
165     return good_addr;
166   }
167 
168   // Not live
169   return 0;
170 }
171 
172 //
173 // Keep alive barrier
174 //
175 uintptr_t ZBarrier::keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr) {
176   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
177   assert(ZHeap::heap()-&gt;is_object_strongly_live(good_addr), &quot;Should be live&quot;);
178   return good_addr;
179 }
180 
181 uintptr_t ZBarrier::keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
182   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
183   assert(ZHeap::heap()-&gt;is_object_live(good_addr), &quot;Should be live&quot;);
184   return good_addr;
185 }
186 
187 //
188 // Mark barrier
189 //
190 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
<a name="9" id="anc9"></a><span class="line-modified">191   return mark&lt;Strong, Overflow&gt;(addr);</span>



192 }
193 
194 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
<a name="10" id="anc10"></a><span class="line-modified">195   const uintptr_t good_addr = mark&lt;Finalizable, Overflow&gt;(addr);</span>
<span class="line-removed">196   if (ZAddress::is_good(addr)) {</span>
<span class="line-removed">197     // If the oop was already strongly marked/good, then we do</span>
<span class="line-removed">198     // not want to downgrade it to finalizable marked/good.</span>
<span class="line-removed">199     return good_addr;</span>
<span class="line-removed">200   }</span>
201 
<a name="11" id="anc11"></a><span class="line-modified">202   // Make the oop finalizable marked/good, instead of normal marked/good.</span>
<span class="line-modified">203   // This is needed because an object might first becomes finalizable</span>
<span class="line-removed">204   // marked by the GC, and then loaded by a mutator thread. In this case,</span>
<span class="line-removed">205   // the mutator thread must be able to tell that the object needs to be</span>
<span class="line-removed">206   // strongly marked. The finalizable bit in the oop exists to make sure</span>
<span class="line-removed">207   // that a load of a finalizable marked oop will fall into the barrier</span>
<span class="line-removed">208   // slow path so that we can mark the object as strongly reachable.</span>
<span class="line-removed">209   return ZAddress::finalizable_good(good_addr);</span>
210 }
211 
212 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
213   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
214   assert(during_mark(), &quot;Invalid phase&quot;);
215 
216   // Mark
<a name="12" id="anc12"></a><span class="line-modified">217   return mark&lt;Strong, Publish&gt;(addr);</span>








218 }
219 
220 //
221 // Relocate barrier
222 //
223 uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {
224   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
225   assert(during_relocate(), &quot;Invalid phase&quot;);
226 
227   // Relocate
228   return relocate(addr);
229 }
230 
231 //
232 // Narrow oop variants, never used.
233 //
234 oop ZBarrier::load_barrier_on_oop_field(volatile narrowOop* p) {
235   ShouldNotReachHere();
236   return NULL;
237 }
238 
239 oop ZBarrier::load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
240   ShouldNotReachHere();
241   return NULL;
242 }
243 
244 void ZBarrier::load_barrier_on_oop_array(volatile narrowOop* p, size_t length) {
245   ShouldNotReachHere();
246 }
247 
248 oop ZBarrier::load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
249   ShouldNotReachHere();
250   return NULL;
251 }
252 
253 oop ZBarrier::load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
254   ShouldNotReachHere();
255   return NULL;
256 }
257 
258 oop ZBarrier::weak_load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
259   ShouldNotReachHere();
260   return NULL;
261 }
262 
263 oop ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
264   ShouldNotReachHere();
265   return NULL;
266 }
267 
268 oop ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
269   ShouldNotReachHere();
270   return NULL;
271 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
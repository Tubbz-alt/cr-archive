<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zLock.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;

 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zMark.inline.hpp&quot;
 27 #include &quot;gc/z/zMarkCache.inline.hpp&quot;
 28 #include &quot;gc/z/zMarkStack.inline.hpp&quot;
 29 #include &quot;gc/z/zMarkTerminate.inline.hpp&quot;
 30 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 31 #include &quot;gc/z/zPage.hpp&quot;
 32 #include &quot;gc/z/zPageTable.inline.hpp&quot;
 33 #include &quot;gc/z/zRootsIterator.hpp&quot;
 34 #include &quot;gc/z/zStat.hpp&quot;
 35 #include &quot;gc/z/zTask.hpp&quot;
<span class="line-modified"> 36 #include &quot;gc/z/zThread.hpp&quot;</span>
 37 #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
 38 #include &quot;gc/z/zUtils.inline.hpp&quot;
 39 #include &quot;gc/z/zWorkers.inline.hpp&quot;
 40 #include &quot;logging/log.hpp&quot;
 41 #include &quot;memory/iterator.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;runtime/atomic.hpp&quot;
 45 #include &quot;runtime/handshake.hpp&quot;
<span class="line-removed"> 46 #include &quot;runtime/orderAccess.hpp&quot;</span>
 47 #include &quot;runtime/prefetch.inline.hpp&quot;

 48 #include &quot;runtime/thread.hpp&quot;
 49 #include &quot;utilities/align.hpp&quot;
 50 #include &quot;utilities/globalDefinitions.hpp&quot;

 51 #include &quot;utilities/ticks.hpp&quot;
 52 
 53 static const ZStatSubPhase ZSubPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
 54 static const ZStatSubPhase ZSubPhaseConcurrentMarkTryFlush(&quot;Concurrent Mark Try Flush&quot;);
 55 static const ZStatSubPhase ZSubPhaseConcurrentMarkIdle(&quot;Concurrent Mark Idle&quot;);
 56 static const ZStatSubPhase ZSubPhaseConcurrentMarkTryTerminate(&quot;Concurrent Mark Try Terminate&quot;);
 57 static const ZStatSubPhase ZSubPhaseMarkTryComplete(&quot;Pause Mark Try Complete&quot;);
 58 
<span class="line-modified"> 59 ZMark::ZMark(ZWorkers* workers, ZPageTable* pagetable) :</span>
 60     _workers(workers),
<span class="line-modified"> 61     _pagetable(pagetable),</span>
 62     _allocator(),
 63     _stripes(),
 64     _terminate(),
 65     _work_terminateflush(true),
 66     _work_nproactiveflush(0),
 67     _work_nterminateflush(0),
 68     _nproactiveflush(0),
 69     _nterminateflush(0),
 70     _ntrycomplete(0),
 71     _ncontinue(0),
 72     _nworkers(0) {}
 73 
 74 bool ZMark::is_initialized() const {
 75   return _allocator.is_initialized();
 76 }
 77 
 78 size_t ZMark::calculate_nstripes(uint nworkers) const {
 79   // Calculate the number of stripes from the number of workers we use,
 80   // where the number of stripes must be a power of two and we want to
 81   // have at least one worker per stripe.
<span class="line-modified"> 82   const size_t nstripes = ZUtils::round_down_power_of_2(nworkers);</span>
 83   return MIN2(nstripes, ZMarkStripesMax);
 84 }
 85 
 86 void ZMark::prepare_mark() {
 87   // Increment global sequence number to invalidate
 88   // marking information for all pages.
 89   ZGlobalSeqNum++;
 90 
 91   // Reset flush/continue counters
 92   _nproactiveflush = 0;
 93   _nterminateflush = 0;
 94   _ntrycomplete = 0;
 95   _ncontinue = 0;
 96 
 97   // Set number of workers to use
 98   _nworkers = _workers-&gt;nconcurrent();
 99 
100   // Set number of mark stripes to use, based on number
101   // of workers we will use in the concurrent mark phase.
102   const size_t nstripes = calculate_nstripes(_nworkers);
</pre>
<hr />
<pre>
115       log.print(&quot;  Worker %u(%u) -&gt; Stripe &quot; SIZE_FORMAT &quot;(&quot; SIZE_FORMAT &quot;)&quot;,
116                 worker_id, _nworkers, stripe_id, nstripes);
117     }
118   }
119 }
120 
121 class ZMarkRootsIteratorClosure : public ZRootsIteratorClosure {
122 public:
123   ZMarkRootsIteratorClosure() {
124     ZThreadLocalAllocBuffer::reset_statistics();
125   }
126 
127   ~ZMarkRootsIteratorClosure() {
128     ZThreadLocalAllocBuffer::publish_statistics();
129   }
130 
131   virtual void do_thread(Thread* thread) {
132     // Update thread local address bad mask
133     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
134 



135     // Retire TLAB
136     ZThreadLocalAllocBuffer::retire(thread);
137   }
138 




139   virtual void do_oop(oop* p) {
140     ZBarrier::mark_barrier_on_root_oop_field(p);
141   }
142 
143   virtual void do_oop(narrowOop* p) {
144     ShouldNotReachHere();
145   }
146 };
147 
148 class ZMarkRootsTask : public ZTask {
149 private:
150   ZMark* const              _mark;
151   ZRootsIterator            _roots;
152   ZMarkRootsIteratorClosure _cl;
153 
154 public:
155   ZMarkRootsTask(ZMark* mark) :
156       ZTask(&quot;ZMarkRootsTask&quot;),
157       _mark(mark),
<span class="line-modified">158       _roots() {}</span>
159 
160   virtual void work() {
161     _roots.oops_do(&amp;_cl);
162 
163     // Flush and free worker stacks. Needed here since
164     // the set of workers executing during root scanning
165     // can be different from the set of workers executing
166     // during mark.
167     _mark-&gt;flush_and_free();
168   }
169 };
170 
171 void ZMark::start() {
172   // Verification
173   if (ZVerifyMarking) {
174     verify_all_stacks_empty();
175   }
176 
177   // Prepare for concurrent mark
178   prepare_mark();
</pre>
<hr />
<pre>
183 }
184 
185 void ZMark::prepare_work() {
186   assert(_nworkers == _workers-&gt;nconcurrent(), &quot;Invalid number of workers&quot;);
187 
188   // Set number of active workers
189   _terminate.reset(_nworkers);
190 
191   // Reset flush counters
192   _work_nproactiveflush = _work_nterminateflush = 0;
193   _work_terminateflush = true;
194 }
195 
196 void ZMark::finish_work() {
197   // Accumulate proactive/terminate flush counters
198   _nproactiveflush += _work_nproactiveflush;
199   _nterminateflush += _work_nterminateflush;
200 }
201 
202 bool ZMark::is_array(uintptr_t addr) const {
<span class="line-modified">203   return ZOop::to_oop(addr)-&gt;is_objArray();</span>
204 }
205 
206 void ZMark::push_partial_array(uintptr_t addr, size_t size, bool finalizable) {
207   assert(is_aligned(addr, ZMarkPartialArrayMinSize), &quot;Address misaligned&quot;);
208   ZMarkThreadLocalStacks* const stacks = ZThreadLocalData::stacks(Thread::current());
209   ZMarkStripe* const stripe = _stripes.stripe_for_addr(addr);
210   const uintptr_t offset = ZAddress::offset(addr) &gt;&gt; ZMarkPartialArrayMinSizeShift;
211   const uintptr_t length = size / oopSize;
212   const ZMarkStackEntry entry(offset, length, finalizable);
213 
214   log_develop_trace(gc, marking)(&quot;Array push partial: &quot; PTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot;), stripe: &quot; SIZE_FORMAT,
215                                  addr, size, _stripes.stripe_id(stripe));
216 
217   stacks-&gt;push(&amp;_allocator, &amp;_stripes, stripe, entry, false /* publish */);
218 }
219 
220 void ZMark::follow_small_array(uintptr_t addr, size_t size, bool finalizable) {
221   assert(size &lt;= ZMarkPartialArrayMinSize, &quot;Too large, should be split&quot;);
222   const size_t length = size / oopSize;
223 
</pre>
<hr />
<pre>
290     cl.do_klass(obj-&gt;klass());
291   }
292 
293   const uintptr_t addr = (uintptr_t)obj-&gt;base();
294   const size_t size = (size_t)obj-&gt;length() * oopSize;
295 
296   follow_array(addr, size, finalizable);
297 }
298 
299 void ZMark::follow_object(oop obj, bool finalizable) {
300   if (finalizable) {
301     ZMarkBarrierOopClosure&lt;true /* finalizable */&gt; cl;
302     obj-&gt;oop_iterate(&amp;cl);
303   } else {
304     ZMarkBarrierOopClosure&lt;false /* finalizable */&gt; cl;
305     obj-&gt;oop_iterate(&amp;cl);
306   }
307 }
308 
309 bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {
<span class="line-modified">310   ZPage* const page = _pagetable-&gt;get(addr);</span>
311   if (page-&gt;is_allocating()) {
312     // Newly allocated objects are implicitly marked
313     return false;
314   }
315 
316   // Try mark object
317   bool inc_live = false;
318   const bool success = page-&gt;mark_object(addr, finalizable, inc_live);
319   if (inc_live) {
320     // Update live objects/bytes for page. We use the aligned object
321     // size since that is the actual number of bytes used on the page
322     // and alignment paddings can never be reclaimed.
323     const size_t size = ZUtils::object_size(addr);
324     const size_t aligned_size = align_up(size, page-&gt;object_alignment());
325     cache-&gt;inc_live(page, aligned_size);
326   }
327 
328   return success;
329 }
330 
331 void ZMark::mark_and_follow(ZMarkCache* cache, ZMarkStackEntry entry) {
332   // Decode flags
333   const bool finalizable = entry.finalizable();
334   const bool partial_array = entry.partial_array();
335 
336   if (partial_array) {
337     follow_partial_array(entry, finalizable);
338     return;
339   }
340 
<span class="line-modified">341   // Decode object address</span>
342   const uintptr_t addr = entry.object_address();
343 
344   if (!try_mark_object(cache, addr, finalizable)) {
345     // Already marked
346     return;
347   }
348 
349   if (is_array(addr)) {
<span class="line-modified">350     follow_array_object(objArrayOop(ZOop::to_oop(addr)), finalizable);</span>






351   } else {
<span class="line-modified">352     follow_object(ZOop::to_oop(addr), finalizable);</span>
353   }
354 }
355 
356 template &lt;typename T&gt;
357 bool ZMark::drain(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks, ZMarkCache* cache, T* timeout) {
358   ZMarkStackEntry entry;
359 
360   // Drain stripe stacks
361   while (stacks-&gt;pop(&amp;_allocator, &amp;_stripes, stripe, entry)) {
362     mark_and_follow(cache, entry);
363 
364     // Check timeout
365     if (timeout-&gt;has_expired()) {
366       // Timeout
367       return false;
368     }
369   }
370 
371   // Success
372   return true;
</pre>
<hr />
<pre>
387   for (ZMarkStripe* victim_stripe = _stripes.stripe_next(stripe);
388        victim_stripe != stripe;
389        victim_stripe = _stripes.stripe_next(victim_stripe)) {
390     ZMarkStack* const stack = victim_stripe-&gt;steal_stack();
391     if (stack != NULL) {
392       // Success, install the stolen stack
393       stacks-&gt;install(&amp;_stripes, stripe, stack);
394       return true;
395     }
396   }
397 
398   // Nothing to steal
399   return false;
400 }
401 
402 void ZMark::idle() const {
403   ZStatTimer timer(ZSubPhaseConcurrentMarkIdle);
404   os::naked_short_sleep(1);
405 }
406 
<span class="line-modified">407 class ZMarkFlushAndFreeStacksClosure : public ThreadClosure {</span>
408 private:
409   ZMark* const _mark;
410   bool         _flushed;
411 
412 public:
413   ZMarkFlushAndFreeStacksClosure(ZMark* mark) :

414       _mark(mark),
415       _flushed(false) {}
416 
417   void do_thread(Thread* thread) {
418     if (_mark-&gt;flush_and_free(thread)) {
419       _flushed = true;
420     }
421   }
422 
423   bool flushed() const {
424     return _flushed;
425   }
426 };
427 
428 bool ZMark::flush(bool at_safepoint) {
429   ZMarkFlushAndFreeStacksClosure cl(this);
430   if (at_safepoint) {
431     Threads::threads_do(&amp;cl);
432   } else {
433     Handshake::execute(&amp;cl);
434   }
435 
436   // Returns true if more work is available
437   return cl.flushed() || !_stripes.is_empty();
438 }
439 
440 bool ZMark::try_flush(volatile size_t* nflush) {
441   // Only flush if handshakes are enabled
<span class="line-modified">442   if (!ThreadLocalHandshakes) {</span>
443     return false;
444   }
445 
446   Atomic::inc(nflush);
447 
448   ZStatTimer timer(ZSubPhaseConcurrentMarkTryFlush);
449   return flush(false /* at_safepoint */);
450 }
451 
452 bool ZMark::try_proactive_flush() {
453   // Only do proactive flushes from worker 0
454   if (ZThread::worker_id() != 0) {
455     return false;
456   }
457 
458   if (Atomic::load(&amp;_work_nproactiveflush) == ZMarkProactiveFlushMax ||
459       Atomic::load(&amp;_work_nterminateflush) != 0) {
460     // Limit reached or we&#39;re trying to terminate
461     return false;
462   }
463 
464   return try_flush(&amp;_work_nproactiveflush);
465 }
466 
467 bool ZMark::try_terminate() {
468   ZStatTimer timer(ZSubPhaseConcurrentMarkTryTerminate);
469 
470   if (_terminate.enter_stage0()) {
471     // Last thread entered stage 0, flush
472     if (Atomic::load(&amp;_work_terminateflush) &amp;&amp;
473         Atomic::load(&amp;_work_nterminateflush) != ZMarkTerminateFlushMax) {
474       // Exit stage 0 to allow other threads to continue marking
475       _terminate.exit_stage0();
476 
477       // Flush before termination
478       if (!try_flush(&amp;_work_nterminateflush)) {
479         // No more work available, skip further flush attempts
<span class="line-modified">480         Atomic::store(false, &amp;_work_terminateflush);</span>
481       }
482 
483       // Don&#39;t terminate, regardless of whether we successfully
484       // flushed out more work or not. We&#39;ve already exited
485       // termination stage 0, to allow other threads to continue
486       // marking, so this thread has to return false and also
487       // make another round of attempted marking.
488       return false;
489     }
490   }
491 
492   for (;;) {
493     if (_terminate.enter_stage1()) {
494       // Last thread entered stage 1, terminate
495       return true;
496     }
497 
498     // Idle to give the other threads
499     // a chance to enter termination.
500     idle();
</pre>
<hr />
<pre>
615   assert(stacks-&gt;is_empty(&amp;_stripes), &quot;Should be empty&quot;);
616 
617   // Free remaining stacks
618   stacks-&gt;free(&amp;_allocator);
619 }
620 
621 class ZMarkConcurrentRootsIteratorClosure : public ZRootsIteratorClosure {
622 public:
623   virtual void do_oop(oop* p) {
624     ZBarrier::mark_barrier_on_oop_field(p, false /* finalizable */);
625   }
626 
627   virtual void do_oop(narrowOop* p) {
628     ShouldNotReachHere();
629   }
630 };
631 
632 
633 class ZMarkConcurrentRootsTask : public ZTask {
634 private:
<span class="line-modified">635   ZConcurrentRootsIterator            _roots;</span>

636   ZMarkConcurrentRootsIteratorClosure _cl;
637 
638 public:
639   ZMarkConcurrentRootsTask(ZMark* mark) :
640       ZTask(&quot;ZMarkConcurrentRootsTask&quot;),
<span class="line-modified">641       _roots(true /* marking */),</span>
<span class="line-modified">642       _cl() {}</span>







643 
644   virtual void work() {
645     _roots.oops_do(&amp;_cl);
646   }
647 };
648 
649 class ZMarkTask : public ZTask {
650 private:
651   ZMark* const   _mark;
652   const uint64_t _timeout_in_millis;
653 
654 public:
655   ZMarkTask(ZMark* mark, uint64_t timeout_in_millis = 0) :
656       ZTask(&quot;ZMarkTask&quot;),
657       _mark(mark),
658       _timeout_in_millis(timeout_in_millis) {
659     _mark-&gt;prepare_work();
660   }
661 
662   ~ZMarkTask() {
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 25 #include &quot;classfile/classLoaderDataGraph.hpp&quot;</span>
 26 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 27 #include &quot;gc/z/zMark.inline.hpp&quot;
 28 #include &quot;gc/z/zMarkCache.inline.hpp&quot;
 29 #include &quot;gc/z/zMarkStack.inline.hpp&quot;
 30 #include &quot;gc/z/zMarkTerminate.inline.hpp&quot;
 31 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 32 #include &quot;gc/z/zPage.hpp&quot;
 33 #include &quot;gc/z/zPageTable.inline.hpp&quot;
 34 #include &quot;gc/z/zRootsIterator.hpp&quot;
 35 #include &quot;gc/z/zStat.hpp&quot;
 36 #include &quot;gc/z/zTask.hpp&quot;
<span class="line-modified"> 37 #include &quot;gc/z/zThread.inline.hpp&quot;</span>
 38 #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
 39 #include &quot;gc/z/zUtils.inline.hpp&quot;
 40 #include &quot;gc/z/zWorkers.inline.hpp&quot;
 41 #include &quot;logging/log.hpp&quot;
 42 #include &quot;memory/iterator.inline.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handshake.hpp&quot;

 47 #include &quot;runtime/prefetch.inline.hpp&quot;
<span class="line-added"> 48 #include &quot;runtime/safepointMechanism.hpp&quot;</span>
 49 #include &quot;runtime/thread.hpp&quot;
 50 #include &quot;utilities/align.hpp&quot;
 51 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added"> 52 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 53 #include &quot;utilities/ticks.hpp&quot;
 54 
 55 static const ZStatSubPhase ZSubPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
 56 static const ZStatSubPhase ZSubPhaseConcurrentMarkTryFlush(&quot;Concurrent Mark Try Flush&quot;);
 57 static const ZStatSubPhase ZSubPhaseConcurrentMarkIdle(&quot;Concurrent Mark Idle&quot;);
 58 static const ZStatSubPhase ZSubPhaseConcurrentMarkTryTerminate(&quot;Concurrent Mark Try Terminate&quot;);
 59 static const ZStatSubPhase ZSubPhaseMarkTryComplete(&quot;Pause Mark Try Complete&quot;);
 60 
<span class="line-modified"> 61 ZMark::ZMark(ZWorkers* workers, ZPageTable* page_table) :</span>
 62     _workers(workers),
<span class="line-modified"> 63     _page_table(page_table),</span>
 64     _allocator(),
 65     _stripes(),
 66     _terminate(),
 67     _work_terminateflush(true),
 68     _work_nproactiveflush(0),
 69     _work_nterminateflush(0),
 70     _nproactiveflush(0),
 71     _nterminateflush(0),
 72     _ntrycomplete(0),
 73     _ncontinue(0),
 74     _nworkers(0) {}
 75 
 76 bool ZMark::is_initialized() const {
 77   return _allocator.is_initialized();
 78 }
 79 
 80 size_t ZMark::calculate_nstripes(uint nworkers) const {
 81   // Calculate the number of stripes from the number of workers we use,
 82   // where the number of stripes must be a power of two and we want to
 83   // have at least one worker per stripe.
<span class="line-modified"> 84   const size_t nstripes = round_down_power_of_2(nworkers);</span>
 85   return MIN2(nstripes, ZMarkStripesMax);
 86 }
 87 
 88 void ZMark::prepare_mark() {
 89   // Increment global sequence number to invalidate
 90   // marking information for all pages.
 91   ZGlobalSeqNum++;
 92 
 93   // Reset flush/continue counters
 94   _nproactiveflush = 0;
 95   _nterminateflush = 0;
 96   _ntrycomplete = 0;
 97   _ncontinue = 0;
 98 
 99   // Set number of workers to use
100   _nworkers = _workers-&gt;nconcurrent();
101 
102   // Set number of mark stripes to use, based on number
103   // of workers we will use in the concurrent mark phase.
104   const size_t nstripes = calculate_nstripes(_nworkers);
</pre>
<hr />
<pre>
117       log.print(&quot;  Worker %u(%u) -&gt; Stripe &quot; SIZE_FORMAT &quot;(&quot; SIZE_FORMAT &quot;)&quot;,
118                 worker_id, _nworkers, stripe_id, nstripes);
119     }
120   }
121 }
122 
123 class ZMarkRootsIteratorClosure : public ZRootsIteratorClosure {
124 public:
125   ZMarkRootsIteratorClosure() {
126     ZThreadLocalAllocBuffer::reset_statistics();
127   }
128 
129   ~ZMarkRootsIteratorClosure() {
130     ZThreadLocalAllocBuffer::publish_statistics();
131   }
132 
133   virtual void do_thread(Thread* thread) {
134     // Update thread local address bad mask
135     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
136 
<span class="line-added">137     // Mark invisible root</span>
<span class="line-added">138     ZThreadLocalData::do_invisible_root(thread, ZBarrier::mark_barrier_on_invisible_root_oop_field);</span>
<span class="line-added">139 </span>
140     // Retire TLAB
141     ZThreadLocalAllocBuffer::retire(thread);
142   }
143 
<span class="line-added">144   virtual bool should_disarm_nmethods() const {</span>
<span class="line-added">145     return true;</span>
<span class="line-added">146   }</span>
<span class="line-added">147 </span>
148   virtual void do_oop(oop* p) {
149     ZBarrier::mark_barrier_on_root_oop_field(p);
150   }
151 
152   virtual void do_oop(narrowOop* p) {
153     ShouldNotReachHere();
154   }
155 };
156 
157 class ZMarkRootsTask : public ZTask {
158 private:
159   ZMark* const              _mark;
160   ZRootsIterator            _roots;
161   ZMarkRootsIteratorClosure _cl;
162 
163 public:
164   ZMarkRootsTask(ZMark* mark) :
165       ZTask(&quot;ZMarkRootsTask&quot;),
166       _mark(mark),
<span class="line-modified">167       _roots(false /* visit_jvmti_weak_export */) {}</span>
168 
169   virtual void work() {
170     _roots.oops_do(&amp;_cl);
171 
172     // Flush and free worker stacks. Needed here since
173     // the set of workers executing during root scanning
174     // can be different from the set of workers executing
175     // during mark.
176     _mark-&gt;flush_and_free();
177   }
178 };
179 
180 void ZMark::start() {
181   // Verification
182   if (ZVerifyMarking) {
183     verify_all_stacks_empty();
184   }
185 
186   // Prepare for concurrent mark
187   prepare_mark();
</pre>
<hr />
<pre>
192 }
193 
194 void ZMark::prepare_work() {
195   assert(_nworkers == _workers-&gt;nconcurrent(), &quot;Invalid number of workers&quot;);
196 
197   // Set number of active workers
198   _terminate.reset(_nworkers);
199 
200   // Reset flush counters
201   _work_nproactiveflush = _work_nterminateflush = 0;
202   _work_terminateflush = true;
203 }
204 
205 void ZMark::finish_work() {
206   // Accumulate proactive/terminate flush counters
207   _nproactiveflush += _work_nproactiveflush;
208   _nterminateflush += _work_nterminateflush;
209 }
210 
211 bool ZMark::is_array(uintptr_t addr) const {
<span class="line-modified">212   return ZOop::from_address(addr)-&gt;is_objArray();</span>
213 }
214 
215 void ZMark::push_partial_array(uintptr_t addr, size_t size, bool finalizable) {
216   assert(is_aligned(addr, ZMarkPartialArrayMinSize), &quot;Address misaligned&quot;);
217   ZMarkThreadLocalStacks* const stacks = ZThreadLocalData::stacks(Thread::current());
218   ZMarkStripe* const stripe = _stripes.stripe_for_addr(addr);
219   const uintptr_t offset = ZAddress::offset(addr) &gt;&gt; ZMarkPartialArrayMinSizeShift;
220   const uintptr_t length = size / oopSize;
221   const ZMarkStackEntry entry(offset, length, finalizable);
222 
223   log_develop_trace(gc, marking)(&quot;Array push partial: &quot; PTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot;), stripe: &quot; SIZE_FORMAT,
224                                  addr, size, _stripes.stripe_id(stripe));
225 
226   stacks-&gt;push(&amp;_allocator, &amp;_stripes, stripe, entry, false /* publish */);
227 }
228 
229 void ZMark::follow_small_array(uintptr_t addr, size_t size, bool finalizable) {
230   assert(size &lt;= ZMarkPartialArrayMinSize, &quot;Too large, should be split&quot;);
231   const size_t length = size / oopSize;
232 
</pre>
<hr />
<pre>
299     cl.do_klass(obj-&gt;klass());
300   }
301 
302   const uintptr_t addr = (uintptr_t)obj-&gt;base();
303   const size_t size = (size_t)obj-&gt;length() * oopSize;
304 
305   follow_array(addr, size, finalizable);
306 }
307 
308 void ZMark::follow_object(oop obj, bool finalizable) {
309   if (finalizable) {
310     ZMarkBarrierOopClosure&lt;true /* finalizable */&gt; cl;
311     obj-&gt;oop_iterate(&amp;cl);
312   } else {
313     ZMarkBarrierOopClosure&lt;false /* finalizable */&gt; cl;
314     obj-&gt;oop_iterate(&amp;cl);
315   }
316 }
317 
318 bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {
<span class="line-modified">319   ZPage* const page = _page_table-&gt;get(addr);</span>
320   if (page-&gt;is_allocating()) {
321     // Newly allocated objects are implicitly marked
322     return false;
323   }
324 
325   // Try mark object
326   bool inc_live = false;
327   const bool success = page-&gt;mark_object(addr, finalizable, inc_live);
328   if (inc_live) {
329     // Update live objects/bytes for page. We use the aligned object
330     // size since that is the actual number of bytes used on the page
331     // and alignment paddings can never be reclaimed.
332     const size_t size = ZUtils::object_size(addr);
333     const size_t aligned_size = align_up(size, page-&gt;object_alignment());
334     cache-&gt;inc_live(page, aligned_size);
335   }
336 
337   return success;
338 }
339 
340 void ZMark::mark_and_follow(ZMarkCache* cache, ZMarkStackEntry entry) {
341   // Decode flags
342   const bool finalizable = entry.finalizable();
343   const bool partial_array = entry.partial_array();
344 
345   if (partial_array) {
346     follow_partial_array(entry, finalizable);
347     return;
348   }
349 
<span class="line-modified">350   // Decode object address and follow flag</span>
351   const uintptr_t addr = entry.object_address();
352 
353   if (!try_mark_object(cache, addr, finalizable)) {
354     // Already marked
355     return;
356   }
357 
358   if (is_array(addr)) {
<span class="line-modified">359     // Decode follow flag</span>
<span class="line-added">360     const bool follow = entry.follow();</span>
<span class="line-added">361 </span>
<span class="line-added">362     // The follow flag is currently only relevant for object arrays</span>
<span class="line-added">363     if (follow) {</span>
<span class="line-added">364       follow_array_object(objArrayOop(ZOop::from_address(addr)), finalizable);</span>
<span class="line-added">365     }</span>
366   } else {
<span class="line-modified">367     follow_object(ZOop::from_address(addr), finalizable);</span>
368   }
369 }
370 
371 template &lt;typename T&gt;
372 bool ZMark::drain(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks, ZMarkCache* cache, T* timeout) {
373   ZMarkStackEntry entry;
374 
375   // Drain stripe stacks
376   while (stacks-&gt;pop(&amp;_allocator, &amp;_stripes, stripe, entry)) {
377     mark_and_follow(cache, entry);
378 
379     // Check timeout
380     if (timeout-&gt;has_expired()) {
381       // Timeout
382       return false;
383     }
384   }
385 
386   // Success
387   return true;
</pre>
<hr />
<pre>
402   for (ZMarkStripe* victim_stripe = _stripes.stripe_next(stripe);
403        victim_stripe != stripe;
404        victim_stripe = _stripes.stripe_next(victim_stripe)) {
405     ZMarkStack* const stack = victim_stripe-&gt;steal_stack();
406     if (stack != NULL) {
407       // Success, install the stolen stack
408       stacks-&gt;install(&amp;_stripes, stripe, stack);
409       return true;
410     }
411   }
412 
413   // Nothing to steal
414   return false;
415 }
416 
417 void ZMark::idle() const {
418   ZStatTimer timer(ZSubPhaseConcurrentMarkIdle);
419   os::naked_short_sleep(1);
420 }
421 
<span class="line-modified">422 class ZMarkFlushAndFreeStacksClosure : public HandshakeClosure {</span>
423 private:
424   ZMark* const _mark;
425   bool         _flushed;
426 
427 public:
428   ZMarkFlushAndFreeStacksClosure(ZMark* mark) :
<span class="line-added">429       HandshakeClosure(&quot;ZMarkFlushAndFreeStacks&quot;),</span>
430       _mark(mark),
431       _flushed(false) {}
432 
433   void do_thread(Thread* thread) {
434     if (_mark-&gt;flush_and_free(thread)) {
435       _flushed = true;
436     }
437   }
438 
439   bool flushed() const {
440     return _flushed;
441   }
442 };
443 
444 bool ZMark::flush(bool at_safepoint) {
445   ZMarkFlushAndFreeStacksClosure cl(this);
446   if (at_safepoint) {
447     Threads::threads_do(&amp;cl);
448   } else {
449     Handshake::execute(&amp;cl);
450   }
451 
452   // Returns true if more work is available
453   return cl.flushed() || !_stripes.is_empty();
454 }
455 
456 bool ZMark::try_flush(volatile size_t* nflush) {
457   // Only flush if handshakes are enabled
<span class="line-modified">458   if (!SafepointMechanism::uses_thread_local_poll()) {</span>
459     return false;
460   }
461 
462   Atomic::inc(nflush);
463 
464   ZStatTimer timer(ZSubPhaseConcurrentMarkTryFlush);
465   return flush(false /* at_safepoint */);
466 }
467 
468 bool ZMark::try_proactive_flush() {
469   // Only do proactive flushes from worker 0
470   if (ZThread::worker_id() != 0) {
471     return false;
472   }
473 
474   if (Atomic::load(&amp;_work_nproactiveflush) == ZMarkProactiveFlushMax ||
475       Atomic::load(&amp;_work_nterminateflush) != 0) {
476     // Limit reached or we&#39;re trying to terminate
477     return false;
478   }
479 
480   return try_flush(&amp;_work_nproactiveflush);
481 }
482 
483 bool ZMark::try_terminate() {
484   ZStatTimer timer(ZSubPhaseConcurrentMarkTryTerminate);
485 
486   if (_terminate.enter_stage0()) {
487     // Last thread entered stage 0, flush
488     if (Atomic::load(&amp;_work_terminateflush) &amp;&amp;
489         Atomic::load(&amp;_work_nterminateflush) != ZMarkTerminateFlushMax) {
490       // Exit stage 0 to allow other threads to continue marking
491       _terminate.exit_stage0();
492 
493       // Flush before termination
494       if (!try_flush(&amp;_work_nterminateflush)) {
495         // No more work available, skip further flush attempts
<span class="line-modified">496         Atomic::store(&amp;_work_terminateflush, false);</span>
497       }
498 
499       // Don&#39;t terminate, regardless of whether we successfully
500       // flushed out more work or not. We&#39;ve already exited
501       // termination stage 0, to allow other threads to continue
502       // marking, so this thread has to return false and also
503       // make another round of attempted marking.
504       return false;
505     }
506   }
507 
508   for (;;) {
509     if (_terminate.enter_stage1()) {
510       // Last thread entered stage 1, terminate
511       return true;
512     }
513 
514     // Idle to give the other threads
515     // a chance to enter termination.
516     idle();
</pre>
<hr />
<pre>
631   assert(stacks-&gt;is_empty(&amp;_stripes), &quot;Should be empty&quot;);
632 
633   // Free remaining stacks
634   stacks-&gt;free(&amp;_allocator);
635 }
636 
637 class ZMarkConcurrentRootsIteratorClosure : public ZRootsIteratorClosure {
638 public:
639   virtual void do_oop(oop* p) {
640     ZBarrier::mark_barrier_on_oop_field(p, false /* finalizable */);
641   }
642 
643   virtual void do_oop(narrowOop* p) {
644     ShouldNotReachHere();
645   }
646 };
647 
648 
649 class ZMarkConcurrentRootsTask : public ZTask {
650 private:
<span class="line-modified">651   SuspendibleThreadSetJoiner          _sts_joiner;</span>
<span class="line-added">652   ZConcurrentRootsIteratorClaimStrong _roots;</span>
653   ZMarkConcurrentRootsIteratorClosure _cl;
654 
655 public:
656   ZMarkConcurrentRootsTask(ZMark* mark) :
657       ZTask(&quot;ZMarkConcurrentRootsTask&quot;),
<span class="line-modified">658       _sts_joiner(),</span>
<span class="line-modified">659       _roots(),</span>
<span class="line-added">660       _cl() {</span>
<span class="line-added">661     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="line-added">662   }</span>
<span class="line-added">663 </span>
<span class="line-added">664   ~ZMarkConcurrentRootsTask() {</span>
<span class="line-added">665     ClassLoaderDataGraph_lock-&gt;unlock();</span>
<span class="line-added">666   }</span>
667 
668   virtual void work() {
669     _roots.oops_do(&amp;_cl);
670   }
671 };
672 
673 class ZMarkTask : public ZTask {
674 private:
675   ZMark* const   _mark;
676   const uint64_t _timeout_in_millis;
677 
678 public:
679   ZMarkTask(ZMark* mark, uint64_t timeout_in_millis = 0) :
680       ZTask(&quot;ZMarkTask&quot;),
681       _mark(mark),
682       _timeout_in_millis(timeout_in_millis) {
683     _mark-&gt;prepare_work();
684   }
685 
686   ~ZMarkTask() {
</pre>
</td>
</tr>
</table>
<center><a href="zLock.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
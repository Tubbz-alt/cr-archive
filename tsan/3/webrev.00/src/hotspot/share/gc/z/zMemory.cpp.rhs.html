<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 
<a name="2" id="anc2"></a><span class="line-added"> 29 ZMemory* ZMemoryManager::create(uintptr_t start, size_t size) {</span>
<span class="line-added"> 30   ZMemory* const area = new ZMemory(start, size);</span>
<span class="line-added"> 31   if (_callbacks._create != NULL) {</span>
<span class="line-added"> 32     _callbacks._create(area);</span>
<span class="line-added"> 33   }</span>
<span class="line-added"> 34   return area;</span>
<span class="line-added"> 35 }</span>
<span class="line-added"> 36 </span>
<span class="line-added"> 37 void ZMemoryManager::destroy(ZMemory* area) {</span>
<span class="line-added"> 38   if (_callbacks._destroy != NULL) {</span>
<span class="line-added"> 39     _callbacks._destroy(area);</span>
<span class="line-added"> 40   }</span>
<span class="line-added"> 41   delete area;</span>
<span class="line-added"> 42 }</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 void ZMemoryManager::shrink_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added"> 45   if (_callbacks._shrink_from_front != NULL) {</span>
<span class="line-added"> 46     _callbacks._shrink_from_front(area, size);</span>
<span class="line-added"> 47   }</span>
<span class="line-added"> 48   area-&gt;shrink_from_front(size);</span>
<span class="line-added"> 49 }</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 void ZMemoryManager::shrink_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added"> 52   if (_callbacks._shrink_from_back != NULL) {</span>
<span class="line-added"> 53     _callbacks._shrink_from_back(area, size);</span>
<span class="line-added"> 54   }</span>
<span class="line-added"> 55   area-&gt;shrink_from_back(size);</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 void ZMemoryManager::grow_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added"> 59   if (_callbacks._grow_from_front != NULL) {</span>
<span class="line-added"> 60     _callbacks._grow_from_front(area, size);</span>
<span class="line-added"> 61   }</span>
<span class="line-added"> 62   area-&gt;grow_from_front(size);</span>
<span class="line-added"> 63 }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65 void ZMemoryManager::grow_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added"> 66   if (_callbacks._grow_from_back != NULL) {</span>
<span class="line-added"> 67     _callbacks._grow_from_back(area, size);</span>
<span class="line-added"> 68   }</span>
<span class="line-added"> 69   area-&gt;grow_from_back(size);</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 ZMemoryManager::Callbacks::Callbacks() :</span>
<span class="line-added"> 73     _create(NULL),</span>
<span class="line-added"> 74     _destroy(NULL),</span>
<span class="line-added"> 75     _shrink_from_front(NULL),</span>
<span class="line-added"> 76     _shrink_from_back(NULL),</span>
<span class="line-added"> 77     _grow_from_front(NULL),</span>
<span class="line-added"> 78     _grow_from_back(NULL) {}</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80 ZMemoryManager::ZMemoryManager() :</span>
<span class="line-added"> 81     _freelist(),</span>
<span class="line-added"> 82     _callbacks() {}</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 void ZMemoryManager::register_callbacks(const Callbacks&amp; callbacks) {</span>
<span class="line-added"> 85   _callbacks = callbacks;</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
 88 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 89   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 90   for (ZMemory* area; iter.next(&amp;area);) {
 91     if (area-&gt;size() &gt;= size) {
 92       if (area-&gt;size() == size) {
 93         // Exact match, remove area
 94         const uintptr_t start = area-&gt;start();
 95         _freelist.remove(area);
<a name="3" id="anc3"></a><span class="line-modified"> 96         destroy(area);</span>
 97         return start;
 98       } else {
 99         // Larger than requested, shrink area
100         const uintptr_t start = area-&gt;start();
<a name="4" id="anc4"></a><span class="line-modified">101         shrink_from_front(area, size);</span>
102         return start;
103       }
104     }
105   }
106 
107   // Out of memory
108   return UINTPTR_MAX;
109 }
110 
<a name="5" id="anc5"></a><span class="line-added">111 uintptr_t ZMemoryManager::alloc_from_front_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">112   ZMemory* area = _freelist.first();</span>
<span class="line-added">113   if (area != NULL) {</span>
<span class="line-added">114     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">115       // Smaller than or equal to requested, remove area</span>
<span class="line-added">116       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">117       *allocated = area-&gt;size();</span>
<span class="line-added">118       _freelist.remove(area);</span>
<span class="line-added">119       destroy(area);</span>
<span class="line-added">120       return start;</span>
<span class="line-added">121     } else {</span>
<span class="line-added">122       // Larger than requested, shrink area</span>
<span class="line-added">123       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">124       shrink_from_front(area, size);</span>
<span class="line-added">125       *allocated = size;</span>
<span class="line-added">126       return start;</span>
<span class="line-added">127     }</span>
<span class="line-added">128   }</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Out of memory</span>
<span class="line-added">131   *allocated = 0;</span>
<span class="line-added">132   return UINTPTR_MAX;</span>
<span class="line-added">133 }</span>
<span class="line-added">134 </span>
135 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
136   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
137   for (ZMemory* area; iter.next(&amp;area);) {
138     if (area-&gt;size() &gt;= size) {
139       if (area-&gt;size() == size) {
140         // Exact match, remove area
141         const uintptr_t start = area-&gt;start();
142         _freelist.remove(area);
<a name="6" id="anc6"></a><span class="line-modified">143         destroy(area);</span>
144         return start;
145       } else {
146         // Larger than requested, shrink area
<a name="7" id="anc7"></a><span class="line-modified">147         shrink_from_back(area, size);</span>
148         return area-&gt;end();
149       }
150     }
151   }
152 
153   // Out of memory
154   return UINTPTR_MAX;
155 }
156 
<a name="8" id="anc8"></a><span class="line-added">157 uintptr_t ZMemoryManager::alloc_from_back_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">158   ZMemory* area = _freelist.last();</span>
<span class="line-added">159   if (area != NULL) {</span>
<span class="line-added">160     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">161       // Smaller than or equal to requested, remove area</span>
<span class="line-added">162       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">163       *allocated = area-&gt;size();</span>
<span class="line-added">164       _freelist.remove(area);</span>
<span class="line-added">165       destroy(area);</span>
<span class="line-added">166       return start;</span>
<span class="line-added">167     } else {</span>
<span class="line-added">168       // Larger than requested, shrink area</span>
<span class="line-added">169       shrink_from_back(area, size);</span>
<span class="line-added">170       *allocated = size;</span>
<span class="line-added">171       return area-&gt;end();</span>
<span class="line-added">172     }</span>
<span class="line-added">173   }</span>
<span class="line-added">174 </span>
<span class="line-added">175   // Out of memory</span>
<span class="line-added">176   *allocated = 0;</span>
<span class="line-added">177   return UINTPTR_MAX;</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
180 void ZMemoryManager::free(uintptr_t start, size_t size) {
181   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
182   const uintptr_t end = start + size;
183 
184   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
185   for (ZMemory* area; iter.next(&amp;area);) {
186     if (start &lt; area-&gt;start()) {
187       ZMemory* const prev = _freelist.prev(area);
188       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
189         if (end == area-&gt;start()) {
190           // Merge with prev and current area
<a name="9" id="anc9"></a><span class="line-modified">191           grow_from_back(prev, size + area-&gt;size());</span>
192           _freelist.remove(area);
193           delete area;
194         } else {
195           // Merge with prev area
<a name="10" id="anc10"></a><span class="line-modified">196           grow_from_back(prev, size);</span>
197         }
198       } else if (end == area-&gt;start()) {
199         // Merge with current area
<a name="11" id="anc11"></a><span class="line-modified">200         grow_from_front(area, size);</span>
201       } else {
202         // Insert new area before current area
203         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<a name="12" id="anc12"></a><span class="line-modified">204         ZMemory* const new_area = create(start, size);</span>
205         _freelist.insert_before(area, new_area);
206       }
207 
208       // Done
209       return;
210     }
211   }
212 
213   // Insert last
214   ZMemory* const last = _freelist.last();
215   if (last != NULL &amp;&amp; start == last-&gt;end()) {
216     // Merge with last area
<a name="13" id="anc13"></a><span class="line-modified">217     grow_from_back(last, size);</span>
218   } else {
219     // Insert new area last
<a name="14" id="anc14"></a><span class="line-modified">220     ZMemory* const new_area = create(start, size);</span>
221     _freelist.insert_last(new_area);
222   }
223 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
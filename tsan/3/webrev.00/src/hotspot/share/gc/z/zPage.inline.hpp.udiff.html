<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zPage.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zPage.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zPage.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,23 +23,33 @@</span>
  
  #ifndef SHARE_GC_Z_ZPAGE_INLINE_HPP
  #define SHARE_GC_Z_ZPAGE_INLINE_HPP
  
  #include &quot;gc/z/zAddress.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/z/zForwardingTable.inline.hpp&quot;</span>
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zLiveMap.inline.hpp&quot;
  #include &quot;gc/z/zMark.hpp&quot;
  #include &quot;gc/z/zNUMA.hpp&quot;
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zPhysicalMemory.inline.hpp&quot;
  #include &quot;gc/z/zVirtualMemory.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/os.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
<span class="udiff-line-added">+ inline uint8_t ZPage::type_from_size(size_t size) const {</span>
<span class="udiff-line-added">+   if (size == ZPageSizeSmall) {</span>
<span class="udiff-line-added">+     return ZPageTypeSmall;</span>
<span class="udiff-line-added">+   } else if (size == ZPageSizeMedium) {</span>
<span class="udiff-line-added">+     return ZPageTypeMedium;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return ZPageTypeLarge;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline const char* ZPage::type_to_string() const {
    switch (type()) {
    case ZPageTypeSmall:
      return &quot;Small&quot;;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -114,71 +124,32 @@</span>
  
  inline size_t ZPage::remaining() const {
    return end() - top();
  }
  
<span class="udiff-line-modified-removed">- inline ZPhysicalMemory&amp; ZPage::physical_memory() {</span>
<span class="udiff-line-modified-added">+ inline const ZPhysicalMemory&amp; ZPage::physical_memory() const {</span>
    return _physical;
  }
  
  inline const ZVirtualMemory&amp; ZPage::virtual_memory() const {
    return _virtual;
  }
  
  inline uint8_t ZPage::numa_id() {
    if (_numa_id == (uint8_t)-1) {
<span class="udiff-line-modified-removed">-     _numa_id = (uint8_t)ZNUMA::memory_id(ZAddress::good(start()));</span>
<span class="udiff-line-modified-added">+     _numa_id = ZNUMA::memory_id(ZAddress::good(start()));</span>
    }
  
    return _numa_id;
  }
  
<span class="udiff-line-removed">- inline bool ZPage::inc_refcount() {</span>
<span class="udiff-line-removed">-   for (uint32_t prev_refcount = _refcount; prev_refcount &gt; 0; prev_refcount = _refcount) {</span>
<span class="udiff-line-removed">-     if (Atomic::cmpxchg(prev_refcount + 1, &amp;_refcount, prev_refcount) == prev_refcount) {</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool ZPage::dec_refcount() {</span>
<span class="udiff-line-removed">-   assert(is_active(), &quot;Should be active&quot;);</span>
<span class="udiff-line-removed">-   return Atomic::sub(1u, &amp;_refcount) == 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool ZPage::is_in(uintptr_t addr) const {</span>
<span class="udiff-line-removed">-   const uintptr_t offset = ZAddress::offset(addr);</span>
<span class="udiff-line-removed">-   return offset &gt;= start() &amp;&amp; offset &lt; top();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline uintptr_t ZPage::block_start(uintptr_t addr) const {</span>
<span class="udiff-line-removed">-   if (block_is_obj(addr)) {</span>
<span class="udiff-line-removed">-     return addr;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return ZAddress::good(top());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool ZPage::block_is_obj(uintptr_t addr) const {</span>
<span class="udiff-line-removed">-   return ZAddress::offset(addr) &lt; top();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool ZPage::is_active() const {</span>
<span class="udiff-line-removed">-   return _refcount &gt; 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline bool ZPage::is_allocating() const {
<span class="udiff-line-modified-removed">-   return is_active() &amp;&amp; _seqnum == ZGlobalSeqNum;</span>
<span class="udiff-line-modified-added">+   return _seqnum == ZGlobalSeqNum;</span>
  }
  
  inline bool ZPage::is_relocatable() const {
<span class="udiff-line-modified-removed">-   return is_active() &amp;&amp; _seqnum &lt; ZGlobalSeqNum;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool ZPage::is_detached() const {</span>
<span class="udiff-line-removed">-   return _physical.is_null();</span>
<span class="udiff-line-modified-added">+   return _seqnum &lt; ZGlobalSeqNum;</span>
  }
  
  inline bool ZPage::is_mapped() const {
    return _seqnum &gt; 0;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -188,34 +159,21 @@</span>
    // memory has been mapped. So, we need to set it to non-zero when the memory
    // has been pre-mapped.
    _seqnum = 1;
  }
  
<span class="udiff-line-modified-removed">- inline bool ZPage::is_pinned() const {</span>
<span class="udiff-line-modified-removed">-   return _pinned;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline void ZPage::set_pinned() {</span>
<span class="udiff-line-removed">-   _pinned = 1;</span>
<span class="udiff-line-modified-added">+ inline uint64_t ZPage::last_used() const {</span>
<span class="udiff-line-modified-added">+   return _last_used;</span>
  }
  
<span class="udiff-line-modified-removed">- inline bool ZPage::is_forwarding() const {</span>
<span class="udiff-line-modified-removed">-   return !_forwarding.is_null();</span>
<span class="udiff-line-modified-added">+ inline void ZPage::set_last_used() {</span>
<span class="udiff-line-modified-added">+   _last_used = os::elapsedTime();</span>
  }
  
<span class="udiff-line-modified-removed">- inline void ZPage::set_forwarding() {</span>
<span class="udiff-line-modified-removed">-   assert(is_marked(), &quot;Should be marked&quot;);</span>
<span class="udiff-line-modified-removed">-   _forwarding.setup(_livemap.live_objects());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline void ZPage::reset_forwarding() {</span>
<span class="udiff-line-removed">-   _forwarding.reset();</span>
<span class="udiff-line-removed">-   _pinned = 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline void ZPage::verify_forwarding() const {</span>
<span class="udiff-line-removed">-   _forwarding.verify(object_max_count(), _livemap.live_objects());</span>
<span class="udiff-line-modified-added">+ inline bool ZPage::is_in(uintptr_t addr) const {</span>
<span class="udiff-line-modified-added">+   const uintptr_t offset = ZAddress::offset(addr);</span>
<span class="udiff-line-modified-added">+   return offset &gt;= start() &amp;&amp; offset &lt; top();</span>
  }
  
  inline bool ZPage::is_marked() const {
    assert(is_relocatable(), &quot;Invalid page state&quot;);
    return _livemap.is_marked();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -244,15 +202,20 @@</span>
    assert(is_relocatable(), &quot;Invalid page state&quot;);
    assert(is_in(addr), &quot;Invalid address&quot;);
  
    // Set mark bit
    const size_t index = ((ZAddress::offset(addr) - start()) &gt;&gt; object_alignment_shift()) * 2;
<span class="udiff-line-modified-removed">-   return _livemap.set_atomic(index, finalizable, inc_live);</span>
<span class="udiff-line-modified-added">+   return _livemap.set(index, finalizable, inc_live);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void ZPage::inc_live(uint32_t objects, size_t bytes) {</span>
<span class="udiff-line-added">+   _livemap.inc_live(objects, bytes);</span>
  }
  
<span class="udiff-line-modified-removed">- inline void ZPage::inc_live_atomic(uint32_t objects, size_t bytes) {</span>
<span class="udiff-line-modified-removed">-   _livemap.inc_live_atomic(objects, bytes);</span>
<span class="udiff-line-modified-added">+ inline uint32_t ZPage::live_objects() const {</span>
<span class="udiff-line-modified-added">+   assert(is_marked(), &quot;Should be marked&quot;);</span>
<span class="udiff-line-added">+   return _livemap.live_objects();</span>
  }
  
  inline size_t ZPage::live_bytes() const {
    assert(is_marked(), &quot;Should be marked&quot;);
    return _livemap.live_bytes();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,11 +253,11 @@</span>
      if (new_top &gt; end()) {
        // Not enough space left
        return 0;
      }
  
<span class="udiff-line-modified-removed">-     const uintptr_t prev_top = Atomic::cmpxchg(new_top, &amp;_top, addr);</span>
<span class="udiff-line-modified-added">+     const uintptr_t prev_top = Atomic::cmpxchg(&amp;_top, addr, new_top);</span>
      if (prev_top == addr) {
        // Success
        return ZAddress::good(addr);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,11 +297,11 @@</span>
      if (new_top != offset) {
        // Failed to undo allocation, not the last allocated object
        return false;
      }
  
<span class="udiff-line-modified-removed">-     const uintptr_t prev_top = Atomic::cmpxchg(new_top, &amp;_top, old_top);</span>
<span class="udiff-line-modified-added">+     const uintptr_t prev_top = Atomic::cmpxchg(&amp;_top, old_top, new_top);</span>
      if (prev_top == old_top) {
        // Success
        return true;
      }
  
</pre>
<center><a href="zPage.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageAllocator.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
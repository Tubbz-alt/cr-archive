diff a/src/hotspot/share/gc/z/zWorkers.cpp b/src/hotspot/share/gc/z/zWorkers.cpp
--- a/src/hotspot/share/gc/z/zWorkers.cpp
+++ b/src/hotspot/share/gc/z/zWorkers.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,49 +24,13 @@
 #include "precompiled.hpp"
 #include "gc/z/zGlobals.hpp"
 #include "gc/z/zTask.hpp"
 #include "gc/z/zThread.hpp"
 #include "gc/z/zWorkers.inline.hpp"
-#include "runtime/os.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/safepoint.hpp"
 
-static uint calculate_nworkers_based_on_ncpus(double cpu_share_in_percent) {
-  return ceil(os::initial_active_processor_count() * cpu_share_in_percent / 100.0);
-}
-
-static uint calculate_nworkers_based_on_heap_size(double reserve_share_in_percent) {
-  const int nworkers = ((MaxHeapSize * (reserve_share_in_percent / 100.0)) - ZPageSizeMedium) / ZPageSizeSmall;
-  return MAX2(nworkers, 1);
-}
-
-static uint calculate_nworkers(double cpu_share_in_percent) {
-  // Cap number of workers so that we never use more than 10% of the max heap
-  // for the reserve. This is useful when using small heaps on large machines.
-  return MIN2(calculate_nworkers_based_on_ncpus(cpu_share_in_percent),
-              calculate_nworkers_based_on_heap_size(10.0));
-}
-
-uint ZWorkers::calculate_nparallel() {
-  // Use 60% of the CPUs, rounded up. We would like to use as many threads as
-  // possible to increase parallelism. However, using a thread count that is
-  // close to the number of processors tends to lead to over-provisioning and
-  // scheduling latency issues. Using 60% of the active processors appears to
-  // be a fairly good balance.
-  return calculate_nworkers(60.0);
-}
-
-uint ZWorkers::calculate_nconcurrent() {
-  // Use 12.5% of the CPUs, rounded up. The number of concurrent threads we
-  // would like to use heavily depends on the type of workload we are running.
-  // Using too many threads will have a negative impact on the application
-  // throughput, while using too few threads will prolong the GC-cycle and
-  // we then risk being out-run by the application. Using 12.5% of the active
-  // processors appears to be a fairly good balance.
-  return calculate_nworkers(12.5);
-}
-
 class ZWorkersInitializeTask : public ZTask {
 private:
   const uint _nworkers;
   uint       _started;
   Monitor    _monitor;
@@ -84,17 +48,17 @@
   virtual void work() {
     // Register as worker
     ZThread::set_worker();
 
     // Wait for all threads to start
-    MonitorLockerEx ml(&_monitor, Monitor::_no_safepoint_check_flag);
+    MonitorLocker ml(&_monitor, Monitor::_no_safepoint_check_flag);
     if (++_started == _nworkers) {
       // All threads started
       ml.notify_all();
     } else {
       while (_started != _nworkers) {
-        ml.wait(Monitor::_no_safepoint_check_flag);
+        ml.wait();
       }
     }
   }
 };
 
@@ -134,11 +98,10 @@
   _workers.update_active_workers(nworkers);
   _workers.run_task(task->gang_task());
 }
 
 void ZWorkers::run_parallel(ZTask* task) {
-  assert(SafepointSynchronize::is_at_safepoint(), "Should be at a safepoint");
   run(task, nparallel());
 }
 
 void ZWorkers::run_concurrent(ZTask* task) {
   run(task, nconcurrent());

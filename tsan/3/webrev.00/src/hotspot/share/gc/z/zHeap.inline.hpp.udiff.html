<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeapIterator.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,16 +23,18 @@</span>
  
  #ifndef SHARE_GC_Z_ZHEAP_INLINE_HPP
  #define SHARE_GC_Z_ZHEAP_INLINE_HPP
  
  #include &quot;gc/z/zAddress.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zForwarding.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/z/zForwardingTable.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/z/zHash.inline.hpp&quot;</span>
  #include &quot;gc/z/zHeap.hpp&quot;
  #include &quot;gc/z/zMark.inline.hpp&quot;
  #include &quot;gc/z/zOop.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageTable.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/z/zUtils.inline.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  
  inline ZHeap* ZHeap::heap() {
    assert(_heap != NULL, &quot;Not initialized&quot;);
    return _heap;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,28 +42,29 @@</span>
  
  inline ReferenceDiscoverer* ZHeap::reference_discoverer() {
    return &amp;_reference_processor;
  }
  
<span class="udiff-line-modified-removed">- inline bool ZHeap::is_relocating(uintptr_t addr) const {</span>
<span class="udiff-line-modified-removed">-   return _pagetable.is_relocating(addr);</span>
<span class="udiff-line-modified-added">+ inline uint32_t ZHeap::hash_oop(uintptr_t addr) const {</span>
<span class="udiff-line-modified-added">+   const uintptr_t offset = ZAddress::offset(addr);</span>
<span class="udiff-line-added">+   return ZHash::address_to_uint32(offset);</span>
  }
  
  inline bool ZHeap::is_object_live(uintptr_t addr) const {
<span class="udiff-line-modified-removed">-   ZPage* page = _pagetable.get(addr);</span>
<span class="udiff-line-modified-added">+   ZPage* page = _page_table.get(addr);</span>
    return page-&gt;is_object_live(addr);
  }
  
  inline bool ZHeap::is_object_strongly_live(uintptr_t addr) const {
<span class="udiff-line-modified-removed">-   ZPage* page = _pagetable.get(addr);</span>
<span class="udiff-line-modified-added">+   ZPage* page = _page_table.get(addr);</span>
    return page-&gt;is_object_strongly_live(addr);
  }
  
<span class="udiff-line-modified-removed">- template &lt;bool finalizable, bool publish&gt;</span>
<span class="udiff-line-modified-added">+ template &lt;bool follow, bool finalizable, bool publish&gt;</span>
  inline void ZHeap::mark_object(uintptr_t addr) {
    assert(ZGlobalPhase == ZPhaseMark, &quot;Mark not allowed&quot;);
<span class="udiff-line-modified-removed">-   _mark.mark_object&lt;finalizable, publish&gt;(addr);</span>
<span class="udiff-line-modified-added">+   _mark.mark_object&lt;follow, finalizable, publish&gt;(addr);</span>
  }
  
  inline uintptr_t ZHeap::alloc_tlab(size_t size) {
    guarantee(size &lt;= max_tlab_size(), &quot;TLAB too large&quot;);
    return _object_allocator.alloc_object(size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,22 +86,55 @@</span>
    assert(ZAddress::is_good_or_null(addr), &quot;Bad address&quot;);
    return addr;
  }
  
  inline void ZHeap::undo_alloc_object_for_relocation(uintptr_t addr, size_t size) {
<span class="udiff-line-modified-removed">-   ZPage* const page = _pagetable.get(addr);</span>
<span class="udiff-line-modified-added">+   ZPage* const page = _page_table.get(addr);</span>
    _object_allocator.undo_alloc_object_for_relocation(page, addr, size);
  }
  
<span class="udiff-line-added">+ inline uintptr_t ZHeap::relocate_object(uintptr_t addr) {</span>
<span class="udiff-line-added">+   assert(ZGlobalPhase == ZPhaseRelocate, &quot;Relocate not allowed&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ZForwarding* const forwarding = _forwarding_table.get(addr);</span>
<span class="udiff-line-added">+   if (forwarding == NULL) {</span>
<span class="udiff-line-added">+     // Not forwarding</span>
<span class="udiff-line-added">+     return ZAddress::good(addr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Relocate object</span>
<span class="udiff-line-added">+   const bool retained = forwarding-&gt;retain_page();</span>
<span class="udiff-line-added">+   const uintptr_t new_addr = _relocate.relocate_object(forwarding, addr);</span>
<span class="udiff-line-added">+   if (retained) {</span>
<span class="udiff-line-added">+     forwarding-&gt;release_page();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return new_addr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline uintptr_t ZHeap::remap_object(uintptr_t addr) {</span>
<span class="udiff-line-added">+   assert(ZGlobalPhase == ZPhaseMark ||</span>
<span class="udiff-line-added">+          ZGlobalPhase == ZPhaseMarkCompleted, &quot;Forward not allowed&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ZForwarding* const forwarding = _forwarding_table.get(addr);</span>
<span class="udiff-line-added">+   if (forwarding == NULL) {</span>
<span class="udiff-line-added">+     // Not forwarding</span>
<span class="udiff-line-added">+     return ZAddress::good(addr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Forward object</span>
<span class="udiff-line-added">+   return _relocate.forward_object(forwarding, addr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline bool ZHeap::is_alloc_stalled() const {
    return _page_allocator.is_alloc_stalled();
  }
  
  inline void ZHeap::check_out_of_memory() {
    _page_allocator.check_out_of_memory();
  }
  
<span class="udiff-line-modified-removed">- inline bool ZHeap::is_oop(oop object) const {</span>
<span class="udiff-line-modified-removed">-   return ZOop::is_good(object);</span>
<span class="udiff-line-modified-added">+ inline bool ZHeap::is_oop(uintptr_t addr) const {</span>
<span class="udiff-line-modified-added">+   return ZAddress::is_good(addr) &amp;&amp; is_object_aligned(addr) &amp;&amp; is_in(addr);</span>
  }
  
  #endif // SHARE_GC_Z_ZHEAP_INLINE_HPP
</pre>
<center><a href="zHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeapIterator.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
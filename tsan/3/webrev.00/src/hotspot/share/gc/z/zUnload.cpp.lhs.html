<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zUnload.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;code/codeBehaviours.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/dependencyContext.hpp&quot;
 30 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/z/zLock.inline.hpp&quot;
 33 #include &quot;gc/z/zNMethod.hpp&quot;
 34 #include &quot;gc/z/zOopClosures.hpp&quot;
 35 #include &quot;gc/z/zStat.hpp&quot;
 36 #include &quot;gc/z/zUnload.hpp&quot;
 37 #include &quot;oops/access.inline.hpp&quot;
 38 
<a name="2" id="anc2"></a><span class="line-modified"> 39 static const ZStatSubPhase ZSubPhaseConcurrentClassesUnload(&quot;Concurrent Classes Unload&quot;);</span>

 40 
 41 class ZIsUnloadingOopClosure : public OopClosure {
 42 private:
 43   ZPhantomIsAliveObjectClosure _is_alive;
 44   bool                         _is_unloading;
 45 
 46 public:
 47   ZIsUnloadingOopClosure() :
 48       _is_alive(),
 49       _is_unloading(false) {}
 50 
 51   virtual void do_oop(oop* p) {
 52     const oop o = RawAccess&lt;&gt;::oop_load(p);
 53     if (o != NULL &amp;&amp; !_is_alive.do_object_b(o)) {
 54       _is_unloading = true;
 55     }
 56   }
 57 
 58   virtual void do_oop(narrowOop* p) {
 59     ShouldNotReachHere();
 60   }
 61 
 62   bool is_unloading() const {
 63     return _is_unloading;
 64   }
 65 };
 66 
 67 class ZIsUnloadingBehaviour : public IsUnloadingBehaviour {
 68 public:
 69   virtual bool is_unloading(CompiledMethod* method) const {
 70     nmethod* const nm = method-&gt;as_nmethod();
 71     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 72     ZLocker&lt;ZReentrantLock&gt; locker(lock);
 73     ZIsUnloadingOopClosure cl;
<a name="3" id="anc3"></a><span class="line-modified"> 74     nm-&gt;oops_do(&amp;cl, true /* allow_zombie */);</span>
 75     return cl.is_unloading();
 76   }
 77 };
 78 
 79 class ZCompiledICProtectionBehaviour : public CompiledICProtectionBehaviour {
 80 public:
 81   virtual bool lock(CompiledMethod* method) {
 82     nmethod* const nm = method-&gt;as_nmethod();
 83     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 84     lock-&gt;lock();
 85     return true;
 86   }
 87 
 88   virtual void unlock(CompiledMethod* method) {
 89     nmethod* const nm = method-&gt;as_nmethod();
 90     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
 91     lock-&gt;unlock();
 92   }
 93 
 94   virtual bool is_safe(CompiledMethod* method) {
 95     if (SafepointSynchronize::is_at_safepoint()) {
 96       return true;
 97     }
 98 
 99     nmethod* const nm = method-&gt;as_nmethod();
100     ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
101     return lock-&gt;is_owned();
102   }
103 };
104 
105 ZUnload::ZUnload(ZWorkers* workers) :
106     _workers(workers) {
107 
108   if (!ClassUnloading) {
109     return;
110   }
111 
112   static ZIsUnloadingBehaviour is_unloading_behaviour;
113   IsUnloadingBehaviour::set_current(&amp;is_unloading_behaviour);
114 
115   static ZCompiledICProtectionBehaviour ic_protection_behaviour;
116   CompiledICProtectionBehaviour::set_current(&amp;ic_protection_behaviour);
117 }
118 
119 void ZUnload::prepare() {
120   if (!ClassUnloading) {
121     return;
122   }
123 
124   CodeCache::increment_unloading_cycle();
125   DependencyContext::cleaning_start();
126 }
127 
128 void ZUnload::unlink() {
<a name="4" id="anc4"></a>




129   SuspendibleThreadSetJoiner sts;
130   bool unloading_occurred;
131 
132   {
<a name="5" id="anc5"></a><span class="line-modified">133     MutexLockerEx ml(ClassLoaderDataGraph_lock);</span>
134     unloading_occurred = SystemDictionary::do_unloading(ZStatPhase::timer());
135   }
136 
137   Klass::clean_weak_klass_links(unloading_occurred);
<a name="6" id="anc6"></a><span class="line-removed">138 </span>
139   ZNMethod::unlink(_workers, unloading_occurred);
<a name="7" id="anc7"></a><span class="line-removed">140 </span>
141   DependencyContext::cleaning_end();
142 }
143 
144 void ZUnload::purge() {
<a name="8" id="anc8"></a>





145   {
146     SuspendibleThreadSetJoiner sts;
147     ZNMethod::purge(_workers);
148   }
149 
150   ClassLoaderDataGraph::purge();
151   CodeCache::purge_exception_caches();
152 }
153 
<a name="9" id="anc9"></a><span class="line-removed">154 class ZUnloadRendezvousClosure : public ThreadClosure {</span>
<span class="line-removed">155 public:</span>
<span class="line-removed">156   void do_thread(Thread* thread) {}</span>
<span class="line-removed">157 };</span>
<span class="line-removed">158 </span>
<span class="line-removed">159 void ZUnload::unload() {</span>
<span class="line-removed">160   if (!ClassUnloading) {</span>
<span class="line-removed">161     return;</span>
<span class="line-removed">162   }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164   ZStatTimer timer(ZSubPhaseConcurrentClassesUnload);</span>
<span class="line-removed">165 </span>
<span class="line-removed">166   // Unlink stale metadata and nmethods</span>
<span class="line-removed">167   unlink();</span>
<span class="line-removed">168 </span>
<span class="line-removed">169   // Make sure stale metadata and nmethods are no longer observable</span>
<span class="line-removed">170   ZUnloadRendezvousClosure cl;</span>
<span class="line-removed">171   Handshake::execute(&amp;cl);</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   // Purge stale metadata and nmethods that were unlinked</span>
<span class="line-removed">174   purge();</span>
<span class="line-removed">175 }</span>
<span class="line-removed">176 </span>
177 void ZUnload::finish() {
178   // Resize and verify metaspace
179   MetaspaceGC::compute_new_size();
180   MetaspaceUtils::verify_metrics();
181 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
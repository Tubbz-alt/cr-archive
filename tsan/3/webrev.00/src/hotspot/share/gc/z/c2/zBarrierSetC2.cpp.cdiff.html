<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/c2/zBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../shenandoah/vmStructs_shenandoah.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zBarrierSetC2.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/c2/zBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,1625 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;opto/compile.hpp&quot;
<span class="line-removed">- #include &quot;opto/castnode.hpp&quot;</span>
<span class="line-removed">- #include &quot;opto/escape.hpp&quot;</span>
  #include &quot;opto/graphKit.hpp&quot;
<span class="line-modified">! #include &quot;opto/idealKit.hpp&quot;</span>
<span class="line-removed">- #include &quot;opto/loopnode.hpp&quot;</span>
  #include &quot;opto/macro.hpp&quot;
  #include &quot;opto/node.hpp&quot;
  #include &quot;opto/type.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zBarrierSet.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zThreadLocalData.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;</span>
  
<span class="line-modified">! ZBarrierSetC2State::ZBarrierSetC2State(Arena* comp_arena) :</span>
<span class="line-modified">!     _load_barrier_nodes(new (comp_arena) GrowableArray&lt;LoadBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {}</span>
  
<span class="line-modified">! int ZBarrierSetC2State::load_barrier_count() const {</span>
<span class="line-modified">!   return _load_barrier_nodes-&gt;length();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- void ZBarrierSetC2State::add_load_barrier_node(LoadBarrierNode * n) {</span>
<span class="line-removed">-   assert(!_load_barrier_nodes-&gt;contains(n), &quot; duplicate entry in expand list&quot;);</span>
<span class="line-removed">-   _load_barrier_nodes-&gt;append(n);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void ZBarrierSetC2State::remove_load_barrier_node(LoadBarrierNode * n) {</span>
<span class="line-modified">!   // this function may be called twice for a node so check</span>
<span class="line-removed">-   // that the node is in the array before attempting to remove it</span>
<span class="line-removed">-   if (_load_barrier_nodes-&gt;contains(n)) {</span>
<span class="line-removed">-     _load_barrier_nodes-&gt;remove(n);</span>
    }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- LoadBarrierNode* ZBarrierSetC2State::load_barrier_node(int idx) const {</span>
<span class="line-removed">-   return _load_barrier_nodes-&gt;at(idx);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void* ZBarrierSetC2::create_barrier_state(Arena* comp_arena) const {</span>
<span class="line-modified">!   return new(comp_arena) ZBarrierSetC2State(comp_arena);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- ZBarrierSetC2State* ZBarrierSetC2::state() const {</span>
<span class="line-removed">-   return reinterpret_cast&lt;ZBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrierSetC2::is_gc_barrier_node(Node* node) const {</span>
<span class="line-removed">-   // 1. This step follows potential oop projections of a load barrier before expansion</span>
<span class="line-removed">-   if (node-&gt;is_Proj()) {</span>
<span class="line-removed">-     node = node-&gt;in(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // 2. This step checks for unexpanded load barriers</span>
<span class="line-removed">-   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // 3. This step checks for the phi corresponding to an optimized load barrier expansion</span>
<span class="line-removed">-   if (node-&gt;is_Phi()) {</span>
<span class="line-removed">-     PhiNode* phi = node-&gt;as_Phi();</span>
<span class="line-removed">-     Node* n = phi-&gt;in(1);</span>
<span class="line-removed">-     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {</span>
<span class="line-removed">-       return true;</span>
      }
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZBarrierSetC2::register_potential_barrier_node(Node* node) const {</span>
<span class="line-removed">-   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     state()-&gt;add_load_barrier_node(node-&gt;as_LoadBarrier());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void ZBarrierSetC2::unregister_potential_barrier_node(Node* node) const {</span>
<span class="line-modified">!   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-modified">!     state()-&gt;remove_load_barrier_node(node-&gt;as_LoadBarrier());</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ZBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {</span>
<span class="line-modified">!   // Remove useless LoadBarrier nodes</span>
<span class="line-modified">!   ZBarrierSetC2State* s = state();</span>
<span class="line-modified">!   for (int i = s-&gt;load_barrier_count()-1; i &gt;= 0; i--) {</span>
<span class="line-removed">-     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed">-     if (!useful.member(n)) {</span>
<span class="line-removed">-       unregister_potential_barrier_node(n);</span>
      }
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void ZBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {</span>
<span class="line-removed">-   if (node-&gt;is_LoadBarrier() &amp;&amp; !node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">-     igvn-&gt;_worklist.push(node);</span>
    }
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ZBarrierSetC2::find_dominating_barriers(PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified">!   // Look for dominating barriers on the same address only once all</span>
<span class="line-removed">-   // other loop opts are over. Loop opts may cause a safepoint to be</span>
<span class="line-removed">-   // inserted between a barrier and its dominating barrier.</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">-   ZBarrierSetC2* bs = (ZBarrierSetC2*)BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">-   ZBarrierSetC2State* s = bs-&gt;state();</span>
<span class="line-removed">-   if (s-&gt;load_barrier_count() &gt;= 2) {</span>
<span class="line-removed">-     Compile::TracePhase tp(&quot;idealLoop&quot;, &amp;C-&gt;timers[Phase::_t_idealLoop]);</span>
<span class="line-removed">-     PhaseIdealLoop::optimize(igvn, LoopOptsLastRound);</span>
<span class="line-removed">-     if (C-&gt;major_progress()) C-&gt;print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! void ZBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {</span>
<span class="line-modified">!   // Permanent temporary workaround</span>
<span class="line-modified">!   // Loadbarriers may have non-obvious dead uses keeping them alive during parsing. The use is</span>
<span class="line-modified">!   // removed by RemoveUseless (after parsing, before optimize) but the barriers won&#39;t be added to</span>
<span class="line-removed">-   // the worklist. Unless we add them explicitly they are not guaranteed to end up there.</span>
<span class="line-removed">-   ZBarrierSetC2State* s = state();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {</span>
<span class="line-removed">-     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed">-     worklist-&gt;push(n);</span>
    }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const TypeFunc* ZBarrierSetC2::load_barrier_Type() const {</span>
<span class="line-removed">-   const Type** fields;</span>
  
<span class="line-modified">!   // Create input types (domain)</span>
<span class="line-removed">-   fields = TypeTuple::fields(2);</span>
<span class="line-removed">-   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;</span>
<span class="line-removed">-   fields[TypeFunc::Parms+1] = TypeOopPtr::BOTTOM;</span>
<span class="line-removed">-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Create result type (range)</span>
<span class="line-removed">-   fields = TypeTuple::fields(1);</span>
<span class="line-removed">-   fields[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM;</span>
<span class="line-removed">-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return TypeFunc::make(domain, range);</span>
  }
  
<span class="line-modified">! // == LoadBarrierNode ==</span>
<span class="line-modified">! </span>
<span class="line-modified">! LoadBarrierNode::LoadBarrierNode(Compile* C,</span>
<span class="line-modified">!                                  Node* c,</span>
<span class="line-modified">!                                  Node* mem,</span>
<span class="line-removed">-                                  Node* val,</span>
<span class="line-removed">-                                  Node* adr,</span>
<span class="line-removed">-                                  bool weak,</span>
<span class="line-removed">-                                  bool writeback,</span>
<span class="line-removed">-                                  bool oop_reload_allowed) :</span>
<span class="line-removed">-     MultiNode(Number_of_Inputs),</span>
      _weak(weak),
<span class="line-modified">!     _writeback(writeback),</span>
<span class="line-modified">!     _oop_reload_allowed(oop_reload_allowed) {</span>
<span class="line-modified">!   init_req(Control, c);</span>
<span class="line-modified">!   init_req(Memory, mem);</span>
<span class="line-removed">-   init_req(Oop, val);</span>
<span class="line-removed">-   init_req(Address, adr);</span>
<span class="line-removed">-   init_req(Similar, C-&gt;top());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   init_class_id(Class_LoadBarrier);</span>
<span class="line-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">-   bs-&gt;register_potential_barrier_node(this);</span>
  }
  
<span class="line-modified">! uint LoadBarrierNode::size_of() const {</span>
<span class="line-modified">!   return sizeof(*this);</span>
  }
  
<span class="line-modified">! uint LoadBarrierNode::cmp(const Node&amp; n) const {</span>
<span class="line-modified">!   ShouldNotReachHere();</span>
<span class="line-removed">-   return 0;</span>
  }
  
<span class="line-modified">! const Type *LoadBarrierNode::bottom_type() const {</span>
<span class="line-modified">!   const Type** floadbarrier = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));</span>
<span class="line-removed">-   Node* in_oop = in(Oop);</span>
<span class="line-removed">-   floadbarrier[Control] = Type::CONTROL;</span>
<span class="line-removed">-   floadbarrier[Memory] = Type::MEMORY;</span>
<span class="line-removed">-   floadbarrier[Oop] = in_oop == NULL ? Type::TOP : in_oop-&gt;bottom_type();</span>
<span class="line-removed">-   return TypeTuple::make(Number_of_Outputs, floadbarrier);</span>
  }
  
<span class="line-modified">! const TypePtr* LoadBarrierNode::adr_type() const {</span>
<span class="line-modified">!   ShouldNotReachHere();</span>
<span class="line-modified">!   return NULL;</span>
  }
  
<span class="line-modified">! const Type *LoadBarrierNode::Value(PhaseGVN *phase) const {</span>
<span class="line-modified">!   const Type** floadbarrier = (const Type **)(phase-&gt;C-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));</span>
<span class="line-removed">-   const Type* val_t = phase-&gt;type(in(Oop));</span>
<span class="line-removed">-   floadbarrier[Control] = Type::CONTROL;</span>
<span class="line-removed">-   floadbarrier[Memory] = Type::MEMORY;</span>
<span class="line-removed">-   floadbarrier[Oop] = val_t;</span>
<span class="line-removed">-   return TypeTuple::make(Number_of_Outputs, floadbarrier);</span>
  }
  
<span class="line-modified">! bool LoadBarrierNode::is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n) {</span>
<span class="line-modified">!   if (phase != NULL) {</span>
<span class="line-modified">!     return phase-&gt;is_dominator(d, n);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   for (int i = 0; i &lt; 10 &amp;&amp; n != NULL; i++) {</span>
<span class="line-removed">-     n = IfNode::up_one_dom(n, linear_only);</span>
<span class="line-removed">-     if (n == d) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
  }
  
<span class="line-modified">! LoadBarrierNode* LoadBarrierNode::has_dominating_barrier(PhaseIdealLoop* phase, bool linear_only, bool look_for_similar) {</span>
<span class="line-modified">!   Node* val = in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   if (in(Similar)-&gt;is_Proj() &amp;&amp; in(Similar)-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     LoadBarrierNode* lb = in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-removed">-     assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);</span>
<span class="line-removed">-     // Load barrier on Similar edge dominates so if it now has the Oop field it can replace this barrier.</span>
<span class="line-removed">-     if (lb-&gt;in(Oop) == in(Oop)) {</span>
<span class="line-removed">-       return lb;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Follow chain of load barrier through Similar edges</span>
<span class="line-removed">-     while (!lb-&gt;in(Similar)-&gt;is_top()) {</span>
<span class="line-removed">-       lb = lb-&gt;in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-removed">-       assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (lb != in(Similar)-&gt;in(0)) {</span>
<span class="line-removed">-       return lb;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">-     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">-       Node* this_ctrl = in(LoadBarrierNode::Control);</span>
<span class="line-removed">-       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {</span>
<span class="line-removed">-         return u-&gt;as_LoadBarrier();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (ZVerifyLoadBarriers || can_be_eliminated()) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!look_for_similar) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* addr = in(LoadBarrierNode::Address);</span>
<span class="line-removed">-   for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-     Node* u = addr-&gt;fast_out(i);</span>
<span class="line-removed">-     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">-       Node* this_ctrl = in(LoadBarrierNode::Control);</span>
<span class="line-removed">-       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {</span>
<span class="line-removed">-         ResourceMark rm;</span>
<span class="line-removed">-         Unique_Node_List wq;</span>
<span class="line-removed">-         wq.push(in(LoadBarrierNode::Control));</span>
<span class="line-removed">-         bool ok = true;</span>
<span class="line-removed">-         bool dom_found = false;</span>
<span class="line-removed">-         for (uint next = 0; next &lt; wq.size(); ++next) {</span>
<span class="line-removed">-           Node *n = wq.at(next);</span>
<span class="line-removed">-           if (n-&gt;is_top()) {</span>
<span class="line-removed">-             return NULL;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           assert(n-&gt;is_CFG(), &quot;&quot;);</span>
<span class="line-removed">-           if (n-&gt;is_SafePoint()) {</span>
<span class="line-removed">-             ok = false;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (n == u) {</span>
<span class="line-removed">-             dom_found = true;</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (n-&gt;is_Region()) {</span>
<span class="line-removed">-             for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed">-               Node* m = n-&gt;in(i);</span>
<span class="line-removed">-               if (m != NULL) {</span>
<span class="line-removed">-                 wq.push(m);</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             Node* m = n-&gt;in(0);</span>
<span class="line-removed">-             if (m != NULL) {</span>
<span class="line-removed">-               wq.push(m);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (ok) {</span>
<span class="line-removed">-           assert(dom_found, &quot;&quot;);</span>
<span class="line-removed">-           return u-&gt;as_LoadBarrier();;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return NULL;</span>
  }
  
<span class="line-modified">! void LoadBarrierNode::push_dominated_barriers(PhaseIterGVN* igvn) const {</span>
<span class="line-modified">!   // Change to that barrier may affect a dominated barrier so re-push those</span>
<span class="line-removed">-   Node* val = in(LoadBarrierNode::Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">-     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val) {</span>
<span class="line-removed">-       Node* this_ctrl = in(Control);</span>
<span class="line-removed">-       Node* other_ctrl = u-&gt;in(Control);</span>
<span class="line-removed">-       if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {</span>
<span class="line-removed">-         igvn-&gt;_worklist.push(u);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Node* addr = in(LoadBarrierNode::Address);</span>
<span class="line-removed">-     for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-       Node* u = addr-&gt;fast_out(i);</span>
<span class="line-removed">-       if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar)-&gt;is_top()) {</span>
<span class="line-removed">-         Node* this_ctrl = in(Control);</span>
<span class="line-removed">-         Node* other_ctrl = u-&gt;in(Control);</span>
<span class="line-removed">-         if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {</span>
<span class="line-removed">-           igvn-&gt;_worklist.push(u);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! Node *LoadBarrierNode::Identity(PhaseGVN *phase) {</span>
<span class="line-modified">!   if (!phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {</span>
<span class="line-modified">!     return this;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool redundant_addr = false;</span>
<span class="line-removed">-   LoadBarrierNode* dominating_barrier = has_dominating_barrier(NULL, true, false);</span>
<span class="line-removed">-   if (dominating_barrier != NULL) {</span>
<span class="line-removed">-     assert(dominating_barrier-&gt;in(Oop) == in(Oop), &quot;&quot;);</span>
<span class="line-removed">-     return dominating_barrier;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return this;</span>
  }
  
<span class="line-modified">! Node *LoadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-modified">!   if (remove_dead_region(phase, can_reshape)) {</span>
<span class="line-modified">!     return this;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* val = in(Oop);</span>
<span class="line-removed">-   Node* mem = in(Memory);</span>
<span class="line-removed">-   Node* ctrl = in(Control);</span>
<span class="line-removed">-   Node* adr = in(Address);</span>
<span class="line-removed">-   assert(val-&gt;Opcode() != Op_LoadN, &quot;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed">-     Node* new_mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);</span>
<span class="line-removed">-     set_req(Memory, new_mem);</span>
<span class="line-removed">-     if (mem-&gt;outcnt() == 0 &amp;&amp; can_reshape) {</span>
<span class="line-removed">-       phase-&gt;is_IterGVN()-&gt;_worklist.push(mem);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return this;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool optimizeLoadBarriers = phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption;</span>
<span class="line-removed">-   LoadBarrierNode* dominating_barrier = optimizeLoadBarriers ? has_dominating_barrier(NULL, !can_reshape, !phase-&gt;C-&gt;major_progress()) : NULL;</span>
<span class="line-removed">-   if (dominating_barrier != NULL &amp;&amp; dominating_barrier-&gt;in(Oop) != in(Oop)) {</span>
<span class="line-removed">-     assert(in(Address) == dominating_barrier-&gt;in(Address), &quot;&quot;);</span>
<span class="line-removed">-     set_req(Similar, dominating_barrier-&gt;proj_out(Oop));</span>
<span class="line-removed">-     return this;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   bool eliminate = (optimizeLoadBarriers &amp;&amp; !(val-&gt;is_Phi() || val-&gt;Opcode() == Op_LoadP || val-&gt;Opcode() == Op_GetAndSetP || val-&gt;is_DecodeN())) ||</span>
<span class="line-modified">!                    (can_reshape &amp;&amp; (dominating_barrier != NULL || !has_true_uses()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (eliminate) {</span>
<span class="line-modified">!     if (can_reshape) {</span>
<span class="line-removed">-       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed">-       Node* out_ctrl = proj_out_or_null(Control);</span>
<span class="line-removed">-       Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (out_ctrl != NULL) {</span>
<span class="line-removed">-         igvn-&gt;replace_node(out_ctrl, ctrl);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // That transformation may cause the Similar edge on the load barrier to be invalid</span>
<span class="line-removed">-       fix_similar_in_uses(igvn);</span>
<span class="line-removed">-       if (out_res != NULL) {</span>
<span class="line-removed">-         if (dominating_barrier != NULL) {</span>
<span class="line-removed">-           igvn-&gt;replace_node(out_res, dominating_barrier-&gt;proj_out(Oop));</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           igvn-&gt;replace_node(out_res, val);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return new ConINode(TypeInt::ZERO);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // If the Similar edge is no longer a load barrier, clear it</span>
<span class="line-removed">-   Node* similar = in(Similar);</span>
<span class="line-removed">-   if (!similar-&gt;is_top() &amp;&amp; !(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier())) {</span>
<span class="line-removed">-     set_req(Similar, phase-&gt;C-&gt;top());</span>
<span class="line-removed">-     return this;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (can_reshape) {</span>
<span class="line-removed">-     // If this barrier is linked through the Similar edge by a</span>
<span class="line-removed">-     // dominated barrier and both barriers have the same Oop field,</span>
<span class="line-removed">-     // the dominated barrier can go away, so push it for reprocessing.</span>
<span class="line-removed">-     // We also want to avoid a barrier to depend on another dominating</span>
<span class="line-removed">-     // barrier through its Similar edge that itself depend on another</span>
<span class="line-removed">-     // barrier through its Similar edge and rather have the first</span>
<span class="line-removed">-     // depend on the third.</span>
<span class="line-removed">-     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed">-     Node* out_res = proj_out(Oop);</span>
<span class="line-removed">-     for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-       Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-removed">-       if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res &amp;&amp;</span>
<span class="line-removed">-           (u-&gt;in(Oop) == val || !u-&gt;in(Similar)-&gt;is_top())) {</span>
<span class="line-removed">-         igvn-&gt;_worklist.push(u);</span>
<span class="line-removed">-       }</span>
      }
  
<span class="line-modified">!     push_dominated_barriers(igvn);</span>
    }
  
<span class="line-modified">!   return NULL;</span>
  }
  
<span class="line-modified">! uint LoadBarrierNode::match_edge(uint idx) const {</span>
<span class="line-modified">!   ShouldNotReachHere();</span>
<span class="line-modified">!   return 0;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- void LoadBarrierNode::fix_similar_in_uses(PhaseIterGVN* igvn) {</span>
<span class="line-removed">-   Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed">-   if (out_res == NULL) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-     Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-removed">-     if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res) {</span>
<span class="line-removed">-       igvn-&gt;replace_input_of(u, Similar, igvn-&gt;C-&gt;top());</span>
<span class="line-removed">-       --i;</span>
<span class="line-removed">-       --imax;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool LoadBarrierNode::has_true_uses() const {</span>
<span class="line-removed">-   Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed">-   if (out_res == NULL) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">!     Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-modified">!     if (!u-&gt;is_LoadBarrier() || u-&gt;in(Similar) != out_res) {</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">!     }</span>
    }
  
<span class="line-modified">!   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // == Accesses ==</span>
<span class="line-removed">- </span>
<span class="line-removed">- Node* ZBarrierSetC2::make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const {</span>
<span class="line-removed">-   assert(!UseCompressedOops, &quot;Not allowed&quot;);</span>
<span class="line-removed">-   CompareAndSwapNode* cas = (CompareAndSwapNode*)access.raw_access();</span>
<span class="line-removed">-   PhaseGVN&amp; gvn = access.gvn();</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">-   GraphKit* kit = access.kit();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* in_ctrl     = cas-&gt;in(MemNode::Control);</span>
<span class="line-removed">-   Node* in_mem      = cas-&gt;in(MemNode::Memory);</span>
<span class="line-removed">-   Node* in_adr      = cas-&gt;in(MemNode::Address);</span>
<span class="line-removed">-   Node* in_val      = cas-&gt;in(MemNode::ValueIn);</span>
<span class="line-removed">-   Node* in_expected = cas-&gt;in(LoadStoreConditionalNode::ExpectedIn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   float likely                   = PROB_LIKELY(0.999);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const TypePtr *adr_type        = gvn.type(in_adr)-&gt;isa_ptr();</span>
<span class="line-removed">-   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);</span>
<span class="line-removed">-   int alias_idx                  = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Outer check - true: continue, false: load and check</span>
<span class="line-removed">-   Node* region   = new RegionNode(3);</span>
<span class="line-removed">-   Node* phi      = new PhiNode(region, TypeInt::BOOL);</span>
<span class="line-removed">-   Node* phi_mem  = new PhiNode(region, Type::MEMORY, adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Inner check - is the healed ref equal to the expected</span>
<span class="line-removed">-   Node* region2  = new RegionNode(3);</span>
<span class="line-removed">-   Node* phi2     = new PhiNode(region2, TypeInt::BOOL);</span>
<span class="line-removed">-   Node* phi_mem2 = new PhiNode(region2, Type::MEMORY, adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // CAS node returns 0 or 1</span>
<span class="line-removed">-   Node* cmp     = gvn.transform(new CmpINode(cas, kit-&gt;intcon(0)));</span>
<span class="line-removed">-   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then    = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed">-   Node* elsen   = gvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* scmemproj1   = gvn.transform(new SCMemProjNode(cas));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   kit-&gt;set_memory(scmemproj1, alias_idx);</span>
<span class="line-removed">-   phi_mem-&gt;init_req(1, scmemproj1);</span>
<span class="line-removed">-   phi_mem2-&gt;init_req(2, scmemproj1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // CAS fail - reload and heal oop</span>
<span class="line-removed">-   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);</span>
<span class="line-removed">-   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));</span>
<span class="line-removed">-   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));</span>
<span class="line-removed">-   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check load</span>
<span class="line-removed">-   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));</span>
<span class="line-removed">-   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));</span>
<span class="line-removed">-   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));</span>
<span class="line-removed">-   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then2   = gvn.transform(new IfTrueNode(iff2));</span>
<span class="line-removed">-   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // redo CAS</span>
<span class="line-removed">-   Node* cas2       = gvn.transform(new CompareAndSwapPNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, cas-&gt;order()));</span>
<span class="line-removed">-   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cas2));</span>
<span class="line-removed">-   kit-&gt;set_control(elsen2);</span>
<span class="line-removed">-   kit-&gt;set_memory(scmemproj2, alias_idx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Merge inner flow - check if healed oop was equal too expected.</span>
<span class="line-removed">-   region2-&gt;set_req(1, kit-&gt;control());</span>
<span class="line-removed">-   region2-&gt;set_req(2, then2);</span>
<span class="line-removed">-   phi2-&gt;set_req(1, cas2);</span>
<span class="line-removed">-   phi2-&gt;set_req(2, kit-&gt;intcon(0));</span>
<span class="line-removed">-   phi_mem2-&gt;init_req(1, scmemproj2);</span>
<span class="line-removed">-   kit-&gt;set_memory(phi_mem2, alias_idx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Merge outer flow - then check if first CAS succeeded</span>
<span class="line-removed">-   region-&gt;set_req(1, then);</span>
<span class="line-removed">-   region-&gt;set_req(2, region2);</span>
<span class="line-removed">-   phi-&gt;set_req(1, kit-&gt;intcon(1));</span>
<span class="line-removed">-   phi-&gt;set_req(2, phi2);</span>
<span class="line-removed">-   phi_mem-&gt;init_req(2, phi_mem2);</span>
<span class="line-removed">-   kit-&gt;set_memory(phi_mem, alias_idx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   gvn.transform(region2);</span>
<span class="line-removed">-   gvn.transform(phi2);</span>
<span class="line-removed">-   gvn.transform(phi_mem2);</span>
<span class="line-removed">-   gvn.transform(region);</span>
<span class="line-removed">-   gvn.transform(phi);</span>
<span class="line-removed">-   gvn.transform(phi_mem);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   kit-&gt;set_control(region);</span>
<span class="line-removed">-   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return phi;</span>
  }
  
<span class="line-modified">! Node* ZBarrierSetC2::make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const {</span>
<span class="line-modified">!   CompareAndExchangePNode* cmpx = (CompareAndExchangePNode*)access.raw_access();</span>
<span class="line-modified">!   GraphKit* kit = access.kit();</span>
<span class="line-modified">!   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-modified">!   Compile* C = Compile::current();</span>
<span class="line-modified">! </span>
<span class="line-removed">-   Node* in_ctrl     = cmpx-&gt;in(MemNode::Control);</span>
<span class="line-removed">-   Node* in_mem      = cmpx-&gt;in(MemNode::Memory);</span>
<span class="line-removed">-   Node* in_adr      = cmpx-&gt;in(MemNode::Address);</span>
<span class="line-removed">-   Node* in_val      = cmpx-&gt;in(MemNode::ValueIn);</span>
<span class="line-removed">-   Node* in_expected = cmpx-&gt;in(LoadStoreConditionalNode::ExpectedIn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   float likely                   = PROB_LIKELY(0.999);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const TypePtr *adr_type        = cmpx-&gt;get_ptr_type();</span>
<span class="line-removed">-   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);</span>
<span class="line-removed">-   int alias_idx                  = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Outer check - true: continue, false: load and check</span>
<span class="line-removed">-   Node* region  = new RegionNode(3);</span>
<span class="line-removed">-   Node* phi     = new PhiNode(region, adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Inner check - is the healed ref equal to the expected</span>
<span class="line-removed">-   Node* region2 = new RegionNode(3);</span>
<span class="line-removed">-   Node* phi2    = new PhiNode(region2, adr_type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check if cmpx succeeded</span>
<span class="line-removed">-   Node* cmp     = gvn.transform(new CmpPNode(cmpx, in_expected));</span>
<span class="line-removed">-   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::eq))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then    = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed">-   Node* elsen   = gvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* scmemproj1  = gvn.transform(new SCMemProjNode(cmpx));</span>
<span class="line-removed">-   kit-&gt;set_memory(scmemproj1, alias_idx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // CAS fail - reload and heal oop</span>
<span class="line-removed">-   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);</span>
<span class="line-removed">-   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));</span>
<span class="line-removed">-   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));</span>
<span class="line-removed">-   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check load</span>
<span class="line-removed">-   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));</span>
<span class="line-removed">-   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));</span>
<span class="line-removed">-   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));</span>
<span class="line-removed">-   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then2   = gvn.transform(new IfTrueNode(iff2));</span>
<span class="line-removed">-   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Redo CAS</span>
<span class="line-removed">-   Node* cmpx2      = gvn.transform(new CompareAndExchangePNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, adr_type, cmpx-&gt;get_ptr_type(), cmpx-&gt;order()));</span>
<span class="line-removed">-   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cmpx2));</span>
<span class="line-removed">-   kit-&gt;set_control(elsen2);</span>
<span class="line-removed">-   kit-&gt;set_memory(scmemproj2, alias_idx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Merge inner flow - check if healed oop was equal too expected.</span>
<span class="line-removed">-   region2-&gt;set_req(1, kit-&gt;control());</span>
<span class="line-removed">-   region2-&gt;set_req(2, then2);</span>
<span class="line-removed">-   phi2-&gt;set_req(1, cmpx2);</span>
<span class="line-removed">-   phi2-&gt;set_req(2, barrierdata);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Merge outer flow - then check if first cas succeeded</span>
<span class="line-removed">-   region-&gt;set_req(1, then);</span>
<span class="line-removed">-   region-&gt;set_req(2, region2);</span>
<span class="line-removed">-   phi-&gt;set_req(1, cmpx);</span>
<span class="line-removed">-   phi-&gt;set_req(2, phi2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   gvn.transform(region2);</span>
<span class="line-removed">-   gvn.transform(phi2);</span>
<span class="line-removed">-   gvn.transform(region);</span>
<span class="line-removed">-   gvn.transform(phi);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   kit-&gt;set_control(region);</span>
<span class="line-removed">-   kit-&gt;set_memory(in_mem, alias_idx);</span>
<span class="line-removed">-   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return phi;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Node* ZBarrierSetC2::load_barrier(GraphKit* kit, Node* val, Node* adr, bool weak, bool writeback, bool oop_reload_allowed) const {</span>
<span class="line-removed">-   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-removed">-   Node* barrier = new LoadBarrierNode(Compile::current(), kit-&gt;control(), kit-&gt;memory(TypeRawPtr::BOTTOM), val, adr, weak, writeback, oop_reload_allowed);</span>
<span class="line-removed">-   Node* transformed_barrier = gvn.transform(barrier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (transformed_barrier-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     if (barrier == transformed_barrier) {</span>
<span class="line-removed">-       kit-&gt;set_control(gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control)));</span>
      }
<span class="line-removed">-     Node* result = gvn.transform(new ProjNode(transformed_barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return val;</span>
    }
  }
  
<span class="line-removed">- static bool barrier_needed(C2Access&amp; access) {</span>
<span class="line-removed">-   return ZBarrierSet::barrier_needed(access.decorators(), access.type());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Node* ZBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<span class="line-modified">!   Node* p = BarrierSetC2::load_at_resolved(access, val_type);</span>
<span class="line-modified">!   if (!barrier_needed(access)) {</span>
<span class="line-removed">-     return p;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool weak = (access.decorators() &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-removed">-   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-removed">-   GraphKit* kit = parse_access.kit();</span>
<span class="line-removed">-   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-removed">-   Node* adr = access.addr().node();</span>
<span class="line-removed">-   Node* heap_base_oop = access.base();</span>
<span class="line-removed">-   bool unsafe = (access.decorators() &amp; C2_UNSAFE_ACCESS) != 0;</span>
<span class="line-removed">-   if (unsafe) {</span>
<span class="line-removed">-     if (!ZVerifyLoadBarriers) {</span>
<span class="line-removed">-       p = load_barrier(kit, p, adr);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (!TypePtr::NULL_PTR-&gt;higher_equal(gvn.type(heap_base_oop))) {</span>
<span class="line-removed">-         p = load_barrier(kit, p, adr);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         IdealKit ideal(kit);</span>
<span class="line-removed">-         IdealVariable res(ideal);</span>
<span class="line-removed">- #define __ ideal.</span>
<span class="line-removed">-         __ declarations_done();</span>
<span class="line-removed">-         __ set(res, p);</span>
<span class="line-removed">-         __ if_then(heap_base_oop, BoolTest::ne, kit-&gt;null(), PROB_UNLIKELY(0.999)); {</span>
<span class="line-removed">-           kit-&gt;sync_kit(ideal);</span>
<span class="line-removed">-           p = load_barrier(kit, p, adr);</span>
<span class="line-removed">-           __ set(res, p);</span>
<span class="line-removed">-           __ sync_kit(kit);</span>
<span class="line-removed">-         } __ end_if();</span>
<span class="line-removed">-         kit-&gt;final_sync(ideal);</span>
<span class="line-removed">-         p = __ value(res);</span>
<span class="line-removed">- #undef __</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return p;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return load_barrier(parse_access.kit(), p, access.addr().node(), weak, true, true);</span>
<span class="line-removed">-   }</span>
  }
  
  Node* ZBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
                                                      Node* new_val, const Type* val_type) const {
<span class="line-modified">!   Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, val_type);</span>
<span class="line-modified">!   if (!barrier_needed(access)) {</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   access.set_needs_pinning(false);</span>
<span class="line-removed">-   return make_cmpx_loadbarrier(access);</span>
  }
  
  Node* ZBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
                                                       Node* new_val, const Type* value_type) const {
<span class="line-modified">!   Node* result = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);</span>
<span class="line-modified">!   if (!barrier_needed(access)) {</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* load_store = access.raw_access();</span>
<span class="line-removed">-   bool weak_cas = (access.decorators() &amp; C2_WEAK_CMPXCHG) != 0;</span>
<span class="line-removed">-   bool expected_is_null = (expected_val-&gt;get_ptr_type() == TypePtr::NULL_PTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!expected_is_null) {</span>
<span class="line-removed">-     if (weak_cas) {</span>
<span class="line-removed">-       access.set_needs_pinning(false);</span>
<span class="line-removed">-       load_store = make_cas_loadbarrier(access);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       access.set_needs_pinning(false);</span>
<span class="line-removed">-       load_store = make_cas_loadbarrier(access);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return load_store;</span>
  }
  
  Node* ZBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* new_val, const Type* val_type) const {
<span class="line-modified">!   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, val_type);</span>
<span class="line-modified">!   if (!barrier_needed(access)) {</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* load_store = access.raw_access();</span>
<span class="line-removed">-   Node* adr = access.addr().node();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-removed">-   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-removed">-   return load_barrier(parse_access.kit(), load_store, adr, false, false, false);</span>
  }
  
<span class="line-modified">! // == Macro Expansion ==</span>
<span class="line-modified">! </span>
<span class="line-modified">! void ZBarrierSetC2::expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const {</span>
<span class="line-modified">!   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">-   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
  
<span class="line-modified">!   if (ZVerifyLoadBarriers) {</span>
<span class="line-modified">!     igvn.replace_node(out_res, in_val);</span>
<span class="line-modified">!     igvn.replace_node(out_ctrl, in_ctrl);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (barrier-&gt;can_be_eliminated()) {</span>
<span class="line-modified">!     // Clone and pin the load for this barrier below the dominating</span>
<span class="line-modified">!     // barrier: the load cannot be allowed to float above the</span>
<span class="line-removed">-     // dominating barrier</span>
<span class="line-removed">-     Node* load = in_val;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (load-&gt;is_Load()) {</span>
<span class="line-removed">-       Node* new_load = load-&gt;clone();</span>
<span class="line-removed">-       Node* addp = new_load-&gt;in(MemNode::Address);</span>
<span class="line-removed">-       assert(addp-&gt;is_AddP() || addp-&gt;is_Phi() || addp-&gt;is_Load(), &quot;bad address&quot;);</span>
<span class="line-removed">-       Node* cast = new CastPPNode(addp, igvn.type(addp), true);</span>
<span class="line-removed">-       Node* ctrl = NULL;</span>
<span class="line-removed">-       Node* similar = barrier-&gt;in(LoadBarrierNode::Similar);</span>
<span class="line-removed">-       if (similar-&gt;is_Phi()) {</span>
<span class="line-removed">-         // already expanded</span>
<span class="line-removed">-         ctrl = similar-&gt;in(0);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         assert(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier(), &quot;unexpected graph shape&quot;);</span>
<span class="line-removed">-         ctrl = similar-&gt;in(0)-&gt;as_LoadBarrier()-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       assert(ctrl != NULL, &quot;bad control&quot;);</span>
<span class="line-removed">-       cast-&gt;set_req(0, ctrl);</span>
<span class="line-removed">-       igvn.transform(cast);</span>
<span class="line-removed">-       new_load-&gt;set_req(MemNode::Address, cast);</span>
<span class="line-removed">-       igvn.transform(new_load);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       igvn.replace_node(out_res, new_load);</span>
<span class="line-removed">-       igvn.replace_node(out_ctrl, in_ctrl);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // cannot eliminate</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // There are two cases that require the basic loadbarrier</span>
<span class="line-removed">-   // 1) When the writeback of a healed oop must be avoided (swap)</span>
<span class="line-removed">-   // 2) When we must guarantee that no reload of is done (swap, cas, cmpx)</span>
<span class="line-removed">-   if (!barrier-&gt;is_writeback()) {</span>
<span class="line-removed">-     assert(!barrier-&gt;oop_reload_allowed(), &quot;writeback barriers should be marked as requires oop&quot;);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   if (!barrier-&gt;oop_reload_allowed()) {</span>
<span class="line-removed">-     expand_loadbarrier_basic(phase, barrier);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     expand_loadbarrier_optimized(phase, barrier);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! // Basic loadbarrier using conventional argument passing</span>
<span class="line-modified">! void ZBarrierSetC2::expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {</span>
<span class="line-modified">!   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">-   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   float unlikely  = PROB_UNLIKELY(0.999);</span>
<span class="line-removed">-   const Type* in_val_maybe_null_t = igvn.type(in_val);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* jthread = igvn.transform(new ThreadLocalNode());</span>
<span class="line-removed">-   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));</span>
<span class="line-removed">-   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered));</span>
<span class="line-removed">-   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));</span>
<span class="line-removed">-   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));</span>
<span class="line-removed">-   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));</span>
<span class="line-removed">-   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then = igvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed">-   Node* elsen = igvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* result_region;</span>
<span class="line-removed">-   Node* result_val;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   result_region = new RegionNode(3);</span>
<span class="line-removed">-   result_val = new PhiNode(result_region, TypeInstPtr::BOTTOM);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   result_region-&gt;set_req(1, elsen);</span>
<span class="line-removed">-   Node* res = igvn.transform(new CastPPNode(in_val, in_val_maybe_null_t));</span>
<span class="line-removed">-   res-&gt;init_req(0, elsen);</span>
<span class="line-removed">-   result_val-&gt;set_req(1, res);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const TypeFunc *tf = load_barrier_Type();</span>
<span class="line-removed">-   Node* call;</span>
<span class="line-removed">-   if (barrier-&gt;is_weak()) {</span>
<span class="line-removed">-     call = new CallLeafNode(tf,</span>
<span class="line-removed">-                             ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr(),</span>
<span class="line-removed">-                             &quot;ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded&quot;,</span>
<span class="line-removed">-                             TypeRawPtr::BOTTOM);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     call = new CallLeafNode(tf,</span>
<span class="line-removed">-                             ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(),</span>
<span class="line-removed">-                             &quot;ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded&quot;,</span>
<span class="line-removed">-                             TypeRawPtr::BOTTOM);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   call-&gt;init_req(TypeFunc::Control, then);</span>
<span class="line-modified">!   call-&gt;init_req(TypeFunc::I_O    , phase-&gt;top());</span>
<span class="line-modified">!   call-&gt;init_req(TypeFunc::Memory , in_mem);</span>
<span class="line-modified">!   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;top());</span>
<span class="line-modified">!   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;top());</span>
<span class="line-removed">-   call-&gt;init_req(TypeFunc::Parms+0, in_val);</span>
<span class="line-removed">-   if (barrier-&gt;is_writeback()) {</span>
<span class="line-removed">-     call-&gt;init_req(TypeFunc::Parms+1, in_adr);</span>
    } else {
<span class="line-modified">!     // When slow path is called with a null address, the healed oop will not be written back</span>
<span class="line-removed">-     call-&gt;init_req(TypeFunc::Parms+1, igvn.zerocon(T_OBJECT));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   call = igvn.transform(call);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* ctrl = igvn.transform(new ProjNode(call, TypeFunc::Control));</span>
<span class="line-removed">-   res = igvn.transform(new ProjNode(call, TypeFunc::Parms));</span>
<span class="line-removed">-   res = igvn.transform(new CheckCastPPNode(ctrl, res, in_val_maybe_null_t));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   result_region-&gt;set_req(2, ctrl);</span>
<span class="line-removed">-   result_val-&gt;set_req(2, res);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   result_region = igvn.transform(result_region);</span>
<span class="line-removed">-   result_val = igvn.transform(result_val);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (out_ctrl != NULL) { // Added if cond</span>
<span class="line-removed">-     igvn.replace_node(out_ctrl, result_region);</span>
    }
<span class="line-removed">-   igvn.replace_node(out_res, result_val);</span>
  }
  
<span class="line-modified">! // Optimized, low spill, loadbarrier variant using stub specialized on register used</span>
<span class="line-modified">! void ZBarrierSetC2::expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {</span>
<span class="line-modified">!   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">! #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-modified">!   Node* preceding_barrier_node = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-modified">! #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* in_mem = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">-   Node* in_val = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   Node* in_adr = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-   Node* out_res = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(barrier-&gt;in(LoadBarrierNode::Oop) != NULL, &quot;oop to loadbarrier node cannot be null&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-removed">-   tty-&gt;print(&quot;\n\n\nBefore barrier optimization:\n&quot;);</span>
<span class="line-removed">-   traverse(barrier, out_ctrl, out_res, -1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   tty-&gt;print(&quot;\nBefore barrier optimization:  preceding_barrier_node\n&quot;);</span>
<span class="line-removed">-   traverse(preceding_barrier_node, out_ctrl, out_res, -1);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   float unlikely  = PROB_UNLIKELY(0.999);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* jthread = igvn.transform(new ThreadLocalNode());</span>
<span class="line-removed">-   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));</span>
<span class="line-removed">-   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr,</span>
<span class="line-removed">-                                                  TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(),</span>
<span class="line-removed">-                                                  MemNode::unordered));</span>
<span class="line-removed">-   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));</span>
<span class="line-removed">-   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));</span>
<span class="line-removed">-   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));</span>
<span class="line-removed">-   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed">-   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed">-   Node* then = igvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed">-   Node* elsen = igvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* slow_path_surrogate;</span>
<span class="line-removed">-   if (!barrier-&gt;is_weak()) {</span>
<span class="line-removed">-     slow_path_surrogate = igvn.transform(new LoadBarrierSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),</span>
<span class="line-removed">-                                                                     (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     slow_path_surrogate = igvn.transform(new LoadBarrierWeakSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),</span>
<span class="line-removed">-                                                                         (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node *new_loadp;</span>
<span class="line-removed">-   new_loadp = slow_path_surrogate;</span>
<span class="line-removed">-   // Create the final region/phi pair to converge cntl/data paths to downstream code</span>
<span class="line-removed">-   Node* result_region = igvn.transform(new RegionNode(3));</span>
<span class="line-removed">-   result_region-&gt;set_req(1, then);</span>
<span class="line-removed">-   result_region-&gt;set_req(2, elsen);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* result_phi = igvn.transform(new PhiNode(result_region, TypeInstPtr::BOTTOM));</span>
<span class="line-removed">-   result_phi-&gt;set_req(1, new_loadp);</span>
<span class="line-removed">-   result_phi-&gt;set_req(2, barrier-&gt;in(LoadBarrierNode::Oop));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Finally, connect the original outputs to the barrier region and phi to complete the expansion/substitution</span>
<span class="line-removed">-   // igvn.replace_node(out_ctrl, result_region);</span>
<span class="line-removed">-   if (out_ctrl != NULL) { // added if cond</span>
<span class="line-removed">-     igvn.replace_node(out_ctrl, result_region);</span>
    }
<span class="line-removed">-   igvn.replace_node(out_res, result_phi);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(barrier-&gt;outcnt() == 0,&quot;LoadBarrier macro node has non-null outputs after expansion!&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-removed">-   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_ctrl\n&quot;);</span>
<span class="line-removed">-   traverse(out_ctrl, out_ctrl, out_res, -1);</span>
<span class="line-removed">-   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_res\n&quot;);</span>
<span class="line-removed">-   traverse(out_res, out_ctrl, out_res, -1);</span>
<span class="line-removed">-   tty-&gt;print(&quot;\nAfter barrier optimization:  old barrier\n&quot;);</span>
<span class="line-removed">-   traverse(barrier, out_ctrl, out_res, -1);</span>
<span class="line-removed">-   tty-&gt;print(&quot;\nAfter barrier optimization:  preceding_barrier_node\n&quot;);</span>
<span class="line-removed">-   traverse(preceding_barrier_node, result_region, result_phi, -1);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(is_gc_barrier_node(result_phi), &quot;sanity&quot;);</span>
<span class="line-removed">-   assert(step_over_gc_barrier(result_phi) == in_val, &quot;sanity&quot;);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool ZBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {</span>
<span class="line-modified">!   ZBarrierSetC2State* s = state();</span>
<span class="line-modified">!   if (s-&gt;load_barrier_count() &gt; 0) {</span>
<span class="line-modified">!     PhaseMacroExpand macro(igvn);</span>
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!     verify_gc_barriers(false);</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!     int skipped = 0;</span>
<span class="line-modified">!     while (s-&gt;load_barrier_count() &gt; skipped) {</span>
<span class="line-modified">!       int load_barrier_count = s-&gt;load_barrier_count();</span>
<span class="line-modified">!       LoadBarrierNode * n = s-&gt;load_barrier_node(load_barrier_count-1-skipped);</span>
<span class="line-modified">!       if (igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {</span>
<span class="line-modified">!         // Node is unreachable, so don&#39;t try to expand it</span>
<span class="line-modified">!         s-&gt;remove_load_barrier_node(n);</span>
<span class="line-modified">!         continue;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       if (!n-&gt;can_be_eliminated()) {</span>
<span class="line-modified">!         skipped++;</span>
<span class="line-modified">!         continue;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       expand_loadbarrier_node(&amp;macro, n);</span>
<span class="line-modified">!       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);</span>
<span class="line-modified">!       if (C-&gt;failing()) {</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     while (s-&gt;load_barrier_count() &gt; 0) {</span>
<span class="line-modified">!       int load_barrier_count = s-&gt;load_barrier_count();</span>
<span class="line-modified">!       LoadBarrierNode* n = s-&gt;load_barrier_node(load_barrier_count - 1);</span>
<span class="line-modified">!       assert(!(igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())), &quot;should have been processed already&quot;);</span>
<span class="line-modified">!       assert(!n-&gt;can_be_eliminated(), &quot;should have been processed already&quot;);</span>
<span class="line-modified">!       expand_loadbarrier_node(&amp;macro, n);</span>
<span class="line-modified">!       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);</span>
<span class="line-modified">!       if (C-&gt;failing()) {</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     igvn.set_delay_transform(false);</span>
<span class="line-modified">!     igvn.optimize();</span>
<span class="line-modified">!     if (C-&gt;failing()) {</span>
        return true;
      }
    }
  
    return false;
  }
  
<span class="line-modified">! // == Loop optimization ==</span>
<span class="line-modified">! </span>
<span class="line-removed">- static bool replace_with_dominating_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, bool last_round) {</span>
<span class="line-removed">-   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   LoadBarrierNode* lb2 = lb-&gt;has_dominating_barrier(phase, false, last_round);</span>
<span class="line-removed">-   if (lb2 == NULL) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (lb-&gt;in(LoadBarrierNode::Oop) != lb2-&gt;in(LoadBarrierNode::Oop)) {</span>
<span class="line-removed">-     assert(lb-&gt;in(LoadBarrierNode::Address) == lb2-&gt;in(LoadBarrierNode::Address), &quot;Invalid address&quot;);</span>
<span class="line-removed">-     igvn.replace_input_of(lb, LoadBarrierNode::Similar, lb2-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">-     C-&gt;set_major_progress();</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">-   lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   assert(lb2-&gt;has_true_uses(), &quot;Invalid uses&quot;);</span>
<span class="line-removed">-   assert(lb2-&gt;in(LoadBarrierNode::Oop) == lb-&gt;in(LoadBarrierNode::Oop), &quot;Invalid oop&quot;);</span>
<span class="line-removed">-   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-removed">-   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-removed">-   igvn.replace_node(val, lb2-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! static Node* find_dominating_memory(PhaseIdealLoop* phase, Node* mem, Node* dom, int i) {</span>
<span class="line-modified">!   assert(dom-&gt;is_Region() || i == -1, &quot;&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* m = mem;</span>
<span class="line-removed">-   while(phase-&gt;is_dominator(dom, phase-&gt;has_ctrl(m) ? phase-&gt;get_ctrl(m) : m-&gt;in(0))) {</span>
<span class="line-removed">-     if (m-&gt;is_Mem()) {</span>
<span class="line-removed">-       assert(m-&gt;as_Mem()-&gt;adr_type() == TypeRawPtr::BOTTOM, &quot;&quot;);</span>
<span class="line-removed">-       m = m-&gt;in(MemNode::Memory);</span>
<span class="line-removed">-     } else if (m-&gt;is_MergeMem()) {</span>
<span class="line-removed">-       m = m-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);</span>
<span class="line-removed">-     } else if (m-&gt;is_Phi()) {</span>
<span class="line-removed">-       if (m-&gt;in(0) == dom &amp;&amp; i != -1) {</span>
<span class="line-removed">-         m = m-&gt;in(i);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         m = m-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else if (m-&gt;is_Proj()) {</span>
<span class="line-removed">-       m = m-&gt;in(0);</span>
<span class="line-removed">-     } else if (m-&gt;is_SafePoint() || m-&gt;is_MemBar()) {</span>
<span class="line-removed">-       m = m-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-       m-&gt;dump();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-       ShouldNotReachHere();</span>
      }
    }
<span class="line-modified">! </span>
<span class="line-modified">!   return m;</span>
  }
  
<span class="line-modified">! static LoadBarrierNode* clone_load_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* ctl, Node* mem, Node* oop_in) {</span>
<span class="line-modified">!   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">!   Compile* C = Compile::current();</span>
<span class="line-modified">!   Node* the_clone = lb-&gt;clone();</span>
<span class="line-modified">!   the_clone-&gt;set_req(LoadBarrierNode::Control, ctl);</span>
<span class="line-modified">!   the_clone-&gt;set_req(LoadBarrierNode::Memory, mem);</span>
<span class="line-modified">!   if (oop_in != NULL) {</span>
<span class="line-modified">!     the_clone-&gt;set_req(LoadBarrierNode::Oop, oop_in);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   LoadBarrierNode* new_lb = the_clone-&gt;as_LoadBarrier();</span>
<span class="line-modified">!   igvn.register_new_node_with_optimizer(new_lb);</span>
<span class="line-modified">!   IdealLoopTree *loop = phase-&gt;get_loop(new_lb-&gt;in(0));</span>
<span class="line-modified">!   phase-&gt;set_ctrl(new_lb, new_lb-&gt;in(0));</span>
<span class="line-modified">!   phase-&gt;set_loop(new_lb, loop);</span>
<span class="line-modified">!   phase-&gt;set_idom(new_lb, new_lb-&gt;in(0), phase-&gt;dom_depth(new_lb-&gt;in(0))+1);</span>
<span class="line-removed">-   if (!loop-&gt;_child) {</span>
<span class="line-removed">-     loop-&gt;_body.push(new_lb);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* proj_ctl = new ProjNode(new_lb, LoadBarrierNode::Control);</span>
<span class="line-removed">-   igvn.register_new_node_with_optimizer(proj_ctl);</span>
<span class="line-removed">-   phase-&gt;set_ctrl(proj_ctl, proj_ctl-&gt;in(0));</span>
<span class="line-removed">-   phase-&gt;set_loop(proj_ctl, loop);</span>
<span class="line-removed">-   phase-&gt;set_idom(proj_ctl, new_lb, phase-&gt;dom_depth(new_lb)+1);</span>
<span class="line-removed">-   if (!loop-&gt;_child) {</span>
<span class="line-removed">-     loop-&gt;_body.push(proj_ctl);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   Node* proj_oop = new ProjNode(new_lb, LoadBarrierNode::Oop);</span>
<span class="line-modified">!   phase-&gt;register_new_node(proj_oop, new_lb);</span>
  
<span class="line-modified">!   if (!new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {</span>
<span class="line-modified">!     LoadBarrierNode* similar = new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-modified">!     if (!phase-&gt;is_dominator(similar, ctl)) {</span>
<span class="line-removed">-       igvn.replace_input_of(new_lb, LoadBarrierNode::Similar, C-&gt;top());</span>
      }
    }
  
<span class="line-modified">!   return new_lb;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static void replace_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* new_val) {</span>
<span class="line-modified">!   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">!   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-modified">!   igvn.replace_node(val, new_val);</span>
<span class="line-modified">!   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-modified">!   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool split_barrier_thru_phi(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">-   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (lb-&gt;in(LoadBarrierNode::Oop)-&gt;is_Phi()) {</span>
<span class="line-removed">-     Node* oop_phi = lb-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if ((oop_phi-&gt;req() != 3) || (oop_phi-&gt;in(2) == oop_phi)) {</span>
<span class="line-removed">-       // Ignore phis with only one input</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (phase-&gt;is_dominator(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)),</span>
<span class="line-modified">!                             oop_phi-&gt;in(0)) &amp;&amp; phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)) != oop_phi-&gt;in(0)) {</span>
<span class="line-modified">!       // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-modified">!       lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       RegionNode* region = oop_phi-&gt;in(0)-&gt;as_Region();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       int backedge = LoopNode::LoopBackControl;</span>
<span class="line-removed">-       if (region-&gt;is_Loop() &amp;&amp; region-&gt;in(backedge)-&gt;is_Proj() &amp;&amp; region-&gt;in(backedge)-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-removed">-         Node* c = region-&gt;in(backedge)-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">-         assert(c-&gt;unique_ctrl_out() == region-&gt;in(backedge)-&gt;in(0), &quot;&quot;);</span>
<span class="line-removed">-         Node* oop = lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(backedge);</span>
<span class="line-removed">-         Node* oop_c = phase-&gt;has_ctrl(oop) ? phase-&gt;get_ctrl(oop) : oop;</span>
<span class="line-removed">-         if (!phase-&gt;is_dominator(oop_c, c)) {</span>
<span class="line-removed">-           return false;</span>
<span class="line-removed">-         }</span>
        }
  
<span class="line-modified">!       // If the node on the backedge above the phi is the node itself - we have a self loop.</span>
<span class="line-modified">!       // Don&#39;t clone - this will be folded later.</span>
<span class="line-modified">!       if (oop_phi-&gt;in(LoopNode::LoopBackControl) == lb-&gt;proj_out(LoadBarrierNode::Oop)) {</span>
<span class="line-removed">-         return false;</span>
        }
  
<span class="line-modified">!       bool is_strip_mined = region-&gt;is_CountedLoop() &amp;&amp; region-&gt;as_CountedLoop()-&gt;is_strip_mined();</span>
<span class="line-modified">!       Node *phi = oop_phi-&gt;clone();</span>
<span class="line-modified">! </span>
<span class="line-modified">!       for (uint i = 1; i &lt; region-&gt;req(); i++) {</span>
<span class="line-modified">!         Node* ctrl = region-&gt;in(i);</span>
<span class="line-modified">!         if (ctrl != C-&gt;top()) {</span>
<span class="line-modified">!           assert(!phase-&gt;is_dominator(ctrl, region) || region-&gt;is_Loop(), &quot;&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!           Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-modified">!           Node* m = find_dominating_memory(phase, mem, region, i);</span>
<span class="line-modified">! </span>
<span class="line-modified">!           if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::LoopBackControl &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-modified">!             ctrl = ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-modified">!           } else if (region-&gt;is_Loop() &amp;&amp; is_strip_mined) {</span>
<span class="line-modified">!             // If this is a strip mined loop, control must move above OuterStripMinedLoop</span>
<span class="line-modified">!             assert(i == LoopNode::EntryControl, &quot;check&quot;);</span>
<span class="line-removed">-             assert(ctrl-&gt;is_OuterStripMinedLoop(), &quot;sanity&quot;);</span>
<span class="line-removed">-             ctrl = ctrl-&gt;as_OuterStripMinedLoop()-&gt;in(LoopNode::EntryControl);</span>
            }
<span class="line-modified">! </span>
<span class="line-modified">!           LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, ctrl, m, lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(i));</span>
<span class="line-modified">!           Node* out_ctrl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (is_strip_mined &amp;&amp; (i == LoopNode::EntryControl)) {</span>
<span class="line-removed">-             assert(region-&gt;in(i)-&gt;is_OuterStripMinedLoop(), &quot;&quot;);</span>
<span class="line-removed">-             igvn.replace_input_of(region-&gt;in(i), i, out_ctrl);</span>
<span class="line-removed">-             phase-&gt;set_idom(region-&gt;in(i), out_ctrl, phase-&gt;dom_depth(out_ctrl));</span>
<span class="line-removed">-           } else if (ctrl == region-&gt;in(i)) {</span>
<span class="line-removed">-             igvn.replace_input_of(region, i, out_ctrl);</span>
<span class="line-removed">-             // Only update the idom if is the loop entry we are updating</span>
<span class="line-removed">-             // - A loop backedge doesn&#39;t change the idom</span>
<span class="line-removed">-             if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::EntryControl) {</span>
<span class="line-removed">-               phase-&gt;set_idom(region, out_ctrl, phase-&gt;dom_depth(out_ctrl));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             Node* iff = region-&gt;in(i)-&gt;in(0);</span>
<span class="line-removed">-             igvn.replace_input_of(iff, 0, out_ctrl);</span>
<span class="line-removed">-             phase-&gt;set_idom(iff, out_ctrl, phase-&gt;dom_depth(out_ctrl)+1);</span>
            }
<span class="line-modified">!           phi-&gt;set_req(i, new_lb-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       phase-&gt;register_new_node(phi, region);</span>
<span class="line-removed">-       replace_barrier(phase, lb, phi);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (region-&gt;is_Loop()) {</span>
<span class="line-removed">-         // Load barrier moved to the back edge of the Loop may now</span>
<span class="line-removed">-         // have a safepoint on the path to the barrier on the Similar</span>
<span class="line-removed">-         // edge</span>
<span class="line-removed">-         igvn.replace_input_of(phi-&gt;in(LoopNode::LoopBackControl)-&gt;in(0), LoadBarrierNode::Similar, C-&gt;top());</span>
<span class="line-removed">-         Node* head = region-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">-         phase-&gt;set_idom(region, head, phase-&gt;dom_depth(head)+1);</span>
<span class="line-removed">-         phase-&gt;recompute_dom_depth();</span>
<span class="line-removed">-         if (head-&gt;is_CountedLoop() &amp;&amp; head-&gt;as_CountedLoop()-&gt;is_main_loop()) {</span>
<span class="line-removed">-           head-&gt;as_CountedLoop()-&gt;set_normal_loop();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool move_out_of_loop(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">-   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">-   IdealLoopTree *lb_loop = phase-&gt;get_loop(lb-&gt;in(0));</span>
<span class="line-removed">-   if (lb_loop != phase-&gt;ltree_root() &amp;&amp; !lb_loop-&gt;_irreducible) {</span>
<span class="line-removed">-     Node* oop_ctrl = phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Oop));</span>
<span class="line-removed">-     IdealLoopTree *oop_loop = phase-&gt;get_loop(oop_ctrl);</span>
<span class="line-removed">-     IdealLoopTree* adr_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)));</span>
<span class="line-removed">-     if (!lb_loop-&gt;is_member(oop_loop) &amp;&amp; !lb_loop-&gt;is_member(adr_loop)) {</span>
<span class="line-removed">-       // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">-       lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       Node* head = lb_loop-&gt;_head;</span>
<span class="line-removed">-       assert(head-&gt;is_Loop(), &quot;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (phase-&gt;is_dominator(head, oop_ctrl)) {</span>
<span class="line-removed">-         assert(oop_ctrl-&gt;Opcode() == Op_CProj &amp;&amp; oop_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch, &quot;&quot;);</span>
<span class="line-removed">-         assert(lb_loop-&gt;is_member(phase-&gt;get_loop(oop_ctrl-&gt;in(0)-&gt;in(0))), &quot;&quot;);</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (head-&gt;is_CountedLoop()) {</span>
<span class="line-removed">-         CountedLoopNode* cloop = head-&gt;as_CountedLoop();</span>
<span class="line-removed">-         if (cloop-&gt;is_main_loop()) {</span>
<span class="line-removed">-           cloop-&gt;set_normal_loop();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // When we are moving barrier out of a counted loop,</span>
<span class="line-removed">-         // make sure we move it all the way out of the strip mined outer loop.</span>
<span class="line-removed">-         if (cloop-&gt;is_strip_mined()) {</span>
<span class="line-removed">-           head = cloop-&gt;outer_loop();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">-       Node* m = find_dominating_memory(phase, mem, head, -1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, head-&gt;in(LoopNode::EntryControl), m, NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       assert(phase-&gt;idom(head) == head-&gt;in(LoopNode::EntryControl), &quot;&quot;);</span>
<span class="line-removed">-       Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-       igvn.replace_input_of(head, LoopNode::EntryControl, proj_ctl);</span>
<span class="line-removed">-       phase-&gt;set_idom(head, proj_ctl, phase-&gt;dom_depth(proj_ctl) + 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       replace_barrier(phase, lb, new_lb-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">- </span>
<span class="line-removed">-       phase-&gt;recompute_dom_depth();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool common_barriers(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">-   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">-   Node* in_val = lb-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   for (DUIterator_Fast imax, i = in_val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-     Node* u = in_val-&gt;fast_out(i);</span>
<span class="line-removed">-     if (u != lb &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">-       Node* this_ctrl = lb-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">-       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       Node* lca = phase-&gt;dom_lca(this_ctrl, other_ctrl);</span>
<span class="line-removed">-       bool ok = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       Node* proj1 = NULL;</span>
<span class="line-removed">-       Node* proj2 = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       while (this_ctrl != lca &amp;&amp; ok) {</span>
<span class="line-removed">-         if (this_ctrl-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">-             this_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {</span>
<span class="line-removed">-           if (this_ctrl-&gt;in(0)-&gt;in(0) == lca) {</span>
<span class="line-removed">-             assert(proj1 == NULL, &quot;&quot;);</span>
<span class="line-removed">-             assert(this_ctrl-&gt;is_Proj(), &quot;&quot;);</span>
<span class="line-removed">-             proj1 = this_ctrl;</span>
<span class="line-removed">-           } else if (!(this_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; this_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {</span>
<span class="line-removed">-             ok = false;</span>
            }
<span class="line-modified">!         }</span>
<span class="line-modified">!         this_ctrl = phase-&gt;idom(this_ctrl);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       while (other_ctrl != lca &amp;&amp; ok) {</span>
<span class="line-modified">!         if (other_ctrl-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">-             other_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {</span>
<span class="line-removed">-           if (other_ctrl-&gt;in(0)-&gt;in(0) == lca) {</span>
<span class="line-removed">-             assert(other_ctrl-&gt;is_Proj(), &quot;&quot;);</span>
<span class="line-removed">-             assert(proj2 == NULL, &quot;&quot;);</span>
<span class="line-removed">-             proj2 = other_ctrl;</span>
<span class="line-removed">-           } else if (!(other_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; other_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {</span>
<span class="line-removed">-             ok = false;</span>
            }
          }
<span class="line-removed">-         other_ctrl = phase-&gt;idom(other_ctrl);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       assert(proj1 == NULL || proj2 == NULL || proj1-&gt;in(0) == proj2-&gt;in(0), &quot;&quot;);</span>
<span class="line-removed">-       if (ok &amp;&amp; proj1 &amp;&amp; proj2 &amp;&amp; proj1 != proj2 &amp;&amp; proj1-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-removed">-         // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">-         lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">-         u-&gt;as_LoadBarrier()-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Node* split = lca-&gt;unique_ctrl_out();</span>
<span class="line-removed">-         assert(split-&gt;in(0) == lca, &quot;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">-         Node* m = find_dominating_memory(phase, mem, split, -1);</span>
<span class="line-removed">-         LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, lca, m, NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">-         igvn.replace_input_of(split, 0, new_lb-&gt;proj_out(LoadBarrierNode::Control));</span>
<span class="line-removed">-         phase-&gt;set_idom(split, proj_ctl, phase-&gt;dom_depth(proj_ctl)+1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Node* proj_oop = new_lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">-         replace_barrier(phase, lb, proj_oop);</span>
<span class="line-removed">-         replace_barrier(phase, u-&gt;as_LoadBarrier(), proj_oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         phase-&gt;recompute_dom_depth();</span>
  
<span class="line-modified">!         return true;</span>
        }
      }
    }
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZBarrierSetC2::loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round) {</span>
<span class="line-removed">-   if (!Compile::current()-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (replace_with_dominating_barrier(phase, node-&gt;as_LoadBarrier(), last_round)) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (split_barrier_thru_phi(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (move_out_of_loop(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (common_barriers(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Node* ZBarrierSetC2::step_over_gc_barrier(Node* c) const {</span>
<span class="line-removed">-   Node* node = c;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // 1. This step follows potential oop projections of a load barrier before expansion</span>
<span class="line-removed">-   if (node-&gt;is_Proj()) {</span>
<span class="line-removed">-     node = node-&gt;in(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // 2. This step checks for unexpanded load barriers</span>
<span class="line-removed">-   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-     return node-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // 3. This step checks for the phi corresponding to an optimized load barrier expansion</span>
<span class="line-removed">-   if (node-&gt;is_Phi()) {</span>
<span class="line-removed">-     PhiNode* phi = node-&gt;as_Phi();</span>
<span class="line-removed">-     Node* n = phi-&gt;in(1);</span>
<span class="line-removed">-     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {</span>
<span class="line-removed">-       assert(c == node, &quot;projections from step 1 should only be seen before macro expansion&quot;);</span>
<span class="line-removed">-       return phi-&gt;in(2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return c;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {</span>
<span class="line-removed">-   return type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {</span>
<span class="line-removed">-   if (opcode != Op_LoadBarrierSlowReg &amp;&amp;</span>
<span class="line-removed">-       opcode != Op_LoadBarrierWeakSlowReg) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   if (VerifyOptoOopOffsets) {</span>
<span class="line-removed">-     MemNode* mem  = n-&gt;as_Mem();</span>
<span class="line-removed">-     // Check to see if address types have grounded out somehow.</span>
<span class="line-removed">-     const TypeInstPtr* tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();</span>
<span class="line-removed">-     ciInstanceKlass* k = tp-&gt;klass()-&gt;as_instance_klass();</span>
<span class="line-removed">-     bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());</span>
<span class="line-removed">-     assert(!tp || oop_offset_is_sane, &quot;&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {</span>
<span class="line-removed">-   if (opcode == Op_CallLeaf &amp;&amp;</span>
<span class="line-removed">-       (n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr() ||</span>
<span class="line-removed">-        n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr())) {</span>
<span class="line-removed">-     mem_op = true;</span>
<span class="line-removed">-     mem_addr_idx = TypeFunc::Parms + 1;</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
  }
  
<span class="line-modified">! // == Verification ==</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
  
<span class="line-modified">! static bool look_for_barrier(Node* n, bool post_parse, VectorSet&amp; visited) {</span>
<span class="line-modified">!   if (visited.test_set(n-&gt;_idx)) {</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">!     Node* u = n-&gt;fast_out(i);</span>
<span class="line-modified">!     if (u-&gt;is_LoadBarrier()) {</span>
<span class="line-modified">!     } else if ((u-&gt;is_Phi() || u-&gt;is_CMove()) &amp;&amp; !post_parse) {</span>
<span class="line-modified">!       if (!look_for_barrier(u, post_parse, visited)) {</span>
<span class="line-modified">!         return false;</span>
        }
<span class="line-modified">!     } else if (u-&gt;Opcode() == Op_EncodeP || u-&gt;Opcode() == Op_DecodeN) {</span>
<span class="line-modified">!       if (!look_for_barrier(u, post_parse, visited)) {</span>
<span class="line-removed">-         return false;</span>
        }
<span class="line-removed">-     } else if (u-&gt;Opcode() != Op_SCMemProj) {</span>
<span class="line-removed">-       tty-&gt;print(&quot;bad use&quot;); u-&gt;dump();</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void ZBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {</span>
<span class="line-modified">!   if (phase == BarrierSetC2::BeforeCodeGen) return;</span>
<span class="line-modified">!   bool post_parse = phase == BarrierSetC2::BeforeOptimize;</span>
<span class="line-modified">!   verify_gc_barriers(post_parse);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void ZBarrierSetC2::verify_gc_barriers(bool post_parse) const {</span>
<span class="line-removed">-   ZBarrierSetC2State* s = state();</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">-   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {</span>
<span class="line-removed">-     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The dominating barrier on the same address if it exists and</span>
<span class="line-removed">-     // this barrier must not be applied on the value from the same</span>
<span class="line-removed">-     // load otherwise the value is not reloaded before it&#39;s used the</span>
<span class="line-removed">-     // second time.</span>
<span class="line-removed">-     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||</span>
<span class="line-removed">-            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;</span>
<span class="line-removed">-             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Address) == n-&gt;in(LoadBarrierNode::Address) &amp;&amp;</span>
<span class="line-removed">-             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Oop) != n-&gt;in(LoadBarrierNode::Oop)),</span>
<span class="line-removed">-            &quot;broken similar edge&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     assert(post_parse || n-&gt;as_LoadBarrier()-&gt;has_true_uses(),</span>
<span class="line-removed">-            &quot;found unneeded load barrier&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Several load barrier nodes chained through their Similar edge</span>
<span class="line-removed">-     // break the code that remove the barriers in final graph reshape.</span>
<span class="line-removed">-     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||</span>
<span class="line-removed">-            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;</span>
<span class="line-removed">-             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()),</span>
<span class="line-removed">-            &quot;chain of Similar load barriers&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {</span>
<span class="line-removed">-       ResourceMark rm;</span>
<span class="line-removed">-       Unique_Node_List wq;</span>
<span class="line-removed">-       Node* other = n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0);</span>
<span class="line-removed">-       wq.push(n);</span>
<span class="line-removed">-       bool ok = true;</span>
<span class="line-removed">-       bool dom_found = false;</span>
<span class="line-removed">-       for (uint next = 0; next &lt; wq.size(); ++next) {</span>
<span class="line-removed">-         Node *n = wq.at(next);</span>
<span class="line-removed">-         assert(n-&gt;is_CFG(), &quot;&quot;);</span>
<span class="line-removed">-         assert(!n-&gt;is_SafePoint(), &quot;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (n == other) {</span>
<span class="line-removed">-           continue;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         if (n-&gt;is_Region()) {</span>
<span class="line-removed">-           for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed">-             Node* m = n-&gt;in(i);</span>
<span class="line-removed">-             if (m != NULL) {</span>
<span class="line-removed">-               wq.push(m);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           Node* m = n-&gt;in(0);</span>
<span class="line-removed">-           if (m != NULL) {</span>
<span class="line-removed">-             wq.push(m);</span>
<span class="line-removed">-           }</span>
          }
        }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (ZVerifyLoadBarriers) {</span>
<span class="line-modified">!       if ((n-&gt;is_Load() || n-&gt;is_LoadStore()) &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr() != NULL) {</span>
<span class="line-modified">!         visited.Clear();</span>
<span class="line-modified">!         bool found = look_for_barrier(n, post_parse, visited);</span>
<span class="line-removed">-         if (!found) {</span>
<span class="line-removed">-           n-&gt;dump(1);</span>
<span class="line-removed">-           n-&gt;dump(-3);</span>
<span class="line-removed">-           stringStream ss;</span>
<span class="line-removed">-           C-&gt;method()-&gt;print_short_name(&amp;ss);</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;-%s-&quot;, ss.as_string());</span>
<span class="line-removed">-           assert(found, &quot;&quot;);</span>
<span class="line-removed">-         }</span>
        }
      }
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {</span>
<span class="line-removed">-   switch (opcode) {</span>
<span class="line-removed">-     case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">-     case Op_LoadBarrierWeakSlowReg:</span>
<span class="line-removed">-       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case Op_Proj:</span>
<span class="line-removed">-       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), delayed_worklist);</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool ZBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {</span>
<span class="line-modified">!   switch (opcode) {</span>
<span class="line-modified">!     case Op_LoadBarrierSlowReg:</span>
<span class="line-modified">!     case Op_LoadBarrierWeakSlowReg:</span>
<span class="line-modified">!       if (gvn-&gt;type(n)-&gt;make_ptr() == NULL) {</span>
<span class="line-modified">!         return false;</span>
        }
<span class="line-modified">!       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(MemNode::Address), NULL);</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     case Op_Proj:</span>
<span class="line-removed">-       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), NULL);</span>
<span class="line-removed">-       return true;</span>
    }
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
  }
<span class="line-new-header">--- 20,482 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;classfile/javaClasses.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/zBarrierSet.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/zBarrierSetAssembler.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;</span>
<span class="line-added">+ #include &quot;opto/arraycopynode.hpp&quot;</span>
<span class="line-added">+ #include &quot;opto/addnode.hpp&quot;</span>
<span class="line-added">+ #include &quot;opto/block.hpp&quot;</span>
  #include &quot;opto/compile.hpp&quot;
  #include &quot;opto/graphKit.hpp&quot;
<span class="line-modified">! #include &quot;opto/machnode.hpp&quot;</span>
  #include &quot;opto/macro.hpp&quot;
<span class="line-added">+ #include &quot;opto/memnode.hpp&quot;</span>
  #include &quot;opto/node.hpp&quot;
<span class="line-added">+ #include &quot;opto/regalloc.hpp&quot;</span>
<span class="line-added">+ #include &quot;opto/rootnode.hpp&quot;</span>
  #include &quot;opto/type.hpp&quot;
<span class="line-added">+ #include &quot;utilities/growableArray.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  
<span class="line-modified">! class ZBarrierSetC2State : public ResourceObj {</span>
<span class="line-modified">! private:</span>
<span class="line-added">+   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* _stubs;</span>
<span class="line-added">+   Node_Array                          _live;</span>
  
<span class="line-modified">! public:</span>
<span class="line-modified">!   ZBarrierSetC2State(Arena* arena) :</span>
<span class="line-modified">!     _stubs(new (arena) GrowableArray&lt;ZLoadBarrierStubC2*&gt;(arena, 8,  0, NULL)),</span>
<span class="line-modified">!     _live(arena) {}</span>
  
<span class="line-modified">!   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* stubs() {</span>
<span class="line-modified">!     return _stubs;</span>
    }
  
<span class="line-modified">!   RegMask* live(const Node* node) {</span>
<span class="line-modified">!     if (!node-&gt;is_Mach()) {</span>
<span class="line-modified">!       // Don&#39;t need liveness for non-MachNodes</span>
<span class="line-modified">!       return NULL;</span>
      }
  
<span class="line-modified">!     const MachNode* const mach = node-&gt;as_Mach();</span>
<span class="line-modified">!     if (mach-&gt;barrier_data() != ZLoadBarrierStrong &amp;&amp;</span>
<span class="line-modified">!         mach-&gt;barrier_data() != ZLoadBarrierWeak) {</span>
<span class="line-modified">!       // Don&#39;t need liveness data for nodes without barriers</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     RegMask* live = (RegMask*)_live[node-&gt;_idx];</span>
<span class="line-modified">!     if (live == NULL) {</span>
<span class="line-modified">!       live = new (Compile::current()-&gt;comp_arena()-&gt;Amalloc_D(sizeof(RegMask))) RegMask();</span>
<span class="line-modified">!       _live.map(node-&gt;_idx, (Node*)live);</span>
      }
  
<span class="line-modified">!     return live;</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! static ZBarrierSetC2State* barrier_set_state() {</span>
<span class="line-modified">!   return reinterpret_cast&lt;ZBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());</span>
  }
  
<span class="line-modified">! ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {</span>
<span class="line-modified">!   ZLoadBarrierStubC2* const stub = new (Compile::current()-&gt;comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, weak);</span>
<span class="line-modified">!   if (!Compile::current()-&gt;in_scratch_emit_size()) {</span>
<span class="line-modified">!     barrier_set_state()-&gt;stubs()-&gt;append(stub);</span>
    }
  
<span class="line-modified">!   return stub;</span>
  }
  
<span class="line-modified">! ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) :</span>
<span class="line-modified">!     _node(node),</span>
<span class="line-modified">!     _ref_addr(ref_addr),</span>
<span class="line-modified">!     _ref(ref),</span>
<span class="line-modified">!     _tmp(tmp),</span>
      _weak(weak),
<span class="line-modified">!     _entry(),</span>
<span class="line-modified">!     _continuation() {</span>
<span class="line-modified">!   assert_different_registers(ref, ref_addr.base());</span>
<span class="line-modified">!   assert_different_registers(ref, ref_addr.index());</span>
  }
  
<span class="line-modified">! Address ZLoadBarrierStubC2::ref_addr() const {</span>
<span class="line-modified">!   return _ref_addr;</span>
  }
  
<span class="line-modified">! Register ZLoadBarrierStubC2::ref() const {</span>
<span class="line-modified">!   return _ref;</span>
  }
  
<span class="line-modified">! Register ZLoadBarrierStubC2::tmp() const {</span>
<span class="line-modified">!   return _tmp;</span>
  }
  
<span class="line-modified">! address ZLoadBarrierStubC2::slow_path() const {</span>
<span class="line-modified">!   const DecoratorSet decorators = _weak ? ON_WEAK_OOP_REF : ON_STRONG_OOP_REF;</span>
<span class="line-modified">!   return ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(decorators);</span>
  }
  
<span class="line-modified">! RegMask&amp; ZLoadBarrierStubC2::live() const {</span>
<span class="line-modified">!   return *barrier_set_state()-&gt;live(_node);</span>
  }
  
<span class="line-modified">! Label* ZLoadBarrierStubC2::entry() {</span>
<span class="line-modified">!   // The _entry will never be bound when in_scratch_emit_size() is true.</span>
<span class="line-modified">!   // However, we still need to return a label that is not bound now, but</span>
<span class="line-modified">!   // will eventually be bound. Any lable will do, as it will only act as</span>
<span class="line-modified">!   // a placeholder, so we return the _continuation label.</span>
<span class="line-modified">!   return Compile::current()-&gt;in_scratch_emit_size() ? &amp;_continuation : &amp;_entry;</span>
  }
  
<span class="line-modified">! Label* ZLoadBarrierStubC2::continuation() {</span>
<span class="line-modified">!   return &amp;_continuation;</span>
  }
  
<span class="line-modified">! void* ZBarrierSetC2::create_barrier_state(Arena* comp_arena) const {</span>
<span class="line-modified">!   return new (comp_arena) ZBarrierSetC2State(comp_arena);</span>
  }
  
<span class="line-modified">! void ZBarrierSetC2::late_barrier_analysis() const {</span>
<span class="line-modified">!   analyze_dominating_barriers();</span>
<span class="line-modified">!   compute_liveness_at_stubs();</span>
  }
  
<span class="line-modified">! void ZBarrierSetC2::emit_stubs(CodeBuffer&amp; cb) const {</span>
<span class="line-modified">!   MacroAssembler masm(&amp;cb);</span>
<span class="line-modified">!   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* const stubs = barrier_set_state()-&gt;stubs();</span>
  
<span class="line-modified">!   for (int i = 0; i &lt; stubs-&gt;length(); i++) {</span>
<span class="line-modified">!     // Make sure there is enough space in the code buffer</span>
<span class="line-modified">!     if (cb.insts()-&gt;maybe_expand_to_ensure_remaining(Compile::MAX_inst_size) &amp;&amp; cb.blob() == NULL) {</span>
<span class="line-modified">!       ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);</span>
<span class="line-modified">!       return;</span>
      }
  
<span class="line-modified">!     ZBarrierSet::assembler()-&gt;generate_c2_load_barrier_stub(&amp;masm, stubs-&gt;at(i));</span>
    }
  
<span class="line-modified">!   masm.flush();</span>
  }
  
<span class="line-modified">! int ZBarrierSetC2::estimate_stub_size() const {</span>
<span class="line-modified">!   Compile* const C = Compile::current();</span>
<span class="line-modified">!   BufferBlob* const blob = C-&gt;scratch_buffer_blob();</span>
<span class="line-modified">!   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* const stubs = barrier_set_state()-&gt;stubs();</span>
<span class="line-modified">!   int size = 0;</span>
  
<span class="line-modified">!   for (int i = 0; i &lt; stubs-&gt;length(); i++) {</span>
<span class="line-modified">!     CodeBuffer cb(blob-&gt;content_begin(), (address)C-&gt;scratch_locs_memory() - blob-&gt;content_begin());</span>
<span class="line-modified">!     MacroAssembler masm(&amp;cb);</span>
<span class="line-modified">!     ZBarrierSet::assembler()-&gt;generate_c2_load_barrier_stub(&amp;masm, stubs-&gt;at(i));</span>
<span class="line-modified">!     size += cb.insts_size();</span>
    }
  
<span class="line-modified">!   return size;</span>
  }
  
<span class="line-modified">! static void set_barrier_data(C2Access&amp; access) {</span>
<span class="line-modified">!   if (ZBarrierSet::barrier_needed(access.decorators(), access.type())) {</span>
<span class="line-modified">!     if (access.decorators() &amp; ON_WEAK_OOP_REF) {</span>
<span class="line-modified">!       access.set_barrier_data(ZLoadBarrierWeak);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       access.set_barrier_data(ZLoadBarrierStrong);</span>
      }
    }
  }
  
  Node* ZBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<span class="line-modified">!   set_barrier_data(access);</span>
<span class="line-modified">!   return BarrierSetC2::load_at_resolved(access, val_type);</span>
  }
  
  Node* ZBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
                                                      Node* new_val, const Type* val_type) const {
<span class="line-modified">!   set_barrier_data(access);</span>
<span class="line-modified">!   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, val_type);</span>
  }
  
  Node* ZBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
                                                       Node* new_val, const Type* value_type) const {
<span class="line-modified">!   set_barrier_data(access);</span>
<span class="line-modified">!   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);</span>
  }
  
  Node* ZBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* new_val, const Type* val_type) const {
<span class="line-modified">!   set_barrier_data(access);</span>
<span class="line-modified">!   return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, val_type);</span>
  }
  
<span class="line-modified">! bool ZBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type,</span>
<span class="line-modified">!                                                     bool is_clone, ArrayCopyPhase phase) const {</span>
<span class="line-modified">!   return type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! // This TypeFunc assumes a 64bit system</span>
<span class="line-modified">! static const TypeFunc* clone_type() {</span>
<span class="line-modified">!   // Create input type (domain)</span>
<span class="line-modified">!   const Type** domain_fields = TypeTuple::fields(4);</span>
<span class="line-modified">!   domain_fields[TypeFunc::Parms + 0] = TypeInstPtr::NOTNULL;  // src</span>
<span class="line-added">+   domain_fields[TypeFunc::Parms + 1] = TypeInstPtr::NOTNULL;  // dst</span>
<span class="line-added">+   domain_fields[TypeFunc::Parms + 2] = TypeLong::LONG;        // size lower</span>
<span class="line-added">+   domain_fields[TypeFunc::Parms + 3] = Type::HALF;            // size upper</span>
<span class="line-added">+   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + 4, domain_fields);</span>
  
<span class="line-modified">!   // Create result type (range)</span>
<span class="line-modified">!   const Type** range_fields = TypeTuple::fields(0);</span>
<span class="line-modified">!   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);</span>
  
<span class="line-modified">!   return TypeFunc::make(domain, range);</span>
  }
  
<span class="line-modified">! // Node n is pointing to the start of oop payload - return base pointer</span>
<span class="line-modified">! static Node* get_base_for_arracycopy_clone(PhaseMacroExpand* phase, Node* n) {</span>
<span class="line-modified">!   // This would normally be handled by optimizations, but the type system</span>
<span class="line-modified">!   // checks get confused when it thinks it already has a base pointer.</span>
<span class="line-modified">!   const int base_offset = BarrierSetC2::arraycopy_payload_base_offset(false);</span>
  
<span class="line-modified">!   if (n-&gt;is_AddP() &amp;&amp;</span>
<span class="line-modified">!       n-&gt;in(AddPNode::Offset)-&gt;is_Con() &amp;&amp;</span>
<span class="line-modified">!       n-&gt;in(AddPNode::Offset)-&gt;get_long() == base_offset) {</span>
<span class="line-modified">!     assert(n-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Address), &quot;Sanity check&quot;);</span>
<span class="line-modified">!     return n-&gt;in(AddPNode::Base);</span>
    } else {
<span class="line-modified">!     return phase-&gt;basic_plus_adr(n, phase-&gt;longcon(-base_offset));</span>
    }
  }
  
<span class="line-modified">! void ZBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {</span>
<span class="line-modified">!   Node* const src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified">!   if (ac-&gt;is_clone_array()) {</span>
<span class="line-modified">!     // Clone primitive array</span>
<span class="line-modified">!     BarrierSetC2::clone_at_expansion(phase, ac);</span>
<span class="line-modified">!     return;</span>
    }
  
<span class="line-modified">!   // Clone instance</span>
<span class="line-modified">!   assert(ac-&gt;is_clone_inst(), &quot;Sanity check&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* const ctrl       = ac-&gt;in(TypeFunc::Control);</span>
<span class="line-modified">!   Node* const mem        = ac-&gt;in(TypeFunc::Memory);</span>
<span class="line-modified">!   Node* const dst        = ac-&gt;in(ArrayCopyNode::Dest);</span>
<span class="line-modified">!   Node* const src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);</span>
<span class="line-modified">!   Node* const dst_offset = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="line-modified">!   Node* const size       = ac-&gt;in(ArrayCopyNode::Length);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(src_offset == NULL, &quot;Should be null&quot;);</span>
<span class="line-modified">!   assert(dst_offset == NULL, &quot;Should be null&quot;);</span>
<span class="line-modified">!   assert(size-&gt;bottom_type()-&gt;is_long(), &quot;Should be long&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The src and dst point to the object payload rather than the object base</span>
<span class="line-modified">!   Node* const src_base = get_base_for_arracycopy_clone(phase, src);</span>
<span class="line-modified">!   Node* const dst_base = get_base_for_arracycopy_clone(phase, dst);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The size must also be increased to match the instance size</span>
<span class="line-modified">!   Node* const base_offset = phase-&gt;longcon(arraycopy_payload_base_offset(false) &gt;&gt; LogBytesPerLong);</span>
<span class="line-modified">!   Node* const full_size = phase-&gt;transform_later(new AddLNode(size, base_offset));</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* const call = phase-&gt;make_leaf_call(ctrl,</span>
<span class="line-modified">!                                            mem,</span>
<span class="line-modified">!                                            clone_type(),</span>
<span class="line-modified">!                                            ZBarrierSetRuntime::clone_addr(),</span>
<span class="line-modified">!                                            &quot;ZBarrierSetRuntime::clone&quot;,</span>
<span class="line-modified">!                                            TypeRawPtr::BOTTOM,</span>
<span class="line-modified">!                                            src_base,</span>
<span class="line-modified">!                                            dst_base,</span>
<span class="line-modified">!                                            full_size,</span>
<span class="line-modified">!                                            phase-&gt;top());</span>
<span class="line-modified">!   phase-&gt;transform_later(call);</span>
<span class="line-modified">!   phase-&gt;igvn().replace_node(ac, call);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // == Dominating barrier elision ==</span>
<span class="line-modified">! </span>
<span class="line-modified">! static bool block_has_safepoint(const Block* block, uint from, uint to) {</span>
<span class="line-modified">!   for (uint i = from; i &lt; to; i++) {</span>
<span class="line-added">+     if (block-&gt;get_node(i)-&gt;is_MachSafePoint()) {</span>
<span class="line-added">+       // Safepoint found</span>
        return true;
      }
    }
  
<span class="line-added">+   // Safepoint not found</span>
    return false;
  }
  
<span class="line-modified">! static bool block_has_safepoint(const Block* block) {</span>
<span class="line-modified">!   return block_has_safepoint(block, 0, block-&gt;number_of_nodes());</span>
  }
  
<span class="line-modified">! static uint block_index(const Block* block, const Node* node) {</span>
<span class="line-modified">!   for (uint j = 0; j &lt; block-&gt;number_of_nodes(); ++j) {</span>
<span class="line-modified">!     if (block-&gt;get_node(j) == node) {</span>
<span class="line-modified">!       return j;</span>
      }
    }
<span class="line-modified">!   ShouldNotReachHere();</span>
<span class="line-modified">!   return 0;</span>
  }
  
<span class="line-modified">! void ZBarrierSetC2::analyze_dominating_barriers() const {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   Compile* const C = Compile::current();</span>
<span class="line-modified">!   PhaseCFG* const cfg = C-&gt;cfg();</span>
<span class="line-modified">!   Block_List worklist;</span>
<span class="line-modified">!   Node_List mem_ops;</span>
<span class="line-modified">!   Node_List barrier_loads;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Step 1 - Find accesses, and track them in lists</span>
<span class="line-modified">!   for (uint i = 0; i &lt; cfg-&gt;number_of_blocks(); ++i) {</span>
<span class="line-modified">!     const Block* const block = cfg-&gt;get_block(i);</span>
<span class="line-modified">!     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); ++j) {</span>
<span class="line-modified">!       const Node* const node = block-&gt;get_node(j);</span>
<span class="line-modified">!       if (!node-&gt;is_Mach()) {</span>
<span class="line-modified">!         continue;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       MachNode* const mach = node-&gt;as_Mach();</span>
<span class="line-modified">!       switch (mach-&gt;ideal_Opcode()) {</span>
<span class="line-added">+       case Op_LoadP:</span>
<span class="line-added">+       case Op_CompareAndExchangeP:</span>
<span class="line-added">+       case Op_CompareAndSwapP:</span>
<span class="line-added">+       case Op_GetAndSetP:</span>
<span class="line-added">+         if (mach-&gt;barrier_data() == ZLoadBarrierStrong) {</span>
<span class="line-added">+           barrier_loads.push(mach);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       case Op_StoreP:</span>
<span class="line-added">+         mem_ops.push(mach);</span>
<span class="line-added">+         break;</span>
  
<span class="line-modified">!       default:</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
      }
    }
  
<span class="line-modified">!   // Step 2 - Find dominating accesses for each load</span>
<span class="line-modified">!   for (uint i = 0; i &lt; barrier_loads.size(); i++) {</span>
<span class="line-added">+     MachNode* const load = barrier_loads.at(i)-&gt;as_Mach();</span>
<span class="line-added">+     const TypePtr* load_adr_type = NULL;</span>
<span class="line-added">+     intptr_t load_offset = 0;</span>
<span class="line-added">+     const Node* const load_obj = load-&gt;get_base_and_disp(load_offset, load_adr_type);</span>
<span class="line-added">+     Block* const load_block = cfg-&gt;get_block_for_node(load);</span>
<span class="line-added">+     const uint load_index = block_index(load_block, load);</span>
  
<span class="line-modified">!     for (uint j = 0; j &lt; mem_ops.size(); j++) {</span>
<span class="line-modified">!       MachNode* mem = mem_ops.at(j)-&gt;as_Mach();</span>
<span class="line-modified">!       const TypePtr* mem_adr_type = NULL;</span>
<span class="line-modified">!       intptr_t mem_offset = 0;</span>
<span class="line-modified">!       const Node* mem_obj = mem-&gt;get_base_and_disp(mem_offset, mem_adr_type);</span>
<span class="line-modified">!       Block* mem_block = cfg-&gt;get_block_for_node(mem);</span>
<span class="line-modified">!       uint mem_index = block_index(mem_block, mem);</span>
  
<span class="line-modified">!       if (load_obj == NodeSentinel || mem_obj == NodeSentinel ||</span>
<span class="line-modified">!           load_obj == NULL || mem_obj == NULL ||</span>
<span class="line-modified">!           load_offset &lt; 0 || mem_offset &lt; 0) {</span>
<span class="line-modified">!         continue;</span>
        }
  
<span class="line-modified">!       if (mem_obj != load_obj || mem_offset != load_offset) {</span>
<span class="line-modified">!         // Not the same addresses, not a candidate</span>
<span class="line-modified">!         continue;</span>
        }
  
<span class="line-modified">!       if (load_block == mem_block) {</span>
<span class="line-modified">!         // Earlier accesses in the same block</span>
<span class="line-modified">!         if (mem_index &lt; load_index &amp;&amp; !block_has_safepoint(mem_block, mem_index + 1, load_index)) {</span>
<span class="line-modified">!           load-&gt;set_barrier_data(ZLoadBarrierElided);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       } else if (mem_block-&gt;dominates(load_block)) {</span>
<span class="line-modified">!         // Dominating block? Look around for safepoints</span>
<span class="line-modified">!         ResourceMark rm;</span>
<span class="line-modified">!         Block_List stack;</span>
<span class="line-modified">!         VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-modified">!         stack.push(load_block);</span>
<span class="line-modified">!         bool safepoint_found = block_has_safepoint(load_block);</span>
<span class="line-modified">!         while (!safepoint_found &amp;&amp; stack.size() &gt; 0) {</span>
<span class="line-modified">!           Block* block = stack.pop();</span>
<span class="line-modified">!           if (visited.test_set(block-&gt;_pre_order)) {</span>
<span class="line-modified">!             continue;</span>
            }
<span class="line-modified">!           if (block_has_safepoint(block)) {</span>
<span class="line-modified">!             safepoint_found = true;</span>
<span class="line-modified">!             break;</span>
            }
<span class="line-modified">!           if (block == mem_block) {</span>
<span class="line-modified">!             continue;</span>
            }
<span class="line-modified">! </span>
<span class="line-modified">!           // Push predecessor blocks</span>
<span class="line-modified">!           for (uint p = 1; p &lt; block-&gt;num_preds(); ++p) {</span>
<span class="line-modified">!             Block* pred = cfg-&gt;get_block_for_node(block-&gt;pred(p));</span>
<span class="line-modified">!             stack.push(pred);</span>
            }
          }
  
<span class="line-modified">!         if (!safepoint_found) {</span>
<span class="line-added">+           load-&gt;set_barrier_data(ZLoadBarrierElided);</span>
<span class="line-added">+         }</span>
        }
      }
    }
  }
  
<span class="line-modified">! // == Reduced spilling optimization ==</span>
  
<span class="line-modified">! void ZBarrierSetC2::compute_liveness_at_stubs() const {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   Compile* const C = Compile::current();</span>
<span class="line-modified">!   Arena* const A = Thread::current()-&gt;resource_area();</span>
<span class="line-modified">!   PhaseCFG* const cfg = C-&gt;cfg();</span>
<span class="line-modified">!   PhaseRegAlloc* const regalloc = C-&gt;regalloc();</span>
<span class="line-modified">!   RegMask* const live = NEW_ARENA_ARRAY(A, RegMask, cfg-&gt;number_of_blocks() * sizeof(RegMask));</span>
<span class="line-modified">!   ZBarrierSetAssembler* const bs = ZBarrierSet::assembler();</span>
<span class="line-modified">!   Block_List worklist;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   for (uint i = 0; i &lt; cfg-&gt;number_of_blocks(); ++i) {</span>
<span class="line-added">+     new ((void*)(live + i)) RegMask();</span>
<span class="line-added">+     worklist.push(cfg-&gt;get_block(i));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   while (worklist.size() &gt; 0) {</span>
<span class="line-added">+     const Block* const block = worklist.pop();</span>
<span class="line-added">+     RegMask&amp; old_live = live[block-&gt;_pre_order];</span>
<span class="line-added">+     RegMask new_live;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Initialize to union of successors</span>
<span class="line-added">+     for (uint i = 0; i &lt; block-&gt;_num_succs; i++) {</span>
<span class="line-added">+       const uint succ_id = block-&gt;_succs[i]-&gt;_pre_order;</span>
<span class="line-added">+       new_live.OR(live[succ_id]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Walk block backwards, computing liveness</span>
<span class="line-added">+     for (int i = block-&gt;number_of_nodes() - 1; i &gt;= 0; --i) {</span>
<span class="line-added">+       const Node* const node = block-&gt;get_node(i);</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Remove def bits</span>
<span class="line-added">+       const OptoReg::Name first = bs-&gt;refine_register(node, regalloc-&gt;get_reg_first(node));</span>
<span class="line-added">+       const OptoReg::Name second = bs-&gt;refine_register(node, regalloc-&gt;get_reg_second(node));</span>
<span class="line-added">+       if (first != OptoReg::Bad) {</span>
<span class="line-added">+         new_live.Remove(first);</span>
        }
<span class="line-modified">!       if (second != OptoReg::Bad) {</span>
<span class="line-modified">!         new_live.Remove(second);</span>
        }
  
<span class="line-modified">!       // Add use bits</span>
<span class="line-modified">!       for (uint j = 1; j &lt; node-&gt;req(); ++j) {</span>
<span class="line-modified">!         const Node* const use = node-&gt;in(j);</span>
<span class="line-modified">!         const OptoReg::Name first = bs-&gt;refine_register(use, regalloc-&gt;get_reg_first(use));</span>
<span class="line-modified">!         const OptoReg::Name second = bs-&gt;refine_register(use, regalloc-&gt;get_reg_second(use));</span>
<span class="line-modified">!         if (first != OptoReg::Bad) {</span>
<span class="line-modified">!           new_live.Insert(first);</span>
          }
<span class="line-modified">!         if (second != OptoReg::Bad) {</span>
<span class="line-modified">!           new_live.Insert(second);</span>
          }
        }
  
<span class="line-modified">!       // If this node tracks liveness, update it</span>
<span class="line-modified">!       RegMask* const regs = barrier_set_state()-&gt;live(node);</span>
<span class="line-modified">!       if (regs != NULL) {</span>
<span class="line-modified">!         regs-&gt;OR(new_live);</span>
        }
      }
  
<span class="line-modified">!     // Now at block top, see if we have any changes</span>
<span class="line-modified">!     new_live.SUBTRACT(old_live);</span>
<span class="line-modified">!     if (new_live.is_NotEmpty()) {</span>
<span class="line-modified">!       // Liveness has refined, update and propagate to prior blocks</span>
<span class="line-modified">!       old_live.OR(new_live);</span>
<span class="line-modified">!       for (uint i = 1; i &lt; block-&gt;num_preds(); ++i) {</span>
<span class="line-added">+         Block* const pred = cfg-&gt;get_block_for_node(block-&gt;pred(i));</span>
<span class="line-added">+         worklist.push(pred);</span>
        }
<span class="line-modified">!     }</span>
    }
  }
</pre>
<center><a href="../../shenandoah/vmStructs_shenandoah.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zBarrierSetC2.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
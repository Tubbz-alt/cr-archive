<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zLiveMap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZLIVEMAP_INLINE_HPP
 25 #define SHARE_GC_Z_ZLIVEMAP_INLINE_HPP
 26 
 27 #include &quot;gc/z/zBitMap.inline.hpp&quot;
 28 #include &quot;gc/z/zLiveMap.hpp&quot;
 29 #include &quot;gc/z/zMark.hpp&quot;
 30 #include &quot;gc/z/zOop.inline.hpp&quot;
 31 #include &quot;gc/z/zUtils.inline.hpp&quot;
 32 #include &quot;runtime/atomic.hpp&quot;
 33 #include &quot;utilities/bitMap.inline.hpp&quot;
 34 #include &quot;utilities/debug.hpp&quot;
 35 
 36 inline void ZLiveMap::reset() {
 37   _seqnum = 0;
 38 }
 39 
 40 inline bool ZLiveMap::is_marked() const {
 41   return Atomic::load_acquire(&amp;_seqnum) == ZGlobalSeqNum;
 42 }
 43 
 44 inline uint32_t ZLiveMap::live_objects() const {
 45   assert(ZGlobalPhase != ZPhaseMark, &quot;Invalid phase&quot;);
 46   return _live_objects;
 47 }
 48 
 49 inline size_t ZLiveMap::live_bytes() const {
 50   assert(ZGlobalPhase != ZPhaseMark, &quot;Invalid phase&quot;);
 51   return _live_bytes;
 52 }
 53 
 54 inline const BitMapView ZLiveMap::segment_live_bits() const {
 55   return BitMapView(const_cast&lt;BitMap::bm_word_t*&gt;(&amp;_segment_live_bits), nsegments);
 56 }
 57 
 58 inline const BitMapView ZLiveMap::segment_claim_bits() const {
 59   return BitMapView(const_cast&lt;BitMap::bm_word_t*&gt;(&amp;_segment_claim_bits), nsegments);
 60 }
 61 
 62 inline BitMapView ZLiveMap::segment_live_bits() {
 63   return BitMapView(&amp;_segment_live_bits, nsegments);
 64 }
 65 
 66 inline BitMapView ZLiveMap::segment_claim_bits() {
 67   return BitMapView(&amp;_segment_claim_bits, nsegments);
 68 }
 69 
 70 inline bool ZLiveMap::is_segment_live(BitMap::idx_t segment) const {
 71   return segment_live_bits().par_at(segment);
 72 }
 73 
 74 inline bool ZLiveMap::set_segment_live(BitMap::idx_t segment) {
 75   return segment_live_bits().par_set_bit(segment, memory_order_release);
 76 }
 77 
 78 inline bool ZLiveMap::claim_segment(BitMap::idx_t segment) {
 79   return segment_claim_bits().par_set_bit(segment, memory_order_acq_rel);
 80 }
 81 
 82 inline BitMap::idx_t ZLiveMap::first_live_segment() const {
 83   return segment_live_bits().get_next_one_offset(0, nsegments);
 84 }
 85 
 86 inline BitMap::idx_t ZLiveMap::next_live_segment(BitMap::idx_t segment) const {
 87   return segment_live_bits().get_next_one_offset(segment + 1, nsegments);
 88 }
 89 
 90 inline BitMap::idx_t ZLiveMap::segment_size() const {
 91   return _bitmap.size() / nsegments;
 92 }
 93 
 94 inline BitMap::idx_t ZLiveMap::index_to_segment(BitMap::idx_t index) const {
 95   return index &gt;&gt; _segment_shift;
 96 }
 97 
 98 inline bool ZLiveMap::get(size_t index) const {
 99   BitMap::idx_t segment = index_to_segment(index);
100   return is_marked() &amp;&amp;              // Page is marked
101          is_segment_live(segment) &amp;&amp; // Segment is marked
102          _bitmap.at(index);          // Object is marked
103 }
104 
105 inline bool ZLiveMap::set(size_t index, bool finalizable, bool&amp; inc_live) {
106   if (!is_marked()) {
107     // First object to be marked during this
108     // cycle, reset marking information.
109     reset(index);
110   }
111 
112   const BitMap::idx_t segment = index_to_segment(index);
113   if (!is_segment_live(segment)) {
114     // First object to be marked in this segment during
115     // this cycle, reset segment bitmap.
116     reset_segment(segment);
117   }
118 
119   return _bitmap.par_set_bit_pair(index, finalizable, inc_live);
120 }
121 
122 inline void ZLiveMap::inc_live(uint32_t objects, size_t bytes) {
123   Atomic::add(&amp;_live_objects, objects);
124   Atomic::add(&amp;_live_bytes, bytes);
125 }
126 
127 inline BitMap::idx_t ZLiveMap::segment_start(BitMap::idx_t segment) const {
128   return segment_size() * segment;
129 }
130 
131 inline BitMap::idx_t ZLiveMap::segment_end(BitMap::idx_t segment) const {
132   return segment_start(segment) + segment_size();
133 }
134 
135 inline void ZLiveMap::iterate_segment(ObjectClosure* cl, BitMap::idx_t segment, uintptr_t page_start, size_t page_object_alignment_shift) {
136   assert(is_segment_live(segment), &quot;Must be&quot;);
137 
138   const BitMap::idx_t start_index = segment_start(segment);
139   const BitMap::idx_t end_index   = segment_end(segment);
140   BitMap::idx_t index = _bitmap.get_next_one_offset(start_index, end_index);
141 
142   while (index &lt; end_index) {
143     // Calculate object address
144     const uintptr_t addr = page_start + ((index / 2) &lt;&lt; page_object_alignment_shift);
145 
146     // Apply closure
147     cl-&gt;do_object(ZOop::from_address(addr));
148 
149     // Find next bit after this object
150     const size_t size = ZUtils::object_size(addr);
151     const uintptr_t next_addr = align_up(addr + size, 1 &lt;&lt; page_object_alignment_shift);
152     const BitMap::idx_t next_index = ((next_addr - page_start) &gt;&gt; page_object_alignment_shift) * 2;
153     if (next_index &gt;= end_index) {
154       // End of live map
155       break;
156     }
157 
158     index = _bitmap.get_next_one_offset(next_index, end_index);
159   }
160 }
161 
162 inline void ZLiveMap::iterate(ObjectClosure* cl, uintptr_t page_start, size_t page_object_alignment_shift) {
163   if (is_marked()) {
164     for (BitMap::idx_t segment = first_live_segment(); segment &lt; nsegments; segment = next_live_segment(segment)) {
165       // For each live segment
166       iterate_segment(cl, segment, page_start, page_object_alignment_shift);
167     }
168   }
169 }
170 
171 #endif // SHARE_GC_Z_ZLIVEMAP_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zArray.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zBarrier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,18 ***</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
<span class="line-removed">- bool ZBarrier::during_mark() {</span>
<span class="line-removed">-   return ZGlobalPhase == ZPhaseMark;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZBarrier::during_relocate() {</span>
<span class="line-removed">-   return ZGlobalPhase == ZPhaseRelocate;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  template &lt;bool finalizable&gt;
  bool ZBarrier::should_mark_through(uintptr_t addr) {
    // Finalizable marked oops can still exists on the heap after marking
    // has completed, in which case we just want to convert this into a
    // good oop and not push it on the mark stack.
<span class="line-new-header">--- 29,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,11 ***</span>
  
    // Mark through
    return true;
  }
  
<span class="line-modified">! template &lt;bool finalizable, bool publish&gt;</span>
  uintptr_t ZBarrier::mark(uintptr_t addr) {
    uintptr_t good_addr;
  
    if (ZAddress::is_marked(addr)) {
      // Already marked, but try to mark though anyway
<span class="line-new-header">--- 62,11 ---</span>
  
    // Mark through
    return true;
  }
  
<span class="line-modified">! template &lt;bool follow, bool finalizable, bool publish&gt;</span>
  uintptr_t ZBarrier::mark(uintptr_t addr) {
    uintptr_t good_addr;
  
    if (ZAddress::is_marked(addr)) {
      // Already marked, but try to mark though anyway
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,44 ***</span>
      good_addr = remap(addr);
    }
  
    // Mark
    if (should_mark_through&lt;finalizable&gt;(addr)) {
<span class="line-modified">!     ZHeap::heap()-&gt;mark_object&lt;finalizable, publish&gt;(good_addr);</span>
    }
  
    return good_addr;
  }
  
  uintptr_t ZBarrier::remap(uintptr_t addr) {
    assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
    assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">! </span>
<span class="line-removed">-   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">-     // Forward</span>
<span class="line-removed">-     return ZHeap::heap()-&gt;forward_object(addr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Remap</span>
<span class="line-removed">-   return ZAddress::good(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate(uintptr_t addr) {
    assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
    assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">! </span>
<span class="line-removed">-   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">-     // Relocate</span>
<span class="line-removed">-     return ZHeap::heap()-&gt;relocate_object(addr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Remap</span>
<span class="line-removed">-   return ZAddress::good(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
<span class="line-modified">!   return during_relocate() ? relocate(addr) : mark&lt;Strong, Publish&gt;(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
    return during_relocate() ? relocate(addr) : remap(addr);
  }
<span class="line-new-header">--- 79,41 ---</span>
      good_addr = remap(addr);
    }
  
    // Mark
    if (should_mark_through&lt;finalizable&gt;(addr)) {
<span class="line-modified">!     ZHeap::heap()-&gt;mark_object&lt;follow, finalizable, publish&gt;(good_addr);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (finalizable) {</span>
<span class="line-added">+     // Make the oop finalizable marked/good, instead of normal marked/good.</span>
<span class="line-added">+     // This is needed because an object might first becomes finalizable</span>
<span class="line-added">+     // marked by the GC, and then loaded by a mutator thread. In this case,</span>
<span class="line-added">+     // the mutator thread must be able to tell that the object needs to be</span>
<span class="line-added">+     // strongly marked. The finalizable bit in the oop exists to make sure</span>
<span class="line-added">+     // that a load of a finalizable marked oop will fall into the barrier</span>
<span class="line-added">+     // slow path so that we can mark the object as strongly reachable.</span>
<span class="line-added">+     return ZAddress::finalizable_good(good_addr);</span>
    }
  
    return good_addr;
  }
  
  uintptr_t ZBarrier::remap(uintptr_t addr) {
    assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
    assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">!   return ZHeap::heap()-&gt;remap_object(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate(uintptr_t addr) {
    assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
    assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">!   return ZHeap::heap()-&gt;relocate_object(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
<span class="line-modified">!   return during_relocate() ? relocate(addr) : mark&lt;Follow, Strong, Publish&gt;(addr);</span>
  }
  
  uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
    return during_relocate() ? relocate(addr) : remap(addr);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,11 ***</span>
  uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
    return relocate_or_mark(addr);
  }
  
  void ZBarrier::load_barrier_on_oop_fields(oop o) {
<span class="line-modified">!   assert(ZOop::is_good(o), &quot;Should be good&quot;);</span>
    ZLoadBarrierOopClosure cl;
    o-&gt;oop_iterate(&amp;cl);
  }
  
  //
<span class="line-new-header">--- 124,11 ---</span>
  uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
    return relocate_or_mark(addr);
  }
  
  void ZBarrier::load_barrier_on_oop_fields(oop o) {
<span class="line-modified">!   assert(ZAddress::is_good(ZOop::to_address(o)), &quot;Should be good&quot;);</span>
    ZLoadBarrierOopClosure cl;
    o-&gt;oop_iterate(&amp;cl);
  }
  
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,37 ***</span>
  
  //
  // Mark barrier
  //
  uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
<span class="line-modified">!   return mark&lt;Strong, Overflow&gt;(addr);</span>
  }
  
  uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
<span class="line-modified">!   const uintptr_t good_addr = mark&lt;Finalizable, Overflow&gt;(addr);</span>
<span class="line-removed">-   if (ZAddress::is_good(addr)) {</span>
<span class="line-removed">-     // If the oop was already strongly marked/good, then we do</span>
<span class="line-removed">-     // not want to downgrade it to finalizable marked/good.</span>
<span class="line-removed">-     return good_addr;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // Make the oop finalizable marked/good, instead of normal marked/good.</span>
<span class="line-modified">!   // This is needed because an object might first becomes finalizable</span>
<span class="line-removed">-   // marked by the GC, and then loaded by a mutator thread. In this case,</span>
<span class="line-removed">-   // the mutator thread must be able to tell that the object needs to be</span>
<span class="line-removed">-   // strongly marked. The finalizable bit in the oop exists to make sure</span>
<span class="line-removed">-   // that a load of a finalizable marked oop will fall into the barrier</span>
<span class="line-removed">-   // slow path so that we can mark the object as strongly reachable.</span>
<span class="line-removed">-   return ZAddress::finalizable_good(good_addr);</span>
  }
  
  uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
    assert(during_mark(), &quot;Invalid phase&quot;);
  
    // Mark
<span class="line-modified">!   return mark&lt;Strong, Publish&gt;(addr);</span>
  }
  
  //
  // Relocate barrier
  //
<span class="line-new-header">--- 175,37 ---</span>
  
  //
  // Mark barrier
  //
  uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
<span class="line-modified">!   assert(during_mark(), &quot;Invalid phase&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Mark</span>
<span class="line-added">+   return mark&lt;Follow, Strong, Overflow&gt;(addr);</span>
  }
  
  uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
<span class="line-modified">!   assert(during_mark(), &quot;Invalid phase&quot;);</span>
  
<span class="line-modified">!   // Mark</span>
<span class="line-modified">!   return mark&lt;Follow, Finalizable, Overflow&gt;(addr);</span>
  }
  
  uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
    assert(during_mark(), &quot;Invalid phase&quot;);
  
    // Mark
<span class="line-modified">!   return mark&lt;Follow, Strong, Publish&gt;(addr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ uintptr_t ZBarrier::mark_barrier_on_invisible_root_oop_slow_path(uintptr_t addr) {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-added">+   assert(during_mark(), &quot;Invalid phase&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Mark</span>
<span class="line-added">+   return mark&lt;DontFollow, Strong, Publish&gt;(addr);</span>
  }
  
  //
  // Relocate barrier
  //
</pre>
<center><a href="zArray.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
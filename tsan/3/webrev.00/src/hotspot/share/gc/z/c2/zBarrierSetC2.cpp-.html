<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/c2/zBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;opto/compile.hpp&quot;
  26 #include &quot;opto/castnode.hpp&quot;
  27 #include &quot;opto/escape.hpp&quot;
  28 #include &quot;opto/graphKit.hpp&quot;
  29 #include &quot;opto/idealKit.hpp&quot;
  30 #include &quot;opto/loopnode.hpp&quot;
  31 #include &quot;opto/macro.hpp&quot;
  32 #include &quot;opto/node.hpp&quot;
  33 #include &quot;opto/type.hpp&quot;
  34 #include &quot;utilities/macros.hpp&quot;
  35 #include &quot;gc/z/zBarrierSet.hpp&quot;
  36 #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;
  37 #include &quot;gc/z/zThreadLocalData.hpp&quot;
  38 #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;
  39 
  40 ZBarrierSetC2State::ZBarrierSetC2State(Arena* comp_arena) :
  41     _load_barrier_nodes(new (comp_arena) GrowableArray&lt;LoadBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {}
  42 
  43 int ZBarrierSetC2State::load_barrier_count() const {
  44   return _load_barrier_nodes-&gt;length();
  45 }
  46 
  47 void ZBarrierSetC2State::add_load_barrier_node(LoadBarrierNode * n) {
  48   assert(!_load_barrier_nodes-&gt;contains(n), &quot; duplicate entry in expand list&quot;);
  49   _load_barrier_nodes-&gt;append(n);
  50 }
  51 
  52 void ZBarrierSetC2State::remove_load_barrier_node(LoadBarrierNode * n) {
  53   // this function may be called twice for a node so check
  54   // that the node is in the array before attempting to remove it
  55   if (_load_barrier_nodes-&gt;contains(n)) {
  56     _load_barrier_nodes-&gt;remove(n);
  57   }
  58 }
  59 
  60 LoadBarrierNode* ZBarrierSetC2State::load_barrier_node(int idx) const {
  61   return _load_barrier_nodes-&gt;at(idx);
  62 }
  63 
  64 void* ZBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
  65   return new(comp_arena) ZBarrierSetC2State(comp_arena);
  66 }
  67 
  68 ZBarrierSetC2State* ZBarrierSetC2::state() const {
  69   return reinterpret_cast&lt;ZBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
  70 }
  71 
  72 bool ZBarrierSetC2::is_gc_barrier_node(Node* node) const {
  73   // 1. This step follows potential oop projections of a load barrier before expansion
  74   if (node-&gt;is_Proj()) {
  75     node = node-&gt;in(0);
  76   }
  77 
  78   // 2. This step checks for unexpanded load barriers
  79   if (node-&gt;is_LoadBarrier()) {
  80     return true;
  81   }
  82 
  83   // 3. This step checks for the phi corresponding to an optimized load barrier expansion
  84   if (node-&gt;is_Phi()) {
  85     PhiNode* phi = node-&gt;as_Phi();
  86     Node* n = phi-&gt;in(1);
  87     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {
  88       return true;
  89     }
  90   }
  91 
  92   return false;
  93 }
  94 
  95 void ZBarrierSetC2::register_potential_barrier_node(Node* node) const {
  96   if (node-&gt;is_LoadBarrier()) {
  97     state()-&gt;add_load_barrier_node(node-&gt;as_LoadBarrier());
  98   }
  99 }
 100 
 101 void ZBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
 102   if (node-&gt;is_LoadBarrier()) {
 103     state()-&gt;remove_load_barrier_node(node-&gt;as_LoadBarrier());
 104   }
 105 }
 106 
 107 void ZBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
 108   // Remove useless LoadBarrier nodes
 109   ZBarrierSetC2State* s = state();
 110   for (int i = s-&gt;load_barrier_count()-1; i &gt;= 0; i--) {
 111     LoadBarrierNode* n = s-&gt;load_barrier_node(i);
 112     if (!useful.member(n)) {
 113       unregister_potential_barrier_node(n);
 114     }
 115   }
 116 }
 117 
 118 void ZBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
 119   if (node-&gt;is_LoadBarrier() &amp;&amp; !node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {
 120     igvn-&gt;_worklist.push(node);
 121   }
 122 }
 123 
 124 void ZBarrierSetC2::find_dominating_barriers(PhaseIterGVN&amp; igvn) {
 125   // Look for dominating barriers on the same address only once all
 126   // other loop opts are over. Loop opts may cause a safepoint to be
 127   // inserted between a barrier and its dominating barrier.
 128   Compile* C = Compile::current();
 129   ZBarrierSetC2* bs = (ZBarrierSetC2*)BarrierSet::barrier_set()-&gt;barrier_set_c2();
 130   ZBarrierSetC2State* s = bs-&gt;state();
 131   if (s-&gt;load_barrier_count() &gt;= 2) {
 132     Compile::TracePhase tp(&quot;idealLoop&quot;, &amp;C-&gt;timers[Phase::_t_idealLoop]);
 133     PhaseIdealLoop::optimize(igvn, LoopOptsLastRound);
 134     if (C-&gt;major_progress()) C-&gt;print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);
 135   }
 136 }
 137 
 138 void ZBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {
 139   // Permanent temporary workaround
 140   // Loadbarriers may have non-obvious dead uses keeping them alive during parsing. The use is
 141   // removed by RemoveUseless (after parsing, before optimize) but the barriers won&#39;t be added to
 142   // the worklist. Unless we add them explicitly they are not guaranteed to end up there.
 143   ZBarrierSetC2State* s = state();
 144 
 145   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {
 146     LoadBarrierNode* n = s-&gt;load_barrier_node(i);
 147     worklist-&gt;push(n);
 148   }
 149 }
 150 
 151 const TypeFunc* ZBarrierSetC2::load_barrier_Type() const {
 152   const Type** fields;
 153 
 154   // Create input types (domain)
 155   fields = TypeTuple::fields(2);
 156   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
 157   fields[TypeFunc::Parms+1] = TypeOopPtr::BOTTOM;
 158   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 159 
 160   // Create result type (range)
 161   fields = TypeTuple::fields(1);
 162   fields[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM;
 163   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 164 
 165   return TypeFunc::make(domain, range);
 166 }
 167 
 168 // == LoadBarrierNode ==
 169 
 170 LoadBarrierNode::LoadBarrierNode(Compile* C,
 171                                  Node* c,
 172                                  Node* mem,
 173                                  Node* val,
 174                                  Node* adr,
 175                                  bool weak,
 176                                  bool writeback,
 177                                  bool oop_reload_allowed) :
 178     MultiNode(Number_of_Inputs),
 179     _weak(weak),
 180     _writeback(writeback),
 181     _oop_reload_allowed(oop_reload_allowed) {
 182   init_req(Control, c);
 183   init_req(Memory, mem);
 184   init_req(Oop, val);
 185   init_req(Address, adr);
 186   init_req(Similar, C-&gt;top());
 187 
 188   init_class_id(Class_LoadBarrier);
 189   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 190   bs-&gt;register_potential_barrier_node(this);
 191 }
 192 
 193 uint LoadBarrierNode::size_of() const {
 194   return sizeof(*this);
 195 }
 196 
 197 uint LoadBarrierNode::cmp(const Node&amp; n) const {
 198   ShouldNotReachHere();
 199   return 0;
 200 }
 201 
 202 const Type *LoadBarrierNode::bottom_type() const {
 203   const Type** floadbarrier = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));
 204   Node* in_oop = in(Oop);
 205   floadbarrier[Control] = Type::CONTROL;
 206   floadbarrier[Memory] = Type::MEMORY;
 207   floadbarrier[Oop] = in_oop == NULL ? Type::TOP : in_oop-&gt;bottom_type();
 208   return TypeTuple::make(Number_of_Outputs, floadbarrier);
 209 }
 210 
 211 const TypePtr* LoadBarrierNode::adr_type() const {
 212   ShouldNotReachHere();
 213   return NULL;
 214 }
 215 
 216 const Type *LoadBarrierNode::Value(PhaseGVN *phase) const {
 217   const Type** floadbarrier = (const Type **)(phase-&gt;C-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));
 218   const Type* val_t = phase-&gt;type(in(Oop));
 219   floadbarrier[Control] = Type::CONTROL;
 220   floadbarrier[Memory] = Type::MEMORY;
 221   floadbarrier[Oop] = val_t;
 222   return TypeTuple::make(Number_of_Outputs, floadbarrier);
 223 }
 224 
 225 bool LoadBarrierNode::is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n) {
 226   if (phase != NULL) {
 227     return phase-&gt;is_dominator(d, n);
 228   }
 229 
 230   for (int i = 0; i &lt; 10 &amp;&amp; n != NULL; i++) {
 231     n = IfNode::up_one_dom(n, linear_only);
 232     if (n == d) {
 233       return true;
 234     }
 235   }
 236 
 237   return false;
 238 }
 239 
 240 LoadBarrierNode* LoadBarrierNode::has_dominating_barrier(PhaseIdealLoop* phase, bool linear_only, bool look_for_similar) {
 241   Node* val = in(LoadBarrierNode::Oop);
 242   if (in(Similar)-&gt;is_Proj() &amp;&amp; in(Similar)-&gt;in(0)-&gt;is_LoadBarrier()) {
 243     LoadBarrierNode* lb = in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();
 244     assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);
 245     // Load barrier on Similar edge dominates so if it now has the Oop field it can replace this barrier.
 246     if (lb-&gt;in(Oop) == in(Oop)) {
 247       return lb;
 248     }
 249     // Follow chain of load barrier through Similar edges
 250     while (!lb-&gt;in(Similar)-&gt;is_top()) {
 251       lb = lb-&gt;in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();
 252       assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);
 253     }
 254     if (lb != in(Similar)-&gt;in(0)) {
 255       return lb;
 256     }
 257   }
 258   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {
 259     Node* u = val-&gt;fast_out(i);
 260     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {
 261       Node* this_ctrl = in(LoadBarrierNode::Control);
 262       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);
 263       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {
 264         return u-&gt;as_LoadBarrier();
 265       }
 266     }
 267   }
 268 
 269   if (ZVerifyLoadBarriers || can_be_eliminated()) {
 270     return NULL;
 271   }
 272 
 273   if (!look_for_similar) {
 274     return NULL;
 275   }
 276 
 277   Node* addr = in(LoadBarrierNode::Address);
 278   for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {
 279     Node* u = addr-&gt;fast_out(i);
 280     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {
 281       Node* this_ctrl = in(LoadBarrierNode::Control);
 282       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);
 283       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {
 284         ResourceMark rm;
 285         Unique_Node_List wq;
 286         wq.push(in(LoadBarrierNode::Control));
 287         bool ok = true;
 288         bool dom_found = false;
 289         for (uint next = 0; next &lt; wq.size(); ++next) {
 290           Node *n = wq.at(next);
 291           if (n-&gt;is_top()) {
 292             return NULL;
 293           }
 294           assert(n-&gt;is_CFG(), &quot;&quot;);
 295           if (n-&gt;is_SafePoint()) {
 296             ok = false;
 297             break;
 298           }
 299           if (n == u) {
 300             dom_found = true;
 301             continue;
 302           }
 303           if (n-&gt;is_Region()) {
 304             for (uint i = 1; i &lt; n-&gt;req(); i++) {
 305               Node* m = n-&gt;in(i);
 306               if (m != NULL) {
 307                 wq.push(m);
 308               }
 309             }
 310           } else {
 311             Node* m = n-&gt;in(0);
 312             if (m != NULL) {
 313               wq.push(m);
 314             }
 315           }
 316         }
 317         if (ok) {
 318           assert(dom_found, &quot;&quot;);
 319           return u-&gt;as_LoadBarrier();;
 320         }
 321         break;
 322       }
 323     }
 324   }
 325 
 326   return NULL;
 327 }
 328 
 329 void LoadBarrierNode::push_dominated_barriers(PhaseIterGVN* igvn) const {
 330   // Change to that barrier may affect a dominated barrier so re-push those
 331   Node* val = in(LoadBarrierNode::Oop);
 332 
 333   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {
 334     Node* u = val-&gt;fast_out(i);
 335     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val) {
 336       Node* this_ctrl = in(Control);
 337       Node* other_ctrl = u-&gt;in(Control);
 338       if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {
 339         igvn-&gt;_worklist.push(u);
 340       }
 341     }
 342 
 343     Node* addr = in(LoadBarrierNode::Address);
 344     for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {
 345       Node* u = addr-&gt;fast_out(i);
 346       if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar)-&gt;is_top()) {
 347         Node* this_ctrl = in(Control);
 348         Node* other_ctrl = u-&gt;in(Control);
 349         if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {
 350           igvn-&gt;_worklist.push(u);
 351         }
 352       }
 353     }
 354   }
 355 }
 356 
 357 Node *LoadBarrierNode::Identity(PhaseGVN *phase) {
 358   if (!phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {
 359     return this;
 360   }
 361 
 362   bool redundant_addr = false;
 363   LoadBarrierNode* dominating_barrier = has_dominating_barrier(NULL, true, false);
 364   if (dominating_barrier != NULL) {
 365     assert(dominating_barrier-&gt;in(Oop) == in(Oop), &quot;&quot;);
 366     return dominating_barrier;
 367   }
 368 
 369   return this;
 370 }
 371 
 372 Node *LoadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 373   if (remove_dead_region(phase, can_reshape)) {
 374     return this;
 375   }
 376 
 377   Node* val = in(Oop);
 378   Node* mem = in(Memory);
 379   Node* ctrl = in(Control);
 380   Node* adr = in(Address);
 381   assert(val-&gt;Opcode() != Op_LoadN, &quot;&quot;);
 382 
 383   if (mem-&gt;is_MergeMem()) {
 384     Node* new_mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
 385     set_req(Memory, new_mem);
 386     if (mem-&gt;outcnt() == 0 &amp;&amp; can_reshape) {
 387       phase-&gt;is_IterGVN()-&gt;_worklist.push(mem);
 388     }
 389 
 390     return this;
 391   }
 392 
 393   bool optimizeLoadBarriers = phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption;
 394   LoadBarrierNode* dominating_barrier = optimizeLoadBarriers ? has_dominating_barrier(NULL, !can_reshape, !phase-&gt;C-&gt;major_progress()) : NULL;
 395   if (dominating_barrier != NULL &amp;&amp; dominating_barrier-&gt;in(Oop) != in(Oop)) {
 396     assert(in(Address) == dominating_barrier-&gt;in(Address), &quot;&quot;);
 397     set_req(Similar, dominating_barrier-&gt;proj_out(Oop));
 398     return this;
 399   }
 400 
 401   bool eliminate = (optimizeLoadBarriers &amp;&amp; !(val-&gt;is_Phi() || val-&gt;Opcode() == Op_LoadP || val-&gt;Opcode() == Op_GetAndSetP || val-&gt;is_DecodeN())) ||
 402                    (can_reshape &amp;&amp; (dominating_barrier != NULL || !has_true_uses()));
 403 
 404   if (eliminate) {
 405     if (can_reshape) {
 406       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
 407       Node* out_ctrl = proj_out_or_null(Control);
 408       Node* out_res = proj_out_or_null(Oop);
 409 
 410       if (out_ctrl != NULL) {
 411         igvn-&gt;replace_node(out_ctrl, ctrl);
 412       }
 413 
 414       // That transformation may cause the Similar edge on the load barrier to be invalid
 415       fix_similar_in_uses(igvn);
 416       if (out_res != NULL) {
 417         if (dominating_barrier != NULL) {
 418           igvn-&gt;replace_node(out_res, dominating_barrier-&gt;proj_out(Oop));
 419         } else {
 420           igvn-&gt;replace_node(out_res, val);
 421         }
 422       }
 423     }
 424 
 425     return new ConINode(TypeInt::ZERO);
 426   }
 427 
 428   // If the Similar edge is no longer a load barrier, clear it
 429   Node* similar = in(Similar);
 430   if (!similar-&gt;is_top() &amp;&amp; !(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier())) {
 431     set_req(Similar, phase-&gt;C-&gt;top());
 432     return this;
 433   }
 434 
 435   if (can_reshape) {
 436     // If this barrier is linked through the Similar edge by a
 437     // dominated barrier and both barriers have the same Oop field,
 438     // the dominated barrier can go away, so push it for reprocessing.
 439     // We also want to avoid a barrier to depend on another dominating
 440     // barrier through its Similar edge that itself depend on another
 441     // barrier through its Similar edge and rather have the first
 442     // depend on the third.
 443     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
 444     Node* out_res = proj_out(Oop);
 445     for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {
 446       Node* u = out_res-&gt;fast_out(i);
 447       if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res &amp;&amp;
 448           (u-&gt;in(Oop) == val || !u-&gt;in(Similar)-&gt;is_top())) {
 449         igvn-&gt;_worklist.push(u);
 450       }
 451     }
 452 
 453     push_dominated_barriers(igvn);
 454   }
 455 
 456   return NULL;
 457 }
 458 
 459 uint LoadBarrierNode::match_edge(uint idx) const {
 460   ShouldNotReachHere();
 461   return 0;
 462 }
 463 
 464 void LoadBarrierNode::fix_similar_in_uses(PhaseIterGVN* igvn) {
 465   Node* out_res = proj_out_or_null(Oop);
 466   if (out_res == NULL) {
 467     return;
 468   }
 469 
 470   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {
 471     Node* u = out_res-&gt;fast_out(i);
 472     if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res) {
 473       igvn-&gt;replace_input_of(u, Similar, igvn-&gt;C-&gt;top());
 474       --i;
 475       --imax;
 476     }
 477   }
 478 }
 479 
 480 bool LoadBarrierNode::has_true_uses() const {
 481   Node* out_res = proj_out_or_null(Oop);
 482   if (out_res == NULL) {
 483     return false;
 484   }
 485 
 486   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {
 487     Node* u = out_res-&gt;fast_out(i);
 488     if (!u-&gt;is_LoadBarrier() || u-&gt;in(Similar) != out_res) {
 489       return true;
 490     }
 491   }
 492 
 493   return false;
 494 }
 495 
 496 // == Accesses ==
 497 
 498 Node* ZBarrierSetC2::make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const {
 499   assert(!UseCompressedOops, &quot;Not allowed&quot;);
 500   CompareAndSwapNode* cas = (CompareAndSwapNode*)access.raw_access();
 501   PhaseGVN&amp; gvn = access.gvn();
 502   Compile* C = Compile::current();
 503   GraphKit* kit = access.kit();
 504 
 505   Node* in_ctrl     = cas-&gt;in(MemNode::Control);
 506   Node* in_mem      = cas-&gt;in(MemNode::Memory);
 507   Node* in_adr      = cas-&gt;in(MemNode::Address);
 508   Node* in_val      = cas-&gt;in(MemNode::ValueIn);
 509   Node* in_expected = cas-&gt;in(LoadStoreConditionalNode::ExpectedIn);
 510 
 511   float likely                   = PROB_LIKELY(0.999);
 512 
 513   const TypePtr *adr_type        = gvn.type(in_adr)-&gt;isa_ptr();
 514   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
 515   int alias_idx                  = C-&gt;get_alias_index(adr_type);
 516 
 517   // Outer check - true: continue, false: load and check
 518   Node* region   = new RegionNode(3);
 519   Node* phi      = new PhiNode(region, TypeInt::BOOL);
 520   Node* phi_mem  = new PhiNode(region, Type::MEMORY, adr_type);
 521 
 522   // Inner check - is the healed ref equal to the expected
 523   Node* region2  = new RegionNode(3);
 524   Node* phi2     = new PhiNode(region2, TypeInt::BOOL);
 525   Node* phi_mem2 = new PhiNode(region2, Type::MEMORY, adr_type);
 526 
 527   // CAS node returns 0 or 1
 528   Node* cmp     = gvn.transform(new CmpINode(cas, kit-&gt;intcon(0)));
 529   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();
 530   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();
 531   Node* then    = gvn.transform(new IfTrueNode(iff));
 532   Node* elsen   = gvn.transform(new IfFalseNode(iff));
 533 
 534   Node* scmemproj1   = gvn.transform(new SCMemProjNode(cas));
 535 
 536   kit-&gt;set_memory(scmemproj1, alias_idx);
 537   phi_mem-&gt;init_req(1, scmemproj1);
 538   phi_mem2-&gt;init_req(2, scmemproj1);
 539 
 540   // CAS fail - reload and heal oop
 541   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);
 542   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));
 543   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));
 544   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));
 545 
 546   // Check load
 547   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));
 548   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));
 549   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));
 550   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();
 551   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();
 552   Node* then2   = gvn.transform(new IfTrueNode(iff2));
 553   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));
 554 
 555   // redo CAS
 556   Node* cas2       = gvn.transform(new CompareAndSwapPNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, cas-&gt;order()));
 557   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cas2));
 558   kit-&gt;set_control(elsen2);
 559   kit-&gt;set_memory(scmemproj2, alias_idx);
 560 
 561   // Merge inner flow - check if healed oop was equal too expected.
 562   region2-&gt;set_req(1, kit-&gt;control());
 563   region2-&gt;set_req(2, then2);
 564   phi2-&gt;set_req(1, cas2);
 565   phi2-&gt;set_req(2, kit-&gt;intcon(0));
 566   phi_mem2-&gt;init_req(1, scmemproj2);
 567   kit-&gt;set_memory(phi_mem2, alias_idx);
 568 
 569   // Merge outer flow - then check if first CAS succeeded
 570   region-&gt;set_req(1, then);
 571   region-&gt;set_req(2, region2);
 572   phi-&gt;set_req(1, kit-&gt;intcon(1));
 573   phi-&gt;set_req(2, phi2);
 574   phi_mem-&gt;init_req(2, phi_mem2);
 575   kit-&gt;set_memory(phi_mem, alias_idx);
 576 
 577   gvn.transform(region2);
 578   gvn.transform(phi2);
 579   gvn.transform(phi_mem2);
 580   gvn.transform(region);
 581   gvn.transform(phi);
 582   gvn.transform(phi_mem);
 583 
 584   kit-&gt;set_control(region);
 585   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 586 
 587   return phi;
 588 }
 589 
 590 Node* ZBarrierSetC2::make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const {
 591   CompareAndExchangePNode* cmpx = (CompareAndExchangePNode*)access.raw_access();
 592   GraphKit* kit = access.kit();
 593   PhaseGVN&amp; gvn = kit-&gt;gvn();
 594   Compile* C = Compile::current();
 595 
 596   Node* in_ctrl     = cmpx-&gt;in(MemNode::Control);
 597   Node* in_mem      = cmpx-&gt;in(MemNode::Memory);
 598   Node* in_adr      = cmpx-&gt;in(MemNode::Address);
 599   Node* in_val      = cmpx-&gt;in(MemNode::ValueIn);
 600   Node* in_expected = cmpx-&gt;in(LoadStoreConditionalNode::ExpectedIn);
 601 
 602   float likely                   = PROB_LIKELY(0.999);
 603 
 604   const TypePtr *adr_type        = cmpx-&gt;get_ptr_type();
 605   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
 606   int alias_idx                  = C-&gt;get_alias_index(adr_type);
 607 
 608   // Outer check - true: continue, false: load and check
 609   Node* region  = new RegionNode(3);
 610   Node* phi     = new PhiNode(region, adr_type);
 611 
 612   // Inner check - is the healed ref equal to the expected
 613   Node* region2 = new RegionNode(3);
 614   Node* phi2    = new PhiNode(region2, adr_type);
 615 
 616   // Check if cmpx succeeded
 617   Node* cmp     = gvn.transform(new CmpPNode(cmpx, in_expected));
 618   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::eq))-&gt;as_Bool();
 619   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();
 620   Node* then    = gvn.transform(new IfTrueNode(iff));
 621   Node* elsen   = gvn.transform(new IfFalseNode(iff));
 622 
 623   Node* scmemproj1  = gvn.transform(new SCMemProjNode(cmpx));
 624   kit-&gt;set_memory(scmemproj1, alias_idx);
 625 
 626   // CAS fail - reload and heal oop
 627   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);
 628   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));
 629   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));
 630   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));
 631 
 632   // Check load
 633   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));
 634   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));
 635   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));
 636   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();
 637   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();
 638   Node* then2   = gvn.transform(new IfTrueNode(iff2));
 639   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));
 640 
 641   // Redo CAS
 642   Node* cmpx2      = gvn.transform(new CompareAndExchangePNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, adr_type, cmpx-&gt;get_ptr_type(), cmpx-&gt;order()));
 643   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cmpx2));
 644   kit-&gt;set_control(elsen2);
 645   kit-&gt;set_memory(scmemproj2, alias_idx);
 646 
 647   // Merge inner flow - check if healed oop was equal too expected.
 648   region2-&gt;set_req(1, kit-&gt;control());
 649   region2-&gt;set_req(2, then2);
 650   phi2-&gt;set_req(1, cmpx2);
 651   phi2-&gt;set_req(2, barrierdata);
 652 
 653   // Merge outer flow - then check if first cas succeeded
 654   region-&gt;set_req(1, then);
 655   region-&gt;set_req(2, region2);
 656   phi-&gt;set_req(1, cmpx);
 657   phi-&gt;set_req(2, phi2);
 658 
 659   gvn.transform(region2);
 660   gvn.transform(phi2);
 661   gvn.transform(region);
 662   gvn.transform(phi);
 663 
 664   kit-&gt;set_control(region);
 665   kit-&gt;set_memory(in_mem, alias_idx);
 666   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 667 
 668   return phi;
 669 }
 670 
 671 Node* ZBarrierSetC2::load_barrier(GraphKit* kit, Node* val, Node* adr, bool weak, bool writeback, bool oop_reload_allowed) const {
 672   PhaseGVN&amp; gvn = kit-&gt;gvn();
 673   Node* barrier = new LoadBarrierNode(Compile::current(), kit-&gt;control(), kit-&gt;memory(TypeRawPtr::BOTTOM), val, adr, weak, writeback, oop_reload_allowed);
 674   Node* transformed_barrier = gvn.transform(barrier);
 675 
 676   if (transformed_barrier-&gt;is_LoadBarrier()) {
 677     if (barrier == transformed_barrier) {
 678       kit-&gt;set_control(gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control)));
 679     }
 680     Node* result = gvn.transform(new ProjNode(transformed_barrier, LoadBarrierNode::Oop));
 681     return result;
 682   } else {
 683     return val;
 684   }
 685 }
 686 
 687 static bool barrier_needed(C2Access&amp; access) {
 688   return ZBarrierSet::barrier_needed(access.decorators(), access.type());
 689 }
 690 
 691 Node* ZBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 692   Node* p = BarrierSetC2::load_at_resolved(access, val_type);
 693   if (!barrier_needed(access)) {
 694     return p;
 695   }
 696 
 697   bool weak = (access.decorators() &amp; ON_WEAK_OOP_REF) != 0;
 698 
 699   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);
 700   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 701   GraphKit* kit = parse_access.kit();
 702   PhaseGVN&amp; gvn = kit-&gt;gvn();
 703   Node* adr = access.addr().node();
 704   Node* heap_base_oop = access.base();
 705   bool unsafe = (access.decorators() &amp; C2_UNSAFE_ACCESS) != 0;
 706   if (unsafe) {
 707     if (!ZVerifyLoadBarriers) {
 708       p = load_barrier(kit, p, adr);
 709     } else {
 710       if (!TypePtr::NULL_PTR-&gt;higher_equal(gvn.type(heap_base_oop))) {
 711         p = load_barrier(kit, p, adr);
 712       } else {
 713         IdealKit ideal(kit);
 714         IdealVariable res(ideal);
 715 #define __ ideal.
 716         __ declarations_done();
 717         __ set(res, p);
 718         __ if_then(heap_base_oop, BoolTest::ne, kit-&gt;null(), PROB_UNLIKELY(0.999)); {
 719           kit-&gt;sync_kit(ideal);
 720           p = load_barrier(kit, p, adr);
 721           __ set(res, p);
 722           __ sync_kit(kit);
 723         } __ end_if();
 724         kit-&gt;final_sync(ideal);
 725         p = __ value(res);
 726 #undef __
 727       }
 728     }
 729     return p;
 730   } else {
 731     return load_barrier(parse_access.kit(), p, access.addr().node(), weak, true, true);
 732   }
 733 }
 734 
 735 Node* ZBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 736                                                     Node* new_val, const Type* val_type) const {
 737   Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, val_type);
 738   if (!barrier_needed(access)) {
 739     return result;
 740   }
 741 
 742   access.set_needs_pinning(false);
 743   return make_cmpx_loadbarrier(access);
 744 }
 745 
 746 Node* ZBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 747                                                      Node* new_val, const Type* value_type) const {
 748   Node* result = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 749   if (!barrier_needed(access)) {
 750     return result;
 751   }
 752 
 753   Node* load_store = access.raw_access();
 754   bool weak_cas = (access.decorators() &amp; C2_WEAK_CMPXCHG) != 0;
 755   bool expected_is_null = (expected_val-&gt;get_ptr_type() == TypePtr::NULL_PTR);
 756 
 757   if (!expected_is_null) {
 758     if (weak_cas) {
 759       access.set_needs_pinning(false);
 760       load_store = make_cas_loadbarrier(access);
 761     } else {
 762       access.set_needs_pinning(false);
 763       load_store = make_cas_loadbarrier(access);
 764     }
 765   }
 766 
 767   return load_store;
 768 }
 769 
 770 Node* ZBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* new_val, const Type* val_type) const {
 771   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, val_type);
 772   if (!barrier_needed(access)) {
 773     return result;
 774   }
 775 
 776   Node* load_store = access.raw_access();
 777   Node* adr = access.addr().node();
 778 
 779   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);
 780   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 781   return load_barrier(parse_access.kit(), load_store, adr, false, false, false);
 782 }
 783 
 784 // == Macro Expansion ==
 785 
 786 void ZBarrierSetC2::expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const {
 787   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);
 788   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);
 789   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);
 790   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);
 791 
 792   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);
 793   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);
 794 
 795   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
 796 
 797   if (ZVerifyLoadBarriers) {
 798     igvn.replace_node(out_res, in_val);
 799     igvn.replace_node(out_ctrl, in_ctrl);
 800     return;
 801   }
 802 
 803   if (barrier-&gt;can_be_eliminated()) {
 804     // Clone and pin the load for this barrier below the dominating
 805     // barrier: the load cannot be allowed to float above the
 806     // dominating barrier
 807     Node* load = in_val;
 808 
 809     if (load-&gt;is_Load()) {
 810       Node* new_load = load-&gt;clone();
 811       Node* addp = new_load-&gt;in(MemNode::Address);
 812       assert(addp-&gt;is_AddP() || addp-&gt;is_Phi() || addp-&gt;is_Load(), &quot;bad address&quot;);
 813       Node* cast = new CastPPNode(addp, igvn.type(addp), true);
 814       Node* ctrl = NULL;
 815       Node* similar = barrier-&gt;in(LoadBarrierNode::Similar);
 816       if (similar-&gt;is_Phi()) {
 817         // already expanded
 818         ctrl = similar-&gt;in(0);
 819       } else {
 820         assert(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier(), &quot;unexpected graph shape&quot;);
 821         ctrl = similar-&gt;in(0)-&gt;as_LoadBarrier()-&gt;proj_out(LoadBarrierNode::Control);
 822       }
 823       assert(ctrl != NULL, &quot;bad control&quot;);
 824       cast-&gt;set_req(0, ctrl);
 825       igvn.transform(cast);
 826       new_load-&gt;set_req(MemNode::Address, cast);
 827       igvn.transform(new_load);
 828 
 829       igvn.replace_node(out_res, new_load);
 830       igvn.replace_node(out_ctrl, in_ctrl);
 831       return;
 832     }
 833     // cannot eliminate
 834   }
 835 
 836   // There are two cases that require the basic loadbarrier
 837   // 1) When the writeback of a healed oop must be avoided (swap)
 838   // 2) When we must guarantee that no reload of is done (swap, cas, cmpx)
 839   if (!barrier-&gt;is_writeback()) {
 840     assert(!barrier-&gt;oop_reload_allowed(), &quot;writeback barriers should be marked as requires oop&quot;);
 841   }
 842 
 843   if (!barrier-&gt;oop_reload_allowed()) {
 844     expand_loadbarrier_basic(phase, barrier);
 845   } else {
 846     expand_loadbarrier_optimized(phase, barrier);
 847   }
 848 }
 849 
 850 // Basic loadbarrier using conventional argument passing
 851 void ZBarrierSetC2::expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {
 852   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
 853 
 854   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);
 855   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);
 856   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);
 857   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);
 858 
 859   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);
 860   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);
 861 
 862   float unlikely  = PROB_UNLIKELY(0.999);
 863   const Type* in_val_maybe_null_t = igvn.type(in_val);
 864 
 865   Node* jthread = igvn.transform(new ThreadLocalNode());
 866   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));
 867   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered));
 868   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));
 869   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));
 870   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));
 871   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();
 872   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();
 873   Node* then = igvn.transform(new IfTrueNode(iff));
 874   Node* elsen = igvn.transform(new IfFalseNode(iff));
 875 
 876   Node* result_region;
 877   Node* result_val;
 878 
 879   result_region = new RegionNode(3);
 880   result_val = new PhiNode(result_region, TypeInstPtr::BOTTOM);
 881 
 882   result_region-&gt;set_req(1, elsen);
 883   Node* res = igvn.transform(new CastPPNode(in_val, in_val_maybe_null_t));
 884   res-&gt;init_req(0, elsen);
 885   result_val-&gt;set_req(1, res);
 886 
 887   const TypeFunc *tf = load_barrier_Type();
 888   Node* call;
 889   if (barrier-&gt;is_weak()) {
 890     call = new CallLeafNode(tf,
 891                             ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr(),
 892                             &quot;ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded&quot;,
 893                             TypeRawPtr::BOTTOM);
 894   } else {
 895     call = new CallLeafNode(tf,
 896                             ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(),
 897                             &quot;ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded&quot;,
 898                             TypeRawPtr::BOTTOM);
 899   }
 900 
 901   call-&gt;init_req(TypeFunc::Control, then);
 902   call-&gt;init_req(TypeFunc::I_O    , phase-&gt;top());
 903   call-&gt;init_req(TypeFunc::Memory , in_mem);
 904   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;top());
 905   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;top());
 906   call-&gt;init_req(TypeFunc::Parms+0, in_val);
 907   if (barrier-&gt;is_writeback()) {
 908     call-&gt;init_req(TypeFunc::Parms+1, in_adr);
 909   } else {
 910     // When slow path is called with a null address, the healed oop will not be written back
 911     call-&gt;init_req(TypeFunc::Parms+1, igvn.zerocon(T_OBJECT));
 912   }
 913   call = igvn.transform(call);
 914 
 915   Node* ctrl = igvn.transform(new ProjNode(call, TypeFunc::Control));
 916   res = igvn.transform(new ProjNode(call, TypeFunc::Parms));
 917   res = igvn.transform(new CheckCastPPNode(ctrl, res, in_val_maybe_null_t));
 918 
 919   result_region-&gt;set_req(2, ctrl);
 920   result_val-&gt;set_req(2, res);
 921 
 922   result_region = igvn.transform(result_region);
 923   result_val = igvn.transform(result_val);
 924 
 925   if (out_ctrl != NULL) { // Added if cond
 926     igvn.replace_node(out_ctrl, result_region);
 927   }
 928   igvn.replace_node(out_res, result_val);
 929 }
 930 
 931 // Optimized, low spill, loadbarrier variant using stub specialized on register used
 932 void ZBarrierSetC2::expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {
 933   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
 934 #ifdef PRINT_NODE_TRAVERSALS
 935   Node* preceding_barrier_node = barrier-&gt;in(LoadBarrierNode::Oop);
 936 #endif
 937 
 938   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);
 939   Node* in_mem = barrier-&gt;in(LoadBarrierNode::Memory);
 940   Node* in_val = barrier-&gt;in(LoadBarrierNode::Oop);
 941   Node* in_adr = barrier-&gt;in(LoadBarrierNode::Address);
 942 
 943   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);
 944   Node* out_res = barrier-&gt;proj_out(LoadBarrierNode::Oop);
 945 
 946   assert(barrier-&gt;in(LoadBarrierNode::Oop) != NULL, &quot;oop to loadbarrier node cannot be null&quot;);
 947 
 948 #ifdef PRINT_NODE_TRAVERSALS
 949   tty-&gt;print(&quot;\n\n\nBefore barrier optimization:\n&quot;);
 950   traverse(barrier, out_ctrl, out_res, -1);
 951 
 952   tty-&gt;print(&quot;\nBefore barrier optimization:  preceding_barrier_node\n&quot;);
 953   traverse(preceding_barrier_node, out_ctrl, out_res, -1);
 954 #endif
 955 
 956   float unlikely  = PROB_UNLIKELY(0.999);
 957 
 958   Node* jthread = igvn.transform(new ThreadLocalNode());
 959   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));
 960   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr,
 961                                                  TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(),
 962                                                  MemNode::unordered));
 963   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));
 964   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));
 965   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));
 966   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();
 967   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();
 968   Node* then = igvn.transform(new IfTrueNode(iff));
 969   Node* elsen = igvn.transform(new IfFalseNode(iff));
 970 
 971   Node* slow_path_surrogate;
 972   if (!barrier-&gt;is_weak()) {
 973     slow_path_surrogate = igvn.transform(new LoadBarrierSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),
 974                                                                     (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));
 975   } else {
 976     slow_path_surrogate = igvn.transform(new LoadBarrierWeakSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),
 977                                                                         (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));
 978   }
 979 
 980   Node *new_loadp;
 981   new_loadp = slow_path_surrogate;
 982   // Create the final region/phi pair to converge cntl/data paths to downstream code
 983   Node* result_region = igvn.transform(new RegionNode(3));
 984   result_region-&gt;set_req(1, then);
 985   result_region-&gt;set_req(2, elsen);
 986 
 987   Node* result_phi = igvn.transform(new PhiNode(result_region, TypeInstPtr::BOTTOM));
 988   result_phi-&gt;set_req(1, new_loadp);
 989   result_phi-&gt;set_req(2, barrier-&gt;in(LoadBarrierNode::Oop));
 990 
 991   // Finally, connect the original outputs to the barrier region and phi to complete the expansion/substitution
 992   // igvn.replace_node(out_ctrl, result_region);
 993   if (out_ctrl != NULL) { // added if cond
 994     igvn.replace_node(out_ctrl, result_region);
 995   }
 996   igvn.replace_node(out_res, result_phi);
 997 
 998   assert(barrier-&gt;outcnt() == 0,&quot;LoadBarrier macro node has non-null outputs after expansion!&quot;);
 999 
1000 #ifdef PRINT_NODE_TRAVERSALS
1001   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_ctrl\n&quot;);
1002   traverse(out_ctrl, out_ctrl, out_res, -1);
1003   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_res\n&quot;);
1004   traverse(out_res, out_ctrl, out_res, -1);
1005   tty-&gt;print(&quot;\nAfter barrier optimization:  old barrier\n&quot;);
1006   traverse(barrier, out_ctrl, out_res, -1);
1007   tty-&gt;print(&quot;\nAfter barrier optimization:  preceding_barrier_node\n&quot;);
1008   traverse(preceding_barrier_node, result_region, result_phi, -1);
1009 #endif
1010 
1011   assert(is_gc_barrier_node(result_phi), &quot;sanity&quot;);
1012   assert(step_over_gc_barrier(result_phi) == in_val, &quot;sanity&quot;);
1013 }
1014 
1015 bool ZBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
1016   ZBarrierSetC2State* s = state();
1017   if (s-&gt;load_barrier_count() &gt; 0) {
1018     PhaseMacroExpand macro(igvn);
1019 #ifdef ASSERT
1020     verify_gc_barriers(false);
1021 #endif
1022     int skipped = 0;
1023     while (s-&gt;load_barrier_count() &gt; skipped) {
1024       int load_barrier_count = s-&gt;load_barrier_count();
1025       LoadBarrierNode * n = s-&gt;load_barrier_node(load_barrier_count-1-skipped);
1026       if (igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
1027         // Node is unreachable, so don&#39;t try to expand it
1028         s-&gt;remove_load_barrier_node(n);
1029         continue;
1030       }
1031       if (!n-&gt;can_be_eliminated()) {
1032         skipped++;
1033         continue;
1034       }
1035       expand_loadbarrier_node(&amp;macro, n);
1036       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);
1037       if (C-&gt;failing()) {
1038         return true;
1039       }
1040     }
1041     while (s-&gt;load_barrier_count() &gt; 0) {
1042       int load_barrier_count = s-&gt;load_barrier_count();
1043       LoadBarrierNode* n = s-&gt;load_barrier_node(load_barrier_count - 1);
1044       assert(!(igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())), &quot;should have been processed already&quot;);
1045       assert(!n-&gt;can_be_eliminated(), &quot;should have been processed already&quot;);
1046       expand_loadbarrier_node(&amp;macro, n);
1047       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);
1048       if (C-&gt;failing()) {
1049         return true;
1050       }
1051     }
1052     igvn.set_delay_transform(false);
1053     igvn.optimize();
1054     if (C-&gt;failing()) {
1055       return true;
1056     }
1057   }
1058 
1059   return false;
1060 }
1061 
1062 // == Loop optimization ==
1063 
1064 static bool replace_with_dominating_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, bool last_round) {
1065   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1066   Compile* C = Compile::current();
1067 
1068   LoadBarrierNode* lb2 = lb-&gt;has_dominating_barrier(phase, false, last_round);
1069   if (lb2 == NULL) {
1070     return false;
1071   }
1072 
1073   if (lb-&gt;in(LoadBarrierNode::Oop) != lb2-&gt;in(LoadBarrierNode::Oop)) {
1074     assert(lb-&gt;in(LoadBarrierNode::Address) == lb2-&gt;in(LoadBarrierNode::Address), &quot;Invalid address&quot;);
1075     igvn.replace_input_of(lb, LoadBarrierNode::Similar, lb2-&gt;proj_out(LoadBarrierNode::Oop));
1076     C-&gt;set_major_progress();
1077     return false;
1078   }
1079 
1080   // That transformation may cause the Similar edge on dominated load barriers to be invalid
1081   lb-&gt;fix_similar_in_uses(&amp;igvn);
1082 
1083   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);
1084   assert(lb2-&gt;has_true_uses(), &quot;Invalid uses&quot;);
1085   assert(lb2-&gt;in(LoadBarrierNode::Oop) == lb-&gt;in(LoadBarrierNode::Oop), &quot;Invalid oop&quot;);
1086   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));
1087   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));
1088   igvn.replace_node(val, lb2-&gt;proj_out(LoadBarrierNode::Oop));
1089 
1090   return true;
1091 }
1092 
1093 static Node* find_dominating_memory(PhaseIdealLoop* phase, Node* mem, Node* dom, int i) {
1094   assert(dom-&gt;is_Region() || i == -1, &quot;&quot;);
1095 
1096   Node* m = mem;
1097   while(phase-&gt;is_dominator(dom, phase-&gt;has_ctrl(m) ? phase-&gt;get_ctrl(m) : m-&gt;in(0))) {
1098     if (m-&gt;is_Mem()) {
1099       assert(m-&gt;as_Mem()-&gt;adr_type() == TypeRawPtr::BOTTOM, &quot;&quot;);
1100       m = m-&gt;in(MemNode::Memory);
1101     } else if (m-&gt;is_MergeMem()) {
1102       m = m-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1103     } else if (m-&gt;is_Phi()) {
1104       if (m-&gt;in(0) == dom &amp;&amp; i != -1) {
1105         m = m-&gt;in(i);
1106         break;
1107       } else {
1108         m = m-&gt;in(LoopNode::EntryControl);
1109       }
1110     } else if (m-&gt;is_Proj()) {
1111       m = m-&gt;in(0);
1112     } else if (m-&gt;is_SafePoint() || m-&gt;is_MemBar()) {
1113       m = m-&gt;in(TypeFunc::Memory);
1114     } else {
1115 #ifdef ASSERT
1116       m-&gt;dump();
1117 #endif
1118       ShouldNotReachHere();
1119     }
1120   }
1121 
1122   return m;
1123 }
1124 
1125 static LoadBarrierNode* clone_load_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* ctl, Node* mem, Node* oop_in) {
1126   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1127   Compile* C = Compile::current();
1128   Node* the_clone = lb-&gt;clone();
1129   the_clone-&gt;set_req(LoadBarrierNode::Control, ctl);
1130   the_clone-&gt;set_req(LoadBarrierNode::Memory, mem);
1131   if (oop_in != NULL) {
1132     the_clone-&gt;set_req(LoadBarrierNode::Oop, oop_in);
1133   }
1134 
1135   LoadBarrierNode* new_lb = the_clone-&gt;as_LoadBarrier();
1136   igvn.register_new_node_with_optimizer(new_lb);
1137   IdealLoopTree *loop = phase-&gt;get_loop(new_lb-&gt;in(0));
1138   phase-&gt;set_ctrl(new_lb, new_lb-&gt;in(0));
1139   phase-&gt;set_loop(new_lb, loop);
1140   phase-&gt;set_idom(new_lb, new_lb-&gt;in(0), phase-&gt;dom_depth(new_lb-&gt;in(0))+1);
1141   if (!loop-&gt;_child) {
1142     loop-&gt;_body.push(new_lb);
1143   }
1144 
1145   Node* proj_ctl = new ProjNode(new_lb, LoadBarrierNode::Control);
1146   igvn.register_new_node_with_optimizer(proj_ctl);
1147   phase-&gt;set_ctrl(proj_ctl, proj_ctl-&gt;in(0));
1148   phase-&gt;set_loop(proj_ctl, loop);
1149   phase-&gt;set_idom(proj_ctl, new_lb, phase-&gt;dom_depth(new_lb)+1);
1150   if (!loop-&gt;_child) {
1151     loop-&gt;_body.push(proj_ctl);
1152   }
1153 
1154   Node* proj_oop = new ProjNode(new_lb, LoadBarrierNode::Oop);
1155   phase-&gt;register_new_node(proj_oop, new_lb);
1156 
1157   if (!new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {
1158     LoadBarrierNode* similar = new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;as_LoadBarrier();
1159     if (!phase-&gt;is_dominator(similar, ctl)) {
1160       igvn.replace_input_of(new_lb, LoadBarrierNode::Similar, C-&gt;top());
1161     }
1162   }
1163 
1164   return new_lb;
1165 }
1166 
1167 static void replace_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* new_val) {
1168   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1169   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);
1170   igvn.replace_node(val, new_val);
1171   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));
1172   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));
1173 }
1174 
1175 static bool split_barrier_thru_phi(PhaseIdealLoop* phase, LoadBarrierNode* lb) {
1176   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1177   Compile* C = Compile::current();
1178 
1179   if (lb-&gt;in(LoadBarrierNode::Oop)-&gt;is_Phi()) {
1180     Node* oop_phi = lb-&gt;in(LoadBarrierNode::Oop);
1181 
1182     if ((oop_phi-&gt;req() != 3) || (oop_phi-&gt;in(2) == oop_phi)) {
1183       // Ignore phis with only one input
1184       return false;
1185     }
1186 
1187     if (phase-&gt;is_dominator(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)),
1188                             oop_phi-&gt;in(0)) &amp;&amp; phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)) != oop_phi-&gt;in(0)) {
1189       // That transformation may cause the Similar edge on dominated load barriers to be invalid
1190       lb-&gt;fix_similar_in_uses(&amp;igvn);
1191 
1192       RegionNode* region = oop_phi-&gt;in(0)-&gt;as_Region();
1193 
1194       int backedge = LoopNode::LoopBackControl;
1195       if (region-&gt;is_Loop() &amp;&amp; region-&gt;in(backedge)-&gt;is_Proj() &amp;&amp; region-&gt;in(backedge)-&gt;in(0)-&gt;is_If()) {
1196         Node* c = region-&gt;in(backedge)-&gt;in(0)-&gt;in(0);
1197         assert(c-&gt;unique_ctrl_out() == region-&gt;in(backedge)-&gt;in(0), &quot;&quot;);
1198         Node* oop = lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(backedge);
1199         Node* oop_c = phase-&gt;has_ctrl(oop) ? phase-&gt;get_ctrl(oop) : oop;
1200         if (!phase-&gt;is_dominator(oop_c, c)) {
1201           return false;
1202         }
1203       }
1204 
1205       // If the node on the backedge above the phi is the node itself - we have a self loop.
1206       // Don&#39;t clone - this will be folded later.
1207       if (oop_phi-&gt;in(LoopNode::LoopBackControl) == lb-&gt;proj_out(LoadBarrierNode::Oop)) {
1208         return false;
1209       }
1210 
1211       bool is_strip_mined = region-&gt;is_CountedLoop() &amp;&amp; region-&gt;as_CountedLoop()-&gt;is_strip_mined();
1212       Node *phi = oop_phi-&gt;clone();
1213 
1214       for (uint i = 1; i &lt; region-&gt;req(); i++) {
1215         Node* ctrl = region-&gt;in(i);
1216         if (ctrl != C-&gt;top()) {
1217           assert(!phase-&gt;is_dominator(ctrl, region) || region-&gt;is_Loop(), &quot;&quot;);
1218 
1219           Node* mem = lb-&gt;in(LoadBarrierNode::Memory);
1220           Node* m = find_dominating_memory(phase, mem, region, i);
1221 
1222           if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::LoopBackControl &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_If()) {
1223             ctrl = ctrl-&gt;in(0)-&gt;in(0);
1224           } else if (region-&gt;is_Loop() &amp;&amp; is_strip_mined) {
1225             // If this is a strip mined loop, control must move above OuterStripMinedLoop
1226             assert(i == LoopNode::EntryControl, &quot;check&quot;);
1227             assert(ctrl-&gt;is_OuterStripMinedLoop(), &quot;sanity&quot;);
1228             ctrl = ctrl-&gt;as_OuterStripMinedLoop()-&gt;in(LoopNode::EntryControl);
1229           }
1230 
1231           LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, ctrl, m, lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(i));
1232           Node* out_ctrl = new_lb-&gt;proj_out(LoadBarrierNode::Control);
1233 
1234           if (is_strip_mined &amp;&amp; (i == LoopNode::EntryControl)) {
1235             assert(region-&gt;in(i)-&gt;is_OuterStripMinedLoop(), &quot;&quot;);
1236             igvn.replace_input_of(region-&gt;in(i), i, out_ctrl);
1237             phase-&gt;set_idom(region-&gt;in(i), out_ctrl, phase-&gt;dom_depth(out_ctrl));
1238           } else if (ctrl == region-&gt;in(i)) {
1239             igvn.replace_input_of(region, i, out_ctrl);
1240             // Only update the idom if is the loop entry we are updating
1241             // - A loop backedge doesn&#39;t change the idom
1242             if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::EntryControl) {
1243               phase-&gt;set_idom(region, out_ctrl, phase-&gt;dom_depth(out_ctrl));
1244             }
1245           } else {
1246             Node* iff = region-&gt;in(i)-&gt;in(0);
1247             igvn.replace_input_of(iff, 0, out_ctrl);
1248             phase-&gt;set_idom(iff, out_ctrl, phase-&gt;dom_depth(out_ctrl)+1);
1249           }
1250           phi-&gt;set_req(i, new_lb-&gt;proj_out(LoadBarrierNode::Oop));
1251         }
1252       }
1253       phase-&gt;register_new_node(phi, region);
1254       replace_barrier(phase, lb, phi);
1255 
1256       if (region-&gt;is_Loop()) {
1257         // Load barrier moved to the back edge of the Loop may now
1258         // have a safepoint on the path to the barrier on the Similar
1259         // edge
1260         igvn.replace_input_of(phi-&gt;in(LoopNode::LoopBackControl)-&gt;in(0), LoadBarrierNode::Similar, C-&gt;top());
1261         Node* head = region-&gt;in(LoopNode::EntryControl);
1262         phase-&gt;set_idom(region, head, phase-&gt;dom_depth(head)+1);
1263         phase-&gt;recompute_dom_depth();
1264         if (head-&gt;is_CountedLoop() &amp;&amp; head-&gt;as_CountedLoop()-&gt;is_main_loop()) {
1265           head-&gt;as_CountedLoop()-&gt;set_normal_loop();
1266         }
1267       }
1268 
1269       return true;
1270     }
1271   }
1272 
1273   return false;
1274 }
1275 
1276 static bool move_out_of_loop(PhaseIdealLoop* phase, LoadBarrierNode* lb) {
1277   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1278   IdealLoopTree *lb_loop = phase-&gt;get_loop(lb-&gt;in(0));
1279   if (lb_loop != phase-&gt;ltree_root() &amp;&amp; !lb_loop-&gt;_irreducible) {
1280     Node* oop_ctrl = phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Oop));
1281     IdealLoopTree *oop_loop = phase-&gt;get_loop(oop_ctrl);
1282     IdealLoopTree* adr_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)));
1283     if (!lb_loop-&gt;is_member(oop_loop) &amp;&amp; !lb_loop-&gt;is_member(adr_loop)) {
1284       // That transformation may cause the Similar edge on dominated load barriers to be invalid
1285       lb-&gt;fix_similar_in_uses(&amp;igvn);
1286 
1287       Node* head = lb_loop-&gt;_head;
1288       assert(head-&gt;is_Loop(), &quot;&quot;);
1289 
1290       if (phase-&gt;is_dominator(head, oop_ctrl)) {
1291         assert(oop_ctrl-&gt;Opcode() == Op_CProj &amp;&amp; oop_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch, &quot;&quot;);
1292         assert(lb_loop-&gt;is_member(phase-&gt;get_loop(oop_ctrl-&gt;in(0)-&gt;in(0))), &quot;&quot;);
1293         return false;
1294       }
1295 
1296       if (head-&gt;is_CountedLoop()) {
1297         CountedLoopNode* cloop = head-&gt;as_CountedLoop();
1298         if (cloop-&gt;is_main_loop()) {
1299           cloop-&gt;set_normal_loop();
1300         }
1301         // When we are moving barrier out of a counted loop,
1302         // make sure we move it all the way out of the strip mined outer loop.
1303         if (cloop-&gt;is_strip_mined()) {
1304           head = cloop-&gt;outer_loop();
1305         }
1306       }
1307 
1308       Node* mem = lb-&gt;in(LoadBarrierNode::Memory);
1309       Node* m = find_dominating_memory(phase, mem, head, -1);
1310 
1311       LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, head-&gt;in(LoopNode::EntryControl), m, NULL);
1312 
1313       assert(phase-&gt;idom(head) == head-&gt;in(LoopNode::EntryControl), &quot;&quot;);
1314       Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);
1315       igvn.replace_input_of(head, LoopNode::EntryControl, proj_ctl);
1316       phase-&gt;set_idom(head, proj_ctl, phase-&gt;dom_depth(proj_ctl) + 1);
1317 
1318       replace_barrier(phase, lb, new_lb-&gt;proj_out(LoadBarrierNode::Oop));
1319 
1320       phase-&gt;recompute_dom_depth();
1321 
1322       return true;
1323     }
1324   }
1325 
1326   return false;
1327 }
1328 
1329 static bool common_barriers(PhaseIdealLoop* phase, LoadBarrierNode* lb) {
1330   PhaseIterGVN &amp;igvn = phase-&gt;igvn();
1331   Node* in_val = lb-&gt;in(LoadBarrierNode::Oop);
1332   for (DUIterator_Fast imax, i = in_val-&gt;fast_outs(imax); i &lt; imax; i++) {
1333     Node* u = in_val-&gt;fast_out(i);
1334     if (u != lb &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {
1335       Node* this_ctrl = lb-&gt;in(LoadBarrierNode::Control);
1336       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);
1337 
1338       Node* lca = phase-&gt;dom_lca(this_ctrl, other_ctrl);
1339       bool ok = true;
1340 
1341       Node* proj1 = NULL;
1342       Node* proj2 = NULL;
1343 
1344       while (this_ctrl != lca &amp;&amp; ok) {
1345         if (this_ctrl-&gt;in(0) != NULL &amp;&amp;
1346             this_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {
1347           if (this_ctrl-&gt;in(0)-&gt;in(0) == lca) {
1348             assert(proj1 == NULL, &quot;&quot;);
1349             assert(this_ctrl-&gt;is_Proj(), &quot;&quot;);
1350             proj1 = this_ctrl;
1351           } else if (!(this_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; this_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {
1352             ok = false;
1353           }
1354         }
1355         this_ctrl = phase-&gt;idom(this_ctrl);
1356       }
1357       while (other_ctrl != lca &amp;&amp; ok) {
1358         if (other_ctrl-&gt;in(0) != NULL &amp;&amp;
1359             other_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {
1360           if (other_ctrl-&gt;in(0)-&gt;in(0) == lca) {
1361             assert(other_ctrl-&gt;is_Proj(), &quot;&quot;);
1362             assert(proj2 == NULL, &quot;&quot;);
1363             proj2 = other_ctrl;
1364           } else if (!(other_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; other_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {
1365             ok = false;
1366           }
1367         }
1368         other_ctrl = phase-&gt;idom(other_ctrl);
1369       }
1370       assert(proj1 == NULL || proj2 == NULL || proj1-&gt;in(0) == proj2-&gt;in(0), &quot;&quot;);
1371       if (ok &amp;&amp; proj1 &amp;&amp; proj2 &amp;&amp; proj1 != proj2 &amp;&amp; proj1-&gt;in(0)-&gt;is_If()) {
1372         // That transformation may cause the Similar edge on dominated load barriers to be invalid
1373         lb-&gt;fix_similar_in_uses(&amp;igvn);
1374         u-&gt;as_LoadBarrier()-&gt;fix_similar_in_uses(&amp;igvn);
1375 
1376         Node* split = lca-&gt;unique_ctrl_out();
1377         assert(split-&gt;in(0) == lca, &quot;&quot;);
1378 
1379         Node* mem = lb-&gt;in(LoadBarrierNode::Memory);
1380         Node* m = find_dominating_memory(phase, mem, split, -1);
1381         LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, lca, m, NULL);
1382 
1383         Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);
1384         igvn.replace_input_of(split, 0, new_lb-&gt;proj_out(LoadBarrierNode::Control));
1385         phase-&gt;set_idom(split, proj_ctl, phase-&gt;dom_depth(proj_ctl)+1);
1386 
1387         Node* proj_oop = new_lb-&gt;proj_out(LoadBarrierNode::Oop);
1388         replace_barrier(phase, lb, proj_oop);
1389         replace_barrier(phase, u-&gt;as_LoadBarrier(), proj_oop);
1390 
1391         phase-&gt;recompute_dom_depth();
1392 
1393         return true;
1394       }
1395     }
1396   }
1397 
1398   return false;
1399 }
1400 
1401 void ZBarrierSetC2::loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round) {
1402   if (!Compile::current()-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {
1403     return;
1404   }
1405 
1406   if (!node-&gt;is_LoadBarrier()) {
1407     return;
1408   }
1409 
1410   if (!node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {
1411     return;
1412   }
1413 
1414   if (replace_with_dominating_barrier(phase, node-&gt;as_LoadBarrier(), last_round)) {
1415     return;
1416   }
1417 
1418   if (split_barrier_thru_phi(phase, node-&gt;as_LoadBarrier())) {
1419     return;
1420   }
1421 
1422   if (move_out_of_loop(phase, node-&gt;as_LoadBarrier())) {
1423     return;
1424   }
1425 
1426   if (common_barriers(phase, node-&gt;as_LoadBarrier())) {
1427     return;
1428   }
1429 }
1430 
1431 Node* ZBarrierSetC2::step_over_gc_barrier(Node* c) const {
1432   Node* node = c;
1433 
1434   // 1. This step follows potential oop projections of a load barrier before expansion
1435   if (node-&gt;is_Proj()) {
1436     node = node-&gt;in(0);
1437   }
1438 
1439   // 2. This step checks for unexpanded load barriers
1440   if (node-&gt;is_LoadBarrier()) {
1441     return node-&gt;in(LoadBarrierNode::Oop);
1442   }
1443 
1444   // 3. This step checks for the phi corresponding to an optimized load barrier expansion
1445   if (node-&gt;is_Phi()) {
1446     PhiNode* phi = node-&gt;as_Phi();
1447     Node* n = phi-&gt;in(1);
1448     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {
1449       assert(c == node, &quot;projections from step 1 should only be seen before macro expansion&quot;);
1450       return phi-&gt;in(2);
1451     }
1452   }
1453 
1454   return c;
1455 }
1456 
1457 bool ZBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
1458   return type == T_OBJECT || type == T_ARRAY;
1459 }
1460 
1461 bool ZBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1462   if (opcode != Op_LoadBarrierSlowReg &amp;&amp;
1463       opcode != Op_LoadBarrierWeakSlowReg) {
1464     return false;
1465   }
1466 
1467 #ifdef ASSERT
1468   if (VerifyOptoOopOffsets) {
1469     MemNode* mem  = n-&gt;as_Mem();
1470     // Check to see if address types have grounded out somehow.
1471     const TypeInstPtr* tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1472     ciInstanceKlass* k = tp-&gt;klass()-&gt;as_instance_klass();
1473     bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1474     assert(!tp || oop_offset_is_sane, &quot;&quot;);
1475   }
1476 #endif
1477 
1478   return true;
1479 }
1480 
1481 bool ZBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {
1482   if (opcode == Op_CallLeaf &amp;&amp;
1483       (n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr() ||
1484        n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr())) {
1485     mem_op = true;
1486     mem_addr_idx = TypeFunc::Parms + 1;
1487     return true;
1488   }
1489 
1490   return false;
1491 }
1492 
1493 // == Verification ==
1494 
1495 #ifdef ASSERT
1496 
1497 static bool look_for_barrier(Node* n, bool post_parse, VectorSet&amp; visited) {
1498   if (visited.test_set(n-&gt;_idx)) {
1499     return true;
1500   }
1501 
1502   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1503     Node* u = n-&gt;fast_out(i);
1504     if (u-&gt;is_LoadBarrier()) {
1505     } else if ((u-&gt;is_Phi() || u-&gt;is_CMove()) &amp;&amp; !post_parse) {
1506       if (!look_for_barrier(u, post_parse, visited)) {
1507         return false;
1508       }
1509     } else if (u-&gt;Opcode() == Op_EncodeP || u-&gt;Opcode() == Op_DecodeN) {
1510       if (!look_for_barrier(u, post_parse, visited)) {
1511         return false;
1512       }
1513     } else if (u-&gt;Opcode() != Op_SCMemProj) {
1514       tty-&gt;print(&quot;bad use&quot;); u-&gt;dump();
1515       return false;
1516     }
1517   }
1518 
1519   return true;
1520 }
1521 
1522 void ZBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
1523   if (phase == BarrierSetC2::BeforeCodeGen) return;
1524   bool post_parse = phase == BarrierSetC2::BeforeOptimize;
1525   verify_gc_barriers(post_parse);
1526 }
1527 
1528 void ZBarrierSetC2::verify_gc_barriers(bool post_parse) const {
1529   ZBarrierSetC2State* s = state();
1530   Compile* C = Compile::current();
1531   ResourceMark rm;
1532   VectorSet visited(Thread::current()-&gt;resource_area());
1533   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {
1534     LoadBarrierNode* n = s-&gt;load_barrier_node(i);
1535 
1536     // The dominating barrier on the same address if it exists and
1537     // this barrier must not be applied on the value from the same
1538     // load otherwise the value is not reloaded before it&#39;s used the
1539     // second time.
1540     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||
1541            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;
1542             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Address) == n-&gt;in(LoadBarrierNode::Address) &amp;&amp;
1543             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Oop) != n-&gt;in(LoadBarrierNode::Oop)),
1544            &quot;broken similar edge&quot;);
1545 
1546     assert(post_parse || n-&gt;as_LoadBarrier()-&gt;has_true_uses(),
1547            &quot;found unneeded load barrier&quot;);
1548 
1549     // Several load barrier nodes chained through their Similar edge
1550     // break the code that remove the barriers in final graph reshape.
1551     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||
1552            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;
1553             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()),
1554            &quot;chain of Similar load barriers&quot;);
1555 
1556     if (!n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {
1557       ResourceMark rm;
1558       Unique_Node_List wq;
1559       Node* other = n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0);
1560       wq.push(n);
1561       bool ok = true;
1562       bool dom_found = false;
1563       for (uint next = 0; next &lt; wq.size(); ++next) {
1564         Node *n = wq.at(next);
1565         assert(n-&gt;is_CFG(), &quot;&quot;);
1566         assert(!n-&gt;is_SafePoint(), &quot;&quot;);
1567 
1568         if (n == other) {
1569           continue;
1570         }
1571 
1572         if (n-&gt;is_Region()) {
1573           for (uint i = 1; i &lt; n-&gt;req(); i++) {
1574             Node* m = n-&gt;in(i);
1575             if (m != NULL) {
1576               wq.push(m);
1577             }
1578           }
1579         } else {
1580           Node* m = n-&gt;in(0);
1581           if (m != NULL) {
1582             wq.push(m);
1583           }
1584         }
1585       }
1586     }
1587 
1588     if (ZVerifyLoadBarriers) {
1589       if ((n-&gt;is_Load() || n-&gt;is_LoadStore()) &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr() != NULL) {
1590         visited.Clear();
1591         bool found = look_for_barrier(n, post_parse, visited);
1592         if (!found) {
1593           n-&gt;dump(1);
1594           n-&gt;dump(-3);
1595           stringStream ss;
1596           C-&gt;method()-&gt;print_short_name(&amp;ss);
1597           tty-&gt;print_cr(&quot;-%s-&quot;, ss.as_string());
1598           assert(found, &quot;&quot;);
1599         }
1600       }
1601     }
1602   }
1603 }
1604 
1605 #endif
1606 
1607 bool ZBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1608   switch (opcode) {
1609     case Op_LoadBarrierSlowReg:
1610     case Op_LoadBarrierWeakSlowReg:
1611       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1612       return true;
1613 
1614     case Op_Proj:
1615       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {
1616         return false;
1617       }
1618       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), delayed_worklist);
1619       return true;
1620   }
1621 
1622   return false;
1623 }
1624 
1625 bool ZBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1626   switch (opcode) {
1627     case Op_LoadBarrierSlowReg:
1628     case Op_LoadBarrierWeakSlowReg:
1629       if (gvn-&gt;type(n)-&gt;make_ptr() == NULL) {
1630         return false;
1631       }
1632       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(MemNode::Address), NULL);
1633       return true;
1634 
1635     case Op_Proj:
1636       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {
1637         return false;
1638       }
1639       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), NULL);
1640       return true;
1641   }
1642 
1643   return false;
1644 }
    </pre>
  </body>
</html>
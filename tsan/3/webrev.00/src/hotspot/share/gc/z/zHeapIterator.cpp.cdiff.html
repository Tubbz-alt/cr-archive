<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zHeapIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeapIterator.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zHeapIterator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,16 ***</span>
<span class="line-new-header">--- 20,20 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;classfile/classLoaderData.hpp&quot;</span>
<span class="line-added">+ #include &quot;classfile/classLoaderDataGraph.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/z/zAddress.inline.hpp&quot;</span>
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zGranuleMap.inline.hpp&quot;
  #include &quot;gc/z/zHeapIterator.hpp&quot;
  #include &quot;gc/z/zOop.inline.hpp&quot;
  #include &quot;gc/z/zRootsIterator.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zStat.hpp&quot;</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #include &quot;utilities/stack.inline.hpp&quot;
  
  class ZHeapIteratorBitMap : public CHeapObj&lt;mtGC&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,52 ***</span>
      _map.set_bit(index);
      return true;
    }
  };
  
  class ZHeapIteratorRootOopClosure : public ZRootsIteratorClosure {
  private:
    ZHeapIterator* const _iter;
  
  public:
    ZHeapIteratorRootOopClosure(ZHeapIterator* iter) :
        _iter(iter) {}
  
    virtual void do_oop(oop* p) {
<span class="line-modified">!     // Load barrier needed here, even on non-concurrent strong roots,</span>
<span class="line-removed">-     // for the same reason we need fixup_partial_loads() in ZHeap::mark_end().</span>
<span class="line-removed">-     const oop obj = NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p);</span>
      _iter-&gt;push(obj);
    }
  
    virtual void do_oop(narrowOop* p) {
      ShouldNotReachHere();
    }
  };
  
<span class="line-modified">! class ZHeapIteratorOopClosure : public BasicOopIterateClosure {</span>
  private:
    ZHeapIterator* const _iter;
    const oop            _base;
<span class="line-removed">-   const bool           _visit_referents;</span>
  
<span class="line-modified">!   oop load_oop(oop* p) const {</span>
<span class="line-modified">!     if (_visit_referents) {</span>
<span class="line-modified">!       return HeapAccess&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load_at(_base, _base-&gt;field_offset(p));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       return HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p);</span>
      }
    }
  
  public:
<span class="line-modified">!   ZHeapIteratorOopClosure(ZHeapIterator* iter, oop base, bool visit_referents) :</span>
        _iter(iter),
<span class="line-modified">!       _base(base),</span>
<span class="line-removed">-       _visit_referents(visit_referents) {}</span>
  
    virtual ReferenceIterationMode reference_iteration_mode() {
<span class="line-modified">!     return _visit_referents ? DO_FIELDS : DO_FIELDS_EXCEPT_REFERENT;</span>
    }
  
    virtual void do_oop(oop* p) {
      const oop obj = load_oop(p);
      _iter-&gt;push(obj);
<span class="line-new-header">--- 52,63 ---</span>
      _map.set_bit(index);
      return true;
    }
  };
  
<span class="line-added">+ template &lt;bool Concurrent, bool Weak&gt;</span>
  class ZHeapIteratorRootOopClosure : public ZRootsIteratorClosure {
  private:
    ZHeapIterator* const _iter;
  
<span class="line-added">+   oop load_oop(oop* p) {</span>
<span class="line-added">+     if (Weak) {</span>
<span class="line-added">+       return NativeAccess&lt;AS_NO_KEEPALIVE | ON_PHANTOM_OOP_REF&gt;::oop_load(p);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (Concurrent) {</span>
<span class="line-added">+       return NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  public:
    ZHeapIteratorRootOopClosure(ZHeapIterator* iter) :
        _iter(iter) {}
  
    virtual void do_oop(oop* p) {
<span class="line-modified">!     const oop obj = load_oop(p);</span>
      _iter-&gt;push(obj);
    }
  
    virtual void do_oop(narrowOop* p) {
      ShouldNotReachHere();
    }
  };
  
<span class="line-modified">! template &lt;bool VisitReferents&gt;</span>
<span class="line-added">+ class ZHeapIteratorOopClosure : public ClaimMetadataVisitingOopIterateClosure {</span>
  private:
    ZHeapIterator* const _iter;
    const oop            _base;
  
<span class="line-modified">!   oop load_oop(oop* p) {</span>
<span class="line-modified">!     if (VisitReferents) {</span>
<span class="line-modified">!       return HeapAccess&lt;AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(_base, _base-&gt;field_offset(p));</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     return HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p);</span>
    }
  
  public:
<span class="line-modified">!   ZHeapIteratorOopClosure(ZHeapIterator* iter, oop base) :</span>
<span class="line-added">+       ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_other),</span>
        _iter(iter),
<span class="line-modified">!       _base(base) {}</span>
  
    virtual ReferenceIterationMode reference_iteration_mode() {
<span class="line-modified">!     return VisitReferents ? DO_FIELDS : DO_FIELDS_EXCEPT_REFERENT;</span>
    }
  
    virtual void do_oop(oop* p) {
      const oop obj = load_oop(p);
      _iter-&gt;push(obj);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,20 ***</span>
      return false;
    }
  #endif
  };
  
<span class="line-modified">! ZHeapIterator::ZHeapIterator(bool visit_referents) :</span>
      _visit_stack(),
<span class="line-modified">!     _visit_map(),</span>
<span class="line-removed">-     _visit_referents(visit_referents) {}</span>
  
  ZHeapIterator::~ZHeapIterator() {
    ZVisitMapIterator iter(&amp;_visit_map);
    for (ZHeapIteratorBitMap* map; iter.next(&amp;map);) {
      delete map;
    }
  }
  
  static size_t object_index_max() {
    return ZGranuleSize &gt;&gt; ZObjectAlignmentSmallShift;
  }
<span class="line-new-header">--- 123,20 ---</span>
      return false;
    }
  #endif
  };
  
<span class="line-modified">! ZHeapIterator::ZHeapIterator() :</span>
      _visit_stack(),
<span class="line-modified">!     _visit_map(ZAddressOffsetMax) {}</span>
  
  ZHeapIterator::~ZHeapIterator() {
    ZVisitMapIterator iter(&amp;_visit_map);
    for (ZHeapIteratorBitMap* map; iter.next(&amp;map);) {
      delete map;
    }
<span class="line-added">+   ClassLoaderDataGraph::clear_claimed_marks(ClassLoaderData::_claim_other);</span>
  }
  
  static size_t object_index_max() {
    return ZGranuleSize &gt;&gt; ZObjectAlignmentSmallShift;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,15 ***</span>
    const uintptr_t mask = ZGranuleSize - 1;
    return (offset &amp; mask) &gt;&gt; ZObjectAlignmentSmallShift;
  }
  
  ZHeapIteratorBitMap* ZHeapIterator::object_map(oop obj) {
<span class="line-modified">!   const uintptr_t addr = ZOop::to_address(obj);</span>
<span class="line-modified">!   ZHeapIteratorBitMap* map = _visit_map.get(addr);</span>
    if (map == NULL) {
      map = new ZHeapIteratorBitMap(object_index_max());
<span class="line-modified">!     _visit_map.put(addr, map);</span>
    }
  
    return map;
  }
  
<span class="line-new-header">--- 147,15 ---</span>
    const uintptr_t mask = ZGranuleSize - 1;
    return (offset &amp; mask) &gt;&gt; ZObjectAlignmentSmallShift;
  }
  
  ZHeapIteratorBitMap* ZHeapIterator::object_map(oop obj) {
<span class="line-modified">!   const uintptr_t offset = ZAddress::offset(ZOop::to_address(obj));</span>
<span class="line-modified">!   ZHeapIteratorBitMap* map = _visit_map.get(offset);</span>
    if (map == NULL) {
      map = new ZHeapIteratorBitMap(object_index_max());
<span class="line-modified">!     _visit_map.put(offset, map);</span>
    }
  
    return map;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,50 ***</span>
  
    // Push
    _visit_stack.push(obj);
  }
  
<span class="line-modified">! void ZHeapIterator::objects_do(ObjectClosure* cl) {</span>
<span class="line-modified">!   // Note that the heap iterator visits all reachable objects, including</span>
<span class="line-modified">!   // objects that might be unreachable from the application, such as a</span>
<span class="line-modified">!   // not yet cleared JNIWeakGloablRef. However, also note that visiting</span>
<span class="line-modified">!   // the JVMTI tag map is a requirement to make sure we visit all tagged</span>
<span class="line-modified">!   // objects, even those that might now have become phantom reachable.</span>
<span class="line-removed">-   // If we didn&#39;t do this the application would have expected to see</span>
<span class="line-removed">-   // ObjectFree events for phantom reachable objects in the tag map.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ZHeapIteratorRootOopClosure root_cl(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Push strong roots onto stack</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     ZRootsIterator roots;</span>
<span class="line-removed">-     roots.oops_do(&amp;root_cl);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     ZConcurrentRootsIterator roots;</span>
<span class="line-modified">!     roots.oops_do(&amp;root_cl);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Push weak roots onto stack</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     ZWeakRootsIterator roots;</span>
<span class="line-removed">-     roots.oops_do(&amp;root_cl);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     ZConcurrentWeakRootsIterator roots;</span>
<span class="line-modified">!     roots.oops_do(&amp;root_cl);</span>
    }
  
    // Drain stack
    while (!_visit_stack.is_empty()) {
      const oop obj = _visit_stack.pop();
  
<span class="line-modified">!     // Visit</span>
      cl-&gt;do_object(obj);
  
<span class="line-modified">!     // Push members to visit</span>
<span class="line-modified">!     ZHeapIteratorOopClosure push_cl(this, obj, _visit_referents);</span>
<span class="line-modified">!     obj-&gt;oop_iterate(&amp;push_cl);</span>
    }
  }
<span class="line-new-header">--- 174,49 ---</span>
  
    // Push
    _visit_stack.push(obj);
  }
  
<span class="line-modified">! template &lt;typename RootsIterator, bool Concurrent, bool Weak&gt;</span>
<span class="line-modified">! void ZHeapIterator::push_roots() {</span>
<span class="line-modified">!   ZHeapIteratorRootOopClosure&lt;Concurrent, Weak&gt; cl(this);</span>
<span class="line-modified">!   RootsIterator roots;</span>
<span class="line-modified">!   roots.oops_do(&amp;cl);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! template &lt;bool VisitReferents&gt;</span>
<span class="line-modified">! void ZHeapIterator::push_fields(oop obj) {</span>
<span class="line-modified">!   ZHeapIteratorOopClosure&lt;VisitReferents&gt; cl(this, obj);</span>
<span class="line-modified">!   obj-&gt;oop_iterate(&amp;cl);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! template &lt;bool VisitWeaks&gt;</span>
<span class="line-modified">! void ZHeapIterator::objects_do(ObjectClosure* cl) {</span>
<span class="line-modified">!   ZStatTimerDisable disable;</span>
  
<span class="line-modified">!   // Push roots to visit</span>
<span class="line-modified">!   push_roots&lt;ZRootsIterator,                     false /* Concurrent */, false /* Weak */&gt;();</span>
<span class="line-modified">!   push_roots&lt;ZConcurrentRootsIteratorClaimOther, true  /* Concurrent */, false /* Weak */&gt;();</span>
<span class="line-added">+   if (VisitWeaks) {</span>
<span class="line-added">+     push_roots&lt;ZWeakRootsIterator,           false /* Concurrent */, true  /* Weak */&gt;();</span>
<span class="line-added">+     push_roots&lt;ZConcurrentWeakRootsIterator, true  /* Concurrent */, true  /* Weak */&gt;();</span>
    }
  
    // Drain stack
    while (!_visit_stack.is_empty()) {
      const oop obj = _visit_stack.pop();
  
<span class="line-modified">!     // Visit object</span>
      cl-&gt;do_object(obj);
  
<span class="line-modified">!     // Push fields to visit</span>
<span class="line-modified">!     push_fields&lt;VisitWeaks&gt;(obj);</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZHeapIterator::objects_do(ObjectClosure* cl, bool visit_weaks) {</span>
<span class="line-added">+   if (visit_weaks) {</span>
<span class="line-added">+     objects_do&lt;true /* VisitWeaks */&gt;(cl);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     objects_do&lt;false /* VisitWeaks */&gt;(cl);</span>
    }
  }
</pre>
<center><a href="zHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeapIterator.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMarkTerminate.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMemory.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMemory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 



























































 29 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 30   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 31   for (ZMemory* area; iter.next(&amp;area);) {
 32     if (area-&gt;size() &gt;= size) {
 33       if (area-&gt;size() == size) {
 34         // Exact match, remove area
 35         const uintptr_t start = area-&gt;start();
 36         _freelist.remove(area);
<span class="line-modified"> 37         delete area;</span>
 38         return start;
 39       } else {
 40         // Larger than requested, shrink area
 41         const uintptr_t start = area-&gt;start();
<span class="line-modified"> 42         area-&gt;shrink_from_front(size);</span>
 43         return start;
 44       }
 45     }
 46   }
 47 
 48   // Out of memory
 49   return UINTPTR_MAX;
 50 }
 51 
























 52 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
 53   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 54   for (ZMemory* area; iter.next(&amp;area);) {
 55     if (area-&gt;size() &gt;= size) {
 56       if (area-&gt;size() == size) {
 57         // Exact match, remove area
 58         const uintptr_t start = area-&gt;start();
 59         _freelist.remove(area);
<span class="line-modified"> 60         delete area;</span>
 61         return start;
 62       } else {
 63         // Larger than requested, shrink area
<span class="line-modified"> 64         area-&gt;shrink_from_back(size);</span>
 65         return area-&gt;end();
 66       }
 67     }
 68   }
 69 
 70   // Out of memory
 71   return UINTPTR_MAX;
 72 }
 73 























 74 void ZMemoryManager::free(uintptr_t start, size_t size) {
 75   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
 76   const uintptr_t end = start + size;
 77 
 78   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 79   for (ZMemory* area; iter.next(&amp;area);) {
 80     if (start &lt; area-&gt;start()) {
 81       ZMemory* const prev = _freelist.prev(area);
 82       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
 83         if (end == area-&gt;start()) {
 84           // Merge with prev and current area
<span class="line-modified"> 85           prev-&gt;grow_from_back(size + area-&gt;size());</span>
 86           _freelist.remove(area);
 87           delete area;
 88         } else {
 89           // Merge with prev area
<span class="line-modified"> 90           prev-&gt;grow_from_back(size);</span>
 91         }
 92       } else if (end == area-&gt;start()) {
 93         // Merge with current area
<span class="line-modified"> 94         area-&gt;grow_from_front(size);</span>
 95       } else {
 96         // Insert new area before current area
 97         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<span class="line-modified"> 98         ZMemory* new_area = new ZMemory(start, size);</span>
 99         _freelist.insert_before(area, new_area);
100       }
101 
102       // Done
103       return;
104     }
105   }
106 
107   // Insert last
108   ZMemory* const last = _freelist.last();
109   if (last != NULL &amp;&amp; start == last-&gt;end()) {
110     // Merge with last area
<span class="line-modified">111     last-&gt;grow_from_back(size);</span>
112   } else {
113     // Insert new area last
<span class="line-modified">114     ZMemory* new_area = new ZMemory(start, size);</span>
115     _freelist.insert_last(new_area);
116   }
117 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 
<span class="line-added"> 29 ZMemory* ZMemoryManager::create(uintptr_t start, size_t size) {</span>
<span class="line-added"> 30   ZMemory* const area = new ZMemory(start, size);</span>
<span class="line-added"> 31   if (_callbacks._create != NULL) {</span>
<span class="line-added"> 32     _callbacks._create(area);</span>
<span class="line-added"> 33   }</span>
<span class="line-added"> 34   return area;</span>
<span class="line-added"> 35 }</span>
<span class="line-added"> 36 </span>
<span class="line-added"> 37 void ZMemoryManager::destroy(ZMemory* area) {</span>
<span class="line-added"> 38   if (_callbacks._destroy != NULL) {</span>
<span class="line-added"> 39     _callbacks._destroy(area);</span>
<span class="line-added"> 40   }</span>
<span class="line-added"> 41   delete area;</span>
<span class="line-added"> 42 }</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 void ZMemoryManager::shrink_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added"> 45   if (_callbacks._shrink_from_front != NULL) {</span>
<span class="line-added"> 46     _callbacks._shrink_from_front(area, size);</span>
<span class="line-added"> 47   }</span>
<span class="line-added"> 48   area-&gt;shrink_from_front(size);</span>
<span class="line-added"> 49 }</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 void ZMemoryManager::shrink_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added"> 52   if (_callbacks._shrink_from_back != NULL) {</span>
<span class="line-added"> 53     _callbacks._shrink_from_back(area, size);</span>
<span class="line-added"> 54   }</span>
<span class="line-added"> 55   area-&gt;shrink_from_back(size);</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 void ZMemoryManager::grow_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added"> 59   if (_callbacks._grow_from_front != NULL) {</span>
<span class="line-added"> 60     _callbacks._grow_from_front(area, size);</span>
<span class="line-added"> 61   }</span>
<span class="line-added"> 62   area-&gt;grow_from_front(size);</span>
<span class="line-added"> 63 }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65 void ZMemoryManager::grow_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added"> 66   if (_callbacks._grow_from_back != NULL) {</span>
<span class="line-added"> 67     _callbacks._grow_from_back(area, size);</span>
<span class="line-added"> 68   }</span>
<span class="line-added"> 69   area-&gt;grow_from_back(size);</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 ZMemoryManager::Callbacks::Callbacks() :</span>
<span class="line-added"> 73     _create(NULL),</span>
<span class="line-added"> 74     _destroy(NULL),</span>
<span class="line-added"> 75     _shrink_from_front(NULL),</span>
<span class="line-added"> 76     _shrink_from_back(NULL),</span>
<span class="line-added"> 77     _grow_from_front(NULL),</span>
<span class="line-added"> 78     _grow_from_back(NULL) {}</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80 ZMemoryManager::ZMemoryManager() :</span>
<span class="line-added"> 81     _freelist(),</span>
<span class="line-added"> 82     _callbacks() {}</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 void ZMemoryManager::register_callbacks(const Callbacks&amp; callbacks) {</span>
<span class="line-added"> 85   _callbacks = callbacks;</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
 88 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 89   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 90   for (ZMemory* area; iter.next(&amp;area);) {
 91     if (area-&gt;size() &gt;= size) {
 92       if (area-&gt;size() == size) {
 93         // Exact match, remove area
 94         const uintptr_t start = area-&gt;start();
 95         _freelist.remove(area);
<span class="line-modified"> 96         destroy(area);</span>
 97         return start;
 98       } else {
 99         // Larger than requested, shrink area
100         const uintptr_t start = area-&gt;start();
<span class="line-modified">101         shrink_from_front(area, size);</span>
102         return start;
103       }
104     }
105   }
106 
107   // Out of memory
108   return UINTPTR_MAX;
109 }
110 
<span class="line-added">111 uintptr_t ZMemoryManager::alloc_from_front_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">112   ZMemory* area = _freelist.first();</span>
<span class="line-added">113   if (area != NULL) {</span>
<span class="line-added">114     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">115       // Smaller than or equal to requested, remove area</span>
<span class="line-added">116       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">117       *allocated = area-&gt;size();</span>
<span class="line-added">118       _freelist.remove(area);</span>
<span class="line-added">119       destroy(area);</span>
<span class="line-added">120       return start;</span>
<span class="line-added">121     } else {</span>
<span class="line-added">122       // Larger than requested, shrink area</span>
<span class="line-added">123       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">124       shrink_from_front(area, size);</span>
<span class="line-added">125       *allocated = size;</span>
<span class="line-added">126       return start;</span>
<span class="line-added">127     }</span>
<span class="line-added">128   }</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Out of memory</span>
<span class="line-added">131   *allocated = 0;</span>
<span class="line-added">132   return UINTPTR_MAX;</span>
<span class="line-added">133 }</span>
<span class="line-added">134 </span>
135 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
136   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
137   for (ZMemory* area; iter.next(&amp;area);) {
138     if (area-&gt;size() &gt;= size) {
139       if (area-&gt;size() == size) {
140         // Exact match, remove area
141         const uintptr_t start = area-&gt;start();
142         _freelist.remove(area);
<span class="line-modified">143         destroy(area);</span>
144         return start;
145       } else {
146         // Larger than requested, shrink area
<span class="line-modified">147         shrink_from_back(area, size);</span>
148         return area-&gt;end();
149       }
150     }
151   }
152 
153   // Out of memory
154   return UINTPTR_MAX;
155 }
156 
<span class="line-added">157 uintptr_t ZMemoryManager::alloc_from_back_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">158   ZMemory* area = _freelist.last();</span>
<span class="line-added">159   if (area != NULL) {</span>
<span class="line-added">160     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">161       // Smaller than or equal to requested, remove area</span>
<span class="line-added">162       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">163       *allocated = area-&gt;size();</span>
<span class="line-added">164       _freelist.remove(area);</span>
<span class="line-added">165       destroy(area);</span>
<span class="line-added">166       return start;</span>
<span class="line-added">167     } else {</span>
<span class="line-added">168       // Larger than requested, shrink area</span>
<span class="line-added">169       shrink_from_back(area, size);</span>
<span class="line-added">170       *allocated = size;</span>
<span class="line-added">171       return area-&gt;end();</span>
<span class="line-added">172     }</span>
<span class="line-added">173   }</span>
<span class="line-added">174 </span>
<span class="line-added">175   // Out of memory</span>
<span class="line-added">176   *allocated = 0;</span>
<span class="line-added">177   return UINTPTR_MAX;</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
180 void ZMemoryManager::free(uintptr_t start, size_t size) {
181   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
182   const uintptr_t end = start + size;
183 
184   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
185   for (ZMemory* area; iter.next(&amp;area);) {
186     if (start &lt; area-&gt;start()) {
187       ZMemory* const prev = _freelist.prev(area);
188       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
189         if (end == area-&gt;start()) {
190           // Merge with prev and current area
<span class="line-modified">191           grow_from_back(prev, size + area-&gt;size());</span>
192           _freelist.remove(area);
193           delete area;
194         } else {
195           // Merge with prev area
<span class="line-modified">196           grow_from_back(prev, size);</span>
197         }
198       } else if (end == area-&gt;start()) {
199         // Merge with current area
<span class="line-modified">200         grow_from_front(area, size);</span>
201       } else {
202         // Insert new area before current area
203         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<span class="line-modified">204         ZMemory* const new_area = create(start, size);</span>
205         _freelist.insert_before(area, new_area);
206       }
207 
208       // Done
209       return;
210     }
211   }
212 
213   // Insert last
214   ZMemory* const last = _freelist.last();
215   if (last != NULL &amp;&amp; start == last-&gt;end()) {
216     // Merge with last area
<span class="line-modified">217     grow_from_back(last, size);</span>
218   } else {
219     // Insert new area last
<span class="line-modified">220     ZMemory* const new_area = create(start, size);</span>
221     _freelist.insert_last(new_area);
222   }
223 }
</pre>
</td>
</tr>
</table>
<center><a href="zMarkTerminate.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMemory.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
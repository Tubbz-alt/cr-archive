<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zPageAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a>
 25 #include &quot;gc/z/zAddress.inline.hpp&quot;
 26 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 27 #include &quot;gc/z/zFuture.inline.hpp&quot;
 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zLock.inline.hpp&quot;
 30 #include &quot;gc/z/zPage.inline.hpp&quot;
 31 #include &quot;gc/z/zPageAllocator.hpp&quot;
 32 #include &quot;gc/z/zPageCache.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 33 #include &quot;gc/z/zPreMappedMemory.inline.hpp&quot;</span>
 34 #include &quot;gc/z/zStat.hpp&quot;
<a name="3" id="anc3"></a>
 35 #include &quot;gc/z/zTracer.inline.hpp&quot;
<a name="4" id="anc4"></a>

 36 #include &quot;runtime/init.hpp&quot;
<a name="5" id="anc5"></a>

 37 
 38 static const ZStatCounter       ZCounterAllocationRate(&quot;Memory&quot;, &quot;Allocation Rate&quot;, ZStatUnitBytesPerSecond);
<a name="6" id="anc6"></a>

 39 static const ZStatCriticalPhase ZCriticalPhaseAllocationStall(&quot;Allocation Stall&quot;);
 40 
 41 class ZPageAllocRequest : public StackObj {
 42   friend class ZList&lt;ZPageAllocRequest&gt;;
 43 
 44 private:
 45   const uint8_t                _type;
 46   const size_t                 _size;
 47   const ZAllocationFlags       _flags;
 48   const unsigned int           _total_collections;
 49   ZListNode&lt;ZPageAllocRequest&gt; _node;
 50   ZFuture&lt;ZPage*&gt;              _result;
 51 
 52 public:
 53   ZPageAllocRequest(uint8_t type, size_t size, ZAllocationFlags flags, unsigned int total_collections) :
 54       _type(type),
 55       _size(size),
 56       _flags(flags),
<a name="7" id="anc7"></a><span class="line-modified"> 57       _total_collections(total_collections) {}</span>


 58 
 59   uint8_t type() const {
 60     return _type;
 61   }
 62 
 63   size_t size() const {
 64     return _size;
 65   }
 66 
 67   ZAllocationFlags flags() const {
 68     return _flags;
 69   }
 70 
 71   unsigned int total_collections() const {
 72     return _total_collections;
 73   }
 74 
<a name="8" id="anc8"></a>



 75   ZPage* wait() {
 76     return _result.get();
 77   }
 78 
 79   void satisfy(ZPage* page) {
 80     _result.set(page);
 81   }
 82 };
 83 
 84 ZPage* const ZPageAllocator::gc_marker = (ZPage*)-1;
 85 
<a name="9" id="anc9"></a><span class="line-modified"> 86 ZPageAllocator::ZPageAllocator(size_t min_capacity, size_t max_capacity, size_t max_reserve) :</span>




 87     _lock(),
<a name="10" id="anc10"></a><span class="line-modified"> 88     _virtual(),</span>
<span class="line-modified"> 89     _physical(max_capacity),</span>
 90     _cache(),
<a name="11" id="anc11"></a>

 91     _max_reserve(max_reserve),
<a name="12" id="anc12"></a><span class="line-modified"> 92     _pre_mapped(_virtual, _physical, try_ensure_unused_for_pre_mapped(min_capacity)),</span>

 93     _used_high(0),
 94     _used_low(0),
 95     _used(0),
 96     _allocated(0),
 97     _reclaimed(0),
 98     _queue(),
<a name="13" id="anc13"></a><span class="line-modified"> 99     _detached() {}</span>
































































































100 
101 bool ZPageAllocator::is_initialized() const {
<a name="14" id="anc14"></a><span class="line-modified">102   return _physical.is_initialized() &amp;&amp;</span>
<span class="line-modified">103          _virtual.is_initialized() &amp;&amp;</span>
<span class="line-modified">104          _pre_mapped.is_initialized();</span>


105 }
106 
107 size_t ZPageAllocator::max_capacity() const {
<a name="15" id="anc15"></a><span class="line-modified">108   return _physical.max_capacity();</span>
109 }
110 
<a name="16" id="anc16"></a><span class="line-modified">111 size_t ZPageAllocator::current_max_capacity() const {</span>
<span class="line-modified">112   return _physical.current_max_capacity();</span>

113 }
114 
115 size_t ZPageAllocator::capacity() const {
<a name="17" id="anc17"></a><span class="line-modified">116   return _physical.capacity();</span>
117 }
118 
119 size_t ZPageAllocator::max_reserve() const {
120   return _max_reserve;
121 }
122 
123 size_t ZPageAllocator::used_high() const {
124   return _used_high;
125 }
126 
127 size_t ZPageAllocator::used_low() const {
128   return _used_low;
129 }
130 
131 size_t ZPageAllocator::used() const {
132   return _used;
133 }
134 
<a name="18" id="anc18"></a>




135 size_t ZPageAllocator::allocated() const {
136   return _allocated;
137 }
138 
139 size_t ZPageAllocator::reclaimed() const {
140   return _reclaimed &gt; 0 ? (size_t)_reclaimed : 0;
141 }
142 
143 void ZPageAllocator::reset_statistics() {
144   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
145   _allocated = 0;
146   _reclaimed = 0;
147   _used_high = _used_low = _used;
148 }
149 
150 void ZPageAllocator::increase_used(size_t size, bool relocation) {
151   if (relocation) {
152     // Allocating a page for the purpose of relocation has a
153     // negative contribution to the number of reclaimed bytes.
154     _reclaimed -= size;
155   }
156   _allocated += size;
157   _used += size;
158   if (_used &gt; _used_high) {
159     _used_high = _used;
160   }
161 }
162 
163 void ZPageAllocator::decrease_used(size_t size, bool reclaimed) {
164   if (reclaimed) {
165     // Only pages explicitly released with the reclaimed flag set
166     // counts as reclaimed bytes. This flag is typically true when
167     // a worker releases a page after relocation, and is typically
168     // false when we release a page to undo an allocation.
169     _reclaimed += size;
170   }
171   _used -= size;
172   if (_used &lt; _used_low) {
173     _used_low = _used;
174   }
175 }
176 
<a name="19" id="anc19"></a><span class="line-removed">177 size_t ZPageAllocator::max_available(bool no_reserve) const {</span>
<span class="line-removed">178   size_t available = current_max_capacity() - used();</span>
<span class="line-removed">179 </span>
<span class="line-removed">180   if (no_reserve) {</span>
<span class="line-removed">181     // The reserve should not be considered available</span>
<span class="line-removed">182     available -= MIN2(available, max_reserve());</span>
<span class="line-removed">183   }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   return available;</span>
<span class="line-removed">186 }</span>
<span class="line-removed">187 </span>
<span class="line-removed">188 size_t ZPageAllocator::try_ensure_unused(size_t size, bool no_reserve) {</span>
<span class="line-removed">189   // Ensure that we always have space available for the reserve. This</span>
<span class="line-removed">190   // is needed to avoid losing the reserve because of failure to map</span>
<span class="line-removed">191   // more memory before reaching max capacity.</span>
<span class="line-removed">192   _physical.try_ensure_unused_capacity(size + max_reserve());</span>
<span class="line-removed">193 </span>
<span class="line-removed">194   size_t unused = _physical.unused_capacity();</span>
<span class="line-removed">195 </span>
<span class="line-removed">196   if (no_reserve) {</span>
<span class="line-removed">197     // The reserve should not be considered unused</span>
<span class="line-removed">198     unused -= MIN2(unused, max_reserve());</span>
<span class="line-removed">199   }</span>
<span class="line-removed">200 </span>
<span class="line-removed">201   return MIN2(size, unused);</span>
<span class="line-removed">202 }</span>
<span class="line-removed">203 </span>
<span class="line-removed">204 size_t ZPageAllocator::try_ensure_unused_for_pre_mapped(size_t size) {</span>
<span class="line-removed">205   // This function is called during construction, where the</span>
<span class="line-removed">206   // physical memory manager might have failed to initialied.</span>
<span class="line-removed">207   if (!_physical.is_initialized()) {</span>
<span class="line-removed">208     return 0;</span>
<span class="line-removed">209   }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   return try_ensure_unused(size, true /* no_reserve */);</span>
<span class="line-removed">212 }</span>
<span class="line-removed">213 </span>
214 ZPage* ZPageAllocator::create_page(uint8_t type, size_t size) {
<a name="20" id="anc20"></a><span class="line-removed">215   // Allocate physical memory</span>
<span class="line-removed">216   const ZPhysicalMemory pmem = _physical.alloc(size);</span>
<span class="line-removed">217   if (pmem.is_null()) {</span>
<span class="line-removed">218     // Out of memory</span>
<span class="line-removed">219     return NULL;</span>
<span class="line-removed">220   }</span>
<span class="line-removed">221 </span>
222   // Allocate virtual memory
223   const ZVirtualMemory vmem = _virtual.alloc(size);
224   if (vmem.is_null()) {
225     // Out of address space
<a name="21" id="anc21"></a><span class="line-removed">226     _physical.free(pmem);</span>
227     return NULL;
228   }
229 
<a name="22" id="anc22"></a>



230   // Allocate page
231   return new ZPage(type, vmem, pmem);
232 }
233 
<a name="23" id="anc23"></a><span class="line-modified">234 void ZPageAllocator::flush_pre_mapped() {</span>
<span class="line-modified">235   if (_pre_mapped.available() == 0) {</span>
<span class="line-modified">236     return;</span>
<span class="line-modified">237   }</span>





238 
<a name="24" id="anc24"></a><span class="line-modified">239   // Detach the memory mapping.</span>
<span class="line-modified">240   detach_memory(_pre_mapped.virtual_memory(), _pre_mapped.physical_memory());</span>
241 
<a name="25" id="anc25"></a><span class="line-modified">242   _pre_mapped.clear();</span>

243 }
244 
<a name="26" id="anc26"></a><span class="line-modified">245 void ZPageAllocator::map_page(ZPage* page) {</span>
246   // Map physical memory
247   _physical.map(page-&gt;physical_memory(), page-&gt;start());
248 }
249 
<a name="27" id="anc27"></a><span class="line-modified">250 void ZPageAllocator::detach_page(ZPage* page) {</span>
<span class="line-modified">251   // Detach the memory mapping.</span>
<span class="line-removed">252   detach_memory(page-&gt;virtual_memory(), page-&gt;physical_memory());</span>
<span class="line-removed">253 </span>
<span class="line-removed">254   // Add to list of detached pages</span>
<span class="line-removed">255   _detached.insert_last(page);</span>
<span class="line-removed">256 }</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 void ZPageAllocator::destroy_page(ZPage* page) {</span>
<span class="line-removed">259   assert(page-&gt;is_detached(), &quot;Invalid page state&quot;);</span>
260 
<a name="28" id="anc28"></a><span class="line-modified">261   // Free virtual memory</span>
<span class="line-modified">262   {</span>
<span class="line-modified">263     ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
<span class="line-removed">264     _virtual.free(page-&gt;virtual_memory());</span>
265   }
266 
<a name="29" id="anc29"></a><span class="line-modified">267   delete page;</span>
<span class="line-removed">268 }</span>
<span class="line-removed">269 </span>
<span class="line-removed">270 void ZPageAllocator::flush_detached_pages(ZList&lt;ZPage&gt;* list) {</span>
<span class="line-removed">271   ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>
<span class="line-removed">272   list-&gt;transfer(&amp;_detached);</span>
273 }
274 
<a name="30" id="anc30"></a><span class="line-modified">275 void ZPageAllocator::flush_cache(size_t size) {</span>
<span class="line-modified">276   ZList&lt;ZPage&gt; list;</span>
<span class="line-modified">277 </span>
<span class="line-modified">278   _cache.flush(&amp;list, size);</span>

































279 
<a name="31" id="anc31"></a><span class="line-modified">280   for (ZPage* page = list.remove_first(); page != NULL; page = list.remove_first()) {</span>
<span class="line-modified">281     detach_page(page);</span>
282   }
<a name="32" id="anc32"></a>


283 }
284 
<a name="33" id="anc33"></a><span class="line-modified">285 void ZPageAllocator::check_out_of_memory_during_initialization() {</span>
<span class="line-modified">286   if (!is_init_completed()) {</span>
<span class="line-modified">287     vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;, &quot;Java heap too small&quot;);</span>


288   }
289 }
290 
<a name="34" id="anc34"></a><span class="line-modified">291 ZPage* ZPageAllocator::alloc_page_common_inner(uint8_t type, size_t size, ZAllocationFlags flags) {</span>
<span class="line-modified">292   const size_t max = max_available(flags.no_reserve());</span>
<span class="line-removed">293   if (max &lt; size) {</span>
294     // Not enough free memory
295     return NULL;
296   }
297 
<a name="35" id="anc35"></a><span class="line-modified">298   // Try allocating from the page cache</span>
<span class="line-modified">299   ZPage* const cached_page = _cache.alloc_page(type, size);</span>
<span class="line-modified">300   if (cached_page != NULL) {</span>
<span class="line-modified">301     return cached_page;</span>
<span class="line-removed">302   }</span>
<span class="line-removed">303 </span>
<span class="line-removed">304   // Try allocate from the pre-mapped memory</span>
<span class="line-removed">305   ZPage* const pre_mapped_page = _pre_mapped.alloc_page(type, size);</span>
<span class="line-removed">306   if (pre_mapped_page != NULL) {</span>
<span class="line-removed">307     return pre_mapped_page;</span>
308   }
309 
<a name="36" id="anc36"></a><span class="line-modified">310   // Flush any remaining pre-mapped memory so that</span>
<span class="line-modified">311   // subsequent allocations can use the physical memory.</span>
<span class="line-removed">312   flush_pre_mapped();</span>
<span class="line-removed">313 </span>
<span class="line-removed">314   // Try ensure that physical memory is available</span>
<span class="line-removed">315   const size_t unused = try_ensure_unused(size, flags.no_reserve());</span>
<span class="line-removed">316   if (unused &lt; size) {</span>
<span class="line-removed">317     // Flush cache to free up more physical memory</span>
<span class="line-removed">318     flush_cache(size - unused);</span>
<span class="line-removed">319   }</span>
320 
<a name="37" id="anc37"></a><span class="line-modified">321   // Create new page and allocate physical memory</span>
322   return create_page(type, size);
323 }
324 
325 ZPage* ZPageAllocator::alloc_page_common(uint8_t type, size_t size, ZAllocationFlags flags) {
<a name="38" id="anc38"></a><span class="line-modified">326   ZPage* const page = alloc_page_common_inner(type, size, flags);</span>
327   if (page == NULL) {
328     // Out of memory
329     return NULL;
330   }
331 
332   // Update used statistics
333   increase_used(size, flags.relocation());
334 
335   // Send trace event
<a name="39" id="anc39"></a><span class="line-modified">336   ZTracer::tracer()-&gt;report_page_alloc(size, used(), max_available(flags.no_reserve()), _cache.available(), flags);</span>
337 
338   return page;
339 }
340 
<a name="40" id="anc40"></a>





341 ZPage* ZPageAllocator::alloc_page_blocking(uint8_t type, size_t size, ZAllocationFlags flags) {
342   // Prepare to block
343   ZPageAllocRequest request(type, size, flags, ZCollectedHeap::heap()-&gt;total_collections());
344 
345   _lock.lock();
346 
347   // Try non-blocking allocation
348   ZPage* page = alloc_page_common(type, size, flags);
349   if (page == NULL) {
350     // Allocation failed, enqueue request
351     _queue.insert_last(&amp;request);
352   }
353 
354   _lock.unlock();
355 
356   if (page == NULL) {
357     // Allocation failed
358     ZStatTimer timer(ZCriticalPhaseAllocationStall);
359 
360     // We can only block if VM is fully initialized
361     check_out_of_memory_during_initialization();
362 
363     do {
364       // Start asynchronous GC
365       ZCollectedHeap::heap()-&gt;collect(GCCause::_z_allocation_stall);
366 
367       // Wait for allocation to complete or fail
368       page = request.wait();
369     } while (page == gc_marker);
370 
371     {
<a name="41" id="anc41"></a><span class="line-modified">372       // Guard deletion of underlying semaphore. This is a workaround for a</span>
<span class="line-modified">373       // bug in sem_post() in glibc &lt; 2.21, where it&#39;s not safe to destroy</span>



374       // the semaphore immediately after returning from sem_wait(). The
375       // reason is that sem_post() can touch the semaphore after a waiting
376       // thread have returned from sem_wait(). To avoid this race we are
377       // forcing the waiting thread to acquire/release the lock held by the
378       // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<a name="42" id="anc42"></a>


379       ZLocker&lt;ZLock&gt; locker(&amp;_lock);
<a name="43" id="anc43"></a>
380     }
381   }
382 
383   return page;
384 }
385 
386 ZPage* ZPageAllocator::alloc_page_nonblocking(uint8_t type, size_t size, ZAllocationFlags flags) {
387   ZLocker&lt;ZLock&gt; locker(&amp;_lock);
388   return alloc_page_common(type, size, flags);
389 }
390 
391 ZPage* ZPageAllocator::alloc_page(uint8_t type, size_t size, ZAllocationFlags flags) {
392   ZPage* const page = flags.non_blocking()
393                       ? alloc_page_nonblocking(type, size, flags)
394                       : alloc_page_blocking(type, size, flags);
395   if (page == NULL) {
396     // Out of memory
397     return NULL;
398   }
399 
400   // Map page if needed
401   if (!page-&gt;is_mapped()) {
402     map_page(page);
403   }
404 
405   // Reset page. This updates the page&#39;s sequence number and must
406   // be done after page allocation, which potentially blocked in
407   // a safepoint where the global sequence number was updated.
408   page-&gt;reset();
409 
410   // Update allocation statistics. Exclude worker threads to avoid
411   // artificial inflation of the allocation rate due to relocation.
412   if (!flags.worker_thread()) {
413     // Note that there are two allocation rate counters, which have
414     // different purposes and are sampled at different frequencies.
415     const size_t bytes = page-&gt;size();
416     ZStatInc(ZCounterAllocationRate, bytes);
417     ZStatInc(ZStatAllocRate::counter(), bytes);
418   }
419 
420   return page;
421 }
422 
423 void ZPageAllocator::satisfy_alloc_queue() {
424   for (;;) {
425     ZPageAllocRequest* const request = _queue.first();
426     if (request == NULL) {
427       // Allocation queue is empty
428       return;
429     }
430 
431     ZPage* const page = alloc_page_common(request-&gt;type(), request-&gt;size(), request-&gt;flags());
432     if (page == NULL) {
433       // Allocation could not be satisfied, give up
434       return;
435     }
436 
437     // Allocation succeeded, dequeue and satisfy request. Note that
438     // the dequeue operation must happen first, since the request
439     // will immediately be deallocated once it has been satisfied.
440     _queue.remove(request);
<a name="44" id="anc44"></a>
441     request-&gt;satisfy(page);
442   }
443 }
444 
<a name="45" id="anc45"></a><span class="line-modified">445 void ZPageAllocator::detach_memory(const ZVirtualMemory&amp; vmem, ZPhysicalMemory&amp; pmem) {</span>
<span class="line-modified">446   const uintptr_t addr = vmem.start();</span>
447 
<a name="46" id="anc46"></a><span class="line-modified">448   // Unmap physical memory</span>
<span class="line-modified">449   _physical.unmap(pmem, addr);</span>
450 
<a name="47" id="anc47"></a><span class="line-modified">451   // Free physical memory</span>
<span class="line-modified">452   _physical.free(pmem);</span>
453 
<a name="48" id="anc48"></a><span class="line-modified">454   // Clear physical mapping</span>
<span class="line-modified">455   pmem.clear();</span>



456 }
457 
<a name="49" id="anc49"></a><span class="line-modified">458 void ZPageAllocator::flip_page(ZPage* page) {</span>
<span class="line-modified">459   const ZPhysicalMemory&amp; pmem = page-&gt;physical_memory();</span>
<span class="line-modified">460   const uintptr_t addr = page-&gt;start();</span>









461 
<a name="50" id="anc50"></a><span class="line-modified">462   // Flip physical mapping</span>
<span class="line-modified">463   _physical.flip(pmem, addr);</span>






464 }
465 
<a name="51" id="anc51"></a><span class="line-modified">466 void ZPageAllocator::flip_pre_mapped() {</span>
<span class="line-modified">467   if (_pre_mapped.available() == 0) {</span>
<span class="line-modified">468     // Nothing to flip</span>
<span class="line-modified">469     return;</span>










470   }
<a name="52" id="anc52"></a>
471 
<a name="53" id="anc53"></a><span class="line-modified">472   const ZPhysicalMemory&amp; pmem = _pre_mapped.physical_memory();</span>
<span class="line-modified">473   const ZVirtualMemory&amp; vmem = _pre_mapped.virtual_memory();</span>
474 
<a name="54" id="anc54"></a><span class="line-modified">475   // Flip physical mapping</span>
<span class="line-modified">476   _physical.flip(pmem, vmem.start());</span>















477 }
478 
<a name="55" id="anc55"></a><span class="line-modified">479 void ZPageAllocator::free_page(ZPage* page, bool reclaimed) {</span>
<span class="line-modified">480   ZLocker&lt;ZLock&gt; locker(&amp;_lock);</span>



481 
<a name="56" id="anc56"></a><span class="line-modified">482   // Update used statistics</span>
<span class="line-modified">483   decrease_used(page-&gt;size(), reclaimed);</span>














484 
<a name="57" id="anc57"></a><span class="line-modified">485   // Cache page</span>
<span class="line-modified">486   _cache.free_page(page);</span>
487 
<a name="58" id="anc58"></a><span class="line-modified">488   // Try satisfy blocked allocations</span>
<span class="line-modified">489   satisfy_alloc_queue();</span>



























































































490 }
491 
492 bool ZPageAllocator::is_alloc_stalled() const {
493   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
494   return !_queue.is_empty();
495 }
496 
497 void ZPageAllocator::check_out_of_memory() {
498   ZLocker&lt;ZLock&gt; locker(&amp;_lock);
499 
500   // Fail allocation requests that were enqueued before the
501   // last GC cycle started, otherwise start a new GC cycle.
502   for (ZPageAllocRequest* request = _queue.first(); request != NULL; request = _queue.first()) {
503     if (request-&gt;total_collections() == ZCollectedHeap::heap()-&gt;total_collections()) {
504       // Start a new GC cycle, keep allocation requests enqueued
505       request-&gt;satisfy(gc_marker);
506       return;
507     }
508 
509     // Out of memory, fail allocation request
<a name="59" id="anc59"></a><span class="line-modified">510     _queue.remove_first();</span>

511     request-&gt;satisfy(NULL);
512   }
513 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 
 29 ZMemory* ZMemoryManager::create(uintptr_t start, size_t size) {
 30   ZMemory* const area = new ZMemory(start, size);
 31   if (_callbacks._create != NULL) {
 32     _callbacks._create(area);
 33   }
 34   return area;
 35 }
 36 
 37 void ZMemoryManager::destroy(ZMemory* area) {
 38   if (_callbacks._destroy != NULL) {
 39     _callbacks._destroy(area);
 40   }
 41   delete area;
 42 }
 43 
 44 void ZMemoryManager::shrink_from_front(ZMemory* area, size_t size) {
 45   if (_callbacks._shrink_from_front != NULL) {
 46     _callbacks._shrink_from_front(area, size);
 47   }
 48   area-&gt;shrink_from_front(size);
 49 }
 50 
 51 void ZMemoryManager::shrink_from_back(ZMemory* area, size_t size) {
 52   if (_callbacks._shrink_from_back != NULL) {
 53     _callbacks._shrink_from_back(area, size);
 54   }
 55   area-&gt;shrink_from_back(size);
 56 }
 57 
 58 void ZMemoryManager::grow_from_front(ZMemory* area, size_t size) {
 59   if (_callbacks._grow_from_front != NULL) {
 60     _callbacks._grow_from_front(area, size);
 61   }
 62   area-&gt;grow_from_front(size);
 63 }
 64 
 65 void ZMemoryManager::grow_from_back(ZMemory* area, size_t size) {
 66   if (_callbacks._grow_from_back != NULL) {
 67     _callbacks._grow_from_back(area, size);
 68   }
 69   area-&gt;grow_from_back(size);
 70 }
 71 
 72 ZMemoryManager::Callbacks::Callbacks() :
 73     _create(NULL),
 74     _destroy(NULL),
 75     _shrink_from_front(NULL),
 76     _shrink_from_back(NULL),
 77     _grow_from_front(NULL),
 78     _grow_from_back(NULL) {}
 79 
 80 ZMemoryManager::ZMemoryManager() :
 81     _freelist(),
 82     _callbacks() {}
 83 
 84 void ZMemoryManager::register_callbacks(const Callbacks&amp; callbacks) {
 85   _callbacks = callbacks;
 86 }
 87 
 88 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 89   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 90   for (ZMemory* area; iter.next(&amp;area);) {
 91     if (area-&gt;size() &gt;= size) {
 92       if (area-&gt;size() == size) {
 93         // Exact match, remove area
 94         const uintptr_t start = area-&gt;start();
 95         _freelist.remove(area);
 96         destroy(area);
 97         return start;
 98       } else {
 99         // Larger than requested, shrink area
100         const uintptr_t start = area-&gt;start();
101         shrink_from_front(area, size);
102         return start;
103       }
104     }
105   }
106 
107   // Out of memory
108   return UINTPTR_MAX;
109 }
110 
111 uintptr_t ZMemoryManager::alloc_from_front_at_most(size_t size, size_t* allocated) {
112   ZMemory* area = _freelist.first();
113   if (area != NULL) {
114     if (area-&gt;size() &lt;= size) {
115       // Smaller than or equal to requested, remove area
116       const uintptr_t start = area-&gt;start();
117       *allocated = area-&gt;size();
118       _freelist.remove(area);
119       destroy(area);
120       return start;
121     } else {
122       // Larger than requested, shrink area
123       const uintptr_t start = area-&gt;start();
124       shrink_from_front(area, size);
125       *allocated = size;
126       return start;
127     }
128   }
129 
130   // Out of memory
131   *allocated = 0;
132   return UINTPTR_MAX;
133 }
134 
135 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
136   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
137   for (ZMemory* area; iter.next(&amp;area);) {
138     if (area-&gt;size() &gt;= size) {
139       if (area-&gt;size() == size) {
140         // Exact match, remove area
141         const uintptr_t start = area-&gt;start();
142         _freelist.remove(area);
143         destroy(area);
144         return start;
145       } else {
146         // Larger than requested, shrink area
147         shrink_from_back(area, size);
148         return area-&gt;end();
149       }
150     }
151   }
152 
153   // Out of memory
154   return UINTPTR_MAX;
155 }
156 
157 uintptr_t ZMemoryManager::alloc_from_back_at_most(size_t size, size_t* allocated) {
158   ZMemory* area = _freelist.last();
159   if (area != NULL) {
160     if (area-&gt;size() &lt;= size) {
161       // Smaller than or equal to requested, remove area
162       const uintptr_t start = area-&gt;start();
163       *allocated = area-&gt;size();
164       _freelist.remove(area);
165       destroy(area);
166       return start;
167     } else {
168       // Larger than requested, shrink area
169       shrink_from_back(area, size);
170       *allocated = size;
171       return area-&gt;end();
172     }
173   }
174 
175   // Out of memory
176   *allocated = 0;
177   return UINTPTR_MAX;
178 }
179 
180 void ZMemoryManager::free(uintptr_t start, size_t size) {
181   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
182   const uintptr_t end = start + size;
183 
184   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
185   for (ZMemory* area; iter.next(&amp;area);) {
186     if (start &lt; area-&gt;start()) {
187       ZMemory* const prev = _freelist.prev(area);
188       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
189         if (end == area-&gt;start()) {
190           // Merge with prev and current area
191           grow_from_back(prev, size + area-&gt;size());
192           _freelist.remove(area);
193           delete area;
194         } else {
195           // Merge with prev area
196           grow_from_back(prev, size);
197         }
198       } else if (end == area-&gt;start()) {
199         // Merge with current area
200         grow_from_front(area, size);
201       } else {
202         // Insert new area before current area
203         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
204         ZMemory* const new_area = create(start, size);
205         _freelist.insert_before(area, new_area);
206       }
207 
208       // Done
209       return;
210     }
211   }
212 
213   // Insert last
214   ZMemory* const last = _freelist.last();
215   if (last != NULL &amp;&amp; start == last-&gt;end()) {
216     // Merge with last area
217     grow_from_back(last, size);
218   } else {
219     // Insert new area last
220     ZMemory* const new_area = create(start, size);
221     _freelist.insert_last(new_area);
222   }
223 }
    </pre>
  </body>
</html>
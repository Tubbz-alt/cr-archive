<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/c2/zBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 25 #include &quot;classfile/javaClasses.hpp&quot;</span>
<span class="line-added"> 26 #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="line-added"> 27 #include &quot;gc/z/zBarrierSet.hpp&quot;</span>
<span class="line-added"> 28 #include &quot;gc/z/zBarrierSetAssembler.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;opto/arraycopynode.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;opto/addnode.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;opto/block.hpp&quot;</span>
 33 #include &quot;opto/compile.hpp&quot;
<a name="2" id="anc2"></a>

 34 #include &quot;opto/graphKit.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 35 #include &quot;opto/machnode.hpp&quot;</span>

 36 #include &quot;opto/macro.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added"> 37 #include &quot;opto/memnode.hpp&quot;</span>
 38 #include &quot;opto/node.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added"> 39 #include &quot;opto/regalloc.hpp&quot;</span>
<span class="line-added"> 40 #include &quot;opto/rootnode.hpp&quot;</span>
 41 #include &quot;opto/type.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added"> 42 #include &quot;utilities/growableArray.hpp&quot;</span>
 43 #include &quot;utilities/macros.hpp&quot;
<a name="7" id="anc7"></a>



 44 
<a name="8" id="anc8"></a><span class="line-modified"> 45 class ZBarrierSetC2State : public ResourceObj {</span>
<span class="line-modified"> 46 private:</span>
<span class="line-added"> 47   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* _stubs;</span>
<span class="line-added"> 48   Node_Array                          _live;</span>
 49 
<a name="9" id="anc9"></a><span class="line-modified"> 50 public:</span>
<span class="line-modified"> 51   ZBarrierSetC2State(Arena* arena) :</span>
<span class="line-modified"> 52     _stubs(new (arena) GrowableArray&lt;ZLoadBarrierStubC2*&gt;(arena, 8,  0, NULL)),</span>
<span class="line-modified"> 53     _live(arena) {}</span>




 54 
<a name="10" id="anc10"></a><span class="line-modified"> 55   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* stubs() {</span>
<span class="line-modified"> 56     return _stubs;</span>



 57   }
<a name="11" id="anc11"></a>




 58 
<a name="12" id="anc12"></a><span class="line-modified"> 59   RegMask* live(const Node* node) {</span>
<span class="line-modified"> 60     if (!node-&gt;is_Mach()) {</span>
<span class="line-modified"> 61       // Don&#39;t need liveness for non-MachNodes</span>
<span class="line-modified"> 62       return NULL;</span>





















 63     }
<a name="13" id="anc13"></a>









 64 
<a name="14" id="anc14"></a><span class="line-modified"> 65     const MachNode* const mach = node-&gt;as_Mach();</span>
<span class="line-modified"> 66     if (mach-&gt;barrier_data() != ZLoadBarrierStrong &amp;&amp;</span>
<span class="line-modified"> 67         mach-&gt;barrier_data() != ZLoadBarrierWeak) {</span>
<span class="line-modified"> 68       // Don&#39;t need liveness data for nodes without barriers</span>
<span class="line-modified"> 69       return NULL;</span>
<span class="line-added"> 70     }</span>
 71 
<a name="15" id="anc15"></a><span class="line-modified"> 72     RegMask* live = (RegMask*)_live[node-&gt;_idx];</span>
<span class="line-modified"> 73     if (live == NULL) {</span>
<span class="line-modified"> 74       live = new (Compile::current()-&gt;comp_arena()-&gt;Amalloc_D(sizeof(RegMask))) RegMask();</span>
<span class="line-modified"> 75       _live.map(node-&gt;_idx, (Node*)live);</span>



 76     }
<a name="16" id="anc16"></a>

 77 
<a name="17" id="anc17"></a><span class="line-modified"> 78     return live;</span>


 79   }
<a name="18" id="anc18"></a><span class="line-modified"> 80 };</span>
 81 
<a name="19" id="anc19"></a><span class="line-modified"> 82 static ZBarrierSetC2State* barrier_set_state() {</span>
<span class="line-modified"> 83   return reinterpret_cast&lt;ZBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());</span>










 84 }
 85 
<a name="20" id="anc20"></a><span class="line-modified"> 86 ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {</span>
<span class="line-modified"> 87   ZLoadBarrierStubC2* const stub = new (Compile::current()-&gt;comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, weak);</span>
<span class="line-modified"> 88   if (!Compile::current()-&gt;in_scratch_emit_size()) {</span>
<span class="line-modified"> 89     barrier_set_state()-&gt;stubs()-&gt;append(stub);</span>






 90   }
<a name="21" id="anc21"></a>



 91 
<a name="22" id="anc22"></a><span class="line-modified"> 92   return stub;</span>











 93 }
 94 
<a name="23" id="anc23"></a><span class="line-modified"> 95 ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) :</span>
<span class="line-modified"> 96     _node(node),</span>
<span class="line-modified"> 97     _ref_addr(ref_addr),</span>
<span class="line-modified"> 98     _ref(ref),</span>
<span class="line-modified"> 99     _tmp(tmp),</span>






100     _weak(weak),
<a name="24" id="anc24"></a><span class="line-modified">101     _entry(),</span>
<span class="line-modified">102     _continuation() {</span>
<span class="line-modified">103   assert_different_registers(ref, ref_addr.base());</span>
<span class="line-modified">104   assert_different_registers(ref, ref_addr.index());</span>







105 }
106 
<a name="25" id="anc25"></a><span class="line-modified">107 Address ZLoadBarrierStubC2::ref_addr() const {</span>
<span class="line-modified">108   return _ref_addr;</span>
109 }
110 
<a name="26" id="anc26"></a><span class="line-modified">111 Register ZLoadBarrierStubC2::ref() const {</span>
<span class="line-modified">112   return _ref;</span>

113 }
114 
<a name="27" id="anc27"></a><span class="line-modified">115 Register ZLoadBarrierStubC2::tmp() const {</span>
<span class="line-modified">116   return _tmp;</span>





117 }
118 
<a name="28" id="anc28"></a><span class="line-modified">119 address ZLoadBarrierStubC2::slow_path() const {</span>
<span class="line-modified">120   const DecoratorSet decorators = _weak ? ON_WEAK_OOP_REF : ON_STRONG_OOP_REF;</span>
<span class="line-modified">121   return ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(decorators);</span>
122 }
123 
<a name="29" id="anc29"></a><span class="line-modified">124 RegMask&amp; ZLoadBarrierStubC2::live() const {</span>
<span class="line-modified">125   return *barrier_set_state()-&gt;live(_node);</span>





126 }
127 
<a name="30" id="anc30"></a><span class="line-modified">128 Label* ZLoadBarrierStubC2::entry() {</span>
<span class="line-modified">129   // The _entry will never be bound when in_scratch_emit_size() is true.</span>
<span class="line-modified">130   // However, we still need to return a label that is not bound now, but</span>
<span class="line-modified">131   // will eventually be bound. Any lable will do, as it will only act as</span>
<span class="line-modified">132   // a placeholder, so we return the _continuation label.</span>
<span class="line-modified">133   return Compile::current()-&gt;in_scratch_emit_size() ? &amp;_continuation : &amp;_entry;</span>







134 }
135 
<a name="31" id="anc31"></a><span class="line-modified">136 Label* ZLoadBarrierStubC2::continuation() {</span>
<span class="line-modified">137   return &amp;_continuation;</span>





















































































138 }
139 
<a name="32" id="anc32"></a><span class="line-modified">140 void* ZBarrierSetC2::create_barrier_state(Arena* comp_arena) const {</span>
<span class="line-modified">141   return new (comp_arena) ZBarrierSetC2State(comp_arena);</span>
























142 }
143 
<a name="33" id="anc33"></a><span class="line-modified">144 void ZBarrierSetC2::late_barrier_analysis() const {</span>
<span class="line-modified">145   analyze_dominating_barriers();</span>
<span class="line-modified">146   compute_liveness_at_stubs();</span>










147 }
148 
<a name="34" id="anc34"></a><span class="line-modified">149 void ZBarrierSetC2::emit_stubs(CodeBuffer&amp; cb) const {</span>
<span class="line-modified">150   MacroAssembler masm(&amp;cb);</span>
<span class="line-modified">151   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* const stubs = barrier_set_state()-&gt;stubs();</span>

























152 
<a name="35" id="anc35"></a><span class="line-modified">153   for (int i = 0; i &lt; stubs-&gt;length(); i++) {</span>
<span class="line-modified">154     // Make sure there is enough space in the code buffer</span>
<span class="line-modified">155     if (cb.insts()-&gt;maybe_expand_to_ensure_remaining(Compile::MAX_inst_size) &amp;&amp; cb.blob() == NULL) {</span>
<span class="line-modified">156       ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);</span>
<span class="line-modified">157       return;</span>













































158     }
159 
<a name="36" id="anc36"></a><span class="line-modified">160     ZBarrierSet::assembler()-&gt;generate_c2_load_barrier_stub(&amp;masm, stubs-&gt;at(i));</span>
161   }
162 
<a name="37" id="anc37"></a><span class="line-modified">163   masm.flush();</span>
164 }
165 
<a name="38" id="anc38"></a><span class="line-modified">166 int ZBarrierSetC2::estimate_stub_size() const {</span>
<span class="line-modified">167   Compile* const C = Compile::current();</span>
<span class="line-modified">168   BufferBlob* const blob = C-&gt;scratch_buffer_blob();</span>
<span class="line-modified">169   GrowableArray&lt;ZLoadBarrierStubC2*&gt;* const stubs = barrier_set_state()-&gt;stubs();</span>
<span class="line-modified">170   int size = 0;</span>





















171 
<a name="39" id="anc39"></a><span class="line-modified">172   for (int i = 0; i &lt; stubs-&gt;length(); i++) {</span>
<span class="line-modified">173     CodeBuffer cb(blob-&gt;content_begin(), (address)C-&gt;scratch_locs_memory() - blob-&gt;content_begin());</span>
<span class="line-modified">174     MacroAssembler masm(&amp;cb);</span>
<span class="line-modified">175     ZBarrierSet::assembler()-&gt;generate_c2_load_barrier_stub(&amp;masm, stubs-&gt;at(i));</span>
<span class="line-modified">176     size += cb.insts_size();</span>
177   }
178 
<a name="40" id="anc40"></a><span class="line-modified">179   return size;</span>






























































































180 }
181 
<a name="41" id="anc41"></a><span class="line-modified">182 static void set_barrier_data(C2Access&amp; access) {</span>
<span class="line-modified">183   if (ZBarrierSet::barrier_needed(access.decorators(), access.type())) {</span>
<span class="line-modified">184     if (access.decorators() &amp; ON_WEAK_OOP_REF) {</span>
<span class="line-modified">185       access.set_barrier_data(ZLoadBarrierWeak);</span>
<span class="line-modified">186     } else {</span>
<span class="line-modified">187       access.set_barrier_data(ZLoadBarrierStrong);</span>



















































































188     }
<a name="42" id="anc42"></a>



189   }
190 }
191 
<a name="43" id="anc43"></a>



192 Node* ZBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<a name="44" id="anc44"></a><span class="line-modified">193   set_barrier_data(access);</span>
<span class="line-modified">194   return BarrierSetC2::load_at_resolved(access, val_type);</span>







































195 }
196 
197 Node* ZBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
198                                                     Node* new_val, const Type* val_type) const {
<a name="45" id="anc45"></a><span class="line-modified">199   set_barrier_data(access);</span>
<span class="line-modified">200   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, val_type);</span>





201 }
202 
203 Node* ZBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
204                                                      Node* new_val, const Type* value_type) const {
<a name="46" id="anc46"></a><span class="line-modified">205   set_barrier_data(access);</span>
<span class="line-modified">206   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);</span>


















207 }
208 
209 Node* ZBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* new_val, const Type* val_type) const {
<a name="47" id="anc47"></a><span class="line-modified">210   set_barrier_data(access);</span>
<span class="line-modified">211   return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, val_type);</span>









212 }
213 
<a name="48" id="anc48"></a><span class="line-modified">214 bool ZBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type,</span>
<span class="line-modified">215                                                     bool is_clone, ArrayCopyPhase phase) const {</span>
<span class="line-modified">216   return type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified">217 }</span>








218 
<a name="49" id="anc49"></a><span class="line-modified">219 // This TypeFunc assumes a 64bit system</span>
<span class="line-modified">220 static const TypeFunc* clone_type() {</span>
<span class="line-modified">221   // Create input type (domain)</span>
<span class="line-modified">222   const Type** domain_fields = TypeTuple::fields(4);</span>
<span class="line-modified">223   domain_fields[TypeFunc::Parms + 0] = TypeInstPtr::NOTNULL;  // src</span>
<span class="line-added">224   domain_fields[TypeFunc::Parms + 1] = TypeInstPtr::NOTNULL;  // dst</span>
<span class="line-added">225   domain_fields[TypeFunc::Parms + 2] = TypeLong::LONG;        // size lower</span>
<span class="line-added">226   domain_fields[TypeFunc::Parms + 3] = Type::HALF;            // size upper</span>
<span class="line-added">227   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + 4, domain_fields);</span>
228 
<a name="50" id="anc50"></a><span class="line-modified">229   // Create result type (range)</span>
<span class="line-modified">230   const Type** range_fields = TypeTuple::fields(0);</span>
<span class="line-modified">231   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);</span>




































232 
<a name="51" id="anc51"></a><span class="line-modified">233   return TypeFunc::make(domain, range);</span>




234 }
235 
<a name="52" id="anc52"></a><span class="line-modified">236 // Node n is pointing to the start of oop payload - return base pointer</span>
<span class="line-modified">237 static Node* get_base_for_arracycopy_clone(PhaseMacroExpand* phase, Node* n) {</span>
<span class="line-modified">238   // This would normally be handled by optimizations, but the type system</span>
<span class="line-modified">239   // checks get confused when it thinks it already has a base pointer.</span>
<span class="line-modified">240   const int base_offset = BarrierSetC2::arraycopy_payload_base_offset(false);</span>













































241 
<a name="53" id="anc53"></a><span class="line-modified">242   if (n-&gt;is_AddP() &amp;&amp;</span>
<span class="line-modified">243       n-&gt;in(AddPNode::Offset)-&gt;is_Con() &amp;&amp;</span>
<span class="line-modified">244       n-&gt;in(AddPNode::Offset)-&gt;get_long() == base_offset) {</span>
<span class="line-modified">245     assert(n-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Address), &quot;Sanity check&quot;);</span>
<span class="line-modified">246     return n-&gt;in(AddPNode::Base);</span>



247   } else {
<a name="54" id="anc54"></a><span class="line-modified">248     return phase-&gt;basic_plus_adr(n, phase-&gt;longcon(-base_offset));</span>
















249   }
<a name="55" id="anc55"></a>
250 }
251 
<a name="56" id="anc56"></a><span class="line-modified">252 void ZBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {</span>
<span class="line-modified">253   Node* const src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified">254   if (ac-&gt;is_clone_array()) {</span>
<span class="line-modified">255     // Clone primitive array</span>
<span class="line-modified">256     BarrierSetC2::clone_at_expansion(phase, ac);</span>
<span class="line-modified">257     return;</span>


























































258   }
<a name="57" id="anc57"></a>

















259 
<a name="58" id="anc58"></a><span class="line-modified">260   // Clone instance</span>
<span class="line-modified">261   assert(ac-&gt;is_clone_inst(), &quot;Sanity check&quot;);</span>
<span class="line-modified">262 </span>
<span class="line-modified">263   Node* const ctrl       = ac-&gt;in(TypeFunc::Control);</span>
<span class="line-modified">264   Node* const mem        = ac-&gt;in(TypeFunc::Memory);</span>
<span class="line-modified">265   Node* const dst        = ac-&gt;in(ArrayCopyNode::Dest);</span>
<span class="line-modified">266   Node* const src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);</span>
<span class="line-modified">267   Node* const dst_offset = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="line-modified">268   Node* const size       = ac-&gt;in(ArrayCopyNode::Length);</span>
<span class="line-modified">269 </span>
<span class="line-modified">270   assert(src_offset == NULL, &quot;Should be null&quot;);</span>
<span class="line-modified">271   assert(dst_offset == NULL, &quot;Should be null&quot;);</span>
<span class="line-modified">272   assert(size-&gt;bottom_type()-&gt;is_long(), &quot;Should be long&quot;);</span>
<span class="line-modified">273 </span>
<span class="line-modified">274   // The src and dst point to the object payload rather than the object base</span>
<span class="line-modified">275   Node* const src_base = get_base_for_arracycopy_clone(phase, src);</span>
<span class="line-modified">276   Node* const dst_base = get_base_for_arracycopy_clone(phase, dst);</span>
<span class="line-modified">277 </span>
<span class="line-modified">278   // The size must also be increased to match the instance size</span>
<span class="line-modified">279   Node* const base_offset = phase-&gt;longcon(arraycopy_payload_base_offset(false) &gt;&gt; LogBytesPerLong);</span>
<span class="line-modified">280   Node* const full_size = phase-&gt;transform_later(new AddLNode(size, base_offset));</span>
<span class="line-modified">281 </span>
<span class="line-modified">282   Node* const call = phase-&gt;make_leaf_call(ctrl,</span>
<span class="line-modified">283                                            mem,</span>
<span class="line-modified">284                                            clone_type(),</span>
<span class="line-modified">285                                            ZBarrierSetRuntime::clone_addr(),</span>
<span class="line-modified">286                                            &quot;ZBarrierSetRuntime::clone&quot;,</span>
<span class="line-modified">287                                            TypeRawPtr::BOTTOM,</span>
<span class="line-modified">288                                            src_base,</span>
<span class="line-modified">289                                            dst_base,</span>
<span class="line-modified">290                                            full_size,</span>
<span class="line-modified">291                                            phase-&gt;top());</span>
<span class="line-modified">292   phase-&gt;transform_later(call);</span>
<span class="line-modified">293   phase-&gt;igvn().replace_node(ac, call);</span>
<span class="line-modified">294 }</span>
<span class="line-modified">295 </span>
<span class="line-modified">296 // == Dominating barrier elision ==</span>
<span class="line-modified">297 </span>
<span class="line-modified">298 static bool block_has_safepoint(const Block* block, uint from, uint to) {</span>
<span class="line-modified">299   for (uint i = from; i &lt; to; i++) {</span>
<span class="line-added">300     if (block-&gt;get_node(i)-&gt;is_MachSafePoint()) {</span>
<span class="line-added">301       // Safepoint found</span>
302       return true;
303     }
304   }
305 
<a name="59" id="anc59"></a><span class="line-added">306   // Safepoint not found</span>
307   return false;
308 }
309 
<a name="60" id="anc60"></a><span class="line-modified">310 static bool block_has_safepoint(const Block* block) {</span>
<span class="line-modified">311   return block_has_safepoint(block, 0, block-&gt;number_of_nodes());</span>



























312 }
313 
<a name="61" id="anc61"></a><span class="line-modified">314 static uint block_index(const Block* block, const Node* node) {</span>
<span class="line-modified">315   for (uint j = 0; j &lt; block-&gt;number_of_nodes(); ++j) {</span>
<span class="line-modified">316     if (block-&gt;get_node(j) == node) {</span>
<span class="line-modified">317       return j;</span>






















318     }
319   }
<a name="62" id="anc62"></a><span class="line-modified">320   ShouldNotReachHere();</span>
<span class="line-modified">321   return 0;</span>
322 }
323 
<a name="63" id="anc63"></a><span class="line-modified">324 void ZBarrierSetC2::analyze_dominating_barriers() const {</span>
<span class="line-modified">325   ResourceMark rm;</span>
<span class="line-modified">326   Compile* const C = Compile::current();</span>
<span class="line-modified">327   PhaseCFG* const cfg = C-&gt;cfg();</span>
<span class="line-modified">328   Block_List worklist;</span>
<span class="line-modified">329   Node_List mem_ops;</span>
<span class="line-modified">330   Node_List barrier_loads;</span>
<span class="line-modified">331 </span>
<span class="line-modified">332   // Step 1 - Find accesses, and track them in lists</span>
<span class="line-modified">333   for (uint i = 0; i &lt; cfg-&gt;number_of_blocks(); ++i) {</span>
<span class="line-modified">334     const Block* const block = cfg-&gt;get_block(i);</span>
<span class="line-modified">335     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); ++j) {</span>
<span class="line-modified">336       const Node* const node = block-&gt;get_node(j);</span>
<span class="line-modified">337       if (!node-&gt;is_Mach()) {</span>
<span class="line-modified">338         continue;</span>
<span class="line-modified">339       }</span>












340 
<a name="64" id="anc64"></a><span class="line-modified">341       MachNode* const mach = node-&gt;as_Mach();</span>
<span class="line-modified">342       switch (mach-&gt;ideal_Opcode()) {</span>
<span class="line-added">343       case Op_LoadP:</span>
<span class="line-added">344       case Op_CompareAndExchangeP:</span>
<span class="line-added">345       case Op_CompareAndSwapP:</span>
<span class="line-added">346       case Op_GetAndSetP:</span>
<span class="line-added">347         if (mach-&gt;barrier_data() == ZLoadBarrierStrong) {</span>
<span class="line-added">348           barrier_loads.push(mach);</span>
<span class="line-added">349         }</span>
<span class="line-added">350       case Op_StoreP:</span>
<span class="line-added">351         mem_ops.push(mach);</span>
<span class="line-added">352         break;</span>
353 
<a name="65" id="anc65"></a><span class="line-modified">354       default:</span>
<span class="line-modified">355         break;</span>
<span class="line-modified">356       }</span>

357     }
358   }
359 
<a name="66" id="anc66"></a><span class="line-modified">360   // Step 2 - Find dominating accesses for each load</span>
<span class="line-modified">361   for (uint i = 0; i &lt; barrier_loads.size(); i++) {</span>
<span class="line-added">362     MachNode* const load = barrier_loads.at(i)-&gt;as_Mach();</span>
<span class="line-added">363     const TypePtr* load_adr_type = NULL;</span>
<span class="line-added">364     intptr_t load_offset = 0;</span>
<span class="line-added">365     const Node* const load_obj = load-&gt;get_base_and_disp(load_offset, load_adr_type);</span>
<span class="line-added">366     Block* const load_block = cfg-&gt;get_block_for_node(load);</span>
<span class="line-added">367     const uint load_index = block_index(load_block, load);</span>
368 
<a name="67" id="anc67"></a><span class="line-modified">369     for (uint j = 0; j &lt; mem_ops.size(); j++) {</span>
<span class="line-modified">370       MachNode* mem = mem_ops.at(j)-&gt;as_Mach();</span>
<span class="line-modified">371       const TypePtr* mem_adr_type = NULL;</span>
<span class="line-modified">372       intptr_t mem_offset = 0;</span>
<span class="line-modified">373       const Node* mem_obj = mem-&gt;get_base_and_disp(mem_offset, mem_adr_type);</span>
<span class="line-modified">374       Block* mem_block = cfg-&gt;get_block_for_node(mem);</span>
<span class="line-modified">375       uint mem_index = block_index(mem_block, mem);</span>












376 
<a name="68" id="anc68"></a><span class="line-modified">377       if (load_obj == NodeSentinel || mem_obj == NodeSentinel ||</span>
<span class="line-modified">378           load_obj == NULL || mem_obj == NULL ||</span>
<span class="line-modified">379           load_offset &lt; 0 || mem_offset &lt; 0) {</span>
<span class="line-modified">380         continue;</span>












381       }
382 
<a name="69" id="anc69"></a><span class="line-modified">383       if (mem_obj != load_obj || mem_offset != load_offset) {</span>
<span class="line-modified">384         // Not the same addresses, not a candidate</span>
<span class="line-modified">385         continue;</span>

386       }
387 
<a name="70" id="anc70"></a><span class="line-modified">388       if (load_block == mem_block) {</span>
<span class="line-modified">389         // Earlier accesses in the same block</span>
<span class="line-modified">390         if (mem_index &lt; load_index &amp;&amp; !block_has_safepoint(mem_block, mem_index + 1, load_index)) {</span>
<span class="line-modified">391           load-&gt;set_barrier_data(ZLoadBarrierElided);</span>
<span class="line-modified">392         }</span>
<span class="line-modified">393       } else if (mem_block-&gt;dominates(load_block)) {</span>
<span class="line-modified">394         // Dominating block? Look around for safepoints</span>
<span class="line-modified">395         ResourceMark rm;</span>
<span class="line-modified">396         Block_List stack;</span>
<span class="line-modified">397         VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-modified">398         stack.push(load_block);</span>
<span class="line-modified">399         bool safepoint_found = block_has_safepoint(load_block);</span>
<span class="line-modified">400         while (!safepoint_found &amp;&amp; stack.size() &gt; 0) {</span>
<span class="line-modified">401           Block* block = stack.pop();</span>
<span class="line-modified">402           if (visited.test_set(block-&gt;_pre_order)) {</span>
<span class="line-modified">403             continue;</span>


404           }
<a name="71" id="anc71"></a><span class="line-modified">405           if (block_has_safepoint(block)) {</span>
<span class="line-modified">406             safepoint_found = true;</span>
<span class="line-modified">407             break;</span>
















408           }
<a name="72" id="anc72"></a><span class="line-modified">409           if (block == mem_block) {</span>
<span class="line-modified">410             continue;</span>





































































































411           }
<a name="73" id="anc73"></a><span class="line-modified">412 </span>
<span class="line-modified">413           // Push predecessor blocks</span>
<span class="line-modified">414           for (uint p = 1; p &lt; block-&gt;num_preds(); ++p) {</span>
<span class="line-modified">415             Block* pred = cfg-&gt;get_block_for_node(block-&gt;pred(p));</span>
<span class="line-modified">416             stack.push(pred);</span>







417           }
418         }
<a name="74" id="anc74"></a>























419 
<a name="75" id="anc75"></a><span class="line-modified">420         if (!safepoint_found) {</span>
<span class="line-added">421           load-&gt;set_barrier_data(ZLoadBarrierElided);</span>
<span class="line-added">422         }</span>
423       }
424     }
425   }
<a name="76" id="anc76"></a>





























































































426 }
427 
<a name="77" id="anc77"></a><span class="line-modified">428 // == Reduced spilling optimization ==</span>


429 
<a name="78" id="anc78"></a><span class="line-modified">430 void ZBarrierSetC2::compute_liveness_at_stubs() const {</span>
<span class="line-modified">431   ResourceMark rm;</span>
<span class="line-modified">432   Compile* const C = Compile::current();</span>
<span class="line-modified">433   Arena* const A = Thread::current()-&gt;resource_area();</span>
<span class="line-modified">434   PhaseCFG* const cfg = C-&gt;cfg();</span>
<span class="line-modified">435   PhaseRegAlloc* const regalloc = C-&gt;regalloc();</span>
<span class="line-modified">436   RegMask* const live = NEW_ARENA_ARRAY(A, RegMask, cfg-&gt;number_of_blocks() * sizeof(RegMask));</span>
<span class="line-modified">437   ZBarrierSetAssembler* const bs = ZBarrierSet::assembler();</span>
<span class="line-modified">438   Block_List worklist;</span>
<span class="line-modified">439 </span>
<span class="line-modified">440   for (uint i = 0; i &lt; cfg-&gt;number_of_blocks(); ++i) {</span>
<span class="line-added">441     new ((void*)(live + i)) RegMask();</span>
<span class="line-added">442     worklist.push(cfg-&gt;get_block(i));</span>
<span class="line-added">443   }</span>
<span class="line-added">444 </span>
<span class="line-added">445   while (worklist.size() &gt; 0) {</span>
<span class="line-added">446     const Block* const block = worklist.pop();</span>
<span class="line-added">447     RegMask&amp; old_live = live[block-&gt;_pre_order];</span>
<span class="line-added">448     RegMask new_live;</span>
<span class="line-added">449 </span>
<span class="line-added">450     // Initialize to union of successors</span>
<span class="line-added">451     for (uint i = 0; i &lt; block-&gt;_num_succs; i++) {</span>
<span class="line-added">452       const uint succ_id = block-&gt;_succs[i]-&gt;_pre_order;</span>
<span class="line-added">453       new_live.OR(live[succ_id]);</span>
<span class="line-added">454     }</span>
<span class="line-added">455 </span>
<span class="line-added">456     // Walk block backwards, computing liveness</span>
<span class="line-added">457     for (int i = block-&gt;number_of_nodes() - 1; i &gt;= 0; --i) {</span>
<span class="line-added">458       const Node* const node = block-&gt;get_node(i);</span>
<span class="line-added">459 </span>
<span class="line-added">460       // Remove def bits</span>
<span class="line-added">461       const OptoReg::Name first = bs-&gt;refine_register(node, regalloc-&gt;get_reg_first(node));</span>
<span class="line-added">462       const OptoReg::Name second = bs-&gt;refine_register(node, regalloc-&gt;get_reg_second(node));</span>
<span class="line-added">463       if (first != OptoReg::Bad) {</span>
<span class="line-added">464         new_live.Remove(first);</span>
465       }
<a name="79" id="anc79"></a><span class="line-modified">466       if (second != OptoReg::Bad) {</span>
<span class="line-modified">467         new_live.Remove(second);</span>

468       }
<a name="80" id="anc80"></a>







469 
<a name="81" id="anc81"></a><span class="line-modified">470       // Add use bits</span>
<span class="line-modified">471       for (uint j = 1; j &lt; node-&gt;req(); ++j) {</span>
<span class="line-modified">472         const Node* const use = node-&gt;in(j);</span>
<span class="line-modified">473         const OptoReg::Name first = bs-&gt;refine_register(use, regalloc-&gt;get_reg_first(use));</span>
<span class="line-modified">474         const OptoReg::Name second = bs-&gt;refine_register(use, regalloc-&gt;get_reg_second(use));</span>
<span class="line-modified">475         if (first != OptoReg::Bad) {</span>
<span class="line-modified">476           new_live.Insert(first);</span>









































477         }
<a name="82" id="anc82"></a><span class="line-modified">478         if (second != OptoReg::Bad) {</span>
<span class="line-modified">479           new_live.Insert(second);</span>











480         }
481       }
<a name="83" id="anc83"></a>
482 
<a name="84" id="anc84"></a><span class="line-modified">483       // If this node tracks liveness, update it</span>
<span class="line-modified">484       RegMask* const regs = barrier_set_state()-&gt;live(node);</span>
<span class="line-modified">485       if (regs != NULL) {</span>
<span class="line-modified">486         regs-&gt;OR(new_live);</span>








487       }
488     }
<a name="85" id="anc85"></a>





















489 
<a name="86" id="anc86"></a><span class="line-modified">490     // Now at block top, see if we have any changes</span>
<span class="line-modified">491     new_live.SUBTRACT(old_live);</span>
<span class="line-modified">492     if (new_live.is_NotEmpty()) {</span>
<span class="line-modified">493       // Liveness has refined, update and propagate to prior blocks</span>
<span class="line-modified">494       old_live.OR(new_live);</span>
<span class="line-modified">495       for (uint i = 1; i &lt; block-&gt;num_preds(); ++i) {</span>
<span class="line-added">496         Block* const pred = cfg-&gt;get_block_for_node(block-&gt;pred(i));</span>
<span class="line-added">497         worklist.push(pred);</span>
498       }
<a name="87" id="anc87"></a><span class="line-modified">499     }</span>








500   }
<a name="88" id="anc88"></a>

501 }
<a name="89" id="anc89"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="89" type="hidden" />
</body>
</html>
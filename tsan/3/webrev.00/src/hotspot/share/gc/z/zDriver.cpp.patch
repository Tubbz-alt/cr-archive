diff a/src/hotspot/share/gc/z/zDriver.cpp b/src/hotspot/share/gc/z/zDriver.cpp
--- a/src/hotspot/share/gc/z/zDriver.cpp
+++ b/src/hotspot/share/gc/z/zDriver.cpp
@@ -29,10 +29,11 @@
 #include "gc/z/zDriver.hpp"
 #include "gc/z/zHeap.inline.hpp"
 #include "gc/z/zMessagePort.inline.hpp"
 #include "gc/z/zServiceability.hpp"
 #include "gc/z/zStat.hpp"
+#include "gc/z/zVerify.hpp"
 #include "logging/log.hpp"
 #include "memory/universe.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 
@@ -41,13 +42,11 @@
 static const ZStatPhaseConcurrent ZPhaseConcurrentMark("Concurrent Mark");
 static const ZStatPhaseConcurrent ZPhaseConcurrentMarkContinue("Concurrent Mark Continue");
 static const ZStatPhasePause      ZPhasePauseMarkEnd("Pause Mark End");
 static const ZStatPhaseConcurrent ZPhaseConcurrentProcessNonStrongReferences("Concurrent Process Non-Strong References");
 static const ZStatPhaseConcurrent ZPhaseConcurrentResetRelocationSet("Concurrent Reset Relocation Set");
-static const ZStatPhaseConcurrent ZPhaseConcurrentDestroyDetachedPages("Concurrent Destroy Detached Pages");
 static const ZStatPhaseConcurrent ZPhaseConcurrentSelectRelocationSet("Concurrent Select Relocation Set");
-static const ZStatPhaseConcurrent ZPhaseConcurrentPrepareRelocationSet("Concurrent Prepare Relocation Set");
 static const ZStatPhasePause      ZPhasePauseRelocateStart("Pause Relocate Start");
 static const ZStatPhaseConcurrent ZPhaseConcurrentRelocated("Concurrent Relocate");
 static const ZStatCriticalPhase   ZCriticalPhaseGCLockerStall("GC Locker Stall", false /* verbose */);
 static const ZStatSampler         ZSamplerJavaThreads("System", "Java Threads", ZStatUnitThreads);
 
@@ -86,10 +85,13 @@
 
     // Setup GC id and active marker
     GCIdMark gc_id_mark(_gc_id);
     IsGCActiveMark gc_active_mark;
 
+    // Verify before operation
+    ZVerify::before_zoperation();
+
     // Execute operation
     _success = do_operation();
 
     // Update statistics
     ZStatSample(ZSamplerJavaThreads, Threads::number_of_threads());
@@ -207,10 +209,21 @@
     ZHeap::heap()->relocate_start();
     return true;
   }
 };
 
+class VM_ZVerify : public VM_Operation {
+public:
+  virtual VMOp_Type type() const {
+    return VMOp_ZVerify;
+  }
+
+  virtual void doit() {
+    ZVerify::after_weak_processing();
+  }
+};
+
 ZDriver::ZDriver() :
     _gc_cycle_port(),
     _gc_locker_port() {
   set_name("ZDriver");
   create_and_start();
@@ -234,10 +247,11 @@
   case GCCause::_z_timer:
   case GCCause::_z_warmup:
   case GCCause::_z_allocation_rate:
   case GCCause::_z_allocation_stall:
   case GCCause::_z_proactive:
+  case GCCause::_z_high_usage:
   case GCCause::_metadata_GC_threshold:
     // Start asynchronous GC
     _gc_cycle_port.send_async(cause);
     break;
 
@@ -298,32 +312,27 @@
 void ZDriver::concurrent_reset_relocation_set() {
   ZStatTimer timer(ZPhaseConcurrentResetRelocationSet);
   ZHeap::heap()->reset_relocation_set();
 }
 
-void ZDriver::concurrent_destroy_detached_pages() {
-  ZStatTimer timer(ZPhaseConcurrentDestroyDetachedPages);
-  ZHeap::heap()->destroy_detached_pages();
-}
-
 void ZDriver::pause_verify() {
   if (VerifyBeforeGC || VerifyDuringGC || VerifyAfterGC) {
+    // Full verification
     VM_Verify op;
     VMThread::execute(&op);
+  } else if (ZVerifyRoots || ZVerifyObjects) {
+    // Limited verification
+    VM_ZVerify op;
+    VMThread::execute(&op);
   }
 }
 
 void ZDriver::concurrent_select_relocation_set() {
   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
   ZHeap::heap()->select_relocation_set();
 }
 
-void ZDriver::concurrent_prepare_relocation_set() {
-  ZStatTimer timer(ZPhaseConcurrentPrepareRelocationSet);
-  ZHeap::heap()->prepare_relocation_set();
-}
-
 void ZDriver::pause_relocate_start() {
   pause<VM_ZRelocateStart>();
 }
 
 void ZDriver::concurrent_relocate() {
@@ -335,17 +344,19 @@
   ZHeap::heap()->check_out_of_memory();
 }
 
 class ZDriverGCScope : public StackObj {
 private:
-  GCIdMark      _gc_id;
-  GCCauseSetter _gc_cause_setter;
-  ZStatTimer    _timer;
+  GCIdMark       _gc_id;
+  GCCause::Cause _gc_cause;
+  GCCauseSetter  _gc_cause_setter;
+  ZStatTimer     _timer;
 
 public:
   ZDriverGCScope(GCCause::Cause cause) :
       _gc_id(),
+      _gc_cause(cause),
       _gc_cause_setter(ZCollectedHeap::heap(), cause),
       _timer(ZPhaseCycle) {
     // Update statistics
     ZStatCycle::at_start();
   }
@@ -354,11 +365,11 @@
     // Calculate boost factor
     const double boost_factor = (double)ZHeap::heap()->nconcurrent_worker_threads() /
                                 (double)ZHeap::heap()->nconcurrent_no_boost_worker_threads();
 
     // Update statistics
-    ZStatCycle::at_end(boost_factor);
+    ZStatCycle::at_end(_gc_cause, boost_factor);
 
     // Update data used by soft reference policy
     Universe::update_heap_info_at_gc();
   }
 };
@@ -382,26 +393,20 @@
   concurrent_process_non_strong_references();
 
   // Phase 5: Concurrent Reset Relocation Set
   concurrent_reset_relocation_set();
 
-  // Phase 6: Concurrent Destroy Detached Pages
-  concurrent_destroy_detached_pages();
-
-  // Phase 7: Pause Verify
+  // Phase 6: Pause Verify
   pause_verify();
 
-  // Phase 8: Concurrent Select Relocation Set
+  // Phase 7: Concurrent Select Relocation Set
   concurrent_select_relocation_set();
 
-  // Phase 9: Concurrent Prepare Relocation Set
-  concurrent_prepare_relocation_set();
-
-  // Phase 10: Pause Relocate Start
+  // Phase 8: Pause Relocate Start
   pause_relocate_start();
 
-  // Phase 11: Concurrent Relocate
+  // Phase 9: Concurrent Relocate
   concurrent_relocate();
 }
 
 void ZDriver::run_service() {
   // Main loop

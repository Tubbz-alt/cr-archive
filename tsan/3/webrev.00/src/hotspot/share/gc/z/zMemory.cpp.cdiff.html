<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMarkTerminate.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMemory.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMemory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,55 ***</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zList.inline.hpp&quot;
  #include &quot;gc/z/zMemory.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  
  uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
    ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
    for (ZMemory* area; iter.next(&amp;area);) {
      if (area-&gt;size() &gt;= size) {
        if (area-&gt;size() == size) {
          // Exact match, remove area
          const uintptr_t start = area-&gt;start();
          _freelist.remove(area);
<span class="line-modified">!         delete area;</span>
          return start;
        } else {
          // Larger than requested, shrink area
          const uintptr_t start = area-&gt;start();
<span class="line-modified">!         area-&gt;shrink_from_front(size);</span>
          return start;
        }
      }
    }
  
    // Out of memory
    return UINTPTR_MAX;
  }
  
  uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
    ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
    for (ZMemory* area; iter.next(&amp;area);) {
      if (area-&gt;size() &gt;= size) {
        if (area-&gt;size() == size) {
          // Exact match, remove area
          const uintptr_t start = area-&gt;start();
          _freelist.remove(area);
<span class="line-modified">!         delete area;</span>
          return start;
        } else {
          // Larger than requested, shrink area
<span class="line-modified">!         area-&gt;shrink_from_back(size);</span>
          return area-&gt;end();
        }
      }
    }
  
    // Out of memory
    return UINTPTR_MAX;
  }
  
  void ZMemoryManager::free(uintptr_t start, size_t size) {
    assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
    const uintptr_t end = start + size;
  
    ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
<span class="line-new-header">--- 24,161 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zList.inline.hpp&quot;
  #include &quot;gc/z/zMemory.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  
<span class="line-added">+ ZMemory* ZMemoryManager::create(uintptr_t start, size_t size) {</span>
<span class="line-added">+   ZMemory* const area = new ZMemory(start, size);</span>
<span class="line-added">+   if (_callbacks._create != NULL) {</span>
<span class="line-added">+     _callbacks._create(area);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return area;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::destroy(ZMemory* area) {</span>
<span class="line-added">+   if (_callbacks._destroy != NULL) {</span>
<span class="line-added">+     _callbacks._destroy(area);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   delete area;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::shrink_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added">+   if (_callbacks._shrink_from_front != NULL) {</span>
<span class="line-added">+     _callbacks._shrink_from_front(area, size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   area-&gt;shrink_from_front(size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::shrink_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added">+   if (_callbacks._shrink_from_back != NULL) {</span>
<span class="line-added">+     _callbacks._shrink_from_back(area, size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   area-&gt;shrink_from_back(size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::grow_from_front(ZMemory* area, size_t size) {</span>
<span class="line-added">+   if (_callbacks._grow_from_front != NULL) {</span>
<span class="line-added">+     _callbacks._grow_from_front(area, size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   area-&gt;grow_from_front(size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::grow_from_back(ZMemory* area, size_t size) {</span>
<span class="line-added">+   if (_callbacks._grow_from_back != NULL) {</span>
<span class="line-added">+     _callbacks._grow_from_back(area, size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   area-&gt;grow_from_back(size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ZMemoryManager::Callbacks::Callbacks() :</span>
<span class="line-added">+     _create(NULL),</span>
<span class="line-added">+     _destroy(NULL),</span>
<span class="line-added">+     _shrink_from_front(NULL),</span>
<span class="line-added">+     _shrink_from_back(NULL),</span>
<span class="line-added">+     _grow_from_front(NULL),</span>
<span class="line-added">+     _grow_from_back(NULL) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ ZMemoryManager::ZMemoryManager() :</span>
<span class="line-added">+     _freelist(),</span>
<span class="line-added">+     _callbacks() {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZMemoryManager::register_callbacks(const Callbacks&amp; callbacks) {</span>
<span class="line-added">+   _callbacks = callbacks;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
    ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
    for (ZMemory* area; iter.next(&amp;area);) {
      if (area-&gt;size() &gt;= size) {
        if (area-&gt;size() == size) {
          // Exact match, remove area
          const uintptr_t start = area-&gt;start();
          _freelist.remove(area);
<span class="line-modified">!         destroy(area);</span>
          return start;
        } else {
          // Larger than requested, shrink area
          const uintptr_t start = area-&gt;start();
<span class="line-modified">!         shrink_from_front(area, size);</span>
          return start;
        }
      }
    }
  
    // Out of memory
    return UINTPTR_MAX;
  }
  
<span class="line-added">+ uintptr_t ZMemoryManager::alloc_from_front_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">+   ZMemory* area = _freelist.first();</span>
<span class="line-added">+   if (area != NULL) {</span>
<span class="line-added">+     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">+       // Smaller than or equal to requested, remove area</span>
<span class="line-added">+       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">+       *allocated = area-&gt;size();</span>
<span class="line-added">+       _freelist.remove(area);</span>
<span class="line-added">+       destroy(area);</span>
<span class="line-added">+       return start;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Larger than requested, shrink area</span>
<span class="line-added">+       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">+       shrink_from_front(area, size);</span>
<span class="line-added">+       *allocated = size;</span>
<span class="line-added">+       return start;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Out of memory</span>
<span class="line-added">+   *allocated = 0;</span>
<span class="line-added">+   return UINTPTR_MAX;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
    ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
    for (ZMemory* area; iter.next(&amp;area);) {
      if (area-&gt;size() &gt;= size) {
        if (area-&gt;size() == size) {
          // Exact match, remove area
          const uintptr_t start = area-&gt;start();
          _freelist.remove(area);
<span class="line-modified">!         destroy(area);</span>
          return start;
        } else {
          // Larger than requested, shrink area
<span class="line-modified">!         shrink_from_back(area, size);</span>
          return area-&gt;end();
        }
      }
    }
  
    // Out of memory
    return UINTPTR_MAX;
  }
  
<span class="line-added">+ uintptr_t ZMemoryManager::alloc_from_back_at_most(size_t size, size_t* allocated) {</span>
<span class="line-added">+   ZMemory* area = _freelist.last();</span>
<span class="line-added">+   if (area != NULL) {</span>
<span class="line-added">+     if (area-&gt;size() &lt;= size) {</span>
<span class="line-added">+       // Smaller than or equal to requested, remove area</span>
<span class="line-added">+       const uintptr_t start = area-&gt;start();</span>
<span class="line-added">+       *allocated = area-&gt;size();</span>
<span class="line-added">+       _freelist.remove(area);</span>
<span class="line-added">+       destroy(area);</span>
<span class="line-added">+       return start;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Larger than requested, shrink area</span>
<span class="line-added">+       shrink_from_back(area, size);</span>
<span class="line-added">+       *allocated = size;</span>
<span class="line-added">+       return area-&gt;end();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Out of memory</span>
<span class="line-added">+   *allocated = 0;</span>
<span class="line-added">+   return UINTPTR_MAX;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ZMemoryManager::free(uintptr_t start, size_t size) {
    assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
    const uintptr_t end = start + size;
  
    ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,24 ***</span>
      if (start &lt; area-&gt;start()) {
        ZMemory* const prev = _freelist.prev(area);
        if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
          if (end == area-&gt;start()) {
            // Merge with prev and current area
<span class="line-modified">!           prev-&gt;grow_from_back(size + area-&gt;size());</span>
            _freelist.remove(area);
            delete area;
          } else {
            // Merge with prev area
<span class="line-modified">!           prev-&gt;grow_from_back(size);</span>
          }
        } else if (end == area-&gt;start()) {
          // Merge with current area
<span class="line-modified">!         area-&gt;grow_from_front(size);</span>
        } else {
          // Insert new area before current area
          assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<span class="line-modified">!         ZMemory* new_area = new ZMemory(start, size);</span>
          _freelist.insert_before(area, new_area);
        }
  
        // Done
        return;
<span class="line-new-header">--- 186,24 ---</span>
      if (start &lt; area-&gt;start()) {
        ZMemory* const prev = _freelist.prev(area);
        if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
          if (end == area-&gt;start()) {
            // Merge with prev and current area
<span class="line-modified">!           grow_from_back(prev, size + area-&gt;size());</span>
            _freelist.remove(area);
            delete area;
          } else {
            // Merge with prev area
<span class="line-modified">!           grow_from_back(prev, size);</span>
          }
        } else if (end == area-&gt;start()) {
          // Merge with current area
<span class="line-modified">!         grow_from_front(area, size);</span>
        } else {
          // Insert new area before current area
          assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<span class="line-modified">!         ZMemory* const new_area = create(start, size);</span>
          _freelist.insert_before(area, new_area);
        }
  
        // Done
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,12 ***</span>
  
    // Insert last
    ZMemory* const last = _freelist.last();
    if (last != NULL &amp;&amp; start == last-&gt;end()) {
      // Merge with last area
<span class="line-modified">!     last-&gt;grow_from_back(size);</span>
    } else {
      // Insert new area last
<span class="line-modified">!     ZMemory* new_area = new ZMemory(start, size);</span>
      _freelist.insert_last(new_area);
    }
  }
<span class="line-new-header">--- 212,12 ---</span>
  
    // Insert last
    ZMemory* const last = _freelist.last();
    if (last != NULL &amp;&amp; start == last-&gt;end()) {
      // Merge with last area
<span class="line-modified">!     grow_from_back(last, size);</span>
    } else {
      // Insert new area last
<span class="line-modified">!     ZMemory* const new_area = create(start, size);</span>
      _freelist.insert_last(new_area);
    }
  }
</pre>
<center><a href="zMarkTerminate.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMemory.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
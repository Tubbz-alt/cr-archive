<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/c2/zBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a>







  25 #include &quot;opto/compile.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed">  26 #include &quot;opto/castnode.hpp&quot;</span>
<span class="line-removed">  27 #include &quot;opto/escape.hpp&quot;</span>
  28 #include &quot;opto/graphKit.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  29 #include &quot;opto/idealKit.hpp&quot;</span>
<span class="line-removed">  30 #include &quot;opto/loopnode.hpp&quot;</span>
  31 #include &quot;opto/macro.hpp&quot;
<a name="4" id="anc4"></a>
  32 #include &quot;opto/node.hpp&quot;
<a name="5" id="anc5"></a>

  33 #include &quot;opto/type.hpp&quot;
<a name="6" id="anc6"></a>
  34 #include &quot;utilities/macros.hpp&quot;
<a name="7" id="anc7"></a><span class="line-removed">  35 #include &quot;gc/z/zBarrierSet.hpp&quot;</span>
<span class="line-removed">  36 #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="line-removed">  37 #include &quot;gc/z/zThreadLocalData.hpp&quot;</span>
<span class="line-removed">  38 #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;</span>
  39 
<a name="8" id="anc8"></a><span class="line-modified">  40 ZBarrierSetC2State::ZBarrierSetC2State(Arena* comp_arena) :</span>
<span class="line-modified">  41     _load_barrier_nodes(new (comp_arena) GrowableArray&lt;LoadBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {}</span>


  42 
<a name="9" id="anc9"></a><span class="line-modified">  43 int ZBarrierSetC2State::load_barrier_count() const {</span>
<span class="line-modified">  44   return _load_barrier_nodes-&gt;length();</span>
<span class="line-modified">  45 }</span>
<span class="line-modified">  46 </span>
<span class="line-removed">  47 void ZBarrierSetC2State::add_load_barrier_node(LoadBarrierNode * n) {</span>
<span class="line-removed">  48   assert(!_load_barrier_nodes-&gt;contains(n), &quot; duplicate entry in expand list&quot;);</span>
<span class="line-removed">  49   _load_barrier_nodes-&gt;append(n);</span>
<span class="line-removed">  50 }</span>
  51 
<a name="10" id="anc10"></a><span class="line-modified">  52 void ZBarrierSetC2State::remove_load_barrier_node(LoadBarrierNode * n) {</span>
<span class="line-modified">  53   // this function may be called twice for a node so check</span>
<span class="line-removed">  54   // that the node is in the array before attempting to remove it</span>
<span class="line-removed">  55   if (_load_barrier_nodes-&gt;contains(n)) {</span>
<span class="line-removed">  56     _load_barrier_nodes-&gt;remove(n);</span>
  57   }
<a name="11" id="anc11"></a><span class="line-removed">  58 }</span>
<span class="line-removed">  59 </span>
<span class="line-removed">  60 LoadBarrierNode* ZBarrierSetC2State::load_barrier_node(int idx) const {</span>
<span class="line-removed">  61   return _load_barrier_nodes-&gt;at(idx);</span>
<span class="line-removed">  62 }</span>
  63 
<a name="12" id="anc12"></a><span class="line-modified">  64 void* ZBarrierSetC2::create_barrier_state(Arena* comp_arena) const {</span>
<span class="line-modified">  65   return new(comp_arena) ZBarrierSetC2State(comp_arena);</span>
<span class="line-modified">  66 }</span>
<span class="line-modified">  67 </span>
<span class="line-removed">  68 ZBarrierSetC2State* ZBarrierSetC2::state() const {</span>
<span class="line-removed">  69   return reinterpret_cast&lt;ZBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());</span>
<span class="line-removed">  70 }</span>
<span class="line-removed">  71 </span>
<span class="line-removed">  72 bool ZBarrierSetC2::is_gc_barrier_node(Node* node) const {</span>
<span class="line-removed">  73   // 1. This step follows potential oop projections of a load barrier before expansion</span>
<span class="line-removed">  74   if (node-&gt;is_Proj()) {</span>
<span class="line-removed">  75     node = node-&gt;in(0);</span>
<span class="line-removed">  76   }</span>
<span class="line-removed">  77 </span>
<span class="line-removed">  78   // 2. This step checks for unexpanded load barriers</span>
<span class="line-removed">  79   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">  80     return true;</span>
<span class="line-removed">  81   }</span>
<span class="line-removed">  82 </span>
<span class="line-removed">  83   // 3. This step checks for the phi corresponding to an optimized load barrier expansion</span>
<span class="line-removed">  84   if (node-&gt;is_Phi()) {</span>
<span class="line-removed">  85     PhiNode* phi = node-&gt;as_Phi();</span>
<span class="line-removed">  86     Node* n = phi-&gt;in(1);</span>
<span class="line-removed">  87     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {</span>
<span class="line-removed">  88       return true;</span>
  89     }
<a name="13" id="anc13"></a><span class="line-removed">  90   }</span>
<span class="line-removed">  91 </span>
<span class="line-removed">  92   return false;</span>
<span class="line-removed">  93 }</span>
<span class="line-removed">  94 </span>
<span class="line-removed">  95 void ZBarrierSetC2::register_potential_barrier_node(Node* node) const {</span>
<span class="line-removed">  96   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">  97     state()-&gt;add_load_barrier_node(node-&gt;as_LoadBarrier());</span>
<span class="line-removed">  98   }</span>
<span class="line-removed">  99 }</span>
 100 
<a name="14" id="anc14"></a><span class="line-modified"> 101 void ZBarrierSetC2::unregister_potential_barrier_node(Node* node) const {</span>
<span class="line-modified"> 102   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-modified"> 103     state()-&gt;remove_load_barrier_node(node-&gt;as_LoadBarrier());</span>
<span class="line-modified"> 104   }</span>
<span class="line-modified"> 105 }</span>

 106 
<a name="15" id="anc15"></a><span class="line-modified"> 107 void ZBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {</span>
<span class="line-modified"> 108   // Remove useless LoadBarrier nodes</span>
<span class="line-modified"> 109   ZBarrierSetC2State* s = state();</span>
<span class="line-modified"> 110   for (int i = s-&gt;load_barrier_count()-1; i &gt;= 0; i--) {</span>
<span class="line-removed"> 111     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed"> 112     if (!useful.member(n)) {</span>
<span class="line-removed"> 113       unregister_potential_barrier_node(n);</span>
 114     }
<a name="16" id="anc16"></a><span class="line-removed"> 115   }</span>
<span class="line-removed"> 116 }</span>
 117 
<a name="17" id="anc17"></a><span class="line-modified"> 118 void ZBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {</span>
<span class="line-removed"> 119   if (node-&gt;is_LoadBarrier() &amp;&amp; !node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed"> 120     igvn-&gt;_worklist.push(node);</span>
 121   }
<a name="18" id="anc18"></a><span class="line-modified"> 122 }</span>
 123 
<a name="19" id="anc19"></a><span class="line-modified"> 124 void ZBarrierSetC2::find_dominating_barriers(PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified"> 125   // Look for dominating barriers on the same address only once all</span>
<span class="line-removed"> 126   // other loop opts are over. Loop opts may cause a safepoint to be</span>
<span class="line-removed"> 127   // inserted between a barrier and its dominating barrier.</span>
<span class="line-removed"> 128   Compile* C = Compile::current();</span>
<span class="line-removed"> 129   ZBarrierSetC2* bs = (ZBarrierSetC2*)BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed"> 130   ZBarrierSetC2State* s = bs-&gt;state();</span>
<span class="line-removed"> 131   if (s-&gt;load_barrier_count() &gt;= 2) {</span>
<span class="line-removed"> 132     Compile::TracePhase tp(&quot;idealLoop&quot;, &amp;C-&gt;timers[Phase::_t_idealLoop]);</span>
<span class="line-removed"> 133     PhaseIdealLoop::optimize(igvn, LoopOptsLastRound);</span>
<span class="line-removed"> 134     if (C-&gt;major_progress()) C-&gt;print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);</span>
<span class="line-removed"> 135   }</span>
 136 }
 137 
<a name="20" id="anc20"></a><span class="line-modified"> 138 void ZBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {</span>
<span class="line-modified"> 139   // Permanent temporary workaround</span>
<span class="line-modified"> 140   // Loadbarriers may have non-obvious dead uses keeping them alive during parsing. The use is</span>
<span class="line-modified"> 141   // removed by RemoveUseless (after parsing, before optimize) but the barriers won&#39;t be added to</span>
<span class="line-removed"> 142   // the worklist. Unless we add them explicitly they are not guaranteed to end up there.</span>
<span class="line-removed"> 143   ZBarrierSetC2State* s = state();</span>
<span class="line-removed"> 144 </span>
<span class="line-removed"> 145   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {</span>
<span class="line-removed"> 146     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed"> 147     worklist-&gt;push(n);</span>
 148   }
<a name="21" id="anc21"></a><span class="line-removed"> 149 }</span>
<span class="line-removed"> 150 </span>
<span class="line-removed"> 151 const TypeFunc* ZBarrierSetC2::load_barrier_Type() const {</span>
<span class="line-removed"> 152   const Type** fields;</span>
 153 
<a name="22" id="anc22"></a><span class="line-modified"> 154   // Create input types (domain)</span>
<span class="line-removed"> 155   fields = TypeTuple::fields(2);</span>
<span class="line-removed"> 156   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;</span>
<span class="line-removed"> 157   fields[TypeFunc::Parms+1] = TypeOopPtr::BOTTOM;</span>
<span class="line-removed"> 158   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);</span>
<span class="line-removed"> 159 </span>
<span class="line-removed"> 160   // Create result type (range)</span>
<span class="line-removed"> 161   fields = TypeTuple::fields(1);</span>
<span class="line-removed"> 162   fields[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM;</span>
<span class="line-removed"> 163   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);</span>
<span class="line-removed"> 164 </span>
<span class="line-removed"> 165   return TypeFunc::make(domain, range);</span>
 166 }
 167 
<a name="23" id="anc23"></a><span class="line-modified"> 168 // == LoadBarrierNode ==</span>
<span class="line-modified"> 169 </span>
<span class="line-modified"> 170 LoadBarrierNode::LoadBarrierNode(Compile* C,</span>
<span class="line-modified"> 171                                  Node* c,</span>
<span class="line-modified"> 172                                  Node* mem,</span>
<span class="line-removed"> 173                                  Node* val,</span>
<span class="line-removed"> 174                                  Node* adr,</span>
<span class="line-removed"> 175                                  bool weak,</span>
<span class="line-removed"> 176                                  bool writeback,</span>
<span class="line-removed"> 177                                  bool oop_reload_allowed) :</span>
<span class="line-removed"> 178     MultiNode(Number_of_Inputs),</span>
 179     _weak(weak),
<a name="24" id="anc24"></a><span class="line-modified"> 180     _writeback(writeback),</span>
<span class="line-modified"> 181     _oop_reload_allowed(oop_reload_allowed) {</span>
<span class="line-modified"> 182   init_req(Control, c);</span>
<span class="line-modified"> 183   init_req(Memory, mem);</span>
<span class="line-removed"> 184   init_req(Oop, val);</span>
<span class="line-removed"> 185   init_req(Address, adr);</span>
<span class="line-removed"> 186   init_req(Similar, C-&gt;top());</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188   init_class_id(Class_LoadBarrier);</span>
<span class="line-removed"> 189   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed"> 190   bs-&gt;register_potential_barrier_node(this);</span>
 191 }
 192 
<a name="25" id="anc25"></a><span class="line-modified"> 193 uint LoadBarrierNode::size_of() const {</span>
<span class="line-modified"> 194   return sizeof(*this);</span>
 195 }
 196 
<a name="26" id="anc26"></a><span class="line-modified"> 197 uint LoadBarrierNode::cmp(const Node&amp; n) const {</span>
<span class="line-modified"> 198   ShouldNotReachHere();</span>
<span class="line-removed"> 199   return 0;</span>
 200 }
 201 
<a name="27" id="anc27"></a><span class="line-modified"> 202 const Type *LoadBarrierNode::bottom_type() const {</span>
<span class="line-modified"> 203   const Type** floadbarrier = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));</span>
<span class="line-removed"> 204   Node* in_oop = in(Oop);</span>
<span class="line-removed"> 205   floadbarrier[Control] = Type::CONTROL;</span>
<span class="line-removed"> 206   floadbarrier[Memory] = Type::MEMORY;</span>
<span class="line-removed"> 207   floadbarrier[Oop] = in_oop == NULL ? Type::TOP : in_oop-&gt;bottom_type();</span>
<span class="line-removed"> 208   return TypeTuple::make(Number_of_Outputs, floadbarrier);</span>
 209 }
 210 
<a name="28" id="anc28"></a><span class="line-modified"> 211 const TypePtr* LoadBarrierNode::adr_type() const {</span>
<span class="line-modified"> 212   ShouldNotReachHere();</span>
<span class="line-modified"> 213   return NULL;</span>
 214 }
 215 
<a name="29" id="anc29"></a><span class="line-modified"> 216 const Type *LoadBarrierNode::Value(PhaseGVN *phase) const {</span>
<span class="line-modified"> 217   const Type** floadbarrier = (const Type **)(phase-&gt;C-&gt;type_arena()-&gt;Amalloc_4((Number_of_Outputs)*sizeof(Type*)));</span>
<span class="line-removed"> 218   const Type* val_t = phase-&gt;type(in(Oop));</span>
<span class="line-removed"> 219   floadbarrier[Control] = Type::CONTROL;</span>
<span class="line-removed"> 220   floadbarrier[Memory] = Type::MEMORY;</span>
<span class="line-removed"> 221   floadbarrier[Oop] = val_t;</span>
<span class="line-removed"> 222   return TypeTuple::make(Number_of_Outputs, floadbarrier);</span>
 223 }
 224 
<a name="30" id="anc30"></a><span class="line-modified"> 225 bool LoadBarrierNode::is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n) {</span>
<span class="line-modified"> 226   if (phase != NULL) {</span>
<span class="line-modified"> 227     return phase-&gt;is_dominator(d, n);</span>
<span class="line-modified"> 228   }</span>
<span class="line-modified"> 229 </span>
<span class="line-modified"> 230   for (int i = 0; i &lt; 10 &amp;&amp; n != NULL; i++) {</span>
<span class="line-removed"> 231     n = IfNode::up_one_dom(n, linear_only);</span>
<span class="line-removed"> 232     if (n == d) {</span>
<span class="line-removed"> 233       return true;</span>
<span class="line-removed"> 234     }</span>
<span class="line-removed"> 235   }</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237   return false;</span>
 238 }
 239 
<a name="31" id="anc31"></a><span class="line-modified"> 240 LoadBarrierNode* LoadBarrierNode::has_dominating_barrier(PhaseIdealLoop* phase, bool linear_only, bool look_for_similar) {</span>
<span class="line-modified"> 241   Node* val = in(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 242   if (in(Similar)-&gt;is_Proj() &amp;&amp; in(Similar)-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed"> 243     LoadBarrierNode* lb = in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-removed"> 244     assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);</span>
<span class="line-removed"> 245     // Load barrier on Similar edge dominates so if it now has the Oop field it can replace this barrier.</span>
<span class="line-removed"> 246     if (lb-&gt;in(Oop) == in(Oop)) {</span>
<span class="line-removed"> 247       return lb;</span>
<span class="line-removed"> 248     }</span>
<span class="line-removed"> 249     // Follow chain of load barrier through Similar edges</span>
<span class="line-removed"> 250     while (!lb-&gt;in(Similar)-&gt;is_top()) {</span>
<span class="line-removed"> 251       lb = lb-&gt;in(Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-removed"> 252       assert(lb-&gt;in(Address) == in(Address), &quot;&quot;);</span>
<span class="line-removed"> 253     }</span>
<span class="line-removed"> 254     if (lb != in(Similar)-&gt;in(0)) {</span>
<span class="line-removed"> 255       return lb;</span>
<span class="line-removed"> 256     }</span>
<span class="line-removed"> 257   }</span>
<span class="line-removed"> 258   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 259     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed"> 260     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed"> 261       Node* this_ctrl = in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 262       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 263       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {</span>
<span class="line-removed"> 264         return u-&gt;as_LoadBarrier();</span>
<span class="line-removed"> 265       }</span>
<span class="line-removed"> 266     }</span>
<span class="line-removed"> 267   }</span>
<span class="line-removed"> 268 </span>
<span class="line-removed"> 269   if (ZVerifyLoadBarriers || can_be_eliminated()) {</span>
<span class="line-removed"> 270     return NULL;</span>
<span class="line-removed"> 271   }</span>
<span class="line-removed"> 272 </span>
<span class="line-removed"> 273   if (!look_for_similar) {</span>
<span class="line-removed"> 274     return NULL;</span>
<span class="line-removed"> 275   }</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277   Node* addr = in(LoadBarrierNode::Address);</span>
<span class="line-removed"> 278   for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 279     Node* u = addr-&gt;fast_out(i);</span>
<span class="line-removed"> 280     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed"> 281       Node* this_ctrl = in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 282       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 283       if (is_dominator(phase, linear_only, other_ctrl, this_ctrl)) {</span>
<span class="line-removed"> 284         ResourceMark rm;</span>
<span class="line-removed"> 285         Unique_Node_List wq;</span>
<span class="line-removed"> 286         wq.push(in(LoadBarrierNode::Control));</span>
<span class="line-removed"> 287         bool ok = true;</span>
<span class="line-removed"> 288         bool dom_found = false;</span>
<span class="line-removed"> 289         for (uint next = 0; next &lt; wq.size(); ++next) {</span>
<span class="line-removed"> 290           Node *n = wq.at(next);</span>
<span class="line-removed"> 291           if (n-&gt;is_top()) {</span>
<span class="line-removed"> 292             return NULL;</span>
<span class="line-removed"> 293           }</span>
<span class="line-removed"> 294           assert(n-&gt;is_CFG(), &quot;&quot;);</span>
<span class="line-removed"> 295           if (n-&gt;is_SafePoint()) {</span>
<span class="line-removed"> 296             ok = false;</span>
<span class="line-removed"> 297             break;</span>
<span class="line-removed"> 298           }</span>
<span class="line-removed"> 299           if (n == u) {</span>
<span class="line-removed"> 300             dom_found = true;</span>
<span class="line-removed"> 301             continue;</span>
<span class="line-removed"> 302           }</span>
<span class="line-removed"> 303           if (n-&gt;is_Region()) {</span>
<span class="line-removed"> 304             for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed"> 305               Node* m = n-&gt;in(i);</span>
<span class="line-removed"> 306               if (m != NULL) {</span>
<span class="line-removed"> 307                 wq.push(m);</span>
<span class="line-removed"> 308               }</span>
<span class="line-removed"> 309             }</span>
<span class="line-removed"> 310           } else {</span>
<span class="line-removed"> 311             Node* m = n-&gt;in(0);</span>
<span class="line-removed"> 312             if (m != NULL) {</span>
<span class="line-removed"> 313               wq.push(m);</span>
<span class="line-removed"> 314             }</span>
<span class="line-removed"> 315           }</span>
<span class="line-removed"> 316         }</span>
<span class="line-removed"> 317         if (ok) {</span>
<span class="line-removed"> 318           assert(dom_found, &quot;&quot;);</span>
<span class="line-removed"> 319           return u-&gt;as_LoadBarrier();;</span>
<span class="line-removed"> 320         }</span>
<span class="line-removed"> 321         break;</span>
<span class="line-removed"> 322       }</span>
<span class="line-removed"> 323     }</span>
<span class="line-removed"> 324   }</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326   return NULL;</span>
 327 }
 328 
<a name="32" id="anc32"></a><span class="line-modified"> 329 void LoadBarrierNode::push_dominated_barriers(PhaseIterGVN* igvn) const {</span>
<span class="line-modified"> 330   // Change to that barrier may affect a dominated barrier so re-push those</span>
<span class="line-removed"> 331   Node* val = in(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 334     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed"> 335     if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Oop) == val) {</span>
<span class="line-removed"> 336       Node* this_ctrl = in(Control);</span>
<span class="line-removed"> 337       Node* other_ctrl = u-&gt;in(Control);</span>
<span class="line-removed"> 338       if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {</span>
<span class="line-removed"> 339         igvn-&gt;_worklist.push(u);</span>
<span class="line-removed"> 340       }</span>
<span class="line-removed"> 341     }</span>
<span class="line-removed"> 342 </span>
<span class="line-removed"> 343     Node* addr = in(LoadBarrierNode::Address);</span>
<span class="line-removed"> 344     for (DUIterator_Fast imax, i = addr-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 345       Node* u = addr-&gt;fast_out(i);</span>
<span class="line-removed"> 346       if (u != this &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar)-&gt;is_top()) {</span>
<span class="line-removed"> 347         Node* this_ctrl = in(Control);</span>
<span class="line-removed"> 348         Node* other_ctrl = u-&gt;in(Control);</span>
<span class="line-removed"> 349         if (is_dominator(NULL, false, this_ctrl, other_ctrl)) {</span>
<span class="line-removed"> 350           igvn-&gt;_worklist.push(u);</span>
<span class="line-removed"> 351         }</span>
<span class="line-removed"> 352       }</span>
<span class="line-removed"> 353     }</span>
<span class="line-removed"> 354   }</span>
 355 }
 356 
<a name="33" id="anc33"></a><span class="line-modified"> 357 Node *LoadBarrierNode::Identity(PhaseGVN *phase) {</span>
<span class="line-modified"> 358   if (!phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {</span>
<span class="line-modified"> 359     return this;</span>
<span class="line-removed"> 360   }</span>
<span class="line-removed"> 361 </span>
<span class="line-removed"> 362   bool redundant_addr = false;</span>
<span class="line-removed"> 363   LoadBarrierNode* dominating_barrier = has_dominating_barrier(NULL, true, false);</span>
<span class="line-removed"> 364   if (dominating_barrier != NULL) {</span>
<span class="line-removed"> 365     assert(dominating_barrier-&gt;in(Oop) == in(Oop), &quot;&quot;);</span>
<span class="line-removed"> 366     return dominating_barrier;</span>
<span class="line-removed"> 367   }</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369   return this;</span>
 370 }
 371 
<a name="34" id="anc34"></a><span class="line-modified"> 372 Node *LoadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-modified"> 373   if (remove_dead_region(phase, can_reshape)) {</span>
<span class="line-modified"> 374     return this;</span>
<span class="line-removed"> 375   }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377   Node* val = in(Oop);</span>
<span class="line-removed"> 378   Node* mem = in(Memory);</span>
<span class="line-removed"> 379   Node* ctrl = in(Control);</span>
<span class="line-removed"> 380   Node* adr = in(Address);</span>
<span class="line-removed"> 381   assert(val-&gt;Opcode() != Op_LoadN, &quot;&quot;);</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383   if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 384     Node* new_mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);</span>
<span class="line-removed"> 385     set_req(Memory, new_mem);</span>
<span class="line-removed"> 386     if (mem-&gt;outcnt() == 0 &amp;&amp; can_reshape) {</span>
<span class="line-removed"> 387       phase-&gt;is_IterGVN()-&gt;_worklist.push(mem);</span>
<span class="line-removed"> 388     }</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390     return this;</span>
<span class="line-removed"> 391   }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393   bool optimizeLoadBarriers = phase-&gt;C-&gt;directive()-&gt;ZOptimizeLoadBarriersOption;</span>
<span class="line-removed"> 394   LoadBarrierNode* dominating_barrier = optimizeLoadBarriers ? has_dominating_barrier(NULL, !can_reshape, !phase-&gt;C-&gt;major_progress()) : NULL;</span>
<span class="line-removed"> 395   if (dominating_barrier != NULL &amp;&amp; dominating_barrier-&gt;in(Oop) != in(Oop)) {</span>
<span class="line-removed"> 396     assert(in(Address) == dominating_barrier-&gt;in(Address), &quot;&quot;);</span>
<span class="line-removed"> 397     set_req(Similar, dominating_barrier-&gt;proj_out(Oop));</span>
<span class="line-removed"> 398     return this;</span>
<span class="line-removed"> 399   }</span>
 400 
<a name="35" id="anc35"></a><span class="line-modified"> 401   bool eliminate = (optimizeLoadBarriers &amp;&amp; !(val-&gt;is_Phi() || val-&gt;Opcode() == Op_LoadP || val-&gt;Opcode() == Op_GetAndSetP || val-&gt;is_DecodeN())) ||</span>
<span class="line-modified"> 402                    (can_reshape &amp;&amp; (dominating_barrier != NULL || !has_true_uses()));</span>
<span class="line-modified"> 403 </span>
<span class="line-modified"> 404   if (eliminate) {</span>
<span class="line-modified"> 405     if (can_reshape) {</span>
<span class="line-removed"> 406       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 407       Node* out_ctrl = proj_out_or_null(Control);</span>
<span class="line-removed"> 408       Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed"> 409 </span>
<span class="line-removed"> 410       if (out_ctrl != NULL) {</span>
<span class="line-removed"> 411         igvn-&gt;replace_node(out_ctrl, ctrl);</span>
<span class="line-removed"> 412       }</span>
<span class="line-removed"> 413 </span>
<span class="line-removed"> 414       // That transformation may cause the Similar edge on the load barrier to be invalid</span>
<span class="line-removed"> 415       fix_similar_in_uses(igvn);</span>
<span class="line-removed"> 416       if (out_res != NULL) {</span>
<span class="line-removed"> 417         if (dominating_barrier != NULL) {</span>
<span class="line-removed"> 418           igvn-&gt;replace_node(out_res, dominating_barrier-&gt;proj_out(Oop));</span>
<span class="line-removed"> 419         } else {</span>
<span class="line-removed"> 420           igvn-&gt;replace_node(out_res, val);</span>
<span class="line-removed"> 421         }</span>
<span class="line-removed"> 422       }</span>
<span class="line-removed"> 423     }</span>
<span class="line-removed"> 424 </span>
<span class="line-removed"> 425     return new ConINode(TypeInt::ZERO);</span>
<span class="line-removed"> 426   }</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428   // If the Similar edge is no longer a load barrier, clear it</span>
<span class="line-removed"> 429   Node* similar = in(Similar);</span>
<span class="line-removed"> 430   if (!similar-&gt;is_top() &amp;&amp; !(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier())) {</span>
<span class="line-removed"> 431     set_req(Similar, phase-&gt;C-&gt;top());</span>
<span class="line-removed"> 432     return this;</span>
<span class="line-removed"> 433   }</span>
<span class="line-removed"> 434 </span>
<span class="line-removed"> 435   if (can_reshape) {</span>
<span class="line-removed"> 436     // If this barrier is linked through the Similar edge by a</span>
<span class="line-removed"> 437     // dominated barrier and both barriers have the same Oop field,</span>
<span class="line-removed"> 438     // the dominated barrier can go away, so push it for reprocessing.</span>
<span class="line-removed"> 439     // We also want to avoid a barrier to depend on another dominating</span>
<span class="line-removed"> 440     // barrier through its Similar edge that itself depend on another</span>
<span class="line-removed"> 441     // barrier through its Similar edge and rather have the first</span>
<span class="line-removed"> 442     // depend on the third.</span>
<span class="line-removed"> 443     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 444     Node* out_res = proj_out(Oop);</span>
<span class="line-removed"> 445     for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 446       Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-removed"> 447       if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res &amp;&amp;</span>
<span class="line-removed"> 448           (u-&gt;in(Oop) == val || !u-&gt;in(Similar)-&gt;is_top())) {</span>
<span class="line-removed"> 449         igvn-&gt;_worklist.push(u);</span>
<span class="line-removed"> 450       }</span>
 451     }
 452 
<a name="36" id="anc36"></a><span class="line-modified"> 453     push_dominated_barriers(igvn);</span>
 454   }
 455 
<a name="37" id="anc37"></a><span class="line-modified"> 456   return NULL;</span>
 457 }
 458 
<a name="38" id="anc38"></a><span class="line-modified"> 459 uint LoadBarrierNode::match_edge(uint idx) const {</span>
<span class="line-modified"> 460   ShouldNotReachHere();</span>
<span class="line-modified"> 461   return 0;</span>
<span class="line-modified"> 462 }</span>
<span class="line-modified"> 463 </span>
<span class="line-removed"> 464 void LoadBarrierNode::fix_similar_in_uses(PhaseIterGVN* igvn) {</span>
<span class="line-removed"> 465   Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed"> 466   if (out_res == NULL) {</span>
<span class="line-removed"> 467     return;</span>
<span class="line-removed"> 468   }</span>
<span class="line-removed"> 469 </span>
<span class="line-removed"> 470   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 471     Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-removed"> 472     if (u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;in(Similar) == out_res) {</span>
<span class="line-removed"> 473       igvn-&gt;replace_input_of(u, Similar, igvn-&gt;C-&gt;top());</span>
<span class="line-removed"> 474       --i;</span>
<span class="line-removed"> 475       --imax;</span>
<span class="line-removed"> 476     }</span>
<span class="line-removed"> 477   }</span>
<span class="line-removed"> 478 }</span>
<span class="line-removed"> 479 </span>
<span class="line-removed"> 480 bool LoadBarrierNode::has_true_uses() const {</span>
<span class="line-removed"> 481   Node* out_res = proj_out_or_null(Oop);</span>
<span class="line-removed"> 482   if (out_res == NULL) {</span>
<span class="line-removed"> 483     return false;</span>
<span class="line-removed"> 484   }</span>
 485 
<a name="39" id="anc39"></a><span class="line-modified"> 486   for (DUIterator_Fast imax, i = out_res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified"> 487     Node* u = out_res-&gt;fast_out(i);</span>
<span class="line-modified"> 488     if (!u-&gt;is_LoadBarrier() || u-&gt;in(Similar) != out_res) {</span>
<span class="line-modified"> 489       return true;</span>
<span class="line-modified"> 490     }</span>
 491   }
 492 
<a name="40" id="anc40"></a><span class="line-modified"> 493   return false;</span>
<span class="line-removed"> 494 }</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496 // == Accesses ==</span>
<span class="line-removed"> 497 </span>
<span class="line-removed"> 498 Node* ZBarrierSetC2::make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const {</span>
<span class="line-removed"> 499   assert(!UseCompressedOops, &quot;Not allowed&quot;);</span>
<span class="line-removed"> 500   CompareAndSwapNode* cas = (CompareAndSwapNode*)access.raw_access();</span>
<span class="line-removed"> 501   PhaseGVN&amp; gvn = access.gvn();</span>
<span class="line-removed"> 502   Compile* C = Compile::current();</span>
<span class="line-removed"> 503   GraphKit* kit = access.kit();</span>
<span class="line-removed"> 504 </span>
<span class="line-removed"> 505   Node* in_ctrl     = cas-&gt;in(MemNode::Control);</span>
<span class="line-removed"> 506   Node* in_mem      = cas-&gt;in(MemNode::Memory);</span>
<span class="line-removed"> 507   Node* in_adr      = cas-&gt;in(MemNode::Address);</span>
<span class="line-removed"> 508   Node* in_val      = cas-&gt;in(MemNode::ValueIn);</span>
<span class="line-removed"> 509   Node* in_expected = cas-&gt;in(LoadStoreConditionalNode::ExpectedIn);</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511   float likely                   = PROB_LIKELY(0.999);</span>
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513   const TypePtr *adr_type        = gvn.type(in_adr)-&gt;isa_ptr();</span>
<span class="line-removed"> 514   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);</span>
<span class="line-removed"> 515   int alias_idx                  = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517   // Outer check - true: continue, false: load and check</span>
<span class="line-removed"> 518   Node* region   = new RegionNode(3);</span>
<span class="line-removed"> 519   Node* phi      = new PhiNode(region, TypeInt::BOOL);</span>
<span class="line-removed"> 520   Node* phi_mem  = new PhiNode(region, Type::MEMORY, adr_type);</span>
<span class="line-removed"> 521 </span>
<span class="line-removed"> 522   // Inner check - is the healed ref equal to the expected</span>
<span class="line-removed"> 523   Node* region2  = new RegionNode(3);</span>
<span class="line-removed"> 524   Node* phi2     = new PhiNode(region2, TypeInt::BOOL);</span>
<span class="line-removed"> 525   Node* phi_mem2 = new PhiNode(region2, Type::MEMORY, adr_type);</span>
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527   // CAS node returns 0 or 1</span>
<span class="line-removed"> 528   Node* cmp     = gvn.transform(new CmpINode(cas, kit-&gt;intcon(0)));</span>
<span class="line-removed"> 529   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed"> 530   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 531   Node* then    = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed"> 532   Node* elsen   = gvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534   Node* scmemproj1   = gvn.transform(new SCMemProjNode(cas));</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536   kit-&gt;set_memory(scmemproj1, alias_idx);</span>
<span class="line-removed"> 537   phi_mem-&gt;init_req(1, scmemproj1);</span>
<span class="line-removed"> 538   phi_mem2-&gt;init_req(2, scmemproj1);</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540   // CAS fail - reload and heal oop</span>
<span class="line-removed"> 541   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);</span>
<span class="line-removed"> 542   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));</span>
<span class="line-removed"> 543   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));</span>
<span class="line-removed"> 544   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed"> 545 </span>
<span class="line-removed"> 546   // Check load</span>
<span class="line-removed"> 547   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));</span>
<span class="line-removed"> 548   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));</span>
<span class="line-removed"> 549   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));</span>
<span class="line-removed"> 550   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed"> 551   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 552   Node* then2   = gvn.transform(new IfTrueNode(iff2));</span>
<span class="line-removed"> 553   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));</span>
<span class="line-removed"> 554 </span>
<span class="line-removed"> 555   // redo CAS</span>
<span class="line-removed"> 556   Node* cas2       = gvn.transform(new CompareAndSwapPNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, cas-&gt;order()));</span>
<span class="line-removed"> 557   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cas2));</span>
<span class="line-removed"> 558   kit-&gt;set_control(elsen2);</span>
<span class="line-removed"> 559   kit-&gt;set_memory(scmemproj2, alias_idx);</span>
<span class="line-removed"> 560 </span>
<span class="line-removed"> 561   // Merge inner flow - check if healed oop was equal too expected.</span>
<span class="line-removed"> 562   region2-&gt;set_req(1, kit-&gt;control());</span>
<span class="line-removed"> 563   region2-&gt;set_req(2, then2);</span>
<span class="line-removed"> 564   phi2-&gt;set_req(1, cas2);</span>
<span class="line-removed"> 565   phi2-&gt;set_req(2, kit-&gt;intcon(0));</span>
<span class="line-removed"> 566   phi_mem2-&gt;init_req(1, scmemproj2);</span>
<span class="line-removed"> 567   kit-&gt;set_memory(phi_mem2, alias_idx);</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569   // Merge outer flow - then check if first CAS succeeded</span>
<span class="line-removed"> 570   region-&gt;set_req(1, then);</span>
<span class="line-removed"> 571   region-&gt;set_req(2, region2);</span>
<span class="line-removed"> 572   phi-&gt;set_req(1, kit-&gt;intcon(1));</span>
<span class="line-removed"> 573   phi-&gt;set_req(2, phi2);</span>
<span class="line-removed"> 574   phi_mem-&gt;init_req(2, phi_mem2);</span>
<span class="line-removed"> 575   kit-&gt;set_memory(phi_mem, alias_idx);</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577   gvn.transform(region2);</span>
<span class="line-removed"> 578   gvn.transform(phi2);</span>
<span class="line-removed"> 579   gvn.transform(phi_mem2);</span>
<span class="line-removed"> 580   gvn.transform(region);</span>
<span class="line-removed"> 581   gvn.transform(phi);</span>
<span class="line-removed"> 582   gvn.transform(phi_mem);</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584   kit-&gt;set_control(region);</span>
<span class="line-removed"> 585   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-removed"> 586 </span>
<span class="line-removed"> 587   return phi;</span>
 588 }
 589 
<a name="41" id="anc41"></a><span class="line-modified"> 590 Node* ZBarrierSetC2::make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const {</span>
<span class="line-modified"> 591   CompareAndExchangePNode* cmpx = (CompareAndExchangePNode*)access.raw_access();</span>
<span class="line-modified"> 592   GraphKit* kit = access.kit();</span>
<span class="line-modified"> 593   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-modified"> 594   Compile* C = Compile::current();</span>
<span class="line-modified"> 595 </span>
<span class="line-removed"> 596   Node* in_ctrl     = cmpx-&gt;in(MemNode::Control);</span>
<span class="line-removed"> 597   Node* in_mem      = cmpx-&gt;in(MemNode::Memory);</span>
<span class="line-removed"> 598   Node* in_adr      = cmpx-&gt;in(MemNode::Address);</span>
<span class="line-removed"> 599   Node* in_val      = cmpx-&gt;in(MemNode::ValueIn);</span>
<span class="line-removed"> 600   Node* in_expected = cmpx-&gt;in(LoadStoreConditionalNode::ExpectedIn);</span>
<span class="line-removed"> 601 </span>
<span class="line-removed"> 602   float likely                   = PROB_LIKELY(0.999);</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604   const TypePtr *adr_type        = cmpx-&gt;get_ptr_type();</span>
<span class="line-removed"> 605   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);</span>
<span class="line-removed"> 606   int alias_idx                  = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608   // Outer check - true: continue, false: load and check</span>
<span class="line-removed"> 609   Node* region  = new RegionNode(3);</span>
<span class="line-removed"> 610   Node* phi     = new PhiNode(region, adr_type);</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612   // Inner check - is the healed ref equal to the expected</span>
<span class="line-removed"> 613   Node* region2 = new RegionNode(3);</span>
<span class="line-removed"> 614   Node* phi2    = new PhiNode(region2, adr_type);</span>
<span class="line-removed"> 615 </span>
<span class="line-removed"> 616   // Check if cmpx succeeded</span>
<span class="line-removed"> 617   Node* cmp     = gvn.transform(new CmpPNode(cmpx, in_expected));</span>
<span class="line-removed"> 618   Node* bol     = gvn.transform(new BoolNode(cmp, BoolTest::eq))-&gt;as_Bool();</span>
<span class="line-removed"> 619   IfNode* iff   = gvn.transform(new IfNode(in_ctrl, bol, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 620   Node* then    = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed"> 621   Node* elsen   = gvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed"> 622 </span>
<span class="line-removed"> 623   Node* scmemproj1  = gvn.transform(new SCMemProjNode(cmpx));</span>
<span class="line-removed"> 624   kit-&gt;set_memory(scmemproj1, alias_idx);</span>
<span class="line-removed"> 625 </span>
<span class="line-removed"> 626   // CAS fail - reload and heal oop</span>
<span class="line-removed"> 627   Node* reload      = kit-&gt;make_load(elsen, in_adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);</span>
<span class="line-removed"> 628   Node* barrier     = gvn.transform(new LoadBarrierNode(C, elsen, scmemproj1, reload, in_adr, false, true, false));</span>
<span class="line-removed"> 629   Node* barrierctrl = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control));</span>
<span class="line-removed"> 630   Node* barrierdata = gvn.transform(new ProjNode(barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632   // Check load</span>
<span class="line-removed"> 633   Node* tmpX    = gvn.transform(new CastP2XNode(NULL, barrierdata));</span>
<span class="line-removed"> 634   Node* in_expX = gvn.transform(new CastP2XNode(NULL, in_expected));</span>
<span class="line-removed"> 635   Node* cmp2    = gvn.transform(new CmpXNode(tmpX, in_expX));</span>
<span class="line-removed"> 636   Node *bol2    = gvn.transform(new BoolNode(cmp2, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed"> 637   IfNode* iff2  = gvn.transform(new IfNode(barrierctrl, bol2, likely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 638   Node* then2   = gvn.transform(new IfTrueNode(iff2));</span>
<span class="line-removed"> 639   Node* elsen2  = gvn.transform(new IfFalseNode(iff2));</span>
<span class="line-removed"> 640 </span>
<span class="line-removed"> 641   // Redo CAS</span>
<span class="line-removed"> 642   Node* cmpx2      = gvn.transform(new CompareAndExchangePNode(elsen2, kit-&gt;memory(alias_idx), in_adr, in_val, in_expected, adr_type, cmpx-&gt;get_ptr_type(), cmpx-&gt;order()));</span>
<span class="line-removed"> 643   Node* scmemproj2 = gvn.transform(new SCMemProjNode(cmpx2));</span>
<span class="line-removed"> 644   kit-&gt;set_control(elsen2);</span>
<span class="line-removed"> 645   kit-&gt;set_memory(scmemproj2, alias_idx);</span>
<span class="line-removed"> 646 </span>
<span class="line-removed"> 647   // Merge inner flow - check if healed oop was equal too expected.</span>
<span class="line-removed"> 648   region2-&gt;set_req(1, kit-&gt;control());</span>
<span class="line-removed"> 649   region2-&gt;set_req(2, then2);</span>
<span class="line-removed"> 650   phi2-&gt;set_req(1, cmpx2);</span>
<span class="line-removed"> 651   phi2-&gt;set_req(2, barrierdata);</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653   // Merge outer flow - then check if first cas succeeded</span>
<span class="line-removed"> 654   region-&gt;set_req(1, then);</span>
<span class="line-removed"> 655   region-&gt;set_req(2, region2);</span>
<span class="line-removed"> 656   phi-&gt;set_req(1, cmpx);</span>
<span class="line-removed"> 657   phi-&gt;set_req(2, phi2);</span>
<span class="line-removed"> 658 </span>
<span class="line-removed"> 659   gvn.transform(region2);</span>
<span class="line-removed"> 660   gvn.transform(phi2);</span>
<span class="line-removed"> 661   gvn.transform(region);</span>
<span class="line-removed"> 662   gvn.transform(phi);</span>
<span class="line-removed"> 663 </span>
<span class="line-removed"> 664   kit-&gt;set_control(region);</span>
<span class="line-removed"> 665   kit-&gt;set_memory(in_mem, alias_idx);</span>
<span class="line-removed"> 666   kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-removed"> 667 </span>
<span class="line-removed"> 668   return phi;</span>
<span class="line-removed"> 669 }</span>
<span class="line-removed"> 670 </span>
<span class="line-removed"> 671 Node* ZBarrierSetC2::load_barrier(GraphKit* kit, Node* val, Node* adr, bool weak, bool writeback, bool oop_reload_allowed) const {</span>
<span class="line-removed"> 672   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-removed"> 673   Node* barrier = new LoadBarrierNode(Compile::current(), kit-&gt;control(), kit-&gt;memory(TypeRawPtr::BOTTOM), val, adr, weak, writeback, oop_reload_allowed);</span>
<span class="line-removed"> 674   Node* transformed_barrier = gvn.transform(barrier);</span>
<span class="line-removed"> 675 </span>
<span class="line-removed"> 676   if (transformed_barrier-&gt;is_LoadBarrier()) {</span>
<span class="line-removed"> 677     if (barrier == transformed_barrier) {</span>
<span class="line-removed"> 678       kit-&gt;set_control(gvn.transform(new ProjNode(barrier, LoadBarrierNode::Control)));</span>
 679     }
<a name="42" id="anc42"></a><span class="line-removed"> 680     Node* result = gvn.transform(new ProjNode(transformed_barrier, LoadBarrierNode::Oop));</span>
<span class="line-removed"> 681     return result;</span>
<span class="line-removed"> 682   } else {</span>
<span class="line-removed"> 683     return val;</span>
 684   }
 685 }
 686 
<a name="43" id="anc43"></a><span class="line-removed"> 687 static bool barrier_needed(C2Access&amp; access) {</span>
<span class="line-removed"> 688   return ZBarrierSet::barrier_needed(access.decorators(), access.type());</span>
<span class="line-removed"> 689 }</span>
<span class="line-removed"> 690 </span>
 691 Node* ZBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<a name="44" id="anc44"></a><span class="line-modified"> 692   Node* p = BarrierSetC2::load_at_resolved(access, val_type);</span>
<span class="line-modified"> 693   if (!barrier_needed(access)) {</span>
<span class="line-removed"> 694     return p;</span>
<span class="line-removed"> 695   }</span>
<span class="line-removed"> 696 </span>
<span class="line-removed"> 697   bool weak = (access.decorators() &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-removed"> 698 </span>
<span class="line-removed"> 699   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-removed"> 700   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-removed"> 701   GraphKit* kit = parse_access.kit();</span>
<span class="line-removed"> 702   PhaseGVN&amp; gvn = kit-&gt;gvn();</span>
<span class="line-removed"> 703   Node* adr = access.addr().node();</span>
<span class="line-removed"> 704   Node* heap_base_oop = access.base();</span>
<span class="line-removed"> 705   bool unsafe = (access.decorators() &amp; C2_UNSAFE_ACCESS) != 0;</span>
<span class="line-removed"> 706   if (unsafe) {</span>
<span class="line-removed"> 707     if (!ZVerifyLoadBarriers) {</span>
<span class="line-removed"> 708       p = load_barrier(kit, p, adr);</span>
<span class="line-removed"> 709     } else {</span>
<span class="line-removed"> 710       if (!TypePtr::NULL_PTR-&gt;higher_equal(gvn.type(heap_base_oop))) {</span>
<span class="line-removed"> 711         p = load_barrier(kit, p, adr);</span>
<span class="line-removed"> 712       } else {</span>
<span class="line-removed"> 713         IdealKit ideal(kit);</span>
<span class="line-removed"> 714         IdealVariable res(ideal);</span>
<span class="line-removed"> 715 #define __ ideal.</span>
<span class="line-removed"> 716         __ declarations_done();</span>
<span class="line-removed"> 717         __ set(res, p);</span>
<span class="line-removed"> 718         __ if_then(heap_base_oop, BoolTest::ne, kit-&gt;null(), PROB_UNLIKELY(0.999)); {</span>
<span class="line-removed"> 719           kit-&gt;sync_kit(ideal);</span>
<span class="line-removed"> 720           p = load_barrier(kit, p, adr);</span>
<span class="line-removed"> 721           __ set(res, p);</span>
<span class="line-removed"> 722           __ sync_kit(kit);</span>
<span class="line-removed"> 723         } __ end_if();</span>
<span class="line-removed"> 724         kit-&gt;final_sync(ideal);</span>
<span class="line-removed"> 725         p = __ value(res);</span>
<span class="line-removed"> 726 #undef __</span>
<span class="line-removed"> 727       }</span>
<span class="line-removed"> 728     }</span>
<span class="line-removed"> 729     return p;</span>
<span class="line-removed"> 730   } else {</span>
<span class="line-removed"> 731     return load_barrier(parse_access.kit(), p, access.addr().node(), weak, true, true);</span>
<span class="line-removed"> 732   }</span>
 733 }
 734 
 735 Node* ZBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 736                                                     Node* new_val, const Type* val_type) const {
<a name="45" id="anc45"></a><span class="line-modified"> 737   Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, val_type);</span>
<span class="line-modified"> 738   if (!barrier_needed(access)) {</span>
<span class="line-removed"> 739     return result;</span>
<span class="line-removed"> 740   }</span>
<span class="line-removed"> 741 </span>
<span class="line-removed"> 742   access.set_needs_pinning(false);</span>
<span class="line-removed"> 743   return make_cmpx_loadbarrier(access);</span>
 744 }
 745 
 746 Node* ZBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 747                                                      Node* new_val, const Type* value_type) const {
<a name="46" id="anc46"></a><span class="line-modified"> 748   Node* result = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);</span>
<span class="line-modified"> 749   if (!barrier_needed(access)) {</span>
<span class="line-removed"> 750     return result;</span>
<span class="line-removed"> 751   }</span>
<span class="line-removed"> 752 </span>
<span class="line-removed"> 753   Node* load_store = access.raw_access();</span>
<span class="line-removed"> 754   bool weak_cas = (access.decorators() &amp; C2_WEAK_CMPXCHG) != 0;</span>
<span class="line-removed"> 755   bool expected_is_null = (expected_val-&gt;get_ptr_type() == TypePtr::NULL_PTR);</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757   if (!expected_is_null) {</span>
<span class="line-removed"> 758     if (weak_cas) {</span>
<span class="line-removed"> 759       access.set_needs_pinning(false);</span>
<span class="line-removed"> 760       load_store = make_cas_loadbarrier(access);</span>
<span class="line-removed"> 761     } else {</span>
<span class="line-removed"> 762       access.set_needs_pinning(false);</span>
<span class="line-removed"> 763       load_store = make_cas_loadbarrier(access);</span>
<span class="line-removed"> 764     }</span>
<span class="line-removed"> 765   }</span>
<span class="line-removed"> 766 </span>
<span class="line-removed"> 767   return load_store;</span>
 768 }
 769 
 770 Node* ZBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* new_val, const Type* val_type) const {
<a name="47" id="anc47"></a><span class="line-modified"> 771   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, val_type);</span>
<span class="line-modified"> 772   if (!barrier_needed(access)) {</span>
<span class="line-removed"> 773     return result;</span>
<span class="line-removed"> 774   }</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776   Node* load_store = access.raw_access();</span>
<span class="line-removed"> 777   Node* adr = access.addr().node();</span>
<span class="line-removed"> 778 </span>
<span class="line-removed"> 779   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-removed"> 780   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-removed"> 781   return load_barrier(parse_access.kit(), load_store, adr, false, false, false);</span>
 782 }
 783 
<a name="48" id="anc48"></a><span class="line-modified"> 784 // == Macro Expansion ==</span>
<span class="line-modified"> 785 </span>
<span class="line-modified"> 786 void ZBarrierSetC2::expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const {</span>
<span class="line-modified"> 787   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 788   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed"> 789   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 790   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed"> 791 </span>
<span class="line-removed"> 792   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed"> 793   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 794 </span>
<span class="line-removed"> 795   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
 796 
<a name="49" id="anc49"></a><span class="line-modified"> 797   if (ZVerifyLoadBarriers) {</span>
<span class="line-modified"> 798     igvn.replace_node(out_res, in_val);</span>
<span class="line-modified"> 799     igvn.replace_node(out_ctrl, in_ctrl);</span>
<span class="line-modified"> 800     return;</span>
<span class="line-modified"> 801   }</span>




 802 
<a name="50" id="anc50"></a><span class="line-modified"> 803   if (barrier-&gt;can_be_eliminated()) {</span>
<span class="line-modified"> 804     // Clone and pin the load for this barrier below the dominating</span>
<span class="line-modified"> 805     // barrier: the load cannot be allowed to float above the</span>
<span class="line-removed"> 806     // dominating barrier</span>
<span class="line-removed"> 807     Node* load = in_val;</span>
<span class="line-removed"> 808 </span>
<span class="line-removed"> 809     if (load-&gt;is_Load()) {</span>
<span class="line-removed"> 810       Node* new_load = load-&gt;clone();</span>
<span class="line-removed"> 811       Node* addp = new_load-&gt;in(MemNode::Address);</span>
<span class="line-removed"> 812       assert(addp-&gt;is_AddP() || addp-&gt;is_Phi() || addp-&gt;is_Load(), &quot;bad address&quot;);</span>
<span class="line-removed"> 813       Node* cast = new CastPPNode(addp, igvn.type(addp), true);</span>
<span class="line-removed"> 814       Node* ctrl = NULL;</span>
<span class="line-removed"> 815       Node* similar = barrier-&gt;in(LoadBarrierNode::Similar);</span>
<span class="line-removed"> 816       if (similar-&gt;is_Phi()) {</span>
<span class="line-removed"> 817         // already expanded</span>
<span class="line-removed"> 818         ctrl = similar-&gt;in(0);</span>
<span class="line-removed"> 819       } else {</span>
<span class="line-removed"> 820         assert(similar-&gt;is_Proj() &amp;&amp; similar-&gt;in(0)-&gt;is_LoadBarrier(), &quot;unexpected graph shape&quot;);</span>
<span class="line-removed"> 821         ctrl = similar-&gt;in(0)-&gt;as_LoadBarrier()-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed"> 822       }</span>
<span class="line-removed"> 823       assert(ctrl != NULL, &quot;bad control&quot;);</span>
<span class="line-removed"> 824       cast-&gt;set_req(0, ctrl);</span>
<span class="line-removed"> 825       igvn.transform(cast);</span>
<span class="line-removed"> 826       new_load-&gt;set_req(MemNode::Address, cast);</span>
<span class="line-removed"> 827       igvn.transform(new_load);</span>
<span class="line-removed"> 828 </span>
<span class="line-removed"> 829       igvn.replace_node(out_res, new_load);</span>
<span class="line-removed"> 830       igvn.replace_node(out_ctrl, in_ctrl);</span>
<span class="line-removed"> 831       return;</span>
<span class="line-removed"> 832     }</span>
<span class="line-removed"> 833     // cannot eliminate</span>
<span class="line-removed"> 834   }</span>
<span class="line-removed"> 835 </span>
<span class="line-removed"> 836   // There are two cases that require the basic loadbarrier</span>
<span class="line-removed"> 837   // 1) When the writeback of a healed oop must be avoided (swap)</span>
<span class="line-removed"> 838   // 2) When we must guarantee that no reload of is done (swap, cas, cmpx)</span>
<span class="line-removed"> 839   if (!barrier-&gt;is_writeback()) {</span>
<span class="line-removed"> 840     assert(!barrier-&gt;oop_reload_allowed(), &quot;writeback barriers should be marked as requires oop&quot;);</span>
<span class="line-removed"> 841   }</span>
 842 
<a name="51" id="anc51"></a><span class="line-modified"> 843   if (!barrier-&gt;oop_reload_allowed()) {</span>
<span class="line-removed"> 844     expand_loadbarrier_basic(phase, barrier);</span>
<span class="line-removed"> 845   } else {</span>
<span class="line-removed"> 846     expand_loadbarrier_optimized(phase, barrier);</span>
<span class="line-removed"> 847   }</span>
 848 }
 849 
<a name="52" id="anc52"></a><span class="line-modified"> 850 // Basic loadbarrier using conventional argument passing</span>
<span class="line-modified"> 851 void ZBarrierSetC2::expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {</span>
<span class="line-modified"> 852   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified"> 853 </span>
<span class="line-modified"> 854   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 855   Node* in_mem  = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed"> 856   Node* in_val  = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 857   Node* in_adr  = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed"> 858 </span>
<span class="line-removed"> 859   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed"> 860   Node* out_res  = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 861 </span>
<span class="line-removed"> 862   float unlikely  = PROB_UNLIKELY(0.999);</span>
<span class="line-removed"> 863   const Type* in_val_maybe_null_t = igvn.type(in_val);</span>
<span class="line-removed"> 864 </span>
<span class="line-removed"> 865   Node* jthread = igvn.transform(new ThreadLocalNode());</span>
<span class="line-removed"> 866   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));</span>
<span class="line-removed"> 867   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered));</span>
<span class="line-removed"> 868   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));</span>
<span class="line-removed"> 869   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));</span>
<span class="line-removed"> 870   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));</span>
<span class="line-removed"> 871   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed"> 872   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 873   Node* then = igvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed"> 874   Node* elsen = igvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed"> 875 </span>
<span class="line-removed"> 876   Node* result_region;</span>
<span class="line-removed"> 877   Node* result_val;</span>
<span class="line-removed"> 878 </span>
<span class="line-removed"> 879   result_region = new RegionNode(3);</span>
<span class="line-removed"> 880   result_val = new PhiNode(result_region, TypeInstPtr::BOTTOM);</span>
<span class="line-removed"> 881 </span>
<span class="line-removed"> 882   result_region-&gt;set_req(1, elsen);</span>
<span class="line-removed"> 883   Node* res = igvn.transform(new CastPPNode(in_val, in_val_maybe_null_t));</span>
<span class="line-removed"> 884   res-&gt;init_req(0, elsen);</span>
<span class="line-removed"> 885   result_val-&gt;set_req(1, res);</span>
<span class="line-removed"> 886 </span>
<span class="line-removed"> 887   const TypeFunc *tf = load_barrier_Type();</span>
<span class="line-removed"> 888   Node* call;</span>
<span class="line-removed"> 889   if (barrier-&gt;is_weak()) {</span>
<span class="line-removed"> 890     call = new CallLeafNode(tf,</span>
<span class="line-removed"> 891                             ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr(),</span>
<span class="line-removed"> 892                             &quot;ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded&quot;,</span>
<span class="line-removed"> 893                             TypeRawPtr::BOTTOM);</span>
<span class="line-removed"> 894   } else {</span>
<span class="line-removed"> 895     call = new CallLeafNode(tf,</span>
<span class="line-removed"> 896                             ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(),</span>
<span class="line-removed"> 897                             &quot;ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded&quot;,</span>
<span class="line-removed"> 898                             TypeRawPtr::BOTTOM);</span>
<span class="line-removed"> 899   }</span>
 900 
<a name="53" id="anc53"></a><span class="line-modified"> 901   call-&gt;init_req(TypeFunc::Control, then);</span>
<span class="line-modified"> 902   call-&gt;init_req(TypeFunc::I_O    , phase-&gt;top());</span>
<span class="line-modified"> 903   call-&gt;init_req(TypeFunc::Memory , in_mem);</span>
<span class="line-modified"> 904   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;top());</span>
<span class="line-modified"> 905   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;top());</span>
<span class="line-removed"> 906   call-&gt;init_req(TypeFunc::Parms+0, in_val);</span>
<span class="line-removed"> 907   if (barrier-&gt;is_writeback()) {</span>
<span class="line-removed"> 908     call-&gt;init_req(TypeFunc::Parms+1, in_adr);</span>
 909   } else {
<a name="54" id="anc54"></a><span class="line-modified"> 910     // When slow path is called with a null address, the healed oop will not be written back</span>
<span class="line-removed"> 911     call-&gt;init_req(TypeFunc::Parms+1, igvn.zerocon(T_OBJECT));</span>
<span class="line-removed"> 912   }</span>
<span class="line-removed"> 913   call = igvn.transform(call);</span>
<span class="line-removed"> 914 </span>
<span class="line-removed"> 915   Node* ctrl = igvn.transform(new ProjNode(call, TypeFunc::Control));</span>
<span class="line-removed"> 916   res = igvn.transform(new ProjNode(call, TypeFunc::Parms));</span>
<span class="line-removed"> 917   res = igvn.transform(new CheckCastPPNode(ctrl, res, in_val_maybe_null_t));</span>
<span class="line-removed"> 918 </span>
<span class="line-removed"> 919   result_region-&gt;set_req(2, ctrl);</span>
<span class="line-removed"> 920   result_val-&gt;set_req(2, res);</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922   result_region = igvn.transform(result_region);</span>
<span class="line-removed"> 923   result_val = igvn.transform(result_val);</span>
<span class="line-removed"> 924 </span>
<span class="line-removed"> 925   if (out_ctrl != NULL) { // Added if cond</span>
<span class="line-removed"> 926     igvn.replace_node(out_ctrl, result_region);</span>
 927   }
<a name="55" id="anc55"></a><span class="line-removed"> 928   igvn.replace_node(out_res, result_val);</span>
 929 }
 930 
<a name="56" id="anc56"></a><span class="line-modified"> 931 // Optimized, low spill, loadbarrier variant using stub specialized on register used</span>
<span class="line-modified"> 932 void ZBarrierSetC2::expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const {</span>
<span class="line-modified"> 933   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified"> 934 #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-modified"> 935   Node* preceding_barrier_node = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-modified"> 936 #endif</span>
<span class="line-removed"> 937 </span>
<span class="line-removed"> 938   Node* in_ctrl = barrier-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed"> 939   Node* in_mem = barrier-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed"> 940   Node* in_val = barrier-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 941   Node* in_adr = barrier-&gt;in(LoadBarrierNode::Address);</span>
<span class="line-removed"> 942 </span>
<span class="line-removed"> 943   Node* out_ctrl = barrier-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed"> 944   Node* out_res = barrier-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed"> 945 </span>
<span class="line-removed"> 946   assert(barrier-&gt;in(LoadBarrierNode::Oop) != NULL, &quot;oop to loadbarrier node cannot be null&quot;);</span>
<span class="line-removed"> 947 </span>
<span class="line-removed"> 948 #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-removed"> 949   tty-&gt;print(&quot;\n\n\nBefore barrier optimization:\n&quot;);</span>
<span class="line-removed"> 950   traverse(barrier, out_ctrl, out_res, -1);</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952   tty-&gt;print(&quot;\nBefore barrier optimization:  preceding_barrier_node\n&quot;);</span>
<span class="line-removed"> 953   traverse(preceding_barrier_node, out_ctrl, out_res, -1);</span>
<span class="line-removed"> 954 #endif</span>
<span class="line-removed"> 955 </span>
<span class="line-removed"> 956   float unlikely  = PROB_UNLIKELY(0.999);</span>
<span class="line-removed"> 957 </span>
<span class="line-removed"> 958   Node* jthread = igvn.transform(new ThreadLocalNode());</span>
<span class="line-removed"> 959   Node* adr = phase-&gt;basic_plus_adr(jthread, in_bytes(ZThreadLocalData::address_bad_mask_offset()));</span>
<span class="line-removed"> 960   Node* bad_mask = igvn.transform(LoadNode::make(igvn, in_ctrl, in_mem, adr,</span>
<span class="line-removed"> 961                                                  TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(),</span>
<span class="line-removed"> 962                                                  MemNode::unordered));</span>
<span class="line-removed"> 963   Node* cast = igvn.transform(new CastP2XNode(in_ctrl, in_val));</span>
<span class="line-removed"> 964   Node* obj_masked = igvn.transform(new AndXNode(cast, bad_mask));</span>
<span class="line-removed"> 965   Node* cmp = igvn.transform(new CmpXNode(obj_masked, igvn.zerocon(TypeX_X-&gt;basic_type())));</span>
<span class="line-removed"> 966   Node *bol = igvn.transform(new BoolNode(cmp, BoolTest::ne))-&gt;as_Bool();</span>
<span class="line-removed"> 967   IfNode* iff = igvn.transform(new IfNode(in_ctrl, bol, unlikely, COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-removed"> 968   Node* then = igvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed"> 969   Node* elsen = igvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971   Node* slow_path_surrogate;</span>
<span class="line-removed"> 972   if (!barrier-&gt;is_weak()) {</span>
<span class="line-removed"> 973     slow_path_surrogate = igvn.transform(new LoadBarrierSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),</span>
<span class="line-removed"> 974                                                                     (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));</span>
<span class="line-removed"> 975   } else {</span>
<span class="line-removed"> 976     slow_path_surrogate = igvn.transform(new LoadBarrierWeakSlowRegNode(then, in_mem, in_adr, in_val-&gt;adr_type(),</span>
<span class="line-removed"> 977                                                                         (const TypePtr*) in_val-&gt;bottom_type(), MemNode::unordered));</span>
<span class="line-removed"> 978   }</span>
<span class="line-removed"> 979 </span>
<span class="line-removed"> 980   Node *new_loadp;</span>
<span class="line-removed"> 981   new_loadp = slow_path_surrogate;</span>
<span class="line-removed"> 982   // Create the final region/phi pair to converge cntl/data paths to downstream code</span>
<span class="line-removed"> 983   Node* result_region = igvn.transform(new RegionNode(3));</span>
<span class="line-removed"> 984   result_region-&gt;set_req(1, then);</span>
<span class="line-removed"> 985   result_region-&gt;set_req(2, elsen);</span>
<span class="line-removed"> 986 </span>
<span class="line-removed"> 987   Node* result_phi = igvn.transform(new PhiNode(result_region, TypeInstPtr::BOTTOM));</span>
<span class="line-removed"> 988   result_phi-&gt;set_req(1, new_loadp);</span>
<span class="line-removed"> 989   result_phi-&gt;set_req(2, barrier-&gt;in(LoadBarrierNode::Oop));</span>
<span class="line-removed"> 990 </span>
<span class="line-removed"> 991   // Finally, connect the original outputs to the barrier region and phi to complete the expansion/substitution</span>
<span class="line-removed"> 992   // igvn.replace_node(out_ctrl, result_region);</span>
<span class="line-removed"> 993   if (out_ctrl != NULL) { // added if cond</span>
<span class="line-removed"> 994     igvn.replace_node(out_ctrl, result_region);</span>
 995   }
<a name="57" id="anc57"></a><span class="line-removed"> 996   igvn.replace_node(out_res, result_phi);</span>
<span class="line-removed"> 997 </span>
<span class="line-removed"> 998   assert(barrier-&gt;outcnt() == 0,&quot;LoadBarrier macro node has non-null outputs after expansion!&quot;);</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000 #ifdef PRINT_NODE_TRAVERSALS</span>
<span class="line-removed">1001   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_ctrl\n&quot;);</span>
<span class="line-removed">1002   traverse(out_ctrl, out_ctrl, out_res, -1);</span>
<span class="line-removed">1003   tty-&gt;print(&quot;\nAfter barrier optimization:  old out_res\n&quot;);</span>
<span class="line-removed">1004   traverse(out_res, out_ctrl, out_res, -1);</span>
<span class="line-removed">1005   tty-&gt;print(&quot;\nAfter barrier optimization:  old barrier\n&quot;);</span>
<span class="line-removed">1006   traverse(barrier, out_ctrl, out_res, -1);</span>
<span class="line-removed">1007   tty-&gt;print(&quot;\nAfter barrier optimization:  preceding_barrier_node\n&quot;);</span>
<span class="line-removed">1008   traverse(preceding_barrier_node, result_region, result_phi, -1);</span>
<span class="line-removed">1009 #endif</span>
<span class="line-removed">1010 </span>
<span class="line-removed">1011   assert(is_gc_barrier_node(result_phi), &quot;sanity&quot;);</span>
<span class="line-removed">1012   assert(step_over_gc_barrier(result_phi) == in_val, &quot;sanity&quot;);</span>
<span class="line-removed">1013 }</span>
1014 
<a name="58" id="anc58"></a><span class="line-modified">1015 bool ZBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {</span>
<span class="line-modified">1016   ZBarrierSetC2State* s = state();</span>
<span class="line-modified">1017   if (s-&gt;load_barrier_count() &gt; 0) {</span>
<span class="line-modified">1018     PhaseMacroExpand macro(igvn);</span>
<span class="line-modified">1019 #ifdef ASSERT</span>
<span class="line-modified">1020     verify_gc_barriers(false);</span>
<span class="line-modified">1021 #endif</span>
<span class="line-modified">1022     int skipped = 0;</span>
<span class="line-modified">1023     while (s-&gt;load_barrier_count() &gt; skipped) {</span>
<span class="line-modified">1024       int load_barrier_count = s-&gt;load_barrier_count();</span>
<span class="line-modified">1025       LoadBarrierNode * n = s-&gt;load_barrier_node(load_barrier_count-1-skipped);</span>
<span class="line-modified">1026       if (igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {</span>
<span class="line-modified">1027         // Node is unreachable, so don&#39;t try to expand it</span>
<span class="line-modified">1028         s-&gt;remove_load_barrier_node(n);</span>
<span class="line-modified">1029         continue;</span>
<span class="line-modified">1030       }</span>
<span class="line-modified">1031       if (!n-&gt;can_be_eliminated()) {</span>
<span class="line-modified">1032         skipped++;</span>
<span class="line-modified">1033         continue;</span>
<span class="line-modified">1034       }</span>
<span class="line-modified">1035       expand_loadbarrier_node(&amp;macro, n);</span>
<span class="line-modified">1036       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);</span>
<span class="line-modified">1037       if (C-&gt;failing()) {</span>
<span class="line-modified">1038         return true;</span>
<span class="line-modified">1039       }</span>
<span class="line-modified">1040     }</span>
<span class="line-modified">1041     while (s-&gt;load_barrier_count() &gt; 0) {</span>
<span class="line-modified">1042       int load_barrier_count = s-&gt;load_barrier_count();</span>
<span class="line-modified">1043       LoadBarrierNode* n = s-&gt;load_barrier_node(load_barrier_count - 1);</span>
<span class="line-modified">1044       assert(!(igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())), &quot;should have been processed already&quot;);</span>
<span class="line-modified">1045       assert(!n-&gt;can_be_eliminated(), &quot;should have been processed already&quot;);</span>
<span class="line-modified">1046       expand_loadbarrier_node(&amp;macro, n);</span>
<span class="line-modified">1047       assert(s-&gt;load_barrier_count() &lt; load_barrier_count, &quot;must have deleted a node from load barrier list&quot;);</span>
<span class="line-modified">1048       if (C-&gt;failing()) {</span>
<span class="line-modified">1049         return true;</span>
<span class="line-modified">1050       }</span>
<span class="line-modified">1051     }</span>
<span class="line-modified">1052     igvn.set_delay_transform(false);</span>
<span class="line-modified">1053     igvn.optimize();</span>
<span class="line-modified">1054     if (C-&gt;failing()) {</span>


1055       return true;
1056     }
1057   }
1058 
<a name="59" id="anc59"></a>
1059   return false;
1060 }
1061 
<a name="60" id="anc60"></a><span class="line-modified">1062 // == Loop optimization ==</span>
<span class="line-modified">1063 </span>
<span class="line-removed">1064 static bool replace_with_dominating_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, bool last_round) {</span>
<span class="line-removed">1065   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">1066   Compile* C = Compile::current();</span>
<span class="line-removed">1067 </span>
<span class="line-removed">1068   LoadBarrierNode* lb2 = lb-&gt;has_dominating_barrier(phase, false, last_round);</span>
<span class="line-removed">1069   if (lb2 == NULL) {</span>
<span class="line-removed">1070     return false;</span>
<span class="line-removed">1071   }</span>
<span class="line-removed">1072 </span>
<span class="line-removed">1073   if (lb-&gt;in(LoadBarrierNode::Oop) != lb2-&gt;in(LoadBarrierNode::Oop)) {</span>
<span class="line-removed">1074     assert(lb-&gt;in(LoadBarrierNode::Address) == lb2-&gt;in(LoadBarrierNode::Address), &quot;Invalid address&quot;);</span>
<span class="line-removed">1075     igvn.replace_input_of(lb, LoadBarrierNode::Similar, lb2-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">1076     C-&gt;set_major_progress();</span>
<span class="line-removed">1077     return false;</span>
<span class="line-removed">1078   }</span>
<span class="line-removed">1079 </span>
<span class="line-removed">1080   // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">1081   lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">1082 </span>
<span class="line-removed">1083   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">1084   assert(lb2-&gt;has_true_uses(), &quot;Invalid uses&quot;);</span>
<span class="line-removed">1085   assert(lb2-&gt;in(LoadBarrierNode::Oop) == lb-&gt;in(LoadBarrierNode::Oop), &quot;Invalid oop&quot;);</span>
<span class="line-removed">1086   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-removed">1087   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-removed">1088   igvn.replace_node(val, lb2-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">1089 </span>
<span class="line-removed">1090   return true;</span>
1091 }
1092 
<a name="61" id="anc61"></a><span class="line-modified">1093 static Node* find_dominating_memory(PhaseIdealLoop* phase, Node* mem, Node* dom, int i) {</span>
<span class="line-modified">1094   assert(dom-&gt;is_Region() || i == -1, &quot;&quot;);</span>
<span class="line-modified">1095 </span>
<span class="line-modified">1096   Node* m = mem;</span>
<span class="line-removed">1097   while(phase-&gt;is_dominator(dom, phase-&gt;has_ctrl(m) ? phase-&gt;get_ctrl(m) : m-&gt;in(0))) {</span>
<span class="line-removed">1098     if (m-&gt;is_Mem()) {</span>
<span class="line-removed">1099       assert(m-&gt;as_Mem()-&gt;adr_type() == TypeRawPtr::BOTTOM, &quot;&quot;);</span>
<span class="line-removed">1100       m = m-&gt;in(MemNode::Memory);</span>
<span class="line-removed">1101     } else if (m-&gt;is_MergeMem()) {</span>
<span class="line-removed">1102       m = m-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);</span>
<span class="line-removed">1103     } else if (m-&gt;is_Phi()) {</span>
<span class="line-removed">1104       if (m-&gt;in(0) == dom &amp;&amp; i != -1) {</span>
<span class="line-removed">1105         m = m-&gt;in(i);</span>
<span class="line-removed">1106         break;</span>
<span class="line-removed">1107       } else {</span>
<span class="line-removed">1108         m = m-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">1109       }</span>
<span class="line-removed">1110     } else if (m-&gt;is_Proj()) {</span>
<span class="line-removed">1111       m = m-&gt;in(0);</span>
<span class="line-removed">1112     } else if (m-&gt;is_SafePoint() || m-&gt;is_MemBar()) {</span>
<span class="line-removed">1113       m = m-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed">1114     } else {</span>
<span class="line-removed">1115 #ifdef ASSERT</span>
<span class="line-removed">1116       m-&gt;dump();</span>
<span class="line-removed">1117 #endif</span>
<span class="line-removed">1118       ShouldNotReachHere();</span>
1119     }
1120   }
<a name="62" id="anc62"></a><span class="line-modified">1121 </span>
<span class="line-modified">1122   return m;</span>
1123 }
1124 
<a name="63" id="anc63"></a><span class="line-modified">1125 static LoadBarrierNode* clone_load_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* ctl, Node* mem, Node* oop_in) {</span>
<span class="line-modified">1126   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">1127   Compile* C = Compile::current();</span>
<span class="line-modified">1128   Node* the_clone = lb-&gt;clone();</span>
<span class="line-modified">1129   the_clone-&gt;set_req(LoadBarrierNode::Control, ctl);</span>
<span class="line-modified">1130   the_clone-&gt;set_req(LoadBarrierNode::Memory, mem);</span>
<span class="line-modified">1131   if (oop_in != NULL) {</span>
<span class="line-modified">1132     the_clone-&gt;set_req(LoadBarrierNode::Oop, oop_in);</span>
<span class="line-modified">1133   }</span>
<span class="line-modified">1134 </span>
<span class="line-modified">1135   LoadBarrierNode* new_lb = the_clone-&gt;as_LoadBarrier();</span>
<span class="line-modified">1136   igvn.register_new_node_with_optimizer(new_lb);</span>
<span class="line-modified">1137   IdealLoopTree *loop = phase-&gt;get_loop(new_lb-&gt;in(0));</span>
<span class="line-modified">1138   phase-&gt;set_ctrl(new_lb, new_lb-&gt;in(0));</span>
<span class="line-modified">1139   phase-&gt;set_loop(new_lb, loop);</span>
<span class="line-modified">1140   phase-&gt;set_idom(new_lb, new_lb-&gt;in(0), phase-&gt;dom_depth(new_lb-&gt;in(0))+1);</span>
<span class="line-removed">1141   if (!loop-&gt;_child) {</span>
<span class="line-removed">1142     loop-&gt;_body.push(new_lb);</span>
<span class="line-removed">1143   }</span>
<span class="line-removed">1144 </span>
<span class="line-removed">1145   Node* proj_ctl = new ProjNode(new_lb, LoadBarrierNode::Control);</span>
<span class="line-removed">1146   igvn.register_new_node_with_optimizer(proj_ctl);</span>
<span class="line-removed">1147   phase-&gt;set_ctrl(proj_ctl, proj_ctl-&gt;in(0));</span>
<span class="line-removed">1148   phase-&gt;set_loop(proj_ctl, loop);</span>
<span class="line-removed">1149   phase-&gt;set_idom(proj_ctl, new_lb, phase-&gt;dom_depth(new_lb)+1);</span>
<span class="line-removed">1150   if (!loop-&gt;_child) {</span>
<span class="line-removed">1151     loop-&gt;_body.push(proj_ctl);</span>
<span class="line-removed">1152   }</span>
1153 
<a name="64" id="anc64"></a><span class="line-modified">1154   Node* proj_oop = new ProjNode(new_lb, LoadBarrierNode::Oop);</span>
<span class="line-modified">1155   phase-&gt;register_new_node(proj_oop, new_lb);</span>










1156 
<a name="65" id="anc65"></a><span class="line-modified">1157   if (!new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {</span>
<span class="line-modified">1158     LoadBarrierNode* similar = new_lb-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;as_LoadBarrier();</span>
<span class="line-modified">1159     if (!phase-&gt;is_dominator(similar, ctl)) {</span>
<span class="line-removed">1160       igvn.replace_input_of(new_lb, LoadBarrierNode::Similar, C-&gt;top());</span>
1161     }
1162   }
1163 
<a name="66" id="anc66"></a><span class="line-modified">1164   return new_lb;</span>
<span class="line-modified">1165 }</span>






1166 
<a name="67" id="anc67"></a><span class="line-modified">1167 static void replace_barrier(PhaseIdealLoop* phase, LoadBarrierNode* lb, Node* new_val) {</span>
<span class="line-modified">1168   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-modified">1169   Node* val = lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-modified">1170   igvn.replace_node(val, new_val);</span>
<span class="line-modified">1171   phase-&gt;lazy_update(lb, lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-modified">1172   phase-&gt;lazy_replace(lb-&gt;proj_out(LoadBarrierNode::Control), lb-&gt;in(LoadBarrierNode::Control));</span>
<span class="line-modified">1173 }</span>
<span class="line-removed">1174 </span>
<span class="line-removed">1175 static bool split_barrier_thru_phi(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">1176   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">1177   Compile* C = Compile::current();</span>
<span class="line-removed">1178 </span>
<span class="line-removed">1179   if (lb-&gt;in(LoadBarrierNode::Oop)-&gt;is_Phi()) {</span>
<span class="line-removed">1180     Node* oop_phi = lb-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">1181 </span>
<span class="line-removed">1182     if ((oop_phi-&gt;req() != 3) || (oop_phi-&gt;in(2) == oop_phi)) {</span>
<span class="line-removed">1183       // Ignore phis with only one input</span>
<span class="line-removed">1184       return false;</span>
<span class="line-removed">1185     }</span>
1186 
<a name="68" id="anc68"></a><span class="line-modified">1187     if (phase-&gt;is_dominator(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)),</span>
<span class="line-modified">1188                             oop_phi-&gt;in(0)) &amp;&amp; phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)) != oop_phi-&gt;in(0)) {</span>
<span class="line-modified">1189       // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-modified">1190       lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">1191 </span>
<span class="line-removed">1192       RegionNode* region = oop_phi-&gt;in(0)-&gt;as_Region();</span>
<span class="line-removed">1193 </span>
<span class="line-removed">1194       int backedge = LoopNode::LoopBackControl;</span>
<span class="line-removed">1195       if (region-&gt;is_Loop() &amp;&amp; region-&gt;in(backedge)-&gt;is_Proj() &amp;&amp; region-&gt;in(backedge)-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-removed">1196         Node* c = region-&gt;in(backedge)-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">1197         assert(c-&gt;unique_ctrl_out() == region-&gt;in(backedge)-&gt;in(0), &quot;&quot;);</span>
<span class="line-removed">1198         Node* oop = lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(backedge);</span>
<span class="line-removed">1199         Node* oop_c = phase-&gt;has_ctrl(oop) ? phase-&gt;get_ctrl(oop) : oop;</span>
<span class="line-removed">1200         if (!phase-&gt;is_dominator(oop_c, c)) {</span>
<span class="line-removed">1201           return false;</span>
<span class="line-removed">1202         }</span>
1203       }
1204 
<a name="69" id="anc69"></a><span class="line-modified">1205       // If the node on the backedge above the phi is the node itself - we have a self loop.</span>
<span class="line-modified">1206       // Don&#39;t clone - this will be folded later.</span>
<span class="line-modified">1207       if (oop_phi-&gt;in(LoopNode::LoopBackControl) == lb-&gt;proj_out(LoadBarrierNode::Oop)) {</span>
<span class="line-removed">1208         return false;</span>
1209       }
1210 
<a name="70" id="anc70"></a><span class="line-modified">1211       bool is_strip_mined = region-&gt;is_CountedLoop() &amp;&amp; region-&gt;as_CountedLoop()-&gt;is_strip_mined();</span>
<span class="line-modified">1212       Node *phi = oop_phi-&gt;clone();</span>
<span class="line-modified">1213 </span>
<span class="line-modified">1214       for (uint i = 1; i &lt; region-&gt;req(); i++) {</span>
<span class="line-modified">1215         Node* ctrl = region-&gt;in(i);</span>
<span class="line-modified">1216         if (ctrl != C-&gt;top()) {</span>
<span class="line-modified">1217           assert(!phase-&gt;is_dominator(ctrl, region) || region-&gt;is_Loop(), &quot;&quot;);</span>
<span class="line-modified">1218 </span>
<span class="line-modified">1219           Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-modified">1220           Node* m = find_dominating_memory(phase, mem, region, i);</span>
<span class="line-modified">1221 </span>
<span class="line-modified">1222           if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::LoopBackControl &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-modified">1223             ctrl = ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-modified">1224           } else if (region-&gt;is_Loop() &amp;&amp; is_strip_mined) {</span>
<span class="line-modified">1225             // If this is a strip mined loop, control must move above OuterStripMinedLoop</span>
<span class="line-modified">1226             assert(i == LoopNode::EntryControl, &quot;check&quot;);</span>
<span class="line-removed">1227             assert(ctrl-&gt;is_OuterStripMinedLoop(), &quot;sanity&quot;);</span>
<span class="line-removed">1228             ctrl = ctrl-&gt;as_OuterStripMinedLoop()-&gt;in(LoopNode::EntryControl);</span>
1229           }
<a name="71" id="anc71"></a><span class="line-modified">1230 </span>
<span class="line-modified">1231           LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, ctrl, m, lb-&gt;in(LoadBarrierNode::Oop)-&gt;in(i));</span>
<span class="line-modified">1232           Node* out_ctrl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234           if (is_strip_mined &amp;&amp; (i == LoopNode::EntryControl)) {</span>
<span class="line-removed">1235             assert(region-&gt;in(i)-&gt;is_OuterStripMinedLoop(), &quot;&quot;);</span>
<span class="line-removed">1236             igvn.replace_input_of(region-&gt;in(i), i, out_ctrl);</span>
<span class="line-removed">1237             phase-&gt;set_idom(region-&gt;in(i), out_ctrl, phase-&gt;dom_depth(out_ctrl));</span>
<span class="line-removed">1238           } else if (ctrl == region-&gt;in(i)) {</span>
<span class="line-removed">1239             igvn.replace_input_of(region, i, out_ctrl);</span>
<span class="line-removed">1240             // Only update the idom if is the loop entry we are updating</span>
<span class="line-removed">1241             // - A loop backedge doesn&#39;t change the idom</span>
<span class="line-removed">1242             if (region-&gt;is_Loop() &amp;&amp; i == LoopNode::EntryControl) {</span>
<span class="line-removed">1243               phase-&gt;set_idom(region, out_ctrl, phase-&gt;dom_depth(out_ctrl));</span>
<span class="line-removed">1244             }</span>
<span class="line-removed">1245           } else {</span>
<span class="line-removed">1246             Node* iff = region-&gt;in(i)-&gt;in(0);</span>
<span class="line-removed">1247             igvn.replace_input_of(iff, 0, out_ctrl);</span>
<span class="line-removed">1248             phase-&gt;set_idom(iff, out_ctrl, phase-&gt;dom_depth(out_ctrl)+1);</span>
1249           }
<a name="72" id="anc72"></a><span class="line-modified">1250           phi-&gt;set_req(i, new_lb-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-modified">1251         }</span>
<span class="line-removed">1252       }</span>
<span class="line-removed">1253       phase-&gt;register_new_node(phi, region);</span>
<span class="line-removed">1254       replace_barrier(phase, lb, phi);</span>
<span class="line-removed">1255 </span>
<span class="line-removed">1256       if (region-&gt;is_Loop()) {</span>
<span class="line-removed">1257         // Load barrier moved to the back edge of the Loop may now</span>
<span class="line-removed">1258         // have a safepoint on the path to the barrier on the Similar</span>
<span class="line-removed">1259         // edge</span>
<span class="line-removed">1260         igvn.replace_input_of(phi-&gt;in(LoopNode::LoopBackControl)-&gt;in(0), LoadBarrierNode::Similar, C-&gt;top());</span>
<span class="line-removed">1261         Node* head = region-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">1262         phase-&gt;set_idom(region, head, phase-&gt;dom_depth(head)+1);</span>
<span class="line-removed">1263         phase-&gt;recompute_dom_depth();</span>
<span class="line-removed">1264         if (head-&gt;is_CountedLoop() &amp;&amp; head-&gt;as_CountedLoop()-&gt;is_main_loop()) {</span>
<span class="line-removed">1265           head-&gt;as_CountedLoop()-&gt;set_normal_loop();</span>
<span class="line-removed">1266         }</span>
<span class="line-removed">1267       }</span>
<span class="line-removed">1268 </span>
<span class="line-removed">1269       return true;</span>
<span class="line-removed">1270     }</span>
<span class="line-removed">1271   }</span>
<span class="line-removed">1272 </span>
<span class="line-removed">1273   return false;</span>
<span class="line-removed">1274 }</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276 static bool move_out_of_loop(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">1277   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">1278   IdealLoopTree *lb_loop = phase-&gt;get_loop(lb-&gt;in(0));</span>
<span class="line-removed">1279   if (lb_loop != phase-&gt;ltree_root() &amp;&amp; !lb_loop-&gt;_irreducible) {</span>
<span class="line-removed">1280     Node* oop_ctrl = phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Oop));</span>
<span class="line-removed">1281     IdealLoopTree *oop_loop = phase-&gt;get_loop(oop_ctrl);</span>
<span class="line-removed">1282     IdealLoopTree* adr_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(lb-&gt;in(LoadBarrierNode::Address)));</span>
<span class="line-removed">1283     if (!lb_loop-&gt;is_member(oop_loop) &amp;&amp; !lb_loop-&gt;is_member(adr_loop)) {</span>
<span class="line-removed">1284       // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">1285       lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">1286 </span>
<span class="line-removed">1287       Node* head = lb_loop-&gt;_head;</span>
<span class="line-removed">1288       assert(head-&gt;is_Loop(), &quot;&quot;);</span>
<span class="line-removed">1289 </span>
<span class="line-removed">1290       if (phase-&gt;is_dominator(head, oop_ctrl)) {</span>
<span class="line-removed">1291         assert(oop_ctrl-&gt;Opcode() == Op_CProj &amp;&amp; oop_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch, &quot;&quot;);</span>
<span class="line-removed">1292         assert(lb_loop-&gt;is_member(phase-&gt;get_loop(oop_ctrl-&gt;in(0)-&gt;in(0))), &quot;&quot;);</span>
<span class="line-removed">1293         return false;</span>
<span class="line-removed">1294       }</span>
<span class="line-removed">1295 </span>
<span class="line-removed">1296       if (head-&gt;is_CountedLoop()) {</span>
<span class="line-removed">1297         CountedLoopNode* cloop = head-&gt;as_CountedLoop();</span>
<span class="line-removed">1298         if (cloop-&gt;is_main_loop()) {</span>
<span class="line-removed">1299           cloop-&gt;set_normal_loop();</span>
<span class="line-removed">1300         }</span>
<span class="line-removed">1301         // When we are moving barrier out of a counted loop,</span>
<span class="line-removed">1302         // make sure we move it all the way out of the strip mined outer loop.</span>
<span class="line-removed">1303         if (cloop-&gt;is_strip_mined()) {</span>
<span class="line-removed">1304           head = cloop-&gt;outer_loop();</span>
<span class="line-removed">1305         }</span>
<span class="line-removed">1306       }</span>
<span class="line-removed">1307 </span>
<span class="line-removed">1308       Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">1309       Node* m = find_dominating_memory(phase, mem, head, -1);</span>
<span class="line-removed">1310 </span>
<span class="line-removed">1311       LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, head-&gt;in(LoopNode::EntryControl), m, NULL);</span>
<span class="line-removed">1312 </span>
<span class="line-removed">1313       assert(phase-&gt;idom(head) == head-&gt;in(LoopNode::EntryControl), &quot;&quot;);</span>
<span class="line-removed">1314       Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">1315       igvn.replace_input_of(head, LoopNode::EntryControl, proj_ctl);</span>
<span class="line-removed">1316       phase-&gt;set_idom(head, proj_ctl, phase-&gt;dom_depth(proj_ctl) + 1);</span>
<span class="line-removed">1317 </span>
<span class="line-removed">1318       replace_barrier(phase, lb, new_lb-&gt;proj_out(LoadBarrierNode::Oop));</span>
<span class="line-removed">1319 </span>
<span class="line-removed">1320       phase-&gt;recompute_dom_depth();</span>
<span class="line-removed">1321 </span>
<span class="line-removed">1322       return true;</span>
<span class="line-removed">1323     }</span>
<span class="line-removed">1324   }</span>
<span class="line-removed">1325 </span>
<span class="line-removed">1326   return false;</span>
<span class="line-removed">1327 }</span>
<span class="line-removed">1328 </span>
<span class="line-removed">1329 static bool common_barriers(PhaseIdealLoop* phase, LoadBarrierNode* lb) {</span>
<span class="line-removed">1330   PhaseIterGVN &amp;igvn = phase-&gt;igvn();</span>
<span class="line-removed">1331   Node* in_val = lb-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">1332   for (DUIterator_Fast imax, i = in_val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1333     Node* u = in_val-&gt;fast_out(i);</span>
<span class="line-removed">1334     if (u != lb &amp;&amp; u-&gt;is_LoadBarrier() &amp;&amp; u-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">1335       Node* this_ctrl = lb-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">1336       Node* other_ctrl = u-&gt;in(LoadBarrierNode::Control);</span>
<span class="line-removed">1337 </span>
<span class="line-removed">1338       Node* lca = phase-&gt;dom_lca(this_ctrl, other_ctrl);</span>
<span class="line-removed">1339       bool ok = true;</span>
<span class="line-removed">1340 </span>
<span class="line-removed">1341       Node* proj1 = NULL;</span>
<span class="line-removed">1342       Node* proj2 = NULL;</span>
<span class="line-removed">1343 </span>
<span class="line-removed">1344       while (this_ctrl != lca &amp;&amp; ok) {</span>
<span class="line-removed">1345         if (this_ctrl-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">1346             this_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {</span>
<span class="line-removed">1347           if (this_ctrl-&gt;in(0)-&gt;in(0) == lca) {</span>
<span class="line-removed">1348             assert(proj1 == NULL, &quot;&quot;);</span>
<span class="line-removed">1349             assert(this_ctrl-&gt;is_Proj(), &quot;&quot;);</span>
<span class="line-removed">1350             proj1 = this_ctrl;</span>
<span class="line-removed">1351           } else if (!(this_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; this_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {</span>
<span class="line-removed">1352             ok = false;</span>
1353           }
<a name="73" id="anc73"></a><span class="line-modified">1354         }</span>
<span class="line-modified">1355         this_ctrl = phase-&gt;idom(this_ctrl);</span>
<span class="line-modified">1356       }</span>
<span class="line-modified">1357       while (other_ctrl != lca &amp;&amp; ok) {</span>
<span class="line-modified">1358         if (other_ctrl-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">1359             other_ctrl-&gt;in(0)-&gt;is_MultiBranch()) {</span>
<span class="line-removed">1360           if (other_ctrl-&gt;in(0)-&gt;in(0) == lca) {</span>
<span class="line-removed">1361             assert(other_ctrl-&gt;is_Proj(), &quot;&quot;);</span>
<span class="line-removed">1362             assert(proj2 == NULL, &quot;&quot;);</span>
<span class="line-removed">1363             proj2 = other_ctrl;</span>
<span class="line-removed">1364           } else if (!(other_ctrl-&gt;in(0)-&gt;is_If() &amp;&amp; other_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none))) {</span>
<span class="line-removed">1365             ok = false;</span>
1366           }
1367         }
<a name="74" id="anc74"></a><span class="line-removed">1368         other_ctrl = phase-&gt;idom(other_ctrl);</span>
<span class="line-removed">1369       }</span>
<span class="line-removed">1370       assert(proj1 == NULL || proj2 == NULL || proj1-&gt;in(0) == proj2-&gt;in(0), &quot;&quot;);</span>
<span class="line-removed">1371       if (ok &amp;&amp; proj1 &amp;&amp; proj2 &amp;&amp; proj1 != proj2 &amp;&amp; proj1-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-removed">1372         // That transformation may cause the Similar edge on dominated load barriers to be invalid</span>
<span class="line-removed">1373         lb-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">1374         u-&gt;as_LoadBarrier()-&gt;fix_similar_in_uses(&amp;igvn);</span>
<span class="line-removed">1375 </span>
<span class="line-removed">1376         Node* split = lca-&gt;unique_ctrl_out();</span>
<span class="line-removed">1377         assert(split-&gt;in(0) == lca, &quot;&quot;);</span>
<span class="line-removed">1378 </span>
<span class="line-removed">1379         Node* mem = lb-&gt;in(LoadBarrierNode::Memory);</span>
<span class="line-removed">1380         Node* m = find_dominating_memory(phase, mem, split, -1);</span>
<span class="line-removed">1381         LoadBarrierNode* new_lb = clone_load_barrier(phase, lb, lca, m, NULL);</span>
<span class="line-removed">1382 </span>
<span class="line-removed">1383         Node* proj_ctl = new_lb-&gt;proj_out(LoadBarrierNode::Control);</span>
<span class="line-removed">1384         igvn.replace_input_of(split, 0, new_lb-&gt;proj_out(LoadBarrierNode::Control));</span>
<span class="line-removed">1385         phase-&gt;set_idom(split, proj_ctl, phase-&gt;dom_depth(proj_ctl)+1);</span>
<span class="line-removed">1386 </span>
<span class="line-removed">1387         Node* proj_oop = new_lb-&gt;proj_out(LoadBarrierNode::Oop);</span>
<span class="line-removed">1388         replace_barrier(phase, lb, proj_oop);</span>
<span class="line-removed">1389         replace_barrier(phase, u-&gt;as_LoadBarrier(), proj_oop);</span>
<span class="line-removed">1390 </span>
<span class="line-removed">1391         phase-&gt;recompute_dom_depth();</span>
1392 
<a name="75" id="anc75"></a><span class="line-modified">1393         return true;</span>


1394       }
1395     }
1396   }
<a name="76" id="anc76"></a><span class="line-removed">1397 </span>
<span class="line-removed">1398   return false;</span>
<span class="line-removed">1399 }</span>
<span class="line-removed">1400 </span>
<span class="line-removed">1401 void ZBarrierSetC2::loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round) {</span>
<span class="line-removed">1402   if (!Compile::current()-&gt;directive()-&gt;ZOptimizeLoadBarriersOption) {</span>
<span class="line-removed">1403     return;</span>
<span class="line-removed">1404   }</span>
<span class="line-removed">1405 </span>
<span class="line-removed">1406   if (!node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">1407     return;</span>
<span class="line-removed">1408   }</span>
<span class="line-removed">1409 </span>
<span class="line-removed">1410   if (!node-&gt;as_LoadBarrier()-&gt;has_true_uses()) {</span>
<span class="line-removed">1411     return;</span>
<span class="line-removed">1412   }</span>
<span class="line-removed">1413 </span>
<span class="line-removed">1414   if (replace_with_dominating_barrier(phase, node-&gt;as_LoadBarrier(), last_round)) {</span>
<span class="line-removed">1415     return;</span>
<span class="line-removed">1416   }</span>
<span class="line-removed">1417 </span>
<span class="line-removed">1418   if (split_barrier_thru_phi(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">1419     return;</span>
<span class="line-removed">1420   }</span>
<span class="line-removed">1421 </span>
<span class="line-removed">1422   if (move_out_of_loop(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">1423     return;</span>
<span class="line-removed">1424   }</span>
<span class="line-removed">1425 </span>
<span class="line-removed">1426   if (common_barriers(phase, node-&gt;as_LoadBarrier())) {</span>
<span class="line-removed">1427     return;</span>
<span class="line-removed">1428   }</span>
<span class="line-removed">1429 }</span>
<span class="line-removed">1430 </span>
<span class="line-removed">1431 Node* ZBarrierSetC2::step_over_gc_barrier(Node* c) const {</span>
<span class="line-removed">1432   Node* node = c;</span>
<span class="line-removed">1433 </span>
<span class="line-removed">1434   // 1. This step follows potential oop projections of a load barrier before expansion</span>
<span class="line-removed">1435   if (node-&gt;is_Proj()) {</span>
<span class="line-removed">1436     node = node-&gt;in(0);</span>
<span class="line-removed">1437   }</span>
<span class="line-removed">1438 </span>
<span class="line-removed">1439   // 2. This step checks for unexpanded load barriers</span>
<span class="line-removed">1440   if (node-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">1441     return node-&gt;in(LoadBarrierNode::Oop);</span>
<span class="line-removed">1442   }</span>
<span class="line-removed">1443 </span>
<span class="line-removed">1444   // 3. This step checks for the phi corresponding to an optimized load barrier expansion</span>
<span class="line-removed">1445   if (node-&gt;is_Phi()) {</span>
<span class="line-removed">1446     PhiNode* phi = node-&gt;as_Phi();</span>
<span class="line-removed">1447     Node* n = phi-&gt;in(1);</span>
<span class="line-removed">1448     if (n != NULL &amp;&amp; (n-&gt;is_LoadBarrierSlowReg() ||  n-&gt;is_LoadBarrierWeakSlowReg())) {</span>
<span class="line-removed">1449       assert(c == node, &quot;projections from step 1 should only be seen before macro expansion&quot;);</span>
<span class="line-removed">1450       return phi-&gt;in(2);</span>
<span class="line-removed">1451     }</span>
<span class="line-removed">1452   }</span>
<span class="line-removed">1453 </span>
<span class="line-removed">1454   return c;</span>
<span class="line-removed">1455 }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457 bool ZBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {</span>
<span class="line-removed">1458   return type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-removed">1459 }</span>
<span class="line-removed">1460 </span>
<span class="line-removed">1461 bool ZBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {</span>
<span class="line-removed">1462   if (opcode != Op_LoadBarrierSlowReg &amp;&amp;</span>
<span class="line-removed">1463       opcode != Op_LoadBarrierWeakSlowReg) {</span>
<span class="line-removed">1464     return false;</span>
<span class="line-removed">1465   }</span>
<span class="line-removed">1466 </span>
<span class="line-removed">1467 #ifdef ASSERT</span>
<span class="line-removed">1468   if (VerifyOptoOopOffsets) {</span>
<span class="line-removed">1469     MemNode* mem  = n-&gt;as_Mem();</span>
<span class="line-removed">1470     // Check to see if address types have grounded out somehow.</span>
<span class="line-removed">1471     const TypeInstPtr* tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();</span>
<span class="line-removed">1472     ciInstanceKlass* k = tp-&gt;klass()-&gt;as_instance_klass();</span>
<span class="line-removed">1473     bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());</span>
<span class="line-removed">1474     assert(!tp || oop_offset_is_sane, &quot;&quot;);</span>
<span class="line-removed">1475   }</span>
<span class="line-removed">1476 #endif</span>
<span class="line-removed">1477 </span>
<span class="line-removed">1478   return true;</span>
<span class="line-removed">1479 }</span>
<span class="line-removed">1480 </span>
<span class="line-removed">1481 bool ZBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {</span>
<span class="line-removed">1482   if (opcode == Op_CallLeaf &amp;&amp;</span>
<span class="line-removed">1483       (n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr() ||</span>
<span class="line-removed">1484        n-&gt;as_Call()-&gt;entry_point() == ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr())) {</span>
<span class="line-removed">1485     mem_op = true;</span>
<span class="line-removed">1486     mem_addr_idx = TypeFunc::Parms + 1;</span>
<span class="line-removed">1487     return true;</span>
<span class="line-removed">1488   }</span>
<span class="line-removed">1489 </span>
<span class="line-removed">1490   return false;</span>
1491 }
1492 
<a name="77" id="anc77"></a><span class="line-modified">1493 // == Verification ==</span>
<span class="line-removed">1494 </span>
<span class="line-removed">1495 #ifdef ASSERT</span>
1496 
<a name="78" id="anc78"></a><span class="line-modified">1497 static bool look_for_barrier(Node* n, bool post_parse, VectorSet&amp; visited) {</span>
<span class="line-modified">1498   if (visited.test_set(n-&gt;_idx)) {</span>
<span class="line-modified">1499     return true;</span>
<span class="line-modified">1500   }</span>
<span class="line-modified">1501 </span>
<span class="line-modified">1502   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">1503     Node* u = n-&gt;fast_out(i);</span>
<span class="line-modified">1504     if (u-&gt;is_LoadBarrier()) {</span>
<span class="line-modified">1505     } else if ((u-&gt;is_Phi() || u-&gt;is_CMove()) &amp;&amp; !post_parse) {</span>
<span class="line-modified">1506       if (!look_for_barrier(u, post_parse, visited)) {</span>
<span class="line-modified">1507         return false;</span>
























1508       }
<a name="79" id="anc79"></a><span class="line-modified">1509     } else if (u-&gt;Opcode() == Op_EncodeP || u-&gt;Opcode() == Op_DecodeN) {</span>
<span class="line-modified">1510       if (!look_for_barrier(u, post_parse, visited)) {</span>
<span class="line-removed">1511         return false;</span>
1512       }
<a name="80" id="anc80"></a><span class="line-removed">1513     } else if (u-&gt;Opcode() != Op_SCMemProj) {</span>
<span class="line-removed">1514       tty-&gt;print(&quot;bad use&quot;); u-&gt;dump();</span>
<span class="line-removed">1515       return false;</span>
<span class="line-removed">1516     }</span>
<span class="line-removed">1517   }</span>
<span class="line-removed">1518 </span>
<span class="line-removed">1519   return true;</span>
<span class="line-removed">1520 }</span>
1521 
<a name="81" id="anc81"></a><span class="line-modified">1522 void ZBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {</span>
<span class="line-modified">1523   if (phase == BarrierSetC2::BeforeCodeGen) return;</span>
<span class="line-modified">1524   bool post_parse = phase == BarrierSetC2::BeforeOptimize;</span>
<span class="line-modified">1525   verify_gc_barriers(post_parse);</span>
<span class="line-modified">1526 }</span>
<span class="line-modified">1527 </span>
<span class="line-modified">1528 void ZBarrierSetC2::verify_gc_barriers(bool post_parse) const {</span>
<span class="line-removed">1529   ZBarrierSetC2State* s = state();</span>
<span class="line-removed">1530   Compile* C = Compile::current();</span>
<span class="line-removed">1531   ResourceMark rm;</span>
<span class="line-removed">1532   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">1533   for (int i = 0; i &lt; s-&gt;load_barrier_count(); i++) {</span>
<span class="line-removed">1534     LoadBarrierNode* n = s-&gt;load_barrier_node(i);</span>
<span class="line-removed">1535 </span>
<span class="line-removed">1536     // The dominating barrier on the same address if it exists and</span>
<span class="line-removed">1537     // this barrier must not be applied on the value from the same</span>
<span class="line-removed">1538     // load otherwise the value is not reloaded before it&#39;s used the</span>
<span class="line-removed">1539     // second time.</span>
<span class="line-removed">1540     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||</span>
<span class="line-removed">1541            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;</span>
<span class="line-removed">1542             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Address) == n-&gt;in(LoadBarrierNode::Address) &amp;&amp;</span>
<span class="line-removed">1543             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Oop) != n-&gt;in(LoadBarrierNode::Oop)),</span>
<span class="line-removed">1544            &quot;broken similar edge&quot;);</span>
<span class="line-removed">1545 </span>
<span class="line-removed">1546     assert(post_parse || n-&gt;as_LoadBarrier()-&gt;has_true_uses(),</span>
<span class="line-removed">1547            &quot;found unneeded load barrier&quot;);</span>
<span class="line-removed">1548 </span>
<span class="line-removed">1549     // Several load barrier nodes chained through their Similar edge</span>
<span class="line-removed">1550     // break the code that remove the barriers in final graph reshape.</span>
<span class="line-removed">1551     assert(n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top() ||</span>
<span class="line-removed">1552            (n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;is_LoadBarrier() &amp;&amp;</span>
<span class="line-removed">1553             n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0)-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()),</span>
<span class="line-removed">1554            &quot;chain of Similar load barriers&quot;);</span>
<span class="line-removed">1555 </span>
<span class="line-removed">1556     if (!n-&gt;in(LoadBarrierNode::Similar)-&gt;is_top()) {</span>
<span class="line-removed">1557       ResourceMark rm;</span>
<span class="line-removed">1558       Unique_Node_List wq;</span>
<span class="line-removed">1559       Node* other = n-&gt;in(LoadBarrierNode::Similar)-&gt;in(0);</span>
<span class="line-removed">1560       wq.push(n);</span>
<span class="line-removed">1561       bool ok = true;</span>
<span class="line-removed">1562       bool dom_found = false;</span>
<span class="line-removed">1563       for (uint next = 0; next &lt; wq.size(); ++next) {</span>
<span class="line-removed">1564         Node *n = wq.at(next);</span>
<span class="line-removed">1565         assert(n-&gt;is_CFG(), &quot;&quot;);</span>
<span class="line-removed">1566         assert(!n-&gt;is_SafePoint(), &quot;&quot;);</span>
<span class="line-removed">1567 </span>
<span class="line-removed">1568         if (n == other) {</span>
<span class="line-removed">1569           continue;</span>
1570         }
<a name="82" id="anc82"></a><span class="line-modified">1571 </span>
<span class="line-modified">1572         if (n-&gt;is_Region()) {</span>
<span class="line-removed">1573           for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed">1574             Node* m = n-&gt;in(i);</span>
<span class="line-removed">1575             if (m != NULL) {</span>
<span class="line-removed">1576               wq.push(m);</span>
<span class="line-removed">1577             }</span>
<span class="line-removed">1578           }</span>
<span class="line-removed">1579         } else {</span>
<span class="line-removed">1580           Node* m = n-&gt;in(0);</span>
<span class="line-removed">1581           if (m != NULL) {</span>
<span class="line-removed">1582             wq.push(m);</span>
<span class="line-removed">1583           }</span>
1584         }
1585       }
<a name="83" id="anc83"></a><span class="line-removed">1586     }</span>
1587 
<a name="84" id="anc84"></a><span class="line-modified">1588     if (ZVerifyLoadBarriers) {</span>
<span class="line-modified">1589       if ((n-&gt;is_Load() || n-&gt;is_LoadStore()) &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr() != NULL) {</span>
<span class="line-modified">1590         visited.Clear();</span>
<span class="line-modified">1591         bool found = look_for_barrier(n, post_parse, visited);</span>
<span class="line-removed">1592         if (!found) {</span>
<span class="line-removed">1593           n-&gt;dump(1);</span>
<span class="line-removed">1594           n-&gt;dump(-3);</span>
<span class="line-removed">1595           stringStream ss;</span>
<span class="line-removed">1596           C-&gt;method()-&gt;print_short_name(&amp;ss);</span>
<span class="line-removed">1597           tty-&gt;print_cr(&quot;-%s-&quot;, ss.as_string());</span>
<span class="line-removed">1598           assert(found, &quot;&quot;);</span>
<span class="line-removed">1599         }</span>
1600       }
1601     }
<a name="85" id="anc85"></a><span class="line-removed">1602   }</span>
<span class="line-removed">1603 }</span>
<span class="line-removed">1604 </span>
<span class="line-removed">1605 #endif</span>
<span class="line-removed">1606 </span>
<span class="line-removed">1607 bool ZBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {</span>
<span class="line-removed">1608   switch (opcode) {</span>
<span class="line-removed">1609     case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">1610     case Op_LoadBarrierWeakSlowReg:</span>
<span class="line-removed">1611       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);</span>
<span class="line-removed">1612       return true;</span>
<span class="line-removed">1613 </span>
<span class="line-removed">1614     case Op_Proj:</span>
<span class="line-removed">1615       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">1616         return false;</span>
<span class="line-removed">1617       }</span>
<span class="line-removed">1618       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), delayed_worklist);</span>
<span class="line-removed">1619       return true;</span>
<span class="line-removed">1620   }</span>
<span class="line-removed">1621 </span>
<span class="line-removed">1622   return false;</span>
<span class="line-removed">1623 }</span>
1624 
<a name="86" id="anc86"></a><span class="line-modified">1625 bool ZBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {</span>
<span class="line-modified">1626   switch (opcode) {</span>
<span class="line-modified">1627     case Op_LoadBarrierSlowReg:</span>
<span class="line-modified">1628     case Op_LoadBarrierWeakSlowReg:</span>
<span class="line-modified">1629       if (gvn-&gt;type(n)-&gt;make_ptr() == NULL) {</span>
<span class="line-modified">1630         return false;</span>


1631       }
<a name="87" id="anc87"></a><span class="line-modified">1632       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(MemNode::Address), NULL);</span>
<span class="line-removed">1633       return true;</span>
<span class="line-removed">1634 </span>
<span class="line-removed">1635     case Op_Proj:</span>
<span class="line-removed">1636       if (n-&gt;as_Proj()-&gt;_con != LoadBarrierNode::Oop || !n-&gt;in(0)-&gt;is_LoadBarrier()) {</span>
<span class="line-removed">1637         return false;</span>
<span class="line-removed">1638       }</span>
<span class="line-removed">1639       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0)-&gt;in(LoadBarrierNode::Oop), NULL);</span>
<span class="line-removed">1640       return true;</span>
1641   }
<a name="88" id="anc88"></a><span class="line-removed">1642 </span>
<span class="line-removed">1643   return false;</span>
1644 }
<a name="89" id="anc89"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="89" type="hidden" />
</body>
</html>
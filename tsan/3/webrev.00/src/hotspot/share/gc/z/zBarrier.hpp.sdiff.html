<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zBarrier.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zBarrier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zBarrier.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZBARRIER_HPP
 25 #define SHARE_GC_Z_ZBARRIER_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;oops/oop.hpp&quot;
 29 
 30 typedef bool (*ZBarrierFastPath)(uintptr_t);
 31 typedef uintptr_t (*ZBarrierSlowPath)(uintptr_t);
 32 
 33 class ZBarrier : public AllStatic {
 34 private:



 35   static const bool Strong      = false;
 36   static const bool Finalizable = true;
 37 
 38   static const bool Publish     = true;
 39   static const bool Overflow    = false;
 40 


 41   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static oop barrier(volatile oop* p, oop o);
 42   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static oop weak_barrier(volatile oop* p, oop o);
 43   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static void root_barrier(oop* p, oop o);
 44 
<span class="line-removed"> 45   static bool is_null_fast_path(uintptr_t addr);</span>
 46   static bool is_good_or_null_fast_path(uintptr_t addr);
 47   static bool is_weak_good_or_null_fast_path(uintptr_t addr);
<span class="line-modified"> 48 </span>
<span class="line-removed"> 49   static bool is_resurrection_blocked(volatile oop* p, oop* o);</span>
 50 
 51   static bool during_mark();
 52   static bool during_relocate();
 53   template &lt;bool finalizable&gt; static bool should_mark_through(uintptr_t addr);
<span class="line-modified"> 54   template &lt;bool finalizable, bool publish&gt; static uintptr_t mark(uintptr_t addr);</span>
 55   static uintptr_t remap(uintptr_t addr);
 56   static uintptr_t relocate(uintptr_t addr);
 57   static uintptr_t relocate_or_mark(uintptr_t addr);
 58   static uintptr_t relocate_or_remap(uintptr_t addr);
 59 
 60   static uintptr_t load_barrier_on_oop_slow_path(uintptr_t addr);
 61 
 62   static uintptr_t weak_load_barrier_on_oop_slow_path(uintptr_t addr);
 63   static uintptr_t weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr);
 64   static uintptr_t weak_load_barrier_on_phantom_oop_slow_path(uintptr_t addr);
 65 
 66   static uintptr_t keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr);
 67   static uintptr_t keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr);
 68 
 69   static uintptr_t mark_barrier_on_oop_slow_path(uintptr_t addr);
 70   static uintptr_t mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr);
 71   static uintptr_t mark_barrier_on_root_oop_slow_path(uintptr_t addr);

 72 
 73   static uintptr_t relocate_barrier_on_root_oop_slow_path(uintptr_t addr);
 74 
 75 public:
 76   // Load barrier
 77   static  oop load_barrier_on_oop(oop o);
 78   static  oop load_barrier_on_oop_field(volatile oop* p);
 79   static  oop load_barrier_on_oop_field_preloaded(volatile oop* p, oop o);
 80   static void load_barrier_on_oop_array(volatile oop* p, size_t length);
 81   static void load_barrier_on_oop_fields(oop o);
 82   static  oop load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o);
 83   static  oop load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o);
 84   static void load_barrier_on_root_oop_field(oop* p);
 85 
 86   // Weak load barrier
 87   static oop weak_load_barrier_on_oop_field(volatile oop* p);
 88   static oop weak_load_barrier_on_oop_field_preloaded(volatile oop* p, oop o);
 89   static oop weak_load_barrier_on_weak_oop(oop o);
 90   static oop weak_load_barrier_on_weak_oop_field(volatile oop* p);
 91   static oop weak_load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o);
 92   static oop weak_load_barrier_on_phantom_oop(oop o);
 93   static oop weak_load_barrier_on_phantom_oop_field(volatile oop* p);
 94   static oop weak_load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o);
 95 
 96   // Is alive barrier
 97   static bool is_alive_barrier_on_weak_oop(oop o);
 98   static bool is_alive_barrier_on_phantom_oop(oop o);
 99 
100   // Keep alive barrier
101   static void keep_alive_barrier_on_weak_oop_field(volatile oop* p);
102   static void keep_alive_barrier_on_phantom_oop_field(volatile oop* p);
103   static void keep_alive_barrier_on_phantom_root_oop_field(oop* p);

104 
105   // Mark barrier
106   static void mark_barrier_on_oop_field(volatile oop* p, bool finalizable);
107   static void mark_barrier_on_oop_array(volatile oop* p, size_t length, bool finalizable);
108   static void mark_barrier_on_root_oop_field(oop* p);

109 
110   // Relocate barrier
111   static void relocate_barrier_on_root_oop_field(oop* p);
112 
113   // Narrow oop variants, never used.
114   static oop  load_barrier_on_oop_field(volatile narrowOop* p);
115   static oop  load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o);
116   static void load_barrier_on_oop_array(volatile narrowOop* p, size_t length);
117   static oop  load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o);
118   static oop  load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o);
119   static oop  weak_load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o);
120   static oop  weak_load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o);
121   static oop  weak_load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o);
122 };
123 
124 #endif // SHARE_GC_Z_ZBARRIER_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZBARRIER_HPP
 25 #define SHARE_GC_Z_ZBARRIER_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;oops/oop.hpp&quot;
 29 
 30 typedef bool (*ZBarrierFastPath)(uintptr_t);
 31 typedef uintptr_t (*ZBarrierSlowPath)(uintptr_t);
 32 
 33 class ZBarrier : public AllStatic {
 34 private:
<span class="line-added"> 35   static const bool Follow      = true;</span>
<span class="line-added"> 36   static const bool DontFollow  = false;</span>
<span class="line-added"> 37 </span>
 38   static const bool Strong      = false;
 39   static const bool Finalizable = true;
 40 
 41   static const bool Publish     = true;
 42   static const bool Overflow    = false;
 43 
<span class="line-added"> 44   template &lt;ZBarrierFastPath fast_path&gt; static void self_heal(volatile oop* p, uintptr_t addr, uintptr_t heal_addr);</span>
<span class="line-added"> 45 </span>
 46   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static oop barrier(volatile oop* p, oop o);
 47   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static oop weak_barrier(volatile oop* p, oop o);
 48   template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt; static void root_barrier(oop* p, oop o);
 49 

 50   static bool is_good_or_null_fast_path(uintptr_t addr);
 51   static bool is_weak_good_or_null_fast_path(uintptr_t addr);
<span class="line-modified"> 52   static bool is_marked_or_null_fast_path(uintptr_t addr);</span>

 53 
 54   static bool during_mark();
 55   static bool during_relocate();
 56   template &lt;bool finalizable&gt; static bool should_mark_through(uintptr_t addr);
<span class="line-modified"> 57   template &lt;bool follow, bool finalizable, bool publish&gt; static uintptr_t mark(uintptr_t addr);</span>
 58   static uintptr_t remap(uintptr_t addr);
 59   static uintptr_t relocate(uintptr_t addr);
 60   static uintptr_t relocate_or_mark(uintptr_t addr);
 61   static uintptr_t relocate_or_remap(uintptr_t addr);
 62 
 63   static uintptr_t load_barrier_on_oop_slow_path(uintptr_t addr);
 64 
 65   static uintptr_t weak_load_barrier_on_oop_slow_path(uintptr_t addr);
 66   static uintptr_t weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr);
 67   static uintptr_t weak_load_barrier_on_phantom_oop_slow_path(uintptr_t addr);
 68 
 69   static uintptr_t keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr);
 70   static uintptr_t keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr);
 71 
 72   static uintptr_t mark_barrier_on_oop_slow_path(uintptr_t addr);
 73   static uintptr_t mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr);
 74   static uintptr_t mark_barrier_on_root_oop_slow_path(uintptr_t addr);
<span class="line-added"> 75   static uintptr_t mark_barrier_on_invisible_root_oop_slow_path(uintptr_t addr);</span>
 76 
 77   static uintptr_t relocate_barrier_on_root_oop_slow_path(uintptr_t addr);
 78 
 79 public:
 80   // Load barrier
 81   static  oop load_barrier_on_oop(oop o);
 82   static  oop load_barrier_on_oop_field(volatile oop* p);
 83   static  oop load_barrier_on_oop_field_preloaded(volatile oop* p, oop o);
 84   static void load_barrier_on_oop_array(volatile oop* p, size_t length);
 85   static void load_barrier_on_oop_fields(oop o);
 86   static  oop load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o);
 87   static  oop load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o);
 88   static void load_barrier_on_root_oop_field(oop* p);
 89 
 90   // Weak load barrier
 91   static oop weak_load_barrier_on_oop_field(volatile oop* p);
 92   static oop weak_load_barrier_on_oop_field_preloaded(volatile oop* p, oop o);
 93   static oop weak_load_barrier_on_weak_oop(oop o);
 94   static oop weak_load_barrier_on_weak_oop_field(volatile oop* p);
 95   static oop weak_load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o);
 96   static oop weak_load_barrier_on_phantom_oop(oop o);
 97   static oop weak_load_barrier_on_phantom_oop_field(volatile oop* p);
 98   static oop weak_load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o);
 99 
100   // Is alive barrier
101   static bool is_alive_barrier_on_weak_oop(oop o);
102   static bool is_alive_barrier_on_phantom_oop(oop o);
103 
104   // Keep alive barrier
105   static void keep_alive_barrier_on_weak_oop_field(volatile oop* p);
106   static void keep_alive_barrier_on_phantom_oop_field(volatile oop* p);
107   static void keep_alive_barrier_on_phantom_root_oop_field(oop* p);
<span class="line-added">108   static void keep_alive_barrier_on_oop(oop o);</span>
109 
110   // Mark barrier
111   static void mark_barrier_on_oop_field(volatile oop* p, bool finalizable);
112   static void mark_barrier_on_oop_array(volatile oop* p, size_t length, bool finalizable);
113   static void mark_barrier_on_root_oop_field(oop* p);
<span class="line-added">114   static void mark_barrier_on_invisible_root_oop_field(oop* p);</span>
115 
116   // Relocate barrier
117   static void relocate_barrier_on_root_oop_field(oop* p);
118 
119   // Narrow oop variants, never used.
120   static oop  load_barrier_on_oop_field(volatile narrowOop* p);
121   static oop  load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o);
122   static void load_barrier_on_oop_array(volatile narrowOop* p, size_t length);
123   static oop  load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o);
124   static oop  load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o);
125   static oop  weak_load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o);
126   static oop  weak_load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o);
127   static oop  weak_load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o);
128 };
129 
130 #endif // SHARE_GC_Z_ZBARRIER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zBarrier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
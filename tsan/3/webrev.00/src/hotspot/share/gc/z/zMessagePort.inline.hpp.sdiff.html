<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMessagePort.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMemory.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMetronome.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMessagePort.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 62     _result.set(message);
 63   }
 64 };
 65 
 66 template &lt;typename T&gt;
 67 inline ZMessagePort&lt;T&gt;::ZMessagePort() :
 68     _monitor(Monitor::leaf,
 69              &quot;ZMessagePort&quot;,
 70              Monitor::_allow_vm_block_flag,
 71              Monitor::_safepoint_check_never),
 72     _has_message(false),
 73     _seqnum(0),
 74     _queue() {}
 75 
 76 template &lt;typename T&gt;
 77 inline void ZMessagePort&lt;T&gt;::send_sync(T message) {
 78   Request request;
 79 
 80   {
 81     // Enqueue message
<span class="line-modified"> 82     MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
 83     request.initialize(message, _seqnum);
 84     _queue.insert_last(&amp;request);
 85     ml.notify();
 86   }
 87 
 88   // Wait for completion
 89   request.wait();
 90 
 91   {
 92     // Guard deletion of underlying semaphore. This is a workaround for a
 93     // bug in sem_post() in glibc &lt; 2.21, where it&#39;s not safe to destroy
 94     // the semaphore immediately after returning from sem_wait(). The
 95     // reason is that sem_post() can touch the semaphore after a waiting
 96     // thread have returned from sem_wait(). To avoid this race we are
 97     // forcing the waiting thread to acquire/release the lock held by the
 98     // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<span class="line-modified"> 99     MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
100   }
101 }
102 
103 template &lt;typename T&gt;
104 inline void ZMessagePort&lt;T&gt;::send_async(T message) {
<span class="line-modified">105   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
106   if (!_has_message) {
107     // Post message
108     _message = message;
109     _has_message = true;
110     ml.notify();
111   }
112 }
113 
114 template &lt;typename T&gt;
115 inline T ZMessagePort&lt;T&gt;::receive() {
<span class="line-modified">116   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
117 
118   // Wait for message
119   while (!_has_message &amp;&amp; _queue.is_empty()) {
<span class="line-modified">120     ml.wait(Monitor::_no_safepoint_check_flag);</span>
121   }
122 
123   // Increment request sequence number
124   _seqnum++;
125 
126   if (!_has_message) {
127     // Message available in the queue
128     _message = _queue.first()-&gt;message();
129     _has_message = true;
130   }
131 
132   return _message;
133 }
134 
135 template &lt;typename T&gt;
136 inline void ZMessagePort&lt;T&gt;::ack() {
<span class="line-modified">137   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
138 
139   if (!_has_message) {
140     // Nothing to ack
141     return;
142   }
143 
144   // Satisfy requests (and duplicates) in queue
145   ZListIterator&lt;Request&gt; iter(&amp;_queue);
146   for (Request* request; iter.next(&amp;request);) {
147     if (request-&gt;message() == _message &amp;&amp; request-&gt;seqnum() &lt; _seqnum) {
148       // Dequeue and satisfy request. Note that the dequeue operation must
149       // happen first, since the request will immediately be deallocated
150       // once it has been satisfied.
151       _queue.remove(request);
152       request-&gt;satisfy(_message);
153     }
154   }
155 
156   if (_queue.is_empty()) {
157     // Queue is empty
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 62     _result.set(message);
 63   }
 64 };
 65 
 66 template &lt;typename T&gt;
 67 inline ZMessagePort&lt;T&gt;::ZMessagePort() :
 68     _monitor(Monitor::leaf,
 69              &quot;ZMessagePort&quot;,
 70              Monitor::_allow_vm_block_flag,
 71              Monitor::_safepoint_check_never),
 72     _has_message(false),
 73     _seqnum(0),
 74     _queue() {}
 75 
 76 template &lt;typename T&gt;
 77 inline void ZMessagePort&lt;T&gt;::send_sync(T message) {
 78   Request request;
 79 
 80   {
 81     // Enqueue message
<span class="line-modified"> 82     MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
 83     request.initialize(message, _seqnum);
 84     _queue.insert_last(&amp;request);
 85     ml.notify();
 86   }
 87 
 88   // Wait for completion
 89   request.wait();
 90 
 91   {
 92     // Guard deletion of underlying semaphore. This is a workaround for a
 93     // bug in sem_post() in glibc &lt; 2.21, where it&#39;s not safe to destroy
 94     // the semaphore immediately after returning from sem_wait(). The
 95     // reason is that sem_post() can touch the semaphore after a waiting
 96     // thread have returned from sem_wait(). To avoid this race we are
 97     // forcing the waiting thread to acquire/release the lock held by the
 98     // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<span class="line-modified"> 99     MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
100   }
101 }
102 
103 template &lt;typename T&gt;
104 inline void ZMessagePort&lt;T&gt;::send_async(T message) {
<span class="line-modified">105   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
106   if (!_has_message) {
107     // Post message
108     _message = message;
109     _has_message = true;
110     ml.notify();
111   }
112 }
113 
114 template &lt;typename T&gt;
115 inline T ZMessagePort&lt;T&gt;::receive() {
<span class="line-modified">116   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
117 
118   // Wait for message
119   while (!_has_message &amp;&amp; _queue.is_empty()) {
<span class="line-modified">120     ml.wait();</span>
121   }
122 
123   // Increment request sequence number
124   _seqnum++;
125 
126   if (!_has_message) {
127     // Message available in the queue
128     _message = _queue.first()-&gt;message();
129     _has_message = true;
130   }
131 
132   return _message;
133 }
134 
135 template &lt;typename T&gt;
136 inline void ZMessagePort&lt;T&gt;::ack() {
<span class="line-modified">137   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
138 
139   if (!_has_message) {
140     // Nothing to ack
141     return;
142   }
143 
144   // Satisfy requests (and duplicates) in queue
145   ZListIterator&lt;Request&gt; iter(&amp;_queue);
146   for (Request* request; iter.next(&amp;request);) {
147     if (request-&gt;message() == _message &amp;&amp; request-&gt;seqnum() &lt; _seqnum) {
148       // Dequeue and satisfy request. Note that the dequeue operation must
149       // happen first, since the request will immediately be deallocated
150       // once it has been satisfied.
151       _queue.remove(request);
152       request-&gt;satisfy(_message);
153     }
154   }
155 
156   if (_queue.is_empty()) {
157     // Queue is empty
</pre>
</td>
</tr>
</table>
<center><a href="zMemory.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMetronome.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
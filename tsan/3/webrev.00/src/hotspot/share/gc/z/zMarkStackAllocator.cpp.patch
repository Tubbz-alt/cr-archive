diff a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
--- a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
+++ b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
@@ -68,11 +68,11 @@
     if (new_top > end) {
       // Not enough space left
       return 0;
     }
 
-    const uintptr_t prev_top = Atomic::cmpxchg(new_top, &_top, top);
+    const uintptr_t prev_top = Atomic::cmpxchg(&_top, top, new_top);
     if (prev_top == top) {
       // Success
       return top;
     }
 
@@ -108,12 +108,12 @@
   // Expand
   os::commit_memory_or_exit((char*)_end, expand_size, false /* executable */, "Mark stack space");
 
   // Increment top before end to make sure another
   // thread can't steal out newly expanded space.
-  addr = Atomic::add(size, &_top) - size;
-  Atomic::add(expand_size, &_end);
+  addr = Atomic::fetch_and_add(&_top, size);
+  Atomic::add(&_end, expand_size);
 
   return addr;
 }
 
 uintptr_t ZMarkStackSpace::alloc(size_t size) {
@@ -164,11 +164,11 @@
   return magazine;
 }
 
 ZMarkStackMagazine* ZMarkStackAllocator::alloc_magazine() {
   // Try allocating from the free list first
-  ZMarkStackMagazine* const magazine = _freelist.pop_atomic();
+  ZMarkStackMagazine* const magazine = _freelist.pop();
   if (magazine != NULL) {
     return magazine;
   }
 
   // Allocate new magazine
@@ -179,7 +179,7 @@
 
   return create_magazine_from_space(addr, ZMarkStackMagazineSize);
 }
 
 void ZMarkStackAllocator::free_magazine(ZMarkStackMagazine* magazine) {
-  _freelist.push_atomic(magazine);
+  _freelist.push(magazine);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMarkStackAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMarkStack.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMarkStackAllocator.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMarkStackAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53 
 54   // Register mark stack space start
 55   ZMarkStackSpaceStart = _start;
 56 }
 57 
 58 bool ZMarkStackSpace::is_initialized() const {
 59   return _start != 0;
 60 }
 61 
 62 uintptr_t ZMarkStackSpace::alloc_space(size_t size) {
 63   uintptr_t top = Atomic::load(&amp;_top);
 64 
 65   for (;;) {
 66     const uintptr_t end = Atomic::load(&amp;_end);
 67     const uintptr_t new_top = top + size;
 68     if (new_top &gt; end) {
 69       // Not enough space left
 70       return 0;
 71     }
 72 
<span class="line-modified"> 73     const uintptr_t prev_top = Atomic::cmpxchg(new_top, &amp;_top, top);</span>
 74     if (prev_top == top) {
 75       // Success
 76       return top;
 77     }
 78 
 79     // Retry
 80     top = prev_top;
 81   }
 82 }
 83 
 84 uintptr_t ZMarkStackSpace::expand_and_alloc_space(size_t size) {
 85   ZLocker&lt;ZLock&gt; locker(&amp;_expand_lock);
 86 
 87   // Retry allocation before expanding
 88   uintptr_t addr = alloc_space(size);
 89   if (addr != 0) {
 90     return addr;
 91   }
 92 
 93   // Check expansion limit
 94   const size_t expand_size = ZMarkStackSpaceExpandSize;
 95   const size_t old_size = _end - _start;
 96   const size_t new_size = old_size + expand_size;
 97   if (new_size &gt; ZMarkStackSpaceLimit) {
 98     // Expansion limit reached. This is a fatal error since we
 99     // currently can&#39;t recover from running out of mark stack space.
100     fatal(&quot;Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=&lt;size&gt; to increase the &quot;
101           &quot;maximum number of bytes allocated for mark stacks. Current limit is &quot; SIZE_FORMAT &quot;M.&quot;,
102           ZMarkStackSpaceLimit / M);
103   }
104 
105   log_debug(gc, marking)(&quot;Expanding mark stack space: &quot; SIZE_FORMAT &quot;M-&gt;&quot; SIZE_FORMAT &quot;M&quot;,
106                          old_size / M, new_size / M);
107 
108   // Expand
109   os::commit_memory_or_exit((char*)_end, expand_size, false /* executable */, &quot;Mark stack space&quot;);
110 
111   // Increment top before end to make sure another
112   // thread can&#39;t steal out newly expanded space.
<span class="line-modified">113   addr = Atomic::add(size, &amp;_top) - size;</span>
<span class="line-modified">114   Atomic::add(expand_size, &amp;_end);</span>
115 
116   return addr;
117 }
118 
119 uintptr_t ZMarkStackSpace::alloc(size_t size) {
120   const uintptr_t addr = alloc_space(size);
121   if (addr != 0) {
122     return addr;
123   }
124 
125   return expand_and_alloc_space(size);
126 }
127 
128 ZMarkStackAllocator::ZMarkStackAllocator() :
129     _freelist(),
130     _space() {
131   guarantee(sizeof(ZMarkStack) == ZMarkStackSize, &quot;Size mismatch&quot;);
132   guarantee(sizeof(ZMarkStackMagazine) &lt;= ZMarkStackSize, &quot;Size mismatch&quot;);
133 
134   // Prime free list to avoid an immediate space
</pre>
<hr />
<pre>
149     free_magazine(magazine);
150   }
151 }
152 
153 ZMarkStackMagazine* ZMarkStackAllocator::create_magazine_from_space(uintptr_t addr, size_t size) {
154   assert(is_aligned(size, ZMarkStackSize), &quot;Invalid size&quot;);
155 
156   // Use first stack as magazine
157   ZMarkStackMagazine* const magazine = new ((void*)addr) ZMarkStackMagazine();
158   for (size_t i = ZMarkStackSize; i &lt; size; i += ZMarkStackSize) {
159     ZMarkStack* const stack = new ((void*)(addr + i)) ZMarkStack();
160     const bool success = magazine-&gt;push(stack);
161     assert(success, &quot;Magazine should never get full&quot;);
162   }
163 
164   return magazine;
165 }
166 
167 ZMarkStackMagazine* ZMarkStackAllocator::alloc_magazine() {
168   // Try allocating from the free list first
<span class="line-modified">169   ZMarkStackMagazine* const magazine = _freelist.pop_atomic();</span>
170   if (magazine != NULL) {
171     return magazine;
172   }
173 
174   // Allocate new magazine
175   const uintptr_t addr = _space.alloc(ZMarkStackMagazineSize);
176   if (addr == 0) {
177     return NULL;
178   }
179 
180   return create_magazine_from_space(addr, ZMarkStackMagazineSize);
181 }
182 
183 void ZMarkStackAllocator::free_magazine(ZMarkStackMagazine* magazine) {
<span class="line-modified">184   _freelist.push_atomic(magazine);</span>
185 }
</pre>
</td>
<td>
<hr />
<pre>
 53 
 54   // Register mark stack space start
 55   ZMarkStackSpaceStart = _start;
 56 }
 57 
 58 bool ZMarkStackSpace::is_initialized() const {
 59   return _start != 0;
 60 }
 61 
 62 uintptr_t ZMarkStackSpace::alloc_space(size_t size) {
 63   uintptr_t top = Atomic::load(&amp;_top);
 64 
 65   for (;;) {
 66     const uintptr_t end = Atomic::load(&amp;_end);
 67     const uintptr_t new_top = top + size;
 68     if (new_top &gt; end) {
 69       // Not enough space left
 70       return 0;
 71     }
 72 
<span class="line-modified"> 73     const uintptr_t prev_top = Atomic::cmpxchg(&amp;_top, top, new_top);</span>
 74     if (prev_top == top) {
 75       // Success
 76       return top;
 77     }
 78 
 79     // Retry
 80     top = prev_top;
 81   }
 82 }
 83 
 84 uintptr_t ZMarkStackSpace::expand_and_alloc_space(size_t size) {
 85   ZLocker&lt;ZLock&gt; locker(&amp;_expand_lock);
 86 
 87   // Retry allocation before expanding
 88   uintptr_t addr = alloc_space(size);
 89   if (addr != 0) {
 90     return addr;
 91   }
 92 
 93   // Check expansion limit
 94   const size_t expand_size = ZMarkStackSpaceExpandSize;
 95   const size_t old_size = _end - _start;
 96   const size_t new_size = old_size + expand_size;
 97   if (new_size &gt; ZMarkStackSpaceLimit) {
 98     // Expansion limit reached. This is a fatal error since we
 99     // currently can&#39;t recover from running out of mark stack space.
100     fatal(&quot;Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=&lt;size&gt; to increase the &quot;
101           &quot;maximum number of bytes allocated for mark stacks. Current limit is &quot; SIZE_FORMAT &quot;M.&quot;,
102           ZMarkStackSpaceLimit / M);
103   }
104 
105   log_debug(gc, marking)(&quot;Expanding mark stack space: &quot; SIZE_FORMAT &quot;M-&gt;&quot; SIZE_FORMAT &quot;M&quot;,
106                          old_size / M, new_size / M);
107 
108   // Expand
109   os::commit_memory_or_exit((char*)_end, expand_size, false /* executable */, &quot;Mark stack space&quot;);
110 
111   // Increment top before end to make sure another
112   // thread can&#39;t steal out newly expanded space.
<span class="line-modified">113   addr = Atomic::fetch_and_add(&amp;_top, size);</span>
<span class="line-modified">114   Atomic::add(&amp;_end, expand_size);</span>
115 
116   return addr;
117 }
118 
119 uintptr_t ZMarkStackSpace::alloc(size_t size) {
120   const uintptr_t addr = alloc_space(size);
121   if (addr != 0) {
122     return addr;
123   }
124 
125   return expand_and_alloc_space(size);
126 }
127 
128 ZMarkStackAllocator::ZMarkStackAllocator() :
129     _freelist(),
130     _space() {
131   guarantee(sizeof(ZMarkStack) == ZMarkStackSize, &quot;Size mismatch&quot;);
132   guarantee(sizeof(ZMarkStackMagazine) &lt;= ZMarkStackSize, &quot;Size mismatch&quot;);
133 
134   // Prime free list to avoid an immediate space
</pre>
<hr />
<pre>
149     free_magazine(magazine);
150   }
151 }
152 
153 ZMarkStackMagazine* ZMarkStackAllocator::create_magazine_from_space(uintptr_t addr, size_t size) {
154   assert(is_aligned(size, ZMarkStackSize), &quot;Invalid size&quot;);
155 
156   // Use first stack as magazine
157   ZMarkStackMagazine* const magazine = new ((void*)addr) ZMarkStackMagazine();
158   for (size_t i = ZMarkStackSize; i &lt; size; i += ZMarkStackSize) {
159     ZMarkStack* const stack = new ((void*)(addr + i)) ZMarkStack();
160     const bool success = magazine-&gt;push(stack);
161     assert(success, &quot;Magazine should never get full&quot;);
162   }
163 
164   return magazine;
165 }
166 
167 ZMarkStackMagazine* ZMarkStackAllocator::alloc_magazine() {
168   // Try allocating from the free list first
<span class="line-modified">169   ZMarkStackMagazine* const magazine = _freelist.pop();</span>
170   if (magazine != NULL) {
171     return magazine;
172   }
173 
174   // Allocate new magazine
175   const uintptr_t addr = _space.alloc(ZMarkStackMagazineSize);
176   if (addr == 0) {
177     return NULL;
178   }
179 
180   return create_magazine_from_space(addr, ZMarkStackMagazineSize);
181 }
182 
183 void ZMarkStackAllocator::free_magazine(ZMarkStackMagazine* magazine) {
<span class="line-modified">184   _freelist.push(magazine);</span>
185 }
</pre>
</td>
</tr>
</table>
<center><a href="zMarkStack.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMarkStackAllocator.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
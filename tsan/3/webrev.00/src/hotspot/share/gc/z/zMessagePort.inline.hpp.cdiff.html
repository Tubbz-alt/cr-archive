<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zMessagePort.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMemory.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMetronome.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMessagePort.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
  inline void ZMessagePort&lt;T&gt;::send_sync(T message) {
    Request request;
  
    {
      // Enqueue message
<span class="line-modified">!     MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
      request.initialize(message, _seqnum);
      _queue.insert_last(&amp;request);
      ml.notify();
    }
  
<span class="line-new-header">--- 77,11 ---</span>
  inline void ZMessagePort&lt;T&gt;::send_sync(T message) {
    Request request;
  
    {
      // Enqueue message
<span class="line-modified">!     MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
      request.initialize(message, _seqnum);
      _queue.insert_last(&amp;request);
      ml.notify();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,32 ***</span>
      // the semaphore immediately after returning from sem_wait(). The
      // reason is that sem_post() can touch the semaphore after a waiting
      // thread have returned from sem_wait(). To avoid this race we are
      // forcing the waiting thread to acquire/release the lock held by the
      // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<span class="line-modified">!     MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
    }
  }
  
  template &lt;typename T&gt;
  inline void ZMessagePort&lt;T&gt;::send_async(T message) {
<span class="line-modified">!   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
    if (!_has_message) {
      // Post message
      _message = message;
      _has_message = true;
      ml.notify();
    }
  }
  
  template &lt;typename T&gt;
  inline T ZMessagePort&lt;T&gt;::receive() {
<span class="line-modified">!   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
  
    // Wait for message
    while (!_has_message &amp;&amp; _queue.is_empty()) {
<span class="line-modified">!     ml.wait(Monitor::_no_safepoint_check_flag);</span>
    }
  
    // Increment request sequence number
    _seqnum++;
  
<span class="line-new-header">--- 94,32 ---</span>
      // the semaphore immediately after returning from sem_wait(). The
      // reason is that sem_post() can touch the semaphore after a waiting
      // thread have returned from sem_wait(). To avoid this race we are
      // forcing the waiting thread to acquire/release the lock held by the
      // posting thread. https://sourceware.org/bugzilla/show_bug.cgi?id=12674
<span class="line-modified">!     MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
    }
  }
  
  template &lt;typename T&gt;
  inline void ZMessagePort&lt;T&gt;::send_async(T message) {
<span class="line-modified">!   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
    if (!_has_message) {
      // Post message
      _message = message;
      _has_message = true;
      ml.notify();
    }
  }
  
  template &lt;typename T&gt;
  inline T ZMessagePort&lt;T&gt;::receive() {
<span class="line-modified">!   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
  
    // Wait for message
    while (!_has_message &amp;&amp; _queue.is_empty()) {
<span class="line-modified">!     ml.wait();</span>
    }
  
    // Increment request sequence number
    _seqnum++;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
    return _message;
  }
  
  template &lt;typename T&gt;
  inline void ZMessagePort&lt;T&gt;::ack() {
<span class="line-modified">!   MonitorLockerEx ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
  
    if (!_has_message) {
      // Nothing to ack
      return;
    }
<span class="line-new-header">--- 132,11 ---</span>
    return _message;
  }
  
  template &lt;typename T&gt;
  inline void ZMessagePort&lt;T&gt;::ack() {
<span class="line-modified">!   MonitorLocker ml(&amp;_monitor, Monitor::_no_safepoint_check_flag);</span>
  
    if (!_has_message) {
      // Nothing to ack
      return;
    }
</pre>
<center><a href="zMemory.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMetronome.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
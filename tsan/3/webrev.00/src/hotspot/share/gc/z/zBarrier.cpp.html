<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zHeap.inline.hpp&quot;
 27 #include &quot;gc/z/zOop.inline.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;memory/iterator.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 
 34 template &lt;bool finalizable&gt;
 35 bool ZBarrier::should_mark_through(uintptr_t addr) {
 36   // Finalizable marked oops can still exists on the heap after marking
 37   // has completed, in which case we just want to convert this into a
 38   // good oop and not push it on the mark stack.
 39   if (!during_mark()) {
 40     assert(ZAddress::is_marked(addr), &quot;Should be marked&quot;);
 41     assert(ZAddress::is_finalizable(addr), &quot;Should be finalizable&quot;);
 42     return false;
 43   }
 44 
 45   // During marking, we mark through already marked oops to avoid having
 46   // some large part of the object graph hidden behind a pushed, but not
 47   // yet flushed, entry on a mutator mark stack. Always marking through
 48   // allows the GC workers to proceed through the object graph even if a
 49   // mutator touched an oop first, which in turn will reduce the risk of
 50   // having to flush mark stacks multiple times to terminate marking.
 51   //
 52   // However, when doing finalizable marking we don&#39;t always want to mark
 53   // through. First, marking through an already strongly marked oop would
 54   // be wasteful, since we will then proceed to do finalizable marking on
 55   // an object which is, or will be, marked strongly. Second, marking
 56   // through an already finalizable marked oop would also be wasteful,
 57   // since such oops can never end up on a mutator mark stack and can
 58   // therefore not hide some part of the object graph from GC workers.
 59   if (finalizable) {
 60     return !ZAddress::is_marked(addr);
 61   }
 62 
 63   // Mark through
 64   return true;
 65 }
 66 
 67 template &lt;bool follow, bool finalizable, bool publish&gt;
 68 uintptr_t ZBarrier::mark(uintptr_t addr) {
 69   uintptr_t good_addr;
 70 
 71   if (ZAddress::is_marked(addr)) {
 72     // Already marked, but try to mark though anyway
 73     good_addr = ZAddress::good(addr);
 74   } else if (ZAddress::is_remapped(addr)) {
 75     // Already remapped, but also needs to be marked
 76     good_addr = ZAddress::good(addr);
 77   } else {
 78     // Needs to be both remapped and marked
 79     good_addr = remap(addr);
 80   }
 81 
 82   // Mark
 83   if (should_mark_through&lt;finalizable&gt;(addr)) {
 84     ZHeap::heap()-&gt;mark_object&lt;follow, finalizable, publish&gt;(good_addr);
 85   }
 86 
 87   if (finalizable) {
 88     // Make the oop finalizable marked/good, instead of normal marked/good.
 89     // This is needed because an object might first becomes finalizable
 90     // marked by the GC, and then loaded by a mutator thread. In this case,
 91     // the mutator thread must be able to tell that the object needs to be
 92     // strongly marked. The finalizable bit in the oop exists to make sure
 93     // that a load of a finalizable marked oop will fall into the barrier
 94     // slow path so that we can mark the object as strongly reachable.
 95     return ZAddress::finalizable_good(good_addr);
 96   }
 97 
 98   return good_addr;
 99 }
100 
101 uintptr_t ZBarrier::remap(uintptr_t addr) {
102   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
103   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
104   return ZHeap::heap()-&gt;remap_object(addr);
105 }
106 
107 uintptr_t ZBarrier::relocate(uintptr_t addr) {
108   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
109   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
110   return ZHeap::heap()-&gt;relocate_object(addr);
111 }
112 
113 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
114   return during_relocate() ? relocate(addr) : mark&lt;Follow, Strong, Publish&gt;(addr);
115 }
116 
117 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
118   return during_relocate() ? relocate(addr) : remap(addr);
119 }
120 
121 //
122 // Load barrier
123 //
124 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
125   return relocate_or_mark(addr);
126 }
127 
128 void ZBarrier::load_barrier_on_oop_fields(oop o) {
129   assert(ZAddress::is_good(ZOop::to_address(o)), &quot;Should be good&quot;);
130   ZLoadBarrierOopClosure cl;
131   o-&gt;oop_iterate(&amp;cl);
132 }
133 
134 //
135 // Weak load barrier
136 //
137 uintptr_t ZBarrier::weak_load_barrier_on_oop_slow_path(uintptr_t addr) {
138   return ZAddress::is_weak_good(addr) ? ZAddress::good(addr) : relocate_or_remap(addr);
139 }
140 
141 uintptr_t ZBarrier::weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr) {
142   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
143   if (ZHeap::heap()-&gt;is_object_strongly_live(good_addr)) {
144     return good_addr;
145   }
146 
147   // Not strongly live
148   return 0;
149 }
150 
151 uintptr_t ZBarrier::weak_load_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
152   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
153   if (ZHeap::heap()-&gt;is_object_live(good_addr)) {
154     return good_addr;
155   }
156 
157   // Not live
158   return 0;
159 }
160 
161 //
162 // Keep alive barrier
163 //
164 uintptr_t ZBarrier::keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr) {
165   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
166   assert(ZHeap::heap()-&gt;is_object_strongly_live(good_addr), &quot;Should be live&quot;);
167   return good_addr;
168 }
169 
170 uintptr_t ZBarrier::keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
171   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
172   assert(ZHeap::heap()-&gt;is_object_live(good_addr), &quot;Should be live&quot;);
173   return good_addr;
174 }
175 
176 //
177 // Mark barrier
178 //
179 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
180   assert(during_mark(), &quot;Invalid phase&quot;);
181 
182   // Mark
183   return mark&lt;Follow, Strong, Overflow&gt;(addr);
184 }
185 
186 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
187   assert(during_mark(), &quot;Invalid phase&quot;);
188 
189   // Mark
190   return mark&lt;Follow, Finalizable, Overflow&gt;(addr);
191 }
192 
193 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
194   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
195   assert(during_mark(), &quot;Invalid phase&quot;);
196 
197   // Mark
198   return mark&lt;Follow, Strong, Publish&gt;(addr);
199 }
200 
201 uintptr_t ZBarrier::mark_barrier_on_invisible_root_oop_slow_path(uintptr_t addr) {
202   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
203   assert(during_mark(), &quot;Invalid phase&quot;);
204 
205   // Mark
206   return mark&lt;DontFollow, Strong, Publish&gt;(addr);
207 }
208 
209 //
210 // Relocate barrier
211 //
212 uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {
213   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
214   assert(during_relocate(), &quot;Invalid phase&quot;);
215 
216   // Relocate
217   return relocate(addr);
218 }
219 
220 //
221 // Narrow oop variants, never used.
222 //
223 oop ZBarrier::load_barrier_on_oop_field(volatile narrowOop* p) {
224   ShouldNotReachHere();
225   return NULL;
226 }
227 
228 oop ZBarrier::load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
229   ShouldNotReachHere();
230   return NULL;
231 }
232 
233 void ZBarrier::load_barrier_on_oop_array(volatile narrowOop* p, size_t length) {
234   ShouldNotReachHere();
235 }
236 
237 oop ZBarrier::load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
238   ShouldNotReachHere();
239   return NULL;
240 }
241 
242 oop ZBarrier::load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
243   ShouldNotReachHere();
244   return NULL;
245 }
246 
247 oop ZBarrier::weak_load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
248   ShouldNotReachHere();
249   return NULL;
250 }
251 
252 oop ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
253   ShouldNotReachHere();
254   return NULL;
255 }
256 
257 oop ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
258   ShouldNotReachHere();
259   return NULL;
260 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/gc/z/zVirtualMemory.cpp b/src/hotspot/share/gc/z/zVirtualMemory.cpp
--- a/src/hotspot/share/gc/z/zVirtualMemory.cpp
+++ b/src/hotspot/share/gc/z/zVirtualMemory.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,32 +20,130 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "precompiled.hpp"
+#include "gc/z/zAddressSpaceLimit.hpp"
 #include "gc/z/zGlobals.hpp"
 #include "gc/z/zVirtualMemory.inline.hpp"
+#include "logging/log.hpp"
 #include "services/memTracker.hpp"
+#include "utilities/debug.hpp"
+#include "utilities/align.hpp"
 
-ZVirtualMemoryManager::ZVirtualMemoryManager() :
+ZVirtualMemoryManager::ZVirtualMemoryManager(size_t max_capacity) :
     _manager(),
     _initialized(false) {
-  // Reserve address space
-  if (!reserve(ZAddressSpaceStart, ZAddressSpaceSize)) {
+
+  // Check max supported heap size
+  if (max_capacity > ZAddressOffsetMax) {
+    log_error(gc)("Java heap too large (max supported heap size is " SIZE_FORMAT "G)",
+                  ZAddressOffsetMax / G);
     return;
   }
 
-  // Make the complete address view free
-  _manager.free(0, ZAddressOffsetMax);
+  // Reserve address space
+  if (!reserve(max_capacity)) {
+    log_error(gc)("Failed to reserve enough address space for Java heap");
+    return;
+  }
 
-  // Register address space with native memory tracker
-  nmt_reserve(ZAddressSpaceStart, ZAddressSpaceSize);
+  // Initialize OS specific parts
+  initialize_os();
 
   // Successfully initialized
   _initialized = true;
 }
 
+size_t ZVirtualMemoryManager::reserve_discontiguous(uintptr_t start, size_t size, size_t min_range) {
+  if (size < min_range) {
+    // Too small
+    return 0;
+  }
+
+  assert(is_aligned(size, ZGranuleSize), "Misaligned");
+
+  if (reserve_contiguous_platform(start, size)) {
+    // Make the address range free
+    _manager.free(start, size);
+    return size;
+  }
+
+  const size_t half = size / 2;
+  if (half < min_range) {
+    // Too small
+    return 0;
+  }
+
+  // Divide and conquer
+  const size_t first_part = align_down(half, ZGranuleSize);
+  const size_t second_part = size - first_part;
+  return reserve_discontiguous(start, first_part, min_range) +
+         reserve_discontiguous(start + first_part, second_part, min_range);
+}
+
+size_t ZVirtualMemoryManager::reserve_discontiguous(size_t size) {
+  // Don't try to reserve address ranges smaller than 1% of the requested size.
+  // This avoids an explosion of reservation attempts in case large parts of the
+  // address space is already occupied.
+  const size_t min_range = align_up(size / 100, ZGranuleSize);
+  size_t start = 0;
+  size_t reserved = 0;
+
+  // Reserve size somewhere between [0, ZAddressOffsetMax)
+  while (reserved < size && start < ZAddressOffsetMax) {
+    const size_t remaining = MIN2(size - reserved, ZAddressOffsetMax - start);
+    reserved += reserve_discontiguous(start, remaining, min_range);
+    start += remaining;
+  }
+
+  return reserved;
+}
+
+bool ZVirtualMemoryManager::reserve_contiguous(size_t size) {
+  // Allow at most 8192 attempts spread evenly across [0, ZAddressOffsetMax)
+  const size_t end = ZAddressOffsetMax - size;
+  const size_t increment = align_up(end / 8192, ZGranuleSize);
+
+  for (size_t start = 0; start <= end; start += increment) {
+    if (reserve_contiguous_platform(start, size)) {
+      // Make the address range free
+      _manager.free(start, size);
+
+      // Success
+      return true;
+    }
+  }
+
+  // Failed
+  return false;
+}
+
+bool ZVirtualMemoryManager::reserve(size_t max_capacity) {
+  const size_t limit = MIN2(ZAddressOffsetMax, ZAddressSpaceLimit::heap_view());
+  const size_t size = MIN2(max_capacity * ZVirtualToPhysicalRatio, limit);
+
+  size_t reserved = size;
+  bool contiguous = true;
+
+  // Prefer a contiguous address space
+  if (!reserve_contiguous(size)) {
+    // Fall back to a discontiguous address space
+    reserved = reserve_discontiguous(size);
+    contiguous = false;
+  }
+
+  log_info(gc, init)("Address Space Type: %s/%s/%s",
+                     (contiguous ? "Contiguous" : "Discontiguous"),
+                     (limit == ZAddressOffsetMax ? "Unrestricted" : "Restricted"),
+                     (reserved == size ? "Complete" : "Degraded"));
+  log_info(gc, init)("Address Space Size: " SIZE_FORMAT "M x " SIZE_FORMAT " = " SIZE_FORMAT "M",
+                     reserved / M, ZHeapViews, (reserved * ZHeapViews) / M);
+
+  return reserved >= max_capacity;
+}
+
 void ZVirtualMemoryManager::nmt_reserve(uintptr_t start, size_t size) {
   MemTracker::record_virtual_memory_reserve((void*)start, size, CALLER_PC);
   MemTracker::record_virtual_memory_type((void*)start, mtJavaHeap);
 }
 
@@ -65,8 +163,8 @@
   }
 
   return ZVirtualMemory(start, size);
 }
 
-void ZVirtualMemoryManager::free(ZVirtualMemory vmem) {
+void ZVirtualMemoryManager::free(const ZVirtualMemory& vmem) {
   _manager.free(vmem.start(), vmem.size());
 }

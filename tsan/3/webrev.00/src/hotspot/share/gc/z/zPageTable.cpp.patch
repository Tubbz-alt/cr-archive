diff a/src/hotspot/share/gc/z/zPageTable.cpp b/src/hotspot/share/gc/z/zPageTable.cpp
--- a/src/hotspot/share/gc/z/zPageTable.cpp
+++ b/src/hotspot/share/gc/z/zPageTable.cpp
@@ -20,76 +20,34 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "precompiled.hpp"
-#include "gc/z/zAddress.inline.hpp"
+#include "gc/z/zGlobals.hpp"
+#include "gc/z/zGranuleMap.inline.hpp"
 #include "gc/z/zPage.inline.hpp"
 #include "gc/z/zPageTable.inline.hpp"
 #include "runtime/orderAccess.hpp"
 #include "utilities/debug.hpp"
 
 ZPageTable::ZPageTable() :
-    _map() {}
-
-ZPageTableEntry ZPageTable::get_entry(ZPage* page) const {
-  const uintptr_t addr = ZAddress::good(page->start());
-  return _map.get(addr);
-}
-
-void ZPageTable::put_entry(ZPage* page, ZPageTableEntry entry) {
-  // Make sure a newly created page is globally visible before
-  // updating the pagetable.
-  OrderAccess::storestore();
-
-  const uintptr_t start = ZAddress::good(page->start());
-  const uintptr_t end = start + page->size();
-  for (uintptr_t addr = start; addr < end; addr += ZGranuleSize) {
-    _map.put(addr, entry);
-  }
-}
+    _map(ZAddressOffsetMax) {}
 
 void ZPageTable::insert(ZPage* page) {
-  assert(get_entry(page).page() == NULL ||
-         get_entry(page).page() == page, "Invalid entry");
+  const uintptr_t offset = page->start();
+  const size_t size = page->size();
 
-  // Cached pages stays in the pagetable and we must not re-insert
-  // those when they get re-allocated because they might also be
-  // relocating and we don't want to clear their relocating bit.
-  if (get_entry(page).page() == NULL) {
-    ZPageTableEntry entry(page, false /* relocating */);
-    put_entry(page, entry);
-  }
+  // Make sure a newly created page is
+  // visible before updating the page table.
+  OrderAccess::storestore();
 
-  assert(get_entry(page).page() == page, "Invalid entry");
+  assert(_map.get(offset) == NULL, "Invalid entry");
+  _map.put(offset, size, page);
 }
 
 void ZPageTable::remove(ZPage* page) {
-  assert(get_entry(page).page() == page, "Invalid entry");
-
-  ZPageTableEntry entry;
-  put_entry(page, entry);
-
-  assert(get_entry(page).page() == NULL, "Invalid entry");
-}
-
-void ZPageTable::set_relocating(ZPage* page) {
-  assert(get_entry(page).page() == page, "Invalid entry");
-  assert(!get_entry(page).relocating(), "Invalid entry");
-
-  ZPageTableEntry entry(page, true /* relocating */);
-  put_entry(page, entry);
-
-  assert(get_entry(page).page() == page, "Invalid entry");
-  assert(get_entry(page).relocating(), "Invalid entry");
-}
-
-void ZPageTable::clear_relocating(ZPage* page) {
-  assert(get_entry(page).page() == page, "Invalid entry");
-  assert(get_entry(page).relocating(), "Invalid entry");
-
-  ZPageTableEntry entry(page, false /* relocating */);
-  put_entry(page, entry);
+  const uintptr_t offset = page->start();
+  const size_t size = page->size();
 
-  assert(get_entry(page).page() == page, "Invalid entry");
-  assert(!get_entry(page).relocating(), "Invalid entry");
+  assert(_map.get(offset) == page, "Invalid entry");
+  _map.put(offset, size, NULL);
 }

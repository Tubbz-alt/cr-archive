<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zNMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zNMethodData.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zNMethodTable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zNMethodTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,40 ***</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHash.inline.hpp&quot;
  #include &quot;gc/z/zLock.inline.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zNMethodAllocator.hpp&quot;</span>
  #include &quot;gc/z/zNMethodData.hpp&quot;
  #include &quot;gc/z/zNMethodTable.hpp&quot;
  #include &quot;gc/z/zNMethodTableEntry.hpp&quot;
  #include &quot;gc/z/zNMethodTableIteration.hpp&quot;
  #include &quot;gc/z/zOopClosures.inline.hpp&quot;
  #include &quot;gc/z/zTask.hpp&quot;
  #include &quot;gc/z/zWorkers.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  
  ZNMethodTableEntry* ZNMethodTable::_table = NULL;
  size_t ZNMethodTable::_size = 0;
  size_t ZNMethodTable::_nregistered = 0;
  size_t ZNMethodTable::_nunregistered = 0;
  ZNMethodTableIteration ZNMethodTable::_iteration;
<span class="line-modified">! </span>
<span class="line-removed">- ZNMethodTableEntry* ZNMethodTable::create(size_t size) {</span>
<span class="line-removed">-   void* const mem = ZNMethodAllocator::allocate(size * sizeof(ZNMethodTableEntry));</span>
<span class="line-removed">-   return ::new (mem) ZNMethodTableEntry[size];</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZNMethodTable::destroy(ZNMethodTableEntry* table) {</span>
<span class="line-removed">-   ZNMethodAllocator::free(table);</span>
<span class="line-removed">- }</span>
  
  size_t ZNMethodTable::first_index(const nmethod* nm, size_t size) {
    assert(is_power_of_2(size), &quot;Invalid size&quot;);
    const size_t mask = size - 1;
    const size_t hash = ZHash::address_to_uint32((uintptr_t)nm);
<span class="line-new-header">--- 28,31 ---</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHash.inline.hpp&quot;
  #include &quot;gc/z/zLock.inline.hpp&quot;
  #include &quot;gc/z/zNMethodData.hpp&quot;
  #include &quot;gc/z/zNMethodTable.hpp&quot;
  #include &quot;gc/z/zNMethodTableEntry.hpp&quot;
  #include &quot;gc/z/zNMethodTableIteration.hpp&quot;
  #include &quot;gc/z/zOopClosures.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zSafeDelete.inline.hpp&quot;</span>
  #include &quot;gc/z/zTask.hpp&quot;
  #include &quot;gc/z/zWorkers.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  ZNMethodTableEntry* ZNMethodTable::_table = NULL;
  size_t ZNMethodTable::_size = 0;
  size_t ZNMethodTable::_nregistered = 0;
  size_t ZNMethodTable::_nunregistered = 0;
  ZNMethodTableIteration ZNMethodTable::_iteration;
<span class="line-modified">! ZSafeDeleteNoLock&lt;ZNMethodTableEntry[]&gt; ZNMethodTable::_safe_delete;</span>
  
  size_t ZNMethodTable::first_index(const nmethod* nm, size_t size) {
    assert(is_power_of_2(size), &quot;Invalid size&quot;);
    const size_t mask = size - 1;
    const size_t hash = ZHash::address_to_uint32((uintptr_t)nm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,29 ***</span>
  
    assert(is_power_of_2(new_size), &quot;Invalid size&quot;);
  
    log_debug(gc, nmethod)(&quot;Rebuilding NMethod Table: &quot;
                           SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot; entries, &quot;
<span class="line-modified">!                          SIZE_FORMAT &quot;(%.0lf%%-&gt;%.0lf%%) registered, &quot;</span>
<span class="line-modified">!                          SIZE_FORMAT &quot;(%.0lf%%-&gt;%.0lf%%) unregistered&quot;,</span>
                           _size, new_size,
                           _nregistered, percent_of(_nregistered, _size), percent_of(_nregistered, new_size),
                           _nunregistered, percent_of(_nunregistered, _size), 0.0);
  
    // Allocate new table
<span class="line-modified">!   ZNMethodTableEntry* const new_table = ZNMethodTable::create(new_size);</span>
  
    // Transfer all registered entries
    for (size_t i = 0; i &lt; _size; i++) {
      const ZNMethodTableEntry entry = _table[i];
      if (entry.registered()) {
        register_entry(new_table, new_size, entry.method());
      }
    }
  
    // Free old table
<span class="line-modified">!   ZNMethodTable::destroy(_table);</span>
  
    // Install new table
    _table = new_table;
    _size = new_size;
    _nunregistered = 0;
<span class="line-new-header">--- 110,29 ---</span>
  
    assert(is_power_of_2(new_size), &quot;Invalid size&quot;);
  
    log_debug(gc, nmethod)(&quot;Rebuilding NMethod Table: &quot;
                           SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot; entries, &quot;
<span class="line-modified">!                          SIZE_FORMAT &quot;(%.0f%%-&gt;%.0f%%) registered, &quot;</span>
<span class="line-modified">!                          SIZE_FORMAT &quot;(%.0f%%-&gt;%.0f%%) unregistered&quot;,</span>
                           _size, new_size,
                           _nregistered, percent_of(_nregistered, _size), percent_of(_nregistered, new_size),
                           _nunregistered, percent_of(_nunregistered, _size), 0.0);
  
    // Allocate new table
<span class="line-modified">!   ZNMethodTableEntry* const new_table = new ZNMethodTableEntry[new_size];</span>
  
    // Transfer all registered entries
    for (size_t i = 0; i &lt; _size; i++) {
      const ZNMethodTableEntry entry = _table[i];
      if (entry.registered()) {
        register_entry(new_table, new_size, entry.method());
      }
    }
  
    // Free old table
<span class="line-modified">!   _safe_delete(_table);</span>
  
    // Install new table
    _table = new_table;
    _size = new_size;
    _nunregistered = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
  
  void ZNMethodTable::wait_until_iteration_done() {
    assert(CodeCache_lock-&gt;owned_by_self(), &quot;Lock must be held&quot;);
  
    while (_iteration.in_progress()) {
<span class="line-modified">!     CodeCache_lock-&gt;wait(Monitor::_no_safepoint_check_flag);</span>
    }
  }
  
  void ZNMethodTable::unregister_nmethod(nmethod* nm) {
    assert(CodeCache_lock-&gt;owned_by_self(), &quot;Lock must be held&quot;);
<span class="line-new-header">--- 192,11 ---</span>
  
  void ZNMethodTable::wait_until_iteration_done() {
    assert(CodeCache_lock-&gt;owned_by_self(), &quot;Lock must be held&quot;);
  
    while (_iteration.in_progress()) {
<span class="line-modified">!     CodeCache_lock-&gt;wait_without_safepoint_check();</span>
    }
  }
  
  void ZNMethodTable::unregister_nmethod(nmethod* nm) {
    assert(CodeCache_lock-&gt;owned_by_self(), &quot;Lock must be held&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,27 ***</span>
    _nunregistered++;
    _nregistered--;
  }
  
  void ZNMethodTable::nmethods_do_begin() {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="line-modified">!   // Make sure we don&#39;t free data while iterating</span>
<span class="line-modified">!   ZNMethodAllocator::activate_deferred_frees();</span>
  
    // Prepare iteration
    _iteration.nmethods_do_begin(_table, _size);
  }
  
  void ZNMethodTable::nmethods_do_end() {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
    // Finish iteration
    _iteration.nmethods_do_end();
  
<span class="line-modified">!   // Process deferred frees</span>
<span class="line-modified">!   ZNMethodAllocator::deactivate_and_process_deferred_frees();</span>
  
    // Notify iteration done
    CodeCache_lock-&gt;notify_all();
  }
  
<span class="line-new-header">--- 206,27 ---</span>
    _nunregistered++;
    _nregistered--;
  }
  
  void ZNMethodTable::nmethods_do_begin() {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="line-modified">!   // Do not allow the table to be deleted while iterating</span>
<span class="line-modified">!   _safe_delete.enable_deferred_delete();</span>
  
    // Prepare iteration
    _iteration.nmethods_do_begin(_table, _size);
  }
  
  void ZNMethodTable::nmethods_do_end() {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
    // Finish iteration
    _iteration.nmethods_do_end();
  
<span class="line-modified">!   // Allow the table to be deleted</span>
<span class="line-modified">!   _safe_delete.disable_deferred_delete();</span>
  
    // Notify iteration done
    CodeCache_lock-&gt;notify_all();
  }
  
</pre>
<center><a href="zNMethodData.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zNMethodTable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
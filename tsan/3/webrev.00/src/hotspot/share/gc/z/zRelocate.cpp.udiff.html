<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zRelocate.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zReferenceProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zRelocate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,33 +22,46 @@</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zAddress.inline.hpp&quot;
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zForwarding.inline.hpp&quot;</span>
  #include &quot;gc/z/zHeap.hpp&quot;
  #include &quot;gc/z/zOopClosures.inline.hpp&quot;
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zRelocate.hpp&quot;
  #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
  #include &quot;gc/z/zRootsIterator.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zStat.hpp&quot;</span>
  #include &quot;gc/z/zTask.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zThread.inline.hpp&quot;</span>
  #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
  #include &quot;gc/z/zWorkers.hpp&quot;
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static const ZStatCounter ZCounterRelocationContention(&quot;Contention&quot;, &quot;Relocation Contention&quot;, ZStatUnitOpsPerSecond);</span>
  
  ZRelocate::ZRelocate(ZWorkers* workers) :
      _workers(workers) {}
  
  class ZRelocateRootsIteratorClosure : public ZRootsIteratorClosure {
  public:
    virtual void do_thread(Thread* thread) {
      // Update thread local address bad mask
      ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
  
<span class="udiff-line-added">+     // Relocate invisible root</span>
<span class="udiff-line-added">+     ZThreadLocalData::do_invisible_root(thread, ZBarrier::relocate_barrier_on_root_oop_field);</span>
<span class="udiff-line-added">+ </span>
      // Remap TLAB
      ZThreadLocalAllocBuffer::remap(thread);
    }
  
<span class="udiff-line-added">+   virtual bool should_disarm_nmethods() const {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    virtual void do_oop(oop* p) {
      ZBarrier::relocate_barrier_on_root_oop_field(p);
    }
  
    virtual void do_oop(narrowOop* p) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62,56 +75,131 @@</span>
    ZRelocateRootsIteratorClosure _cl;
  
  public:
    ZRelocateRootsTask() :
        ZTask(&quot;ZRelocateRootsTask&quot;),
<span class="udiff-line-modified-removed">-       _roots() {}</span>
<span class="udiff-line-modified-added">+       _roots(true /* visit_jvmti_weak_export */) {}</span>
  
    virtual void work() {
      // During relocation we need to visit the JVMTI
      // export weak roots to rehash the JVMTI tag map
<span class="udiff-line-modified-removed">-     _roots.oops_do(&amp;_cl, true /* visit_jvmti_weak_export */);</span>
<span class="udiff-line-modified-added">+     _roots.oops_do(&amp;_cl);</span>
    }
  };
  
  void ZRelocate::start() {
    ZRelocateRootsTask task;
    _workers-&gt;run_parallel(&amp;task);
  }
  
<span class="udiff-line-added">+ uintptr_t ZRelocate::relocate_object_inner(ZForwarding* forwarding, uintptr_t from_index, uintptr_t from_offset) const {</span>
<span class="udiff-line-added">+   ZForwardingCursor cursor;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Lookup forwarding entry</span>
<span class="udiff-line-added">+   const ZForwardingEntry entry = forwarding-&gt;find(from_index, &amp;cursor);</span>
<span class="udiff-line-added">+   if (entry.populated() &amp;&amp; entry.from_index() == from_index) {</span>
<span class="udiff-line-added">+     // Already relocated, return new address</span>
<span class="udiff-line-added">+     return entry.to_offset();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(ZHeap::heap()-&gt;is_object_live(ZAddress::good(from_offset)), &quot;Should be live&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (forwarding-&gt;is_pinned()) {</span>
<span class="udiff-line-added">+     // In-place forward</span>
<span class="udiff-line-added">+     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Allocate object</span>
<span class="udiff-line-added">+   const uintptr_t from_good = ZAddress::good(from_offset);</span>
<span class="udiff-line-added">+   const size_t size = ZUtils::object_size(from_good);</span>
<span class="udiff-line-added">+   const uintptr_t to_good = ZHeap::heap()-&gt;alloc_object_for_relocation(size);</span>
<span class="udiff-line-added">+   if (to_good == 0) {</span>
<span class="udiff-line-added">+     // Failed, in-place forward</span>
<span class="udiff-line-added">+     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Copy object</span>
<span class="udiff-line-added">+   ZUtils::object_copy(from_good, to_good, size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Insert forwarding entry</span>
<span class="udiff-line-added">+   const uintptr_t to_offset = ZAddress::offset(to_good);</span>
<span class="udiff-line-added">+   const uintptr_t to_offset_final = forwarding-&gt;insert(from_index, to_offset, &amp;cursor);</span>
<span class="udiff-line-added">+   if (to_offset_final == to_offset) {</span>
<span class="udiff-line-added">+     // Relocation succeeded</span>
<span class="udiff-line-added">+     return to_offset;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Relocation contention</span>
<span class="udiff-line-added">+   ZStatInc(ZCounterRelocationContention);</span>
<span class="udiff-line-added">+   log_trace(gc)(&quot;Relocation contention, thread: &quot; PTR_FORMAT &quot; (%s), forwarding: &quot; PTR_FORMAT</span>
<span class="udiff-line-added">+                 &quot;, entry: &quot; SIZE_FORMAT &quot;, oop: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+                 ZThread::id(), ZThread::name(), p2i(forwarding), cursor, from_good, size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Try undo allocation</span>
<span class="udiff-line-added">+   ZHeap::heap()-&gt;undo_alloc_object_for_relocation(to_good, size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return to_offset_final;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uintptr_t ZRelocate::relocate_object(ZForwarding* forwarding, uintptr_t from_addr) const {</span>
<span class="udiff-line-added">+   const uintptr_t from_offset = ZAddress::offset(from_addr);</span>
<span class="udiff-line-added">+   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();</span>
<span class="udiff-line-added">+   const uintptr_t to_offset = relocate_object_inner(forwarding, from_index, from_offset);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (from_offset == to_offset) {</span>
<span class="udiff-line-added">+     // In-place forwarding, pin page</span>
<span class="udiff-line-added">+     forwarding-&gt;set_pinned();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return ZAddress::good(to_offset);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uintptr_t ZRelocate::forward_object(ZForwarding* forwarding, uintptr_t from_addr) const {</span>
<span class="udiff-line-added">+   const uintptr_t from_offset = ZAddress::offset(from_addr);</span>
<span class="udiff-line-added">+   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();</span>
<span class="udiff-line-added">+   const ZForwardingEntry entry = forwarding-&gt;find(from_index);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(entry.populated(), &quot;Should be forwarded&quot;);</span>
<span class="udiff-line-added">+   assert(entry.from_index() == from_index, &quot;Should be forwarded&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return ZAddress::good(entry.to_offset());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  class ZRelocateObjectClosure : public ObjectClosure {
  private:
<span class="udiff-line-modified-removed">-   ZPage* const _page;</span>
<span class="udiff-line-modified-added">+   ZRelocate* const   _relocate;</span>
<span class="udiff-line-added">+   ZForwarding* const _forwarding;</span>
  
  public:
<span class="udiff-line-modified-removed">-   ZRelocateObjectClosure(ZPage* page) :</span>
<span class="udiff-line-modified-removed">-       _page(page) {}</span>
<span class="udiff-line-modified-added">+   ZRelocateObjectClosure(ZRelocate* relocate, ZForwarding* forwarding) :</span>
<span class="udiff-line-modified-added">+       _relocate(relocate),</span>
<span class="udiff-line-added">+       _forwarding(forwarding) {}</span>
  
    virtual void do_object(oop o) {
<span class="udiff-line-modified-removed">-     _page-&gt;relocate_object(ZOop::to_address(o));</span>
<span class="udiff-line-modified-added">+     _relocate-&gt;relocate_object(_forwarding, ZOop::to_address(o));</span>
    }
  };
  
  bool ZRelocate::work(ZRelocationSetParallelIterator* iter) {
    bool success = true;
  
    // Relocate pages in the relocation set
<span class="udiff-line-modified-removed">-   for (ZPage* page; iter-&gt;next(&amp;page);) {</span>
<span class="udiff-line-modified-added">+   for (ZForwarding* forwarding; iter-&gt;next(&amp;forwarding);) {</span>
      // Relocate objects in page
<span class="udiff-line-modified-removed">-     ZRelocateObjectClosure cl(page);</span>
<span class="udiff-line-modified-removed">-     page-&gt;object_iterate(&amp;cl);</span>
<span class="udiff-line-modified-added">+     ZRelocateObjectClosure cl(this, forwarding);</span>
<span class="udiff-line-modified-added">+     forwarding-&gt;page()-&gt;object_iterate(&amp;cl);</span>
  
      if (ZVerifyForwarding) {
<span class="udiff-line-modified-removed">-       page-&gt;verify_forwarding();</span>
<span class="udiff-line-modified-added">+       forwarding-&gt;verify();</span>
      }
  
<span class="udiff-line-modified-removed">-     if (page-&gt;is_pinned()) {</span>
<span class="udiff-line-modified-added">+     if (forwarding-&gt;is_pinned()) {</span>
        // Relocation failed, page is now pinned
        success = false;
      } else {
        // Relocation succeeded, release page
<span class="udiff-line-modified-removed">-       ZHeap::heap()-&gt;release_page(page, true /* reclaimed */);</span>
<span class="udiff-line-modified-added">+       forwarding-&gt;release_page();</span>
      }
    }
  
    return success;
  }
</pre>
<center><a href="zReferenceProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
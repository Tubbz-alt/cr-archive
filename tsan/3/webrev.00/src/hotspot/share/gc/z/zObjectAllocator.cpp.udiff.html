<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zObjectAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zNUMA.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zObjectAllocator.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zObjectAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,15 +23,17 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/z/zCollectedHeap.hpp&quot;
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zHeuristics.hpp&quot;</span>
  #include &quot;gc/z/zObjectAllocator.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/z/zThread.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/z/zThread.inline.hpp&quot;</span>
  #include &quot;gc/z/zUtils.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zValue.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,34 +41,50 @@</span>
  #include &quot;utilities/debug.hpp&quot;
  
  static const ZStatCounter ZCounterUndoObjectAllocationSucceeded(&quot;Memory&quot;, &quot;Undo Object Allocation Succeeded&quot;, ZStatUnitOpsPerSecond);
  static const ZStatCounter ZCounterUndoObjectAllocationFailed(&quot;Memory&quot;, &quot;Undo Object Allocation Failed&quot;, ZStatUnitOpsPerSecond);
  
<span class="udiff-line-modified-removed">- ZObjectAllocator::ZObjectAllocator(uint nworkers) :</span>
<span class="udiff-line-modified-removed">-     _nworkers(nworkers),</span>
<span class="udiff-line-modified-added">+ ZObjectAllocator::ZObjectAllocator() :</span>
<span class="udiff-line-modified-added">+     _use_per_cpu_shared_small_pages(ZHeuristics::use_per_cpu_shared_small_pages()),</span>
      _used(0),
<span class="udiff-line-added">+     _undone(0),</span>
      _shared_medium_page(NULL),
      _shared_small_page(NULL),
      _worker_small_page(NULL) {}
  
<span class="udiff-line-added">+ ZPage** ZObjectAllocator::shared_small_page_addr() {</span>
<span class="udiff-line-added">+   return _use_per_cpu_shared_small_pages ? _shared_small_page.addr() : _shared_small_page.addr(0);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ZPage* const* ZObjectAllocator::shared_small_page_addr() const {</span>
<span class="udiff-line-added">+   return _use_per_cpu_shared_small_pages ? _shared_small_page.addr() : _shared_small_page.addr(0);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  ZPage* ZObjectAllocator::alloc_page(uint8_t type, size_t size, ZAllocationFlags flags) {
    ZPage* const page = ZHeap::heap()-&gt;alloc_page(type, size, flags);
    if (page != NULL) {
      // Increment used bytes
<span class="udiff-line-modified-removed">-     Atomic::add(size, _used.addr());</span>
<span class="udiff-line-modified-added">+     Atomic::add(_used.addr(), size);</span>
    }
  
    return page;
  }
  
<span class="udiff-line-added">+ void ZObjectAllocator::undo_alloc_page(ZPage* page) {</span>
<span class="udiff-line-added">+   // Increment undone bytes</span>
<span class="udiff-line-added">+   Atomic::add(_undone.addr(), page-&gt;size());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ZHeap::heap()-&gt;undo_alloc_page(page);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  uintptr_t ZObjectAllocator::alloc_object_in_shared_page(ZPage** shared_page,
                                                          uint8_t page_type,
                                                          size_t page_size,
                                                          size_t size,
                                                          ZAllocationFlags flags) {
    uintptr_t addr = 0;
<span class="udiff-line-modified-removed">-   ZPage* page = *shared_page;</span>
<span class="udiff-line-modified-added">+   ZPage* page = Atomic::load_acquire(shared_page);</span>
  
    if (page != NULL) {
      addr = page-&gt;alloc_object_atomic(size);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -77,11 +95,11 @@</span>
        // Allocate object before installing the new page
        addr = new_page-&gt;alloc_object(size);
  
      retry:
        // Install new page
<span class="udiff-line-modified-removed">-       ZPage* const prev_page = Atomic::cmpxchg(new_page, shared_page, page);</span>
<span class="udiff-line-modified-added">+       ZPage* const prev_page = Atomic::cmpxchg(shared_page, page, new_page);</span>
        if (prev_page != page) {
          if (prev_page == NULL) {
            // Previous page was retired, retry installing the new page
            page = prev_page;
            goto retry;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,11 +115,11 @@</span>
  
          // Allocation succeeded in already installed page
          addr = prev_addr;
  
          // Undo new page allocation
<span class="udiff-line-modified-removed">-         ZHeap::heap()-&gt;undo_alloc_page(new_page);</span>
<span class="udiff-line-modified-added">+         undo_alloc_page(new_page);</span>
        }
      }
    }
  
    return addr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,11 +150,11 @@</span>
           &quot;Should be a Java, VM or Runtime worker thread&quot;);
  
    // Non-worker small page allocation can never use the reserve
    flags.set_no_reserve();
  
<span class="udiff-line-modified-removed">-   return alloc_object_in_shared_page(_shared_small_page.addr(), ZPageTypeSmall, ZPageSizeSmall, size, flags);</span>
<span class="udiff-line-modified-added">+   return alloc_object_in_shared_page(shared_small_page_addr(), ZPageTypeSmall, ZPageSizeSmall, size, flags);</span>
  }
  
  uintptr_t ZObjectAllocator::alloc_small_object_from_worker(size_t size, ZAllocationFlags flags) {
    assert(ZThread::is_worker(), &quot;Should be a worker thread&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,14 +202,10 @@</span>
    assert(ZThread::is_java(), &quot;Must be a Java thread&quot;);
  
    ZAllocationFlags flags;
    flags.set_no_reserve();
  
<span class="udiff-line-removed">-   if (!ZStallOnOutOfMemory) {</span>
<span class="udiff-line-removed">-     flags.set_non_blocking();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    return alloc_object(size, flags);
  }
  
  uintptr_t ZObjectAllocator::alloc_object_for_relocation(size_t size) {
    assert(ZThread::is_java() || ZThread::is_vm() || ZThread::is_worker() || ZThread::is_runtime_worker(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -210,11 +224,11 @@</span>
  
  bool ZObjectAllocator::undo_alloc_large_object(ZPage* page) {
    assert(page-&gt;type() == ZPageTypeLarge, &quot;Invalid page type&quot;);
  
    // Undo page allocation
<span class="udiff-line-modified-removed">-   ZHeap::heap()-&gt;undo_alloc_page(page);</span>
<span class="udiff-line-modified-added">+   undo_alloc_page(page);</span>
    return true;
  }
  
  bool ZObjectAllocator::undo_alloc_medium_object(ZPage* page, uintptr_t addr, size_t size) {
    assert(page-&gt;type() == ZPageTypeMedium, &quot;Invalid page type&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,35 +284,42 @@</span>
    }
  }
  
  size_t ZObjectAllocator::used() const {
    size_t total_used = 0;
<span class="udiff-line-added">+   size_t total_undone = 0;</span>
  
<span class="udiff-line-modified-removed">-   ZPerCPUConstIterator&lt;size_t&gt; iter(&amp;_used);</span>
<span class="udiff-line-modified-removed">-   for (const size_t* cpu_used; iter.next(&amp;cpu_used);) {</span>
<span class="udiff-line-modified-added">+   ZPerCPUConstIterator&lt;size_t&gt; iter_used(&amp;_used);</span>
<span class="udiff-line-modified-added">+   for (const size_t* cpu_used; iter_used.next(&amp;cpu_used);) {</span>
      total_used += *cpu_used;
    }
  
<span class="udiff-line-modified-removed">-   return total_used;</span>
<span class="udiff-line-modified-added">+   ZPerCPUConstIterator&lt;size_t&gt; iter_undone(&amp;_undone);</span>
<span class="udiff-line-added">+   for (const size_t* cpu_undone; iter_undone.next(&amp;cpu_undone);) {</span>
<span class="udiff-line-added">+     total_undone += *cpu_undone;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return total_used - total_undone;</span>
  }
  
  size_t ZObjectAllocator::remaining() const {
    assert(ZThread::is_java(), &quot;Should be a Java thread&quot;);
  
<span class="udiff-line-modified-removed">-   ZPage* page = _shared_small_page.get();</span>
<span class="udiff-line-modified-added">+   const ZPage* const page = Atomic::load_acquire(shared_small_page_addr());</span>
    if (page != NULL) {
      return page-&gt;remaining();
    }
  
    return 0;
  }
  
  void ZObjectAllocator::retire_pages() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="udiff-line-modified-removed">-   // Reset used</span>
<span class="udiff-line-modified-added">+   // Reset used and undone bytes</span>
    _used.set_all(0);
<span class="udiff-line-added">+   _undone.set_all(0);</span>
  
    // Reset allocation pages
    _shared_medium_page.set(NULL);
    _shared_small_page.set_all(NULL);
    _worker_small_page.set_all(NULL);
</pre>
<center><a href="zNUMA.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zObjectAllocator.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
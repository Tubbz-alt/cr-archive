<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zStat.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zStat.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zStat.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZSTAT_HPP
 25 #define SHARE_GC_Z_ZSTAT_HPP
 26 
 27 #include &quot;gc/shared/concurrentGCThread.hpp&quot;

 28 #include &quot;gc/shared/gcTimer.hpp&quot;
 29 #include &quot;gc/z/zMetronome.hpp&quot;
 30 #include &quot;logging/logHandle.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;

 32 #include &quot;utilities/numberSeq.hpp&quot;
 33 #include &quot;utilities/ticks.hpp&quot;
 34 
 35 class ZPage;


 36 class ZStatSampler;
 37 class ZStatSamplerHistory;
 38 struct ZStatCounterData;
 39 struct ZStatSamplerData;
 40 
 41 //
 42 // Stat unit printers
 43 //
 44 typedef void (*ZStatUnitPrinter)(LogTargetHandle log, const ZStatSampler&amp;, const ZStatSamplerHistory&amp;);
 45 
 46 void ZStatUnitTime(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 47 void ZStatUnitBytes(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 48 void ZStatUnitThreads(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 49 void ZStatUnitBytesPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 50 void ZStatUnitOpsPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 51 
 52 //
 53 // Stat value
 54 //
 55 class ZStatValue {
</pre>
<hr />
<pre>
252 
253   virtual void register_start(const Ticks&amp; start) const;
254   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
255 };
256 
257 class ZStatCriticalPhase : public ZStatPhase {
258 private:
259   const ZStatCounter _counter;
260   const bool         _verbose;
261 
262 public:
263   ZStatCriticalPhase(const char* name, bool verbose = true);
264 
265   virtual void register_start(const Ticks&amp; start) const;
266   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
267 };
268 
269 //
270 // Stat timer
271 //


















272 class ZStatTimer : public StackObj {
273 private:

274   const ZStatPhase&amp; _phase;
275   const Ticks       _start;
276 
277 public:
278   ZStatTimer(const ZStatPhase&amp; phase) :

279       _phase(phase),
280       _start(Ticks::now()) {
<span class="line-modified">281     _phase.register_start(_start);</span>


282   }
283 
284   ~ZStatTimer() {
<span class="line-modified">285     const Ticks end = Ticks::now();</span>
<span class="line-modified">286     _phase.register_end(_start, end);</span>


287   }
288 };
289 
290 //
291 // Stat sample/increment
292 //
<span class="line-modified">293 void ZStatSample(const ZStatSampler&amp; sampler, uint64_t value, bool trace = ZStatisticsForceTrace);</span>
<span class="line-modified">294 void ZStatInc(const ZStatCounter&amp; counter, uint64_t increment = 1, bool trace = ZStatisticsForceTrace);</span>
295 void ZStatInc(const ZStatUnsampledCounter&amp; counter, uint64_t increment = 1);
296 
297 //
298 // Stat allocation rate
299 //
300 class ZStatAllocRate : public AllStatic {
301 private:
302   static const ZStatUnsampledCounter _counter;
303   static TruncatedSeq                _rate;     // B/s
304   static TruncatedSeq                _rate_avg; // B/s
305 
306 public:
307   static const uint64_t sample_window_sec = 1; // seconds
308   static const uint64_t sample_hz         = 10;
309 
310   static const ZStatUnsampledCounter&amp; counter();
311   static uint64_t sample_and_reset();
312 
313   static double avg();
314   static double avg_sd();
</pre>
<hr />
<pre>
323 
324   ZMetronome _metronome;
325 
326   void sample_and_collect(ZStatSamplerHistory* history) const;
327   bool should_print(LogTargetHandle log) const;
328   void print(LogTargetHandle log, const ZStatSamplerHistory* history) const;
329 
330 protected:
331   virtual void run_service();
332   virtual void stop_service();
333 
334 public:
335   ZStat();
336 };
337 
338 //
339 // Stat cycle
340 //
341 class ZStatCycle : public AllStatic {
342 private:
<span class="line-modified">343   static uint64_t  _ncycles;</span>
344   static Ticks     _start_of_last;
345   static Ticks     _end_of_last;
346   static NumberSeq _normalized_duration;
347 
348 public:
349   static void at_start();
<span class="line-modified">350   static void at_end(double boost_factor);</span>
351 
<span class="line-modified">352   static uint64_t ncycles();</span>



353   static const AbsSeq&amp; normalized_duration();

354   static double time_since_last();
355 };
356 
357 //
358 // Stat load
359 //
360 class ZStatLoad : public AllStatic {
361 public:
362   static void print();
363 };
364 
365 //
366 // Stat mark
367 //
368 class ZStatMark : public AllStatic {
369 private:
370   static size_t _nstripes;
371   static size_t _nproactiveflush;
372   static size_t _nterminateflush;
373   static size_t _ntrycomplete;
374   static size_t _ncontinue;
375 
376 public:
377   static void set_at_mark_start(size_t nstripes);
378   static void set_at_mark_end(size_t nproactiveflush,
379                               size_t nterminateflush,
380                               size_t ntrycomplete,
381                               size_t ncontinue);
382 
383   static void print();
384 };
385 
386 //
387 // Stat relocation
388 //
389 class ZStatRelocation : public AllStatic {
390 private:
<span class="line-modified">391   static size_t _relocating;</span>
<span class="line-modified">392   static bool   _success;</span>


393 
394 public:
<span class="line-modified">395   static void set_at_select_relocation_set(size_t relocating);</span>
396   static void set_at_relocate_end(bool success);
397 
398   static void print();
399 };
400 
401 //
402 // Stat nmethods
403 //
404 class ZStatNMethods : public AllStatic {
405 public:
406   static void print();
407 };
408 
409 //
410 // Stat metaspace
411 //
412 class ZStatMetaspace : public AllStatic {
413 public:
414   static void print();
415 };
</pre>
<hr />
<pre>
426   } _soft, _weak, _final, _phantom;
427 
428   static void set(ZCount* count, size_t encountered, size_t discovered, size_t enqueued);
429   static void print(const char* name, const ZCount&amp; ref);
430 
431 public:
432   static void set_soft(size_t encountered, size_t discovered, size_t enqueued);
433   static void set_weak(size_t encountered, size_t discovered, size_t enqueued);
434   static void set_final(size_t encountered, size_t discovered, size_t enqueued);
435   static void set_phantom(size_t encountered, size_t discovered, size_t enqueued);
436 
437   static void print();
438 };
439 
440 //
441 // Stat heap
442 //
443 class ZStatHeap : public AllStatic {
444 private:
445   static struct ZAtInitialize {

446     size_t max_capacity;
447     size_t max_reserve;
448   } _at_initialize;
449 
450   static struct ZAtMarkStart {

451     size_t capacity;
452     size_t reserve;
453     size_t used;
454     size_t free;
455   } _at_mark_start;
456 
457   static struct ZAtMarkEnd {
458     size_t capacity;
459     size_t reserve;
460     size_t allocated;
461     size_t used;
462     size_t free;
463     size_t live;
464     size_t garbage;
465   } _at_mark_end;
466 
467   static struct ZAtRelocateStart {
468     size_t capacity;
469     size_t reserve;
470     size_t garbage;
</pre>
<hr />
<pre>
475   } _at_relocate_start;
476 
477   static struct ZAtRelocateEnd {
478     size_t capacity;
479     size_t capacity_high;
480     size_t capacity_low;
481     size_t reserve;
482     size_t reserve_high;
483     size_t reserve_low;
484     size_t garbage;
485     size_t allocated;
486     size_t reclaimed;
487     size_t used;
488     size_t used_high;
489     size_t used_low;
490     size_t free;
491     size_t free_high;
492     size_t free_low;
493   } _at_relocate_end;
494 


495   static size_t available(size_t used);
496   static size_t reserve(size_t used);
497   static size_t free(size_t used);
498 
499 public:
<span class="line-modified">500   static void set_at_initialize(size_t max_capacity,</span>

501                                 size_t max_reserve);
<span class="line-modified">502   static void set_at_mark_start(size_t capacity,</span>

503                                 size_t used);
504   static void set_at_mark_end(size_t capacity,
505                               size_t allocated,
506                               size_t used);
<span class="line-modified">507   static void set_at_select_relocation_set(size_t live,</span>
<span class="line-removed">508                                            size_t garbage,</span>
509                                            size_t reclaimed);
510   static void set_at_relocate_start(size_t capacity,
511                                     size_t allocated,
512                                     size_t used);
513   static void set_at_relocate_end(size_t capacity,
514                                   size_t allocated,
515                                   size_t reclaimed,
516                                   size_t used,
517                                   size_t used_high,
518                                   size_t used_low);
519 
520   static size_t max_capacity();
521   static size_t used_at_mark_start();
522   static size_t used_at_relocate_end();
523 
524   static void print();
525 };
526 
527 #endif // SHARE_GC_Z_ZSTAT_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZSTAT_HPP
 25 #define SHARE_GC_Z_ZSTAT_HPP
 26 
 27 #include &quot;gc/shared/concurrentGCThread.hpp&quot;
<span class="line-added"> 28 #include &quot;gc/shared/gcCause.hpp&quot;</span>
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/z/zMetronome.hpp&quot;
 31 #include &quot;logging/logHandle.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 33 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 34 #include &quot;utilities/numberSeq.hpp&quot;
 35 #include &quot;utilities/ticks.hpp&quot;
 36 
 37 class ZPage;
<span class="line-added"> 38 class ZRelocationSetSelectorGroupStats;</span>
<span class="line-added"> 39 class ZRelocationSetSelectorStats;</span>
 40 class ZStatSampler;
 41 class ZStatSamplerHistory;
 42 struct ZStatCounterData;
 43 struct ZStatSamplerData;
 44 
 45 //
 46 // Stat unit printers
 47 //
 48 typedef void (*ZStatUnitPrinter)(LogTargetHandle log, const ZStatSampler&amp;, const ZStatSamplerHistory&amp;);
 49 
 50 void ZStatUnitTime(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 51 void ZStatUnitBytes(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 52 void ZStatUnitThreads(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 53 void ZStatUnitBytesPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 54 void ZStatUnitOpsPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 55 
 56 //
 57 // Stat value
 58 //
 59 class ZStatValue {
</pre>
<hr />
<pre>
256 
257   virtual void register_start(const Ticks&amp; start) const;
258   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
259 };
260 
261 class ZStatCriticalPhase : public ZStatPhase {
262 private:
263   const ZStatCounter _counter;
264   const bool         _verbose;
265 
266 public:
267   ZStatCriticalPhase(const char* name, bool verbose = true);
268 
269   virtual void register_start(const Ticks&amp; start) const;
270   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
271 };
272 
273 //
274 // Stat timer
275 //
<span class="line-added">276 class ZStatTimerDisable : public StackObj {</span>
<span class="line-added">277 private:</span>
<span class="line-added">278   static THREAD_LOCAL uint32_t _active;</span>
<span class="line-added">279 </span>
<span class="line-added">280 public:</span>
<span class="line-added">281   ZStatTimerDisable() {</span>
<span class="line-added">282     _active++;</span>
<span class="line-added">283   }</span>
<span class="line-added">284 </span>
<span class="line-added">285   ~ZStatTimerDisable() {</span>
<span class="line-added">286     _active--;</span>
<span class="line-added">287   }</span>
<span class="line-added">288 </span>
<span class="line-added">289   static bool is_active() {</span>
<span class="line-added">290     return _active &gt; 0;</span>
<span class="line-added">291   }</span>
<span class="line-added">292 };</span>
<span class="line-added">293 </span>
294 class ZStatTimer : public StackObj {
295 private:
<span class="line-added">296   const bool        _enabled;</span>
297   const ZStatPhase&amp; _phase;
298   const Ticks       _start;
299 
300 public:
301   ZStatTimer(const ZStatPhase&amp; phase) :
<span class="line-added">302       _enabled(!ZStatTimerDisable::is_active()),</span>
303       _phase(phase),
304       _start(Ticks::now()) {
<span class="line-modified">305     if (_enabled) {</span>
<span class="line-added">306       _phase.register_start(_start);</span>
<span class="line-added">307     }</span>
308   }
309 
310   ~ZStatTimer() {
<span class="line-modified">311     if (_enabled) {</span>
<span class="line-modified">312       const Ticks end = Ticks::now();</span>
<span class="line-added">313       _phase.register_end(_start, end);</span>
<span class="line-added">314     }</span>
315   }
316 };
317 
318 //
319 // Stat sample/increment
320 //
<span class="line-modified">321 void ZStatSample(const ZStatSampler&amp; sampler, uint64_t value);</span>
<span class="line-modified">322 void ZStatInc(const ZStatCounter&amp; counter, uint64_t increment = 1);</span>
323 void ZStatInc(const ZStatUnsampledCounter&amp; counter, uint64_t increment = 1);
324 
325 //
326 // Stat allocation rate
327 //
328 class ZStatAllocRate : public AllStatic {
329 private:
330   static const ZStatUnsampledCounter _counter;
331   static TruncatedSeq                _rate;     // B/s
332   static TruncatedSeq                _rate_avg; // B/s
333 
334 public:
335   static const uint64_t sample_window_sec = 1; // seconds
336   static const uint64_t sample_hz         = 10;
337 
338   static const ZStatUnsampledCounter&amp; counter();
339   static uint64_t sample_and_reset();
340 
341   static double avg();
342   static double avg_sd();
</pre>
<hr />
<pre>
351 
352   ZMetronome _metronome;
353 
354   void sample_and_collect(ZStatSamplerHistory* history) const;
355   bool should_print(LogTargetHandle log) const;
356   void print(LogTargetHandle log, const ZStatSamplerHistory* history) const;
357 
358 protected:
359   virtual void run_service();
360   virtual void stop_service();
361 
362 public:
363   ZStat();
364 };
365 
366 //
367 // Stat cycle
368 //
369 class ZStatCycle : public AllStatic {
370 private:
<span class="line-modified">371   static uint64_t  _nwarmup_cycles;</span>
372   static Ticks     _start_of_last;
373   static Ticks     _end_of_last;
374   static NumberSeq _normalized_duration;
375 
376 public:
377   static void at_start();
<span class="line-modified">378   static void at_end(GCCause::Cause cause, double boost_factor);</span>
379 
<span class="line-modified">380   static bool is_warm();</span>
<span class="line-added">381   static uint64_t nwarmup_cycles();</span>
<span class="line-added">382 </span>
<span class="line-added">383   static bool is_normalized_duration_trustable();</span>
384   static const AbsSeq&amp; normalized_duration();
<span class="line-added">385 </span>
386   static double time_since_last();
387 };
388 
389 //
390 // Stat load
391 //
392 class ZStatLoad : public AllStatic {
393 public:
394   static void print();
395 };
396 
397 //
398 // Stat mark
399 //
400 class ZStatMark : public AllStatic {
401 private:
402   static size_t _nstripes;
403   static size_t _nproactiveflush;
404   static size_t _nterminateflush;
405   static size_t _ntrycomplete;
406   static size_t _ncontinue;
407 
408 public:
409   static void set_at_mark_start(size_t nstripes);
410   static void set_at_mark_end(size_t nproactiveflush,
411                               size_t nterminateflush,
412                               size_t ntrycomplete,
413                               size_t ncontinue);
414 
415   static void print();
416 };
417 
418 //
419 // Stat relocation
420 //
421 class ZStatRelocation : public AllStatic {
422 private:
<span class="line-modified">423   static ZRelocationSetSelectorStats _stats;</span>
<span class="line-modified">424   static bool                        _success;</span>
<span class="line-added">425 </span>
<span class="line-added">426   static void print(const char* name, const ZRelocationSetSelectorGroupStats&amp; group);</span>
427 
428 public:
<span class="line-modified">429   static void set_at_select_relocation_set(const ZRelocationSetSelectorStats&amp; stats);</span>
430   static void set_at_relocate_end(bool success);
431 
432   static void print();
433 };
434 
435 //
436 // Stat nmethods
437 //
438 class ZStatNMethods : public AllStatic {
439 public:
440   static void print();
441 };
442 
443 //
444 // Stat metaspace
445 //
446 class ZStatMetaspace : public AllStatic {
447 public:
448   static void print();
449 };
</pre>
<hr />
<pre>
460   } _soft, _weak, _final, _phantom;
461 
462   static void set(ZCount* count, size_t encountered, size_t discovered, size_t enqueued);
463   static void print(const char* name, const ZCount&amp; ref);
464 
465 public:
466   static void set_soft(size_t encountered, size_t discovered, size_t enqueued);
467   static void set_weak(size_t encountered, size_t discovered, size_t enqueued);
468   static void set_final(size_t encountered, size_t discovered, size_t enqueued);
469   static void set_phantom(size_t encountered, size_t discovered, size_t enqueued);
470 
471   static void print();
472 };
473 
474 //
475 // Stat heap
476 //
477 class ZStatHeap : public AllStatic {
478 private:
479   static struct ZAtInitialize {
<span class="line-added">480     size_t min_capacity;</span>
481     size_t max_capacity;
482     size_t max_reserve;
483   } _at_initialize;
484 
485   static struct ZAtMarkStart {
<span class="line-added">486     size_t soft_max_capacity;</span>
487     size_t capacity;
488     size_t reserve;
489     size_t used;
490     size_t free;
491   } _at_mark_start;
492 
493   static struct ZAtMarkEnd {
494     size_t capacity;
495     size_t reserve;
496     size_t allocated;
497     size_t used;
498     size_t free;
499     size_t live;
500     size_t garbage;
501   } _at_mark_end;
502 
503   static struct ZAtRelocateStart {
504     size_t capacity;
505     size_t reserve;
506     size_t garbage;
</pre>
<hr />
<pre>
511   } _at_relocate_start;
512 
513   static struct ZAtRelocateEnd {
514     size_t capacity;
515     size_t capacity_high;
516     size_t capacity_low;
517     size_t reserve;
518     size_t reserve_high;
519     size_t reserve_low;
520     size_t garbage;
521     size_t allocated;
522     size_t reclaimed;
523     size_t used;
524     size_t used_high;
525     size_t used_low;
526     size_t free;
527     size_t free_high;
528     size_t free_low;
529   } _at_relocate_end;
530 
<span class="line-added">531   static size_t capacity_high();</span>
<span class="line-added">532   static size_t capacity_low();</span>
533   static size_t available(size_t used);
534   static size_t reserve(size_t used);
535   static size_t free(size_t used);
536 
537 public:
<span class="line-modified">538   static void set_at_initialize(size_t min_capacity,</span>
<span class="line-added">539                                 size_t max_capacity,</span>
540                                 size_t max_reserve);
<span class="line-modified">541   static void set_at_mark_start(size_t soft_max_capacity,</span>
<span class="line-added">542                                 size_t capacity,</span>
543                                 size_t used);
544   static void set_at_mark_end(size_t capacity,
545                               size_t allocated,
546                               size_t used);
<span class="line-modified">547   static void set_at_select_relocation_set(const ZRelocationSetSelectorStats&amp; stats,</span>

548                                            size_t reclaimed);
549   static void set_at_relocate_start(size_t capacity,
550                                     size_t allocated,
551                                     size_t used);
552   static void set_at_relocate_end(size_t capacity,
553                                   size_t allocated,
554                                   size_t reclaimed,
555                                   size_t used,
556                                   size_t used_high,
557                                   size_t used_low);
558 
559   static size_t max_capacity();
560   static size_t used_at_mark_start();
561   static size_t used_at_relocate_end();
562 
563   static void print();
564 };
565 
566 #endif // SHARE_GC_Z_ZSTAT_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zStat.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
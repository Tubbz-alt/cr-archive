<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zDriver.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcId.hpp&quot;
 26 #include &quot;gc/shared/gcLocker.hpp&quot;
 27 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 28 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 29 #include &quot;gc/z/zDriver.hpp&quot;
 30 #include &quot;gc/z/zHeap.inline.hpp&quot;
 31 #include &quot;gc/z/zMessagePort.inline.hpp&quot;
 32 #include &quot;gc/z/zServiceability.hpp&quot;
 33 #include &quot;gc/z/zStat.hpp&quot;
<a name="1" id="anc1"></a>
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
 38 
 39 static const ZStatPhaseCycle      ZPhaseCycle(&quot;Garbage Collection Cycle&quot;);
 40 static const ZStatPhasePause      ZPhasePauseMarkStart(&quot;Pause Mark Start&quot;);
 41 static const ZStatPhaseConcurrent ZPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
 42 static const ZStatPhaseConcurrent ZPhaseConcurrentMarkContinue(&quot;Concurrent Mark Continue&quot;);
 43 static const ZStatPhasePause      ZPhasePauseMarkEnd(&quot;Pause Mark End&quot;);
 44 static const ZStatPhaseConcurrent ZPhaseConcurrentProcessNonStrongReferences(&quot;Concurrent Process Non-Strong References&quot;);
 45 static const ZStatPhaseConcurrent ZPhaseConcurrentResetRelocationSet(&quot;Concurrent Reset Relocation Set&quot;);
<a name="2" id="anc2"></a><span class="line-removed"> 46 static const ZStatPhaseConcurrent ZPhaseConcurrentDestroyDetachedPages(&quot;Concurrent Destroy Detached Pages&quot;);</span>
 47 static const ZStatPhaseConcurrent ZPhaseConcurrentSelectRelocationSet(&quot;Concurrent Select Relocation Set&quot;);
<a name="3" id="anc3"></a><span class="line-removed"> 48 static const ZStatPhaseConcurrent ZPhaseConcurrentPrepareRelocationSet(&quot;Concurrent Prepare Relocation Set&quot;);</span>
 49 static const ZStatPhasePause      ZPhasePauseRelocateStart(&quot;Pause Relocate Start&quot;);
 50 static const ZStatPhaseConcurrent ZPhaseConcurrentRelocated(&quot;Concurrent Relocate&quot;);
 51 static const ZStatCriticalPhase   ZCriticalPhaseGCLockerStall(&quot;GC Locker Stall&quot;, false /* verbose */);
 52 static const ZStatSampler         ZSamplerJavaThreads(&quot;System&quot;, &quot;Java Threads&quot;, ZStatUnitThreads);
 53 
 54 class VM_ZOperation : public VM_Operation {
 55 private:
 56   const uint _gc_id;
 57   bool       _gc_locked;
 58   bool       _success;
 59 
 60 public:
 61   VM_ZOperation() :
 62       _gc_id(GCId::current()),
 63       _gc_locked(false),
 64       _success(false) {}
 65 
 66   virtual bool needs_inactive_gc_locker() const {
 67     // An inactive GC locker is needed in operations where we change the bad
 68     // mask or move objects. Changing the bad mask will invalidate all oops,
 69     // which makes it conceptually the same thing as moving all objects.
 70     return false;
 71   }
 72 
 73   virtual bool do_operation() = 0;
 74 
 75   virtual bool doit_prologue() {
 76     Heap_lock-&gt;lock();
 77     return true;
 78   }
 79 
 80   virtual void doit() {
 81     // Abort if GC locker state is incompatible
 82     if (needs_inactive_gc_locker() &amp;&amp; GCLocker::check_active_before_gc()) {
 83       _gc_locked = true;
 84       return;
 85     }
 86 
 87     // Setup GC id and active marker
 88     GCIdMark gc_id_mark(_gc_id);
 89     IsGCActiveMark gc_active_mark;
 90 
<a name="4" id="anc4"></a>


 91     // Execute operation
 92     _success = do_operation();
 93 
 94     // Update statistics
 95     ZStatSample(ZSamplerJavaThreads, Threads::number_of_threads());
 96   }
 97 
 98   virtual void doit_epilogue() {
 99     Heap_lock-&gt;unlock();
100   }
101 
102   bool gc_locked() const {
103     return _gc_locked;
104   }
105 
106   bool success() const {
107     return _success;
108   }
109 };
110 
111 static bool should_clear_soft_references() {
112   // Clear if one or more allocations have stalled
113   const bool stalled = ZHeap::heap()-&gt;is_alloc_stalled();
114   if (stalled) {
115     // Clear
116     return true;
117   }
118 
119   // Clear if implied by the GC cause
120   const GCCause::Cause cause = ZCollectedHeap::heap()-&gt;gc_cause();
121   if (cause == GCCause::_wb_full_gc ||
122       cause == GCCause::_metadata_GC_clear_soft_refs) {
123     // Clear
124     return true;
125   }
126 
127   // Don&#39;t clear
128   return false;
129 }
130 
131 static bool should_boost_worker_threads() {
132   // Boost worker threads if one or more allocations have stalled
133   const bool stalled = ZHeap::heap()-&gt;is_alloc_stalled();
134   if (stalled) {
135     // Boost
136     return true;
137   }
138 
139   // Boost worker threads if implied by the GC cause
140   const GCCause::Cause cause = ZCollectedHeap::heap()-&gt;gc_cause();
141   if (cause == GCCause::_wb_full_gc ||
142       cause == GCCause::_java_lang_system_gc ||
143       cause == GCCause::_metadata_GC_clear_soft_refs) {
144     // Boost
145     return true;
146   }
147 
148   // Don&#39;t boost
149   return false;
150 }
151 
152 class VM_ZMarkStart : public VM_ZOperation {
153 public:
154   virtual VMOp_Type type() const {
155     return VMOp_ZMarkStart;
156   }
157 
158   virtual bool needs_inactive_gc_locker() const {
159     return true;
160   }
161 
162   virtual bool do_operation() {
163     ZStatTimer timer(ZPhasePauseMarkStart);
164     ZServiceabilityMarkStartTracer tracer;
165 
166     // Set up soft reference policy
167     const bool clear = should_clear_soft_references();
168     ZHeap::heap()-&gt;set_soft_reference_policy(clear);
169 
170     // Set up boost mode
171     const bool boost = should_boost_worker_threads();
172     ZHeap::heap()-&gt;set_boost_worker_threads(boost);
173 
174     ZCollectedHeap::heap()-&gt;increment_total_collections(true /* full */);
175 
176     ZHeap::heap()-&gt;mark_start();
177     return true;
178   }
179 };
180 
181 class VM_ZMarkEnd : public VM_ZOperation {
182 public:
183   virtual VMOp_Type type() const {
184     return VMOp_ZMarkEnd;
185   }
186 
187   virtual bool do_operation() {
188     ZStatTimer timer(ZPhasePauseMarkEnd);
189     ZServiceabilityMarkEndTracer tracer;
190     return ZHeap::heap()-&gt;mark_end();
191   }
192 };
193 
194 class VM_ZRelocateStart : public VM_ZOperation {
195 public:
196   virtual VMOp_Type type() const {
197     return VMOp_ZRelocateStart;
198   }
199 
200   virtual bool needs_inactive_gc_locker() const {
201     return true;
202   }
203 
204   virtual bool do_operation() {
205     ZStatTimer timer(ZPhasePauseRelocateStart);
206     ZServiceabilityRelocateStartTracer tracer;
207     ZHeap::heap()-&gt;relocate_start();
208     return true;
209   }
210 };
211 
<a name="5" id="anc5"></a>










212 ZDriver::ZDriver() :
213     _gc_cycle_port(),
214     _gc_locker_port() {
215   set_name(&quot;ZDriver&quot;);
216   create_and_start();
217 }
218 
219 void ZDriver::collect(GCCause::Cause cause) {
220   switch (cause) {
221   case GCCause::_wb_young_gc:
222   case GCCause::_wb_conc_mark:
223   case GCCause::_wb_full_gc:
224   case GCCause::_dcmd_gc_run:
225   case GCCause::_java_lang_system_gc:
226   case GCCause::_full_gc_alot:
227   case GCCause::_scavenge_alot:
228   case GCCause::_jvmti_force_gc:
229   case GCCause::_metadata_GC_clear_soft_refs:
230     // Start synchronous GC
231     _gc_cycle_port.send_sync(cause);
232     break;
233 
234   case GCCause::_z_timer:
235   case GCCause::_z_warmup:
236   case GCCause::_z_allocation_rate:
237   case GCCause::_z_allocation_stall:
238   case GCCause::_z_proactive:
<a name="6" id="anc6"></a>
239   case GCCause::_metadata_GC_threshold:
240     // Start asynchronous GC
241     _gc_cycle_port.send_async(cause);
242     break;
243 
244   case GCCause::_gc_locker:
245     // Restart VM operation previously blocked by the GC locker
246     _gc_locker_port.signal();
247     break;
248 
249   default:
250     // Other causes not supported
251     fatal(&quot;Unsupported GC cause (%s)&quot;, GCCause::to_string(cause));
252     break;
253   }
254 }
255 
256 template &lt;typename T&gt;
257 bool ZDriver::pause() {
258   for (;;) {
259     T op;
260     VMThread::execute(&amp;op);
261     if (op.gc_locked()) {
262       // Wait for GC to become unlocked and restart the VM operation
263       ZStatTimer timer(ZCriticalPhaseGCLockerStall);
264       _gc_locker_port.wait();
265       continue;
266     }
267 
268     // Notify VM operation completed
269     _gc_locker_port.ack();
270 
271     return op.success();
272   }
273 }
274 
275 void ZDriver::pause_mark_start() {
276   pause&lt;VM_ZMarkStart&gt;();
277 }
278 
279 void ZDriver::concurrent_mark() {
280   ZStatTimer timer(ZPhaseConcurrentMark);
281   ZHeap::heap()-&gt;mark(true /* initial */);
282 }
283 
284 bool ZDriver::pause_mark_end() {
285   return pause&lt;VM_ZMarkEnd&gt;();
286 }
287 
288 void ZDriver::concurrent_mark_continue() {
289   ZStatTimer timer(ZPhaseConcurrentMarkContinue);
290   ZHeap::heap()-&gt;mark(false /* initial */);
291 }
292 
293 void ZDriver::concurrent_process_non_strong_references() {
294   ZStatTimer timer(ZPhaseConcurrentProcessNonStrongReferences);
295   ZHeap::heap()-&gt;process_non_strong_references();
296 }
297 
298 void ZDriver::concurrent_reset_relocation_set() {
299   ZStatTimer timer(ZPhaseConcurrentResetRelocationSet);
300   ZHeap::heap()-&gt;reset_relocation_set();
301 }
302 
<a name="7" id="anc7"></a><span class="line-removed">303 void ZDriver::concurrent_destroy_detached_pages() {</span>
<span class="line-removed">304   ZStatTimer timer(ZPhaseConcurrentDestroyDetachedPages);</span>
<span class="line-removed">305   ZHeap::heap()-&gt;destroy_detached_pages();</span>
<span class="line-removed">306 }</span>
<span class="line-removed">307 </span>
308 void ZDriver::pause_verify() {
309   if (VerifyBeforeGC || VerifyDuringGC || VerifyAfterGC) {
<a name="8" id="anc8"></a>
310     VM_Verify op;
311     VMThread::execute(&amp;op);
<a name="9" id="anc9"></a>



312   }
313 }
314 
315 void ZDriver::concurrent_select_relocation_set() {
316   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
317   ZHeap::heap()-&gt;select_relocation_set();
318 }
319 
<a name="10" id="anc10"></a><span class="line-removed">320 void ZDriver::concurrent_prepare_relocation_set() {</span>
<span class="line-removed">321   ZStatTimer timer(ZPhaseConcurrentPrepareRelocationSet);</span>
<span class="line-removed">322   ZHeap::heap()-&gt;prepare_relocation_set();</span>
<span class="line-removed">323 }</span>
<span class="line-removed">324 </span>
325 void ZDriver::pause_relocate_start() {
326   pause&lt;VM_ZRelocateStart&gt;();
327 }
328 
329 void ZDriver::concurrent_relocate() {
330   ZStatTimer timer(ZPhaseConcurrentRelocated);
331   ZHeap::heap()-&gt;relocate();
332 }
333 
334 void ZDriver::check_out_of_memory() {
335   ZHeap::heap()-&gt;check_out_of_memory();
336 }
337 
338 class ZDriverGCScope : public StackObj {
339 private:
<a name="11" id="anc11"></a><span class="line-modified">340   GCIdMark      _gc_id;</span>
<span class="line-modified">341   GCCauseSetter _gc_cause_setter;</span>
<span class="line-modified">342   ZStatTimer    _timer;</span>

343 
344 public:
345   ZDriverGCScope(GCCause::Cause cause) :
346       _gc_id(),
<a name="12" id="anc12"></a>
347       _gc_cause_setter(ZCollectedHeap::heap(), cause),
348       _timer(ZPhaseCycle) {
349     // Update statistics
350     ZStatCycle::at_start();
351   }
352 
353   ~ZDriverGCScope() {
354     // Calculate boost factor
355     const double boost_factor = (double)ZHeap::heap()-&gt;nconcurrent_worker_threads() /
356                                 (double)ZHeap::heap()-&gt;nconcurrent_no_boost_worker_threads();
357 
358     // Update statistics
<a name="13" id="anc13"></a><span class="line-modified">359     ZStatCycle::at_end(boost_factor);</span>
360 
361     // Update data used by soft reference policy
362     Universe::update_heap_info_at_gc();
363   }
364 };
365 
366 void ZDriver::gc(GCCause::Cause cause) {
367   ZDriverGCScope scope(cause);
368 
369   // Phase 1: Pause Mark Start
370   pause_mark_start();
371 
372   // Phase 2: Concurrent Mark
373   concurrent_mark();
374 
375   // Phase 3: Pause Mark End
376   while (!pause_mark_end()) {
377     // Phase 3.5: Concurrent Mark Continue
378     concurrent_mark_continue();
379   }
380 
381   // Phase 4: Concurrent Process Non-Strong References
382   concurrent_process_non_strong_references();
383 
384   // Phase 5: Concurrent Reset Relocation Set
385   concurrent_reset_relocation_set();
386 
<a name="14" id="anc14"></a><span class="line-modified">387   // Phase 6: Concurrent Destroy Detached Pages</span>
<span class="line-removed">388   concurrent_destroy_detached_pages();</span>
<span class="line-removed">389 </span>
<span class="line-removed">390   // Phase 7: Pause Verify</span>
391   pause_verify();
392 
<a name="15" id="anc15"></a><span class="line-modified">393   // Phase 8: Concurrent Select Relocation Set</span>
394   concurrent_select_relocation_set();
395 
<a name="16" id="anc16"></a><span class="line-modified">396   // Phase 9: Concurrent Prepare Relocation Set</span>
<span class="line-removed">397   concurrent_prepare_relocation_set();</span>
<span class="line-removed">398 </span>
<span class="line-removed">399   // Phase 10: Pause Relocate Start</span>
400   pause_relocate_start();
401 
<a name="17" id="anc17"></a><span class="line-modified">402   // Phase 11: Concurrent Relocate</span>
403   concurrent_relocate();
404 }
405 
406 void ZDriver::run_service() {
407   // Main loop
408   while (!should_terminate()) {
409     // Wait for GC request
410     const GCCause::Cause cause = _gc_cycle_port.receive();
411     if (cause == GCCause::_no_gc) {
412       continue;
413     }
414 
415     // Run GC
416     gc(cause);
417 
418     // Notify GC completed
419     _gc_cycle_port.ack();
420 
421     // Check for out of memory condition
422     check_out_of_memory();
423   }
424 }
425 
426 void ZDriver::stop_service() {
427   _gc_cycle_port.send_async(GCCause::_no_gc);
428 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
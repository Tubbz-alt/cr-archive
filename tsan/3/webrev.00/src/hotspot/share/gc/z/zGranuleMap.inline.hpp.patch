diff a/src/hotspot/share/gc/z/zGranuleMap.inline.hpp b/src/hotspot/share/gc/z/zGranuleMap.inline.hpp
--- a/src/hotspot/share/gc/z/zGranuleMap.inline.hpp
+++ b/src/hotspot/share/gc/z/zGranuleMap.inline.hpp
@@ -22,63 +22,82 @@
  */
 
 #ifndef SHARE_GC_Z_ZGRANULEMAP_INLINE_HPP
 #define SHARE_GC_Z_ZGRANULEMAP_INLINE_HPP
 
-#include "gc/z/zAddress.inline.hpp"
 #include "gc/z/zGlobals.hpp"
 #include "gc/z/zGranuleMap.hpp"
 #include "memory/allocation.inline.hpp"
+#include "utilities/align.hpp"
+#include "utilities/debug.hpp"
 
 template <typename T>
-inline ZGranuleMap<T>::ZGranuleMap() :
-    _map(MmapArrayAllocator<T>::allocate(size(), mtGC)) {}
+inline ZGranuleMap<T>::ZGranuleMap(size_t max_offset) :
+    _size(max_offset >> ZGranuleSizeShift),
+    _map(MmapArrayAllocator<T>::allocate(_size, mtGC)) {
+  assert(is_aligned(max_offset, ZGranuleSize), "Misaligned");
+}
 
 template <typename T>
 inline ZGranuleMap<T>::~ZGranuleMap() {
-  MmapArrayAllocator<T>::free(_map, size());
+  MmapArrayAllocator<T>::free(_map, _size);
 }
 
 template <typename T>
-inline size_t ZGranuleMap<T>::index_for_addr(uintptr_t addr) const {
-  assert(!ZAddress::is_null(addr), "Invalid address");
-
-  const size_t index = ZAddress::offset(addr) >> ZGranuleSizeShift;
-  assert(index < size(), "Invalid index");
+inline size_t ZGranuleMap<T>::index_for_offset(uintptr_t offset) const {
+  const size_t index = offset >> ZGranuleSizeShift;
+  assert(index < _size, "Invalid index");
 
   return index;
 }
 
 template <typename T>
-inline size_t ZGranuleMap<T>::size() const {
-  return ZAddressOffsetMax >> ZGranuleSizeShift;
+inline T ZGranuleMap<T>::get(uintptr_t offset) const {
+  const size_t index = index_for_offset(offset);
+  return _map[index];
 }
 
 template <typename T>
-inline T ZGranuleMap<T>::get(uintptr_t addr) const {
-  const size_t index = index_for_addr(addr);
-  return _map[index];
+inline void ZGranuleMap<T>::put(uintptr_t offset, T value) {
+  const size_t index = index_for_offset(offset);
+  _map[index] = value;
 }
 
 template <typename T>
-inline void ZGranuleMap<T>::put(uintptr_t addr, T value) {
-  const size_t index = index_for_addr(addr);
-  _map[index] = value;
+inline void ZGranuleMap<T>::put(uintptr_t offset, size_t size, T value) {
+  assert(is_aligned(size, ZGranuleSize), "Misaligned");
+
+  const size_t start_index = index_for_offset(offset);
+  const size_t end_index = start_index + (size >> ZGranuleSizeShift);
+  for (size_t index = start_index; index < end_index; index++) {
+    _map[index] = value;
+  }
 }
 
 template <typename T>
 inline ZGranuleMapIterator<T>::ZGranuleMapIterator(const ZGranuleMap<T>* map) :
     _map(map),
     _next(0) {}
 
 template <typename T>
 inline bool ZGranuleMapIterator<T>::next(T* value) {
-  if (_next < _map->size()) {
+  if (_next < _map->_size) {
     *value = _map->_map[_next++];
     return true;
   }
 
   // End of map
   return false;
 }
 
+template <typename T>
+inline bool ZGranuleMapIterator<T>::next(T** value) {
+  if (_next < _map->_size) {
+    *value = _map->_map + _next++;
+    return true;
+  }
+
+  // End of map
+  return false;
+}
+
 #endif // SHARE_GC_Z_ZGRANULEMAP_INLINE_HPP

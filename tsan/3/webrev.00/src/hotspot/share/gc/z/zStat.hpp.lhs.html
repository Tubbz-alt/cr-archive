<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zStat.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZSTAT_HPP
 25 #define SHARE_GC_Z_ZSTAT_HPP
 26 
 27 #include &quot;gc/shared/concurrentGCThread.hpp&quot;
<a name="2" id="anc2"></a>
 28 #include &quot;gc/shared/gcTimer.hpp&quot;
 29 #include &quot;gc/z/zMetronome.hpp&quot;
 30 #include &quot;logging/logHandle.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
<a name="3" id="anc3"></a>
 32 #include &quot;utilities/numberSeq.hpp&quot;
 33 #include &quot;utilities/ticks.hpp&quot;
 34 
 35 class ZPage;
<a name="4" id="anc4"></a>

 36 class ZStatSampler;
 37 class ZStatSamplerHistory;
 38 struct ZStatCounterData;
 39 struct ZStatSamplerData;
 40 
 41 //
 42 // Stat unit printers
 43 //
 44 typedef void (*ZStatUnitPrinter)(LogTargetHandle log, const ZStatSampler&amp;, const ZStatSamplerHistory&amp;);
 45 
 46 void ZStatUnitTime(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 47 void ZStatUnitBytes(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 48 void ZStatUnitThreads(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 49 void ZStatUnitBytesPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 50 void ZStatUnitOpsPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history);
 51 
 52 //
 53 // Stat value
 54 //
 55 class ZStatValue {
 56 private:
 57   static uintptr_t _base;
 58   static uint32_t  _cpu_offset;
 59 
 60   const char* const _group;
 61   const char* const _name;
 62   const uint32_t    _id;
 63   const uint32_t    _offset;
 64 
 65 protected:
 66   ZStatValue(const char* group,
 67              const char* name,
 68              uint32_t id,
 69              uint32_t size);
 70 
 71   template &lt;typename T&gt; T* get_cpu_local(uint32_t cpu) const;
 72 
 73 public:
 74   static void initialize();
 75 
 76   const char* group() const;
 77   const char* name() const;
 78   uint32_t id() const;
 79 };
 80 
 81 //
 82 // Stat iterable value
 83 //
 84 template &lt;typename T&gt;
 85 class ZStatIterableValue : public ZStatValue {
 86 private:
 87   static uint32_t _count;
 88   static T*       _first;
 89 
 90   T* _next;
 91 
 92   T* insert() const;
 93 
 94 protected:
 95   ZStatIterableValue(const char* group,
 96                      const char* name,
 97                      uint32_t size);
 98 
 99 public:
100   static uint32_t count() {
101     return _count;
102   }
103 
104   static T* first() {
105     return _first;
106   }
107 
108   T* next() const {
109     return _next;
110   }
111 };
112 
113 //
114 // Stat sampler
115 //
116 class ZStatSampler : public ZStatIterableValue&lt;ZStatSampler&gt; {
117 private:
118   const ZStatUnitPrinter _printer;
119 
120 public:
121   ZStatSampler(const char* group,
122                const char* name,
123                ZStatUnitPrinter printer);
124 
125   ZStatSamplerData* get() const;
126   ZStatSamplerData collect_and_reset() const;
127 
128   ZStatUnitPrinter printer() const;
129 };
130 
131 //
132 // Stat counter
133 //
134 class ZStatCounter : public ZStatIterableValue&lt;ZStatCounter&gt; {
135 private:
136   const ZStatSampler _sampler;
137 
138 public:
139   ZStatCounter(const char* group,
140                const char* name,
141                ZStatUnitPrinter printer);
142 
143   ZStatCounterData* get() const;
144   void sample_and_reset() const;
145 };
146 
147 //
148 // Stat unsampled counter
149 //
150 class ZStatUnsampledCounter : public ZStatIterableValue&lt;ZStatUnsampledCounter&gt; {
151 public:
152   ZStatUnsampledCounter(const char* name);
153 
154   ZStatCounterData* get() const;
155   ZStatCounterData collect_and_reset() const;
156 };
157 
158 //
159 // Stat MMU (Minimum Mutator Utilization)
160 //
161 class ZStatMMUPause {
162 private:
163   double _start;
164   double _end;
165 
166 public:
167   ZStatMMUPause();
168   ZStatMMUPause(const Ticks&amp; start, const Ticks&amp; end);
169 
170   double end() const;
171   double overlap(double start, double end) const;
172 };
173 
174 class ZStatMMU {
175 private:
176   static size_t        _next;
177   static size_t        _npauses;
178   static ZStatMMUPause _pauses[200]; // Record the last 200 pauses
179 
180   static double _mmu_2ms;
181   static double _mmu_5ms;
182   static double _mmu_10ms;
183   static double _mmu_20ms;
184   static double _mmu_50ms;
185   static double _mmu_100ms;
186 
187   static const ZStatMMUPause&amp; pause(size_t index);
188   static double calculate_mmu(double time_slice);
189 
190 public:
191   static void register_pause(const Ticks&amp; start, const Ticks&amp; end);
192 
193   static void print();
194 };
195 
196 //
197 // Stat phases
198 //
199 class ZStatPhase {
200 private:
201   static ConcurrentGCTimer _timer;
202 
203 protected:
204   const ZStatSampler _sampler;
205 
206   ZStatPhase(const char* group, const char* name);
207 
208   void log_start(LogTargetHandle log, bool thread = false) const;
209   void log_end(LogTargetHandle log, const Tickspan&amp; duration, bool thread = false) const;
210 
211 public:
212   static ConcurrentGCTimer* timer();
213 
214   const char* name() const;
215 
216   virtual void register_start(const Ticks&amp; start) const = 0;
217   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const = 0;
218 };
219 
220 class ZStatPhaseCycle : public ZStatPhase {
221 public:
222   ZStatPhaseCycle(const char* name);
223 
224   virtual void register_start(const Ticks&amp; start) const;
225   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
226 };
227 
228 class ZStatPhasePause : public ZStatPhase {
229 private:
230   static Tickspan _max; // Max pause time
231 
232 public:
233   ZStatPhasePause(const char* name);
234 
235   static const Tickspan&amp; max();
236 
237   virtual void register_start(const Ticks&amp; start) const;
238   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
239 };
240 
241 class ZStatPhaseConcurrent : public ZStatPhase {
242 public:
243   ZStatPhaseConcurrent(const char* name);
244 
245   virtual void register_start(const Ticks&amp; start) const;
246   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
247 };
248 
249 class ZStatSubPhase : public ZStatPhase {
250 public:
251   ZStatSubPhase(const char* name);
252 
253   virtual void register_start(const Ticks&amp; start) const;
254   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
255 };
256 
257 class ZStatCriticalPhase : public ZStatPhase {
258 private:
259   const ZStatCounter _counter;
260   const bool         _verbose;
261 
262 public:
263   ZStatCriticalPhase(const char* name, bool verbose = true);
264 
265   virtual void register_start(const Ticks&amp; start) const;
266   virtual void register_end(const Ticks&amp; start, const Ticks&amp; end) const;
267 };
268 
269 //
270 // Stat timer
271 //
<a name="5" id="anc5"></a>

















272 class ZStatTimer : public StackObj {
273 private:
<a name="6" id="anc6"></a>
274   const ZStatPhase&amp; _phase;
275   const Ticks       _start;
276 
277 public:
278   ZStatTimer(const ZStatPhase&amp; phase) :
<a name="7" id="anc7"></a>
279       _phase(phase),
280       _start(Ticks::now()) {
<a name="8" id="anc8"></a><span class="line-modified">281     _phase.register_start(_start);</span>


282   }
283 
284   ~ZStatTimer() {
<a name="9" id="anc9"></a><span class="line-modified">285     const Ticks end = Ticks::now();</span>
<span class="line-modified">286     _phase.register_end(_start, end);</span>


287   }
288 };
289 
290 //
291 // Stat sample/increment
292 //
<a name="10" id="anc10"></a><span class="line-modified">293 void ZStatSample(const ZStatSampler&amp; sampler, uint64_t value, bool trace = ZStatisticsForceTrace);</span>
<span class="line-modified">294 void ZStatInc(const ZStatCounter&amp; counter, uint64_t increment = 1, bool trace = ZStatisticsForceTrace);</span>
295 void ZStatInc(const ZStatUnsampledCounter&amp; counter, uint64_t increment = 1);
296 
297 //
298 // Stat allocation rate
299 //
300 class ZStatAllocRate : public AllStatic {
301 private:
302   static const ZStatUnsampledCounter _counter;
303   static TruncatedSeq                _rate;     // B/s
304   static TruncatedSeq                _rate_avg; // B/s
305 
306 public:
307   static const uint64_t sample_window_sec = 1; // seconds
308   static const uint64_t sample_hz         = 10;
309 
310   static const ZStatUnsampledCounter&amp; counter();
311   static uint64_t sample_and_reset();
312 
313   static double avg();
314   static double avg_sd();
315 };
316 
317 //
318 // Stat thread
319 //
320 class ZStat : public ConcurrentGCThread {
321 private:
322   static const uint64_t sample_hz = 1;
323 
324   ZMetronome _metronome;
325 
326   void sample_and_collect(ZStatSamplerHistory* history) const;
327   bool should_print(LogTargetHandle log) const;
328   void print(LogTargetHandle log, const ZStatSamplerHistory* history) const;
329 
330 protected:
331   virtual void run_service();
332   virtual void stop_service();
333 
334 public:
335   ZStat();
336 };
337 
338 //
339 // Stat cycle
340 //
341 class ZStatCycle : public AllStatic {
342 private:
<a name="11" id="anc11"></a><span class="line-modified">343   static uint64_t  _ncycles;</span>
344   static Ticks     _start_of_last;
345   static Ticks     _end_of_last;
346   static NumberSeq _normalized_duration;
347 
348 public:
349   static void at_start();
<a name="12" id="anc12"></a><span class="line-modified">350   static void at_end(double boost_factor);</span>
351 
<a name="13" id="anc13"></a><span class="line-modified">352   static uint64_t ncycles();</span>



353   static const AbsSeq&amp; normalized_duration();
<a name="14" id="anc14"></a>
354   static double time_since_last();
355 };
356 
357 //
358 // Stat load
359 //
360 class ZStatLoad : public AllStatic {
361 public:
362   static void print();
363 };
364 
365 //
366 // Stat mark
367 //
368 class ZStatMark : public AllStatic {
369 private:
370   static size_t _nstripes;
371   static size_t _nproactiveflush;
372   static size_t _nterminateflush;
373   static size_t _ntrycomplete;
374   static size_t _ncontinue;
375 
376 public:
377   static void set_at_mark_start(size_t nstripes);
378   static void set_at_mark_end(size_t nproactiveflush,
379                               size_t nterminateflush,
380                               size_t ntrycomplete,
381                               size_t ncontinue);
382 
383   static void print();
384 };
385 
386 //
387 // Stat relocation
388 //
389 class ZStatRelocation : public AllStatic {
390 private:
<a name="15" id="anc15"></a><span class="line-modified">391   static size_t _relocating;</span>
<span class="line-modified">392   static bool   _success;</span>


393 
394 public:
<a name="16" id="anc16"></a><span class="line-modified">395   static void set_at_select_relocation_set(size_t relocating);</span>
396   static void set_at_relocate_end(bool success);
397 
398   static void print();
399 };
400 
401 //
402 // Stat nmethods
403 //
404 class ZStatNMethods : public AllStatic {
405 public:
406   static void print();
407 };
408 
409 //
410 // Stat metaspace
411 //
412 class ZStatMetaspace : public AllStatic {
413 public:
414   static void print();
415 };
416 
417 //
418 // Stat references
419 //
420 class ZStatReferences : public AllStatic {
421 private:
422   static struct ZCount {
423     size_t encountered;
424     size_t discovered;
425     size_t enqueued;
426   } _soft, _weak, _final, _phantom;
427 
428   static void set(ZCount* count, size_t encountered, size_t discovered, size_t enqueued);
429   static void print(const char* name, const ZCount&amp; ref);
430 
431 public:
432   static void set_soft(size_t encountered, size_t discovered, size_t enqueued);
433   static void set_weak(size_t encountered, size_t discovered, size_t enqueued);
434   static void set_final(size_t encountered, size_t discovered, size_t enqueued);
435   static void set_phantom(size_t encountered, size_t discovered, size_t enqueued);
436 
437   static void print();
438 };
439 
440 //
441 // Stat heap
442 //
443 class ZStatHeap : public AllStatic {
444 private:
445   static struct ZAtInitialize {
<a name="17" id="anc17"></a>
446     size_t max_capacity;
447     size_t max_reserve;
448   } _at_initialize;
449 
450   static struct ZAtMarkStart {
<a name="18" id="anc18"></a>
451     size_t capacity;
452     size_t reserve;
453     size_t used;
454     size_t free;
455   } _at_mark_start;
456 
457   static struct ZAtMarkEnd {
458     size_t capacity;
459     size_t reserve;
460     size_t allocated;
461     size_t used;
462     size_t free;
463     size_t live;
464     size_t garbage;
465   } _at_mark_end;
466 
467   static struct ZAtRelocateStart {
468     size_t capacity;
469     size_t reserve;
470     size_t garbage;
471     size_t allocated;
472     size_t reclaimed;
473     size_t used;
474     size_t free;
475   } _at_relocate_start;
476 
477   static struct ZAtRelocateEnd {
478     size_t capacity;
479     size_t capacity_high;
480     size_t capacity_low;
481     size_t reserve;
482     size_t reserve_high;
483     size_t reserve_low;
484     size_t garbage;
485     size_t allocated;
486     size_t reclaimed;
487     size_t used;
488     size_t used_high;
489     size_t used_low;
490     size_t free;
491     size_t free_high;
492     size_t free_low;
493   } _at_relocate_end;
494 
<a name="19" id="anc19"></a>

495   static size_t available(size_t used);
496   static size_t reserve(size_t used);
497   static size_t free(size_t used);
498 
499 public:
<a name="20" id="anc20"></a><span class="line-modified">500   static void set_at_initialize(size_t max_capacity,</span>

501                                 size_t max_reserve);
<a name="21" id="anc21"></a><span class="line-modified">502   static void set_at_mark_start(size_t capacity,</span>

503                                 size_t used);
504   static void set_at_mark_end(size_t capacity,
505                               size_t allocated,
506                               size_t used);
<a name="22" id="anc22"></a><span class="line-modified">507   static void set_at_select_relocation_set(size_t live,</span>
<span class="line-removed">508                                            size_t garbage,</span>
509                                            size_t reclaimed);
510   static void set_at_relocate_start(size_t capacity,
511                                     size_t allocated,
512                                     size_t used);
513   static void set_at_relocate_end(size_t capacity,
514                                   size_t allocated,
515                                   size_t reclaimed,
516                                   size_t used,
517                                   size_t used_high,
518                                   size_t used_low);
519 
520   static size_t max_capacity();
521   static size_t used_at_mark_start();
522   static size_t used_at_relocate_end();
523 
524   static void print();
525 };
526 
527 #endif // SHARE_GC_Z_ZSTAT_HPP
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
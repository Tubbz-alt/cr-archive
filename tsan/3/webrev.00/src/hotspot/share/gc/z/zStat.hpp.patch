diff a/src/hotspot/share/gc/z/zStat.hpp b/src/hotspot/share/gc/z/zStat.hpp
--- a/src/hotspot/share/gc/z/zStat.hpp
+++ b/src/hotspot/share/gc/z/zStat.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,18 +23,22 @@
 
 #ifndef SHARE_GC_Z_ZSTAT_HPP
 #define SHARE_GC_Z_ZSTAT_HPP
 
 #include "gc/shared/concurrentGCThread.hpp"
+#include "gc/shared/gcCause.hpp"
 #include "gc/shared/gcTimer.hpp"
 #include "gc/z/zMetronome.hpp"
 #include "logging/logHandle.hpp"
 #include "memory/allocation.hpp"
+#include "utilities/globalDefinitions.hpp"
 #include "utilities/numberSeq.hpp"
 #include "utilities/ticks.hpp"
 
 class ZPage;
+class ZRelocationSetSelectorGroupStats;
+class ZRelocationSetSelectorStats;
 class ZStatSampler;
 class ZStatSamplerHistory;
 struct ZStatCounterData;
 struct ZStatSamplerData;
 
@@ -267,33 +271,57 @@
 };
 
 //
 // Stat timer
 //
+class ZStatTimerDisable : public StackObj {
+private:
+  static THREAD_LOCAL uint32_t _active;
+
+public:
+  ZStatTimerDisable() {
+    _active++;
+  }
+
+  ~ZStatTimerDisable() {
+    _active--;
+  }
+
+  static bool is_active() {
+    return _active > 0;
+  }
+};
+
 class ZStatTimer : public StackObj {
 private:
+  const bool        _enabled;
   const ZStatPhase& _phase;
   const Ticks       _start;
 
 public:
   ZStatTimer(const ZStatPhase& phase) :
+      _enabled(!ZStatTimerDisable::is_active()),
       _phase(phase),
       _start(Ticks::now()) {
-    _phase.register_start(_start);
+    if (_enabled) {
+      _phase.register_start(_start);
+    }
   }
 
   ~ZStatTimer() {
-    const Ticks end = Ticks::now();
-    _phase.register_end(_start, end);
+    if (_enabled) {
+      const Ticks end = Ticks::now();
+      _phase.register_end(_start, end);
+    }
   }
 };
 
 //
 // Stat sample/increment
 //
-void ZStatSample(const ZStatSampler& sampler, uint64_t value, bool trace = ZStatisticsForceTrace);
-void ZStatInc(const ZStatCounter& counter, uint64_t increment = 1, bool trace = ZStatisticsForceTrace);
+void ZStatSample(const ZStatSampler& sampler, uint64_t value);
+void ZStatInc(const ZStatCounter& counter, uint64_t increment = 1);
 void ZStatInc(const ZStatUnsampledCounter& counter, uint64_t increment = 1);
 
 //
 // Stat allocation rate
 //
@@ -338,21 +366,25 @@
 //
 // Stat cycle
 //
 class ZStatCycle : public AllStatic {
 private:
-  static uint64_t  _ncycles;
+  static uint64_t  _nwarmup_cycles;
   static Ticks     _start_of_last;
   static Ticks     _end_of_last;
   static NumberSeq _normalized_duration;
 
 public:
   static void at_start();
-  static void at_end(double boost_factor);
+  static void at_end(GCCause::Cause cause, double boost_factor);
 
-  static uint64_t ncycles();
+  static bool is_warm();
+  static uint64_t nwarmup_cycles();
+
+  static bool is_normalized_duration_trustable();
   static const AbsSeq& normalized_duration();
+
   static double time_since_last();
 };
 
 //
 // Stat load
@@ -386,15 +418,17 @@
 //
 // Stat relocation
 //
 class ZStatRelocation : public AllStatic {
 private:
-  static size_t _relocating;
-  static bool   _success;
+  static ZRelocationSetSelectorStats _stats;
+  static bool                        _success;
+
+  static void print(const char* name, const ZRelocationSetSelectorGroupStats& group);
 
 public:
-  static void set_at_select_relocation_set(size_t relocating);
+  static void set_at_select_relocation_set(const ZRelocationSetSelectorStats& stats);
   static void set_at_relocate_end(bool success);
 
   static void print();
 };
 
@@ -441,15 +475,17 @@
 // Stat heap
 //
 class ZStatHeap : public AllStatic {
 private:
   static struct ZAtInitialize {
+    size_t min_capacity;
     size_t max_capacity;
     size_t max_reserve;
   } _at_initialize;
 
   static struct ZAtMarkStart {
+    size_t soft_max_capacity;
     size_t capacity;
     size_t reserve;
     size_t used;
     size_t free;
   } _at_mark_start;
@@ -490,24 +526,27 @@
     size_t free;
     size_t free_high;
     size_t free_low;
   } _at_relocate_end;
 
+  static size_t capacity_high();
+  static size_t capacity_low();
   static size_t available(size_t used);
   static size_t reserve(size_t used);
   static size_t free(size_t used);
 
 public:
-  static void set_at_initialize(size_t max_capacity,
+  static void set_at_initialize(size_t min_capacity,
+                                size_t max_capacity,
                                 size_t max_reserve);
-  static void set_at_mark_start(size_t capacity,
+  static void set_at_mark_start(size_t soft_max_capacity,
+                                size_t capacity,
                                 size_t used);
   static void set_at_mark_end(size_t capacity,
                               size_t allocated,
                               size_t used);
-  static void set_at_select_relocation_set(size_t live,
-                                           size_t garbage,
+  static void set_at_select_relocation_set(const ZRelocationSetSelectorStats& stats,
                                            size_t reclaimed);
   static void set_at_relocate_start(size_t capacity,
                                     size_t allocated,
                                     size_t used);
   static void set_at_relocate_end(size_t capacity,

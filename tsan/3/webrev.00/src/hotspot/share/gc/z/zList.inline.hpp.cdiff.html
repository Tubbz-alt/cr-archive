<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zList.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zLiveMap.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zList.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,24 ***</span>
  
  #ifndef SHARE_GC_Z_ZLIST_INLINE_HPP
  #define SHARE_GC_Z_ZLIST_INLINE_HPP
  
  #include &quot;gc/z/zList.hpp&quot;
  
  template &lt;typename T, bool forward&gt;
<span class="line-modified">! ZListIteratorImpl&lt;T, forward&gt;::ZListIteratorImpl(ZList&lt;T&gt;* list) :</span>
      _list(list),
      _next(forward ? list-&gt;first() : list-&gt;last()) {}
  
  template &lt;typename T, bool forward&gt;
<span class="line-modified">! bool ZListIteratorImpl&lt;T, forward&gt;::next(T** elem) {</span>
    if (_next != NULL) {
      *elem = _next;
      _next = forward ? _list-&gt;next(_next) : _list-&gt;prev(_next);
      return true;
    }
  
    // No more elements
    return false;
  }
  
  #endif // SHARE_GC_Z_ZLIST_INLINE_HPP
<span class="line-new-header">--- 23,211 ---</span>
  
  #ifndef SHARE_GC_Z_ZLIST_INLINE_HPP
  #define SHARE_GC_Z_ZLIST_INLINE_HPP
  
  #include &quot;gc/z/zList.hpp&quot;
<span class="line-added">+ #include &quot;utilities/debug.hpp&quot;</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListNode&lt;T&gt;::ZListNode(ZListNode* next, ZListNode* prev) :</span>
<span class="line-added">+     _next(next),</span>
<span class="line-added">+     _prev(prev) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZListNode&lt;T&gt;::set_unused() {</span>
<span class="line-added">+   _next = NULL;</span>
<span class="line-added">+   _prev = NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListNode&lt;T&gt;::ZListNode() {</span>
<span class="line-added">+   set_unused();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListNode&lt;T&gt;::~ZListNode() {</span>
<span class="line-added">+   set_unused();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline bool ZListNode&lt;T&gt;::is_unused() const {</span>
<span class="line-added">+   return _next == NULL &amp;&amp; _prev == NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::verify() const {</span>
<span class="line-added">+   assert(_head._next-&gt;_prev == &amp;_head, &quot;List corrupt&quot;);</span>
<span class="line-added">+   assert(_head._prev-&gt;_next == &amp;_head, &quot;List corrupt&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::insert(ZListNode&lt;T&gt;* before, ZListNode&lt;T&gt;* node) {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(node-&gt;is_unused(), &quot;Already in a list&quot;);</span>
<span class="line-added">+   node-&gt;_prev = before;</span>
<span class="line-added">+   node-&gt;_next = before-&gt;_next;</span>
<span class="line-added">+   before-&gt;_next = node;</span>
<span class="line-added">+   node-&gt;_next-&gt;_prev = node;</span>
<span class="line-added">+ </span>
<span class="line-added">+   _size++;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListNode&lt;T&gt;* ZList&lt;T&gt;::cast_to_inner(T* elem) const {</span>
<span class="line-added">+   return &amp;elem-&gt;_node;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::cast_to_outer(ZListNode&lt;T&gt;* node) const {</span>
<span class="line-added">+   return (T*)((uintptr_t)node - offset_of(T, _node));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZList&lt;T&gt;::ZList() :</span>
<span class="line-added">+     _head(&amp;_head, &amp;_head),</span>
<span class="line-added">+     _size(0) {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline size_t ZList&lt;T&gt;::size() const {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+   return _size;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline bool ZList&lt;T&gt;::is_empty() const {</span>
<span class="line-added">+   return _size == 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::first() const {</span>
<span class="line-added">+   return is_empty() ? NULL : cast_to_outer(_head._next);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::last() const {</span>
<span class="line-added">+   return is_empty() ? NULL : cast_to_outer(_head._prev);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::next(T* elem) const {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+   ZListNode&lt;T&gt;* next = cast_to_inner(elem)-&gt;_next;</span>
<span class="line-added">+   return (next == &amp;_head) ? NULL : cast_to_outer(next);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::prev(T* elem) const {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+   ZListNode&lt;T&gt;* prev = cast_to_inner(elem)-&gt;_prev;</span>
<span class="line-added">+   return (prev == &amp;_head) ? NULL : cast_to_outer(prev);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::insert_first(T* elem) {</span>
<span class="line-added">+   insert(&amp;_head, cast_to_inner(elem));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::insert_last(T* elem) {</span>
<span class="line-added">+   insert(_head._prev, cast_to_inner(elem));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::insert_before(T* before, T* elem) {</span>
<span class="line-added">+   insert(cast_to_inner(before)-&gt;_prev, cast_to_inner(elem));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::insert_after(T* after, T* elem) {</span>
<span class="line-added">+   insert(cast_to_inner(after), cast_to_inner(elem));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::remove(T* elem) {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZListNode&lt;T&gt;* const node = cast_to_inner(elem);</span>
<span class="line-added">+   assert(!node-&gt;is_unused(), &quot;Not in a list&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZListNode&lt;T&gt;* const next = node-&gt;_next;</span>
<span class="line-added">+   ZListNode&lt;T&gt;* const prev = node-&gt;_prev;</span>
<span class="line-added">+   assert(next-&gt;_prev == node, &quot;List corrupt&quot;);</span>
<span class="line-added">+   assert(prev-&gt;_next == node, &quot;List corrupt&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   prev-&gt;_next = next;</span>
<span class="line-added">+   next-&gt;_prev = prev;</span>
<span class="line-added">+   node-&gt;set_unused();</span>
<span class="line-added">+ </span>
<span class="line-added">+   _size--;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::remove_first() {</span>
<span class="line-added">+   T* elem = first();</span>
<span class="line-added">+   if (elem != NULL) {</span>
<span class="line-added">+     remove(elem);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return elem;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline T* ZList&lt;T&gt;::remove_last() {</span>
<span class="line-added">+   T* elem = last();</span>
<span class="line-added">+   if (elem != NULL) {</span>
<span class="line-added">+     remove(elem);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return elem;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void ZList&lt;T&gt;::transfer(ZList&lt;T&gt;* list) {</span>
<span class="line-added">+   verify();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!list-&gt;is_empty()) {</span>
<span class="line-added">+     list-&gt;_head._next-&gt;_prev = _head._prev;</span>
<span class="line-added">+     list-&gt;_head._prev-&gt;_next = _head._prev-&gt;_next;</span>
<span class="line-added">+ </span>
<span class="line-added">+     _head._prev-&gt;_next = list-&gt;_head._next;</span>
<span class="line-added">+     _head._prev = list-&gt;_head._prev;</span>
<span class="line-added">+ </span>
<span class="line-added">+     list-&gt;_head._next = &amp;list-&gt;_head;</span>
<span class="line-added">+     list-&gt;_head._prev = &amp;list-&gt;_head;</span>
<span class="line-added">+ </span>
<span class="line-added">+     _size += list-&gt;_size;</span>
<span class="line-added">+     list-&gt;_size = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     list-&gt;verify();</span>
<span class="line-added">+     verify();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  template &lt;typename T, bool forward&gt;
<span class="line-modified">! inline ZListIteratorImpl&lt;T, forward&gt;::ZListIteratorImpl(const ZList&lt;T&gt;* list) :</span>
      _list(list),
      _next(forward ? list-&gt;first() : list-&gt;last()) {}
  
  template &lt;typename T, bool forward&gt;
<span class="line-modified">! inline bool ZListIteratorImpl&lt;T, forward&gt;::next(T** elem) {</span>
    if (_next != NULL) {
      *elem = _next;
      _next = forward ? _list-&gt;next(_next) : _list-&gt;prev(_next);
      return true;
    }
  
    // No more elements
    return false;
  }
  
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListIterator&lt;T&gt;::ZListIterator(const ZList&lt;T&gt;* list) :</span>
<span class="line-added">+     ZListIteratorImpl&lt;T, ZLIST_FORWARD&gt;(list) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline ZListReverseIterator&lt;T&gt;::ZListReverseIterator(const ZList&lt;T&gt;* list) :</span>
<span class="line-added">+     ZListIteratorImpl&lt;T, ZLIST_REVERSE&gt;(list) {}</span>
<span class="line-added">+ </span>
  #endif // SHARE_GC_Z_ZLIST_INLINE_HPP
</pre>
<center><a href="zList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zLiveMap.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zValue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZVALUE_HPP
 25 #define SHARE_GC_Z_ZVALUE_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 
 30 //
 31 // Storage
 32 //
 33 
 34 template &lt;typename S&gt;
 35 class ZValueStorage : public AllStatic {
 36 private:
 37   static uintptr_t _top;
 38   static uintptr_t _end;
 39 
 40 public:
 41   static const size_t offset = 4 * K;
 42 
 43   static uintptr_t alloc(size_t size);
 44 };
 45 
 46 class ZContendedStorage : public ZValueStorage&lt;ZContendedStorage&gt; {
 47 public:
 48   static size_t alignment();
 49   static uint32_t count();
 50   static uint32_t id();
 51 };
 52 
 53 class ZPerCPUStorage : public ZValueStorage&lt;ZPerCPUStorage&gt; {
 54 public:
 55   static size_t alignment();
 56   static uint32_t count();
 57   static uint32_t id();
 58 };
 59 
 60 class ZPerNUMAStorage : public ZValueStorage&lt;ZPerNUMAStorage&gt; {
 61 public:
 62   static size_t alignment();
 63   static uint32_t count();
 64   static uint32_t id();
 65 };
 66 
 67 class ZPerWorkerStorage : public ZValueStorage&lt;ZPerWorkerStorage&gt; {
 68 public:
 69   static size_t alignment();
 70   static uint32_t count();
 71   static uint32_t id();
 72 };
 73 
 74 //
 75 // Value
 76 //
 77 
 78 template &lt;typename S, typename T&gt;
 79 class ZValue : public CHeapObj&lt;mtGC&gt; {
 80 private:
 81   const uintptr_t _addr;
 82 
 83   uintptr_t value_addr(uint32_t value_id) const;
 84 
 85 public:
 86   ZValue();
 87   ZValue(const T&amp; value);
 88 
 89   const T* addr(uint32_t value_id = S::id()) const;
 90   T* addr(uint32_t value_id = S::id());
 91 
 92   const T&amp; get(uint32_t value_id = S::id()) const;
 93   T&amp; get(uint32_t value_id = S::id());
 94 
 95   void set(const T&amp; value, uint32_t value_id = S::id());
 96   void set_all(const T&amp; value);
 97 };
 98 
 99 template &lt;typename T&gt;
100 class ZContended : public ZValue&lt;ZContendedStorage, T&gt; {
101 public:
102   ZContended();
103   ZContended(const T&amp; value);
104 };
105 
106 template &lt;typename T&gt;
107 class ZPerCPU : public ZValue&lt;ZPerCPUStorage, T&gt; {
108 public:
109   ZPerCPU();
110   ZPerCPU(const T&amp; value);
111 };
112 
113 template &lt;typename T&gt;
114 class ZPerNUMA : public ZValue&lt;ZPerNUMAStorage, T&gt; {
115 public:
116   ZPerNUMA();
117   ZPerNUMA(const T&amp; value);
118 };
119 
120 template &lt;typename T&gt;
121 class ZPerWorker : public ZValue&lt;ZPerWorkerStorage, T&gt; {
122 public:
123   ZPerWorker();
124   ZPerWorker(const T&amp; value);
125 };
126 
127 //
128 // Iterator
129 //
130 
131 template &lt;typename S, typename T&gt;
132 class ZValueIterator {
133 private:
134   ZValue&lt;S, T&gt;* const _value;
135   uint32_t            _value_id;
136 
137 public:
138   ZValueIterator(ZValue&lt;S, T&gt;* value);
139 
140   bool next(T** value);
141 };
142 
143 template &lt;typename T&gt;
144 class ZPerCPUIterator : public ZValueIterator&lt;ZPerCPUStorage, T&gt; {
145 public:
146   ZPerCPUIterator(ZPerCPU&lt;T&gt;* value);
147 };
148 
149 template &lt;typename T&gt;
150 class ZPerNUMAIterator : public ZValueIterator&lt;ZPerNUMAStorage, T&gt; {
151 public:
152   ZPerNUMAIterator(ZPerNUMA&lt;T&gt;* value);
153 };
154 
155 template &lt;typename T&gt;
156 class ZPerWorkerIterator : public ZValueIterator&lt;ZPerWorkerStorage, T&gt; {
157 public:
158   ZPerWorkerIterator(ZPerWorker&lt;T&gt;* value);
159 };
160 
161 template &lt;typename S, typename T&gt;
162 class ZValueConstIterator {
163 private:
164   const ZValue&lt;S, T&gt;* const _value;
165   uint32_t                  _value_id;
166 
167 public:
168   ZValueConstIterator(const ZValue&lt;S, T&gt;* value);
169 
170   bool next(const T** value);
171 };
172 
173 template &lt;typename T&gt;
174 class ZPerCPUConstIterator : public ZValueConstIterator&lt;ZPerCPUStorage, T&gt; {
175 public:
176   ZPerCPUConstIterator(const ZPerCPU&lt;T&gt;* value);
177 };
178 
179 template &lt;typename T&gt;
180 class ZPerNUMAConstIterator : public ZValueConstIterator&lt;ZPerNUMAStorage, T&gt; {
181 public:
182   ZPerNUMAConstIterator(const ZPerNUMA&lt;T&gt;* value);
183 };
184 
185 template &lt;typename T&gt;
186 class ZPerWorkerConstIterator : public ZValueConstIterator&lt;ZPerWorkerStorage, T&gt; {
187 public:
188   ZPerWorkerConstIterator(const ZPerWorker&lt;T&gt;* value);
189 };
190 
191 #endif // SHARE_GC_Z_ZVALUE_HPP
    </pre>
  </body>
</html>
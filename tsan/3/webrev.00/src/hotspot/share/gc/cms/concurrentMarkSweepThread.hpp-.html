<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/concurrentMarkSweepThread.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_CONCURRENTMARKSWEEPTHREAD_HPP
 26 #define SHARE_GC_CMS_CONCURRENTMARKSWEEPTHREAD_HPP
 27 
 28 #include &quot;gc/cms/concurrentMarkSweepGeneration.hpp&quot;
 29 #include &quot;gc/shared/concurrentGCThread.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 
 32 class ConcurrentMarkSweepGeneration;
 33 class CMSCollector;
 34 
 35 // The Concurrent Mark Sweep GC Thread
 36 class ConcurrentMarkSweepThread: public ConcurrentGCThread {
 37   friend class VMStructs;
 38   friend class ConcurrentMarkSweepGeneration;   // XXX should remove friendship
 39   friend class CMSCollector;
 40 
 41  private:
 42   static ConcurrentMarkSweepThread* _cmst;
 43   static CMSCollector*              _collector;
 44 
 45   enum CMS_flag_type {
 46     CMS_nil             = NoBits,
 47     CMS_cms_wants_token = nth_bit(0),
 48     CMS_cms_has_token   = nth_bit(1),
 49     CMS_vm_wants_token  = nth_bit(2),
 50     CMS_vm_has_token    = nth_bit(3)
 51   };
 52 
 53   static int _CMS_flag;
 54 
 55   static bool CMS_flag_is_set(int b)        { return (_CMS_flag &amp; b) != 0;   }
 56   static bool set_CMS_flag(int b)           { return (_CMS_flag |= b) != 0;  }
 57   static bool clear_CMS_flag(int b)         { return (_CMS_flag &amp;= ~b) != 0; }
 58   void sleepBeforeNextCycle();
 59 
 60   // CMS thread should yield for a young gen collection and direct allocations
 61   static char _pad_1[64 - sizeof(jint)];    // prevent cache-line sharing
 62   static volatile jint _pending_yields;
 63   static char _pad_2[64 - sizeof(jint)];    // prevent cache-line sharing
 64 
 65   // debugging
 66   void verify_ok_to_terminate() const PRODUCT_RETURN;
 67 
 68   void run_service();
 69   void stop_service();
 70 
 71  public:
 72   // Constructor
 73   ConcurrentMarkSweepThread(CMSCollector* collector);
 74 
 75   static void threads_do(ThreadClosure* tc);
 76 
 77   // Printing
 78   static void print_all_on(outputStream* st);
 79   static void print_all()                             { print_all_on(tty); }
 80 
 81   // Returns the CMS Thread
 82   static ConcurrentMarkSweepThread* cmst()    { return _cmst; }
 83   static CMSCollector*         collector()    { return _collector;  }
 84 
 85   // Create and start the CMS Thread, or stop it on shutdown
 86   static ConcurrentMarkSweepThread* start(CMSCollector* collector);
 87 
 88   // Synchronization using CMS token
 89   static void synchronize(bool is_cms_thread);
 90   static void desynchronize(bool is_cms_thread);
 91   static bool vm_thread_has_cms_token() {
 92     return CMS_flag_is_set(CMS_vm_has_token);
 93   }
 94   static bool cms_thread_has_cms_token() {
 95     return CMS_flag_is_set(CMS_cms_has_token);
 96   }
 97   static bool vm_thread_wants_cms_token() {
 98     return CMS_flag_is_set(CMS_vm_wants_token);
 99   }
100   static bool cms_thread_wants_cms_token() {
101     return CMS_flag_is_set(CMS_cms_wants_token);
102   }
103 
104   // Wait on CMS lock until the next synchronous GC
105   // or given timeout, whichever is earlier. A timeout value
106   // of 0 indicates that there is no upper bound on the wait time.
107   // A concurrent full gc request terminates the wait.
108   void wait_on_cms_lock(long t_millis);
109 
110   // Wait on CMS lock until the next synchronous GC
111   // or given timeout, whichever is earlier. A timeout value
112   // of 0 indicates that there is no upper bound on the wait time.
113   // A concurrent full gc request terminates the wait.
114   void wait_on_cms_lock_for_scavenge(long t_millis);
115 
116   // The CMS thread will yield during the work portion of its cycle
117   // only when requested to.
118   // A synchronous request is used for young gen collections and
119   // for direct allocations.  The requesting thread increments
120   // _pending_yields at the beginning of an operation, and decrements
121   // _pending_yields when that operation is completed.
122   // In turn, the CMS thread yields when _pending_yields is positive,
123   // and continues to yield until the value reverts to 0.
124 
125   static void increment_pending_yields()   {
126     Atomic::inc(&amp;_pending_yields);
127     assert(_pending_yields &gt;= 0, &quot;can&#39;t be negative&quot;);
128   }
129   static void decrement_pending_yields()   {
130     Atomic::dec(&amp;_pending_yields);
131     assert(_pending_yields &gt;= 0, &quot;can&#39;t be negative&quot;);
132   }
133   static bool should_yield()   { return _pending_yields &gt; 0; }
134 };
135 
136 // For scoped increment/decrement of (synchronous) yield requests
137 class CMSSynchronousYieldRequest: public StackObj {
138  public:
139   CMSSynchronousYieldRequest() {
140     ConcurrentMarkSweepThread::increment_pending_yields();
141   }
142   ~CMSSynchronousYieldRequest() {
143     ConcurrentMarkSweepThread::decrement_pending_yields();
144   }
145 };
146 
147 // Used to emit a warning in case of unexpectedly excessive
148 // looping (in &quot;apparently endless loops&quot;) in CMS code.
149 class CMSLoopCountWarn: public StackObj {
150  private:
151   const char* _src;
152   const char* _msg;
153   const intx  _threshold;
154   intx        _ticks;
155 
156  public:
157   inline CMSLoopCountWarn(const char* src, const char* msg,
158                           const intx threshold) :
159     _src(src), _msg(msg), _threshold(threshold), _ticks(0) { }
160 
161   inline void tick() {
162     _ticks++;
163     if (CMSLoopWarn &amp;&amp; _ticks % _threshold == 0) {
164       log_warning(gc)(&quot;%s has looped &quot; INTX_FORMAT &quot; times %s&quot;, _src, _ticks, _msg);
165     }
166   }
167 };
168 
169 #endif // SHARE_GC_CMS_CONCURRENTMARKSWEEPTHREAD_HPP
    </pre>
  </body>
</html>
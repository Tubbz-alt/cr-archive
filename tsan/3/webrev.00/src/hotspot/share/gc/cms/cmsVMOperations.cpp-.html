<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cmsVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/cms/cmsHeap.hpp&quot;
 27 #include &quot;gc/cms/cmsVMOperations.hpp&quot;
 28 #include &quot;gc/cms/concurrentMarkSweepGeneration.inline.hpp&quot;
 29 #include &quot;gc/cms/concurrentMarkSweepThread.hpp&quot;
 30 #include &quot;gc/shared/gcLocker.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 33 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;utilities/dtrace.hpp&quot;
 38 
 39 //////////////////////////////////////////////////////////
 40 // Methods in abstract class VM_CMS_Operation
 41 //////////////////////////////////////////////////////////
 42 void VM_CMS_Operation::verify_before_gc() {
 43   if (VerifyBeforeGC &amp;&amp;
 44       CMSHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) {
 45     GCTraceTime(Info, gc, phases, verify) tm(&quot;Verify Before&quot;, _collector-&gt;_gc_timer_cm);
 46     HandleMark hm;
 47     FreelistLocker x(_collector);
 48     MutexLockerEx  y(_collector-&gt;bitMapLock(), Mutex::_no_safepoint_check_flag);
 49     CMSHeap::heap()-&gt;prepare_for_verify();
 50     Universe::verify();
 51   }
 52 }
 53 
 54 void VM_CMS_Operation::verify_after_gc() {
 55   if (VerifyAfterGC &amp;&amp;
 56       CMSHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) {
 57     GCTraceTime(Info, gc, phases, verify) tm(&quot;Verify After&quot;, _collector-&gt;_gc_timer_cm);
 58     HandleMark hm;
 59     FreelistLocker x(_collector);
 60     MutexLockerEx  y(_collector-&gt;bitMapLock(), Mutex::_no_safepoint_check_flag);
 61     Universe::verify();
 62   }
 63 }
 64 
 65 bool VM_CMS_Operation::lost_race() const {
 66   if (CMSCollector::abstract_state() == CMSCollector::Idling) {
 67     // We lost a race to a foreground collection
 68     // -- there&#39;s nothing to do
 69     return true;
 70   }
 71   assert(CMSCollector::abstract_state() == legal_state(),
 72          &quot;Inconsistent collector state?&quot;);
 73   return false;
 74 }
 75 
 76 bool VM_CMS_Operation::doit_prologue() {
 77   assert(Thread::current()-&gt;is_ConcurrentGC_thread(), &quot;just checking&quot;);
 78   assert(!CMSCollector::foregroundGCShouldWait(), &quot;Possible deadlock&quot;);
 79   assert(!ConcurrentMarkSweepThread::cms_thread_has_cms_token(),
 80          &quot;Possible deadlock&quot;);
 81 
 82   Heap_lock-&gt;lock();
 83   if (lost_race()) {
 84     assert(_prologue_succeeded == false, &quot;Initialized in c&#39;tor&quot;);
 85     Heap_lock-&gt;unlock();
 86   } else {
 87     _prologue_succeeded = true;
 88   }
 89   return _prologue_succeeded;
 90 }
 91 
 92 void VM_CMS_Operation::doit_epilogue() {
 93   assert(Thread::current()-&gt;is_ConcurrentGC_thread(), &quot;just checking&quot;);
 94   assert(!CMSCollector::foregroundGCShouldWait(), &quot;Possible deadlock&quot;);
 95   assert(!ConcurrentMarkSweepThread::cms_thread_has_cms_token(),
 96          &quot;Possible deadlock&quot;);
 97 
 98   if (Universe::has_reference_pending_list()) {
 99     Heap_lock-&gt;notify_all();
100   }
101   Heap_lock-&gt;unlock();
102 }
103 
104 //////////////////////////////////////////////////////////
105 // Methods in class VM_CMS_Initial_Mark
106 //////////////////////////////////////////////////////////
107 void VM_CMS_Initial_Mark::doit() {
108   if (lost_race()) {
109     // Nothing to do.
110     return;
111   }
112   HS_PRIVATE_CMS_INITMARK_BEGIN();
113   GCIdMark gc_id_mark(_gc_id);
114 
115   _collector-&gt;_gc_timer_cm-&gt;register_gc_pause_start(&quot;Initial Mark&quot;);
116 
117   CMSHeap* heap = CMSHeap::heap();
118   GCCauseSetter gccs(heap, GCCause::_cms_initial_mark);
119 
120   VM_CMS_Operation::verify_before_gc();
121 
122   IsGCActiveMark x; // stop-world GC active
123   _collector-&gt;do_CMS_operation(CMSCollector::CMS_op_checkpointRootsInitial, heap-&gt;gc_cause());
124 
125   VM_CMS_Operation::verify_after_gc();
126 
127   _collector-&gt;_gc_timer_cm-&gt;register_gc_pause_end();
128 
129   HS_PRIVATE_CMS_INITMARK_END();
130 }
131 
132 //////////////////////////////////////////////////////////
133 // Methods in class VM_CMS_Final_Remark_Operation
134 //////////////////////////////////////////////////////////
135 void VM_CMS_Final_Remark::doit() {
136   if (lost_race()) {
137     // Nothing to do.
138     return;
139   }
140   HS_PRIVATE_CMS_REMARK_BEGIN();
141   GCIdMark gc_id_mark(_gc_id);
142 
143   _collector-&gt;_gc_timer_cm-&gt;register_gc_pause_start(&quot;Final Mark&quot;);
144 
145   CMSHeap* heap = CMSHeap::heap();
146   GCCauseSetter gccs(heap, GCCause::_cms_final_remark);
147 
148   VM_CMS_Operation::verify_before_gc();
149 
150   IsGCActiveMark x; // stop-world GC active
151   _collector-&gt;do_CMS_operation(CMSCollector::CMS_op_checkpointRootsFinal, heap-&gt;gc_cause());
152 
153   VM_CMS_Operation::verify_after_gc();
154 
155   _collector-&gt;save_heap_summary();
156   _collector-&gt;_gc_timer_cm-&gt;register_gc_pause_end();
157 
158   HS_PRIVATE_CMS_REMARK_END();
159 }
160 
161 // VM operation to invoke a concurrent collection of a
162 // GenCollectedHeap heap.
163 void VM_GenCollectFullConcurrent::doit() {
164   assert(Thread::current()-&gt;is_VM_thread(), &quot;Should be VM thread&quot;);
165   assert(GCLockerInvokesConcurrent || ExplicitGCInvokesConcurrent, &quot;Unexpected&quot;);
166 
167   CMSHeap* heap = CMSHeap::heap();
168   if (_gc_count_before == heap-&gt;total_collections()) {
169     // The &quot;full&quot; of do_full_collection call below &quot;forces&quot;
170     // a collection; the second arg, 0, below ensures that
171     // only the young gen is collected. XXX In the future,
172     // we&#39;ll probably need to have something in this interface
173     // to say do this only if we are sure we will not bail
174     // out to a full collection in this attempt, but that&#39;s
175     // for the future.
176     assert(SafepointSynchronize::is_at_safepoint(),
177       &quot;We can only be executing this arm of if at a safepoint&quot;);
178     GCCauseSetter gccs(heap, _gc_cause);
179     heap-&gt;do_full_collection(heap-&gt;must_clear_all_soft_refs(), GenCollectedHeap::YoungGen);
180   } // Else no need for a foreground young gc
181   assert((_gc_count_before &lt; heap-&gt;total_collections()) ||
182          (GCLocker::is_active() /* gc may have been skipped */
183           &amp;&amp; (_gc_count_before == heap-&gt;total_collections())),
184          &quot;total_collections() should be monotonically increasing&quot;);
185 
186   MutexLockerEx x(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
187   assert(_full_gc_count_before &lt;= heap-&gt;total_full_collections(), &quot;Error&quot;);
188   if (heap-&gt;total_full_collections() == _full_gc_count_before) {
189     // Nudge the CMS thread to start a concurrent collection.
190     CMSCollector::request_full_gc(_full_gc_count_before, _gc_cause);
191   } else {
192     assert(_full_gc_count_before &lt; heap-&gt;total_full_collections(), &quot;Error&quot;);
193     FullGCCount_lock-&gt;notify_all();  // Inform the Java thread its work is done
194   }
195 }
196 
197 bool VM_GenCollectFullConcurrent::evaluate_at_safepoint() const {
198   Thread* thr = Thread::current();
199   assert(thr != NULL, &quot;Unexpected tid&quot;);
200   if (!thr-&gt;is_Java_thread()) {
201     assert(thr-&gt;is_VM_thread(), &quot;Expected to be evaluated by VM thread&quot;);
202     CMSHeap* heap = CMSHeap::heap();
203     if (_gc_count_before != heap-&gt;total_collections()) {
204       // No need to do a young gc, we&#39;ll just nudge the CMS thread
205       // in the doit() method above, to be executed soon.
206       assert(_gc_count_before &lt; heap-&gt;total_collections(),
207              &quot;total_collections() should be monotonically increasing&quot;);
208       return false;  // no need for foreground young gc
209     }
210   }
211   return true;       // may still need foreground young gc
212 }
213 
214 
215 void VM_GenCollectFullConcurrent::doit_epilogue() {
216   Thread* thr = Thread::current();
217   assert(thr-&gt;is_Java_thread(), &quot;just checking&quot;);
218   JavaThread* jt = (JavaThread*)thr;
219 
220   if (Universe::has_reference_pending_list()) {
221     Heap_lock-&gt;notify_all();
222   }
223   Heap_lock-&gt;unlock();
224 
225   // It is fine to test whether completed collections has
226   // exceeded our request count without locking because
227   // the completion count is monotonically increasing;
228   // this will break for very long-running apps when the
229   // count overflows and wraps around. XXX fix me !!!
230   // e.g. at the rate of 1 full gc per ms, this could
231   // overflow in about 1000 years.
232   CMSHeap* heap = CMSHeap::heap();
233   if (_gc_cause != GCCause::_gc_locker &amp;&amp;
234       heap-&gt;total_full_collections_completed() &lt;= _full_gc_count_before) {
235     // maybe we should change the condition to test _gc_cause ==
236     // GCCause::_java_lang_system_gc or GCCause::_dcmd_gc_run,
237     // instead of _gc_cause != GCCause::_gc_locker
238     assert(GCCause::is_user_requested_gc(_gc_cause),
239            &quot;the only way to get here if this was a System.gc()-induced GC&quot;);
240     assert(ExplicitGCInvokesConcurrent, &quot;Error&quot;);
241     // Now, wait for witnessing concurrent gc cycle to complete,
242     // but do so in native mode, because we want to lock the
243     // FullGCEvent_lock, which may be needed by the VM thread
244     // or by the CMS thread, so we do not want to be suspended
245     // while holding that lock.
246     ThreadToNativeFromVM native(jt);
247     MutexLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
248     // Either a concurrent or a stop-world full gc is sufficient
249     // witness to our request.
250     while (heap-&gt;total_full_collections_completed() &lt;= _full_gc_count_before) {
251       FullGCCount_lock-&gt;wait(Mutex::_no_safepoint_check_flag);
252     }
253   }
254 }
    </pre>
  </body>
</html>
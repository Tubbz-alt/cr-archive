<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cmsCardTable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #ifndef SHARE_GC_CMS_CMSCARDTABLE_HPP
26 #define SHARE_GC_CMS_CMSCARDTABLE_HPP
27 
28 #include &quot;gc/shared/cardTableRS.hpp&quot;
29 #include &quot;utilities/globalDefinitions.hpp&quot;
30 
31 class DirtyCardToOopClosure;
32 class MemRegion;
33 class OopsInGenClosure;
34 class Space;
35 
36 class CMSCardTable : public CardTableRS {
37 private:
38   // Returns the number of chunks necessary to cover &quot;mr&quot;.
39   size_t chunks_to_cover(MemRegion mr);
40 
41   // Returns the index of the chunk in a stride which
42   // covers the given address.
43   uintptr_t addr_to_chunk_index(const void* addr);
44 
45   // Initializes &quot;lowest_non_clean&quot; to point to the array for the region
46   // covering &quot;sp&quot;, and &quot;lowest_non_clean_base_chunk_index&quot; to the chunk
47   // index of the corresponding to the first element of that array.
48   // Ensures that these arrays are of sufficient size, allocating if necessary.
49   // May be called by several threads concurrently.
50   void get_LNC_array_for_space(Space* sp,
51                                CardValue**&amp; lowest_non_clean,
52                                uintptr_t&amp; lowest_non_clean_base_chunk_index,
53                                size_t&amp; lowest_non_clean_chunk_size);
54 
55   // Apply cl, which must either itself apply dcto_cl or be dcto_cl,
56   // to the cards in the stride (of n_strides) within the given space.
57   void process_stride(Space* sp,
58                       MemRegion used,
59                       jint stride, int n_strides,
60                       OopsInGenClosure* cl,
61                       CardTableRS* ct,
62                       CardValue** lowest_non_clean,
63                       uintptr_t lowest_non_clean_base_chunk_index,
64                       size_t lowest_non_clean_chunk_size);
65 
66   // Makes sure that chunk boundaries are handled appropriately, by
67   // adjusting the min_done of dcto_cl, and by using a special card-table
68   // value to indicate how min_done should be set.
69   void process_chunk_boundaries(Space* sp,
70                                 DirtyCardToOopClosure* dcto_cl,
71                                 MemRegion chunk_mr,
72                                 MemRegion used,
73                                 CardValue** lowest_non_clean,
74                                 uintptr_t lowest_non_clean_base_chunk_index,
75                                 size_t    lowest_non_clean_chunk_size);
76 
77   virtual void verify_used_region_at_save_marks(Space* sp) const NOT_DEBUG_RETURN;
78 
79 protected:
80   // Work method used to implement non_clean_card_iterate_possibly_parallel()
81   // above in the parallel case.
82   virtual void non_clean_card_iterate_parallel_work(Space* sp, MemRegion mr,
83                                                     OopsInGenClosure* cl, CardTableRS* ct,
84                                                     uint n_threads);
85 
86 public:
87   CMSCardTable(MemRegion whole_heap);
88 };
89 
90 #endif // SHARE_GC_CMS_CMSCARDTABLE_HPP
    </pre>
  </body>
</html>
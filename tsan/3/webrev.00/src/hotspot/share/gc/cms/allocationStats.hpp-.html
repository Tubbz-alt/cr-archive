<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/allocationStats.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_ALLOCATIONSTATS_HPP
 26 #define SHARE_GC_CMS_ALLOCATIONSTATS_HPP
 27 
 28 #include &quot;gc/shared/gcUtil.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 class AllocationStats {
 34   // A duration threshold (in ms) used to filter
 35   // possibly unreliable samples.
 36   static float _threshold;
 37 
 38   // We measure the demand between the end of the previous sweep and
 39   // beginning of this sweep:
 40   //   Count(end_last_sweep) - Count(start_this_sweep)
 41   //     + split_births(between) - split_deaths(between)
 42   // The above number divided by the time since the end of the
 43   // previous sweep gives us a time rate of demand for blocks
 44   // of this size. We compute a padded average of this rate as
 45   // our current estimate for the time rate of demand for blocks
 46   // of this size. Similarly, we keep a padded average for the time
 47   // between sweeps. Our current estimate for demand for blocks of
 48   // this size is then simply computed as the product of these two
 49   // estimates.
 50   AdaptivePaddedAverage _demand_rate_estimate;
 51 
 52   ssize_t     _desired;          // Demand estimate computed as described above
 53   ssize_t     _coal_desired;     // desired +/- small-percent for tuning coalescing
 54 
 55   ssize_t     _surplus;          // count - (desired +/- small-percent),
 56                                  // used to tune splitting in best fit
 57   ssize_t     _bfr_surp;         // surplus at start of current sweep
 58   ssize_t     _prev_sweep;       // count from end of previous sweep
 59   ssize_t     _before_sweep;     // count from before current sweep
 60   ssize_t     _coal_births;      // additional chunks from coalescing
 61   ssize_t     _coal_deaths;      // loss from coalescing
 62   ssize_t     _split_births;     // additional chunks from splitting
 63   ssize_t     _split_deaths;     // loss from splitting
 64   size_t      _returned_bytes;   // number of bytes returned to list.
 65  public:
 66   void initialize(bool split_birth = false);
 67 
 68   AllocationStats() {
 69     initialize();
 70   }
 71 
 72   // The rate estimate is in blocks per second.
 73   void compute_desired(size_t count,
 74                        float inter_sweep_current,
 75                        float inter_sweep_estimate,
 76                        float intra_sweep_estimate) {
 77     // If the latest inter-sweep time is below our granularity
 78     // of measurement, we may call in here with
 79     // inter_sweep_current == 0. However, even for suitably small
 80     // but non-zero inter-sweep durations, we may not trust the accuracy
 81     // of accumulated data, since it has not been &quot;integrated&quot;
 82     // (read &quot;low-pass-filtered&quot;) long enough, and would be
 83     // vulnerable to noisy glitches. In such cases, we
 84     // ignore the current sample and use currently available
 85     // historical estimates.
 86     assert(prev_sweep() + split_births() + coal_births()        // &quot;Total Production Stock&quot;
 87            &gt;= split_deaths() + coal_deaths() + (ssize_t)count, // &quot;Current stock + depletion&quot;
 88            &quot;Conservation Principle&quot;);
 89     if (inter_sweep_current &gt; _threshold) {
 90       ssize_t demand = prev_sweep() - (ssize_t)count + split_births() + coal_births()
 91                        - split_deaths() - coal_deaths();
 92       assert(demand &gt;= 0,
 93              &quot;Demand (&quot; SSIZE_FORMAT &quot;) should be non-negative for &quot;
 94              PTR_FORMAT &quot; (size=&quot; SIZE_FORMAT &quot;)&quot;,
 95              demand, p2i(this), count);
 96       // Defensive: adjust for imprecision in event counting
 97       if (demand &lt; 0) {
 98         demand = 0;
 99       }
100       float old_rate = _demand_rate_estimate.padded_average();
101       float rate = ((float)demand)/inter_sweep_current;
102       _demand_rate_estimate.sample(rate);
103       float new_rate = _demand_rate_estimate.padded_average();
104       ssize_t old_desired = _desired;
105       float delta_ise = (CMSExtrapolateSweep ? intra_sweep_estimate : 0.0);
106       _desired = (ssize_t)(new_rate * (inter_sweep_estimate + delta_ise));
107       log_trace(gc, freelist)(&quot;demand: &quot; SSIZE_FORMAT &quot;, old_rate: %f, current_rate: %f, &quot;
108                               &quot;new_rate: %f, old_desired: &quot; SSIZE_FORMAT &quot;, new_desired: &quot; SSIZE_FORMAT,
109                               demand, old_rate, rate, new_rate, old_desired, _desired);
110     }
111   }
112 
113   ssize_t desired() const { return _desired; }
114   void set_desired(ssize_t v) { _desired = v; }
115 
116   ssize_t coal_desired() const { return _coal_desired; }
117   void set_coal_desired(ssize_t v) { _coal_desired = v; }
118 
119   ssize_t surplus() const { return _surplus; }
120   void set_surplus(ssize_t v) { _surplus = v; }
121   void increment_surplus() { _surplus++; }
122   void decrement_surplus() { _surplus--; }
123 
124   ssize_t bfr_surp() const { return _bfr_surp; }
125   void set_bfr_surp(ssize_t v) { _bfr_surp = v; }
126   ssize_t prev_sweep() const { return _prev_sweep; }
127   void set_prev_sweep(ssize_t v) { _prev_sweep = v; }
128   ssize_t before_sweep() const { return _before_sweep; }
129   void set_before_sweep(ssize_t v) { _before_sweep = v; }
130 
131   ssize_t coal_births() const { return _coal_births; }
132   void set_coal_births(ssize_t v) { _coal_births = v; }
133   void increment_coal_births() { _coal_births++; }
134 
135   ssize_t coal_deaths() const { return _coal_deaths; }
136   void set_coal_deaths(ssize_t v) { _coal_deaths = v; }
137   void increment_coal_deaths() { _coal_deaths++; }
138 
139   ssize_t split_births() const { return _split_births; }
140   void set_split_births(ssize_t v) { _split_births = v; }
141   void increment_split_births() { _split_births++; }
142 
143   ssize_t split_deaths() const { return _split_deaths; }
144   void set_split_deaths(ssize_t v) { _split_deaths = v; }
145   void increment_split_deaths() { _split_deaths++; }
146 
147   NOT_PRODUCT(
148     size_t returned_bytes() const { return _returned_bytes; }
149     void set_returned_bytes(size_t v) { _returned_bytes = v; }
150   )
151 };
152 
153 #endif // SHARE_GC_CMS_ALLOCATIONSTATS_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/parOopClosures.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_PAROOPCLOSURES_HPP
 26 #define SHARE_GC_CMS_PAROOPCLOSURES_HPP
 27 
 28 #include &quot;gc/shared/genOopClosures.hpp&quot;
 29 #include &quot;gc/shared/taskqueue.hpp&quot;
 30 #include &quot;memory/padded.hpp&quot;
 31 
 32 // Closures for ParNewGeneration
 33 
 34 class ParScanThreadState;
 35 class ParNewGeneration;
 36 typedef Padded&lt;OopTaskQueue&gt; ObjToScanQueue;
 37 typedef GenericTaskQueueSet&lt;ObjToScanQueue, mtGC&gt; ObjToScanQueueSet;
 38 class ParallelTaskTerminator;
 39 
 40 class ParScanClosure: public OopsInClassLoaderDataOrGenClosure {
 41  protected:
 42   ParScanThreadState* _par_scan_state;
 43   ParNewGeneration*   _g;
 44   HeapWord*           _boundary;
 45   template &lt;class T&gt; void inline par_do_barrier(T* p);
 46   template &lt;class T&gt; void inline do_oop_work(T* p,
 47                                              bool gc_barrier,
 48                                              bool root_scan);
 49  public:
 50   ParScanClosure(ParNewGeneration* g, ParScanThreadState* par_scan_state);
 51 };
 52 
 53 class ParScanWithBarrierClosure: public ParScanClosure {
 54  public:
 55   ParScanWithBarrierClosure(ParNewGeneration* g,
 56                             ParScanThreadState* par_scan_state) :
 57     ParScanClosure(g, par_scan_state) {}
 58   virtual void do_oop(oop* p);
 59   virtual void do_oop(narrowOop* p);
 60 };
 61 
 62 class ParScanWithoutBarrierClosure: public ParScanClosure {
 63  public:
 64   ParScanWithoutBarrierClosure(ParNewGeneration* g,
 65                                ParScanThreadState* par_scan_state) :
 66     ParScanClosure(g, par_scan_state) {}
 67   virtual void do_oop(oop* p);
 68   virtual void do_oop(narrowOop* p);
 69 };
 70 
 71 class ParRootScanWithBarrierTwoGensClosure: public ParScanClosure {
 72  public:
 73   ParRootScanWithBarrierTwoGensClosure(ParNewGeneration* g,
 74                                        ParScanThreadState* par_scan_state) :
 75     ParScanClosure(g, par_scan_state) {}
 76   virtual void do_oop(oop* p);
 77   virtual void do_oop(narrowOop* p);
 78 };
 79 
 80 class ParRootScanWithoutBarrierClosure: public ParScanClosure {
 81  public:
 82   ParRootScanWithoutBarrierClosure(ParNewGeneration* g,
 83                                    ParScanThreadState* par_scan_state) :
 84     ParScanClosure(g, par_scan_state) {}
 85   virtual void do_oop(oop* p);
 86   virtual void do_oop(narrowOop* p);
 87 };
 88 
 89 class ParScanWeakRefClosure: public ScanWeakRefClosure {
 90  protected:
 91   ParScanThreadState* _par_scan_state;
 92   template &lt;class T&gt; inline void do_oop_work(T* p);
 93  public:
 94   ParScanWeakRefClosure(ParNewGeneration* g,
 95                         ParScanThreadState* par_scan_state);
 96   virtual void do_oop(oop* p);
 97   virtual void do_oop(narrowOop* p);
 98 };
 99 
100 class ParEvacuateFollowersClosure: public VoidClosure {
101  private:
102   ParScanThreadState* _par_scan_state;
103   ParScanThreadState* par_scan_state() { return _par_scan_state; }
104 
105   // We want to preserve the specific types here (rather than &quot;OopClosure&quot;)
106   // for later de-virtualization of do_oop calls.
107   ParScanWithoutBarrierClosure* _to_space_closure;
108   ParScanWithoutBarrierClosure* to_space_closure() {
109     return _to_space_closure;
110   }
111   ParRootScanWithoutBarrierClosure* _to_space_root_closure;
112   ParRootScanWithoutBarrierClosure* to_space_root_closure() {
113     return _to_space_root_closure;
114   }
115 
116   ParScanWithBarrierClosure* _old_gen_closure;
117   ParScanWithBarrierClosure* old_gen_closure () {
118     return _old_gen_closure;
119   }
120   ParRootScanWithBarrierTwoGensClosure* _old_gen_root_closure;
121   ParRootScanWithBarrierTwoGensClosure* old_gen_root_closure () {
122     return _old_gen_root_closure;
123   }
124 
125   ParNewGeneration* _par_gen;
126   ParNewGeneration* par_gen() { return _par_gen; }
127 
128   ObjToScanQueueSet*  _task_queues;
129   ObjToScanQueueSet*  task_queues() { return _task_queues; }
130 
131   ParallelTaskTerminator* _terminator;
132   ParallelTaskTerminator* terminator() { return _terminator; }
133  public:
134   ParEvacuateFollowersClosure(
135     ParScanThreadState* par_scan_state_,
136     ParScanWithoutBarrierClosure* to_space_closure_,
137     ParScanWithBarrierClosure* old_gen_closure_,
138     ParRootScanWithoutBarrierClosure* to_space_root_closure_,
139     ParNewGeneration* par_gen_,
140     ParRootScanWithBarrierTwoGensClosure* old_gen_root_closure_,
141     ObjToScanQueueSet* task_queues_,
142     ParallelTaskTerminator* terminator_);
143   virtual void do_void();
144 };
145 
146 #endif // SHARE_GC_CMS_PAROOPCLOSURES_HPP
    </pre>
  </body>
</html>
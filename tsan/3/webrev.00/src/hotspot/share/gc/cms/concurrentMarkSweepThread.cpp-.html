<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/concurrentMarkSweepThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;gc/cms/cmsHeap.hpp&quot;
 28 #include &quot;gc/cms/concurrentMarkSweepGeneration.inline.hpp&quot;
 29 #include &quot;gc/cms/concurrentMarkSweepThread.hpp&quot;
 30 #include &quot;gc/shared/gcId.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/init.hpp&quot;
 33 #include &quot;runtime/java.hpp&quot;
 34 #include &quot;runtime/javaCalls.hpp&quot;
 35 #include &quot;runtime/mutexLocker.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
 38 
 39 // ======= Concurrent Mark Sweep Thread ========
 40 
 41 ConcurrentMarkSweepThread* ConcurrentMarkSweepThread::_cmst = NULL;
 42 CMSCollector* ConcurrentMarkSweepThread::_collector         = NULL;
 43 int  ConcurrentMarkSweepThread::_CMS_flag                   = CMS_nil;
 44 
 45 volatile jint ConcurrentMarkSweepThread::_pending_yields    = 0;
 46 
 47 ConcurrentMarkSweepThread::ConcurrentMarkSweepThread(CMSCollector* collector)
 48   : ConcurrentGCThread() {
 49   assert(UseConcMarkSweepGC,  &quot;UseConcMarkSweepGC should be set&quot;);
 50   assert(_cmst == NULL, &quot;CMS thread already created&quot;);
 51   _cmst = this;
 52   assert(_collector == NULL, &quot;Collector already set&quot;);
 53   _collector = collector;
 54 
 55   set_name(&quot;CMS Main Thread&quot;);
 56 
 57   // An old comment here said: &quot;Priority should be just less
 58   // than that of VMThread&quot;.  Since the VMThread runs at
 59   // NearMaxPriority, the old comment was inaccurate, but
 60   // changing the default priority to NearMaxPriority-1
 61   // could change current behavior, so the default of
 62   // NearMaxPriority stays in place.
 63   //
 64   // Note that there&#39;s a possibility of the VMThread
 65   // starving if UseCriticalCMSThreadPriority is on.
 66   // That won&#39;t happen on Solaris for various reasons,
 67   // but may well happen on non-Solaris platforms.
 68   create_and_start(UseCriticalCMSThreadPriority ? CriticalPriority : NearMaxPriority);
 69 }
 70 
 71 void ConcurrentMarkSweepThread::run_service() {
 72   assert(this == cmst(), &quot;just checking&quot;);
 73 
 74   if (BindCMSThreadToCPU &amp;&amp; !os::bind_to_processor(CPUForCMSThread)) {
 75     log_warning(gc)(&quot;Couldn&#39;t bind CMS thread to processor &quot; UINTX_FORMAT, CPUForCMSThread);
 76   }
 77 
 78   while (!should_terminate()) {
 79     sleepBeforeNextCycle();
 80     if (should_terminate()) break;
 81     GCIdMark gc_id_mark;
 82     GCCause::Cause cause = _collector-&gt;_full_gc_requested ?
 83       _collector-&gt;_full_gc_cause : GCCause::_cms_concurrent_mark;
 84     _collector-&gt;collect_in_background(cause);
 85   }
 86 
 87   // Check that the state of any protocol for synchronization
 88   // between background (CMS) and foreground collector is &quot;clean&quot;
 89   // (i.e. will not potentially block the foreground collector,
 90   // requiring action by us).
 91   verify_ok_to_terminate();
 92 }
 93 
 94 #ifndef PRODUCT
 95 void ConcurrentMarkSweepThread::verify_ok_to_terminate() const {
 96   assert(!(CGC_lock-&gt;owned_by_self() || cms_thread_has_cms_token() ||
 97            cms_thread_wants_cms_token()),
 98          &quot;Must renounce all worldly possessions and desires for nirvana&quot;);
 99   _collector-&gt;verify_ok_to_terminate();
100 }
101 #endif
102 
103 // create and start a new ConcurrentMarkSweep Thread for given CMS generation
104 ConcurrentMarkSweepThread* ConcurrentMarkSweepThread::start(CMSCollector* collector) {
105   guarantee(_cmst == NULL, &quot;start() called twice!&quot;);
106   ConcurrentMarkSweepThread* th = new ConcurrentMarkSweepThread(collector);
107   assert(_cmst == th, &quot;Where did the just-created CMS thread go?&quot;);
108   return th;
109 }
110 
111 void ConcurrentMarkSweepThread::stop_service() {
112   // Now post a notify on CGC_lock so as to nudge
113   // CMS thread(s) that might be slumbering in
114   // sleepBeforeNextCycle.
115   MutexLockerEx x(CGC_lock, Mutex::_no_safepoint_check_flag);
116   CGC_lock-&gt;notify_all();
117 }
118 
119 void ConcurrentMarkSweepThread::threads_do(ThreadClosure* tc) {
120   assert(tc != NULL, &quot;Null ThreadClosure&quot;);
121   if (cmst() != NULL &amp;&amp; !cmst()-&gt;has_terminated()) {
122     tc-&gt;do_thread(cmst());
123   }
124   assert(Universe::is_fully_initialized(),
125          &quot;Called too early, make sure heap is fully initialized&quot;);
126   if (_collector != NULL) {
127     AbstractWorkGang* gang = _collector-&gt;conc_workers();
128     if (gang != NULL) {
129       gang-&gt;threads_do(tc);
130     }
131   }
132 }
133 
134 void ConcurrentMarkSweepThread::print_all_on(outputStream* st) {
135   if (cmst() != NULL &amp;&amp; !cmst()-&gt;has_terminated()) {
136     cmst()-&gt;print_on(st);
137     st-&gt;cr();
138   }
139   if (_collector != NULL) {
140     AbstractWorkGang* gang = _collector-&gt;conc_workers();
141     if (gang != NULL) {
142       gang-&gt;print_worker_threads_on(st);
143     }
144   }
145 }
146 
147 void ConcurrentMarkSweepThread::synchronize(bool is_cms_thread) {
148   assert(UseConcMarkSweepGC, &quot;just checking&quot;);
149 
150   MutexLockerEx x(CGC_lock,
151                   Mutex::_no_safepoint_check_flag);
152   if (!is_cms_thread) {
153     assert(Thread::current()-&gt;is_VM_thread(), &quot;Not a VM thread&quot;);
154     CMSSynchronousYieldRequest yr;
155     while (CMS_flag_is_set(CMS_cms_has_token)) {
156       // indicate that we want to get the token
157       set_CMS_flag(CMS_vm_wants_token);
158       CGC_lock-&gt;wait(true);
159     }
160     // claim the token and proceed
161     clear_CMS_flag(CMS_vm_wants_token);
162     set_CMS_flag(CMS_vm_has_token);
163   } else {
164     assert(Thread::current()-&gt;is_ConcurrentGC_thread(),
165            &quot;Not a CMS thread&quot;);
166     // The following barrier assumes there&#39;s only one CMS thread.
167     // This will need to be modified is there are more CMS threads than one.
168     while (CMS_flag_is_set(CMS_vm_has_token | CMS_vm_wants_token)) {
169       set_CMS_flag(CMS_cms_wants_token);
170       CGC_lock-&gt;wait(true);
171     }
172     // claim the token
173     clear_CMS_flag(CMS_cms_wants_token);
174     set_CMS_flag(CMS_cms_has_token);
175   }
176 }
177 
178 void ConcurrentMarkSweepThread::desynchronize(bool is_cms_thread) {
179   assert(UseConcMarkSweepGC, &quot;just checking&quot;);
180 
181   MutexLockerEx x(CGC_lock,
182                   Mutex::_no_safepoint_check_flag);
183   if (!is_cms_thread) {
184     assert(Thread::current()-&gt;is_VM_thread(), &quot;Not a VM thread&quot;);
185     assert(CMS_flag_is_set(CMS_vm_has_token), &quot;just checking&quot;);
186     clear_CMS_flag(CMS_vm_has_token);
187     if (CMS_flag_is_set(CMS_cms_wants_token)) {
188       // wake-up a waiting CMS thread
189       CGC_lock-&gt;notify();
190     }
191     assert(!CMS_flag_is_set(CMS_vm_has_token | CMS_vm_wants_token),
192            &quot;Should have been cleared&quot;);
193   } else {
194     assert(Thread::current()-&gt;is_ConcurrentGC_thread(),
195            &quot;Not a CMS thread&quot;);
196     assert(CMS_flag_is_set(CMS_cms_has_token), &quot;just checking&quot;);
197     clear_CMS_flag(CMS_cms_has_token);
198     if (CMS_flag_is_set(CMS_vm_wants_token)) {
199       // wake-up a waiting VM thread
200       CGC_lock-&gt;notify();
201     }
202     assert(!CMS_flag_is_set(CMS_cms_has_token | CMS_cms_wants_token),
203            &quot;Should have been cleared&quot;);
204   }
205 }
206 
207 // Wait until any cms_lock event
208 void ConcurrentMarkSweepThread::wait_on_cms_lock(long t_millis) {
209   MutexLockerEx x(CGC_lock,
210                   Mutex::_no_safepoint_check_flag);
211   if (should_terminate() || _collector-&gt;_full_gc_requested) {
212     return;
213   }
214   set_CMS_flag(CMS_cms_wants_token);   // to provoke notifies
215   CGC_lock-&gt;wait(Mutex::_no_safepoint_check_flag, t_millis);
216   clear_CMS_flag(CMS_cms_wants_token);
217   assert(!CMS_flag_is_set(CMS_cms_has_token | CMS_cms_wants_token),
218          &quot;Should not be set&quot;);
219 }
220 
221 // Wait until the next synchronous GC, a concurrent full gc request,
222 // or a timeout, whichever is earlier.
223 void ConcurrentMarkSweepThread::wait_on_cms_lock_for_scavenge(long t_millis) {
224   // Wait time in millis or 0 value representing infinite wait for a scavenge
225   assert(t_millis &gt;= 0, &quot;Wait time for scavenge should be 0 or positive&quot;);
226 
227   CMSHeap* heap = CMSHeap::heap();
228   double start_time_secs = os::elapsedTime();
229   double end_time_secs = start_time_secs + (t_millis / ((double) MILLIUNITS));
230 
231   // Total collections count before waiting loop
232   unsigned int before_count;
233   {
234     MutexLockerEx hl(Heap_lock, Mutex::_no_safepoint_check_flag);
235     before_count = heap-&gt;total_collections();
236   }
237 
238   unsigned int loop_count = 0;
239 
240   while(!should_terminate()) {
241     double now_time = os::elapsedTime();
242     long wait_time_millis;
243 
244     if(t_millis != 0) {
245       // New wait limit
246       wait_time_millis = (long) ((end_time_secs - now_time) * MILLIUNITS);
247       if(wait_time_millis &lt;= 0) {
248         // Wait time is over
249         break;
250       }
251     } else {
252       // No wait limit, wait if necessary forever
253       wait_time_millis = 0;
254     }
255 
256     // Wait until the next event or the remaining timeout
257     {
258       MutexLockerEx x(CGC_lock, Mutex::_no_safepoint_check_flag);
259 
260       if (should_terminate() || _collector-&gt;_full_gc_requested) {
261         return;
262       }
263       set_CMS_flag(CMS_cms_wants_token);   // to provoke notifies
264       assert(t_millis == 0 || wait_time_millis &gt; 0, &quot;Sanity&quot;);
265       CGC_lock-&gt;wait(Mutex::_no_safepoint_check_flag, wait_time_millis);
266       clear_CMS_flag(CMS_cms_wants_token);
267       assert(!CMS_flag_is_set(CMS_cms_has_token | CMS_cms_wants_token),
268              &quot;Should not be set&quot;);
269     }
270 
271     // Extra wait time check before entering the heap lock to get the collection count
272     if(t_millis != 0 &amp;&amp; os::elapsedTime() &gt;= end_time_secs) {
273       // Wait time is over
274       break;
275     }
276 
277     // Total collections count after the event
278     unsigned int after_count;
279     {
280       MutexLockerEx hl(Heap_lock, Mutex::_no_safepoint_check_flag);
281       after_count = heap-&gt;total_collections();
282     }
283 
284     if(before_count != after_count) {
285       // There was a collection - success
286       break;
287     }
288 
289     // Too many loops warning
290     if(++loop_count == 0) {
291       log_warning(gc)(&quot;wait_on_cms_lock_for_scavenge() has looped %u times&quot;, loop_count - 1);
292     }
293   }
294 }
295 
296 void ConcurrentMarkSweepThread::sleepBeforeNextCycle() {
297   while (!should_terminate()) {
298     if(CMSWaitDuration &gt;= 0) {
299       // Wait until the next synchronous GC, a concurrent full gc
300       // request or a timeout, whichever is earlier.
301       wait_on_cms_lock_for_scavenge(CMSWaitDuration);
302     } else {
303       // Wait until any cms_lock event or check interval not to call shouldConcurrentCollect permanently
304       wait_on_cms_lock(CMSCheckInterval);
305     }
306     // Check if we should start a CMS collection cycle
307     if (_collector-&gt;shouldConcurrentCollect()) {
308       return;
309     }
310     // .. collection criterion not yet met, let&#39;s go back
311     // and wait some more
312   }
313 }
    </pre>
  </body>
</html>
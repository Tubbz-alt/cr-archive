<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/parNewGeneration.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/stringTable.hpp&quot;
  27 #include &quot;gc/cms/cmsHeap.inline.hpp&quot;
  28 #include &quot;gc/cms/compactibleFreeListSpace.hpp&quot;
  29 #include &quot;gc/cms/concurrentMarkSweepGeneration.hpp&quot;
  30 #include &quot;gc/cms/parNewGeneration.inline.hpp&quot;
  31 #include &quot;gc/cms/parOopClosures.inline.hpp&quot;
  32 #include &quot;gc/serial/defNewGeneration.inline.hpp&quot;
  33 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  34 #include &quot;gc/shared/ageTable.inline.hpp&quot;
  35 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
  36 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  37 #include &quot;gc/shared/gcTimer.hpp&quot;
  38 #include &quot;gc/shared/gcTrace.hpp&quot;
  39 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  40 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  41 #include &quot;gc/shared/generation.hpp&quot;
  42 #include &quot;gc/shared/plab.inline.hpp&quot;
  43 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  44 #include &quot;gc/shared/referencePolicy.hpp&quot;
  45 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  46 #include &quot;gc/shared/space.hpp&quot;
  47 #include &quot;gc/shared/spaceDecorator.hpp&quot;
  48 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  49 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
  50 #include &quot;gc/shared/weakProcessor.hpp&quot;
  51 #include &quot;gc/shared/workgroup.hpp&quot;
  52 #include &quot;gc/shared/workerPolicy.hpp&quot;
  53 #include &quot;logging/log.hpp&quot;
  54 #include &quot;logging/logStream.hpp&quot;
  55 #include &quot;memory/iterator.inline.hpp&quot;
  56 #include &quot;memory/resourceArea.hpp&quot;
  57 #include &quot;oops/access.inline.hpp&quot;
  58 #include &quot;oops/compressedOops.inline.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;runtime/atomic.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/thread.inline.hpp&quot;
  65 #include &quot;utilities/copy.hpp&quot;
  66 #include &quot;utilities/globalDefinitions.hpp&quot;
  67 #include &quot;utilities/stack.inline.hpp&quot;
  68 
  69 ParScanThreadState::ParScanThreadState(Space* to_space_,
  70                                        ParNewGeneration* young_gen_,
  71                                        Generation* old_gen_,
  72                                        int thread_num_,
  73                                        ObjToScanQueueSet* work_queue_set_,
  74                                        Stack&lt;oop, mtGC&gt;* overflow_stacks_,
  75                                        PreservedMarks* preserved_marks_,
  76                                        size_t desired_plab_sz_,
  77                                        TaskTerminator&amp; term_) :
  78   _work_queue(work_queue_set_-&gt;queue(thread_num_)),
  79   _overflow_stack(overflow_stacks_ ? overflow_stacks_ + thread_num_ : NULL),
  80   _preserved_marks(preserved_marks_),
  81   _to_space_alloc_buffer(desired_plab_sz_),
  82   _to_space_closure(young_gen_, this),
  83   _old_gen_closure(young_gen_, this),
  84   _to_space_root_closure(young_gen_, this),
  85   _older_gen_closure(young_gen_, this),
  86   _old_gen_root_closure(young_gen_, this),
  87   _evacuate_followers(this, &amp;_to_space_closure, &amp;_old_gen_closure,
  88                       &amp;_to_space_root_closure, young_gen_, &amp;_old_gen_root_closure,
  89                       work_queue_set_, term_.terminator()),
  90   _is_alive_closure(young_gen_),
  91   _scan_weak_ref_closure(young_gen_, this),
  92   _keep_alive_closure(&amp;_scan_weak_ref_closure),
  93   _to_space(to_space_),
  94   _young_gen(young_gen_),
  95   _old_gen(old_gen_),
  96   _young_old_boundary(NULL),
  97   _thread_num(thread_num_),
  98   _ageTable(false), // false ==&gt; not the global age table, no perf data.
  99   _to_space_full(false),
 100   _strong_roots_time(0.0),
 101   _term_time(0.0)
 102 {
 103   #if TASKQUEUE_STATS
 104   _term_attempts = 0;
 105   _overflow_refills = 0;
 106   _overflow_refill_objs = 0;
 107   #endif // TASKQUEUE_STATS
 108 
 109   _survivor_chunk_array = (ChunkArray*) old_gen()-&gt;get_data_recorder(thread_num());
 110   _start = os::elapsedTime();
 111   _old_gen_closure.set_generation(old_gen_);
 112   _old_gen_root_closure.set_generation(old_gen_);
 113 }
 114 
 115 void ParScanThreadState::record_survivor_plab(HeapWord* plab_start,
 116                                               size_t plab_word_size) {
 117   ChunkArray* sca = survivor_chunk_array();
 118   if (sca != NULL) {
 119     // A non-null SCA implies that we want the PLAB data recorded.
 120     sca-&gt;record_sample(plab_start, plab_word_size);
 121   }
 122 }
 123 
 124 bool ParScanThreadState::should_be_partially_scanned(oop new_obj, oop old_obj) const {
 125   return new_obj-&gt;is_objArray() &amp;&amp;
 126          arrayOop(new_obj)-&gt;length() &gt; ParGCArrayScanChunk &amp;&amp;
 127          new_obj != old_obj;
 128 }
 129 
 130 void ParScanThreadState::scan_partial_array_and_push_remainder(oop old) {
 131   assert(old-&gt;is_objArray(), &quot;must be obj array&quot;);
 132   assert(old-&gt;is_forwarded(), &quot;must be forwarded&quot;);
 133   assert(CMSHeap::heap()-&gt;is_in_reserved(old), &quot;must be in heap.&quot;);
 134   assert(!old_gen()-&gt;is_in(old), &quot;must be in young generation.&quot;);
 135 
 136   objArrayOop obj = objArrayOop(old-&gt;forwardee());
 137   // Process ParGCArrayScanChunk elements now
 138   // and push the remainder back onto queue
 139   int start     = arrayOop(old)-&gt;length();
 140   int end       = obj-&gt;length();
 141   int remainder = end - start;
 142   assert(start &lt;= end, &quot;just checking&quot;);
 143   if (remainder &gt; 2 * ParGCArrayScanChunk) {
 144     // Test above combines last partial chunk with a full chunk
 145     end = start + ParGCArrayScanChunk;
 146     arrayOop(old)-&gt;set_length(end);
 147     // Push remainder.
 148     bool ok = work_queue()-&gt;push(old);
 149     assert(ok, &quot;just popped, push must be okay&quot;);
 150   } else {
 151     // Restore length so that it can be used if there
 152     // is a promotion failure and forwarding pointers
 153     // must be removed.
 154     arrayOop(old)-&gt;set_length(end);
 155   }
 156 
 157   // process our set of indices (include header in first chunk)
 158   // should make sure end is even (aligned to HeapWord in case of compressed oops)
 159   if ((HeapWord *)obj &lt; young_old_boundary()) {
 160     // object is in to_space
 161     obj-&gt;oop_iterate_range(&amp;_to_space_closure, start, end);
 162   } else {
 163     // object is in old generation
 164     obj-&gt;oop_iterate_range(&amp;_old_gen_closure, start, end);
 165   }
 166 }
 167 
 168 void ParScanThreadState::trim_queues(int max_size) {
 169   ObjToScanQueue* queue = work_queue();
 170   do {
 171     while (queue-&gt;size() &gt; (juint)max_size) {
 172       oop obj_to_scan;
 173       if (queue-&gt;pop_local(obj_to_scan)) {
 174         if ((HeapWord *)obj_to_scan &lt; young_old_boundary()) {
 175           if (obj_to_scan-&gt;is_objArray() &amp;&amp;
 176               obj_to_scan-&gt;is_forwarded() &amp;&amp;
 177               obj_to_scan-&gt;forwardee() != obj_to_scan) {
 178             scan_partial_array_and_push_remainder(obj_to_scan);
 179           } else {
 180             // object is in to_space
 181             obj_to_scan-&gt;oop_iterate(&amp;_to_space_closure);
 182           }
 183         } else {
 184           // object is in old generation
 185           obj_to_scan-&gt;oop_iterate(&amp;_old_gen_closure);
 186         }
 187       }
 188     }
 189     // For the  case of compressed oops, we have a private, non-shared
 190     // overflow stack, so we eagerly drain it so as to more evenly
 191     // distribute load early. Note: this may be good to do in
 192     // general rather than delay for the final stealing phase.
 193     // If applicable, we&#39;ll transfer a set of objects over to our
 194     // work queue, allowing them to be stolen and draining our
 195     // private overflow stack.
 196   } while (ParGCTrimOverflow &amp;&amp; young_gen()-&gt;take_from_overflow_list(this));
 197 }
 198 
 199 bool ParScanThreadState::take_from_overflow_stack() {
 200   assert(ParGCUseLocalOverflow, &quot;Else should not call&quot;);
 201   assert(young_gen()-&gt;overflow_list() == NULL, &quot;Error&quot;);
 202   ObjToScanQueue* queue = work_queue();
 203   Stack&lt;oop, mtGC&gt;* const of_stack = overflow_stack();
 204   const size_t num_overflow_elems = of_stack-&gt;size();
 205   const size_t space_available = queue-&gt;max_elems() - queue-&gt;size();
 206   const size_t num_take_elems = MIN3(space_available / 4,
 207                                      (size_t)ParGCDesiredObjsFromOverflowList,
 208                                      num_overflow_elems);
 209   // Transfer the most recent num_take_elems from the overflow
 210   // stack to our work queue.
 211   for (size_t i = 0; i != num_take_elems; i++) {
 212     oop cur = of_stack-&gt;pop();
 213     oop obj_to_push = cur-&gt;forwardee();
 214     assert(CMSHeap::heap()-&gt;is_in_reserved(cur), &quot;Should be in heap&quot;);
 215     assert(!old_gen()-&gt;is_in_reserved(cur), &quot;Should be in young gen&quot;);
 216     assert(CMSHeap::heap()-&gt;is_in_reserved(obj_to_push), &quot;Should be in heap&quot;);
 217     if (should_be_partially_scanned(obj_to_push, cur)) {
 218       assert(arrayOop(cur)-&gt;length() == 0, &quot;entire array remaining to be scanned&quot;);
 219       obj_to_push = cur;
 220     }
 221     bool ok = queue-&gt;push(obj_to_push);
 222     assert(ok, &quot;Should have succeeded&quot;);
 223   }
 224   assert(young_gen()-&gt;overflow_list() == NULL, &quot;Error&quot;);
 225   return num_take_elems &gt; 0;  // was something transferred?
 226 }
 227 
 228 void ParScanThreadState::push_on_overflow_stack(oop p) {
 229   assert(ParGCUseLocalOverflow, &quot;Else should not call&quot;);
 230   overflow_stack()-&gt;push(p);
 231   assert(young_gen()-&gt;overflow_list() == NULL, &quot;Error&quot;);
 232 }
 233 
 234 HeapWord* ParScanThreadState::alloc_in_to_space_slow(size_t word_sz) {
 235   // If the object is small enough, try to reallocate the buffer.
 236   HeapWord* obj = NULL;
 237   if (!_to_space_full) {
 238     PLAB* const plab = to_space_alloc_buffer();
 239     Space* const sp  = to_space();
 240     if (word_sz * 100 &lt; ParallelGCBufferWastePct * plab-&gt;word_sz()) {
 241       // Is small enough; abandon this buffer and start a new one.
 242       plab-&gt;retire();
 243       // The minimum size has to be twice SurvivorAlignmentInBytes to
 244       // allow for padding used in the alignment of 1 word.  A padding
 245       // of 1 is too small for a filler word so the padding size will
 246       // be increased by SurvivorAlignmentInBytes.
 247       size_t min_usable_size = 2 * static_cast&lt;size_t&gt;(SurvivorAlignmentInBytes &gt;&gt; LogHeapWordSize);
 248       size_t buf_size = MAX2(plab-&gt;word_sz(), min_usable_size);
 249       HeapWord* buf_space = sp-&gt;par_allocate(buf_size);
 250       if (buf_space == NULL) {
 251         const size_t min_bytes = MAX2(PLAB::min_size(), min_usable_size) &lt;&lt; LogHeapWordSize;
 252         size_t free_bytes = sp-&gt;free();
 253         while(buf_space == NULL &amp;&amp; free_bytes &gt;= min_bytes) {
 254           buf_size = free_bytes &gt;&gt; LogHeapWordSize;
 255           assert(buf_size == (size_t)align_object_size(buf_size), &quot;Invariant&quot;);
 256           buf_space  = sp-&gt;par_allocate(buf_size);
 257           free_bytes = sp-&gt;free();
 258         }
 259       }
 260       if (buf_space != NULL) {
 261         plab-&gt;set_buf(buf_space, buf_size);
 262         record_survivor_plab(buf_space, buf_size);
 263         obj = plab-&gt;allocate_aligned(word_sz, SurvivorAlignmentInBytes);
 264         // Note that we cannot compare buf_size &lt; word_sz below
 265         // because of AlignmentReserve (see PLAB::allocate()).
 266         assert(obj != NULL || plab-&gt;words_remaining() &lt; word_sz,
 267                &quot;Else should have been able to allocate requested object size &quot;
 268                SIZE_FORMAT &quot;, PLAB size &quot; SIZE_FORMAT &quot;, SurvivorAlignmentInBytes &quot;
 269                SIZE_FORMAT &quot;, words_remaining &quot; SIZE_FORMAT,
 270                word_sz, buf_size, SurvivorAlignmentInBytes, plab-&gt;words_remaining());
 271         // It&#39;s conceivable that we may be able to use the
 272         // buffer we just grabbed for subsequent small requests
 273         // even if not for this one.
 274       } else {
 275         // We&#39;re used up.
 276         _to_space_full = true;
 277       }
 278     } else {
 279       // Too large; allocate the object individually.
 280       obj = sp-&gt;par_allocate(word_sz);
 281     }
 282   }
 283   return obj;
 284 }
 285 
 286 void ParScanThreadState::undo_alloc_in_to_space(HeapWord* obj, size_t word_sz) {
 287   to_space_alloc_buffer()-&gt;undo_allocation(obj, word_sz);
 288 }
 289 
 290 void ParScanThreadState::print_promotion_failure_size() {
 291   if (_promotion_failed_info.has_failed()) {
 292     log_trace(gc, promotion)(&quot; (%d: promotion failure size = &quot; SIZE_FORMAT &quot;) &quot;,
 293                              _thread_num, _promotion_failed_info.first_size());
 294   }
 295 }
 296 
 297 class ParScanThreadStateSet: StackObj {
 298 public:
 299   // Initializes states for the specified number of threads;
 300   ParScanThreadStateSet(int                     num_threads,
 301                         Space&amp;                  to_space,
 302                         ParNewGeneration&amp;       young_gen,
 303                         Generation&amp;             old_gen,
 304                         ObjToScanQueueSet&amp;      queue_set,
 305                         Stack&lt;oop, mtGC&gt;*       overflow_stacks_,
 306                         PreservedMarksSet&amp;      preserved_marks_set,
 307                         size_t                  desired_plab_sz,
 308                         TaskTerminator&amp; term);
 309 
 310   ~ParScanThreadStateSet() { TASKQUEUE_STATS_ONLY(reset_stats()); }
 311 
 312   inline ParScanThreadState&amp; thread_state(int i);
 313 
 314   void trace_promotion_failed(const YoungGCTracer* gc_tracer);
 315   void reset(uint active_workers, bool promotion_failed);
 316   void flush();
 317 
 318   #if TASKQUEUE_STATS
 319   static void
 320     print_termination_stats_hdr(outputStream* const st);
 321   void print_termination_stats();
 322   static void
 323     print_taskqueue_stats_hdr(outputStream* const st);
 324   void print_taskqueue_stats();
 325   void reset_stats();
 326   #endif // TASKQUEUE_STATS
 327 
 328 private:
 329   TaskTerminator&amp;         _term;
 330   ParNewGeneration&amp;       _young_gen;
 331   Generation&amp;             _old_gen;
 332   ParScanThreadState*     _per_thread_states;
 333   const int               _num_threads;
 334  public:
 335   bool is_valid(int id) const { return id &lt; _num_threads; }
 336   ParallelTaskTerminator* terminator() { return _term.terminator(); }
 337 };
 338 
 339 ParScanThreadStateSet::ParScanThreadStateSet(int num_threads,
 340                                              Space&amp; to_space,
 341                                              ParNewGeneration&amp; young_gen,
 342                                              Generation&amp; old_gen,
 343                                              ObjToScanQueueSet&amp; queue_set,
 344                                              Stack&lt;oop, mtGC&gt;* overflow_stacks,
 345                                              PreservedMarksSet&amp; preserved_marks_set,
 346                                              size_t desired_plab_sz,
 347                                              TaskTerminator&amp; term)
 348   : _term(term),
 349     _young_gen(young_gen),
 350     _old_gen(old_gen),
 351     _per_thread_states(NEW_RESOURCE_ARRAY(ParScanThreadState, num_threads)),
 352     _num_threads(num_threads)
 353 {
 354   assert(num_threads &gt; 0, &quot;sanity check!&quot;);
 355   assert(ParGCUseLocalOverflow == (overflow_stacks != NULL),
 356          &quot;overflow_stack allocation mismatch&quot;);
 357   // Initialize states.
 358   for (int i = 0; i &lt; num_threads; ++i) {
 359     new(_per_thread_states + i)
 360       ParScanThreadState(&amp;to_space, &amp;young_gen, &amp;old_gen, i, &amp;queue_set,
 361                          overflow_stacks, preserved_marks_set.get(i),
 362                          desired_plab_sz, term);
 363   }
 364 }
 365 
 366 inline ParScanThreadState&amp; ParScanThreadStateSet::thread_state(int i) {
 367   assert(i &gt;= 0 &amp;&amp; i &lt; _num_threads, &quot;sanity check!&quot;);
 368   return _per_thread_states[i];
 369 }
 370 
 371 void ParScanThreadStateSet::trace_promotion_failed(const YoungGCTracer* gc_tracer) {
 372   for (int i = 0; i &lt; _num_threads; ++i) {
 373     if (thread_state(i).promotion_failed()) {
 374       gc_tracer-&gt;report_promotion_failed(thread_state(i).promotion_failed_info());
 375       thread_state(i).promotion_failed_info().reset();
 376     }
 377   }
 378 }
 379 
 380 void ParScanThreadStateSet::reset(uint active_threads, bool promotion_failed) {
 381   _term.terminator()-&gt;reset_for_reuse(active_threads);
 382   if (promotion_failed) {
 383     for (int i = 0; i &lt; _num_threads; ++i) {
 384       thread_state(i).print_promotion_failure_size();
 385     }
 386   }
 387 }
 388 
 389 #if TASKQUEUE_STATS
 390 void ParScanThreadState::reset_stats() {
 391   taskqueue_stats().reset();
 392   _term_attempts = 0;
 393   _overflow_refills = 0;
 394   _overflow_refill_objs = 0;
 395 }
 396 
 397 void ParScanThreadStateSet::reset_stats() {
 398   for (int i = 0; i &lt; _num_threads; ++i) {
 399     thread_state(i).reset_stats();
 400   }
 401 }
 402 
 403 void ParScanThreadStateSet::print_termination_stats_hdr(outputStream* const st) {
 404   st-&gt;print_raw_cr(&quot;GC Termination Stats&quot;);
 405   st-&gt;print_raw_cr(&quot;     elapsed  --strong roots-- -------termination-------&quot;);
 406   st-&gt;print_raw_cr(&quot;thr     ms        ms       %       ms       %   attempts&quot;);
 407   st-&gt;print_raw_cr(&quot;--- --------- --------- ------ --------- ------ --------&quot;);
 408 }
 409 
 410 void ParScanThreadStateSet::print_termination_stats() {
 411   Log(gc, task, stats) log;
 412   if (!log.is_debug()) {
 413     return;
 414   }
 415 
 416   ResourceMark rm;
 417   LogStream ls(log.debug());
 418   outputStream* st = &amp;ls;
 419 
 420   print_termination_stats_hdr(st);
 421 
 422   for (int i = 0; i &lt; _num_threads; ++i) {
 423     const ParScanThreadState &amp; pss = thread_state(i);
 424     const double elapsed_ms = pss.elapsed_time() * 1000.0;
 425     const double s_roots_ms = pss.strong_roots_time() * 1000.0;
 426     const double term_ms = pss.term_time() * 1000.0;
 427     st-&gt;print_cr(&quot;%3d %9.2f %9.2f %6.2f %9.2f %6.2f &quot; SIZE_FORMAT_W(8),
 428                  i, elapsed_ms, s_roots_ms, s_roots_ms * 100 / elapsed_ms,
 429                  term_ms, term_ms * 100 / elapsed_ms, pss.term_attempts());
 430   }
 431 }
 432 
 433 // Print stats related to work queue activity.
 434 void ParScanThreadStateSet::print_taskqueue_stats_hdr(outputStream* const st) {
 435   st-&gt;print_raw_cr(&quot;GC Task Stats&quot;);
 436   st-&gt;print_raw(&quot;thr &quot;); TaskQueueStats::print_header(1, st); st-&gt;cr();
 437   st-&gt;print_raw(&quot;--- &quot;); TaskQueueStats::print_header(2, st); st-&gt;cr();
 438 }
 439 
 440 void ParScanThreadStateSet::print_taskqueue_stats() {
 441   if (!log_is_enabled(Trace, gc, task, stats)) {
 442     return;
 443   }
 444   Log(gc, task, stats) log;
 445   ResourceMark rm;
 446   LogStream ls(log.trace());
 447   outputStream* st = &amp;ls;
 448   print_taskqueue_stats_hdr(st);
 449 
 450   TaskQueueStats totals;
 451   for (int i = 0; i &lt; _num_threads; ++i) {
 452     const ParScanThreadState &amp; pss = thread_state(i);
 453     const TaskQueueStats &amp; stats = pss.taskqueue_stats();
 454     st-&gt;print(&quot;%3d &quot;, i); stats.print(st); st-&gt;cr();
 455     totals += stats;
 456 
 457     if (pss.overflow_refills() &gt; 0) {
 458       st-&gt;print_cr(&quot;    &quot; SIZE_FORMAT_W(10) &quot; overflow refills    &quot;
 459                    SIZE_FORMAT_W(10) &quot; overflow objects&quot;,
 460                    pss.overflow_refills(), pss.overflow_refill_objs());
 461     }
 462   }
 463   st-&gt;print(&quot;tot &quot;); totals.print(st); st-&gt;cr();
 464 
 465   DEBUG_ONLY(totals.verify());
 466 }
 467 #endif // TASKQUEUE_STATS
 468 
 469 void ParScanThreadStateSet::flush() {
 470   // Work in this loop should be kept as lightweight as
 471   // possible since this might otherwise become a bottleneck
 472   // to scaling. Should we add heavy-weight work into this
 473   // loop, consider parallelizing the loop into the worker threads.
 474   for (int i = 0; i &lt; _num_threads; ++i) {
 475     ParScanThreadState&amp; par_scan_state = thread_state(i);
 476 
 477     // Flush stats related to To-space PLAB activity and
 478     // retire the last buffer.
 479     par_scan_state.to_space_alloc_buffer()-&gt;flush_and_retire_stats(_young_gen.plab_stats());
 480 
 481     // Every thread has its own age table.  We need to merge
 482     // them all into one.
 483     AgeTable *local_table = par_scan_state.age_table();
 484     _young_gen.age_table()-&gt;merge(local_table);
 485 
 486     // Inform old gen that we&#39;re done.
 487     _old_gen.par_promote_alloc_done(i);
 488   }
 489 
 490   if (UseConcMarkSweepGC) {
 491     // We need to call this even when ResizeOldPLAB is disabled
 492     // so as to avoid breaking some asserts. While we may be able
 493     // to avoid this by reorganizing the code a bit, I am loathe
 494     // to do that unless we find cases where ergo leads to bad
 495     // performance.
 496     CompactibleFreeListSpaceLAB::compute_desired_plab_size();
 497   }
 498 }
 499 
 500 ParScanClosure::ParScanClosure(ParNewGeneration* g,
 501                                ParScanThreadState* par_scan_state) :
 502   OopsInClassLoaderDataOrGenClosure(g), _par_scan_state(par_scan_state), _g(g) {
 503   _boundary = _g-&gt;reserved().end();
 504 }
 505 
 506 void ParRootScanWithBarrierTwoGensClosure::do_oop(oop* p)       { ParScanClosure::do_oop_work(p, true, true); }
 507 void ParRootScanWithBarrierTwoGensClosure::do_oop(narrowOop* p) { ParScanClosure::do_oop_work(p, true, true); }
 508 
 509 void ParRootScanWithoutBarrierClosure::do_oop(oop* p)       { ParScanClosure::do_oop_work(p, false, true); }
 510 void ParRootScanWithoutBarrierClosure::do_oop(narrowOop* p) { ParScanClosure::do_oop_work(p, false, true); }
 511 
 512 ParScanWeakRefClosure::ParScanWeakRefClosure(ParNewGeneration* g,
 513                                              ParScanThreadState* par_scan_state)
 514   : ScanWeakRefClosure(g), _par_scan_state(par_scan_state)
 515 {}
 516 
 517 #ifdef WIN32
 518 #pragma warning(disable: 4786) /* identifier was truncated to &#39;255&#39; characters in the browser information */
 519 #endif
 520 
 521 ParEvacuateFollowersClosure::ParEvacuateFollowersClosure(
 522     ParScanThreadState* par_scan_state_,
 523     ParScanWithoutBarrierClosure* to_space_closure_,
 524     ParScanWithBarrierClosure* old_gen_closure_,
 525     ParRootScanWithoutBarrierClosure* to_space_root_closure_,
 526     ParNewGeneration* par_gen_,
 527     ParRootScanWithBarrierTwoGensClosure* old_gen_root_closure_,
 528     ObjToScanQueueSet* task_queues_,
 529     ParallelTaskTerminator* terminator_) :
 530 
 531     _par_scan_state(par_scan_state_),
 532     _to_space_closure(to_space_closure_),
 533     _to_space_root_closure(to_space_root_closure_),
 534     _old_gen_closure(old_gen_closure_),
 535     _old_gen_root_closure(old_gen_root_closure_),
 536     _par_gen(par_gen_),
 537     _task_queues(task_queues_),
 538     _terminator(terminator_)
 539 {}
 540 
 541 void ParEvacuateFollowersClosure::do_void() {
 542   ObjToScanQueue* work_q = par_scan_state()-&gt;work_queue();
 543 
 544   while (true) {
 545     // Scan to-space and old-gen objs until we run out of both.
 546     oop obj_to_scan;
 547     par_scan_state()-&gt;trim_queues(0);
 548 
 549     // We have no local work, attempt to steal from other threads.
 550 
 551     // Attempt to steal work from promoted.
 552     if (task_queues()-&gt;steal(par_scan_state()-&gt;thread_num(),
 553                              obj_to_scan)) {
 554       bool res = work_q-&gt;push(obj_to_scan);
 555       assert(res, &quot;Empty queue should have room for a push.&quot;);
 556 
 557       // If successful, goto Start.
 558       continue;
 559 
 560       // Try global overflow list.
 561     } else if (par_gen()-&gt;take_from_overflow_list(par_scan_state())) {
 562       continue;
 563     }
 564 
 565     // Otherwise, offer termination.
 566     par_scan_state()-&gt;start_term_time();
 567     if (terminator()-&gt;offer_termination()) break;
 568     par_scan_state()-&gt;end_term_time();
 569   }
 570   assert(par_gen()-&gt;_overflow_list == NULL &amp;&amp; par_gen()-&gt;_num_par_pushes == 0,
 571          &quot;Broken overflow list?&quot;);
 572   // Finish the last termination pause.
 573   par_scan_state()-&gt;end_term_time();
 574 }
 575 
 576 ParNewGenTask::ParNewGenTask(ParNewGeneration* young_gen,
 577                              Generation* old_gen,
 578                              HeapWord* young_old_boundary,
 579                              ParScanThreadStateSet* state_set,
 580                              StrongRootsScope* strong_roots_scope) :
 581     AbstractGangTask(&quot;ParNewGeneration collection&quot;),
 582     _young_gen(young_gen), _old_gen(old_gen),
 583     _young_old_boundary(young_old_boundary),
 584     _state_set(state_set),
 585     _strong_roots_scope(strong_roots_scope),
 586     _par_state_string(StringTable::weak_storage())
 587 {}
 588 
 589 void ParNewGenTask::work(uint worker_id) {
 590   CMSHeap* heap = CMSHeap::heap();
 591   // Since this is being done in a separate thread, need new resource
 592   // and handle marks.
 593   ResourceMark rm;
 594   HandleMark hm;
 595 
 596   ParScanThreadState&amp; par_scan_state = _state_set-&gt;thread_state(worker_id);
 597   assert(_state_set-&gt;is_valid(worker_id), &quot;Should not have been called&quot;);
 598 
 599   par_scan_state.set_young_old_boundary(_young_old_boundary);
 600 
 601   CLDScanClosure cld_scan_closure(&amp;par_scan_state.to_space_root_closure(),
 602                                   heap-&gt;rem_set()-&gt;cld_rem_set()-&gt;accumulate_modified_oops());
 603 
 604   par_scan_state.start_strong_roots();
 605   heap-&gt;young_process_roots(_strong_roots_scope,
 606                            &amp;par_scan_state.to_space_root_closure(),
 607                            &amp;par_scan_state.older_gen_closure(),
 608                            &amp;cld_scan_closure);
 609 
 610   par_scan_state.end_strong_roots();
 611 
 612   // &quot;evacuate followers&quot;.
 613   par_scan_state.evacuate_followers_closure().do_void();
 614 
 615   // This will collapse this worker&#39;s promoted object list that&#39;s
 616   // created during the main ParNew parallel phase of ParNew. This has
 617   // to be called after all workers have finished promoting objects
 618   // and scanning promoted objects. It should be safe calling it from
 619   // here, given that we can only reach here after all thread have
 620   // offered termination, i.e., after there is no more work to be
 621   // done. It will also disable promotion tracking for the rest of
 622   // this GC as it&#39;s not necessary to be on during reference processing.
 623   _old_gen-&gt;par_oop_since_save_marks_iterate_done((int) worker_id);
 624 }
 625 
 626 ParNewGeneration::ParNewGeneration(ReservedSpace rs, size_t initial_byte_size)
 627   : DefNewGeneration(rs, initial_byte_size, &quot;CMS young collection pauses&quot;),
 628   _plab_stats(&quot;Young&quot;, YoungPLABSize, PLABWeight),
 629   _overflow_list(NULL),
 630   _is_alive_closure(this)
 631 {
 632   NOT_PRODUCT(_overflow_counter = ParGCWorkQueueOverflowInterval;)
 633   NOT_PRODUCT(_num_par_pushes = 0;)
 634   _task_queues = new ObjToScanQueueSet(ParallelGCThreads);
 635   guarantee(_task_queues != NULL, &quot;task_queues allocation failure.&quot;);
 636 
 637   for (uint i = 0; i &lt; ParallelGCThreads; i++) {
 638     ObjToScanQueue *q = new ObjToScanQueue();
 639     guarantee(q != NULL, &quot;work_queue Allocation failure.&quot;);
 640     _task_queues-&gt;register_queue(i, q);
 641   }
 642 
 643   for (uint i = 0; i &lt; ParallelGCThreads; i++) {
 644     _task_queues-&gt;queue(i)-&gt;initialize();
 645   }
 646 
 647   _overflow_stacks = NULL;
 648   if (ParGCUseLocalOverflow) {
 649     // typedef to workaround NEW_C_HEAP_ARRAY macro, which can not deal with &#39;,&#39;
 650     typedef Stack&lt;oop, mtGC&gt; GCOopStack;
 651 
 652     _overflow_stacks = NEW_C_HEAP_ARRAY(GCOopStack, ParallelGCThreads, mtGC);
 653     for (size_t i = 0; i &lt; ParallelGCThreads; ++i) {
 654       new (_overflow_stacks + i) Stack&lt;oop, mtGC&gt;();
 655     }
 656   }
 657 
 658   if (UsePerfData) {
 659     EXCEPTION_MARK;
 660     ResourceMark rm;
 661 
 662     const char* cname =
 663          PerfDataManager::counter_name(_gen_counters-&gt;name_space(), &quot;threads&quot;);
 664     PerfDataManager::create_constant(SUN_GC, cname, PerfData::U_None,
 665                                      ParallelGCThreads, CHECK);
 666   }
 667 }
 668 
 669 // ParNewGeneration::
 670 ParKeepAliveClosure::ParKeepAliveClosure(ParScanWeakRefClosure* cl) :
 671   DefNewGeneration::KeepAliveClosure(cl), _par_cl(cl) {}
 672 
 673 template &lt;class T&gt;
 674 void /*ParNewGeneration::*/ParKeepAliveClosure::do_oop_work(T* p) {
 675 #ifdef ASSERT
 676   {
 677     oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 678     // We never expect to see a null reference being processed
 679     // as a weak reference.
 680     assert(oopDesc::is_oop(obj), &quot;expected an oop while scanning weak refs&quot;);
 681   }
 682 #endif // ASSERT
 683 
 684   Devirtualizer::do_oop_no_verify(_par_cl, p);
 685 
 686   if (CMSHeap::heap()-&gt;is_in_reserved(p)) {
 687     oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);;
 688     _rs-&gt;write_ref_field_gc_par(p, obj);
 689   }
 690 }
 691 
 692 void /*ParNewGeneration::*/ParKeepAliveClosure::do_oop(oop* p)       { ParKeepAliveClosure::do_oop_work(p); }
 693 void /*ParNewGeneration::*/ParKeepAliveClosure::do_oop(narrowOop* p) { ParKeepAliveClosure::do_oop_work(p); }
 694 
 695 // ParNewGeneration::
 696 KeepAliveClosure::KeepAliveClosure(ScanWeakRefClosure* cl) :
 697   DefNewGeneration::KeepAliveClosure(cl) {}
 698 
 699 template &lt;class T&gt;
 700 void /*ParNewGeneration::*/KeepAliveClosure::do_oop_work(T* p) {
 701 #ifdef ASSERT
 702   {
 703     oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 704     // We never expect to see a null reference being processed
 705     // as a weak reference.
 706     assert(oopDesc::is_oop(obj), &quot;expected an oop while scanning weak refs&quot;);
 707   }
 708 #endif // ASSERT
 709 
 710   Devirtualizer::do_oop_no_verify(_cl, p);
 711 
 712   if (CMSHeap::heap()-&gt;is_in_reserved(p)) {
 713     oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 714     _rs-&gt;write_ref_field_gc_par(p, obj);
 715   }
 716 }
 717 
 718 void /*ParNewGeneration::*/KeepAliveClosure::do_oop(oop* p)       { KeepAliveClosure::do_oop_work(p); }
 719 void /*ParNewGeneration::*/KeepAliveClosure::do_oop(narrowOop* p) { KeepAliveClosure::do_oop_work(p); }
 720 
 721 template &lt;class T&gt; void ScanClosureWithParBarrier::do_oop_work(T* p) {
 722   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 723   if (!CompressedOops::is_null(heap_oop)) {
 724     oop obj = CompressedOops::decode_not_null(heap_oop);
 725     if ((HeapWord*)obj &lt; _boundary) {
 726       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
 727       oop new_obj = obj-&gt;is_forwarded()
 728                       ? obj-&gt;forwardee()
 729                       : _g-&gt;DefNewGeneration::copy_to_survivor_space(obj);
 730       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
 731     }
 732     if (_gc_barrier) {
 733       // If p points to a younger generation, mark the card.
 734       if ((HeapWord*)obj &lt; _gen_boundary) {
 735         _rs-&gt;write_ref_field_gc_par(p, obj);
 736       }
 737     }
 738   }
 739 }
 740 
 741 void ScanClosureWithParBarrier::do_oop(oop* p)       { ScanClosureWithParBarrier::do_oop_work(p); }
 742 void ScanClosureWithParBarrier::do_oop(narrowOop* p) { ScanClosureWithParBarrier::do_oop_work(p); }
 743 
 744 class ParNewRefProcTaskProxy: public AbstractGangTask {
 745   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
 746 public:
 747   ParNewRefProcTaskProxy(ProcessTask&amp; task,
 748                          ParNewGeneration&amp; young_gen,
 749                          Generation&amp; old_gen,
 750                          HeapWord* young_old_boundary,
 751                          ParScanThreadStateSet&amp; state_set);
 752 
 753 private:
 754   virtual void work(uint worker_id);
 755 private:
 756   ParNewGeneration&amp;      _young_gen;
 757   ProcessTask&amp;           _task;
 758   Generation&amp;            _old_gen;
 759   HeapWord*              _young_old_boundary;
 760   ParScanThreadStateSet&amp; _state_set;
 761 };
 762 
 763 ParNewRefProcTaskProxy::ParNewRefProcTaskProxy(ProcessTask&amp; task,
 764                                                ParNewGeneration&amp; young_gen,
 765                                                Generation&amp; old_gen,
 766                                                HeapWord* young_old_boundary,
 767                                                ParScanThreadStateSet&amp; state_set)
 768   : AbstractGangTask(&quot;ParNewGeneration parallel reference processing&quot;),
 769     _young_gen(young_gen),
 770     _task(task),
 771     _old_gen(old_gen),
 772     _young_old_boundary(young_old_boundary),
 773     _state_set(state_set)
 774 { }
 775 
 776 void ParNewRefProcTaskProxy::work(uint worker_id) {
 777   ResourceMark rm;
 778   HandleMark hm;
 779   ParScanThreadState&amp; par_scan_state = _state_set.thread_state(worker_id);
 780   par_scan_state.set_young_old_boundary(_young_old_boundary);
 781   _task.work(worker_id, par_scan_state.is_alive_closure(),
 782              par_scan_state.keep_alive_closure(),
 783              par_scan_state.evacuate_followers_closure());
 784 }
 785 
 786 void ParNewRefProcTaskExecutor::execute(ProcessTask&amp; task, uint ergo_workers) {
 787   CMSHeap* gch = CMSHeap::heap();
 788   WorkGang* workers = gch-&gt;workers();
 789   assert(workers != NULL, &quot;Need parallel worker threads.&quot;);
 790   assert(workers-&gt;active_workers() == ergo_workers,
 791          &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,
 792          ergo_workers, workers-&gt;active_workers());
 793   _state_set.reset(workers-&gt;active_workers(), _young_gen.promotion_failed());
 794   ParNewRefProcTaskProxy rp_task(task, _young_gen, _old_gen,
 795                                  _young_gen.reserved().end(), _state_set);
 796   workers-&gt;run_task(&amp;rp_task, workers-&gt;active_workers());
 797   _state_set.reset(0 /* bad value in debug if not reset */,
 798                    _young_gen.promotion_failed());
 799 }
 800 
 801 void ParNewRefProcTaskExecutor::set_single_threaded_mode() {
 802   _state_set.flush();
 803   CMSHeap* heap = CMSHeap::heap();
 804   heap-&gt;save_marks();
 805 }
 806 
 807 ScanClosureWithParBarrier::
 808 ScanClosureWithParBarrier(ParNewGeneration* g, bool gc_barrier) :
 809   OopsInClassLoaderDataOrGenClosure(g), _g(g), _boundary(g-&gt;reserved().end()), _gc_barrier(gc_barrier)
 810 { }
 811 
 812 template &lt;typename OopClosureType1, typename OopClosureType2&gt;
 813 EvacuateFollowersClosureGeneral&lt;OopClosureType1, OopClosureType2&gt;::
 814 EvacuateFollowersClosureGeneral(CMSHeap* heap,
 815                                 OopClosureType1* cur,
 816                                 OopClosureType2* older) :
 817   _heap(heap),
 818   _scan_cur_or_nonheap(cur), _scan_older(older)
 819 { }
 820 
 821 template &lt;typename OopClosureType1, typename OopClosureType2&gt;
 822 void EvacuateFollowersClosureGeneral&lt;OopClosureType1, OopClosureType2&gt;::do_void() {
 823   do {
 824     _heap-&gt;oop_since_save_marks_iterate(_scan_cur_or_nonheap,
 825                                         _scan_older);
 826   } while (!_heap-&gt;no_allocs_since_save_marks());
 827 }
 828 
 829 // A Generation that does parallel young-gen collection.
 830 
 831 void ParNewGeneration::handle_promotion_failed(CMSHeap* gch, ParScanThreadStateSet&amp; thread_state_set) {
 832   assert(_promo_failure_scan_stack.is_empty(), &quot;post condition&quot;);
 833   _promo_failure_scan_stack.clear(true); // Clear cached segments.
 834 
 835   remove_forwarding_pointers();
 836   log_info(gc, promotion)(&quot;Promotion failed&quot;);
 837   // All the spaces are in play for mark-sweep.
 838   swap_spaces();  // Make life simpler for CMS || rescan; see 6483690.
 839   from()-&gt;set_next_compaction_space(to());
 840   gch-&gt;set_incremental_collection_failed();
 841   // Inform the next generation that a promotion failure occurred.
 842   _old_gen-&gt;promotion_failure_occurred();
 843 
 844   // Trace promotion failure in the parallel GC threads
 845   thread_state_set.trace_promotion_failed(gc_tracer());
 846   // Single threaded code may have reported promotion failure to the global state
 847   if (_promotion_failed_info.has_failed()) {
 848     _gc_tracer.report_promotion_failed(_promotion_failed_info);
 849   }
 850   // Reset the PromotionFailureALot counters.
 851   NOT_PRODUCT(gch-&gt;reset_promotion_should_fail();)
 852 }
 853 
 854 void ParNewGeneration::collect(bool   full,
 855                                bool   clear_all_soft_refs,
 856                                size_t size,
 857                                bool   is_tlab) {
 858   assert(full || size &gt; 0, &quot;otherwise we don&#39;t want to collect&quot;);
 859 
 860   CMSHeap* gch = CMSHeap::heap();
 861 
 862   _gc_timer-&gt;register_gc_start();
 863 
 864   AdaptiveSizePolicy* size_policy = gch-&gt;size_policy();
 865   WorkGang* workers = gch-&gt;workers();
 866   assert(workers != NULL, &quot;Need workgang for parallel work&quot;);
 867   uint active_workers =
 868       WorkerPolicy::calc_active_workers(workers-&gt;total_workers(),
 869                                         workers-&gt;active_workers(),
 870                                         Threads::number_of_non_daemon_threads());
 871   active_workers = workers-&gt;update_active_workers(active_workers);
 872   log_info(gc,task)(&quot;Using %u workers of %u for evacuation&quot;, active_workers, workers-&gt;total_workers());
 873 
 874   _old_gen = gch-&gt;old_gen();
 875 
 876   // If the next generation is too full to accommodate worst-case promotion
 877   // from this generation, pass on collection; let the next generation
 878   // do it.
 879   if (!collection_attempt_is_safe()) {
 880     gch-&gt;set_incremental_collection_failed();  // slight lie, in that we did not even attempt one
 881     return;
 882   }
 883   assert(to()-&gt;is_empty(), &quot;Else not collection_attempt_is_safe&quot;);
 884 
 885   _gc_tracer.report_gc_start(gch-&gt;gc_cause(), _gc_timer-&gt;gc_start());
 886   gch-&gt;trace_heap_before_gc(gc_tracer());
 887 
 888   init_assuming_no_promotion_failure();
 889 
 890   GCTraceTime(Trace, gc, phases) t1(&quot;ParNew&quot;, NULL, gch-&gt;gc_cause());
 891 
 892   age_table()-&gt;clear();
 893   to()-&gt;clear(SpaceDecorator::Mangle);
 894 
 895   gch-&gt;save_marks();
 896 
 897   // Set the correct parallelism (number of queues) in the reference processor
 898   ref_processor()-&gt;set_active_mt_degree(active_workers);
 899 
 900   // Need to initialize the preserved marks before the ThreadStateSet c&#39;tor.
 901   _preserved_marks_set.init(active_workers);
 902 
 903   // Always set the terminator for the active number of workers
 904   // because only those workers go through the termination protocol.
 905   TaskTerminator _term(active_workers, task_queues());
 906   ParScanThreadStateSet thread_state_set(active_workers,
 907                                          *to(), *this, *_old_gen, *task_queues(),
 908                                          _overflow_stacks, _preserved_marks_set,
 909                                          desired_plab_sz(), _term);
 910 
 911   thread_state_set.reset(active_workers, promotion_failed());
 912 
 913   {
 914     StrongRootsScope srs(active_workers);
 915 
 916     ParNewGenTask tsk(this, _old_gen, reserved().end(), &amp;thread_state_set, &amp;srs);
 917     gch-&gt;rem_set()-&gt;prepare_for_younger_refs_iterate(true);
 918     // It turns out that even when we&#39;re using 1 thread, doing the work in a
 919     // separate thread causes wide variance in run times.  We can&#39;t help this
 920     // in the multi-threaded case, but we special-case n=1 here to get
 921     // repeatable measurements of the 1-thread overhead of the parallel code.
 922     // Might multiple workers ever be used?  If yes, initialization
 923     // has been done such that the single threaded path should not be used.
 924     if (workers-&gt;total_workers() &gt; 1) {
 925       workers-&gt;run_task(&amp;tsk);
 926     } else {
 927       tsk.work(0);
 928     }
 929   }
 930 
 931   thread_state_set.reset(0 /* Bad value in debug if not reset */,
 932                          promotion_failed());
 933 
 934   // Trace and reset failed promotion info.
 935   if (promotion_failed()) {
 936     thread_state_set.trace_promotion_failed(gc_tracer());
 937   }
 938 
 939   // Process (weak) reference objects found during scavenge.
 940   ReferenceProcessor* rp = ref_processor();
 941   IsAliveClosure is_alive(this);
 942   ScanWeakRefClosure scan_weak_ref(this);
 943   KeepAliveClosure keep_alive(&amp;scan_weak_ref);
 944   ScanClosure               scan_without_gc_barrier(this, false);
 945   ScanClosureWithParBarrier scan_with_gc_barrier(this, true);
 946   set_promo_failure_scan_stack_closure(&amp;scan_without_gc_barrier);
 947   EvacuateFollowersClosureGeneral&lt;ScanClosure, ScanClosureWithParBarrier&gt; evacuate_followers(
 948       gch, &amp;scan_without_gc_barrier, &amp;scan_with_gc_barrier);
 949   rp-&gt;setup_policy(clear_all_soft_refs);
 950   // Can  the mt_degree be set later (at run_task() time would be best)?
 951   rp-&gt;set_active_mt_degree(active_workers);
 952   ReferenceProcessorStats stats;
 953   ReferenceProcessorPhaseTimes pt(_gc_timer, rp-&gt;max_num_queues());
 954   if (rp-&gt;processing_is_mt()) {
 955     ParNewRefProcTaskExecutor task_executor(*this, *_old_gen, thread_state_set);
 956     stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
 957                                               &amp;evacuate_followers, &amp;task_executor,
 958                                               &amp;pt);
 959   } else {
 960     thread_state_set.flush();
 961     gch-&gt;save_marks();
 962     stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
 963                                               &amp;evacuate_followers, NULL,
 964                                               &amp;pt);
 965   }
 966   _gc_tracer.report_gc_reference_stats(stats);
 967   _gc_tracer.report_tenuring_threshold(tenuring_threshold());
 968   pt.print_all_references();
 969 
 970   assert(gch-&gt;no_allocs_since_save_marks(), &quot;evacuation should be done at this point&quot;);
 971 
 972   WeakProcessor::weak_oops_do(&amp;is_alive, &amp;keep_alive);
 973 
 974   // Verify that the usage of keep_alive only forwarded
 975   // the oops and did not find anything new to copy.
 976   assert(gch-&gt;no_allocs_since_save_marks(), &quot;unexpectedly copied objects&quot;);
 977 
 978   if (!promotion_failed()) {
 979     // Swap the survivor spaces.
 980     eden()-&gt;clear(SpaceDecorator::Mangle);
 981     from()-&gt;clear(SpaceDecorator::Mangle);
 982     if (ZapUnusedHeapArea) {
 983       // This is now done here because of the piece-meal mangling which
 984       // can check for valid mangling at intermediate points in the
 985       // collection(s).  When a young collection fails to collect
 986       // sufficient space resizing of the young generation can occur
 987       // and redistribute the spaces in the young generation.  Mangle
 988       // here so that unzapped regions don&#39;t get distributed to
 989       // other spaces.
 990       to()-&gt;mangle_unused_area();
 991     }
 992     swap_spaces();
 993 
 994     // A successful scavenge should restart the GC time limit count which is
 995     // for full GC&#39;s.
 996     size_policy-&gt;reset_gc_overhead_limit_count();
 997 
 998     assert(to()-&gt;is_empty(), &quot;to space should be empty now&quot;);
 999 
1000     adjust_desired_tenuring_threshold();
1001   } else {
1002     handle_promotion_failed(gch, thread_state_set);
1003   }
1004   _preserved_marks_set.reclaim();
1005   // set new iteration safe limit for the survivor spaces
1006   from()-&gt;set_concurrent_iteration_safe_limit(from()-&gt;top());
1007   to()-&gt;set_concurrent_iteration_safe_limit(to()-&gt;top());
1008 
1009   plab_stats()-&gt;adjust_desired_plab_sz();
1010 
1011   TASKQUEUE_STATS_ONLY(thread_state_set.print_termination_stats());
1012   TASKQUEUE_STATS_ONLY(thread_state_set.print_taskqueue_stats());
1013 
1014   // We need to use a monotonically non-decreasing time in ms
1015   // or we will see time-warp warnings and os::javaTimeMillis()
1016   // does not guarantee monotonicity.
1017   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
1018   update_time_of_last_gc(now);
1019 
1020   rp-&gt;set_enqueuing_is_done(true);
1021   rp-&gt;verify_no_references_recorded();
1022 
1023   gch-&gt;trace_heap_after_gc(gc_tracer());
1024 
1025   _gc_timer-&gt;register_gc_end();
1026 
1027   _gc_tracer.report_gc_end(_gc_timer-&gt;gc_end(), _gc_timer-&gt;time_partitions());
1028 }
1029 
1030 size_t ParNewGeneration::desired_plab_sz() {
1031   return _plab_stats.desired_plab_sz(CMSHeap::heap()-&gt;workers()-&gt;active_workers());
1032 }
1033 
1034 static int sum;
1035 void ParNewGeneration::waste_some_time() {
1036   for (int i = 0; i &lt; 100; i++) {
1037     sum += i;
1038   }
1039 }
1040 
1041 static const oop ClaimedForwardPtr = cast_to_oop&lt;intptr_t&gt;(0x4);
1042 
1043 // Because of concurrency, there are times where an object for which
1044 // &quot;is_forwarded()&quot; is true contains an &quot;interim&quot; forwarding pointer
1045 // value.  Such a value will soon be overwritten with a real value.
1046 // This method requires &quot;obj&quot; to have a forwarding pointer, and waits, if
1047 // necessary for a real one to be inserted, and returns it.
1048 
1049 oop ParNewGeneration::real_forwardee(oop obj) {
1050   oop forward_ptr = obj-&gt;forwardee();
1051   if (forward_ptr != ClaimedForwardPtr) {
1052     return forward_ptr;
1053   } else {
1054     return real_forwardee_slow(obj);
1055   }
1056 }
1057 
1058 oop ParNewGeneration::real_forwardee_slow(oop obj) {
1059   // Spin-read if it is claimed but not yet written by another thread.
1060   oop forward_ptr = obj-&gt;forwardee();
1061   while (forward_ptr == ClaimedForwardPtr) {
1062     waste_some_time();
1063     assert(obj-&gt;is_forwarded(), &quot;precondition&quot;);
1064     forward_ptr = obj-&gt;forwardee();
1065   }
1066   return forward_ptr;
1067 }
1068 
1069 // Multiple GC threads may try to promote an object.  If the object
1070 // is successfully promoted, a forwarding pointer will be installed in
1071 // the object in the young generation.  This method claims the right
1072 // to install the forwarding pointer before it copies the object,
1073 // thus avoiding the need to undo the copy as in
1074 // copy_to_survivor_space_avoiding_with_undo.
1075 
1076 oop ParNewGeneration::copy_to_survivor_space(ParScanThreadState* par_scan_state,
1077                                              oop old,
1078                                              size_t sz,
1079                                              markOop m) {
1080   // In the sequential version, this assert also says that the object is
1081   // not forwarded.  That might not be the case here.  It is the case that
1082   // the caller observed it to be not forwarded at some time in the past.
1083   assert(is_in_reserved(old), &quot;shouldn&#39;t be scavenging this oop&quot;);
1084 
1085   // The sequential code read &quot;old-&gt;age()&quot; below.  That doesn&#39;t work here,
1086   // since the age is in the mark word, and that might be overwritten with
1087   // a forwarding pointer by a parallel thread.  So we must save the mark
1088   // word in a local and then analyze it.
1089   oopDesc dummyOld;
1090   dummyOld.set_mark_raw(m);
1091   assert(!dummyOld.is_forwarded(),
1092          &quot;should not be called with forwarding pointer mark word.&quot;);
1093 
1094   oop new_obj = NULL;
1095   oop forward_ptr;
1096 
1097   // Try allocating obj in to-space (unless too old)
1098   if (dummyOld.age() &lt; tenuring_threshold()) {
1099     new_obj = (oop)par_scan_state-&gt;alloc_in_to_space(sz);
1100   }
1101 
1102   if (new_obj == NULL) {
1103     // Either to-space is full or we decided to promote try allocating obj tenured
1104 
1105     // Attempt to install a null forwarding pointer (atomically),
1106     // to claim the right to install the real forwarding pointer.
1107     forward_ptr = old-&gt;forward_to_atomic(ClaimedForwardPtr, m);
1108     if (forward_ptr != NULL) {
1109       // someone else beat us to it.
1110         return real_forwardee(old);
1111     }
1112 
1113     if (!_promotion_failed) {
1114       new_obj = _old_gen-&gt;par_promote(par_scan_state-&gt;thread_num(),
1115                                       old, m, sz);
1116     }
1117 
1118     if (new_obj == NULL) {
1119       // promotion failed, forward to self
1120       _promotion_failed = true;
1121       new_obj = old;
1122 
1123       par_scan_state-&gt;preserved_marks()-&gt;push_if_necessary(old, m);
1124       par_scan_state-&gt;register_promotion_failure(sz);
1125     }
1126 
1127     old-&gt;forward_to(new_obj);
1128     forward_ptr = NULL;
1129   } else {
1130     // Is in to-space; do copying ourselves.
1131     Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)new_obj, sz);
1132     assert(CMSHeap::heap()-&gt;is_in_reserved(new_obj), &quot;illegal forwarding pointer value.&quot;);
1133     forward_ptr = old-&gt;forward_to_atomic(new_obj, m);
1134     // Restore the mark word copied above.
1135     new_obj-&gt;set_mark_raw(m);
1136     // Increment age if obj still in new generation
1137     new_obj-&gt;incr_age();
1138     par_scan_state-&gt;age_table()-&gt;add(new_obj, sz);
1139   }
1140   assert(new_obj != NULL, &quot;just checking&quot;);
1141 
1142   // This code must come after the CAS test, or it will print incorrect
1143   // information.
1144   log_develop_trace(gc, scavenge)(&quot;{%s %s &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot; (%d)}&quot;,
1145                                   is_in_reserved(new_obj) ? &quot;copying&quot; : &quot;tenuring&quot;,
1146                                   new_obj-&gt;klass()-&gt;internal_name(), p2i(old), p2i(new_obj), new_obj-&gt;size());
1147 
1148   if (forward_ptr == NULL) {
1149     oop obj_to_push = new_obj;
1150     if (par_scan_state-&gt;should_be_partially_scanned(obj_to_push, old)) {
1151       // Length field used as index of next element to be scanned.
1152       // Real length can be obtained from real_forwardee()
1153       arrayOop(old)-&gt;set_length(0);
1154       obj_to_push = old;
1155       assert(obj_to_push-&gt;is_forwarded() &amp;&amp; obj_to_push-&gt;forwardee() != obj_to_push,
1156              &quot;push forwarded object&quot;);
1157     }
1158     // Push it on one of the queues of to-be-scanned objects.
1159     bool simulate_overflow = false;
1160     NOT_PRODUCT(
1161       if (ParGCWorkQueueOverflowALot &amp;&amp; should_simulate_overflow()) {
1162         // simulate a stack overflow
1163         simulate_overflow = true;
1164       }
1165     )
1166     if (simulate_overflow || !par_scan_state-&gt;work_queue()-&gt;push(obj_to_push)) {
1167       // Add stats for overflow pushes.
1168       log_develop_trace(gc)(&quot;Queue Overflow&quot;);
1169       push_on_overflow_list(old, par_scan_state);
1170       TASKQUEUE_STATS_ONLY(par_scan_state-&gt;taskqueue_stats().record_overflow(0));
1171     }
1172 
1173     return new_obj;
1174   }
1175 
1176   // Oops.  Someone beat us to it.  Undo the allocation.  Where did we
1177   // allocate it?
1178   if (is_in_reserved(new_obj)) {
1179     // Must be in to_space.
1180     assert(to()-&gt;is_in_reserved(new_obj), &quot;Checking&quot;);
1181     if (forward_ptr == ClaimedForwardPtr) {
1182       // Wait to get the real forwarding pointer value.
1183       forward_ptr = real_forwardee(old);
1184     }
1185     par_scan_state-&gt;undo_alloc_in_to_space((HeapWord*)new_obj, sz);
1186   }
1187 
1188   return forward_ptr;
1189 }
1190 
1191 #ifndef PRODUCT
1192 // It&#39;s OK to call this multi-threaded;  the worst thing
1193 // that can happen is that we&#39;ll get a bunch of closely
1194 // spaced simulated overflows, but that&#39;s OK, in fact
1195 // probably good as it would exercise the overflow code
1196 // under contention.
1197 bool ParNewGeneration::should_simulate_overflow() {
1198   if (_overflow_counter-- &lt;= 0) { // just being defensive
1199     _overflow_counter = ParGCWorkQueueOverflowInterval;
1200     return true;
1201   } else {
1202     return false;
1203   }
1204 }
1205 #endif
1206 
1207 // In case we are using compressed oops, we need to be careful.
1208 // If the object being pushed is an object array, then its length
1209 // field keeps track of the &quot;grey boundary&quot; at which the next
1210 // incremental scan will be done (see ParGCArrayScanChunk).
1211 // When using compressed oops, this length field is kept in the
1212 // lower 32 bits of the erstwhile klass word and cannot be used
1213 // for the overflow chaining pointer (OCP below). As such the OCP
1214 // would itself need to be compressed into the top 32-bits in this
1215 // case. Unfortunately, see below, in the event that we have a
1216 // promotion failure, the node to be pushed on the list can be
1217 // outside of the Java heap, so the heap-based pointer compression
1218 // would not work (we would have potential aliasing between C-heap
1219 // and Java-heap pointers). For this reason, when using compressed
1220 // oops, we simply use a worker-thread-local, non-shared overflow
1221 // list in the form of a growable array, with a slightly different
1222 // overflow stack draining strategy. If/when we start using fat
1223 // stacks here, we can go back to using (fat) pointer chains
1224 // (although some performance comparisons would be useful since
1225 // single global lists have their own performance disadvantages
1226 // as we were made painfully aware not long ago, see 6786503).
1227 #define BUSY (cast_to_oop&lt;intptr_t&gt;(0x1aff1aff))
1228 void ParNewGeneration::push_on_overflow_list(oop from_space_obj, ParScanThreadState* par_scan_state) {
1229   assert(is_in_reserved(from_space_obj), &quot;Should be from this generation&quot;);
1230   if (ParGCUseLocalOverflow) {
1231     // In the case of compressed oops, we use a private, not-shared
1232     // overflow stack.
1233     par_scan_state-&gt;push_on_overflow_stack(from_space_obj);
1234   } else {
1235     assert(!UseCompressedOops, &quot;Error&quot;);
1236     // if the object has been forwarded to itself, then we cannot
1237     // use the klass pointer for the linked list.  Instead we have
1238     // to allocate an oopDesc in the C-Heap and use that for the linked list.
1239     // XXX This is horribly inefficient when a promotion failure occurs
1240     // and should be fixed. XXX FIX ME !!!
1241 #ifndef PRODUCT
1242     Atomic::inc(&amp;_num_par_pushes);
1243     assert(_num_par_pushes &gt; 0, &quot;Tautology&quot;);
1244 #endif
1245     if (from_space_obj-&gt;forwardee() == from_space_obj) {
1246       oopDesc* listhead = NEW_C_HEAP_ARRAY(oopDesc, 1, mtGC);
1247       listhead-&gt;forward_to(from_space_obj);
1248       from_space_obj = listhead;
1249     }
1250     oop observed_overflow_list = _overflow_list;
1251     oop cur_overflow_list;
1252     do {
1253       cur_overflow_list = observed_overflow_list;
1254       if (cur_overflow_list != BUSY) {
1255         from_space_obj-&gt;set_klass_to_list_ptr(cur_overflow_list);
1256       } else {
1257         from_space_obj-&gt;set_klass_to_list_ptr(NULL);
1258       }
1259       observed_overflow_list =
1260         Atomic::cmpxchg((oopDesc*)from_space_obj, &amp;_overflow_list, (oopDesc*)cur_overflow_list);
1261     } while (cur_overflow_list != observed_overflow_list);
1262   }
1263 }
1264 
1265 bool ParNewGeneration::take_from_overflow_list(ParScanThreadState* par_scan_state) {
1266   bool res;
1267 
1268   if (ParGCUseLocalOverflow) {
1269     res = par_scan_state-&gt;take_from_overflow_stack();
1270   } else {
1271     assert(!UseCompressedOops, &quot;Error&quot;);
1272     res = take_from_overflow_list_work(par_scan_state);
1273   }
1274   return res;
1275 }
1276 
1277 
1278 // *NOTE*: The overflow list manipulation code here and
1279 // in CMSCollector:: are very similar in shape,
1280 // except that in the CMS case we thread the objects
1281 // directly into the list via their mark word, and do
1282 // not need to deal with special cases below related
1283 // to chunking of object arrays and promotion failure
1284 // handling.
1285 // CR 6797058 has been filed to attempt consolidation of
1286 // the common code.
1287 // Because of the common code, if you make any changes in
1288 // the code below, please check the CMS version to see if
1289 // similar changes might be needed.
1290 // See CMSCollector::par_take_from_overflow_list() for
1291 // more extensive documentation comments.
1292 bool ParNewGeneration::take_from_overflow_list_work(ParScanThreadState* par_scan_state) {
1293   ObjToScanQueue* work_q = par_scan_state-&gt;work_queue();
1294   // How many to take?
1295   size_t objsFromOverflow = MIN2((size_t)(work_q-&gt;max_elems() - work_q-&gt;size())/4,
1296                                  (size_t)ParGCDesiredObjsFromOverflowList);
1297 
1298   assert(!UseCompressedOops, &quot;Error&quot;);
1299   assert(par_scan_state-&gt;overflow_stack() == NULL, &quot;Error&quot;);
1300   if (_overflow_list == NULL) return false;
1301 
1302   // Otherwise, there was something there; try claiming the list.
1303   oop prefix = cast_to_oop(Atomic::xchg((oopDesc*)BUSY, &amp;_overflow_list));
1304   // Trim off a prefix of at most objsFromOverflow items
1305   Thread* tid = Thread::current();
1306   size_t spin_count = ParallelGCThreads;
1307   size_t sleep_time_millis = MAX2((size_t)1, objsFromOverflow/100);
1308   for (size_t spin = 0; prefix == BUSY &amp;&amp; spin &lt; spin_count; spin++) {
1309     // someone grabbed it before we did ...
1310     // ... we spin for a short while...
1311     os::sleep(tid, sleep_time_millis, false);
1312     if (_overflow_list == NULL) {
1313       // nothing left to take
1314       return false;
1315     } else if (_overflow_list != BUSY) {
1316      // try and grab the prefix
1317      prefix = cast_to_oop(Atomic::xchg((oopDesc*)BUSY, &amp;_overflow_list));
1318     }
1319   }
1320   if (prefix == NULL || prefix == BUSY) {
1321      // Nothing to take or waited long enough
1322      if (prefix == NULL) {
1323        // Write back the NULL in case we overwrote it with BUSY above
1324        // and it is still the same value.
1325        (void) Atomic::cmpxchg((oopDesc*)NULL, &amp;_overflow_list, (oopDesc*)BUSY);
1326      }
1327      return false;
1328   }
1329   assert(prefix != NULL &amp;&amp; prefix != BUSY, &quot;Error&quot;);
1330   oop cur = prefix;
1331   for (size_t i = 1; i &lt; objsFromOverflow; ++i) {
1332     oop next = cur-&gt;list_ptr_from_klass();
1333     if (next == NULL) break;
1334     cur = next;
1335   }
1336   assert(cur != NULL, &quot;Loop postcondition&quot;);
1337 
1338   // Reattach remaining (suffix) to overflow list
1339   oop suffix = cur-&gt;list_ptr_from_klass();
1340   if (suffix == NULL) {
1341     // Write back the NULL in lieu of the BUSY we wrote
1342     // above and it is still the same value.
1343     if (_overflow_list == BUSY) {
1344       (void) Atomic::cmpxchg((oopDesc*)NULL, &amp;_overflow_list, (oopDesc*)BUSY);
1345     }
1346   } else {
1347     assert(suffix != BUSY, &quot;Error&quot;);
1348     // suffix will be put back on global list
1349     cur-&gt;set_klass_to_list_ptr(NULL);     // break off suffix
1350     // It&#39;s possible that the list is still in the empty(busy) state
1351     // we left it in a short while ago; in that case we may be
1352     // able to place back the suffix.
1353     oop observed_overflow_list = _overflow_list;
1354     oop cur_overflow_list = observed_overflow_list;
1355     bool attached = false;
1356     while (observed_overflow_list == BUSY || observed_overflow_list == NULL) {
1357       observed_overflow_list =
1358         Atomic::cmpxchg((oopDesc*)suffix, &amp;_overflow_list, (oopDesc*)cur_overflow_list);
1359       if (cur_overflow_list == observed_overflow_list) {
1360         attached = true;
1361         break;
1362       } else cur_overflow_list = observed_overflow_list;
1363     }
1364     if (!attached) {
1365       // Too bad, someone else got in in between; we&#39;ll need to do a splice.
1366       // Find the last item of suffix list
1367       oop last = suffix;
1368       while (true) {
1369         oop next = last-&gt;list_ptr_from_klass();
1370         if (next == NULL) break;
1371         last = next;
1372       }
1373       // Atomically prepend suffix to current overflow list
1374       observed_overflow_list = _overflow_list;
1375       do {
1376         cur_overflow_list = observed_overflow_list;
1377         if (cur_overflow_list != BUSY) {
1378           // Do the splice ...
1379           last-&gt;set_klass_to_list_ptr(cur_overflow_list);
1380         } else { // cur_overflow_list == BUSY
1381           last-&gt;set_klass_to_list_ptr(NULL);
1382         }
1383         observed_overflow_list =
1384           Atomic::cmpxchg((oopDesc*)suffix, &amp;_overflow_list, (oopDesc*)cur_overflow_list);
1385       } while (cur_overflow_list != observed_overflow_list);
1386     }
1387   }
1388 
1389   // Push objects on prefix list onto this thread&#39;s work queue
1390   assert(prefix != NULL &amp;&amp; prefix != BUSY, &quot;program logic&quot;);
1391   cur = prefix;
1392   ssize_t n = 0;
1393   while (cur != NULL) {
1394     oop obj_to_push = cur-&gt;forwardee();
1395     oop next        = cur-&gt;list_ptr_from_klass();
1396     cur-&gt;set_klass(obj_to_push-&gt;klass());
1397     // This may be an array object that is self-forwarded. In that case, the list pointer
1398     // space, cur, is not in the Java heap, but rather in the C-heap and should be freed.
1399     if (!is_in_reserved(cur)) {
1400       // This can become a scaling bottleneck when there is work queue overflow coincident
1401       // with promotion failure.
1402       oopDesc* f = cur;
1403       FREE_C_HEAP_ARRAY(oopDesc, f);
1404     } else if (par_scan_state-&gt;should_be_partially_scanned(obj_to_push, cur)) {
1405       assert(arrayOop(cur)-&gt;length() == 0, &quot;entire array remaining to be scanned&quot;);
1406       obj_to_push = cur;
1407     }
1408     bool ok = work_q-&gt;push(obj_to_push);
1409     assert(ok, &quot;Should have succeeded&quot;);
1410     cur = next;
1411     n++;
1412   }
1413   TASKQUEUE_STATS_ONLY(par_scan_state-&gt;note_overflow_refill(n));
1414 #ifndef PRODUCT
1415   assert(_num_par_pushes &gt;= n, &quot;Too many pops?&quot;);
1416   Atomic::sub(n, &amp;_num_par_pushes);
1417 #endif
1418   return true;
1419 }
1420 #undef BUSY
1421 
1422 void ParNewGeneration::ref_processor_init() {
1423   if (_ref_processor == NULL) {
1424     // Allocate and initialize a reference processor
1425     _span_based_discoverer.set_span(_reserved);
1426     _ref_processor =
1427       new ReferenceProcessor(&amp;_span_based_discoverer,    // span
1428                              ParallelRefProcEnabled &amp;&amp; (ParallelGCThreads &gt; 1), // mt processing
1429                              ParallelGCThreads,          // mt processing degree
1430                              refs_discovery_is_mt(),     // mt discovery
1431                              ParallelGCThreads,          // mt discovery degree
1432                              refs_discovery_is_atomic(), // atomic_discovery
1433                              NULL,                       // is_alive_non_header
1434                              false);                     // disable adjusting number of processing threads
1435   }
1436 }
1437 
1438 const char* ParNewGeneration::name() const {
1439   return &quot;par new generation&quot;;
1440 }
1441 
1442 void ParNewGeneration::restore_preserved_marks() {
1443   SharedRestorePreservedMarksTaskExecutor task_executor(CMSHeap::heap()-&gt;workers());
1444   _preserved_marks_set.restore(&amp;task_executor);
1445 }
    </pre>
  </body>
</html>
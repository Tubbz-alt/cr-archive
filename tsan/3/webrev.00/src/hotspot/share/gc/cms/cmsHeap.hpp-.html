<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cmsHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_CMSHEAP_HPP
 26 #define SHARE_GC_CMS_CMSHEAP_HPP
 27 
 28 #include &quot;gc/cms/concurrentMarkSweepGeneration.hpp&quot;
 29 #include &quot;gc/cms/parNewGeneration.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shared/gcCause.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;gc/shared/oopStorageParState.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 
 36 class CLDClosure;
 37 class GenCollectorPolicy;
 38 class GCMemoryManager;
 39 class MemoryPool;
 40 class OopsInGenClosure;
 41 class outputStream;
 42 class StrongRootsScope;
 43 class ThreadClosure;
 44 class WorkGang;
 45 
 46 class CMSHeap : public GenCollectedHeap {
 47 public:
 48   CMSHeap(GenCollectorPolicy *policy);
 49 
 50   // Returns JNI_OK on success
 51   virtual jint initialize();
 52   virtual CardTableRS* create_rem_set(const MemRegion&amp; reserved_region);
 53 
 54   // Convenience function to be used in situations where the heap type can be
 55   // asserted to be this type.
 56   static CMSHeap* heap();
 57 
 58   virtual Name kind() const {
 59     return CollectedHeap::CMS;
 60   }
 61 
 62   virtual const char* name() const {
 63     return &quot;Concurrent Mark Sweep&quot;;
 64   }
 65 
 66   WorkGang* workers() const { return _workers; }
 67 
 68   virtual void print_gc_threads_on(outputStream* st) const;
 69   virtual void gc_threads_do(ThreadClosure* tc) const;
 70   virtual void print_on_error(outputStream* st) const;
 71 
 72   // Perform a full collection of the heap; intended for use in implementing
 73   // &quot;System.gc&quot;. This implies as full a collection as the CollectedHeap
 74   // supports. Caller does not hold the Heap_lock on entry.
 75   void collect(GCCause::Cause cause);
 76 
 77   void stop();
 78   void safepoint_synchronize_begin();
 79   void safepoint_synchronize_end();
 80 
 81   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
 82   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
 83 
 84   // If &quot;young_gen_as_roots&quot; is false, younger generations are
 85   // not scanned as roots; in this case, the caller must be arranging to
 86   // scan the younger generations itself.  (For example, a generation might
 87   // explicitly mark reachable objects in younger generations, to avoid
 88   // excess storage retention.)
 89   void cms_process_roots(StrongRootsScope* scope,
 90                          bool young_gen_as_roots,
 91                          ScanningOption so,
 92                          bool only_strong_roots,
 93                          OopsInGenClosure* root_closure,
 94                          CLDClosure* cld_closure);
 95 
 96   GCMemoryManager* old_manager() const { return _old_manager; }
 97 
 98   ParNewGeneration* young_gen() const {
 99     assert(_young_gen-&gt;kind() == Generation::ParNew, &quot;Wrong generation type&quot;);
100     return static_cast&lt;ParNewGeneration*&gt;(_young_gen);
101   }
102 
103   ConcurrentMarkSweepGeneration* old_gen() const {
104     assert(_old_gen-&gt;kind() == Generation::ConcurrentMarkSweep, &quot;Wrong generation kind&quot;);
105     return static_cast&lt;ConcurrentMarkSweepGeneration*&gt;(_old_gen);
106   }
107 
108   // Apply &quot;cur-&gt;do_oop&quot; or &quot;older-&gt;do_oop&quot; to all the oops in objects
109   // allocated since the last call to save_marks in the young generation.
110   // The &quot;cur&quot; closure is applied to references in the younger generation
111   // at &quot;level&quot;, and the &quot;older&quot; closure to older generations.
112   template &lt;typename OopClosureType1, typename OopClosureType2&gt;
113   void oop_since_save_marks_iterate(OopClosureType1* cur,
114                                     OopClosureType2* older);
115 
116 private:
117   WorkGang* _workers;
118   MemoryPool* _eden_pool;
119   MemoryPool* _survivor_pool;
120   MemoryPool* _old_pool;
121 
122   virtual void gc_prologue(bool full);
123   virtual void gc_epilogue(bool full);
124 
125   virtual void initialize_serviceability();
126 
127   // Accessor for memory state verification support
128   NOT_PRODUCT(
129     virtual size_t skip_header_HeapWords() { return CMSCollector::skip_header_HeapWords(); }
130   )
131 
132   // Returns success or failure.
133   bool create_cms_collector();
134 
135   // In support of ExplicitGCInvokesConcurrent functionality
136   bool should_do_concurrent_full_gc(GCCause::Cause cause);
137 
138   void collect_mostly_concurrent(GCCause::Cause cause);
139 };
140 
141 #endif // SHARE_GC_CMS_CMSHEAP_HPP
    </pre>
  </body>
</html>
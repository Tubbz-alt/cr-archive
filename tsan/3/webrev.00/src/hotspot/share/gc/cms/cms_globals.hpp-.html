<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cms_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_CMS_GLOBALS_HPP
 26 #define SHARE_GC_CMS_CMS_GLOBALS_HPP
 27 
 28 #define GC_CMS_FLAGS(develop,                                               \
 29                      develop_pd,                                            \
 30                      product,                                               \
 31                      product_pd,                                            \
 32                      diagnostic,                                            \
 33                      diagnostic_pd,                                         \
 34                      experimental,                                          \
 35                      notproduct,                                            \
 36                      manageable,                                            \
 37                      product_rw,                                            \
 38                      lp64_product,                                          \
 39                      range,                                                 \
 40                      constraint,                                            \
 41                      writeable)                                             \
 42   product(bool, UseCMSBestFit, true,                                        \
 43           &quot;Use CMS best fit allocation strategy&quot;)                           \
 44                                                                             \
 45   product(size_t, CMSOldPLABMax, 1024,                                      \
 46           &quot;Maximum size of CMS gen promotion LAB caches per worker &quot;        \
 47           &quot;per block size&quot;)                                                 \
 48           range(1, max_uintx)                                               \
 49           constraint(CMSOldPLABMaxConstraintFunc,AfterMemoryInit)           \
 50                                                                             \
 51   product(size_t, CMSOldPLABMin, 16,                                        \
 52           &quot;Minimum size of CMS gen promotion LAB caches per worker &quot;        \
 53           &quot;per block size&quot;)                                                 \
 54           range(1, max_uintx)                                               \
 55           constraint(CMSOldPLABMinConstraintFunc,AfterMemoryInit)           \
 56                                                                             \
 57   product(uintx, CMSOldPLABNumRefills, 4,                                   \
 58           &quot;Nominal number of refills of CMS gen promotion LAB cache &quot;       \
 59           &quot;per worker per block size&quot;)                                      \
 60           range(1, max_uintx)                                               \
 61                                                                             \
 62   product(bool, CMSOldPLABResizeQuicker, false,                             \
 63           &quot;React on-the-fly during a scavenge to a sudden &quot;                 \
 64           &quot;change in block demand rate&quot;)                                    \
 65                                                                             \
 66   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
 67           &quot;The tolerance of the phase-change detector for on-the-fly &quot;      \
 68           &quot;PLAB resizing during a scavenge&quot;)                                \
 69           range(1, max_uintx)                                               \
 70                                                                             \
 71   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
 72           &quot;The gain in the feedback loop for on-the-fly PLAB resizing &quot;     \
 73           &quot;during a scavenge&quot;)                                              \
 74           range(1, max_uintx)                                               \
 75                                                                             \
 76   product_pd(size_t, CMSYoungGenPerWorker,                                  \
 77           &quot;The maximum size of young gen chosen by default per GC worker &quot;  \
 78           &quot;thread available&quot;)                                               \
 79           range(1, max_uintx)                                               \
 80                                                                             \
 81   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
 82           &quot;Percentage (0-100) used to add conservatism when computing the &quot; \
 83           &quot;duty cycle&quot;)                                                     \
 84           range(0, 100)                                                     \
 85                                                                             \
 86   product(uintx, CMSExpAvgFactor, 50,                                       \
 87           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
 88           &quot;computing exponential averages for CMS statistics&quot;)              \
 89           range(0, 100)                                                     \
 90                                                                             \
 91   product(uintx, CMS_FLSWeight, 75,                                         \
 92           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
 93           &quot;computing exponentially decaying averages for CMS FLS &quot;          \
 94           &quot;statistics&quot;)                                                     \
 95           range(0, 100)                                                     \
 96                                                                             \
 97   product(uintx, CMS_FLSPadding, 1,                                         \
 98           &quot;The multiple of deviation from mean to use for buffering &quot;       \
 99           &quot;against volatility in free list demand&quot;)                         \
100           range(0, max_juint)                                               \
101                                                                             \
102   product(uintx, FLSCoalescePolicy, 2,                                      \
103           &quot;CMS: aggressiveness level for coalescing, increasing &quot;           \
104           &quot;from 0 to 4&quot;)                                                    \
105           range(0, 4)                                                       \
106                                                                             \
107   product(bool, FLSAlwaysCoalesceLarge, false,                              \
108           &quot;CMS: larger free blocks are always available for coalescing&quot;)    \
109                                                                             \
110   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
111           &quot;CMS: the smaller the percentage the greater the coalescing &quot;     \
112           &quot;force&quot;)                                                          \
113           range(0.0, 1.0)                                                   \
114                                                                             \
115   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
116           &quot;CMS: the factor by which to inflate estimated demand of small &quot;  \
117           &quot;block sizes to prevent coalescing with an adjoining block&quot;)      \
118           range(0.0, DBL_MAX)                                               \
119                                                                             \
120   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
121           &quot;CMS: the factor by which to inflate estimated demand of large &quot;  \
122           &quot;block sizes to prevent coalescing with an adjoining block&quot;)      \
123           range(0.0, DBL_MAX)                                               \
124                                                                             \
125   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
126           &quot;CMS: the factor by which to inflate estimated demand of small &quot;  \
127           &quot;block sizes to prevent splitting to supply demand for smaller &quot;  \
128           &quot;blocks&quot;)                                                         \
129           range(0.0, DBL_MAX)                                               \
130                                                                             \
131   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
132           &quot;CMS: the factor by which to inflate estimated demand of large &quot;  \
133           &quot;block sizes to prevent splitting to supply demand for smaller &quot;  \
134           &quot;blocks&quot;)                                                         \
135           range(0.0, DBL_MAX)                                               \
136                                                                             \
137   product(bool, CMSExtrapolateSweep, false,                                 \
138           &quot;CMS: cushion for block demand during sweep&quot;)                     \
139                                                                             \
140   product(uintx, CMS_SweepWeight, 75,                                       \
141           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
142           &quot;computing exponentially decaying average for inter-sweep &quot;       \
143           &quot;duration&quot;)                                                       \
144           range(0, 100)                                                     \
145                                                                             \
146   product(uintx, CMS_SweepPadding, 1,                                       \
147           &quot;The multiple of deviation from mean to use for buffering &quot;       \
148           &quot;against volatility in inter-sweep duration&quot;)                     \
149           range(0, max_juint)                                               \
150                                                                             \
151   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
152           &quot;Skip block flux-rate sampling for an epoch unless inter-sweep &quot;  \
153           &quot;duration exceeds this threshold in milliseconds&quot;)                \
154           range(0, max_uintx)                                               \
155                                                                             \
156   product(bool, CMSClassUnloadingEnabled, true,                             \
157           &quot;Whether class unloading enabled when using CMS GC&quot;)              \
158                                                                             \
159   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
160           &quot;When CMS class unloading is enabled, the maximum CMS cycle &quot;     \
161           &quot;count for which classes may not be unloaded&quot;)                    \
162           range(0, max_uintx)                                               \
163                                                                             \
164   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
165           &quot;Replenish an indexed free list with this number of chunks&quot;)      \
166           range(1, max_uintx)                                               \
167                                                                             \
168   product(bool, CMSReplenishIntermediate, true,                             \
169           &quot;Replenish all intermediate free-list caches&quot;)                    \
170                                                                             \
171   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
172           &quot;When satisfying batched demand, split blocks from the &quot;          \
173           &quot;IndexedFreeList whose size is a multiple of requested size&quot;)     \
174                                                                             \
175   product(bool, CMSLoopWarn, false,                                         \
176           &quot;Warn in case of excessive CMS looping&quot;)                          \
177                                                                             \
178   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
179           &quot;Simulate frequent marking stack / work queue overflow&quot;)          \
180                                                                             \
181   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
182           &quot;An \&quot;interval\&quot; counter that determines how frequently &quot;         \
183           &quot;to simulate overflow; a smaller number increases frequency&quot;)     \
184                                                                             \
185   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
186           &quot;Maximum number of abortable preclean iterations, if &gt; 0&quot;)        \
187           range(0, max_uintx)                                               \
188                                                                             \
189   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
190           &quot;Maximum time in abortable preclean (in milliseconds)&quot;)           \
191           range(0, max_intx)                                                \
192                                                                             \
193   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
194           &quot;Nominal minimum work per abortable preclean iteration&quot;)          \
195           range(0, max_uintx)                                               \
196                                                                             \
197   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
198           &quot;Time that we sleep between iterations when not given &quot;           \
199           &quot;enough work per iteration&quot;)                                      \
200           range(0, max_intx)                                                \
201                                                                             \
202   /* 4096 = CardTable::card_size_in_words * BitsPerWord */                  \
203   product(size_t, CMSRescanMultiple, 32,                                    \
204           &quot;Size (in cards) of CMS parallel rescan task&quot;)                    \
205           range(1, SIZE_MAX / 4096)                                         \
206           constraint(CMSRescanMultipleConstraintFunc,AfterMemoryInit)       \
207                                                                             \
208   /* 4096 = CardTable::card_size_in_words * BitsPerWord */                  \
209   product(size_t, CMSConcMarkMultiple, 32,                                  \
210           &quot;Size (in cards) of CMS concurrent MT marking task&quot;)              \
211           range(1, SIZE_MAX / 4096)                                         \
212           constraint(CMSConcMarkMultipleConstraintFunc,AfterMemoryInit)     \
213                                                                             \
214   product(bool, CMSAbortSemantics, false,                                   \
215           &quot;Whether abort-on-overflow semantics is implemented&quot;)             \
216                                                                             \
217   product(bool, CMSParallelInitialMarkEnabled, true,                        \
218           &quot;Use the parallel initial mark.&quot;)                                 \
219                                                                             \
220   product(bool, CMSParallelRemarkEnabled, true,                             \
221           &quot;Whether parallel remark enabled (only if ParNewGC)&quot;)             \
222                                                                             \
223   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
224           &quot;Whether parallel remark of survivor space &quot;                      \
225           &quot;enabled (effective only if CMSParallelRemarkEnabled)&quot;)           \
226                                                                             \
227   product(bool, CMSPLABRecordAlways, true,                                  \
228           &quot;Always record survivor space PLAB boundaries (effective only &quot;   \
229           &quot;if CMSParallelSurvivorRemarkEnabled)&quot;)                           \
230                                                                             \
231   product(bool, CMSEdenChunksRecordAlways, true,                            \
232           &quot;Always record eden chunks used for the parallel initial mark &quot;   \
233           &quot;or remark of eden&quot;)                                              \
234                                                                             \
235   product(bool, CMSConcurrentMTEnabled, true,                               \
236           &quot;Whether multi-threaded concurrent work enabled &quot;                 \
237           &quot;(effective only if ParNewGC)&quot;)                                   \
238                                                                             \
239   product(bool, CMSPrecleaningEnabled, true,                                \
240           &quot;Whether concurrent precleaning enabled&quot;)                         \
241                                                                             \
242   product(uintx, CMSPrecleanIter, 3,                                        \
243           &quot;Maximum number of precleaning iteration passes&quot;)                 \
244           range(0, 9)                                                       \
245                                                                             \
246   product(uintx, CMSPrecleanDenominator, 3,                                 \
247           &quot;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence &quot; \
248           &quot;ratio&quot;)                                                          \
249           range(1, max_uintx)                                               \
250           constraint(CMSPrecleanDenominatorConstraintFunc,AfterErgo)        \
251                                                                             \
252   product(uintx, CMSPrecleanNumerator, 2,                                   \
253           &quot;CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence &quot; \
254           &quot;ratio&quot;)                                                          \
255           range(0, max_uintx-1)                                             \
256           constraint(CMSPrecleanNumeratorConstraintFunc,AfterErgo)          \
257                                                                             \
258   product(bool, CMSPrecleanRefLists1, true,                                 \
259           &quot;Preclean ref lists during (initial) preclean phase&quot;)             \
260                                                                             \
261   product(bool, CMSPrecleanRefLists2, false,                                \
262           &quot;Preclean ref lists during abortable preclean phase&quot;)             \
263                                                                             \
264   product(bool, CMSPrecleanSurvivors1, false,                               \
265           &quot;Preclean survivors during (initial) preclean phase&quot;)             \
266                                                                             \
267   product(bool, CMSPrecleanSurvivors2, true,                                \
268           &quot;Preclean survivors during abortable preclean phase&quot;)             \
269                                                                             \
270   product(uintx, CMSPrecleanThreshold, 1000,                                \
271           &quot;Do not iterate again if number of dirty cards is less than this&quot;)\
272           range(100, max_uintx)                                             \
273                                                                             \
274   product(bool, CMSCleanOnEnter, true,                                      \
275           &quot;Clean-on-enter optimization for reducing number of dirty cards&quot;) \
276                                                                             \
277   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
278           &quot;Choose variant (1,2) of verification following remark&quot;)          \
279           range(1, 2)                                                       \
280                                                                             \
281   product(size_t, CMSScheduleRemarkEdenSizeThreshold, 2*M,                  \
282           &quot;If Eden size is below this, do not try to schedule remark&quot;)      \
283           range(0, max_uintx)                                               \
284                                                                             \
285   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
286           &quot;The Eden occupancy percentage (0-100) at which &quot;                 \
287           &quot;to try and schedule remark pause&quot;)                               \
288           range(0, 100)                                                     \
289                                                                             \
290   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
291           &quot;Start sampling eden top at least before young gen &quot;              \
292           &quot;occupancy reaches 1/&lt;ratio&gt; of the size at which &quot;               \
293           &quot;we plan to schedule remark&quot;)                                     \
294           range(1, max_uintx)                                               \
295                                                                             \
296   product(uintx, CMSSamplingGrain, 16*K,                                    \
297           &quot;The minimum distance between eden samples for CMS (see above)&quot;)  \
298           range(ObjectAlignmentInBytes, max_uintx)                          \
299           constraint(CMSSamplingGrainConstraintFunc,AfterMemoryInit)        \
300                                                                             \
301   product(bool, CMSScavengeBeforeRemark, false,                             \
302           &quot;Attempt scavenge before the CMS remark step&quot;)                    \
303                                                                             \
304   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
305           &quot;Don&#39;t drain below this size per parallel worker/thief&quot;)          \
306           range(1, max_juint)                                               \
307           constraint(CMSWorkQueueDrainThresholdConstraintFunc,AfterErgo)    \
308                                                                             \
309   manageable(intx, CMSWaitDuration, 2000,                                   \
310           &quot;Time in milliseconds that CMS thread waits for young GC&quot;)        \
311           range(min_jint, max_jint)                                         \
312                                                                             \
313   develop(uintx, CMSCheckInterval, 1000,                                    \
314           &quot;Interval in milliseconds that CMS thread checks if it &quot;          \
315           &quot;should start a collection cycle&quot;)                                \
316                                                                             \
317   product(bool, CMSYield, true,                                             \
318           &quot;Yield between steps of CMS&quot;)                                     \
319                                                                             \
320   product(size_t, CMSBitMapYieldQuantum, 10*M,                              \
321           &quot;Bitmap operations should process at most this many bits &quot;        \
322           &quot;between yields&quot;)                                                 \
323           range(1, max_uintx)                                               \
324           constraint(CMSBitMapYieldQuantumConstraintFunc,AfterMemoryInit)   \
325                                                                             \
326   product(bool, CMSPrintChunksInDump, false,                                \
327           &quot;If logging for the \&quot;gc\&quot; and \&quot;promotion\&quot; tags is enabled on&quot;  \
328           &quot;trace level include more detailed information about the&quot;         \
329           &quot;free chunks&quot;)                                                    \
330                                                                             \
331   product(bool, CMSPrintObjectsInDump, false,                               \
332           &quot;If logging for the \&quot;gc\&quot; and \&quot;promotion\&quot; tags is enabled on&quot;  \
333           &quot;trace level include more detailed information about the&quot;         \
334           &quot;allocated objects&quot;)                                              \
335                                                                             \
336   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
337           &quot;Verify that all references across the FLS boundary &quot;             \
338           &quot;are to valid objects&quot;)                                           \
339                                                                             \
340   diagnostic(bool, FLSVerifyLists, false,                                   \
341           &quot;Do lots of (expensive) FreeListSpace verification&quot;)              \
342                                                                             \
343   diagnostic(bool, FLSVerifyIndexTable, false,                              \
344           &quot;Do lots of (expensive) FLS index table verification&quot;)            \
345                                                                             \
346   product(uintx, CMSTriggerRatio, 80,                                       \
347           &quot;Percentage of MinHeapFreeRatio in CMS generation that is &quot;       \
348           &quot;allocated before a CMS collection cycle commences&quot;)              \
349           range(0, 100)                                                     \
350                                                                             \
351   product(uintx, CMSBootstrapOccupancy, 50,                                 \
352           &quot;Percentage CMS generation occupancy at which to &quot;                \
353           &quot;initiate CMS collection for bootstrapping collection stats&quot;)     \
354           range(0, 100)                                                     \
355                                                                             \
356   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
357           &quot;Percentage CMS generation occupancy to start a CMS collection &quot;  \
358           &quot;cycle. A negative value means that CMSTriggerRatio is used&quot;)     \
359           range(min_intx, 100)                                              \
360                                                                             \
361   manageable(intx, CMSTriggerInterval, -1,                                  \
362           &quot;Commence a CMS collection cycle (at least) every so many &quot;       \
363           &quot;milliseconds (0 permanently, -1 disabled)&quot;)                      \
364           range(-1, max_intx)                                               \
365                                                                             \
366   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
367           &quot;Only use occupancy as a criterion for starting a CMS collection&quot;)\
368                                                                             \
369   product(uintx, CMSIsTooFullPercentage, 98,                                \
370           &quot;An absolute ceiling above which CMS will always consider the &quot;   \
371           &quot;unloading of classes when class unloading is enabled&quot;)           \
372           range(0, 100)                                                     \
373                                                                             \
374   develop(bool, CMSTestInFreeList, false,                                   \
375           &quot;Check if the coalesced range is already in the &quot;                 \
376           &quot;free lists as claimed&quot;)                                          \
377                                                                             \
378   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
379           &quot;Check that all the garbage collected was returned to the &quot;       \
380           &quot;free lists&quot;)                                                     \
381                                                                             \
382   diagnostic(bool, BindCMSThreadToCPU, false,                               \
383           &quot;Bind CMS Thread to CPU if possible&quot;)                             \
384                                                                             \
385   diagnostic(uintx, CPUForCMSThread, 0,                                     \
386           &quot;When BindCMSThreadToCPU is true, the CPU to bind CMS thread to&quot;) \
387           range(0, max_juint)                                               \
388                                                                             \
389   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
390           &quot;Number of times the coordinator GC thread will sleep while &quot;     \
391           &quot;yielding before giving up and resuming GC&quot;)                      \
392           range(0, max_juint)                                               \
393                                                                             \
394   product(uintx, CMSYieldSleepCount, 0,                                     \
395           &quot;Number of times a GC thread (minus the coordinator) &quot;            \
396           &quot;will sleep while yielding before giving up and resuming GC&quot;)     \
397           range(0, max_juint)                                               \
398                                                                             \
399   product(bool, ParGCUseLocalOverflow, false,                               \
400           &quot;Instead of a global overflow list, use local overflow stacks&quot;)   \
401                                                                             \
402   product(bool, ParGCTrimOverflow, true,                                    \
403           &quot;Eagerly trim the local overflow lists &quot;                          \
404           &quot;(when ParGCUseLocalOverflow)&quot;)                                   \
405                                                                             \
406   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
407           &quot;Simulate work queue overflow in ParNew&quot;)                         \
408                                                                             \
409   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
410           &quot;An `interval&#39; counter that determines how frequently &quot;           \
411           &quot;we simulate overflow; a smaller number increases frequency&quot;)     \
412                                                                             \
413   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
414           &quot;The desired number of objects to claim from the overflow list&quot;)  \
415           range(0, max_uintx)                                               \
416                                                                             \
417   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
418           &quot;The number of strides per worker thread that we divide up the &quot;  \
419           &quot;card table scanning work into&quot;)                                  \
420           range(1, max_uintx)                                               \
421           constraint(ParGCStridesPerThreadConstraintFunc,AfterErgo)         \
422                                                                             \
423   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
424           &quot;The number of cards in each chunk of the parallel chunks used &quot;  \
425           &quot;during card table scanning&quot;)                                     \
426           range(1, max_intx)                                                \
427           constraint(ParGCCardsPerStrideChunkConstraintFunc,AfterMemoryInit)
428 
429 #endif // SHARE_GC_CMS_CMS_GLOBALS_HPP
    </pre>
  </body>
</html>
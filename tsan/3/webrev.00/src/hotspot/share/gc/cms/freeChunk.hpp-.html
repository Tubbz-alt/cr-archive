<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/freeChunk.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_FREECHUNK_HPP
 26 #define SHARE_GC_CMS_FREECHUNK_HPP
 27 
 28 #include &quot;memory/memRegion.hpp&quot;
 29 #include &quot;oops/markOop.hpp&quot;
 30 #include &quot;runtime/mutex.hpp&quot;
 31 #include &quot;runtime/orderAccess.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 
 36 //
 37 // Free block maintenance for Concurrent Mark Sweep Generation
 38 //
 39 // The main data structure for free blocks are
 40 // . an indexed array of small free blocks, and
 41 // . a dictionary of large free blocks
 42 //
 43 
 44 // No virtuals in FreeChunk (don&#39;t want any vtables).
 45 
 46 // A FreeChunk is merely a chunk that can be in a doubly linked list
 47 // and has a size field. NOTE: FreeChunks are distinguished from allocated
 48 // objects in two ways (by the sweeper), depending on whether the VM is 32 or
 49 // 64 bits.
 50 // In 32 bits or 64 bits without CompressedOops, the second word (prev) has the
 51 // LSB set to indicate a free chunk; allocated objects&#39; klass() pointers
 52 // don&#39;t have their LSB set. The corresponding bit in the CMSBitMap is
 53 // set when the chunk is allocated. There are also blocks that &quot;look free&quot;
 54 // but are not part of the free list and should not be coalesced into larger
 55 // free blocks. These free blocks have their two LSB&#39;s set.
 56 
 57 class FreeChunk {
 58   friend class VMStructs;
 59   // For 64 bit compressed oops, the markOop encodes both the size and the
 60   // indication that this is a FreeChunk and not an object.
 61   volatile size_t   _size;
 62   FreeChunk* _prev;
 63   FreeChunk* _next;
 64 
 65   markOop mark()     const volatile { return (markOop)_size; }
 66   void set_mark(markOop m)          { _size = (size_t)m; }
 67 
 68  public:
 69   NOT_PRODUCT(static const size_t header_size();)
 70 
 71   // Returns &quot;true&quot; if the address indicates that the block represents
 72   // a free chunk.
 73   static bool indicatesFreeChunk(const HeapWord* addr) {
 74     // Force volatile read from addr because value might change between
 75     // calls.  We really want the read of _mark and _prev from this pointer
 76     // to be volatile but making the fields volatile causes all sorts of
 77     // compilation errors.
 78     return ((volatile FreeChunk*)addr)-&gt;is_free();
 79   }
 80 
 81   bool is_free() const volatile {
 82     LP64_ONLY(if (UseCompressedOops) return mark()-&gt;is_cms_free_chunk(); else)
 83     return (((intptr_t)_prev) &amp; 0x1) == 0x1;
 84   }
 85   bool cantCoalesce() const {
 86     assert(is_free(), &quot;can&#39;t get coalesce bit on not free&quot;);
 87     return (((intptr_t)_prev) &amp; 0x2) == 0x2;
 88   }
 89   void dontCoalesce() {
 90     // the block should be free
 91     assert(is_free(), &quot;Should look like a free block&quot;);
 92     _prev = (FreeChunk*)(((intptr_t)_prev) | 0x2);
 93   }
 94   FreeChunk* prev() const {
 95     return (FreeChunk*)(((intptr_t)_prev) &amp; ~(0x3));
 96   }
 97 
 98   debug_only(void* prev_addr() const { return (void*)&amp;_prev; })
 99   debug_only(void* next_addr() const { return (void*)&amp;_next; })
100   debug_only(void* size_addr() const { return (void*)&amp;_size; })
101 
102   size_t size() const volatile {
103     LP64_ONLY(if (UseCompressedOops) return mark()-&gt;get_size(); else )
104     return _size;
105   }
106   void set_size(size_t sz) {
107     LP64_ONLY(if (UseCompressedOops) set_mark(markOopDesc::set_size_and_free(sz)); else )
108     _size = sz;
109   }
110 
111   FreeChunk* next()   const { return _next; }
112 
113   void link_after(FreeChunk* ptr) {
114     link_next(ptr);
115     if (ptr != NULL) ptr-&gt;link_prev(this);
116   }
117   void link_next(FreeChunk* ptr) { _next = ptr; }
118   void link_prev(FreeChunk* ptr) {
119     LP64_ONLY(if (UseCompressedOops) _prev = ptr; else)
120     _prev = (FreeChunk*)((intptr_t)ptr | 0x1);
121   }
122   void clear_next()              { _next = NULL; }
123   void markNotFree() {
124     // Set _prev (klass) to null before (if) clearing the mark word below
125     _prev = NULL;
126 #ifdef _LP64
127     if (UseCompressedOops) {
128       OrderAccess::storestore();
129       set_mark(markOopDesc::prototype());
130     }
131 #endif
132     assert(!is_free(), &quot;Error&quot;);
133   }
134 
135   // Return the address past the end of this chunk
136   uintptr_t* end() const { return ((uintptr_t*) this) + size(); }
137 
138   // debugging
139   void verify()             const PRODUCT_RETURN;
140   void verifyList()         const PRODUCT_RETURN;
141   void mangleAllocated(size_t size) PRODUCT_RETURN;
142   void mangleFreed(size_t size)     PRODUCT_RETURN;
143 
144   void print_on(outputStream* st);
145 };
146 
147 extern size_t MinChunkSize;
148 
149 
150 #endif // SHARE_GC_CMS_FREECHUNK_HPP
    </pre>
  </body>
</html>
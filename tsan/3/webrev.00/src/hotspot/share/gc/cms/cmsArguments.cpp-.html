<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cmsArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;gc/cms/cmsArguments.hpp&quot;
 28 #include &quot;gc/cms/cmsCollectorPolicy.hpp&quot;
 29 #include &quot;gc/cms/cmsHeap.hpp&quot;
 30 #include &quot;gc/cms/compactibleFreeListSpace.hpp&quot;
 31 #include &quot;gc/shared/gcArguments.inline.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;gc/shared/workerPolicy.hpp&quot;
 34 #include &quot;runtime/arguments.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/globals_extension.hpp&quot;
 37 #include &quot;utilities/defaultStream.hpp&quot;
 38 
 39 size_t CMSArguments::conservative_max_heap_alignment() {
 40   return GenCollectedHeap::conservative_max_heap_alignment();
 41 }
 42 
 43 void CMSArguments::set_parnew_gc_flags() {
 44   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC &amp;&amp; !UseG1GC,
 45          &quot;control point invariant&quot;);
 46   assert(UseConcMarkSweepGC, &quot;CMS is expected to be on here&quot;);
 47 
 48   if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
 49     FLAG_SET_DEFAULT(ParallelGCThreads, WorkerPolicy::parallel_worker_threads());
 50     assert(ParallelGCThreads &gt; 0, &quot;We should always have at least one thread by default&quot;);
 51   } else if (ParallelGCThreads == 0) {
 52     jio_fprintf(defaultStream::error_stream(),
 53         &quot;The ParNew GC can not be combined with -XX:ParallelGCThreads=0\n&quot;);
 54     vm_exit(1);
 55   }
 56 
 57   // By default YoungPLABSize and OldPLABSize are set to 4096 and 1024 respectively,
 58   // these settings are default for Parallel Scavenger. For ParNew+Tenured configuration
 59   // we set them to 1024 and 1024.
 60   // See CR 6362902.
 61   if (FLAG_IS_DEFAULT(YoungPLABSize)) {
 62     FLAG_SET_DEFAULT(YoungPLABSize, (intx)1024);
 63   }
 64   if (FLAG_IS_DEFAULT(OldPLABSize)) {
 65     FLAG_SET_DEFAULT(OldPLABSize, (intx)1024);
 66   }
 67 
 68   // When using compressed oops, we use local overflow stacks,
 69   // rather than using a global overflow list chained through
 70   // the klass word of the object&#39;s pre-image.
 71   if (UseCompressedOops &amp;&amp; !ParGCUseLocalOverflow) {
 72     if (!FLAG_IS_DEFAULT(ParGCUseLocalOverflow)) {
 73       warning(&quot;Forcing +ParGCUseLocalOverflow: needed if using compressed references&quot;);
 74     }
 75     FLAG_SET_DEFAULT(ParGCUseLocalOverflow, true);
 76   }
 77   assert(ParGCUseLocalOverflow || !UseCompressedOops, &quot;Error&quot;);
 78 }
 79 
 80 // Adjust some sizes to suit CMS and/or ParNew needs; these work well on
 81 // sparc/solaris for certain applications, but would gain from
 82 // further optimization and tuning efforts, and would almost
 83 // certainly gain from analysis of platform and environment.
 84 void CMSArguments::initialize() {
 85   GCArguments::initialize();
 86 
 87   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC, &quot;Error&quot;);
 88   assert(UseConcMarkSweepGC, &quot;CMS is expected to be on here&quot;);
 89 
 90   // CMS space iteration, which FLSVerifyAllHeapreferences entails,
 91   // insists that we hold the requisite locks so that the iteration is
 92   // MT-safe. For the verification at start-up and shut-down, we don&#39;t
 93   // yet have a good way of acquiring and releasing these locks,
 94   // which are not visible at the CollectedHeap level. We want to
 95   // be able to acquire these locks and then do the iteration rather
 96   // than just disable the lock verification. This will be fixed under
 97   // bug 4788986.
 98   if (UseConcMarkSweepGC &amp;&amp; FLSVerifyAllHeapReferences) {
 99     if (VerifyDuringStartup) {
100       warning(&quot;Heap verification at start-up disabled &quot;
101               &quot;(due to current incompatibility with FLSVerifyAllHeapReferences)&quot;);
102       VerifyDuringStartup = false; // Disable verification at start-up
103     }
104 
105     if (VerifyBeforeExit) {
106       warning(&quot;Heap verification at shutdown disabled &quot;
107               &quot;(due to current incompatibility with FLSVerifyAllHeapReferences)&quot;);
108       VerifyBeforeExit = false; // Disable verification at shutdown
109     }
110   }
111 
112   if (!ClassUnloading) {
113     FLAG_SET_CMDLINE(bool, CMSClassUnloadingEnabled, false);
114   }
115 
116   // Set CMS global values
117   CompactibleFreeListSpace::set_cms_values();
118 
119   // Turn off AdaptiveSizePolicy by default for cms until it is complete.
120   disable_adaptive_size_policy(&quot;UseConcMarkSweepGC&quot;);
121 
122   set_parnew_gc_flags();
123 
124   size_t max_heap = align_down(MaxHeapSize,
125                                CardTableRS::ct_max_alignment_constraint());
126 
127   // Now make adjustments for CMS
128   intx   tenuring_default = (intx)6;
129   size_t young_gen_per_worker = CMSYoungGenPerWorker;
130 
131   // Preferred young gen size for &quot;short&quot; pauses:
132   // upper bound depends on # of threads and NewRatio.
133   const size_t preferred_max_new_size_unaligned =
134     MIN2(max_heap/(NewRatio+1), ScaleForWordSize(young_gen_per_worker * ParallelGCThreads));
135   size_t preferred_max_new_size =
136     align_up(preferred_max_new_size_unaligned, os::vm_page_size());
137 
138   // Unless explicitly requested otherwise, size young gen
139   // for &quot;short&quot; pauses ~ CMSYoungGenPerWorker*ParallelGCThreads
140 
141   // If either MaxNewSize or NewRatio is set on the command line,
142   // assume the user is trying to set the size of the young gen.
143   if (FLAG_IS_DEFAULT(MaxNewSize) &amp;&amp; FLAG_IS_DEFAULT(NewRatio)) {
144 
145     // Set MaxNewSize to our calculated preferred_max_new_size unless
146     // NewSize was set on the command line and it is larger than
147     // preferred_max_new_size.
148     if (!FLAG_IS_DEFAULT(NewSize)) {   // NewSize explicitly set at command-line
149       FLAG_SET_ERGO(size_t, MaxNewSize, MAX2(NewSize, preferred_max_new_size));
150     } else {
151       FLAG_SET_ERGO(size_t, MaxNewSize, preferred_max_new_size);
152     }
153     log_trace(gc, heap)(&quot;CMS ergo set MaxNewSize: &quot; SIZE_FORMAT, MaxNewSize);
154 
155     // Code along this path potentially sets NewSize and OldSize
156     log_trace(gc, heap)(&quot;CMS set min_heap_size: &quot; SIZE_FORMAT &quot; initial_heap_size:  &quot; SIZE_FORMAT &quot; max_heap: &quot; SIZE_FORMAT,
157                         Arguments::min_heap_size(), InitialHeapSize, max_heap);
158     size_t min_new = preferred_max_new_size;
159     if (FLAG_IS_CMDLINE(NewSize)) {
160       min_new = NewSize;
161     }
162     if (max_heap &gt; min_new &amp;&amp; Arguments::min_heap_size() &gt; min_new) {
163       // Unless explicitly requested otherwise, make young gen
164       // at least min_new, and at most preferred_max_new_size.
165       if (FLAG_IS_DEFAULT(NewSize)) {
166         FLAG_SET_ERGO(size_t, NewSize, MAX2(NewSize, min_new));
167         FLAG_SET_ERGO(size_t, NewSize, MIN2(preferred_max_new_size, NewSize));
168         log_trace(gc, heap)(&quot;CMS ergo set NewSize: &quot; SIZE_FORMAT, NewSize);
169       }
170       // Unless explicitly requested otherwise, size old gen
171       // so it&#39;s NewRatio x of NewSize.
172       if (FLAG_IS_DEFAULT(OldSize)) {
173         if (max_heap &gt; NewSize) {
174           FLAG_SET_ERGO(size_t, OldSize, MIN2(NewRatio*NewSize, max_heap - NewSize));
175           log_trace(gc, heap)(&quot;CMS ergo set OldSize: &quot; SIZE_FORMAT, OldSize);
176         }
177       }
178     }
179   }
180   // Unless explicitly requested otherwise, definitely
181   // promote all objects surviving &quot;tenuring_default&quot; scavenges.
182   if (FLAG_IS_DEFAULT(MaxTenuringThreshold) &amp;&amp;
183       FLAG_IS_DEFAULT(SurvivorRatio)) {
184     FLAG_SET_ERGO(uintx, MaxTenuringThreshold, tenuring_default);
185   }
186   // If we decided above (or user explicitly requested)
187   // `promote all&#39; (via MaxTenuringThreshold := 0),
188   // prefer minuscule survivor spaces so as not to waste
189   // space for (non-existent) survivors
190   if (FLAG_IS_DEFAULT(SurvivorRatio) &amp;&amp; MaxTenuringThreshold == 0) {
191     FLAG_SET_ERGO(uintx, SurvivorRatio, MAX2((uintx)1024, SurvivorRatio));
192   }
193 
194   // OldPLABSize is interpreted in CMS as not the size of the PLAB in words,
195   // but rather the number of free blocks of a given size that are used when
196   // replenishing the local per-worker free list caches.
197   if (FLAG_IS_DEFAULT(OldPLABSize)) {
198     if (!FLAG_IS_DEFAULT(ResizeOldPLAB) &amp;&amp; !ResizeOldPLAB) {
199       // OldPLAB sizing manually turned off: Use a larger default setting,
200       // unless it was manually specified. This is because a too-low value
201       // will slow down scavenges.
202       FLAG_SET_ERGO(size_t, OldPLABSize, CompactibleFreeListSpaceLAB::_default_static_old_plab_size); // default value before 6631166
203     } else {
204       FLAG_SET_DEFAULT(OldPLABSize, CompactibleFreeListSpaceLAB::_default_dynamic_old_plab_size); // old CMSParPromoteBlocksToClaim default
205     }
206   }
207 
208   // If either of the static initialization defaults have changed, note this
209   // modification.
210   if (!FLAG_IS_DEFAULT(OldPLABSize) || !FLAG_IS_DEFAULT(OldPLABWeight)) {
211     CompactibleFreeListSpaceLAB::modify_initialization(OldPLABSize, OldPLABWeight);
212   }
213 
214   log_trace(gc)(&quot;MarkStackSize: %uk  MarkStackSizeMax: %uk&quot;, (unsigned int) (MarkStackSize / K), (uint) (MarkStackSizeMax / K));
215 }
216 
217 void CMSArguments::disable_adaptive_size_policy(const char* collector_name) {
218   if (UseAdaptiveSizePolicy) {
219     if (FLAG_IS_CMDLINE(UseAdaptiveSizePolicy)) {
220       warning(&quot;Disabling UseAdaptiveSizePolicy; it is incompatible with %s.&quot;,
221               collector_name);
222     }
223     FLAG_SET_DEFAULT(UseAdaptiveSizePolicy, false);
224   }
225 }
226 
227 CollectedHeap* CMSArguments::create_heap() {
228   return create_heap_with_policy&lt;CMSHeap, ConcurrentMarkSweepPolicy&gt;();
229 }
    </pre>
  </body>
</html>
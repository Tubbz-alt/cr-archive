<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/cmsHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/cms/cmsCardTable.hpp&quot;
 27 #include &quot;gc/cms/cmsVMOperations.hpp&quot;
 28 #include &quot;gc/cms/compactibleFreeListSpace.hpp&quot;
 29 #include &quot;gc/cms/concurrentMarkSweepGeneration.hpp&quot;
 30 #include &quot;gc/cms/concurrentMarkSweepThread.hpp&quot;
 31 #include &quot;gc/cms/cmsHeap.hpp&quot;
 32 #include &quot;gc/cms/parNewGeneration.hpp&quot;
 33 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 34 #include &quot;gc/shared/genMemoryPools.hpp&quot;
 35 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 36 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 37 #include &quot;gc/shared/workgroup.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;runtime/vmThread.hpp&quot;
 40 #include &quot;services/memoryManager.hpp&quot;
 41 #include &quot;utilities/stack.inline.hpp&quot;
 42 
 43 class CompactibleFreeListSpacePool : public CollectedMemoryPool {
 44 private:
 45   CompactibleFreeListSpace* _space;
 46 public:
 47   CompactibleFreeListSpacePool(CompactibleFreeListSpace* space,
 48                                const char* name,
 49                                size_t max_size,
 50                                bool support_usage_threshold) :
 51     CollectedMemoryPool(name, space-&gt;capacity(), max_size, support_usage_threshold),
 52     _space(space) {
 53   }
 54 
 55   MemoryUsage get_memory_usage() {
 56     size_t max_heap_size   = (available_for_allocation() ? max_size() : 0);
 57     size_t used      = used_in_bytes();
 58     size_t committed = _space-&gt;capacity();
 59 
 60     return MemoryUsage(initial_size(), used, committed, max_heap_size);
 61   }
 62 
 63   size_t used_in_bytes() {
 64     return _space-&gt;used();
 65   }
 66 };
 67 
 68 CMSHeap::CMSHeap(GenCollectorPolicy *policy) :
 69     GenCollectedHeap(policy,
 70                      Generation::ParNew,
 71                      Generation::ConcurrentMarkSweep,
 72                      &quot;ParNew:CMS&quot;),
 73     _workers(NULL),
 74     _eden_pool(NULL),
 75     _survivor_pool(NULL),
 76     _old_pool(NULL) {
 77 }
 78 
 79 jint CMSHeap::initialize() {
 80   jint status = GenCollectedHeap::initialize();
 81   if (status != JNI_OK) return status;
 82 
 83   _workers = new WorkGang(&quot;GC Thread&quot;, ParallelGCThreads,
 84                           /* are_GC_task_threads */true,
 85                           /* are_ConcurrentGC_threads */false);
 86   if (_workers == NULL) {
 87     return JNI_ENOMEM;
 88   }
 89   _workers-&gt;initialize_workers();
 90 
 91   // If we are running CMS, create the collector responsible
 92   // for collecting the CMS generations.
 93   if (!create_cms_collector()) {
 94     return JNI_ENOMEM;
 95   }
 96 
 97   return JNI_OK;
 98 }
 99 
100 CardTableRS* CMSHeap::create_rem_set(const MemRegion&amp; reserved_region) {
101   return new CMSCardTable(reserved_region);
102 }
103 
104 void CMSHeap::initialize_serviceability() {
105   _young_manager = new GCMemoryManager(&quot;ParNew&quot;, &quot;end of minor GC&quot;);
106   _old_manager = new GCMemoryManager(&quot;ConcurrentMarkSweep&quot;, &quot;end of major GC&quot;);
107 
108   ParNewGeneration* young = young_gen();
109   _eden_pool = new ContiguousSpacePool(young-&gt;eden(),
110                                        &quot;Par Eden Space&quot;,
111                                        young-&gt;max_eden_size(),
112                                        false);
113 
114   _survivor_pool = new SurvivorContiguousSpacePool(young,
115                                                    &quot;Par Survivor Space&quot;,
116                                                    young-&gt;max_survivor_size(),
117                                                    false);
118 
119   ConcurrentMarkSweepGeneration* old = (ConcurrentMarkSweepGeneration*) old_gen();
120   _old_pool = new CompactibleFreeListSpacePool(old-&gt;cmsSpace(),
121                                                &quot;CMS Old Gen&quot;,
122                                                old-&gt;reserved().byte_size(),
123                                                true);
124 
125   _young_manager-&gt;add_pool(_eden_pool);
126   _young_manager-&gt;add_pool(_survivor_pool);
127   young-&gt;set_gc_manager(_young_manager);
128 
129   _old_manager-&gt;add_pool(_eden_pool);
130   _old_manager-&gt;add_pool(_survivor_pool);
131   _old_manager-&gt;add_pool(_old_pool);
132   old -&gt;set_gc_manager(_old_manager);
133 
134 }
135 
136 CMSHeap* CMSHeap::heap() {
137   CollectedHeap* heap = Universe::heap();
138   assert(heap != NULL, &quot;Uninitialized access to CMSHeap::heap()&quot;);
139   assert(heap-&gt;kind() == CollectedHeap::CMS, &quot;Invalid name&quot;);
140   return static_cast&lt;CMSHeap*&gt;(heap);
141 }
142 
143 void CMSHeap::gc_threads_do(ThreadClosure* tc) const {
144   assert(workers() != NULL, &quot;should have workers here&quot;);
145   workers()-&gt;threads_do(tc);
146   ConcurrentMarkSweepThread::threads_do(tc);
147 }
148 
149 void CMSHeap::print_gc_threads_on(outputStream* st) const {
150   assert(workers() != NULL, &quot;should have workers here&quot;);
151   workers()-&gt;print_worker_threads_on(st);
152   ConcurrentMarkSweepThread::print_all_on(st);
153 }
154 
155 void CMSHeap::print_on_error(outputStream* st) const {
156   GenCollectedHeap::print_on_error(st);
157   st-&gt;cr();
158   CMSCollector::print_on_error(st);
159 }
160 
161 bool CMSHeap::create_cms_collector() {
162   assert(old_gen()-&gt;kind() == Generation::ConcurrentMarkSweep,
163          &quot;Unexpected generation kinds&quot;);
164   CMSCollector* collector =
165     new CMSCollector((ConcurrentMarkSweepGeneration*) old_gen(),
166                      rem_set(),
167                      (ConcurrentMarkSweepPolicy*) gen_policy());
168 
169   if (collector == NULL || !collector-&gt;completed_initialization()) {
170     if (collector) {
171       delete collector; // Be nice in embedded situation
172     }
173     vm_shutdown_during_initialization(&quot;Could not create CMS collector&quot;);
174     return false;
175   }
176   return true; // success
177 }
178 
179 void CMSHeap::collect(GCCause::Cause cause) {
180   if (should_do_concurrent_full_gc(cause)) {
181     // Mostly concurrent full collection.
182     collect_mostly_concurrent(cause);
183   } else {
184     GenCollectedHeap::collect(cause);
185   }
186 }
187 
188 bool CMSHeap::should_do_concurrent_full_gc(GCCause::Cause cause) {
189   switch (cause) {
190     case GCCause::_gc_locker:           return GCLockerInvokesConcurrent;
191     case GCCause::_java_lang_system_gc:
192     case GCCause::_dcmd_gc_run:         return ExplicitGCInvokesConcurrent;
193     default:                            return false;
194   }
195 }
196 
197 void CMSHeap::collect_mostly_concurrent(GCCause::Cause cause) {
198   assert(!Heap_lock-&gt;owned_by_self(), &quot;Should not own Heap_lock&quot;);
199 
200   MutexLocker ml(Heap_lock);
201   // Read the GC counts while holding the Heap_lock
202   unsigned int full_gc_count_before = total_full_collections();
203   unsigned int gc_count_before      = total_collections();
204   {
205     MutexUnlocker mu(Heap_lock);
206     VM_GenCollectFullConcurrent op(gc_count_before, full_gc_count_before, cause);
207     VMThread::execute(&amp;op);
208   }
209 }
210 
211 void CMSHeap::stop() {
212   ConcurrentMarkSweepThread::cmst()-&gt;stop();
213 }
214 
215 void CMSHeap::safepoint_synchronize_begin() {
216   ConcurrentMarkSweepThread::synchronize(false);
217 }
218 
219 void CMSHeap::safepoint_synchronize_end() {
220   ConcurrentMarkSweepThread::desynchronize(false);
221 }
222 
223 void CMSHeap::cms_process_roots(StrongRootsScope* scope,
224                                 bool young_gen_as_roots,
225                                 ScanningOption so,
226                                 bool only_strong_roots,
227                                 OopsInGenClosure* root_closure,
228                                 CLDClosure* cld_closure) {
229   MarkingCodeBlobClosure mark_code_closure(root_closure, !CodeBlobToOopClosure::FixRelocations);
230   CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;
231 
232   process_roots(scope, so, root_closure, cld_closure, weak_cld_closure, &amp;mark_code_closure);
233 
234   if (young_gen_as_roots &amp;&amp;
235       _process_strong_tasks-&gt;try_claim_task(GCH_PS_younger_gens)) {
236     root_closure-&gt;set_generation(young_gen());
237     young_gen()-&gt;oop_iterate(root_closure);
238     root_closure-&gt;reset_generation();
239   }
240 
241   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
242 }
243 
244 void CMSHeap::gc_prologue(bool full) {
245   always_do_update_barrier = false;
246   GenCollectedHeap::gc_prologue(full);
247 };
248 
249 void CMSHeap::gc_epilogue(bool full) {
250   GenCollectedHeap::gc_epilogue(full);
251   always_do_update_barrier = true;
252 };
253 
254 GrowableArray&lt;GCMemoryManager*&gt; CMSHeap::memory_managers() {
255   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
256   memory_managers.append(_young_manager);
257   memory_managers.append(_old_manager);
258   return memory_managers;
259 }
260 
261 GrowableArray&lt;MemoryPool*&gt; CMSHeap::memory_pools() {
262   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
263   memory_pools.append(_eden_pool);
264   memory_pools.append(_survivor_pool);
265   memory_pools.append(_old_pool);
266   return memory_pools;
267 }
    </pre>
  </body>
</html>
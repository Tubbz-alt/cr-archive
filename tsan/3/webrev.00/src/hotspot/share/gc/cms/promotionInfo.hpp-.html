<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/cms/promotionInfo.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_CMS_PROMOTIONINFO_HPP
 26 #define SHARE_GC_CMS_PROMOTIONINFO_HPP
 27 
 28 #include &quot;gc/cms/freeChunk.hpp&quot;
 29 
 30 // Forward declarations
 31 class CompactibleFreeListSpace;
 32 
 33 class PromotedObject {
 34  private:
 35   enum {
 36     promoted_mask  = right_n_bits(2),   // i.e. 0x3
 37     displaced_mark = nth_bit(2),        // i.e. 0x4
 38     next_mask      = ~(right_n_bits(3)) // i.e. ~(0x7)
 39   };
 40 
 41   // Below, we want _narrow_next in the &quot;higher&quot; 32 bit slot,
 42   // whose position will depend on endian-ness of the platform.
 43   // This is so that there is no interference with the
 44   // cms_free_bit occupying bit position 7 (lsb == 0)
 45   // when we are using compressed oops; see FreeChunk::is_free().
 46   // We cannot move the cms_free_bit down because currently
 47   // biased locking code assumes that age bits are contiguous
 48   // with the lock bits. Even if that assumption were relaxed,
 49   // the least position we could move this bit to would be
 50   // to bit position 3, which would require 16 byte alignment.
 51   typedef struct {
 52 #ifdef VM_LITTLE_ENDIAN
 53     LP64_ONLY(narrowOop _pad;)
 54               narrowOop _narrow_next;
 55 #else
 56               narrowOop _narrow_next;
 57     LP64_ONLY(narrowOop _pad;)
 58 #endif
 59   } Data;
 60 
 61   union {
 62     intptr_t _next;
 63     Data     _data;
 64   };
 65  public:
 66   PromotedObject* next() const;
 67   void setNext(PromotedObject* x);
 68   inline void setPromotedMark() {
 69     _next |= promoted_mask;
 70     assert(!((FreeChunk*)this)-&gt;is_free(), &quot;Error&quot;);
 71   }
 72   inline bool hasPromotedMark() const {
 73     assert(!((FreeChunk*)this)-&gt;is_free(), &quot;Error&quot;);
 74     return (_next &amp; promoted_mask) == promoted_mask;
 75   }
 76   inline void setDisplacedMark() {
 77     _next |= displaced_mark;
 78     assert(!((FreeChunk*)this)-&gt;is_free(), &quot;Error&quot;);
 79   }
 80   inline bool hasDisplacedMark() const {
 81     assert(!((FreeChunk*)this)-&gt;is_free(), &quot;Error&quot;);
 82     return (_next &amp; displaced_mark) != 0;
 83   }
 84   inline void clear_next()        {
 85     _next = 0;
 86     assert(!((FreeChunk*)this)-&gt;is_free(), &quot;Error&quot;);
 87   }
 88   debug_only(void *next_addr() { return (void *) &amp;_next; })
 89 };
 90 
 91 class SpoolBlock: public FreeChunk {
 92   friend class PromotionInfo;
 93  protected:
 94   SpoolBlock*  nextSpoolBlock;
 95   size_t       bufferSize;        // number of usable words in this block
 96   markOop*     displacedHdr;      // the displaced headers start here
 97 
 98   // Note about bufferSize: it denotes the number of entries available plus 1;
 99   // legal indices range from 1 through BufferSize - 1.  See the verification
100   // code verify() that counts the number of displaced headers spooled.
101   size_t computeBufferSize() {
102     return (size() * sizeof(HeapWord) - sizeof(*this)) / sizeof(markOop);
103   }
104 
105  public:
106   void init() {
107     bufferSize = computeBufferSize();
108     displacedHdr = (markOop*)&amp;displacedHdr;
109     nextSpoolBlock = NULL;
110   }
111 
112   void print_on(outputStream* st) const;
113   void print() const { print_on(tty); }
114 };
115 
116 class PromotionInfo {
117   bool            _tracking;      // set if tracking
118   CompactibleFreeListSpace* _space; // the space to which this belongs
119   PromotedObject* _promoHead;     // head of list of promoted objects
120   PromotedObject* _promoTail;     // tail of list of promoted objects
121   SpoolBlock*     _spoolHead;     // first spooling block
122   SpoolBlock*     _spoolTail;     // last  non-full spooling block or null
123   SpoolBlock*     _splice_point;  // when _spoolTail is null, holds list tail
124   SpoolBlock*     _spareSpool;    // free spool buffer
125   size_t          _firstIndex;    // first active index in
126                                   // first spooling block (_spoolHead)
127   size_t          _nextIndex;     // last active index + 1 in last
128                                   // spooling block (_spoolTail)
129  private:
130   // ensure that spooling space exists; return true if there is spooling space
131   bool ensure_spooling_space_work();
132 
133  public:
134   PromotionInfo() :
135     _tracking(0), _space(NULL),
136     _promoHead(NULL), _promoTail(NULL),
137     _spoolHead(NULL), _spoolTail(NULL),
138     _spareSpool(NULL), _firstIndex(1),
139     _nextIndex(1) {}
140 
141   bool noPromotions() const {
142     assert(_promoHead != NULL || _promoTail == NULL, &quot;list inconsistency&quot;);
143     return _promoHead == NULL;
144   }
145   void startTrackingPromotions();
146   void stopTrackingPromotions();
147   bool tracking() const          { return _tracking;  }
148   void track(PromotedObject* trackOop);      // keep track of a promoted oop
149   // The following variant must be used when trackOop is not fully
150   // initialized and has a NULL klass:
151   void track(PromotedObject* trackOop, Klass* klassOfOop); // keep track of a promoted oop
152   void setSpace(CompactibleFreeListSpace* sp) { _space = sp; }
153   CompactibleFreeListSpace* space() const     { return _space; }
154   markOop nextDisplacedHeader(); // get next header &amp; forward spool pointer
155   void    saveDisplacedHeader(markOop hdr);
156                                  // save header and forward spool
157 
158   inline size_t refillSize() const;
159 
160   SpoolBlock* getSpoolBlock();   // return a free spooling block
161   inline bool has_spooling_space() {
162     return _spoolTail != NULL &amp;&amp; _spoolTail-&gt;bufferSize &gt; _nextIndex;
163   }
164   // ensure that spooling space exists
165   bool ensure_spooling_space() {
166     return has_spooling_space() || ensure_spooling_space_work();
167   }
168 
169   template &lt;typename OopClosureType&gt;
170   void promoted_oops_iterate(OopClosureType* cl);
171 
172   void verify()  const;
173   void reset() {
174     _promoHead = NULL;
175     _promoTail = NULL;
176     _spoolHead = NULL;
177     _spoolTail = NULL;
178     _spareSpool = NULL;
179     _firstIndex = 0;
180     _nextIndex = 0;
181 
182   }
183 
184   void print_on(outputStream* st) const;
185 };
186 
187 
188 #endif // SHARE_GC_CMS_PROMOTIONINFO_HPP
    </pre>
  </body>
</html>
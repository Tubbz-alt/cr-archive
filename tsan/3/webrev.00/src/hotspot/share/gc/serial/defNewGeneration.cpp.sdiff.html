<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/serial/defNewGeneration.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cSpaceCounters.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="defNewGeneration.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/serial/defNewGeneration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/serial/defNewGeneration.inline.hpp&quot;
  27 #include &quot;gc/serial/serialHeap.inline.hpp&quot;
  28 #include &quot;gc/serial/tenuredGeneration.hpp&quot;
  29 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  30 #include &quot;gc/shared/ageTable.inline.hpp&quot;
  31 #include &quot;gc/shared/cardTableRS.hpp&quot;
  32 #include &quot;gc/shared/collectorCounters.hpp&quot;

  33 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  34 #include &quot;gc/shared/gcLocker.hpp&quot;
  35 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  36 #include &quot;gc/shared/gcTimer.hpp&quot;
  37 #include &quot;gc/shared/gcTrace.hpp&quot;
  38 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  39 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  40 #include &quot;gc/shared/generationSpec.hpp&quot;
  41 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  42 #include &quot;gc/shared/referencePolicy.hpp&quot;
  43 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  44 #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">  45 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
  46 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  47 #include &quot;gc/shared/weakProcessor.hpp&quot;
  48 #include &quot;logging/log.hpp&quot;
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;oops/instanceRefKlass.hpp&quot;
  52 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">  53 #include &quot;runtime/atomic.hpp&quot;</span>
  54 #include &quot;runtime/java.hpp&quot;
  55 #include &quot;runtime/prefetch.inline.hpp&quot;
  56 #include &quot;runtime/thread.inline.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/copy.hpp&quot;
  59 #include &quot;utilities/globalDefinitions.hpp&quot;
  60 #include &quot;utilities/stack.inline.hpp&quot;
  61 
  62 //
  63 // DefNewGeneration functions.
  64 
  65 // Methods of protected closure types.
  66 
  67 DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {
<span class="line-modified">  68   assert(_young_gen-&gt;kind() == Generation::ParNew ||</span>
<span class="line-removed">  69          _young_gen-&gt;kind() == Generation::DefNew, &quot;Expected the young generation here&quot;);</span>
  70 }
  71 
  72 bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {
<span class="line-modified">  73   return (HeapWord*)p &gt;= _young_gen-&gt;reserved().end() || p-&gt;is_forwarded();</span>
  74 }
  75 
  76 DefNewGeneration::KeepAliveClosure::
  77 KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {
  78   _rs = GenCollectedHeap::heap()-&gt;rem_set();
  79 }
  80 
  81 void DefNewGeneration::KeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }
  82 void DefNewGeneration::KeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }
  83 
  84 
  85 DefNewGeneration::FastKeepAliveClosure::
  86 FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :
  87   DefNewGeneration::KeepAliveClosure(cl) {
  88   _boundary = g-&gt;reserved().end();
  89 }
  90 
  91 void DefNewGeneration::FastKeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }
  92 void DefNewGeneration::FastKeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }
  93 
</pre>
<hr />
<pre>
 134 
 135     // Tell the closure which CLD is being scanned so that it can be dirtied
 136     // if oops are left pointing into the young gen.
 137     _scavenge_closure-&gt;set_scanned_cld(cld);
 138 
 139     // Clean the cld since we&#39;re going to scavenge all the metadata.
 140     cld-&gt;oops_do(_scavenge_closure, ClassLoaderData::_claim_none, /*clear_modified_oops*/true);
 141 
 142     _scavenge_closure-&gt;set_scanned_cld(NULL);
 143   }
 144 }
 145 
 146 ScanWeakRefClosure::ScanWeakRefClosure(DefNewGeneration* g) :
 147   _g(g)
 148 {
 149   _boundary = _g-&gt;reserved().end();
 150 }
 151 
 152 DefNewGeneration::DefNewGeneration(ReservedSpace rs,
 153                                    size_t initial_size,


 154                                    const char* policy)
 155   : Generation(rs, initial_size),
 156     _preserved_marks_set(false /* in_c_heap */),
 157     _promo_failure_drain_in_progress(false),
 158     _should_allocate_from_space(false)
 159 {
 160   MemRegion cmr((HeapWord*)_virtual_space.low(),
 161                 (HeapWord*)_virtual_space.high());
 162   GenCollectedHeap* gch = GenCollectedHeap::heap();
 163 
 164   gch-&gt;rem_set()-&gt;resize_covered_region(cmr);
 165 
 166   _eden_space = new ContiguousSpace();
 167   _from_space = new ContiguousSpace();
 168   _to_space   = new ContiguousSpace();
 169 
<span class="line-removed"> 170   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {</span>
<span class="line-removed"> 171     vm_exit_during_initialization(&quot;Could not allocate a new gen space&quot;);</span>
<span class="line-removed"> 172   }</span>
<span class="line-removed"> 173 </span>
 174   // Compute the maximum eden and survivor space sizes. These sizes
 175   // are computed assuming the entire reserved space is committed.
 176   // These values are exported as performance counters.
<span class="line-removed"> 177   uintx alignment = gch-&gt;collector_policy()-&gt;space_alignment();</span>
 178   uintx size = _virtual_space.reserved_size();
<span class="line-modified"> 179   _max_survivor_size = compute_survivor_size(size, alignment);</span>
 180   _max_eden_size = size - (2*_max_survivor_size);
 181 
 182   // allocate the performance counters
<span class="line-removed"> 183   GenCollectorPolicy* gcp = gch-&gt;gen_policy();</span>
 184 
 185   // Generation counters -- generation 0, 3 subspaces
 186   _gen_counters = new GenerationCounters(&quot;new&quot;, 0, 3,
<span class="line-modified"> 187       gcp-&gt;min_young_size(), gcp-&gt;max_young_size(), &amp;_virtual_space);</span>
 188   _gc_counters = new CollectorCounters(policy, 0);
 189 
 190   _eden_counters = new CSpaceCounters(&quot;eden&quot;, 0, _max_eden_size, _eden_space,
 191                                       _gen_counters);
 192   _from_counters = new CSpaceCounters(&quot;s0&quot;, 1, _max_survivor_size, _from_space,
 193                                       _gen_counters);
 194   _to_counters = new CSpaceCounters(&quot;s1&quot;, 2, _max_survivor_size, _to_space,
 195                                     _gen_counters);
 196 
 197   compute_space_boundaries(0, SpaceDecorator::Clear, SpaceDecorator::Mangle);
 198   update_counters();
 199   _old_gen = NULL;
 200   _tenuring_threshold = MaxTenuringThreshold;
 201   _pretenure_size_threshold_words = PretenureSizeThreshold &gt;&gt; LogHeapWordSize;
 202 
 203   _gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
 204 }
 205 
 206 void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,
 207                                                 bool clear_space,
 208                                                 bool mangle_space) {
<span class="line-removed"> 209   uintx alignment =</span>
<span class="line-removed"> 210     GenCollectedHeap::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
<span class="line-removed"> 211 </span>
 212   // If the spaces are being cleared (only done at heap initialization
 213   // currently), the survivor spaces need not be empty.
 214   // Otherwise, no care is taken for used areas in the survivor spaces
 215   // so check.
 216   assert(clear_space || (to()-&gt;is_empty() &amp;&amp; from()-&gt;is_empty()),
 217     &quot;Initialization of the survivor spaces assumes these are empty&quot;);
 218 
 219   // Compute sizes
 220   uintx size = _virtual_space.committed_size();
<span class="line-modified"> 221   uintx survivor_size = compute_survivor_size(size, alignment);</span>
 222   uintx eden_size = size - (2*survivor_size);
 223   assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
 224 
 225   if (eden_size &lt; minimum_eden_size) {
 226     // May happen due to 64Kb rounding, if so adjust eden size back up
<span class="line-modified"> 227     minimum_eden_size = align_up(minimum_eden_size, alignment);</span>
 228     uintx maximum_survivor_size = (size - minimum_eden_size) / 2;
 229     uintx unaligned_survivor_size =
<span class="line-modified"> 230       align_down(maximum_survivor_size, alignment);</span>
<span class="line-modified"> 231     survivor_size = MAX2(unaligned_survivor_size, alignment);</span>
 232     eden_size = size - (2*survivor_size);
 233     assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
 234     assert(eden_size &gt;= minimum_eden_size, &quot;just checking&quot;);
 235   }
 236 
 237   char *eden_start = _virtual_space.low();
 238   char *from_start = eden_start + eden_size;
 239   char *to_start   = from_start + survivor_size;
 240   char *to_end     = to_start   + survivor_size;
 241 
 242   assert(to_end == _virtual_space.high(), &quot;just checking&quot;);
 243   assert(Space::is_aligned(eden_start), &quot;checking alignment&quot;);
 244   assert(Space::is_aligned(from_start), &quot;checking alignment&quot;);
 245   assert(Space::is_aligned(to_start),   &quot;checking alignment&quot;);
 246 
 247   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)from_start);
 248   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)to_start);
 249   MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)to_end);
 250 
 251   // A minimum eden size implies that there is a part of eden that
</pre>
<hr />
<pre>
 378 
 379   size_t old_size = gch-&gt;old_gen()-&gt;capacity();
 380   size_t new_size_before = _virtual_space.committed_size();
 381   size_t min_new_size = initial_size();
 382   size_t max_new_size = reserved().byte_size();
 383   assert(min_new_size &lt;= new_size_before &amp;&amp;
 384          new_size_before &lt;= max_new_size,
 385          &quot;just checking&quot;);
 386   // All space sizes must be multiples of Generation::GenGrain.
 387   size_t alignment = Generation::GenGrain;
 388 
 389   int threads_count = 0;
 390   size_t thread_increase_size = 0;
 391 
 392   size_t new_size_candidate = old_size / NewRatio;
 393   // Compute desired new generation size based on NewRatio and NewSizeThreadIncrease
 394   // and reverts to previous value if any overflow happens
 395   size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before, alignment);
 396 
 397   // Adjust new generation size
<span class="line-modified"> 398   desired_new_size = MAX2(MIN2(desired_new_size, max_new_size), min_new_size);</span>
 399   assert(desired_new_size &lt;= max_new_size, &quot;just checking&quot;);
 400 
 401   bool changed = false;
 402   if (desired_new_size &gt; new_size_before) {
 403     size_t change = desired_new_size - new_size_before;
 404     assert(change % alignment == 0, &quot;just checking&quot;);
 405     if (expand(change)) {
 406        changed = true;
 407     }
 408     // If the heap failed to expand to the desired size,
 409     // &quot;changed&quot; will be false.  If the expansion failed
 410     // (and at this point it was expected to succeed),
 411     // ignore the failure (leaving &quot;changed&quot; as false).
 412   }
 413   if (desired_new_size &lt; new_size_before &amp;&amp; eden()-&gt;is_empty()) {
 414     // bail out of shrinking if objects in eden
 415     size_t change = new_size_before - desired_new_size;
 416     assert(change % alignment == 0, &quot;just checking&quot;);
 417     _virtual_space.shrink_by(change);
 418     changed = true;
</pre>
<hr />
<pre>
 444 
 445 
 446 size_t DefNewGeneration::capacity() const {
 447   return eden()-&gt;capacity()
 448        + from()-&gt;capacity();  // to() is only used during scavenge
 449 }
 450 
 451 
 452 size_t DefNewGeneration::used() const {
 453   return eden()-&gt;used()
 454        + from()-&gt;used();      // to() is only used during scavenge
 455 }
 456 
 457 
 458 size_t DefNewGeneration::free() const {
 459   return eden()-&gt;free()
 460        + from()-&gt;free();      // to() is only used during scavenge
 461 }
 462 
 463 size_t DefNewGeneration::max_capacity() const {
<span class="line-removed"> 464   const size_t alignment = GenCollectedHeap::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
 465   const size_t reserved_bytes = reserved().byte_size();
<span class="line-modified"> 466   return reserved_bytes - compute_survivor_size(reserved_bytes, alignment);</span>
 467 }
 468 
 469 size_t DefNewGeneration::unsafe_max_alloc_nogc() const {
 470   return eden()-&gt;free();
 471 }
 472 
 473 size_t DefNewGeneration::capacity_before_gc() const {
 474   return eden()-&gt;capacity();
 475 }
 476 
 477 size_t DefNewGeneration::contiguous_available() const {
 478   return eden()-&gt;free();
 479 }
 480 
 481 
 482 HeapWord* volatile* DefNewGeneration::top_addr() const { return eden()-&gt;top_addr(); }
 483 HeapWord** DefNewGeneration::end_addr() const { return eden()-&gt;end_addr(); }
 484 
 485 void DefNewGeneration::object_iterate(ObjectClosure* blk) {
 486   eden()-&gt;object_iterate(blk);
</pre>
<hr />
<pre>
 699 
 700   _gc_timer-&gt;register_gc_end();
 701 
 702   gc_tracer.report_gc_end(_gc_timer-&gt;gc_end(), _gc_timer-&gt;time_partitions());
 703 }
 704 
 705 void DefNewGeneration::init_assuming_no_promotion_failure() {
 706   _promotion_failed = false;
 707   _promotion_failed_info.reset();
 708   from()-&gt;set_next_compaction_space(NULL);
 709 }
 710 
 711 void DefNewGeneration::remove_forwarding_pointers() {
 712   RemoveForwardedPointerClosure rspc;
 713   eden()-&gt;object_iterate(&amp;rspc);
 714   from()-&gt;object_iterate(&amp;rspc);
 715   restore_preserved_marks();
 716 }
 717 
 718 void DefNewGeneration::restore_preserved_marks() {
<span class="line-modified"> 719   SharedRestorePreservedMarksTaskExecutor task_executor(NULL);</span>
<span class="line-removed"> 720   _preserved_marks_set.restore(&amp;task_executor);</span>
 721 }
 722 
 723 void DefNewGeneration::handle_promotion_failure(oop old) {
 724   log_debug(gc, promotion)(&quot;Promotion failure size = %d) &quot;, old-&gt;size());
 725 
 726   _promotion_failed = true;
 727   _promotion_failed_info.register_copy_failure(old-&gt;size());
 728   _preserved_marks_set.get()-&gt;push_if_necessary(old, old-&gt;mark_raw());
 729   // forward to self
 730   old-&gt;forward_to(old);
 731 
 732   _promo_failure_scan_stack.push(old);
 733 
 734   if (!_promo_failure_drain_in_progress) {
 735     // prevent recursion in copy_to_survivor_space()
 736     _promo_failure_drain_in_progress = true;
 737     drain_promo_failure_scan_stack();
 738     _promo_failure_drain_in_progress = false;
 739   }
 740 }
</pre>
<hr />
<pre>
 746   oop obj = NULL;
 747 
 748   // Try allocating obj in to-space (unless too old)
 749   if (old-&gt;age() &lt; tenuring_threshold()) {
 750     obj = (oop) to()-&gt;allocate_aligned(s);
 751   }
 752 
 753   // Otherwise try allocating obj tenured
 754   if (obj == NULL) {
 755     obj = _old_gen-&gt;promote(old, s);
 756     if (obj == NULL) {
 757       handle_promotion_failure(old);
 758       return old;
 759     }
 760   } else {
 761     // Prefetch beyond obj
 762     const intx interval = PrefetchCopyIntervalInBytes;
 763     Prefetch::write(obj, interval);
 764 
 765     // Copy obj
<span class="line-modified"> 766     Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)obj, s);</span>
 767 
 768     // Increment age if obj still in new generation
 769     obj-&gt;incr_age();
 770     age_table()-&gt;add(obj, s);
 771   }
 772 
 773   // Done, insert forward pointer to obj in this header
 774   old-&gt;forward_to(obj);
 775 
 776   return obj;
 777 }
 778 
 779 void DefNewGeneration::drain_promo_failure_scan_stack() {
 780   while (!_promo_failure_scan_stack.is_empty()) {
 781      oop obj = _promo_failure_scan_stack.pop();
 782      obj-&gt;oop_iterate(_promo_failure_scan_stack_closure);
 783   }
 784 }
 785 
 786 void DefNewGeneration::save_marks() {
</pre>
<hr />
<pre>
 870       gch-&gt;clear_incremental_collection_failed(); // We just did a full collection
 871       clear_should_allocate_from_space(); // if set
 872     }
 873   } else {
 874 #ifdef ASSERT
 875     // It is possible that incremental_collection_failed() == true
 876     // here, because an attempted scavenge did not succeed. The policy
 877     // is normally expected to cause a full collection which should
 878     // clear that condition, so we should not be here twice in a row
 879     // with incremental_collection_failed() == true without having done
 880     // a full collection in between.
 881     if (!seen_incremental_collection_failed &amp;&amp;
 882         gch-&gt;incremental_collection_failed()) {
 883       log_trace(gc)(&quot;DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed&quot;,
 884                             GCCause::to_string(gch-&gt;gc_cause()));
 885       seen_incremental_collection_failed = true;
 886     } else if (seen_incremental_collection_failed) {
 887       log_trace(gc)(&quot;DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed&quot;,
 888                             GCCause::to_string(gch-&gt;gc_cause()));
 889       assert(gch-&gt;gc_cause() == GCCause::_scavenge_alot ||
<span class="line-removed"> 890              (GCCause::is_user_requested_gc(gch-&gt;gc_cause()) &amp;&amp; UseConcMarkSweepGC &amp;&amp; ExplicitGCInvokesConcurrent) ||</span>
 891              !gch-&gt;incremental_collection_failed(),
 892              &quot;Twice in a row&quot;);
 893       seen_incremental_collection_failed = false;
 894     }
 895 #endif // ASSERT
 896   }
 897 
 898   if (ZapUnusedHeapArea) {
 899     eden()-&gt;check_mangled_unused_area_complete();
 900     from()-&gt;check_mangled_unused_area_complete();
 901     to()-&gt;check_mangled_unused_area_complete();
 902   }
 903 
 904   if (!CleanChunkPoolAsync) {
 905     Chunk::clean_chunk_pool();
 906   }
 907 
 908   // update the generation and space performance counters
 909   update_counters();
 910   gch-&gt;counters()-&gt;update_counters();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/serial/defNewGeneration.inline.hpp&quot;
  27 #include &quot;gc/serial/serialHeap.inline.hpp&quot;
  28 #include &quot;gc/serial/tenuredGeneration.hpp&quot;
  29 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  30 #include &quot;gc/shared/ageTable.inline.hpp&quot;
  31 #include &quot;gc/shared/cardTableRS.hpp&quot;
  32 #include &quot;gc/shared/collectorCounters.hpp&quot;
<span class="line-added">  33 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  34 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  35 #include &quot;gc/shared/gcLocker.hpp&quot;
  36 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  37 #include &quot;gc/shared/gcTimer.hpp&quot;
  38 #include &quot;gc/shared/gcTrace.hpp&quot;
  39 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  40 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  41 #include &quot;gc/shared/generationSpec.hpp&quot;
  42 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  43 #include &quot;gc/shared/referencePolicy.hpp&quot;
  44 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  45 #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">  46 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
  47 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  48 #include &quot;gc/shared/weakProcessor.hpp&quot;
  49 #include &quot;logging/log.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;oops/instanceRefKlass.hpp&quot;
  53 #include &quot;oops/oop.inline.hpp&quot;

  54 #include &quot;runtime/java.hpp&quot;
  55 #include &quot;runtime/prefetch.inline.hpp&quot;
  56 #include &quot;runtime/thread.inline.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/copy.hpp&quot;
  59 #include &quot;utilities/globalDefinitions.hpp&quot;
  60 #include &quot;utilities/stack.inline.hpp&quot;
  61 
  62 //
  63 // DefNewGeneration functions.
  64 
  65 // Methods of protected closure types.
  66 
  67 DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {
<span class="line-modified">  68   assert(_young_gen-&gt;kind() == Generation::DefNew, &quot;Expected the young generation here&quot;);</span>

  69 }
  70 
  71 bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {
<span class="line-modified">  72   return cast_from_oop&lt;HeapWord*&gt;(p) &gt;= _young_gen-&gt;reserved().end() || p-&gt;is_forwarded();</span>
  73 }
  74 
  75 DefNewGeneration::KeepAliveClosure::
  76 KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {
  77   _rs = GenCollectedHeap::heap()-&gt;rem_set();
  78 }
  79 
  80 void DefNewGeneration::KeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }
  81 void DefNewGeneration::KeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }
  82 
  83 
  84 DefNewGeneration::FastKeepAliveClosure::
  85 FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :
  86   DefNewGeneration::KeepAliveClosure(cl) {
  87   _boundary = g-&gt;reserved().end();
  88 }
  89 
  90 void DefNewGeneration::FastKeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }
  91 void DefNewGeneration::FastKeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }
  92 
</pre>
<hr />
<pre>
 133 
 134     // Tell the closure which CLD is being scanned so that it can be dirtied
 135     // if oops are left pointing into the young gen.
 136     _scavenge_closure-&gt;set_scanned_cld(cld);
 137 
 138     // Clean the cld since we&#39;re going to scavenge all the metadata.
 139     cld-&gt;oops_do(_scavenge_closure, ClassLoaderData::_claim_none, /*clear_modified_oops*/true);
 140 
 141     _scavenge_closure-&gt;set_scanned_cld(NULL);
 142   }
 143 }
 144 
 145 ScanWeakRefClosure::ScanWeakRefClosure(DefNewGeneration* g) :
 146   _g(g)
 147 {
 148   _boundary = _g-&gt;reserved().end();
 149 }
 150 
 151 DefNewGeneration::DefNewGeneration(ReservedSpace rs,
 152                                    size_t initial_size,
<span class="line-added"> 153                                    size_t min_size,</span>
<span class="line-added"> 154                                    size_t max_size,</span>
 155                                    const char* policy)
 156   : Generation(rs, initial_size),
 157     _preserved_marks_set(false /* in_c_heap */),
 158     _promo_failure_drain_in_progress(false),
 159     _should_allocate_from_space(false)
 160 {
 161   MemRegion cmr((HeapWord*)_virtual_space.low(),
 162                 (HeapWord*)_virtual_space.high());
 163   GenCollectedHeap* gch = GenCollectedHeap::heap();
 164 
 165   gch-&gt;rem_set()-&gt;resize_covered_region(cmr);
 166 
 167   _eden_space = new ContiguousSpace();
 168   _from_space = new ContiguousSpace();
 169   _to_space   = new ContiguousSpace();
 170 




 171   // Compute the maximum eden and survivor space sizes. These sizes
 172   // are computed assuming the entire reserved space is committed.
 173   // These values are exported as performance counters.

 174   uintx size = _virtual_space.reserved_size();
<span class="line-modified"> 175   _max_survivor_size = compute_survivor_size(size, SpaceAlignment);</span>
 176   _max_eden_size = size - (2*_max_survivor_size);
 177 
 178   // allocate the performance counters

 179 
 180   // Generation counters -- generation 0, 3 subspaces
 181   _gen_counters = new GenerationCounters(&quot;new&quot;, 0, 3,
<span class="line-modified"> 182       min_size, max_size, &amp;_virtual_space);</span>
 183   _gc_counters = new CollectorCounters(policy, 0);
 184 
 185   _eden_counters = new CSpaceCounters(&quot;eden&quot;, 0, _max_eden_size, _eden_space,
 186                                       _gen_counters);
 187   _from_counters = new CSpaceCounters(&quot;s0&quot;, 1, _max_survivor_size, _from_space,
 188                                       _gen_counters);
 189   _to_counters = new CSpaceCounters(&quot;s1&quot;, 2, _max_survivor_size, _to_space,
 190                                     _gen_counters);
 191 
 192   compute_space_boundaries(0, SpaceDecorator::Clear, SpaceDecorator::Mangle);
 193   update_counters();
 194   _old_gen = NULL;
 195   _tenuring_threshold = MaxTenuringThreshold;
 196   _pretenure_size_threshold_words = PretenureSizeThreshold &gt;&gt; LogHeapWordSize;
 197 
 198   _gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
 199 }
 200 
 201 void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,
 202                                                 bool clear_space,
 203                                                 bool mangle_space) {



 204   // If the spaces are being cleared (only done at heap initialization
 205   // currently), the survivor spaces need not be empty.
 206   // Otherwise, no care is taken for used areas in the survivor spaces
 207   // so check.
 208   assert(clear_space || (to()-&gt;is_empty() &amp;&amp; from()-&gt;is_empty()),
 209     &quot;Initialization of the survivor spaces assumes these are empty&quot;);
 210 
 211   // Compute sizes
 212   uintx size = _virtual_space.committed_size();
<span class="line-modified"> 213   uintx survivor_size = compute_survivor_size(size, SpaceAlignment);</span>
 214   uintx eden_size = size - (2*survivor_size);
 215   assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
 216 
 217   if (eden_size &lt; minimum_eden_size) {
 218     // May happen due to 64Kb rounding, if so adjust eden size back up
<span class="line-modified"> 219     minimum_eden_size = align_up(minimum_eden_size, SpaceAlignment);</span>
 220     uintx maximum_survivor_size = (size - minimum_eden_size) / 2;
 221     uintx unaligned_survivor_size =
<span class="line-modified"> 222       align_down(maximum_survivor_size, SpaceAlignment);</span>
<span class="line-modified"> 223     survivor_size = MAX2(unaligned_survivor_size, SpaceAlignment);</span>
 224     eden_size = size - (2*survivor_size);
 225     assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
 226     assert(eden_size &gt;= minimum_eden_size, &quot;just checking&quot;);
 227   }
 228 
 229   char *eden_start = _virtual_space.low();
 230   char *from_start = eden_start + eden_size;
 231   char *to_start   = from_start + survivor_size;
 232   char *to_end     = to_start   + survivor_size;
 233 
 234   assert(to_end == _virtual_space.high(), &quot;just checking&quot;);
 235   assert(Space::is_aligned(eden_start), &quot;checking alignment&quot;);
 236   assert(Space::is_aligned(from_start), &quot;checking alignment&quot;);
 237   assert(Space::is_aligned(to_start),   &quot;checking alignment&quot;);
 238 
 239   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)from_start);
 240   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)to_start);
 241   MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)to_end);
 242 
 243   // A minimum eden size implies that there is a part of eden that
</pre>
<hr />
<pre>
 370 
 371   size_t old_size = gch-&gt;old_gen()-&gt;capacity();
 372   size_t new_size_before = _virtual_space.committed_size();
 373   size_t min_new_size = initial_size();
 374   size_t max_new_size = reserved().byte_size();
 375   assert(min_new_size &lt;= new_size_before &amp;&amp;
 376          new_size_before &lt;= max_new_size,
 377          &quot;just checking&quot;);
 378   // All space sizes must be multiples of Generation::GenGrain.
 379   size_t alignment = Generation::GenGrain;
 380 
 381   int threads_count = 0;
 382   size_t thread_increase_size = 0;
 383 
 384   size_t new_size_candidate = old_size / NewRatio;
 385   // Compute desired new generation size based on NewRatio and NewSizeThreadIncrease
 386   // and reverts to previous value if any overflow happens
 387   size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before, alignment);
 388 
 389   // Adjust new generation size
<span class="line-modified"> 390   desired_new_size = clamp(desired_new_size, min_new_size, max_new_size);</span>
 391   assert(desired_new_size &lt;= max_new_size, &quot;just checking&quot;);
 392 
 393   bool changed = false;
 394   if (desired_new_size &gt; new_size_before) {
 395     size_t change = desired_new_size - new_size_before;
 396     assert(change % alignment == 0, &quot;just checking&quot;);
 397     if (expand(change)) {
 398        changed = true;
 399     }
 400     // If the heap failed to expand to the desired size,
 401     // &quot;changed&quot; will be false.  If the expansion failed
 402     // (and at this point it was expected to succeed),
 403     // ignore the failure (leaving &quot;changed&quot; as false).
 404   }
 405   if (desired_new_size &lt; new_size_before &amp;&amp; eden()-&gt;is_empty()) {
 406     // bail out of shrinking if objects in eden
 407     size_t change = new_size_before - desired_new_size;
 408     assert(change % alignment == 0, &quot;just checking&quot;);
 409     _virtual_space.shrink_by(change);
 410     changed = true;
</pre>
<hr />
<pre>
 436 
 437 
 438 size_t DefNewGeneration::capacity() const {
 439   return eden()-&gt;capacity()
 440        + from()-&gt;capacity();  // to() is only used during scavenge
 441 }
 442 
 443 
 444 size_t DefNewGeneration::used() const {
 445   return eden()-&gt;used()
 446        + from()-&gt;used();      // to() is only used during scavenge
 447 }
 448 
 449 
 450 size_t DefNewGeneration::free() const {
 451   return eden()-&gt;free()
 452        + from()-&gt;free();      // to() is only used during scavenge
 453 }
 454 
 455 size_t DefNewGeneration::max_capacity() const {

 456   const size_t reserved_bytes = reserved().byte_size();
<span class="line-modified"> 457   return reserved_bytes - compute_survivor_size(reserved_bytes, SpaceAlignment);</span>
 458 }
 459 
 460 size_t DefNewGeneration::unsafe_max_alloc_nogc() const {
 461   return eden()-&gt;free();
 462 }
 463 
 464 size_t DefNewGeneration::capacity_before_gc() const {
 465   return eden()-&gt;capacity();
 466 }
 467 
 468 size_t DefNewGeneration::contiguous_available() const {
 469   return eden()-&gt;free();
 470 }
 471 
 472 
 473 HeapWord* volatile* DefNewGeneration::top_addr() const { return eden()-&gt;top_addr(); }
 474 HeapWord** DefNewGeneration::end_addr() const { return eden()-&gt;end_addr(); }
 475 
 476 void DefNewGeneration::object_iterate(ObjectClosure* blk) {
 477   eden()-&gt;object_iterate(blk);
</pre>
<hr />
<pre>
 690 
 691   _gc_timer-&gt;register_gc_end();
 692 
 693   gc_tracer.report_gc_end(_gc_timer-&gt;gc_end(), _gc_timer-&gt;time_partitions());
 694 }
 695 
 696 void DefNewGeneration::init_assuming_no_promotion_failure() {
 697   _promotion_failed = false;
 698   _promotion_failed_info.reset();
 699   from()-&gt;set_next_compaction_space(NULL);
 700 }
 701 
 702 void DefNewGeneration::remove_forwarding_pointers() {
 703   RemoveForwardedPointerClosure rspc;
 704   eden()-&gt;object_iterate(&amp;rspc);
 705   from()-&gt;object_iterate(&amp;rspc);
 706   restore_preserved_marks();
 707 }
 708 
 709 void DefNewGeneration::restore_preserved_marks() {
<span class="line-modified"> 710   _preserved_marks_set.restore(NULL);</span>

 711 }
 712 
 713 void DefNewGeneration::handle_promotion_failure(oop old) {
 714   log_debug(gc, promotion)(&quot;Promotion failure size = %d) &quot;, old-&gt;size());
 715 
 716   _promotion_failed = true;
 717   _promotion_failed_info.register_copy_failure(old-&gt;size());
 718   _preserved_marks_set.get()-&gt;push_if_necessary(old, old-&gt;mark_raw());
 719   // forward to self
 720   old-&gt;forward_to(old);
 721 
 722   _promo_failure_scan_stack.push(old);
 723 
 724   if (!_promo_failure_drain_in_progress) {
 725     // prevent recursion in copy_to_survivor_space()
 726     _promo_failure_drain_in_progress = true;
 727     drain_promo_failure_scan_stack();
 728     _promo_failure_drain_in_progress = false;
 729   }
 730 }
</pre>
<hr />
<pre>
 736   oop obj = NULL;
 737 
 738   // Try allocating obj in to-space (unless too old)
 739   if (old-&gt;age() &lt; tenuring_threshold()) {
 740     obj = (oop) to()-&gt;allocate_aligned(s);
 741   }
 742 
 743   // Otherwise try allocating obj tenured
 744   if (obj == NULL) {
 745     obj = _old_gen-&gt;promote(old, s);
 746     if (obj == NULL) {
 747       handle_promotion_failure(old);
 748       return old;
 749     }
 750   } else {
 751     // Prefetch beyond obj
 752     const intx interval = PrefetchCopyIntervalInBytes;
 753     Prefetch::write(obj, interval);
 754 
 755     // Copy obj
<span class="line-modified"> 756     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(old), cast_from_oop&lt;HeapWord*&gt;(obj), s);</span>
 757 
 758     // Increment age if obj still in new generation
 759     obj-&gt;incr_age();
 760     age_table()-&gt;add(obj, s);
 761   }
 762 
 763   // Done, insert forward pointer to obj in this header
 764   old-&gt;forward_to(obj);
 765 
 766   return obj;
 767 }
 768 
 769 void DefNewGeneration::drain_promo_failure_scan_stack() {
 770   while (!_promo_failure_scan_stack.is_empty()) {
 771      oop obj = _promo_failure_scan_stack.pop();
 772      obj-&gt;oop_iterate(_promo_failure_scan_stack_closure);
 773   }
 774 }
 775 
 776 void DefNewGeneration::save_marks() {
</pre>
<hr />
<pre>
 860       gch-&gt;clear_incremental_collection_failed(); // We just did a full collection
 861       clear_should_allocate_from_space(); // if set
 862     }
 863   } else {
 864 #ifdef ASSERT
 865     // It is possible that incremental_collection_failed() == true
 866     // here, because an attempted scavenge did not succeed. The policy
 867     // is normally expected to cause a full collection which should
 868     // clear that condition, so we should not be here twice in a row
 869     // with incremental_collection_failed() == true without having done
 870     // a full collection in between.
 871     if (!seen_incremental_collection_failed &amp;&amp;
 872         gch-&gt;incremental_collection_failed()) {
 873       log_trace(gc)(&quot;DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed&quot;,
 874                             GCCause::to_string(gch-&gt;gc_cause()));
 875       seen_incremental_collection_failed = true;
 876     } else if (seen_incremental_collection_failed) {
 877       log_trace(gc)(&quot;DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed&quot;,
 878                             GCCause::to_string(gch-&gt;gc_cause()));
 879       assert(gch-&gt;gc_cause() == GCCause::_scavenge_alot ||

 880              !gch-&gt;incremental_collection_failed(),
 881              &quot;Twice in a row&quot;);
 882       seen_incremental_collection_failed = false;
 883     }
 884 #endif // ASSERT
 885   }
 886 
 887   if (ZapUnusedHeapArea) {
 888     eden()-&gt;check_mangled_unused_area_complete();
 889     from()-&gt;check_mangled_unused_area_complete();
 890     to()-&gt;check_mangled_unused_area_complete();
 891   }
 892 
 893   if (!CleanChunkPoolAsync) {
 894     Chunk::clean_chunk_pool();
 895   }
 896 
 897   // update the generation and space performance counters
 898   update_counters();
 899   gch-&gt;counters()-&gt;update_counters();
</pre>
</td>
</tr>
</table>
<center><a href="cSpaceCounters.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="defNewGeneration.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
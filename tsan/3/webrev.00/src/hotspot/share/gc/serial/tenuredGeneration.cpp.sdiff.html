<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/serial/tenuredGeneration.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="serial_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="tenuredGeneration.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/serial/tenuredGeneration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/serial/genMarkSweep.hpp&quot;
 27 #include &quot;gc/serial/tenuredGeneration.inline.hpp&quot;
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/cardGeneration.inline.hpp&quot;
 30 #include &quot;gc/shared/collectorCounters.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 34 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 35 #include &quot;gc/shared/generationSpec.hpp&quot;
 36 #include &quot;gc/shared/space.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;memory/allocation.inline.hpp&quot;
 39 #include &quot;oops/oop.inline.hpp&quot;
 40 #include &quot;runtime/java.hpp&quot;
 41 #include &quot;utilities/macros.hpp&quot;
<span class="line-removed"> 42 #if INCLUDE_CMSGC</span>
<span class="line-removed"> 43 #include &quot;gc/cms/parOopClosures.hpp&quot;</span>
<span class="line-removed"> 44 #endif</span>
 45 
 46 TenuredGeneration::TenuredGeneration(ReservedSpace rs,
 47                                      size_t initial_byte_size,


 48                                      CardTableRS* remset) :
 49   CardGeneration(rs, initial_byte_size, remset)
 50 {
 51   HeapWord* bottom = (HeapWord*) _virtual_space.low();
 52   HeapWord* end    = (HeapWord*) _virtual_space.high();
 53   _the_space  = new TenuredSpace(_bts, MemRegion(bottom, end));
 54   _the_space-&gt;reset_saved_mark();
 55   _shrink_factor = 0;
 56   _capacity_at_prologue = 0;
 57 
 58   _gc_stats = new GCStats();
 59 
 60   // initialize performance counters
 61 
 62   const char* gen_name = &quot;old&quot;;
<span class="line-removed"> 63   GenCollectorPolicy* gcp = GenCollectedHeap::heap()-&gt;gen_policy();</span>
 64   // Generation Counters -- generation 1, 1 subspace
 65   _gen_counters = new GenerationCounters(gen_name, 1, 1,
<span class="line-modified"> 66       gcp-&gt;min_old_size(), gcp-&gt;max_old_size(), &amp;_virtual_space);</span>
 67 
 68   _gc_counters = new CollectorCounters(&quot;Serial full collection pauses&quot;, 1);
 69 
 70   _space_counters = new CSpaceCounters(gen_name, 0,
 71                                        _virtual_space.reserved_size(),
 72                                        _the_space, _gen_counters);
 73 }
 74 
 75 void TenuredGeneration::gc_prologue(bool full) {
 76   _capacity_at_prologue = capacity();
 77   _used_at_prologue = used();
 78 }
 79 
 80 bool TenuredGeneration::should_collect(bool  full,
 81                                        size_t size,
 82                                        bool   is_tlab) {
 83   // This should be one big conditional or (||), but I want to be able to tell
 84   // why it returns what it returns (without re-evaluating the conditionals
 85   // in case they aren&#39;t idempotent), so I&#39;m doing it this way.
 86   // DeMorgan says it&#39;s okay.
</pre>
<hr />
<pre>
184 
185   gch-&gt;post_full_gc_dump(gc_timer);
186 
187   gc_timer-&gt;register_gc_end();
188 
189   gc_tracer-&gt;report_gc_end(gc_timer-&gt;gc_end(), gc_timer-&gt;time_partitions());
190 }
191 
192 HeapWord*
193 TenuredGeneration::expand_and_allocate(size_t word_size,
194                                        bool is_tlab,
195                                        bool parallel) {
196   assert(!is_tlab, &quot;TenuredGeneration does not support TLAB allocation&quot;);
197   if (parallel) {
198     MutexLocker x(ParGCRareEvent_lock);
199     HeapWord* result = NULL;
200     size_t byte_size = word_size * HeapWordSize;
201     while (true) {
202       expand(byte_size, _min_heap_delta_bytes);
203       if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">204         os::sleep(Thread::current(), GCExpandToAllocateDelayMillis, false);</span>
205       }
206       result = _the_space-&gt;par_allocate(word_size);
207       if ( result != NULL) {
208         return result;
209       } else {
210         // If there&#39;s not enough expansion space available, give up.
211         if (_virtual_space.uncommitted_size() &lt; byte_size) {
212           return NULL;
213         }
214         // else try again
215       }
216     }
217   } else {
218     expand(word_size*HeapWordSize, _min_heap_delta_bytes);
219     return _the_space-&gt;allocate(word_size);
220   }
221 }
222 
223 bool TenuredGeneration::expand(size_t bytes, size_t expand_bytes) {
224   GCMutexLocker x(ExpandHeap_lock);
</pre>
</td>
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/serial/genMarkSweep.hpp&quot;
 27 #include &quot;gc/serial/tenuredGeneration.inline.hpp&quot;
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/cardGeneration.inline.hpp&quot;
 30 #include &quot;gc/shared/collectorCounters.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 34 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 35 #include &quot;gc/shared/generationSpec.hpp&quot;
 36 #include &quot;gc/shared/space.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;memory/allocation.inline.hpp&quot;
 39 #include &quot;oops/oop.inline.hpp&quot;
 40 #include &quot;runtime/java.hpp&quot;
 41 #include &quot;utilities/macros.hpp&quot;



 42 
 43 TenuredGeneration::TenuredGeneration(ReservedSpace rs,
 44                                      size_t initial_byte_size,
<span class="line-added"> 45                                      size_t min_byte_size,</span>
<span class="line-added"> 46                                      size_t max_byte_size,</span>
 47                                      CardTableRS* remset) :
 48   CardGeneration(rs, initial_byte_size, remset)
 49 {
 50   HeapWord* bottom = (HeapWord*) _virtual_space.low();
 51   HeapWord* end    = (HeapWord*) _virtual_space.high();
 52   _the_space  = new TenuredSpace(_bts, MemRegion(bottom, end));
 53   _the_space-&gt;reset_saved_mark();
 54   _shrink_factor = 0;
 55   _capacity_at_prologue = 0;
 56 
 57   _gc_stats = new GCStats();
 58 
 59   // initialize performance counters
 60 
 61   const char* gen_name = &quot;old&quot;;

 62   // Generation Counters -- generation 1, 1 subspace
 63   _gen_counters = new GenerationCounters(gen_name, 1, 1,
<span class="line-modified"> 64       min_byte_size, max_byte_size, &amp;_virtual_space);</span>
 65 
 66   _gc_counters = new CollectorCounters(&quot;Serial full collection pauses&quot;, 1);
 67 
 68   _space_counters = new CSpaceCounters(gen_name, 0,
 69                                        _virtual_space.reserved_size(),
 70                                        _the_space, _gen_counters);
 71 }
 72 
 73 void TenuredGeneration::gc_prologue(bool full) {
 74   _capacity_at_prologue = capacity();
 75   _used_at_prologue = used();
 76 }
 77 
 78 bool TenuredGeneration::should_collect(bool  full,
 79                                        size_t size,
 80                                        bool   is_tlab) {
 81   // This should be one big conditional or (||), but I want to be able to tell
 82   // why it returns what it returns (without re-evaluating the conditionals
 83   // in case they aren&#39;t idempotent), so I&#39;m doing it this way.
 84   // DeMorgan says it&#39;s okay.
</pre>
<hr />
<pre>
182 
183   gch-&gt;post_full_gc_dump(gc_timer);
184 
185   gc_timer-&gt;register_gc_end();
186 
187   gc_tracer-&gt;report_gc_end(gc_timer-&gt;gc_end(), gc_timer-&gt;time_partitions());
188 }
189 
190 HeapWord*
191 TenuredGeneration::expand_and_allocate(size_t word_size,
192                                        bool is_tlab,
193                                        bool parallel) {
194   assert(!is_tlab, &quot;TenuredGeneration does not support TLAB allocation&quot;);
195   if (parallel) {
196     MutexLocker x(ParGCRareEvent_lock);
197     HeapWord* result = NULL;
198     size_t byte_size = word_size * HeapWordSize;
199     while (true) {
200       expand(byte_size, _min_heap_delta_bytes);
201       if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">202         os::naked_sleep(GCExpandToAllocateDelayMillis);</span>
203       }
204       result = _the_space-&gt;par_allocate(word_size);
205       if ( result != NULL) {
206         return result;
207       } else {
208         // If there&#39;s not enough expansion space available, give up.
209         if (_virtual_space.uncommitted_size() &lt; byte_size) {
210           return NULL;
211         }
212         // else try again
213       }
214     }
215   } else {
216     expand(word_size*HeapWordSize, _min_heap_delta_bytes);
217     return _the_space-&gt;allocate(word_size);
218   }
219 }
220 
221 bool TenuredGeneration::expand(size_t bytes, size_t expand_bytes) {
222   GCMutexLocker x(ExpandHeap_lock);
</pre>
</td>
</tr>
</table>
<center><a href="serial_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="tenuredGeneration.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
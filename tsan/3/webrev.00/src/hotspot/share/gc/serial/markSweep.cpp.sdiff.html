<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/serial/markSweep.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genMarkSweep.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="markSweep.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/serial/markSweep.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/shared/gcTrace.hpp&quot;
 31 #include &quot;memory/iterator.inline.hpp&quot;

 32 #include &quot;oops/access.inline.hpp&quot;
 33 #include &quot;oops/compressedOops.inline.hpp&quot;
 34 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
 35 #include &quot;oops/instanceKlass.inline.hpp&quot;
 36 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
 37 #include &quot;oops/instanceRefKlass.inline.hpp&quot;
 38 #include &quot;oops/methodData.hpp&quot;
 39 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 42 #include &quot;utilities/macros.hpp&quot;
 43 #include &quot;utilities/stack.inline.hpp&quot;
 44 
 45 uint                    MarkSweep::_total_invocations = 0;
 46 
 47 Stack&lt;oop, mtGC&gt;              MarkSweep::_marking_stack;
 48 Stack&lt;ObjArrayTask, mtGC&gt;     MarkSweep::_objarray_stack;
 49 
 50 Stack&lt;oop, mtGC&gt;              MarkSweep::_preserved_oop_stack;
<span class="line-modified"> 51 Stack&lt;markOop, mtGC&gt;          MarkSweep::_preserved_mark_stack;</span>
 52 size_t                  MarkSweep::_preserved_count = 0;
 53 size_t                  MarkSweep::_preserved_count_max = 0;
 54 PreservedMark*          MarkSweep::_preserved_marks = NULL;
 55 ReferenceProcessor*     MarkSweep::_ref_processor   = NULL;
 56 STWGCTimer*             MarkSweep::_gc_timer        = NULL;
 57 SerialOldTracer*        MarkSweep::_gc_tracer       = NULL;
 58 
 59 MarkSweep::FollowRootClosure  MarkSweep::follow_root_closure;
 60 
 61 MarkAndPushClosure MarkSweep::mark_and_push_closure;
 62 CLDToOopClosure    MarkSweep::follow_cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
 63 CLDToOopClosure    MarkSweep::adjust_cld_closure(&amp;adjust_pointer_closure, ClassLoaderData::_claim_strong);
 64 
 65 template &lt;class T&gt; inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {
 66   mark_and_push(p);
 67 }
 68 
 69 void MarkSweep::push_objarray(oop obj, size_t index) {
 70   ObjArrayTask task(obj, index);
 71   assert(task.is_valid(), &quot;bad ObjArrayTask&quot;);
</pre>
<hr />
<pre>
109 void MarkSweep::follow_stack() {
110   do {
111     while (!_marking_stack.is_empty()) {
112       oop obj = _marking_stack.pop();
113       assert (obj-&gt;is_gc_marked(), &quot;p must be marked&quot;);
114       follow_object(obj);
115     }
116     // Process ObjArrays one at a time to avoid marking stack bloat.
117     if (!_objarray_stack.is_empty()) {
118       ObjArrayTask task = _objarray_stack.pop();
119       follow_array_chunk(objArrayOop(task.obj()), task.index());
120     }
121   } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());
122 }
123 
124 MarkSweep::FollowStackClosure MarkSweep::follow_stack_closure;
125 
126 void MarkSweep::FollowStackClosure::do_void() { follow_stack(); }
127 
128 template &lt;class T&gt; inline void MarkSweep::follow_root(T* p) {
<span class="line-modified">129   assert(!Universe::heap()-&gt;is_in_reserved(p),</span>
130          &quot;roots shouldn&#39;t be things within the heap&quot;);
131   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
132   if (!CompressedOops::is_null(heap_oop)) {
133     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">134     if (!obj-&gt;mark_raw()-&gt;is_marked()) {</span>
135       mark_object(obj);
136       follow_object(obj);
137     }
138   }
139   follow_stack();
140 }
141 
142 void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }
143 void MarkSweep::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }
144 
145 void PreservedMark::adjust_pointer() {
146   MarkSweep::adjust_pointer(&amp;_obj);
147 }
148 
149 void PreservedMark::restore() {
150   _obj-&gt;set_mark_raw(_mark);
151 }
152 
153 // We preserve the mark which should be replaced at the end and the location
<span class="line-modified">154 // that it will go.  Note that the object that this markOop belongs to isn&#39;t</span>
155 // currently at that address but it will be after phase4
<span class="line-modified">156 void MarkSweep::preserve_mark(oop obj, markOop mark) {</span>
157   // We try to store preserved marks in the to space of the new generation since
158   // this is storage which should be available.  Most of the time this should be
159   // sufficient space for the marks we need to preserve but if it isn&#39;t we fall
160   // back to using Stacks to keep track of the overflow.
161   if (_preserved_count &lt; _preserved_count_max) {
162     _preserved_marks[_preserved_count++].init(obj, mark);
163   } else {
164     _preserved_mark_stack.push(mark);
165     _preserved_oop_stack.push(obj);
166   }
167 }
168 
169 void MarkSweep::set_ref_processor(ReferenceProcessor* rp) {
170   _ref_processor = rp;
171   mark_and_push_closure.set_ref_discoverer(_ref_processor);
172 }
173 
174 AdjustPointerClosure MarkSweep::adjust_pointer_closure;
175 
176 void MarkSweep::adjust_marks() {
</pre>
<hr />
<pre>
186   StackIterator&lt;oop, mtGC&gt; iter(_preserved_oop_stack);
187   while (!iter.is_empty()) {
188     oop* p = iter.next_addr();
189     adjust_pointer(p);
190   }
191 }
192 
193 void MarkSweep::restore_marks() {
194   assert(_preserved_oop_stack.size() == _preserved_mark_stack.size(),
195          &quot;inconsistent preserved oop stacks&quot;);
196   log_trace(gc)(&quot;Restoring &quot; SIZE_FORMAT &quot; marks&quot;, _preserved_count + _preserved_oop_stack.size());
197 
198   // restore the marks we saved earlier
199   for (size_t i = 0; i &lt; _preserved_count; i++) {
200     _preserved_marks[i].restore();
201   }
202 
203   // deal with the overflow
204   while (!_preserved_oop_stack.is_empty()) {
205     oop obj       = _preserved_oop_stack.pop();
<span class="line-modified">206     markOop mark  = _preserved_mark_stack.pop();</span>
207     obj-&gt;set_mark_raw(mark);
208   }
209 }
210 
211 MarkSweep::IsAliveClosure   MarkSweep::is_alive;
212 
213 bool MarkSweep::IsAliveClosure::do_object_b(oop p) { return p-&gt;is_gc_marked(); }
214 
215 MarkSweep::KeepAliveClosure MarkSweep::keep_alive;
216 
217 void MarkSweep::KeepAliveClosure::do_oop(oop* p)       { MarkSweep::KeepAliveClosure::do_oop_work(p); }
218 void MarkSweep::KeepAliveClosure::do_oop(narrowOop* p) { MarkSweep::KeepAliveClosure::do_oop_work(p); }
219 
220 void MarkSweep::initialize() {
221   MarkSweep::_gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
222   MarkSweep::_gc_tracer = new (ResourceObj::C_HEAP, mtGC) SerialOldTracer();
223 }
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/shared/gcTrace.hpp&quot;
 31 #include &quot;memory/iterator.inline.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/compressedOops.inline.hpp&quot;
 35 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
 36 #include &quot;oops/instanceKlass.inline.hpp&quot;
 37 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceRefKlass.inline.hpp&quot;
 39 #include &quot;oops/methodData.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/oop.inline.hpp&quot;
 42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 43 #include &quot;utilities/macros.hpp&quot;
 44 #include &quot;utilities/stack.inline.hpp&quot;
 45 
 46 uint                    MarkSweep::_total_invocations = 0;
 47 
 48 Stack&lt;oop, mtGC&gt;              MarkSweep::_marking_stack;
 49 Stack&lt;ObjArrayTask, mtGC&gt;     MarkSweep::_objarray_stack;
 50 
 51 Stack&lt;oop, mtGC&gt;              MarkSweep::_preserved_oop_stack;
<span class="line-modified"> 52 Stack&lt;markWord, mtGC&gt;         MarkSweep::_preserved_mark_stack;</span>
 53 size_t                  MarkSweep::_preserved_count = 0;
 54 size_t                  MarkSweep::_preserved_count_max = 0;
 55 PreservedMark*          MarkSweep::_preserved_marks = NULL;
 56 ReferenceProcessor*     MarkSweep::_ref_processor   = NULL;
 57 STWGCTimer*             MarkSweep::_gc_timer        = NULL;
 58 SerialOldTracer*        MarkSweep::_gc_tracer       = NULL;
 59 
 60 MarkSweep::FollowRootClosure  MarkSweep::follow_root_closure;
 61 
 62 MarkAndPushClosure MarkSweep::mark_and_push_closure;
 63 CLDToOopClosure    MarkSweep::follow_cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
 64 CLDToOopClosure    MarkSweep::adjust_cld_closure(&amp;adjust_pointer_closure, ClassLoaderData::_claim_strong);
 65 
 66 template &lt;class T&gt; inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {
 67   mark_and_push(p);
 68 }
 69 
 70 void MarkSweep::push_objarray(oop obj, size_t index) {
 71   ObjArrayTask task(obj, index);
 72   assert(task.is_valid(), &quot;bad ObjArrayTask&quot;);
</pre>
<hr />
<pre>
110 void MarkSweep::follow_stack() {
111   do {
112     while (!_marking_stack.is_empty()) {
113       oop obj = _marking_stack.pop();
114       assert (obj-&gt;is_gc_marked(), &quot;p must be marked&quot;);
115       follow_object(obj);
116     }
117     // Process ObjArrays one at a time to avoid marking stack bloat.
118     if (!_objarray_stack.is_empty()) {
119       ObjArrayTask task = _objarray_stack.pop();
120       follow_array_chunk(objArrayOop(task.obj()), task.index());
121     }
122   } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());
123 }
124 
125 MarkSweep::FollowStackClosure MarkSweep::follow_stack_closure;
126 
127 void MarkSweep::FollowStackClosure::do_void() { follow_stack(); }
128 
129 template &lt;class T&gt; inline void MarkSweep::follow_root(T* p) {
<span class="line-modified">130   assert(!Universe::heap()-&gt;is_in(p),</span>
131          &quot;roots shouldn&#39;t be things within the heap&quot;);
132   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
133   if (!CompressedOops::is_null(heap_oop)) {
134     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">135     if (!obj-&gt;mark_raw().is_marked()) {</span>
136       mark_object(obj);
137       follow_object(obj);
138     }
139   }
140   follow_stack();
141 }
142 
143 void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }
144 void MarkSweep::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }
145 
146 void PreservedMark::adjust_pointer() {
147   MarkSweep::adjust_pointer(&amp;_obj);
148 }
149 
150 void PreservedMark::restore() {
151   _obj-&gt;set_mark_raw(_mark);
152 }
153 
154 // We preserve the mark which should be replaced at the end and the location
<span class="line-modified">155 // that it will go.  Note that the object that this markWord belongs to isn&#39;t</span>
156 // currently at that address but it will be after phase4
<span class="line-modified">157 void MarkSweep::preserve_mark(oop obj, markWord mark) {</span>
158   // We try to store preserved marks in the to space of the new generation since
159   // this is storage which should be available.  Most of the time this should be
160   // sufficient space for the marks we need to preserve but if it isn&#39;t we fall
161   // back to using Stacks to keep track of the overflow.
162   if (_preserved_count &lt; _preserved_count_max) {
163     _preserved_marks[_preserved_count++].init(obj, mark);
164   } else {
165     _preserved_mark_stack.push(mark);
166     _preserved_oop_stack.push(obj);
167   }
168 }
169 
170 void MarkSweep::set_ref_processor(ReferenceProcessor* rp) {
171   _ref_processor = rp;
172   mark_and_push_closure.set_ref_discoverer(_ref_processor);
173 }
174 
175 AdjustPointerClosure MarkSweep::adjust_pointer_closure;
176 
177 void MarkSweep::adjust_marks() {
</pre>
<hr />
<pre>
187   StackIterator&lt;oop, mtGC&gt; iter(_preserved_oop_stack);
188   while (!iter.is_empty()) {
189     oop* p = iter.next_addr();
190     adjust_pointer(p);
191   }
192 }
193 
194 void MarkSweep::restore_marks() {
195   assert(_preserved_oop_stack.size() == _preserved_mark_stack.size(),
196          &quot;inconsistent preserved oop stacks&quot;);
197   log_trace(gc)(&quot;Restoring &quot; SIZE_FORMAT &quot; marks&quot;, _preserved_count + _preserved_oop_stack.size());
198 
199   // restore the marks we saved earlier
200   for (size_t i = 0; i &lt; _preserved_count; i++) {
201     _preserved_marks[i].restore();
202   }
203 
204   // deal with the overflow
205   while (!_preserved_oop_stack.is_empty()) {
206     oop obj       = _preserved_oop_stack.pop();
<span class="line-modified">207     markWord mark = _preserved_mark_stack.pop();</span>
208     obj-&gt;set_mark_raw(mark);
209   }
210 }
211 
212 MarkSweep::IsAliveClosure   MarkSweep::is_alive;
213 
214 bool MarkSweep::IsAliveClosure::do_object_b(oop p) { return p-&gt;is_gc_marked(); }
215 
216 MarkSweep::KeepAliveClosure MarkSweep::keep_alive;
217 
218 void MarkSweep::KeepAliveClosure::do_oop(oop* p)       { MarkSweep::KeepAliveClosure::do_oop_work(p); }
219 void MarkSweep::KeepAliveClosure::do_oop(narrowOop* p) { MarkSweep::KeepAliveClosure::do_oop_work(p); }
220 
221 void MarkSweep::initialize() {
222   MarkSweep::_gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
223   MarkSweep::_gc_tracer = new (ResourceObj::C_HEAP, mtGC) SerialOldTracer();
224 }
</pre>
</td>
</tr>
</table>
<center><a href="genMarkSweep.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="markSweep.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/serial/genMarkSweep.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/symbolTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;code/icBuffer.hpp&quot;
 34 #include &quot;gc/serial/genMarkSweep.hpp&quot;
 35 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 36 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 37 #include &quot;gc/shared/gcTimer.hpp&quot;
 38 #include &quot;gc/shared/gcTrace.hpp&quot;
 39 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 40 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 41 #include &quot;gc/shared/generation.hpp&quot;
 42 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 43 #include &quot;gc/shared/modRefBarrierSet.hpp&quot;
 44 #include &quot;gc/shared/referencePolicy.hpp&quot;
 45 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 46 #include &quot;gc/shared/space.hpp&quot;
 47 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 48 #include &quot;gc/shared/weakProcessor.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 49 #include &quot;memory/universe.hpp&quot;</span>
 50 #include &quot;oops/instanceRefKlass.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;prims/jvmtiExport.hpp&quot;
 53 #include &quot;runtime/handles.inline.hpp&quot;
 54 #include &quot;runtime/synchronizer.hpp&quot;
 55 #include &quot;runtime/thread.inline.hpp&quot;
 56 #include &quot;runtime/vmThread.hpp&quot;
 57 #include &quot;utilities/copy.hpp&quot;
 58 #include &quot;utilities/events.hpp&quot;
 59 #include &quot;utilities/stack.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 60 #if INCLUDE_JVMCI</span>
<span class="line-added"> 61 #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="line-added"> 62 #endif</span>
 63 
 64 void GenMarkSweep::invoke_at_safepoint(ReferenceProcessor* rp, bool clear_all_softrefs) {
 65   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);
 66 
 67   GenCollectedHeap* gch = GenCollectedHeap::heap();
 68 #ifdef ASSERT
 69   if (gch-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs()) {
 70     assert(clear_all_softrefs, &quot;Policy should have been checked earlier&quot;);
 71   }
 72 #endif
 73 
 74   // hook up weak ref data so it can be used during Mark-Sweep
 75   assert(ref_processor() == NULL, &quot;no stomping&quot;);
 76   assert(rp != NULL, &quot;should be non-NULL&quot;);
 77   set_ref_processor(rp);
 78   rp-&gt;setup_policy(clear_all_softrefs);
 79 
 80   gch-&gt;trace_heap_before_gc(_gc_tracer);
 81 
 82   // Increment the invocation count
 83   _total_invocations++;
 84 
 85   // Capture used regions for each generation that will be
 86   // subject to collection, so that card table adjustments can
 87   // be made intelligently (see clear / invalidate further below).
 88   gch-&gt;save_used_regions();
 89 
 90   allocate_stacks();
 91 
 92   mark_sweep_phase1(clear_all_softrefs);
 93 
 94   mark_sweep_phase2();
 95 
 96   // Don&#39;t add any more derived pointers during phase3
 97 #if COMPILER2_OR_JVMCI
 98   assert(DerivedPointerTable::is_active(), &quot;Sanity&quot;);
 99   DerivedPointerTable::set_active(false);
100 #endif
101 
102   mark_sweep_phase3();
103 
104   mark_sweep_phase4();
105 
106   restore_marks();
107 
108   // Set saved marks for allocation profiler (and other things? -- dld)
109   // (Should this be in general part?)
110   gch-&gt;save_marks();
111 
112   deallocate_stacks();
113 
114   // If compaction completely evacuated the young generation then we
115   // can clear the card table.  Otherwise, we must invalidate
116   // it (consider all cards dirty).  In the future, we might consider doing
117   // compaction within generations only, and doing card-table sliding.
118   CardTableRS* rs = gch-&gt;rem_set();
119   Generation* old_gen = gch-&gt;old_gen();
120 
121   // Clear/invalidate below make use of the &quot;prev_used_regions&quot; saved earlier.
122   if (gch-&gt;young_gen()-&gt;used() == 0) {
123     // We&#39;ve evacuated the young generation.
124     rs-&gt;clear_into_younger(old_gen);
125   } else {
126     // Invalidate the cards corresponding to the currently used
127     // region and clear those corresponding to the evacuated region.
128     rs-&gt;invalidate_or_clear(old_gen);
129   }
130 
<a name="3" id="anc3"></a><span class="line-modified">131   gch-&gt;prune_scavengable_nmethods();</span>

132 
133   // refs processing: clean slate
134   set_ref_processor(NULL);
135 
136   // Update heap occupancy information which is used as
137   // input to soft ref clearing policy at the next gc.
138   Universe::update_heap_info_at_gc();
139 
140   // Update time of last gc for all generations we collected
141   // (which currently is all the generations in the heap).
142   // We need to use a monotonically non-decreasing time in ms
143   // or we will see time-warp warnings and os::javaTimeMillis()
144   // does not guarantee monotonicity.
145   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
146   gch-&gt;update_time_of_last_gc(now);
147 
148   gch-&gt;trace_heap_after_gc(_gc_tracer);
149 }
150 
151 void GenMarkSweep::allocate_stacks() {
152   GenCollectedHeap* gch = GenCollectedHeap::heap();
153   // Scratch request on behalf of old generation; will do no allocation.
154   ScratchBlock* scratch = gch-&gt;gather_scratch(gch-&gt;old_gen(), 0);
155 
156   // $$$ To cut a corner, we&#39;ll only use the first scratch block, and then
157   // revert to malloc.
158   if (scratch != NULL) {
159     _preserved_count_max =
160       scratch-&gt;num_words * HeapWordSize / sizeof(PreservedMark);
161   } else {
162     _preserved_count_max = 0;
163   }
164 
165   _preserved_marks = (PreservedMark*)scratch;
166   _preserved_count = 0;
167 }
168 
169 
170 void GenMarkSweep::deallocate_stacks() {
171   GenCollectedHeap* gch = GenCollectedHeap::heap();
172   gch-&gt;release_scratch();
173 
174   _preserved_mark_stack.clear(true);
175   _preserved_oop_stack.clear(true);
176   _marking_stack.clear();
177   _objarray_stack.clear(true);
178 }
179 
180 void GenMarkSweep::mark_sweep_phase1(bool clear_all_softrefs) {
181   // Recursively traverse all live objects and mark them
182   GCTraceTime(Info, gc, phases) tm(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
183 
184   GenCollectedHeap* gch = GenCollectedHeap::heap();
185 
186   // Because follow_root_closure is created statically, cannot
187   // use OopsInGenClosure constructor which takes a generation,
188   // as the Universe has not been created when the static constructors
189   // are run.
190   follow_root_closure.set_orig_generation(gch-&gt;old_gen());
191 
192   // Need new claim bits before marking starts.
193   ClassLoaderDataGraph::clear_claimed_marks();
194 
195   {
196     StrongRootsScope srs(1);
197 
198     gch-&gt;full_process_roots(&amp;srs,
199                             false, // not the adjust phase
200                             GenCollectedHeap::SO_None,
201                             ClassUnloading, // only strong roots if ClassUnloading
202                                             // is enabled
203                             &amp;follow_root_closure,
204                             &amp;follow_cld_closure);
205   }
206 
207   // Process reference objects found during marking
208   {
209     GCTraceTime(Debug, gc, phases) tm_m(&quot;Reference Processing&quot;, gc_timer());
210 
211     ref_processor()-&gt;setup_policy(clear_all_softrefs);
212     ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()-&gt;max_num_queues());
213     const ReferenceProcessorStats&amp; stats =
214       ref_processor()-&gt;process_discovered_references(
215         &amp;is_alive, &amp;keep_alive, &amp;follow_stack_closure, NULL, &amp;pt);
216     pt.print_all_references();
217     gc_tracer()-&gt;report_gc_reference_stats(stats);
218   }
219 
220   // This is the point where the entire marking should have completed.
221   assert(_marking_stack.is_empty(), &quot;Marking should have completed&quot;);
222 
223   {
224     GCTraceTime(Debug, gc, phases) tm_m(&quot;Weak Processing&quot;, gc_timer());
225     WeakProcessor::weak_oops_do(&amp;is_alive, &amp;do_nothing_cl);
226   }
227 
228   {
229     GCTraceTime(Debug, gc, phases) tm_m(&quot;Class Unloading&quot;, gc_timer());
230 
231     // Unload classes and purge the SystemDictionary.
232     bool purged_class = SystemDictionary::do_unloading(gc_timer());
233 
234     // Unload nmethods.
235     CodeCache::do_unloading(&amp;is_alive, purged_class);
236 
237     // Prune dead klasses from subklass/sibling/implementor lists.
238     Klass::clean_weak_klass_links(purged_class);
<a name="4" id="anc4"></a><span class="line-added">239 </span>
<span class="line-added">240     // Clean JVMCI metadata handles.</span>
<span class="line-added">241     JVMCI_ONLY(JVMCI::do_unloading(purged_class));</span>
242   }
243 
244   gc_tracer()-&gt;report_object_count_after_gc(&amp;is_alive);
245 }
246 
247 
248 void GenMarkSweep::mark_sweep_phase2() {
249   // Now all live objects are marked, compute the new object addresses.
250 
251   // It is imperative that we traverse perm_gen LAST. If dead space is
252   // allowed a range of dead object may get overwritten by a dead int
253   // array. If perm_gen is not traversed last a Klass* may get
254   // overwritten. This is fine since it is dead, but if the class has dead
255   // instances we have to skip them, and in order to find their size we
256   // need the Klass*!
257   //
258   // It is not required that we traverse spaces in the same order in
259   // phase2, phase3 and phase4, but the ValidateMarkSweep live oops
260   // tracking expects us to do so. See comment under phase4.
261 
262   GenCollectedHeap* gch = GenCollectedHeap::heap();
263 
264   GCTraceTime(Info, gc, phases) tm(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
265 
266   gch-&gt;prepare_for_compaction();
267 }
268 
269 class GenAdjustPointersClosure: public GenCollectedHeap::GenClosure {
270 public:
271   void do_generation(Generation* gen) {
272     gen-&gt;adjust_pointers();
273   }
274 };
275 
276 void GenMarkSweep::mark_sweep_phase3() {
277   GenCollectedHeap* gch = GenCollectedHeap::heap();
278 
279   // Adjust the pointers to reflect the new locations
280   GCTraceTime(Info, gc, phases) tm(&quot;Phase 3: Adjust pointers&quot;, gc_timer());
281 
282   // Need new claim bits for the pointer adjustment tracing.
283   ClassLoaderDataGraph::clear_claimed_marks();
284 
285   // Because the closure below is created statically, we cannot
286   // use OopsInGenClosure constructor which takes a generation,
287   // as the Universe has not been created when the static constructors
288   // are run.
289   adjust_pointer_closure.set_orig_generation(gch-&gt;old_gen());
290 
291   {
292     StrongRootsScope srs(1);
293 
294     gch-&gt;full_process_roots(&amp;srs,
295                             true,  // this is the adjust phase
296                             GenCollectedHeap::SO_AllCodeCache,
297                             false, // all roots
298                             &amp;adjust_pointer_closure,
299                             &amp;adjust_cld_closure);
300   }
301 
302   gch-&gt;gen_process_weak_roots(&amp;adjust_pointer_closure);
303 
304   adjust_marks();
305   GenAdjustPointersClosure blk;
306   gch-&gt;generation_iterate(&amp;blk, true);
307 }
308 
309 class GenCompactClosure: public GenCollectedHeap::GenClosure {
310 public:
311   void do_generation(Generation* gen) {
312     gen-&gt;compact();
313   }
314 };
315 
316 void GenMarkSweep::mark_sweep_phase4() {
317   // All pointers are now adjusted, move objects accordingly
318 
319   // It is imperative that we traverse perm_gen first in phase4. All
320   // classes must be allocated earlier than their instances, and traversing
321   // perm_gen first makes sure that all Klass*s have moved to their new
322   // location before any instance does a dispatch through it&#39;s klass!
323 
324   // The ValidateMarkSweep live oops tracking expects us to traverse spaces
325   // in the same order in phase2, phase3 and phase4. We don&#39;t quite do that
326   // here (perm_gen first rather than last), so we tell the validate code
327   // to use a higher index (saved from phase2) when verifying perm_gen.
328   GenCollectedHeap* gch = GenCollectedHeap::heap();
329 
330   GCTraceTime(Info, gc, phases) tm(&quot;Phase 4: Move objects&quot;, _gc_timer);
331 
332   GenCompactClosure blk;
333   gch-&gt;generation_iterate(&amp;blk, true);
334 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
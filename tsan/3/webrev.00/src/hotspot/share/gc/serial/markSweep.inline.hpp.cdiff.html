<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/serial/markSweep.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="markSweep.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="serialArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/serial/markSweep.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,32 ***</span>
  #define SHARE_GC_SERIAL_MARKSWEEP_INLINE_HPP
  
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;gc/serial/markSweep.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.inline.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;utilities/stack.inline.hpp&quot;
  
  inline void MarkSweep::mark_object(oop obj) {
    // some marks may contain information we need to preserve so we store them away
    // and overwrite the mark.  We&#39;ll restore it at the end of markSweep.
<span class="line-modified">!   markOop mark = obj-&gt;mark_raw();</span>
<span class="line-modified">!   obj-&gt;set_mark_raw(markOopDesc::prototype()-&gt;set_marked());</span>
  
<span class="line-modified">!   if (mark-&gt;must_be_preserved(obj)) {</span>
      preserve_mark(obj, mark);
    }
  }
  
  template &lt;class T&gt; inline void MarkSweep::mark_and_push(T* p) {
    T heap_oop = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(heap_oop)) {
      oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">!     if (!obj-&gt;mark_raw()-&gt;is_marked()) {</span>
        mark_object(obj);
        _marking_stack.push(obj);
      }
    }
  }
<span class="line-new-header">--- 26,33 ---</span>
  #define SHARE_GC_SERIAL_MARKSWEEP_INLINE_HPP
  
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;gc/serial/markSweep.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-modified">! #include &quot;oops/markWord.inline.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  #include &quot;utilities/stack.inline.hpp&quot;
  
  inline void MarkSweep::mark_object(oop obj) {
    // some marks may contain information we need to preserve so we store them away
    // and overwrite the mark.  We&#39;ll restore it at the end of markSweep.
<span class="line-modified">!   markWord mark = obj-&gt;mark_raw();</span>
<span class="line-modified">!   obj-&gt;set_mark_raw(markWord::prototype().set_marked());</span>
  
<span class="line-modified">!   if (obj-&gt;mark_must_be_preserved(mark)) {</span>
      preserve_mark(obj, mark);
    }
  }
  
  template &lt;class T&gt; inline void MarkSweep::mark_and_push(T* p) {
    T heap_oop = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(heap_oop)) {
      oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">!     if (!obj-&gt;mark_raw().is_marked()) {</span>
        mark_object(obj);
        _marking_stack.push(obj);
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,21 ***</span>
    T heap_oop = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(heap_oop)) {
      oop obj = CompressedOops::decode_not_null(heap_oop);
      assert(Universe::heap()-&gt;is_in(obj), &quot;should be in heap&quot;);
  
<span class="line-modified">!     oop new_obj = oop(obj-&gt;mark_raw()-&gt;decode_pointer());</span>
  
<span class="line-modified">!     assert(new_obj != NULL ||                         // is forwarding ptr?</span>
<span class="line-modified">!            obj-&gt;mark_raw() == markOopDesc::prototype() || // not gc marked?</span>
<span class="line-modified">!            (UseBiasedLocking &amp;&amp; obj-&gt;mark_raw()-&gt;has_bias_pattern()),</span>
             // not gc marked?
             &quot;should be forwarded&quot;);
  
      if (new_obj != NULL) {
<span class="line-modified">!       assert(Universe::heap()-&gt;is_in_reserved(new_obj),</span>
<span class="line-removed">-              &quot;should be in object space&quot;);</span>
        RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
      }
    }
  }
  
<span class="line-new-header">--- 77,20 ---</span>
    T heap_oop = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(heap_oop)) {
      oop obj = CompressedOops::decode_not_null(heap_oop);
      assert(Universe::heap()-&gt;is_in(obj), &quot;should be in heap&quot;);
  
<span class="line-modified">!     oop new_obj = oop(obj-&gt;mark_raw().decode_pointer());</span>
  
<span class="line-modified">!     assert(new_obj != NULL ||                          // is forwarding ptr?</span>
<span class="line-modified">!            obj-&gt;mark_raw() == markWord::prototype() || // not gc marked?</span>
<span class="line-modified">!            (UseBiasedLocking &amp;&amp; obj-&gt;mark_raw().has_bias_pattern()),</span>
             // not gc marked?
             &quot;should be forwarded&quot;);
  
      if (new_obj != NULL) {
<span class="line-modified">!       assert(is_object_aligned(new_obj), &quot;oop must be aligned&quot;);</span>
        RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
      }
    }
  }
  
</pre>
<center><a href="markSweep.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="serialArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/serial/markSweep.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/shared/gcTrace.hpp&quot;
 31 #include &quot;memory/iterator.inline.hpp&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;oops/access.inline.hpp&quot;
 33 #include &quot;oops/compressedOops.inline.hpp&quot;
 34 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
 35 #include &quot;oops/instanceKlass.inline.hpp&quot;
 36 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
 37 #include &quot;oops/instanceRefKlass.inline.hpp&quot;
 38 #include &quot;oops/methodData.hpp&quot;
 39 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 42 #include &quot;utilities/macros.hpp&quot;
 43 #include &quot;utilities/stack.inline.hpp&quot;
 44 
 45 uint                    MarkSweep::_total_invocations = 0;
 46 
 47 Stack&lt;oop, mtGC&gt;              MarkSweep::_marking_stack;
 48 Stack&lt;ObjArrayTask, mtGC&gt;     MarkSweep::_objarray_stack;
 49 
 50 Stack&lt;oop, mtGC&gt;              MarkSweep::_preserved_oop_stack;
<a name="2" id="anc2"></a><span class="line-modified"> 51 Stack&lt;markOop, mtGC&gt;          MarkSweep::_preserved_mark_stack;</span>
 52 size_t                  MarkSweep::_preserved_count = 0;
 53 size_t                  MarkSweep::_preserved_count_max = 0;
 54 PreservedMark*          MarkSweep::_preserved_marks = NULL;
 55 ReferenceProcessor*     MarkSweep::_ref_processor   = NULL;
 56 STWGCTimer*             MarkSweep::_gc_timer        = NULL;
 57 SerialOldTracer*        MarkSweep::_gc_tracer       = NULL;
 58 
 59 MarkSweep::FollowRootClosure  MarkSweep::follow_root_closure;
 60 
 61 MarkAndPushClosure MarkSweep::mark_and_push_closure;
 62 CLDToOopClosure    MarkSweep::follow_cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
 63 CLDToOopClosure    MarkSweep::adjust_cld_closure(&amp;adjust_pointer_closure, ClassLoaderData::_claim_strong);
 64 
 65 template &lt;class T&gt; inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {
 66   mark_and_push(p);
 67 }
 68 
 69 void MarkSweep::push_objarray(oop obj, size_t index) {
 70   ObjArrayTask task(obj, index);
 71   assert(task.is_valid(), &quot;bad ObjArrayTask&quot;);
 72   _objarray_stack.push(task);
 73 }
 74 
 75 inline void MarkSweep::follow_array(objArrayOop array) {
 76   MarkSweep::follow_klass(array-&gt;klass());
 77   // Don&#39;t push empty arrays to avoid unnecessary work.
 78   if (array-&gt;length() &gt; 0) {
 79     MarkSweep::push_objarray(array, 0);
 80   }
 81 }
 82 
 83 inline void MarkSweep::follow_object(oop obj) {
 84   assert(obj-&gt;is_gc_marked(), &quot;should be marked&quot;);
 85   if (obj-&gt;is_objArray()) {
 86     // Handle object arrays explicitly to allow them to
 87     // be split into chunks if needed.
 88     MarkSweep::follow_array((objArrayOop)obj);
 89   } else {
 90     obj-&gt;oop_iterate(&amp;mark_and_push_closure);
 91   }
 92 }
 93 
 94 void MarkSweep::follow_array_chunk(objArrayOop array, int index) {
 95   const int len = array-&gt;length();
 96   const int beg_index = index;
 97   assert(beg_index &lt; len || len == 0, &quot;index too large&quot;);
 98 
 99   const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);
100   const int end_index = beg_index + stride;
101 
102   array-&gt;oop_iterate_range(&amp;mark_and_push_closure, beg_index, end_index);
103 
104   if (end_index &lt; len) {
105     MarkSweep::push_objarray(array, end_index); // Push the continuation.
106   }
107 }
108 
109 void MarkSweep::follow_stack() {
110   do {
111     while (!_marking_stack.is_empty()) {
112       oop obj = _marking_stack.pop();
113       assert (obj-&gt;is_gc_marked(), &quot;p must be marked&quot;);
114       follow_object(obj);
115     }
116     // Process ObjArrays one at a time to avoid marking stack bloat.
117     if (!_objarray_stack.is_empty()) {
118       ObjArrayTask task = _objarray_stack.pop();
119       follow_array_chunk(objArrayOop(task.obj()), task.index());
120     }
121   } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());
122 }
123 
124 MarkSweep::FollowStackClosure MarkSweep::follow_stack_closure;
125 
126 void MarkSweep::FollowStackClosure::do_void() { follow_stack(); }
127 
128 template &lt;class T&gt; inline void MarkSweep::follow_root(T* p) {
<a name="3" id="anc3"></a><span class="line-modified">129   assert(!Universe::heap()-&gt;is_in_reserved(p),</span>
130          &quot;roots shouldn&#39;t be things within the heap&quot;);
131   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
132   if (!CompressedOops::is_null(heap_oop)) {
133     oop obj = CompressedOops::decode_not_null(heap_oop);
<a name="4" id="anc4"></a><span class="line-modified">134     if (!obj-&gt;mark_raw()-&gt;is_marked()) {</span>
135       mark_object(obj);
136       follow_object(obj);
137     }
138   }
139   follow_stack();
140 }
141 
142 void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }
143 void MarkSweep::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }
144 
145 void PreservedMark::adjust_pointer() {
146   MarkSweep::adjust_pointer(&amp;_obj);
147 }
148 
149 void PreservedMark::restore() {
150   _obj-&gt;set_mark_raw(_mark);
151 }
152 
153 // We preserve the mark which should be replaced at the end and the location
<a name="5" id="anc5"></a><span class="line-modified">154 // that it will go.  Note that the object that this markOop belongs to isn&#39;t</span>
155 // currently at that address but it will be after phase4
<a name="6" id="anc6"></a><span class="line-modified">156 void MarkSweep::preserve_mark(oop obj, markOop mark) {</span>
157   // We try to store preserved marks in the to space of the new generation since
158   // this is storage which should be available.  Most of the time this should be
159   // sufficient space for the marks we need to preserve but if it isn&#39;t we fall
160   // back to using Stacks to keep track of the overflow.
161   if (_preserved_count &lt; _preserved_count_max) {
162     _preserved_marks[_preserved_count++].init(obj, mark);
163   } else {
164     _preserved_mark_stack.push(mark);
165     _preserved_oop_stack.push(obj);
166   }
167 }
168 
169 void MarkSweep::set_ref_processor(ReferenceProcessor* rp) {
170   _ref_processor = rp;
171   mark_and_push_closure.set_ref_discoverer(_ref_processor);
172 }
173 
174 AdjustPointerClosure MarkSweep::adjust_pointer_closure;
175 
176 void MarkSweep::adjust_marks() {
177   assert( _preserved_oop_stack.size() == _preserved_mark_stack.size(),
178          &quot;inconsistent preserved oop stacks&quot;);
179 
180   // adjust the oops we saved earlier
181   for (size_t i = 0; i &lt; _preserved_count; i++) {
182     _preserved_marks[i].adjust_pointer();
183   }
184 
185   // deal with the overflow stack
186   StackIterator&lt;oop, mtGC&gt; iter(_preserved_oop_stack);
187   while (!iter.is_empty()) {
188     oop* p = iter.next_addr();
189     adjust_pointer(p);
190   }
191 }
192 
193 void MarkSweep::restore_marks() {
194   assert(_preserved_oop_stack.size() == _preserved_mark_stack.size(),
195          &quot;inconsistent preserved oop stacks&quot;);
196   log_trace(gc)(&quot;Restoring &quot; SIZE_FORMAT &quot; marks&quot;, _preserved_count + _preserved_oop_stack.size());
197 
198   // restore the marks we saved earlier
199   for (size_t i = 0; i &lt; _preserved_count; i++) {
200     _preserved_marks[i].restore();
201   }
202 
203   // deal with the overflow
204   while (!_preserved_oop_stack.is_empty()) {
205     oop obj       = _preserved_oop_stack.pop();
<a name="7" id="anc7"></a><span class="line-modified">206     markOop mark  = _preserved_mark_stack.pop();</span>
207     obj-&gt;set_mark_raw(mark);
208   }
209 }
210 
211 MarkSweep::IsAliveClosure   MarkSweep::is_alive;
212 
213 bool MarkSweep::IsAliveClosure::do_object_b(oop p) { return p-&gt;is_gc_marked(); }
214 
215 MarkSweep::KeepAliveClosure MarkSweep::keep_alive;
216 
217 void MarkSweep::KeepAliveClosure::do_oop(oop* p)       { MarkSweep::KeepAliveClosure::do_oop_work(p); }
218 void MarkSweep::KeepAliveClosure::do_oop(narrowOop* p) { MarkSweep::KeepAliveClosure::do_oop_work(p); }
219 
220 void MarkSweep::initialize() {
221   MarkSweep::_gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
222   MarkSweep::_gc_tracer = new (ResourceObj::C_HEAP, mtGC) SerialOldTracer();
223 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/serial/markSweep.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/shared/gcTrace.hpp&quot;
 31 #include &quot;memory/iterator.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/compressedOops.inline.hpp&quot;
 35 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
 36 #include &quot;oops/instanceKlass.inline.hpp&quot;
 37 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceRefKlass.inline.hpp&quot;
 39 #include &quot;oops/methodData.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/oop.inline.hpp&quot;
 42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 43 #include &quot;utilities/macros.hpp&quot;
 44 #include &quot;utilities/stack.inline.hpp&quot;
 45 
 46 uint                    MarkSweep::_total_invocations = 0;
 47 
 48 Stack&lt;oop, mtGC&gt;              MarkSweep::_marking_stack;
 49 Stack&lt;ObjArrayTask, mtGC&gt;     MarkSweep::_objarray_stack;
 50 
 51 Stack&lt;oop, mtGC&gt;              MarkSweep::_preserved_oop_stack;
<a name="2" id="anc2"></a><span class="line-modified"> 52 Stack&lt;markWord, mtGC&gt;         MarkSweep::_preserved_mark_stack;</span>
 53 size_t                  MarkSweep::_preserved_count = 0;
 54 size_t                  MarkSweep::_preserved_count_max = 0;
 55 PreservedMark*          MarkSweep::_preserved_marks = NULL;
 56 ReferenceProcessor*     MarkSweep::_ref_processor   = NULL;
 57 STWGCTimer*             MarkSweep::_gc_timer        = NULL;
 58 SerialOldTracer*        MarkSweep::_gc_tracer       = NULL;
 59 
 60 MarkSweep::FollowRootClosure  MarkSweep::follow_root_closure;
 61 
 62 MarkAndPushClosure MarkSweep::mark_and_push_closure;
 63 CLDToOopClosure    MarkSweep::follow_cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
 64 CLDToOopClosure    MarkSweep::adjust_cld_closure(&amp;adjust_pointer_closure, ClassLoaderData::_claim_strong);
 65 
 66 template &lt;class T&gt; inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {
 67   mark_and_push(p);
 68 }
 69 
 70 void MarkSweep::push_objarray(oop obj, size_t index) {
 71   ObjArrayTask task(obj, index);
 72   assert(task.is_valid(), &quot;bad ObjArrayTask&quot;);
 73   _objarray_stack.push(task);
 74 }
 75 
 76 inline void MarkSweep::follow_array(objArrayOop array) {
 77   MarkSweep::follow_klass(array-&gt;klass());
 78   // Don&#39;t push empty arrays to avoid unnecessary work.
 79   if (array-&gt;length() &gt; 0) {
 80     MarkSweep::push_objarray(array, 0);
 81   }
 82 }
 83 
 84 inline void MarkSweep::follow_object(oop obj) {
 85   assert(obj-&gt;is_gc_marked(), &quot;should be marked&quot;);
 86   if (obj-&gt;is_objArray()) {
 87     // Handle object arrays explicitly to allow them to
 88     // be split into chunks if needed.
 89     MarkSweep::follow_array((objArrayOop)obj);
 90   } else {
 91     obj-&gt;oop_iterate(&amp;mark_and_push_closure);
 92   }
 93 }
 94 
 95 void MarkSweep::follow_array_chunk(objArrayOop array, int index) {
 96   const int len = array-&gt;length();
 97   const int beg_index = index;
 98   assert(beg_index &lt; len || len == 0, &quot;index too large&quot;);
 99 
100   const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);
101   const int end_index = beg_index + stride;
102 
103   array-&gt;oop_iterate_range(&amp;mark_and_push_closure, beg_index, end_index);
104 
105   if (end_index &lt; len) {
106     MarkSweep::push_objarray(array, end_index); // Push the continuation.
107   }
108 }
109 
110 void MarkSweep::follow_stack() {
111   do {
112     while (!_marking_stack.is_empty()) {
113       oop obj = _marking_stack.pop();
114       assert (obj-&gt;is_gc_marked(), &quot;p must be marked&quot;);
115       follow_object(obj);
116     }
117     // Process ObjArrays one at a time to avoid marking stack bloat.
118     if (!_objarray_stack.is_empty()) {
119       ObjArrayTask task = _objarray_stack.pop();
120       follow_array_chunk(objArrayOop(task.obj()), task.index());
121     }
122   } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());
123 }
124 
125 MarkSweep::FollowStackClosure MarkSweep::follow_stack_closure;
126 
127 void MarkSweep::FollowStackClosure::do_void() { follow_stack(); }
128 
129 template &lt;class T&gt; inline void MarkSweep::follow_root(T* p) {
<a name="3" id="anc3"></a><span class="line-modified">130   assert(!Universe::heap()-&gt;is_in(p),</span>
131          &quot;roots shouldn&#39;t be things within the heap&quot;);
132   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
133   if (!CompressedOops::is_null(heap_oop)) {
134     oop obj = CompressedOops::decode_not_null(heap_oop);
<a name="4" id="anc4"></a><span class="line-modified">135     if (!obj-&gt;mark_raw().is_marked()) {</span>
136       mark_object(obj);
137       follow_object(obj);
138     }
139   }
140   follow_stack();
141 }
142 
143 void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }
144 void MarkSweep::FollowRootClosure::do_oop(narrowOop* p) { follow_root(p); }
145 
146 void PreservedMark::adjust_pointer() {
147   MarkSweep::adjust_pointer(&amp;_obj);
148 }
149 
150 void PreservedMark::restore() {
151   _obj-&gt;set_mark_raw(_mark);
152 }
153 
154 // We preserve the mark which should be replaced at the end and the location
<a name="5" id="anc5"></a><span class="line-modified">155 // that it will go.  Note that the object that this markWord belongs to isn&#39;t</span>
156 // currently at that address but it will be after phase4
<a name="6" id="anc6"></a><span class="line-modified">157 void MarkSweep::preserve_mark(oop obj, markWord mark) {</span>
158   // We try to store preserved marks in the to space of the new generation since
159   // this is storage which should be available.  Most of the time this should be
160   // sufficient space for the marks we need to preserve but if it isn&#39;t we fall
161   // back to using Stacks to keep track of the overflow.
162   if (_preserved_count &lt; _preserved_count_max) {
163     _preserved_marks[_preserved_count++].init(obj, mark);
164   } else {
165     _preserved_mark_stack.push(mark);
166     _preserved_oop_stack.push(obj);
167   }
168 }
169 
170 void MarkSweep::set_ref_processor(ReferenceProcessor* rp) {
171   _ref_processor = rp;
172   mark_and_push_closure.set_ref_discoverer(_ref_processor);
173 }
174 
175 AdjustPointerClosure MarkSweep::adjust_pointer_closure;
176 
177 void MarkSweep::adjust_marks() {
178   assert( _preserved_oop_stack.size() == _preserved_mark_stack.size(),
179          &quot;inconsistent preserved oop stacks&quot;);
180 
181   // adjust the oops we saved earlier
182   for (size_t i = 0; i &lt; _preserved_count; i++) {
183     _preserved_marks[i].adjust_pointer();
184   }
185 
186   // deal with the overflow stack
187   StackIterator&lt;oop, mtGC&gt; iter(_preserved_oop_stack);
188   while (!iter.is_empty()) {
189     oop* p = iter.next_addr();
190     adjust_pointer(p);
191   }
192 }
193 
194 void MarkSweep::restore_marks() {
195   assert(_preserved_oop_stack.size() == _preserved_mark_stack.size(),
196          &quot;inconsistent preserved oop stacks&quot;);
197   log_trace(gc)(&quot;Restoring &quot; SIZE_FORMAT &quot; marks&quot;, _preserved_count + _preserved_oop_stack.size());
198 
199   // restore the marks we saved earlier
200   for (size_t i = 0; i &lt; _preserved_count; i++) {
201     _preserved_marks[i].restore();
202   }
203 
204   // deal with the overflow
205   while (!_preserved_oop_stack.is_empty()) {
206     oop obj       = _preserved_oop_stack.pop();
<a name="7" id="anc7"></a><span class="line-modified">207     markWord mark = _preserved_mark_stack.pop();</span>
208     obj-&gt;set_mark_raw(mark);
209   }
210 }
211 
212 MarkSweep::IsAliveClosure   MarkSweep::is_alive;
213 
214 bool MarkSweep::IsAliveClosure::do_object_b(oop p) { return p-&gt;is_gc_marked(); }
215 
216 MarkSweep::KeepAliveClosure MarkSweep::keep_alive;
217 
218 void MarkSweep::KeepAliveClosure::do_oop(oop* p)       { MarkSweep::KeepAliveClosure::do_oop_work(p); }
219 void MarkSweep::KeepAliveClosure::do_oop(narrowOop* p) { MarkSweep::KeepAliveClosure::do_oop_work(p); }
220 
221 void MarkSweep::initialize() {
222   MarkSweep::_gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();
223   MarkSweep::_gc_tracer = new (ResourceObj::C_HEAP, mtGC) SerialOldTracer();
224 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
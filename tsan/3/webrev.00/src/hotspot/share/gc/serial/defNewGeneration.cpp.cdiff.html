<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/serial/defNewGeneration.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cSpaceCounters.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="defNewGeneration.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/serial/defNewGeneration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;gc/serial/tenuredGeneration.hpp&quot;
  #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  #include &quot;gc/shared/ageTable.inline.hpp&quot;
  #include &quot;gc/shared/cardTableRS.hpp&quot;
  #include &quot;gc/shared/collectorCounters.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTrace.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,19 ***</span>
  #include &quot;gc/shared/generationSpec.hpp&quot;
  #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  #include &quot;gc/shared/referencePolicy.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
  #include &quot;gc/shared/weakProcessor.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/instanceRefKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
<span class="line-new-header">--- 41,18 ---</span>
  #include &quot;gc/shared/generationSpec.hpp&quot;
  #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  #include &quot;gc/shared/referencePolicy.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
  #include &quot;gc/shared/weakProcessor.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/instanceRefKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,16 ***</span>
  // DefNewGeneration functions.
  
  // Methods of protected closure types.
  
  DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {
<span class="line-modified">!   assert(_young_gen-&gt;kind() == Generation::ParNew ||</span>
<span class="line-removed">-          _young_gen-&gt;kind() == Generation::DefNew, &quot;Expected the young generation here&quot;);</span>
  }
  
  bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {
<span class="line-modified">!   return (HeapWord*)p &gt;= _young_gen-&gt;reserved().end() || p-&gt;is_forwarded();</span>
  }
  
  DefNewGeneration::KeepAliveClosure::
  KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {
    _rs = GenCollectedHeap::heap()-&gt;rem_set();
<span class="line-new-header">--- 63,15 ---</span>
  // DefNewGeneration functions.
  
  // Methods of protected closure types.
  
  DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {
<span class="line-modified">!   assert(_young_gen-&gt;kind() == Generation::DefNew, &quot;Expected the young generation here&quot;);</span>
  }
  
  bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {
<span class="line-modified">!   return cast_from_oop&lt;HeapWord*&gt;(p) &gt;= _young_gen-&gt;reserved().end() || p-&gt;is_forwarded();</span>
  }
  
  DefNewGeneration::KeepAliveClosure::
  KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {
    _rs = GenCollectedHeap::heap()-&gt;rem_set();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,10 ***</span>
<span class="line-new-header">--- 148,12 ---</span>
    _boundary = _g-&gt;reserved().end();
  }
  
  DefNewGeneration::DefNewGeneration(ReservedSpace rs,
                                     size_t initial_size,
<span class="line-added">+                                    size_t min_size,</span>
<span class="line-added">+                                    size_t max_size,</span>
                                     const char* policy)
    : Generation(rs, initial_size),
      _preserved_marks_set(false /* in_c_heap */),
      _promo_failure_drain_in_progress(false),
      _should_allocate_from_space(false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,28 ***</span>
  
    _eden_space = new ContiguousSpace();
    _from_space = new ContiguousSpace();
    _to_space   = new ContiguousSpace();
  
<span class="line-removed">-   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not allocate a new gen space&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Compute the maximum eden and survivor space sizes. These sizes
    // are computed assuming the entire reserved space is committed.
    // These values are exported as performance counters.
<span class="line-removed">-   uintx alignment = gch-&gt;collector_policy()-&gt;space_alignment();</span>
    uintx size = _virtual_space.reserved_size();
<span class="line-modified">!   _max_survivor_size = compute_survivor_size(size, alignment);</span>
    _max_eden_size = size - (2*_max_survivor_size);
  
    // allocate the performance counters
<span class="line-removed">-   GenCollectorPolicy* gcp = gch-&gt;gen_policy();</span>
  
    // Generation counters -- generation 0, 3 subspaces
    _gen_counters = new GenerationCounters(&quot;new&quot;, 0, 3,
<span class="line-modified">!       gcp-&gt;min_young_size(), gcp-&gt;max_young_size(), &amp;_virtual_space);</span>
    _gc_counters = new CollectorCounters(policy, 0);
  
    _eden_counters = new CSpaceCounters(&quot;eden&quot;, 0, _max_eden_size, _eden_space,
                                        _gen_counters);
    _from_counters = new CSpaceCounters(&quot;s0&quot;, 1, _max_survivor_size, _from_space,
<span class="line-new-header">--- 166,22 ---</span>
  
    _eden_space = new ContiguousSpace();
    _from_space = new ContiguousSpace();
    _to_space   = new ContiguousSpace();
  
    // Compute the maximum eden and survivor space sizes. These sizes
    // are computed assuming the entire reserved space is committed.
    // These values are exported as performance counters.
    uintx size = _virtual_space.reserved_size();
<span class="line-modified">!   _max_survivor_size = compute_survivor_size(size, SpaceAlignment);</span>
    _max_eden_size = size - (2*_max_survivor_size);
  
    // allocate the performance counters
  
    // Generation counters -- generation 0, 3 subspaces
    _gen_counters = new GenerationCounters(&quot;new&quot;, 0, 3,
<span class="line-modified">!       min_size, max_size, &amp;_virtual_space);</span>
    _gc_counters = new CollectorCounters(policy, 0);
  
    _eden_counters = new CSpaceCounters(&quot;eden&quot;, 0, _max_eden_size, _eden_space,
                                        _gen_counters);
    _from_counters = new CSpaceCounters(&quot;s0&quot;, 1, _max_survivor_size, _from_space,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,33 ***</span>
  }
  
  void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,
                                                  bool clear_space,
                                                  bool mangle_space) {
<span class="line-removed">-   uintx alignment =</span>
<span class="line-removed">-     GenCollectedHeap::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
<span class="line-removed">- </span>
    // If the spaces are being cleared (only done at heap initialization
    // currently), the survivor spaces need not be empty.
    // Otherwise, no care is taken for used areas in the survivor spaces
    // so check.
    assert(clear_space || (to()-&gt;is_empty() &amp;&amp; from()-&gt;is_empty()),
      &quot;Initialization of the survivor spaces assumes these are empty&quot;);
  
    // Compute sizes
    uintx size = _virtual_space.committed_size();
<span class="line-modified">!   uintx survivor_size = compute_survivor_size(size, alignment);</span>
    uintx eden_size = size - (2*survivor_size);
    assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
  
    if (eden_size &lt; minimum_eden_size) {
      // May happen due to 64Kb rounding, if so adjust eden size back up
<span class="line-modified">!     minimum_eden_size = align_up(minimum_eden_size, alignment);</span>
      uintx maximum_survivor_size = (size - minimum_eden_size) / 2;
      uintx unaligned_survivor_size =
<span class="line-modified">!       align_down(maximum_survivor_size, alignment);</span>
<span class="line-modified">!     survivor_size = MAX2(unaligned_survivor_size, alignment);</span>
      eden_size = size - (2*survivor_size);
      assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
      assert(eden_size &gt;= minimum_eden_size, &quot;just checking&quot;);
    }
  
<span class="line-new-header">--- 199,30 ---</span>
  }
  
  void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,
                                                  bool clear_space,
                                                  bool mangle_space) {
    // If the spaces are being cleared (only done at heap initialization
    // currently), the survivor spaces need not be empty.
    // Otherwise, no care is taken for used areas in the survivor spaces
    // so check.
    assert(clear_space || (to()-&gt;is_empty() &amp;&amp; from()-&gt;is_empty()),
      &quot;Initialization of the survivor spaces assumes these are empty&quot;);
  
    // Compute sizes
    uintx size = _virtual_space.committed_size();
<span class="line-modified">!   uintx survivor_size = compute_survivor_size(size, SpaceAlignment);</span>
    uintx eden_size = size - (2*survivor_size);
    assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
  
    if (eden_size &lt; minimum_eden_size) {
      // May happen due to 64Kb rounding, if so adjust eden size back up
<span class="line-modified">!     minimum_eden_size = align_up(minimum_eden_size, SpaceAlignment);</span>
      uintx maximum_survivor_size = (size - minimum_eden_size) / 2;
      uintx unaligned_survivor_size =
<span class="line-modified">!       align_down(maximum_survivor_size, SpaceAlignment);</span>
<span class="line-modified">!     survivor_size = MAX2(unaligned_survivor_size, SpaceAlignment);</span>
      eden_size = size - (2*survivor_size);
      assert(eden_size &gt; 0 &amp;&amp; survivor_size &lt;= eden_size, &quot;just checking&quot;);
      assert(eden_size &gt;= minimum_eden_size, &quot;just checking&quot;);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,11 ***</span>
    // Compute desired new generation size based on NewRatio and NewSizeThreadIncrease
    // and reverts to previous value if any overflow happens
    size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before, alignment);
  
    // Adjust new generation size
<span class="line-modified">!   desired_new_size = MAX2(MIN2(desired_new_size, max_new_size), min_new_size);</span>
    assert(desired_new_size &lt;= max_new_size, &quot;just checking&quot;);
  
    bool changed = false;
    if (desired_new_size &gt; new_size_before) {
      size_t change = desired_new_size - new_size_before;
<span class="line-new-header">--- 385,11 ---</span>
    // Compute desired new generation size based on NewRatio and NewSizeThreadIncrease
    // and reverts to previous value if any overflow happens
    size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before, alignment);
  
    // Adjust new generation size
<span class="line-modified">!   desired_new_size = clamp(desired_new_size, min_new_size, max_new_size);</span>
    assert(desired_new_size &lt;= max_new_size, &quot;just checking&quot;);
  
    bool changed = false;
    if (desired_new_size &gt; new_size_before) {
      size_t change = desired_new_size - new_size_before;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,13 ***</span>
    return eden()-&gt;free()
         + from()-&gt;free();      // to() is only used during scavenge
  }
  
  size_t DefNewGeneration::max_capacity() const {
<span class="line-removed">-   const size_t alignment = GenCollectedHeap::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
    const size_t reserved_bytes = reserved().byte_size();
<span class="line-modified">!   return reserved_bytes - compute_survivor_size(reserved_bytes, alignment);</span>
  }
  
  size_t DefNewGeneration::unsafe_max_alloc_nogc() const {
    return eden()-&gt;free();
  }
<span class="line-new-header">--- 451,12 ---</span>
    return eden()-&gt;free()
         + from()-&gt;free();      // to() is only used during scavenge
  }
  
  size_t DefNewGeneration::max_capacity() const {
    const size_t reserved_bytes = reserved().byte_size();
<span class="line-modified">!   return reserved_bytes - compute_survivor_size(reserved_bytes, SpaceAlignment);</span>
  }
  
  size_t DefNewGeneration::unsafe_max_alloc_nogc() const {
    return eden()-&gt;free();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,12 ***</span>
    from()-&gt;object_iterate(&amp;rspc);
    restore_preserved_marks();
  }
  
  void DefNewGeneration::restore_preserved_marks() {
<span class="line-modified">!   SharedRestorePreservedMarksTaskExecutor task_executor(NULL);</span>
<span class="line-removed">-   _preserved_marks_set.restore(&amp;task_executor);</span>
  }
  
  void DefNewGeneration::handle_promotion_failure(oop old) {
    log_debug(gc, promotion)(&quot;Promotion failure size = %d) &quot;, old-&gt;size());
  
<span class="line-new-header">--- 705,11 ---</span>
    from()-&gt;object_iterate(&amp;rspc);
    restore_preserved_marks();
  }
  
  void DefNewGeneration::restore_preserved_marks() {
<span class="line-modified">!   _preserved_marks_set.restore(NULL);</span>
  }
  
  void DefNewGeneration::handle_promotion_failure(oop old) {
    log_debug(gc, promotion)(&quot;Promotion failure size = %d) &quot;, old-&gt;size());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 761,11 ***</span>
      // Prefetch beyond obj
      const intx interval = PrefetchCopyIntervalInBytes;
      Prefetch::write(obj, interval);
  
      // Copy obj
<span class="line-modified">!     Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)obj, s);</span>
  
      // Increment age if obj still in new generation
      obj-&gt;incr_age();
      age_table()-&gt;add(obj, s);
    }
<span class="line-new-header">--- 751,11 ---</span>
      // Prefetch beyond obj
      const intx interval = PrefetchCopyIntervalInBytes;
      Prefetch::write(obj, interval);
  
      // Copy obj
<span class="line-modified">!     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(old), cast_from_oop&lt;HeapWord*&gt;(obj), s);</span>
  
      // Increment age if obj still in new generation
      obj-&gt;incr_age();
      age_table()-&gt;add(obj, s);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,11 ***</span>
        seen_incremental_collection_failed = true;
      } else if (seen_incremental_collection_failed) {
        log_trace(gc)(&quot;DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed&quot;,
                              GCCause::to_string(gch-&gt;gc_cause()));
        assert(gch-&gt;gc_cause() == GCCause::_scavenge_alot ||
<span class="line-removed">-              (GCCause::is_user_requested_gc(gch-&gt;gc_cause()) &amp;&amp; UseConcMarkSweepGC &amp;&amp; ExplicitGCInvokesConcurrent) ||</span>
               !gch-&gt;incremental_collection_failed(),
               &quot;Twice in a row&quot;);
        seen_incremental_collection_failed = false;
      }
  #endif // ASSERT
<span class="line-new-header">--- 875,10 ---</span>
</pre>
<center><a href="cSpaceCounters.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="defNewGeneration.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
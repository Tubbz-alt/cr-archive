<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
109 
110   const char* type_string()                      { return &quot;ciMethod&quot;; }
111 
112   void print_impl(outputStream* st);
113 
114   void load_code();
115 
116   bool ensure_method_data(const methodHandle&amp; h_m);
117 
118   void code_at_put(int bci, Bytecodes::Code code) {
119     Bytecodes::check(code);
120     assert(0 &lt;= bci &amp;&amp; bci &lt; code_size(), &quot;valid bci&quot;);
121     address bcp = _code + bci;
122     *bcp = code;
123   }
124 
125   // Check bytecode and profile data collected are compatible
126   void assert_virtual_call_type_ok(int bci);
127   void assert_call_type_ok(int bci);
128 



129  public:
130   void check_is_loaded() const                   { assert(is_loaded(), &quot;not loaded&quot;); }
131 
132   // Basic method information.
133   ciFlags flags() const                          { check_is_loaded(); return _flags; }
134   ciSymbol* name() const                         { return _name; }
135   ciInstanceKlass* holder() const                { return _holder; }
136   ciMethodData* method_data();
137   ciMethodData* method_data_or_null();
138 
139   // Signature information.
140   ciSignature* signature() const                 { return _signature; }
141   ciType*      return_type() const               { return _signature-&gt;return_type(); }
142   int          arg_size_no_receiver() const      { return _signature-&gt;size(); }
143   // Can only be used on loaded ciMethods
144   int          arg_size() const                  {
145     check_is_loaded();
146     return _signature-&gt;size() + (_flags.is_static() ? 0 : 1);
147   }
148   // Report the number of elements on stack when invoking the current method.
</pre>
<hr />
<pre>
228   bool          has_balanced_monitors();
229 
230   // Returns a bitmap indicating which locals are required to be
231   // maintained as live for deopt.  raw_liveness_at_bci is always the
232   // direct output of the liveness computation while liveness_at_bci
233   // may mark all locals as live to improve support for debugging Java
234   // code by maintaining the state of as many locals as possible.
235   MethodLivenessResult raw_liveness_at_bci(int bci);
236   MethodLivenessResult liveness_at_bci(int bci);
237 
238   // Get the interpreters viewpoint on oop liveness.  MethodLiveness is
239   // conservative in the sense that it may consider locals to be live which
240   // cannot be live, like in the case where a local could contain an oop or
241   // a primitive along different paths.  In that case the local must be
242   // dead when those paths merge. Since the interpreter&#39;s viewpoint is
243   // used when gc&#39;ing an interpreter frame we need to use its viewpoint
244   // during OSR when loading the locals.
245 
246   ResourceBitMap live_local_oops_at_bci(int bci);
247 


248 #ifdef COMPILER1
249   const BitMap&amp; bci_block_start();
250 #endif
251 
252   ciTypeFlow*   get_flow_analysis();
253   ciTypeFlow*   get_osr_flow_analysis(int osr_bci);  // alternate entry point
254   ciCallProfile call_profile_at_bci(int bci);
255   int           interpreter_call_site_count(int bci);
256 
257   // Does type profiling provide any useful information at this point?
258   bool          argument_profiled_type(int bci, int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
259   bool          parameter_profiled_type(int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
260   bool          return_profiled_type(int bci, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
261 
262   ciField*      get_field_at_bci( int bci, bool &amp;will_link);
263   ciMethod*     get_method_at_bci(int bci, bool &amp;will_link, ciSignature* *declared_signature);
264   ciMethod*     get_method_at_bci(int bci) {
265     bool ignored_will_link;
266     ciSignature* ignored_declared_signature;
267     return get_method_at_bci(bci, ignored_will_link, &amp;ignored_declared_signature);
</pre>
<hr />
<pre>
335 
336   // Other flags
337   bool is_empty_method() const;
338   bool is_vanilla_constructor() const;
339   bool is_final_method() const                   { return is_final() || holder()-&gt;is_final(); }
340   bool is_default_method() const                 { return !is_abstract() &amp;&amp; !is_private() &amp;&amp;
341                                                           holder()-&gt;is_interface(); }
342   bool is_overpass    () const                   { check_is_loaded(); return _is_overpass; }
343   bool has_loops      () const;
344   bool has_jsrs       () const;
345   bool is_getter      () const;
346   bool is_setter      () const;
347   bool is_accessor    () const;
348   bool is_initializer () const;
349   bool can_be_statically_bound() const           { return _can_be_statically_bound; }
350   bool has_reserved_stack_access() const         { return _has_reserved_stack_access; }
351   bool is_boxing_method() const;
352   bool is_unboxing_method() const;
353   bool is_object_initializer() const;
354 


355   // Replay data methods
356   void dump_name_as_ascii(outputStream* st);
357   void dump_replay_data(outputStream* st);
358 
359   // Print the bytecodes of this method.
360   void print_codes_on(outputStream* st);
361   void print_codes() {
362     print_codes_on(tty);
363   }
364   void print_codes_on(int from, int to, outputStream* st);
365 
366   // Print the name of this method in various incarnations.
367   void print_name(outputStream* st = tty);
368   void print_short_name(outputStream* st = tty);
369 
370   static bool is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method);
371 };
372 
373 #endif // SHARE_CI_CIMETHOD_HPP
</pre>
</td>
<td>
<hr />
<pre>
109 
110   const char* type_string()                      { return &quot;ciMethod&quot;; }
111 
112   void print_impl(outputStream* st);
113 
114   void load_code();
115 
116   bool ensure_method_data(const methodHandle&amp; h_m);
117 
118   void code_at_put(int bci, Bytecodes::Code code) {
119     Bytecodes::check(code);
120     assert(0 &lt;= bci &amp;&amp; bci &lt; code_size(), &quot;valid bci&quot;);
121     address bcp = _code + bci;
122     *bcp = code;
123   }
124 
125   // Check bytecode and profile data collected are compatible
126   void assert_virtual_call_type_ok(int bci);
127   void assert_call_type_ok(int bci);
128 
<span class="line-added">129   // Check and update the profile counter in case of overflow</span>
<span class="line-added">130   static int check_overflow(int c, Bytecodes::Code code);</span>
<span class="line-added">131 </span>
132  public:
133   void check_is_loaded() const                   { assert(is_loaded(), &quot;not loaded&quot;); }
134 
135   // Basic method information.
136   ciFlags flags() const                          { check_is_loaded(); return _flags; }
137   ciSymbol* name() const                         { return _name; }
138   ciInstanceKlass* holder() const                { return _holder; }
139   ciMethodData* method_data();
140   ciMethodData* method_data_or_null();
141 
142   // Signature information.
143   ciSignature* signature() const                 { return _signature; }
144   ciType*      return_type() const               { return _signature-&gt;return_type(); }
145   int          arg_size_no_receiver() const      { return _signature-&gt;size(); }
146   // Can only be used on loaded ciMethods
147   int          arg_size() const                  {
148     check_is_loaded();
149     return _signature-&gt;size() + (_flags.is_static() ? 0 : 1);
150   }
151   // Report the number of elements on stack when invoking the current method.
</pre>
<hr />
<pre>
231   bool          has_balanced_monitors();
232 
233   // Returns a bitmap indicating which locals are required to be
234   // maintained as live for deopt.  raw_liveness_at_bci is always the
235   // direct output of the liveness computation while liveness_at_bci
236   // may mark all locals as live to improve support for debugging Java
237   // code by maintaining the state of as many locals as possible.
238   MethodLivenessResult raw_liveness_at_bci(int bci);
239   MethodLivenessResult liveness_at_bci(int bci);
240 
241   // Get the interpreters viewpoint on oop liveness.  MethodLiveness is
242   // conservative in the sense that it may consider locals to be live which
243   // cannot be live, like in the case where a local could contain an oop or
244   // a primitive along different paths.  In that case the local must be
245   // dead when those paths merge. Since the interpreter&#39;s viewpoint is
246   // used when gc&#39;ing an interpreter frame we need to use its viewpoint
247   // during OSR when loading the locals.
248 
249   ResourceBitMap live_local_oops_at_bci(int bci);
250 
<span class="line-added">251   bool needs_clinit_barrier() const;</span>
<span class="line-added">252 </span>
253 #ifdef COMPILER1
254   const BitMap&amp; bci_block_start();
255 #endif
256 
257   ciTypeFlow*   get_flow_analysis();
258   ciTypeFlow*   get_osr_flow_analysis(int osr_bci);  // alternate entry point
259   ciCallProfile call_profile_at_bci(int bci);
260   int           interpreter_call_site_count(int bci);
261 
262   // Does type profiling provide any useful information at this point?
263   bool          argument_profiled_type(int bci, int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
264   bool          parameter_profiled_type(int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
265   bool          return_profiled_type(int bci, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
266 
267   ciField*      get_field_at_bci( int bci, bool &amp;will_link);
268   ciMethod*     get_method_at_bci(int bci, bool &amp;will_link, ciSignature* *declared_signature);
269   ciMethod*     get_method_at_bci(int bci) {
270     bool ignored_will_link;
271     ciSignature* ignored_declared_signature;
272     return get_method_at_bci(bci, ignored_will_link, &amp;ignored_declared_signature);
</pre>
<hr />
<pre>
340 
341   // Other flags
342   bool is_empty_method() const;
343   bool is_vanilla_constructor() const;
344   bool is_final_method() const                   { return is_final() || holder()-&gt;is_final(); }
345   bool is_default_method() const                 { return !is_abstract() &amp;&amp; !is_private() &amp;&amp;
346                                                           holder()-&gt;is_interface(); }
347   bool is_overpass    () const                   { check_is_loaded(); return _is_overpass; }
348   bool has_loops      () const;
349   bool has_jsrs       () const;
350   bool is_getter      () const;
351   bool is_setter      () const;
352   bool is_accessor    () const;
353   bool is_initializer () const;
354   bool can_be_statically_bound() const           { return _can_be_statically_bound; }
355   bool has_reserved_stack_access() const         { return _has_reserved_stack_access; }
356   bool is_boxing_method() const;
357   bool is_unboxing_method() const;
358   bool is_object_initializer() const;
359 
<span class="line-added">360   bool can_be_statically_bound(ciInstanceKlass* context) const;</span>
<span class="line-added">361 </span>
362   // Replay data methods
363   void dump_name_as_ascii(outputStream* st);
364   void dump_replay_data(outputStream* st);
365 
366   // Print the bytecodes of this method.
367   void print_codes_on(outputStream* st);
368   void print_codes() {
369     print_codes_on(tty);
370   }
371   void print_codes_on(int from, int to, outputStream* st);
372 
373   // Print the name of this method in various incarnations.
374   void print_name(outputStream* st = tty);
375   void print_short_name(outputStream* st = tty);
376 
377   static bool is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method);
378 };
379 
380 #endif // SHARE_CI_CIMETHOD_HPP
</pre>
</td>
</tr>
</table>
<center><a href="ciMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
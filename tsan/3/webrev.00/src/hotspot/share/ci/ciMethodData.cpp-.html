<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/ci/ciMethodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciMetadata.hpp&quot;
 27 #include &quot;ci/ciMethodData.hpp&quot;
 28 #include &quot;ci/ciReplay.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/deoptimization.hpp&quot;
 33 #include &quot;utilities/copy.hpp&quot;
 34 
 35 // ciMethodData
 36 
 37 // ------------------------------------------------------------------
 38 // ciMethodData::ciMethodData
 39 //
 40 ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md) {
 41   assert(md != NULL, &quot;no null method data&quot;);
 42   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 43   _data = NULL;
 44   _data_size = 0;
 45   _extra_data_size = 0;
 46   _current_mileage = 0;
 47   _invocation_counter = 0;
 48   _backedge_counter = 0;
 49   _state = empty_state;
 50   _saw_free_extra_data = false;
 51   // Set an initial hint. Don&#39;t use set_hint_di() because
 52   // first_di() may be out of bounds if data_size is 0.
 53   _hint_di = first_di();
 54   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 55   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 56   _parameters = NULL;
 57 }
 58 
 59 // ------------------------------------------------------------------
 60 // ciMethodData::ciMethodData
 61 //
 62 // No MethodData*.
 63 ciMethodData::ciMethodData() : ciMetadata(NULL) {
 64   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 65   _data = NULL;
 66   _data_size = 0;
 67   _extra_data_size = 0;
 68   _current_mileage = 0;
 69   _invocation_counter = 0;
 70   _backedge_counter = 0;
 71   _state = empty_state;
 72   _saw_free_extra_data = false;
 73   // Set an initial hint. Don&#39;t use set_hint_di() because
 74   // first_di() may be out of bounds if data_size is 0.
 75   _hint_di = first_di();
 76   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 77   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 78   _parameters = NULL;
 79 }
 80 
 81 // Check for entries that reference an unloaded method
 82 class PrepareExtraDataClosure : public CleanExtraDataClosure {
 83   MethodData*            _mdo;
 84   uint64_t               _safepoint_counter;
 85   GrowableArray&lt;Method*&gt; _uncached_methods;
 86 
 87 public:
 88   PrepareExtraDataClosure(MethodData* mdo)
 89     : _mdo(mdo),
 90       _safepoint_counter(SafepointSynchronize::safepoint_counter()),
 91       _uncached_methods()
 92   { }
 93 
 94   bool is_live(Method* m) {
 95     if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
 96       return false;
 97     }
 98     if (CURRENT_ENV-&gt;cached_metadata(m) == NULL) {
 99       // Uncached entries need to be pre-populated.
100       _uncached_methods.append(m);
101     }
102     return true;
103   }
104 
105   bool has_safepointed() {
106     return SafepointSynchronize::safepoint_counter() != _safepoint_counter;
107   }
108 
109   bool finish() {
110     if (_uncached_methods.length() == 0) {
111       // Preparation finished iff all Methods* were already cached.
112       return true;
113     }
114     // Holding locks through safepoints is bad practice.
115     MutexUnlocker mu(_mdo-&gt;extra_data_lock());
116     for (int i = 0; i &lt; _uncached_methods.length(); ++i) {
117       if (has_safepointed()) {
118         // The metadata in the growable array might contain stale
119         // entries after a safepoint.
120         return false;
121       }
122       Method* method = _uncached_methods.at(i);
123       // Populating ciEnv caches may cause safepoints due
124       // to taking the Compile_lock with safepoint checks.
125       (void)CURRENT_ENV-&gt;get_method(method);
126     }
127     return false;
128   }
129 };
130 
131 void ciMethodData::prepare_metadata() {
132   MethodData* mdo = get_MethodData();
133 
134   for (;;) {
135     ResourceMark rm;
136     PrepareExtraDataClosure cl(mdo);
137     mdo-&gt;clean_extra_data(&amp;cl);
138     if (cl.finish()) {
139       // When encountering uncached metadata, the Compile_lock might be
140       // acquired when creating ciMetadata handles, causing safepoints
141       // which requires a new round of preparation to clean out potentially
142       // new unloading metadata.
143       return;
144     }
145   }
146 }
147 
148 void ciMethodData::load_extra_data() {
149   MethodData* mdo = get_MethodData();
150   MutexLocker ml(mdo-&gt;extra_data_lock());
151   // Deferred metadata cleaning due to concurrent class unloading.
152   prepare_metadata();
153   // After metadata preparation, there is no stale metadata,
154   // and no safepoints can introduce more stale metadata.
155   NoSafepointVerifier no_safepoint;
156 
157   // speculative trap entries also hold a pointer to a Method so need to be translated
158   DataLayout* dp_src  = mdo-&gt;extra_data_base();
159   DataLayout* end_src = mdo-&gt;args_data_limit();
160   DataLayout* dp_dst  = extra_data_base();
161   for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
162     assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
163     assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
164 
165     // New traps in the MDO may have been added since we copied the
166     // data (concurrent deoptimizations before we acquired
167     // extra_data_lock above) or can be removed (a safepoint may occur
168     // in the prepare_metadata call above) as we translate the copy:
169     // update the copy as we go.
170     int tag = dp_src-&gt;tag();
171     size_t entry_size = DataLayout::header_size_in_bytes();
172     if (tag != DataLayout::no_tag) {
173       ProfileData* src_data = dp_src-&gt;data_in();
174       entry_size = src_data-&gt;size_in_bytes();
175     }
176     memcpy(dp_dst, dp_src, entry_size);
177 
178     switch(tag) {
179     case DataLayout::speculative_trap_data_tag: {
180       ciSpeculativeTrapData data_dst(dp_dst);
181       SpeculativeTrapData   data_src(dp_src);
182       data_dst.translate_from(&amp;data_src);
183       break;
184     }
185     case DataLayout::bit_data_tag:
186       break;
187     case DataLayout::no_tag:
188     case DataLayout::arg_info_data_tag:
189       // An empty slot or ArgInfoData entry marks the end of the trap data
190       {
191         return; // Need a block to avoid SS compiler bug
192       }
193     default:
194       fatal(&quot;bad tag = %d&quot;, tag);
195     }
196   }
197 }
198 
199 void ciMethodData::load_data() {
200   MethodData* mdo = get_MethodData();
201   if (mdo == NULL) {
202     return;
203   }
204 
205   // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
206   // of invocations.
207 
208   // Snapshot the data -- actually, take an approximate snapshot of
209   // the data.  Any concurrently executing threads may be changing the
210   // data as we copy it.
211   Copy::disjoint_words_atomic((HeapWord*) mdo,
212                               (HeapWord*) &amp;_orig,
213                               sizeof(_orig) / HeapWordSize);
214   Arena* arena = CURRENT_ENV-&gt;arena();
215   _data_size = mdo-&gt;data_size();
216   _extra_data_size = mdo-&gt;extra_data_size();
217   int total_size = _data_size + _extra_data_size;
218   _data = (intptr_t *) arena-&gt;Amalloc(total_size);
219   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
220                               (HeapWord*) _data,
221                               total_size / HeapWordSize);
222 
223   // Traverse the profile data, translating any oops into their
224   // ci equivalents.
225   ResourceMark rm;
226   ciProfileData* ci_data = first_data();
227   ProfileData* data = mdo-&gt;first_data();
228   while (is_valid(ci_data)) {
229     ci_data-&gt;translate_from(data);
230     ci_data = next_data(ci_data);
231     data = mdo-&gt;next_data(data);
232   }
233   if (mdo-&gt;parameters_type_data() != NULL) {
234     _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
235     ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
236     parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
237   }
238 
239   load_extra_data();
240 
241   // Note:  Extra data are all BitData, and do not need translation.
242   _current_mileage = MethodData::mileage_of(mdo-&gt;method());
243   _invocation_counter = mdo-&gt;invocation_count();
244   _backedge_counter = mdo-&gt;backedge_count();
245   _state = mdo-&gt;is_mature()? mature_state: immature_state;
246 
247   _eflags = mdo-&gt;eflags();
248   _arg_local = mdo-&gt;arg_local();
249   _arg_stack = mdo-&gt;arg_stack();
250   _arg_returned  = mdo-&gt;arg_returned();
251 #ifndef PRODUCT
252   if (ReplayCompiles) {
253     ciReplay::initialize(this);
254   }
255 #endif
256 }
257 
258 void ciReceiverTypeData::translate_receiver_data_from(const ProfileData* data) {
259   for (uint row = 0; row &lt; row_limit(); row++) {
260     Klass* k = data-&gt;as_ReceiverTypeData()-&gt;receiver(row);
261     if (k != NULL) {
262       if (k-&gt;is_loader_alive()) {
263         ciKlass* klass = CURRENT_ENV-&gt;get_klass(k);
264         set_receiver(row, klass);
265       } else {
266         // With concurrent class unloading, the MDO could have stale metadata; override it
267         clear_row(row);
268       }
269     }
270   }
271 }
272 
273 void ciTypeStackSlotEntries::translate_type_data_from(const TypeStackSlotEntries* entries) {
274   for (int i = 0; i &lt; number_of_entries(); i++) {
275     intptr_t k = entries-&gt;type(i);
276     Klass* klass = (Klass*)klass_part(k);
277     if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
278       // With concurrent class unloading, the MDO could have stale metadata; override it
279       TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)NULL, k));
280     } else {
281       TypeStackSlotEntries::set_type(i, translate_klass(k));
282     }
283   }
284 }
285 
286 void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {
287   intptr_t k = ret-&gt;type();
288   Klass* klass = (Klass*)klass_part(k);
289   if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
290     // With concurrent class unloading, the MDO could have stale metadata; override it
291     set_type(ReturnTypeEntry::with_status((Klass*)NULL, k));
292   } else {
293     set_type(translate_klass(k));
294   }
295 }
296 
297 void ciSpeculativeTrapData::translate_from(const ProfileData* data) {
298   Method* m = data-&gt;as_SpeculativeTrapData()-&gt;method();
299   ciMethod* ci_m = CURRENT_ENV-&gt;get_method(m);
300   set_method(ci_m);
301 }
302 
303 // Get the data at an arbitrary (sort of) data index.
304 ciProfileData* ciMethodData::data_at(int data_index) {
305   if (out_of_bounds(data_index)) {
306     return NULL;
307   }
308   DataLayout* data_layout = data_layout_at(data_index);
309 
310   switch (data_layout-&gt;tag()) {
311   case DataLayout::no_tag:
312   default:
313     ShouldNotReachHere();
314     return NULL;
315   case DataLayout::bit_data_tag:
316     return new ciBitData(data_layout);
317   case DataLayout::counter_data_tag:
318     return new ciCounterData(data_layout);
319   case DataLayout::jump_data_tag:
320     return new ciJumpData(data_layout);
321   case DataLayout::receiver_type_data_tag:
322     return new ciReceiverTypeData(data_layout);
323   case DataLayout::virtual_call_data_tag:
324     return new ciVirtualCallData(data_layout);
325   case DataLayout::ret_data_tag:
326     return new ciRetData(data_layout);
327   case DataLayout::branch_data_tag:
328     return new ciBranchData(data_layout);
329   case DataLayout::multi_branch_data_tag:
330     return new ciMultiBranchData(data_layout);
331   case DataLayout::arg_info_data_tag:
332     return new ciArgInfoData(data_layout);
333   case DataLayout::call_type_data_tag:
334     return new ciCallTypeData(data_layout);
335   case DataLayout::virtual_call_type_data_tag:
336     return new ciVirtualCallTypeData(data_layout);
337   case DataLayout::parameters_type_data_tag:
338     return new ciParametersTypeData(data_layout);
339   };
340 }
341 
342 // Iteration over data.
343 ciProfileData* ciMethodData::next_data(ciProfileData* current) {
344   int current_index = dp_to_di(current-&gt;dp());
345   int next_index = current_index + current-&gt;size_in_bytes();
346   ciProfileData* next = data_at(next_index);
347   return next;
348 }
349 
350 ciProfileData* ciMethodData::bci_to_extra_data(int bci, ciMethod* m, bool&amp; two_free_slots) {
351   DataLayout* dp  = extra_data_base();
352   DataLayout* end = args_data_limit();
353   two_free_slots = false;
354   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
355     switch(dp-&gt;tag()) {
356     case DataLayout::no_tag:
357       _saw_free_extra_data = true;  // observed an empty slot (common case)
358       two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
359       return NULL;
360     case DataLayout::arg_info_data_tag:
361       return NULL; // ArgInfoData is at the end of extra data section.
362     case DataLayout::bit_data_tag:
363       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
364         return new ciBitData(dp);
365       }
366       break;
367     case DataLayout::speculative_trap_data_tag: {
368       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
369       // data-&gt;method() might be null if the MDO is snapshotted
370       // concurrently with a trap
371       if (m != NULL &amp;&amp; data-&gt;method() == m &amp;&amp; dp-&gt;bci() == bci) {
372         return data;
373       }
374       break;
375     }
376     default:
377       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
378     }
379   }
380   return NULL;
381 }
382 
383 // Translate a bci to its corresponding data, or NULL.
384 ciProfileData* ciMethodData::bci_to_data(int bci, ciMethod* m) {
385   // If m is not NULL we look for a SpeculativeTrapData entry
386   if (m == NULL) {
387     ciProfileData* data = data_before(bci);
388     for ( ; is_valid(data); data = next_data(data)) {
389       if (data-&gt;bci() == bci) {
390         set_hint_di(dp_to_di(data-&gt;dp()));
391         return data;
392       } else if (data-&gt;bci() &gt; bci) {
393         break;
394       }
395     }
396   }
397   bool two_free_slots = false;
398   ciProfileData* result = bci_to_extra_data(bci, m, two_free_slots);
399   if (result != NULL) {
400     return result;
401   }
402   if (m != NULL &amp;&amp; !two_free_slots) {
403     // We were looking for a SpeculativeTrapData entry we didn&#39;t
404     // find. Room is not available for more SpeculativeTrapData
405     // entries, look in the non SpeculativeTrapData entries.
406     return bci_to_data(bci, NULL);
407   }
408   return NULL;
409 }
410 
411 // Conservatively decode the trap_state of a ciProfileData.
412 int ciMethodData::has_trap_at(ciProfileData* data, int reason) {
413   typedef Deoptimization::DeoptReason DR_t;
414   int per_bc_reason
415     = Deoptimization::reason_recorded_per_bytecode_if_any((DR_t) reason);
416   if (trap_count(reason) == 0) {
417     // Impossible for this trap to have occurred, regardless of trap_state.
418     // Note:  This happens if the MDO is empty.
419     return 0;
420   } else if (per_bc_reason == Deoptimization::Reason_none) {
421     // We cannot conclude anything; a trap happened somewhere, maybe here.
422     return -1;
423   } else if (data == NULL) {
424     // No profile here, not even an extra_data record allocated on the fly.
425     // If there are empty extra_data records, and there had been a trap,
426     // there would have been a non-null data pointer.  If there are no
427     // free extra_data records, we must return a conservative -1.
428     if (_saw_free_extra_data)
429       return 0;                 // Q.E.D.
430     else
431       return -1;                // bail with a conservative answer
432   } else {
433     return Deoptimization::trap_state_has_reason(data-&gt;trap_state(), per_bc_reason);
434   }
435 }
436 
437 int ciMethodData::trap_recompiled_at(ciProfileData* data) {
438   if (data == NULL) {
439     return (_saw_free_extra_data? 0: -1);  // (see previous method)
440   } else {
441     return Deoptimization::trap_state_is_recompiled(data-&gt;trap_state())? 1: 0;
442   }
443 }
444 
445 void ciMethodData::clear_escape_info() {
446   VM_ENTRY_MARK;
447   MethodData* mdo = get_MethodData();
448   if (mdo != NULL) {
449     mdo-&gt;clear_escape_info();
450     ArgInfoData *aid = arg_info();
451     int arg_count = (aid == NULL) ? 0 : aid-&gt;number_of_args();
452     for (int i = 0; i &lt; arg_count; i++) {
453       set_arg_modified(i, 0);
454     }
455   }
456   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
457 }
458 
459 // copy our escape info to the MethodData* if it exists
460 void ciMethodData::update_escape_info() {
461   VM_ENTRY_MARK;
462   MethodData* mdo = get_MethodData();
463   if ( mdo != NULL) {
464     mdo-&gt;set_eflags(_eflags);
465     mdo-&gt;set_arg_local(_arg_local);
466     mdo-&gt;set_arg_stack(_arg_stack);
467     mdo-&gt;set_arg_returned(_arg_returned);
468     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
469     for (int i = 0; i &lt; arg_count; i++) {
470       mdo-&gt;set_arg_modified(i, arg_modified(i));
471     }
472   }
473 }
474 
475 void ciMethodData::set_compilation_stats(short loops, short blocks) {
476   VM_ENTRY_MARK;
477   MethodData* mdo = get_MethodData();
478   if (mdo != NULL) {
479     mdo-&gt;set_num_loops(loops);
480     mdo-&gt;set_num_blocks(blocks);
481   }
482 }
483 
484 void ciMethodData::set_would_profile(bool p) {
485   VM_ENTRY_MARK;
486   MethodData* mdo = get_MethodData();
487   if (mdo != NULL) {
488     mdo-&gt;set_would_profile(p);
489   }
490 }
491 
492 void ciMethodData::set_argument_type(int bci, int i, ciKlass* k) {
493   VM_ENTRY_MARK;
494   MethodData* mdo = get_MethodData();
495   if (mdo != NULL) {
496     ProfileData* data = mdo-&gt;bci_to_data(bci);
497     if (data != NULL) {
498       if (data-&gt;is_CallTypeData()) {
499         data-&gt;as_CallTypeData()-&gt;set_argument_type(i, k-&gt;get_Klass());
500       } else {
501         assert(data-&gt;is_VirtualCallTypeData(), &quot;no arguments!&quot;);
502         data-&gt;as_VirtualCallTypeData()-&gt;set_argument_type(i, k-&gt;get_Klass());
503       }
504     }
505   }
506 }
507 
508 void ciMethodData::set_parameter_type(int i, ciKlass* k) {
509   VM_ENTRY_MARK;
510   MethodData* mdo = get_MethodData();
511   if (mdo != NULL) {
512     mdo-&gt;parameters_type_data()-&gt;set_type(i, k-&gt;get_Klass());
513   }
514 }
515 
516 void ciMethodData::set_return_type(int bci, ciKlass* k) {
517   VM_ENTRY_MARK;
518   MethodData* mdo = get_MethodData();
519   if (mdo != NULL) {
520     ProfileData* data = mdo-&gt;bci_to_data(bci);
521     if (data != NULL) {
522       if (data-&gt;is_CallTypeData()) {
523         data-&gt;as_CallTypeData()-&gt;set_return_type(k-&gt;get_Klass());
524       } else {
525         assert(data-&gt;is_VirtualCallTypeData(), &quot;no arguments!&quot;);
526         data-&gt;as_VirtualCallTypeData()-&gt;set_return_type(k-&gt;get_Klass());
527       }
528     }
529   }
530 }
531 
532 bool ciMethodData::has_escape_info() {
533   return eflag_set(MethodData::estimated);
534 }
535 
536 void ciMethodData::set_eflag(MethodData::EscapeFlag f) {
537   set_bits(_eflags, f);
538 }
539 
540 bool ciMethodData::eflag_set(MethodData::EscapeFlag f) const {
541   return mask_bits(_eflags, f) != 0;
542 }
543 
544 void ciMethodData::set_arg_local(int i) {
545   set_nth_bit(_arg_local, i);
546 }
547 
548 void ciMethodData::set_arg_stack(int i) {
549   set_nth_bit(_arg_stack, i);
550 }
551 
552 void ciMethodData::set_arg_returned(int i) {
553   set_nth_bit(_arg_returned, i);
554 }
555 
556 void ciMethodData::set_arg_modified(int arg, uint val) {
557   ArgInfoData *aid = arg_info();
558   if (aid == NULL)
559     return;
560   assert(arg &gt;= 0 &amp;&amp; arg &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
561   aid-&gt;set_arg_modified(arg, val);
562 }
563 
564 bool ciMethodData::is_arg_local(int i) const {
565   return is_set_nth_bit(_arg_local, i);
566 }
567 
568 bool ciMethodData::is_arg_stack(int i) const {
569   return is_set_nth_bit(_arg_stack, i);
570 }
571 
572 bool ciMethodData::is_arg_returned(int i) const {
573   return is_set_nth_bit(_arg_returned, i);
574 }
575 
576 uint ciMethodData::arg_modified(int arg) const {
577   ArgInfoData *aid = arg_info();
578   if (aid == NULL)
579     return 0;
580   assert(arg &gt;= 0 &amp;&amp; arg &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
581   return aid-&gt;arg_modified(arg);
582 }
583 
584 ByteSize ciMethodData::offset_of_slot(ciProfileData* data, ByteSize slot_offset_in_data) {
585   // Get offset within MethodData* of the data array
586   ByteSize data_offset = MethodData::data_offset();
587 
588   // Get cell offset of the ProfileData within data array
589   int cell_offset = dp_to_di(data-&gt;dp());
590 
591   // Add in counter_offset, the # of bytes into the ProfileData of counter or flag
592   int offset = in_bytes(data_offset) + cell_offset + in_bytes(slot_offset_in_data);
593 
594   return in_ByteSize(offset);
595 }
596 
597 ciArgInfoData *ciMethodData::arg_info() const {
598   // Should be last, have to skip all traps.
599   DataLayout* dp  = extra_data_base();
600   DataLayout* end = args_data_limit();
601   for (; dp &lt; end; dp = MethodData::next_extra(dp)) {
602     if (dp-&gt;tag() == DataLayout::arg_info_data_tag)
603       return new ciArgInfoData(dp);
604   }
605   return NULL;
606 }
607 
608 
609 // Implementation of the print method.
610 void ciMethodData::print_impl(outputStream* st) {
611   ciMetadata::print_impl(st);
612 }
613 
614 void ciMethodData::dump_replay_data_type_helper(outputStream* out, int round, int&amp; count, ProfileData* pdata, ByteSize offset, ciKlass* k) {
615   if (k != NULL) {
616     if (round == 0) {
617       count++;
618     } else {
619       out-&gt;print(&quot; %d %s&quot;, (int)(dp_to_di(pdata-&gt;dp() + in_bytes(offset)) / sizeof(intptr_t)), k-&gt;name()-&gt;as_quoted_ascii());
620     }
621   }
622 }
623 
624 template&lt;class T&gt; void ciMethodData::dump_replay_data_receiver_type_helper(outputStream* out, int round, int&amp; count, T* vdata) {
625   for (uint i = 0; i &lt; vdata-&gt;row_limit(); i++) {
626     dump_replay_data_type_helper(out, round, count, vdata, vdata-&gt;receiver_offset(i), vdata-&gt;receiver(i));
627   }
628 }
629 
630 template&lt;class T&gt; void ciMethodData::dump_replay_data_call_type_helper(outputStream* out, int round, int&amp; count, T* call_type_data) {
631   if (call_type_data-&gt;has_arguments()) {
632     for (int i = 0; i &lt; call_type_data-&gt;number_of_arguments(); i++) {
633       dump_replay_data_type_helper(out, round, count, call_type_data, call_type_data-&gt;argument_type_offset(i), call_type_data-&gt;valid_argument_type(i));
634     }
635   }
636   if (call_type_data-&gt;has_return()) {
637     dump_replay_data_type_helper(out, round, count, call_type_data, call_type_data-&gt;return_type_offset(), call_type_data-&gt;valid_return_type());
638   }
639 }
640 
641 void ciMethodData::dump_replay_data_extra_data_helper(outputStream* out, int round, int&amp; count) {
642   DataLayout* dp  = extra_data_base();
643   DataLayout* end = args_data_limit();
644 
645   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
646     switch(dp-&gt;tag()) {
647     case DataLayout::no_tag:
648     case DataLayout::arg_info_data_tag:
649       return;
650     case DataLayout::bit_data_tag:
651       break;
652     case DataLayout::speculative_trap_data_tag: {
653       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
654       ciMethod* m = data-&gt;method();
655       if (m != NULL) {
656         if (round == 0) {
657           count++;
658         } else {
659           out-&gt;print(&quot; %d &quot;, (int)(dp_to_di(((address)dp) + in_bytes(ciSpeculativeTrapData::method_offset())) / sizeof(intptr_t)));
660           m-&gt;dump_name_as_ascii(out);
661         }
662       }
663       break;
664     }
665     default:
666       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
667     }
668   }
669 }
670 
671 void ciMethodData::dump_replay_data(outputStream* out) {
672   ResourceMark rm;
673   MethodData* mdo = get_MethodData();
674   Method* method = mdo-&gt;method();
675   Klass* holder = method-&gt;method_holder();
676   out-&gt;print(&quot;ciMethodData %s %s %s %d %d&quot;,
677              holder-&gt;name()-&gt;as_quoted_ascii(),
678              method-&gt;name()-&gt;as_quoted_ascii(),
679              method-&gt;signature()-&gt;as_quoted_ascii(),
680              _state,
681              current_mileage());
682 
683   // dump the contents of the MDO header as raw data
684   unsigned char* orig = (unsigned char*)&amp;_orig;
685   int length = sizeof(_orig);
686   out-&gt;print(&quot; orig %d&quot;, length);
687   for (int i = 0; i &lt; length; i++) {
688     out-&gt;print(&quot; %d&quot;, orig[i]);
689   }
690 
691   // dump the MDO data as raw data
692   int elements = (data_size() + extra_data_size()) / sizeof(intptr_t);
693   out-&gt;print(&quot; data %d&quot;, elements);
694   for (int i = 0; i &lt; elements; i++) {
695     // We could use INTPTR_FORMAT here but that&#39;s zero justified
696     // which makes comparing it with the SA version of this output
697     // harder. data()&#39;s element type is intptr_t.
698     out-&gt;print(&quot; &quot; INTPTRNZ_FORMAT, data()[i]);
699   }
700 
701   // The MDO contained oop references as ciObjects, so scan for those
702   // and emit pairs of offset and klass name so that they can be
703   // reconstructed at runtime.  The first round counts the number of
704   // oop references and the second actually emits them.
705   ciParametersTypeData* parameters = parameters_type_data();
706   for (int count = 0, round = 0; round &lt; 2; round++) {
707     if (round == 1) out-&gt;print(&quot; oops %d&quot;, count);
708     ProfileData* pdata = first_data();
709     for ( ; is_valid(pdata); pdata = next_data(pdata)) {
710       if (pdata-&gt;is_VirtualCallData()) {
711         ciVirtualCallData* vdata = (ciVirtualCallData*)pdata;
712         dump_replay_data_receiver_type_helper&lt;ciVirtualCallData&gt;(out, round, count, vdata);
713         if (pdata-&gt;is_VirtualCallTypeData()) {
714           ciVirtualCallTypeData* call_type_data = (ciVirtualCallTypeData*)pdata;
715           dump_replay_data_call_type_helper&lt;ciVirtualCallTypeData&gt;(out, round, count, call_type_data);
716         }
717       } else if (pdata-&gt;is_ReceiverTypeData()) {
718         ciReceiverTypeData* vdata = (ciReceiverTypeData*)pdata;
719         dump_replay_data_receiver_type_helper&lt;ciReceiverTypeData&gt;(out, round, count, vdata);
720       } else if (pdata-&gt;is_CallTypeData()) {
721           ciCallTypeData* call_type_data = (ciCallTypeData*)pdata;
722           dump_replay_data_call_type_helper&lt;ciCallTypeData&gt;(out, round, count, call_type_data);
723       }
724     }
725     if (parameters != NULL) {
726       for (int i = 0; i &lt; parameters-&gt;number_of_parameters(); i++) {
727         dump_replay_data_type_helper(out, round, count, parameters, ParametersTypeData::type_offset(i), parameters-&gt;valid_parameter_type(i));
728       }
729     }
730   }
731   for (int count = 0, round = 0; round &lt; 2; round++) {
732     if (round == 1) out-&gt;print(&quot; methods %d&quot;, count);
733     dump_replay_data_extra_data_helper(out, round, count);
734   }
735   out-&gt;cr();
736 }
737 
738 #ifndef PRODUCT
739 void ciMethodData::print() {
740   print_data_on(tty);
741 }
742 
743 void ciMethodData::print_data_on(outputStream* st) {
744   ResourceMark rm;
745   ciParametersTypeData* parameters = parameters_type_data();
746   if (parameters != NULL) {
747     parameters-&gt;print_data_on(st);
748   }
749   ciProfileData* data;
750   for (data = first_data(); is_valid(data); data = next_data(data)) {
751     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
752     st-&gt;fill_to(6);
753     data-&gt;print_data_on(st);
754   }
755   st-&gt;print_cr(&quot;--- Extra data:&quot;);
756   DataLayout* dp  = extra_data_base();
757   DataLayout* end = args_data_limit();
758   for (;; dp = MethodData::next_extra(dp)) {
759     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
760     switch (dp-&gt;tag()) {
761     case DataLayout::no_tag:
762       continue;
763     case DataLayout::bit_data_tag:
764       data = new BitData(dp);
765       break;
766     case DataLayout::arg_info_data_tag:
767       data = new ciArgInfoData(dp);
768       dp = end; // ArgInfoData is at the end of extra data section.
769       break;
770     case DataLayout::speculative_trap_data_tag:
771       data = new ciSpeculativeTrapData(dp);
772       break;
773     default:
774       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
775     }
776     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
777     st-&gt;fill_to(6);
778     data-&gt;print_data_on(st);
779     if (dp &gt;= end) return;
780   }
781 }
782 
783 void ciTypeEntries::print_ciklass(outputStream* st, intptr_t k) {
784   if (TypeEntries::is_type_none(k)) {
785     st-&gt;print(&quot;none&quot;);
786   } else if (TypeEntries::is_type_unknown(k)) {
787     st-&gt;print(&quot;unknown&quot;);
788   } else {
789     valid_ciklass(k)-&gt;print_name_on(st);
790   }
791   if (TypeEntries::was_null_seen(k)) {
792     st-&gt;print(&quot; (null seen)&quot;);
793   }
794 }
795 
796 void ciTypeStackSlotEntries::print_data_on(outputStream* st) const {
797   for (int i = 0; i &lt; number_of_entries(); i++) {
798     _pd-&gt;tab(st);
799     st-&gt;print(&quot;%d: stack (%u) &quot;, i, stack_slot(i));
800     print_ciklass(st, type(i));
801     st-&gt;cr();
802   }
803 }
804 
805 void ciReturnTypeEntry::print_data_on(outputStream* st) const {
806   _pd-&gt;tab(st);
807   st-&gt;print(&quot;ret &quot;);
808   print_ciklass(st, type());
809   st-&gt;cr();
810 }
811 
812 void ciCallTypeData::print_data_on(outputStream* st, const char* extra) const {
813   print_shared(st, &quot;ciCallTypeData&quot;, extra);
814   if (has_arguments()) {
815     tab(st, true);
816     st-&gt;print_cr(&quot;argument types&quot;);
817     args()-&gt;print_data_on(st);
818   }
819   if (has_return()) {
820     tab(st, true);
821     st-&gt;print_cr(&quot;return type&quot;);
822     ret()-&gt;print_data_on(st);
823   }
824 }
825 
826 void ciReceiverTypeData::print_receiver_data_on(outputStream* st) const {
827   uint row;
828   int entries = 0;
829   for (row = 0; row &lt; row_limit(); row++) {
830     if (receiver(row) != NULL)  entries++;
831   }
832   st-&gt;print_cr(&quot;count(%u) entries(%u)&quot;, count(), entries);
833   for (row = 0; row &lt; row_limit(); row++) {
834     if (receiver(row) != NULL) {
835       tab(st);
836       receiver(row)-&gt;print_name_on(st);
837       st-&gt;print_cr(&quot;(%u)&quot;, receiver_count(row));
838     }
839   }
840 }
841 
842 void ciReceiverTypeData::print_data_on(outputStream* st, const char* extra) const {
843   print_shared(st, &quot;ciReceiverTypeData&quot;, extra);
844   print_receiver_data_on(st);
845 }
846 
847 void ciVirtualCallData::print_data_on(outputStream* st, const char* extra) const {
848   print_shared(st, &quot;ciVirtualCallData&quot;, extra);
849   rtd_super()-&gt;print_receiver_data_on(st);
850 }
851 
852 void ciVirtualCallTypeData::print_data_on(outputStream* st, const char* extra) const {
853   print_shared(st, &quot;ciVirtualCallTypeData&quot;, extra);
854   rtd_super()-&gt;print_receiver_data_on(st);
855   if (has_arguments()) {
856     tab(st, true);
857     st-&gt;print(&quot;argument types&quot;);
858     args()-&gt;print_data_on(st);
859   }
860   if (has_return()) {
861     tab(st, true);
862     st-&gt;print(&quot;return type&quot;);
863     ret()-&gt;print_data_on(st);
864   }
865 }
866 
867 void ciParametersTypeData::print_data_on(outputStream* st, const char* extra) const {
868   st-&gt;print_cr(&quot;ciParametersTypeData&quot;);
869   parameters()-&gt;print_data_on(st);
870 }
871 
872 void ciSpeculativeTrapData::print_data_on(outputStream* st, const char* extra) const {
873   st-&gt;print_cr(&quot;ciSpeculativeTrapData&quot;);
874   tab(st);
875   method()-&gt;print_short_name(st);
876   st-&gt;cr();
877 }
878 #endif
    </pre>
  </body>
</html>
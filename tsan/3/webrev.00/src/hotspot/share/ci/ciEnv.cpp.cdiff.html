<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/ci/ciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciConstant.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciEnv.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,20 ***</span>
<span class="line-new-header">--- 31,22 ---</span>
  #include &quot;ci/ciInstanceKlass.hpp&quot;
  #include &quot;ci/ciMethod.hpp&quot;
  #include &quot;ci/ciNullObject.hpp&quot;
  #include &quot;ci/ciReplay.hpp&quot;
  #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
<span class="line-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,11 ***</span>
  static bool firstEnv = true;
  #endif /* PRODUCT */
  
  // ------------------------------------------------------------------
  // ciEnv::ciEnv
<span class="line-modified">! ciEnv::ciEnv(CompileTask* task, int system_dictionary_modification_counter)</span>
    : _ciEnv_arena(mtCompiler) {
    VM_ENTRY_MARK;
  
    // Set up ciEnv::current immediately, for the sake of ciObjectFactory, etc.
    thread-&gt;set_env(this);
<span class="line-new-header">--- 96,11 ---</span>
  static bool firstEnv = true;
  #endif /* PRODUCT */
  
  // ------------------------------------------------------------------
  // ciEnv::ciEnv
<span class="line-modified">! ciEnv::ciEnv(CompileTask* task)</span>
    : _ciEnv_arena(mtCompiler) {
    VM_ENTRY_MARK;
  
    // Set up ciEnv::current immediately, for the sake of ciObjectFactory, etc.
    thread-&gt;set_env(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,11 ***</span>
    _compiler_data = NULL;
  #ifndef PRODUCT
    assert(!firstEnv, &quot;not initialized properly&quot;);
  #endif /* !PRODUCT */
  
<span class="line-removed">-   _system_dictionary_modification_counter = system_dictionary_modification_counter;</span>
    _num_inlined_bytecodes = 0;
    assert(task == NULL || thread-&gt;task() == task, &quot;sanity&quot;);
    if (task != NULL) {
      task-&gt;mark_started(os::elapsed_counter());
    }
<span class="line-new-header">--- 116,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,10 ***</span>
<span class="line-new-header">--- 152,11 ---</span>
    _ArrayStoreException_instance = NULL;
    _ClassCastException_instance = NULL;
    _the_null_string = NULL;
    _the_min_jint_string = NULL;
  
<span class="line-added">+   _jvmti_redefinition_count = 0;</span>
    _jvmti_can_hotswap_or_post_breakpoint = false;
    _jvmti_can_access_local_variables = false;
    _jvmti_can_post_on_exceptions = false;
    _jvmti_can_pop_frame = false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,11 ***</span>
  #ifndef PRODUCT
    assert(firstEnv, &quot;must be first&quot;);
    firstEnv = false;
  #endif /* !PRODUCT */
  
<span class="line-removed">-   _system_dictionary_modification_counter = 0;</span>
    _num_inlined_bytecodes = 0;
    _task = NULL;
    _log = NULL;
  
    // Temporary buffer for creating symbols and such.
<span class="line-new-header">--- 181,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,10 ***</span>
<span class="line-new-header">--- 208,11 ---</span>
    _ArrayStoreException_instance = NULL;
    _ClassCastException_instance = NULL;
    _the_null_string = NULL;
    _the_min_jint_string = NULL;
  
<span class="line-added">+   _jvmti_redefinition_count = 0;</span>
    _jvmti_can_hotswap_or_post_breakpoint = false;
    _jvmti_can_access_local_variables = false;
    _jvmti_can_post_on_exceptions = false;
    _jvmti_can_pop_frame = false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,17 ***</span>
<span class="line-new-header">--- 231,24 ---</span>
  // Cache Jvmti state
  void ciEnv::cache_jvmti_state() {
    VM_ENTRY_MARK;
    // Get Jvmti capabilities under lock to get consistant values.
    MutexLocker mu(JvmtiThreadState_lock);
<span class="line-added">+   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();</span>
    _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();
    _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();
    _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();
    _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();
<span class="line-added">+   _jvmti_can_get_owned_monitor_info     = JvmtiExport::can_get_owned_monitor_info();</span>
  }
  
  bool ciEnv::jvmti_state_changed() const {
<span class="line-added">+   // Some classes were redefined</span>
<span class="line-added">+   if (_jvmti_redefinition_count != JvmtiExport::redefinition_count()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (!_jvmti_can_access_local_variables &amp;&amp;
        JvmtiExport::can_access_local_variables()) {
      return true;
    }
    if (!_jvmti_can_hotswap_or_post_breakpoint &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,10 ***</span>
<span class="line-new-header">--- 261,15 ---</span>
    }
    if (!_jvmti_can_pop_frame &amp;&amp;
        JvmtiExport::can_pop_frame()) {
      return true;
    }
<span class="line-added">+   if (!_jvmti_can_get_owned_monitor_info &amp;&amp;</span>
<span class="line-added">+       JvmtiExport::can_get_owned_monitor_info()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    return false;
  }
  
  // ------------------------------------------------------------------
  // Cache DTrace flags
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,17 ***</span>
    ASSERT_IN_VM;
    EXCEPTION_CONTEXT;
  
    // Now we need to check the SystemDictionary
    Symbol* sym = name-&gt;get_symbol();
<span class="line-modified">!   if (sym-&gt;char_at(0) == &#39;L&#39; &amp;&amp;</span>
<span class="line-removed">-     sym-&gt;char_at(sym-&gt;utf8_length()-1) == &#39;;&#39;) {</span>
      // This is a name from a signature.  Strip off the trimmings.
      // Call recursive to keep scope of strippedsym.
<span class="line-modified">!     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-removed">-                     sym-&gt;utf8_length()-2,</span>
<span class="line-removed">-                     KILL_COMPILE_ON_FATAL_(_unloaded_ciinstance_klass));</span>
      ciSymbol* strippedname = get_symbol(strippedsym);
      return get_klass_by_name_impl(accessing_klass, cpool, strippedname, require_local);
    }
  
    // Check for prior unloaded klass.  The SystemDictionary&#39;s answers
<span class="line-new-header">--- 411,14 ---</span>
    ASSERT_IN_VM;
    EXCEPTION_CONTEXT;
  
    // Now we need to check the SystemDictionary
    Symbol* sym = name-&gt;get_symbol();
<span class="line-modified">!   if (Signature::has_envelope(sym)) {</span>
      // This is a name from a signature.  Strip off the trimmings.
      // Call recursive to keep scope of strippedsym.
<span class="line-modified">!     TempNewSymbol strippedsym = Signature::strip_envelope(sym);</span>
      ciSymbol* strippedname = get_symbol(strippedsym);
      return get_klass_by_name_impl(accessing_klass, cpool, strippedname, require_local);
    }
  
    // Check for prior unloaded klass.  The SystemDictionary&#39;s answers
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,11 ***</span>
      domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
    }
  
    // setup up the proper type to return on OOM
    ciKlass* fail_type;
<span class="line-modified">!   if (sym-&gt;char_at(0) == &#39;[&#39;) {</span>
      fail_type = _unloaded_ciobjarrayklass;
    } else {
      fail_type = _unloaded_ciinstance_klass;
    }
    Klass* found_klass;
<span class="line-new-header">--- 436,11 ---</span>
      domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
    }
  
    // setup up the proper type to return on OOM
    ciKlass* fail_type;
<span class="line-modified">!   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY) {</span>
      fail_type = _unloaded_ciobjarrayklass;
    } else {
      fail_type = _unloaded_ciinstance_klass;
    }
    Klass* found_klass;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,23 ***</span>
    // The element type may be available either locally or via constraints.
    // In either case, if we can find the element type in the system dictionary,
    // we must build an array type around it.  The CI requires array klasses
    // to be loaded if their element klasses are loaded, except when memory
    // is exhausted.
<span class="line-modified">!   if (sym-&gt;char_at(0) == &#39;[&#39; &amp;&amp;</span>
<span class="line-modified">!       (sym-&gt;char_at(1) == &#39;[&#39; || sym-&gt;char_at(1) == &#39;L&#39;)) {</span>
      // We have an unloaded array.
      // Build it on the fly if the element class exists.
<span class="line-modified">!     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-modified">!                                                  sym-&gt;utf8_length()-1,</span>
<span class="line-removed">-                                                  KILL_COMPILE_ON_FATAL_(fail_type));</span>
<span class="line-removed">- </span>
      // Get element ciKlass recursively.
      ciKlass* elem_klass =
        get_klass_by_name_impl(accessing_klass,
                               cpool,
<span class="line-modified">!                              get_symbol(elem_sym),</span>
                               require_local);
      if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_loaded()) {
        // Now make an array for it
        return ciObjArrayKlass::make_impl(elem_klass);
      }
<span class="line-new-header">--- 462,21 ---</span>
    // The element type may be available either locally or via constraints.
    // In either case, if we can find the element type in the system dictionary,
    // we must build an array type around it.  The CI requires array klasses
    // to be loaded if their element klasses are loaded, except when memory
    // is exhausted.
<span class="line-modified">!   if (Signature::is_array(sym) &amp;&amp;</span>
<span class="line-modified">!       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {</span>
      // We have an unloaded array.
      // Build it on the fly if the element class exists.
<span class="line-modified">!     SignatureStream ss(sym, false);</span>
<span class="line-modified">!     ss.skip_array_prefix(1);</span>
      // Get element ciKlass recursively.
      ciKlass* elem_klass =
        get_klass_by_name_impl(accessing_klass,
                               cpool,
<span class="line-modified">!                              get_symbol(ss.as_symbol()),</span>
                               require_local);
      if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_loaded()) {
        // Now make an array for it
        return ciObjArrayKlass::make_impl(elem_klass);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,11 ***</span>
                                          get_symbol(klass_name),
                                          false);
      // Calculate accessibility the hard way.
      if (!k-&gt;is_loaded()) {
        is_accessible = false;
<span class="line-modified">!     } else if (!oopDesc::equals(k-&gt;loader(), accessor-&gt;loader()) &amp;&amp;</span>
                 get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
        // Loaded only remotely.  Not linked yet.
        is_accessible = false;
      } else {
        // Linked locally, and we must also check public/private, etc.
<span class="line-new-header">--- 548,11 ---</span>
                                          get_symbol(klass_name),
                                          false);
      // Calculate accessibility the hard way.
      if (!k-&gt;is_loaded()) {
        is_accessible = false;
<span class="line-modified">!     } else if (k-&gt;loader() != accessor-&gt;loader() &amp;&amp;</span>
                 get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
        // Loaded only remotely.  Not linked yet.
        is_accessible = false;
      } else {
        // Linked locally, and we must also check public/private, etc.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,16 ***</span>
    if (cache_index &gt;= 0) {
      assert(index &lt; 0, &quot;only one kind of index at a time&quot;);
      index = cpool-&gt;object_to_cp_index(cache_index);
      oop obj = cpool-&gt;resolved_references()-&gt;obj_at(cache_index);
      if (obj != NULL) {
<span class="line-modified">!       if (oopDesc::equals(obj, Universe::the_null_sentinel())) {</span>
          return ciConstant(T_OBJECT, get_object(NULL));
        }
        BasicType bt = T_OBJECT;
        if (cpool-&gt;tag_at(index).is_dynamic_constant())
<span class="line-modified">!         bt = FieldType::basic_type(cpool-&gt;uncached_signature_ref_at(index));</span>
        if (is_reference_type(bt)) {
        } else {
          // we have to unbox the primitive value
          if (!is_java_primitive(bt))  return ciConstant();
          jvalue value;
<span class="line-new-header">--- 599,16 ---</span>
    if (cache_index &gt;= 0) {
      assert(index &lt; 0, &quot;only one kind of index at a time&quot;);
      index = cpool-&gt;object_to_cp_index(cache_index);
      oop obj = cpool-&gt;resolved_references()-&gt;obj_at(cache_index);
      if (obj != NULL) {
<span class="line-modified">!       if (obj == Universe::the_null_sentinel()) {</span>
          return ciConstant(T_OBJECT, get_object(NULL));
        }
        BasicType bt = T_OBJECT;
        if (cpool-&gt;tag_at(index).is_dynamic_constant())
<span class="line-modified">!         bt = Signature::basic_type(cpool-&gt;uncached_signature_ref_at(index));</span>
        if (is_reference_type(bt)) {
        } else {
          // we have to unbox the primitive value
          if (!is_java_primitive(bt))  return ciConstant();
          jvalue value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,11 ***</span>
    // Accessibility checks are performed in ciEnv::get_method_by_index_impl.
    assert(check_klass_accessibility(accessor, holder-&gt;get_Klass()), &quot;holder not accessible&quot;);
  
    InstanceKlass* accessor_klass = accessor-&gt;get_instanceKlass();
    Klass* holder_klass = holder-&gt;get_Klass();
<span class="line-modified">!   methodHandle dest_method;</span>
    LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::needs_access_check, tag);
    switch (bc) {
    case Bytecodes::_invokestatic:
      dest_method =
        LinkResolver::resolve_static_call_or_null(link_info);
<span class="line-new-header">--- 755,11 ---</span>
    // Accessibility checks are performed in ciEnv::get_method_by_index_impl.
    assert(check_klass_accessibility(accessor, holder-&gt;get_Klass()), &quot;holder not accessible&quot;);
  
    InstanceKlass* accessor_klass = accessor-&gt;get_instanceKlass();
    Klass* holder_klass = holder-&gt;get_Klass();
<span class="line-modified">!   Method* dest_method;</span>
    LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::needs_access_check, tag);
    switch (bc) {
    case Bytecodes::_invokestatic:
      dest_method =
        LinkResolver::resolve_static_call_or_null(link_info);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 768,19 ***</span>
        LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
      break;
    default: ShouldNotReachHere();
    }
  
<span class="line-modified">!   return dest_method();</span>
  }
  
  
  // ------------------------------------------------------------------
  // ciEnv::get_method_by_index_impl
  ciMethod* ciEnv::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
                                            int index, Bytecodes::Code bc,
                                            ciInstanceKlass* accessor) {
    if (bc == Bytecodes::_invokedynamic) {
      ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
      bool is_resolved = !cpce-&gt;is_f1_null();
      // FIXME: code generation could allow for null (unlinked) call site
      // The call site could be made patchable as follows:
<span class="line-new-header">--- 777,21 ---</span>
        LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
      break;
    default: ShouldNotReachHere();
    }
  
<span class="line-modified">!   return dest_method;</span>
  }
  
  
  // ------------------------------------------------------------------
  // ciEnv::get_method_by_index_impl
  ciMethod* ciEnv::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
                                            int index, Bytecodes::Code bc,
                                            ciInstanceKlass* accessor) {
<span class="line-added">+   assert(cpool.not_null(), &quot;need constant pool&quot;);</span>
<span class="line-added">+   assert(accessor != NULL, &quot;need origin of access&quot;);</span>
    if (bc == Bytecodes::_invokedynamic) {
      ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
      bool is_resolved = !cpce-&gt;is_f1_null();
      // FIXME: code generation could allow for null (unlinked) call site
      // The call site could be made patchable as follows:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 917,31 ***</span>
  // ciEnv::is_in_vm
  bool ciEnv::is_in_vm() {
    return JavaThread::current()-&gt;thread_state() == _thread_in_vm;
  }
  
<span class="line-removed">- bool ciEnv::system_dictionary_modification_counter_changed_locked() {</span>
<span class="line-removed">-   assert_locked_or_safepoint(Compile_lock);</span>
<span class="line-removed">-   return _system_dictionary_modification_counter != SystemDictionary::number_of_modifications();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ciEnv::system_dictionary_modification_counter_changed() {</span>
<span class="line-removed">-   VM_ENTRY_MARK;</span>
<span class="line-removed">-   MutexLocker ml(Compile_lock, THREAD); // lock with safepoint check</span>
<span class="line-removed">-   return system_dictionary_modification_counter_changed_locked();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // ------------------------------------------------------------------
  // ciEnv::validate_compile_task_dependencies
  //
  // Check for changes during compilation (e.g. class loads, evolution,
  // breakpoints, call site invalidation).
  void ciEnv::validate_compile_task_dependencies(ciMethod* target) {
    if (failing())  return;  // no need for further checks
  
<span class="line-modified">!   bool counter_changed = system_dictionary_modification_counter_changed_locked();</span>
<span class="line-removed">-   Dependencies::DepType result = dependencies()-&gt;validate_dependencies(_task, counter_changed);</span>
    if (result != Dependencies::end_marker) {
      if (result == Dependencies::call_site_target_value) {
        _inc_decompile_count_on_failure = false;
        record_failure(&quot;call site target change&quot;);
      } else if (Dependencies::is_klass_type(result)) {
<span class="line-new-header">--- 928,19 ---</span>
  // ciEnv::is_in_vm
  bool ciEnv::is_in_vm() {
    return JavaThread::current()-&gt;thread_state() == _thread_in_vm;
  }
  
  // ------------------------------------------------------------------
  // ciEnv::validate_compile_task_dependencies
  //
  // Check for changes during compilation (e.g. class loads, evolution,
  // breakpoints, call site invalidation).
  void ciEnv::validate_compile_task_dependencies(ciMethod* target) {
    if (failing())  return;  // no need for further checks
  
<span class="line-modified">!   Dependencies::DepType result = dependencies()-&gt;validate_dependencies(_task);</span>
    if (result != Dependencies::end_marker) {
      if (result == Dependencies::call_site_target_value) {
        _inc_decompile_count_on_failure = false;
        record_failure(&quot;call site target change&quot;);
      } else if (Dependencies::is_klass_type(result)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,11 ***</span>
                              RTMState  rtm_state) {
    VM_ENTRY_MARK;
    nmethod* nm = NULL;
    {
      // To prevent compile queue updates.
<span class="line-modified">!     MutexLocker locker(MethodCompileQueue_lock, THREAD);</span>
  
      // Prevent SystemDictionary::add_to_hierarchy from running
      // and invalidating our dependencies until we install this method.
      // No safepoints are allowed. Otherwise, class redefinition can occur in between.
      MutexLocker ml(Compile_lock);
<span class="line-new-header">--- 968,11 ---</span>
                              RTMState  rtm_state) {
    VM_ENTRY_MARK;
    nmethod* nm = NULL;
    {
      // To prevent compile queue updates.
<span class="line-modified">!     MutexLocker locker(THREAD, MethodCompileQueue_lock);</span>
  
      // Prevent SystemDictionary::add_to_hierarchy from running
      // and invalidating our dependencies until we install this method.
      // No safepoints are allowed. Otherwise, class redefinition can occur in between.
      MutexLocker ml(Compile_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,10 ***</span>
<span class="line-new-header">--- 989,15 ---</span>
            (!dtrace_method_probes() &amp;&amp; DTraceMethodProbes) ||
            (!dtrace_alloc_probes() &amp;&amp; DTraceAllocProbes) )) {
        record_failure(&quot;DTrace flags change invalidated dependencies&quot;);
      }
  
<span class="line-added">+     if (!failing() &amp;&amp; target-&gt;needs_clinit_barrier() &amp;&amp;</span>
<span class="line-added">+         target-&gt;holder()-&gt;is_in_error_state()) {</span>
<span class="line-added">+       record_failure(&quot;method holder is in error state&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!failing()) {
        if (log() != NULL) {
          // Log the dependencies which this compilation declares.
          dependencies()-&gt;log_all_dependencies();
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1070,33 ***</span>
            }
            if (old != NULL) {
              old-&gt;make_not_used();
            }
          }
<span class="line-modified">!         if (TraceNMethodInstalls) {</span>
            ResourceMark rm;
            char *method_name = method-&gt;name_and_sig_as_C_string();
<span class="line-modified">!           ttyLocker ttyl;</span>
<span class="line-modified">!           tty-&gt;print_cr(&quot;Installing method (%d) %s &quot;,</span>
<span class="line-removed">-                         task()-&gt;comp_level(),</span>
<span class="line-removed">-                         method_name);</span>
          }
          // Allow the code to be executed
<span class="line-modified">!         method-&gt;set_code(method, nm);</span>
        } else {
<span class="line-modified">!         if (TraceNMethodInstalls) {</span>
            ResourceMark rm;
            char *method_name = method-&gt;name_and_sig_as_C_string();
<span class="line-modified">!           ttyLocker ttyl;</span>
<span class="line-modified">!           tty-&gt;print_cr(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-modified">!                         task()-&gt;comp_level(),</span>
<span class="line-modified">!                         method_name,</span>
<span class="line-modified">!                         entry_bci);</span>
          }
<span class="line-removed">-         method-&gt;method_holder()-&gt;add_osr_nmethod(nm);</span>
        }
<span class="line-removed">-       nm-&gt;make_in_use();</span>
      }
    }  // safepoints are allowed again
  
    if (nm != NULL) {
      // JVMTI -- compiled method notification (must be done outside lock)
<span class="line-new-header">--- 1074,36 ---</span>
            }
            if (old != NULL) {
              old-&gt;make_not_used();
            }
          }
<span class="line-modified">! </span>
<span class="line-added">+         LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">+         if (lt.is_enabled()) {</span>
            ResourceMark rm;
            char *method_name = method-&gt;name_and_sig_as_C_string();
<span class="line-modified">!           lt.print(&quot;Installing method (%d) %s &quot;,</span>
<span class="line-modified">!                     task()-&gt;comp_level(), method_name);</span>
          }
          // Allow the code to be executed
<span class="line-modified">!         MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+         if (nm-&gt;make_in_use()) {</span>
<span class="line-added">+           method-&gt;set_code(method, nm);</span>
<span class="line-added">+         }</span>
        } else {
<span class="line-modified">!         LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">+         if (lt.is_enabled()) {</span>
            ResourceMark rm;
            char *method_name = method-&gt;name_and_sig_as_C_string();
<span class="line-modified">!           lt.print(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-modified">!                     task()-&gt;comp_level(), method_name, entry_bci);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!         if (nm-&gt;make_in_use()) {</span>
<span class="line-added">+           method-&gt;method_holder()-&gt;add_osr_nmethod(nm);</span>
          }
        }
      }
    }  // safepoints are allowed again
  
    if (nm != NULL) {
      // JVMTI -- compiled method notification (must be done outside lock)
</pre>
<center><a href="ciConstant.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciEnv.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
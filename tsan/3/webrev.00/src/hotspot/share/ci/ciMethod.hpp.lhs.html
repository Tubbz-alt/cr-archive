<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CI_CIMETHOD_HPP
 26 #define SHARE_CI_CIMETHOD_HPP
 27 
 28 #include &quot;ci/ciFlags.hpp&quot;
 29 #include &quot;ci/ciInstanceKlass.hpp&quot;
 30 #include &quot;ci/ciObject.hpp&quot;
 31 #include &quot;ci/ciSignature.hpp&quot;
 32 #include &quot;compiler/methodLiveness.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;utilities/bitMap.hpp&quot;
 35 
 36 class ciMethodBlocks;
 37 class MethodLiveness;
 38 class Arena;
 39 class BCEscapeAnalyzer;
 40 class InlineTree;
 41 
 42 // Whether profiling found an oop to be always, never or sometimes
 43 // null
 44 enum ProfilePtrKind {
 45   ProfileAlwaysNull,
 46   ProfileNeverNull,
 47   ProfileMaybeNull
 48 };
 49 
 50 // ciMethod
 51 //
 52 // This class represents a Method* in the HotSpot virtual
 53 // machine.
 54 class ciMethod : public ciMetadata {
 55   friend class CompileBroker;
 56   CI_PACKAGE_ACCESS
 57   friend class ciEnv;
 58   friend class ciExceptionHandlerStream;
 59   friend class ciBytecodeStream;
 60   friend class ciMethodHandle;
 61   friend class ciReplay;
 62   friend class InlineTree;
 63 
 64  private:
 65   // General method information.
 66   ciFlags          _flags;
 67   ciSymbol*        _name;
 68   ciInstanceKlass* _holder;
 69   ciSignature*     _signature;
 70   ciMethodData*    _method_data;
 71   ciMethodBlocks*   _method_blocks;
 72 
 73   // Code attributes.
 74   int _code_size;
 75   int _max_stack;
 76   int _max_locals;
 77   vmIntrinsics::ID _intrinsic_id;
 78   int _handler_count;
 79   int _nmethod_age;
 80   int _interpreter_invocation_count;
 81   int _interpreter_throwout_count;
 82   int _instructions_size;
 83   int _size_of_parameters;
 84 
 85   bool _uses_monitors;
 86   bool _balanced_monitors;
 87   bool _is_c1_compilable;
 88   bool _is_c2_compilable;
 89   bool _can_be_parsed;
 90   bool _can_be_statically_bound;
 91   bool _has_reserved_stack_access;
 92   bool _is_overpass;
 93 
 94   // Lazy fields, filled in on demand
 95   address              _code;
 96   ciExceptionHandler** _exception_handlers;
 97 
 98   // Optional liveness analyzer.
 99   MethodLiveness* _liveness;
100 #if defined(COMPILER2)
101   ciTypeFlow*         _flow;
102   BCEscapeAnalyzer*   _bcea;
103 #endif
104 
105   ciMethod(const methodHandle&amp; h_m, ciInstanceKlass* holder);
106   ciMethod(ciInstanceKlass* holder, ciSymbol* name, ciSymbol* signature, ciInstanceKlass* accessor);
107 
108   oop loader() const                             { return _holder-&gt;loader(); }
109 
110   const char* type_string()                      { return &quot;ciMethod&quot;; }
111 
112   void print_impl(outputStream* st);
113 
114   void load_code();
115 
116   bool ensure_method_data(const methodHandle&amp; h_m);
117 
118   void code_at_put(int bci, Bytecodes::Code code) {
119     Bytecodes::check(code);
120     assert(0 &lt;= bci &amp;&amp; bci &lt; code_size(), &quot;valid bci&quot;);
121     address bcp = _code + bci;
122     *bcp = code;
123   }
124 
125   // Check bytecode and profile data collected are compatible
126   void assert_virtual_call_type_ok(int bci);
127   void assert_call_type_ok(int bci);
128 
<a name="1" id="anc1"></a>


129  public:
130   void check_is_loaded() const                   { assert(is_loaded(), &quot;not loaded&quot;); }
131 
132   // Basic method information.
133   ciFlags flags() const                          { check_is_loaded(); return _flags; }
134   ciSymbol* name() const                         { return _name; }
135   ciInstanceKlass* holder() const                { return _holder; }
136   ciMethodData* method_data();
137   ciMethodData* method_data_or_null();
138 
139   // Signature information.
140   ciSignature* signature() const                 { return _signature; }
141   ciType*      return_type() const               { return _signature-&gt;return_type(); }
142   int          arg_size_no_receiver() const      { return _signature-&gt;size(); }
143   // Can only be used on loaded ciMethods
144   int          arg_size() const                  {
145     check_is_loaded();
146     return _signature-&gt;size() + (_flags.is_static() ? 0 : 1);
147   }
148   // Report the number of elements on stack when invoking the current method.
149   // If the method is loaded, arg_size() gives precise information about the
150   // number of stack elements (using the method&#39;s signature and its flags).
151   // However, if the method is not loaded, the number of stack elements must
152   // be determined differently, as the method&#39;s flags are not yet available.
153   // The invoke_arg_size() method assumes in that case that all bytecodes except
154   // invokestatic and invokedynamic have a receiver that is also pushed onto the
155   // stack by the caller of the current method.
156   int invoke_arg_size(Bytecodes::Code code) const {
157     if (is_loaded()) {
158       return arg_size();
159     } else {
160       int arg_size = _signature-&gt;size();
161       if (code != Bytecodes::_invokestatic &amp;&amp;
162           code != Bytecodes::_invokedynamic) {
163         arg_size++;
164       }
165       return arg_size;
166     }
167   }
168 
169   Method* get_Method() const {
170     Method* m = (Method*)_metadata;
171     assert(m != NULL, &quot;illegal use of unloaded method&quot;);
172     return m;
173   }
174 
175   // Method code and related information.
176   address code()                                 { if (_code == NULL) load_code(); return _code; }
177   int code_size() const                          { check_is_loaded(); return _code_size; }
178   int max_stack() const                          { check_is_loaded(); return _max_stack; }
179   int max_locals() const                         { check_is_loaded(); return _max_locals; }
180   vmIntrinsics::ID intrinsic_id() const          { check_is_loaded(); return _intrinsic_id; }
181   bool has_exception_handlers() const            { check_is_loaded(); return _handler_count &gt; 0; }
182   int exception_table_length() const             { check_is_loaded(); return _handler_count; }
183   int interpreter_invocation_count() const       { check_is_loaded(); return _interpreter_invocation_count; }
184   int interpreter_throwout_count() const         { check_is_loaded(); return _interpreter_throwout_count; }
185   int size_of_parameters() const                 { check_is_loaded(); return _size_of_parameters; }
186   int nmethod_age() const                        { check_is_loaded(); return _nmethod_age; }
187 
188   // Should the method be compiled with an age counter?
189   bool profile_aging() const;
190 
191   // Code size for inlining decisions.
192   int code_size_for_inlining();
193 
194   bool caller_sensitive()      const { return get_Method()-&gt;caller_sensitive();      }
195   bool force_inline()          const { return get_Method()-&gt;force_inline();          }
196   bool dont_inline()           const { return get_Method()-&gt;dont_inline();           }
197   bool intrinsic_candidate()   const { return get_Method()-&gt;intrinsic_candidate();   }
198   bool is_static_initializer() const { return get_Method()-&gt;is_static_initializer(); }
199 
200   int comp_level();
201   int highest_osr_comp_level();
202 
203   Bytecodes::Code java_code_at_bci(int bci) {
204     address bcp = code() + bci;
205     return Bytecodes::java_code_at(NULL, bcp);
206   }
207   Bytecodes::Code raw_code_at_bci(int bci) {
208     address bcp = code() + bci;
209     return Bytecodes::code_at(NULL, bcp);
210   }
211   BCEscapeAnalyzer  *get_bcea();
212   ciMethodBlocks    *get_method_blocks();
213 
214   bool    has_linenumber_table() const;          // length unknown until decompression
215   u_char* compressed_linenumber_table() const;   // not preserved by gc
216 
217   int line_number_from_bci(int bci) const;
218 
219   // Runtime information.
220   int           vtable_index();
221   address       native_entry();
222   address       interpreter_entry();
223 
224   // Analysis and profiling.
225   //
226   // Usage note: liveness_at_bci and init_vars should be wrapped in ResourceMarks.
227   bool          has_monitor_bytecodes() const    { return _uses_monitors; }
228   bool          has_balanced_monitors();
229 
230   // Returns a bitmap indicating which locals are required to be
231   // maintained as live for deopt.  raw_liveness_at_bci is always the
232   // direct output of the liveness computation while liveness_at_bci
233   // may mark all locals as live to improve support for debugging Java
234   // code by maintaining the state of as many locals as possible.
235   MethodLivenessResult raw_liveness_at_bci(int bci);
236   MethodLivenessResult liveness_at_bci(int bci);
237 
238   // Get the interpreters viewpoint on oop liveness.  MethodLiveness is
239   // conservative in the sense that it may consider locals to be live which
240   // cannot be live, like in the case where a local could contain an oop or
241   // a primitive along different paths.  In that case the local must be
242   // dead when those paths merge. Since the interpreter&#39;s viewpoint is
243   // used when gc&#39;ing an interpreter frame we need to use its viewpoint
244   // during OSR when loading the locals.
245 
246   ResourceBitMap live_local_oops_at_bci(int bci);
247 
<a name="2" id="anc2"></a>

248 #ifdef COMPILER1
249   const BitMap&amp; bci_block_start();
250 #endif
251 
252   ciTypeFlow*   get_flow_analysis();
253   ciTypeFlow*   get_osr_flow_analysis(int osr_bci);  // alternate entry point
254   ciCallProfile call_profile_at_bci(int bci);
255   int           interpreter_call_site_count(int bci);
256 
257   // Does type profiling provide any useful information at this point?
258   bool          argument_profiled_type(int bci, int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
259   bool          parameter_profiled_type(int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
260   bool          return_profiled_type(int bci, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind);
261 
262   ciField*      get_field_at_bci( int bci, bool &amp;will_link);
263   ciMethod*     get_method_at_bci(int bci, bool &amp;will_link, ciSignature* *declared_signature);
264   ciMethod*     get_method_at_bci(int bci) {
265     bool ignored_will_link;
266     ciSignature* ignored_declared_signature;
267     return get_method_at_bci(bci, ignored_will_link, &amp;ignored_declared_signature);
268   }
269 
270   ciKlass*      get_declared_method_holder_at_bci(int bci);
271 
272   ciSignature*  get_declared_signature_at_bci(int bci) {
273     bool ignored_will_link;
274     ciSignature* declared_signature;
275     get_method_at_bci(bci, ignored_will_link, &amp;declared_signature);
276     assert(declared_signature != NULL, &quot;cannot be null&quot;);
277     return declared_signature;
278   }
279 
280   // Given a certain calling environment, find the monomorphic target
281   // for the call.  Return NULL if the call is not monomorphic in
282   // its calling environment.
283   ciMethod* find_monomorphic_target(ciInstanceKlass* caller,
284                                     ciInstanceKlass* callee_holder,
285                                     ciInstanceKlass* actual_receiver,
286                                     bool check_access = true);
287 
288   // Given a known receiver klass, find the target for the call.
289   // Return NULL if the call has no target or is abstract.
290   ciMethod* resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access = true);
291 
292   // Find the proper vtable index to invoke this method.
293   int resolve_vtable_index(ciKlass* caller, ciKlass* receiver);
294 
295   bool has_option(const char *option);
296   bool has_option_value(const char* option, double&amp; value);
297   bool can_be_compiled();
298   bool can_be_parsed() const { return _can_be_parsed; }
299   bool can_be_osr_compiled(int entry_bci);
300   void set_not_compilable(const char* reason = NULL);
301   bool has_compiled_code();
302   void log_nmethod_identity(xmlStream* log);
303   bool is_not_reached(int bci);
304   bool was_executed_more_than(int times);
305   bool has_unloaded_classes_in_signature();
306   bool is_klass_loaded(int refinfo_index, bool must_be_resolved) const;
307   bool check_call(int refinfo_index, bool is_static) const;
308   bool ensure_method_data();  // make sure it exists in the VM also
309   MethodCounters* ensure_method_counters();
310   int instructions_size();
311   int scale_count(int count, float prof_factor = 1.);  // make MDO count commensurate with IIC
312 
313   // Stack walking support
314   bool is_ignored_by_security_stack_walk() const;
315 
316   // JSR 292 support
317   bool is_method_handle_intrinsic()  const;
318   bool is_compiled_lambda_form() const;
319   bool has_member_arg() const;
320 
321   // What kind of ciObject is this?
322   bool is_method() const                         { return true; }
323 
324   // Java access flags
325   bool is_public      () const                   { return flags().is_public(); }
326   bool is_private     () const                   { return flags().is_private(); }
327   bool is_protected   () const                   { return flags().is_protected(); }
328   bool is_static      () const                   { return flags().is_static(); }
329   bool is_final       () const                   { return flags().is_final(); }
330   bool is_synchronized() const                   { return flags().is_synchronized(); }
331   bool is_native      () const                   { return flags().is_native(); }
332   bool is_interface   () const                   { return flags().is_interface(); }
333   bool is_abstract    () const                   { return flags().is_abstract(); }
334   bool is_strict      () const                   { return flags().is_strict(); }
335 
336   // Other flags
337   bool is_empty_method() const;
338   bool is_vanilla_constructor() const;
339   bool is_final_method() const                   { return is_final() || holder()-&gt;is_final(); }
340   bool is_default_method() const                 { return !is_abstract() &amp;&amp; !is_private() &amp;&amp;
341                                                           holder()-&gt;is_interface(); }
342   bool is_overpass    () const                   { check_is_loaded(); return _is_overpass; }
343   bool has_loops      () const;
344   bool has_jsrs       () const;
345   bool is_getter      () const;
346   bool is_setter      () const;
347   bool is_accessor    () const;
348   bool is_initializer () const;
349   bool can_be_statically_bound() const           { return _can_be_statically_bound; }
350   bool has_reserved_stack_access() const         { return _has_reserved_stack_access; }
351   bool is_boxing_method() const;
352   bool is_unboxing_method() const;
353   bool is_object_initializer() const;
354 
<a name="3" id="anc3"></a>

355   // Replay data methods
356   void dump_name_as_ascii(outputStream* st);
357   void dump_replay_data(outputStream* st);
358 
359   // Print the bytecodes of this method.
360   void print_codes_on(outputStream* st);
361   void print_codes() {
362     print_codes_on(tty);
363   }
364   void print_codes_on(int from, int to, outputStream* st);
365 
366   // Print the name of this method in various incarnations.
367   void print_name(outputStream* st = tty);
368   void print_short_name(outputStream* st = tty);
369 
370   static bool is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method);
371 };
372 
373 #endif // SHARE_CI_CIMETHOD_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/ci/ciMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciMetadata.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethod.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -70,29 +70,29 @@</span>
    _holder(holder)
  {
    assert(h_m() != NULL, &quot;no null method&quot;);
  
    if (LogTouchedMethods) {
<span class="udiff-line-modified-removed">-     h_m()-&gt;log_touched(Thread::current());</span>
<span class="udiff-line-modified-added">+     h_m-&gt;log_touched(Thread::current());</span>
    }
    // These fields are always filled in in loaded methods.
<span class="udiff-line-modified-removed">-   _flags = ciFlags(h_m()-&gt;access_flags());</span>
<span class="udiff-line-modified-added">+   _flags = ciFlags(h_m-&gt;access_flags());</span>
  
    // Easy to compute, so fill them in now.
<span class="udiff-line-modified-removed">-   _max_stack          = h_m()-&gt;max_stack();</span>
<span class="udiff-line-modified-removed">-   _max_locals         = h_m()-&gt;max_locals();</span>
<span class="udiff-line-modified-removed">-   _code_size          = h_m()-&gt;code_size();</span>
<span class="udiff-line-modified-removed">-   _intrinsic_id       = h_m()-&gt;intrinsic_id();</span>
<span class="udiff-line-modified-removed">-   _handler_count      = h_m()-&gt;exception_table_length();</span>
<span class="udiff-line-modified-removed">-   _size_of_parameters = h_m()-&gt;size_of_parameters();</span>
<span class="udiff-line-modified-removed">-   _uses_monitors      = h_m()-&gt;access_flags().has_monitor_bytecodes();</span>
<span class="udiff-line-modified-removed">-   _balanced_monitors  = !_uses_monitors || h_m()-&gt;access_flags().is_monitor_matching();</span>
<span class="udiff-line-modified-removed">-   _is_c1_compilable   = !h_m()-&gt;is_not_c1_compilable();</span>
<span class="udiff-line-modified-removed">-   _is_c2_compilable   = !h_m()-&gt;is_not_c2_compilable();</span>
<span class="udiff-line-modified-added">+   _max_stack          = h_m-&gt;max_stack();</span>
<span class="udiff-line-modified-added">+   _max_locals         = h_m-&gt;max_locals();</span>
<span class="udiff-line-modified-added">+   _code_size          = h_m-&gt;code_size();</span>
<span class="udiff-line-modified-added">+   _intrinsic_id       = h_m-&gt;intrinsic_id();</span>
<span class="udiff-line-modified-added">+   _handler_count      = h_m-&gt;exception_table_length();</span>
<span class="udiff-line-modified-added">+   _size_of_parameters = h_m-&gt;size_of_parameters();</span>
<span class="udiff-line-modified-added">+   _uses_monitors      = h_m-&gt;access_flags().has_monitor_bytecodes();</span>
<span class="udiff-line-modified-added">+   _balanced_monitors  = !_uses_monitors || h_m-&gt;access_flags().is_monitor_matching();</span>
<span class="udiff-line-modified-added">+   _is_c1_compilable   = !h_m-&gt;is_not_c1_compilable();</span>
<span class="udiff-line-modified-added">+   _is_c2_compilable   = !h_m-&gt;is_not_c2_compilable();</span>
    _can_be_parsed      = true;
<span class="udiff-line-modified-removed">-   _has_reserved_stack_access = h_m()-&gt;has_reserved_stack_access();</span>
<span class="udiff-line-modified-removed">-   _is_overpass        = h_m()-&gt;is_overpass();</span>
<span class="udiff-line-modified-added">+   _has_reserved_stack_access = h_m-&gt;has_reserved_stack_access();</span>
<span class="udiff-line-modified-added">+   _is_overpass        = h_m-&gt;is_overpass();</span>
    // Lazy fields, filled in on demand.  Require allocation.
    _code               = NULL;
    _exception_handlers = NULL;
    _liveness           = NULL;
    _method_blocks = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,41 +109,41 @@</span>
        _is_c1_compilable = false;
        _is_c2_compilable = false;
        _can_be_parsed = false;
      }
    } else {
<span class="udiff-line-modified-removed">-     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
<span class="udiff-line-modified-added">+     DEBUG_ONLY(CompilerThread::current()-&gt;check_possible_safepoint());</span>
    }
  
<span class="udiff-line-modified-removed">-   if (h_m()-&gt;method_holder()-&gt;is_linked()) {</span>
<span class="udiff-line-modified-removed">-     _can_be_statically_bound = h_m()-&gt;can_be_statically_bound();</span>
<span class="udiff-line-modified-added">+   if (h_m-&gt;method_holder()-&gt;is_linked()) {</span>
<span class="udiff-line-modified-added">+     _can_be_statically_bound = h_m-&gt;can_be_statically_bound();</span>
    } else {
      // Have to use a conservative value in this case.
      _can_be_statically_bound = false;
    }
  
    // Adjust the definition of this condition to be more useful:
    // %%% take these conditions into account in vtable generation
<span class="udiff-line-modified-removed">-   if (!_can_be_statically_bound &amp;&amp; h_m()-&gt;is_private())</span>
<span class="udiff-line-modified-added">+   if (!_can_be_statically_bound &amp;&amp; h_m-&gt;is_private())</span>
      _can_be_statically_bound = true;
<span class="udiff-line-modified-removed">-   if (_can_be_statically_bound &amp;&amp; h_m()-&gt;is_abstract())</span>
<span class="udiff-line-modified-added">+   if (_can_be_statically_bound &amp;&amp; h_m-&gt;is_abstract())</span>
      _can_be_statically_bound = false;
  
    // generating _signature may allow GC and therefore move m.
    // These fields are always filled in.
<span class="udiff-line-modified-removed">-   _name = env-&gt;get_symbol(h_m()-&gt;name());</span>
<span class="udiff-line-modified-removed">-   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m()-&gt;signature());</span>
<span class="udiff-line-modified-removed">-   constantPoolHandle cpool = h_m()-&gt;constants();</span>
<span class="udiff-line-modified-added">+   _name = env-&gt;get_symbol(h_m-&gt;name());</span>
<span class="udiff-line-modified-added">+   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m-&gt;signature());</span>
<span class="udiff-line-modified-added">+   constantPoolHandle cpool(Thread::current(), h_m-&gt;constants());</span>
    _signature = new (env-&gt;arena()) ciSignature(_holder, cpool, sig_symbol);
    _method_data = NULL;
<span class="udiff-line-modified-removed">-   _nmethod_age = h_m()-&gt;nmethod_age();</span>
<span class="udiff-line-modified-added">+   _nmethod_age = h_m-&gt;nmethod_age();</span>
    // Take a snapshot of these values, so they will be commensurate with the MDO.
    if (ProfileInterpreter || TieredCompilation) {
<span class="udiff-line-modified-removed">-     int invcnt = h_m()-&gt;interpreter_invocation_count();</span>
<span class="udiff-line-modified-added">+     int invcnt = h_m-&gt;interpreter_invocation_count();</span>
      // if the value overflowed report it as max int
      _interpreter_invocation_count = invcnt &lt; 0 ? max_jint : invcnt ;
<span class="udiff-line-modified-removed">-     _interpreter_throwout_count   = h_m()-&gt;interpreter_throwout_count();</span>
<span class="udiff-line-modified-added">+     _interpreter_throwout_count   = h_m-&gt;interpreter_throwout_count();</span>
    } else {
      _interpreter_invocation_count = 0;
      _interpreter_throwout_count = 0;
    }
    if (_interpreter_invocation_count == 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -429,11 +429,11 @@</span>
  // OSR when loading the locals.
  
  ResourceBitMap ciMethod::live_local_oops_at_bci(int bci) {
    VM_ENTRY_MARK;
    InterpreterOopMap mask;
<span class="udiff-line-modified-removed">-   OopMapCache::compute_one_oop_map(get_Method(), bci, &amp;mask);</span>
<span class="udiff-line-modified-added">+   OopMapCache::compute_one_oop_map(methodHandle(THREAD, get_Method()), bci, &amp;mask);</span>
    int mask_size = max_locals();
    ResourceBitMap result(mask_size);
    int i;
    for (i = 0; i &lt; mask_size ; i++ ) {
      if (mask.is_oop(i)) result.set_bit(i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -459,10 +459,31 @@</span>
    return _liveness-&gt;get_bci_block_start();
  }
  #endif // COMPILER1
  
  
<span class="udiff-line-added">+ // ------------------------------------------------------------------</span>
<span class="udiff-line-added">+ // ciMethod::check_overflow</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Check whether the profile counter is overflowed and adjust if true.</span>
<span class="udiff-line-added">+ // For invoke* it will turn negative values into max_jint,</span>
<span class="udiff-line-added">+ // and for checkcast/aastore/instanceof turn positive values into min_jint.</span>
<span class="udiff-line-added">+ int ciMethod::check_overflow(int c, Bytecodes::Code code) {</span>
<span class="udiff-line-added">+   switch (code) {</span>
<span class="udiff-line-added">+     case Bytecodes::_aastore:    // fall-through</span>
<span class="udiff-line-added">+     case Bytecodes::_checkcast:  // fall-through</span>
<span class="udiff-line-added">+     case Bytecodes::_instanceof: {</span>
<span class="udiff-line-added">+       return (c &gt; 0 ? min_jint : c); // always non-positive</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     default: {</span>
<span class="udiff-line-added">+       assert(Bytecodes::is_invoke(code), &quot;%s&quot;, Bytecodes::name(code));</span>
<span class="udiff-line-added">+       return (c &lt; 0 ? max_jint : c); // always non-negative</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  // ------------------------------------------------------------------
  // ciMethod::call_profile_at_bci
  //
  // Get the ciCallProfile for the invocation of this method.
  // Also reports receiver types for non-call type checks (if TypeProfileCasts).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -471,11 +492,11 @@</span>
    ciCallProfile result;
    if (method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
      ciProfileData* data = method_data()-&gt;bci_to_data(bci);
      if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
        // Every profiled call site has a counter.
<span class="udiff-line-modified-removed">-       int count = data-&gt;as_CounterData()-&gt;count();</span>
<span class="udiff-line-modified-added">+       int count = check_overflow(data-&gt;as_CounterData()-&gt;count(), java_code_at_bci(bci));</span>
  
        if (!data-&gt;is_ReceiverTypeData()) {
          result._receiver_count[0] = 0;  // that&#39;s a definite zero
        } else { // ReceiverTypeData is a subclass of CounterData
          ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,13 +521,13 @@</span>
            }
          }
          for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
            ciKlass* receiver = call-&gt;receiver(i);
            if (receiver == NULL)  continue;
<span class="udiff-line-modified-removed">-           int rcount = call-&gt;receiver_count(i) + epsilon;</span>
<span class="udiff-line-modified-added">+           int rcount = saturated_add(call-&gt;receiver_count(i), epsilon);</span>
            if (rcount == 0) rcount = 1; // Should be valid value
<span class="udiff-line-modified-removed">-           receivers_count_total += rcount;</span>
<span class="udiff-line-modified-added">+           receivers_count_total = saturated_add(receivers_count_total, rcount);</span>
            // Add the receiver to result data.
            result.add_receiver(receiver, rcount);
            // If we extend profiling to record methods,
            // we will set result._method also.
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,11 +553,11 @@</span>
          // Make the count consistent if this is a call profile. If count is
          // zero or less, presume that this is a typecheck profile and
          // do nothing.  Otherwise, increase count to be the sum of all
          // receiver&#39;s counts.
          if (count &gt;= 0) {
<span class="udiff-line-modified-removed">-           count += receivers_count_total;</span>
<span class="udiff-line-modified-added">+           count = saturated_add(count, receivers_count_total);</span>
          }
        }
        result._count = count;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -726,12 +747,12 @@</span>
  
    methodHandle target;
    {
      MutexLocker locker(Compile_lock);
      Klass* context = actual_recv-&gt;get_Klass();
<span class="udiff-line-modified-removed">-     target = Dependencies::find_unique_concrete_method(context,</span>
<span class="udiff-line-modified-removed">-                                                        root_m-&gt;get_Method());</span>
<span class="udiff-line-modified-added">+     target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,</span>
<span class="udiff-line-modified-added">+                                                        root_m-&gt;get_Method()));</span>
      // %%% Should upgrade this ciMethod API to look for 1 or 2 concrete methods.
    }
  
  #ifndef PRODUCT
    if (TraceDependencies &amp;&amp; target() != NULL &amp;&amp; target() != root_m-&gt;get_Method()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -762,10 +783,18 @@</span>
    }
    assert(!target()-&gt;is_abstract(), &quot;not allowed&quot;);
    return CURRENT_THREAD_ENV-&gt;get_method(target());
  }
  
<span class="udiff-line-added">+ // ------------------------------------------------------------------</span>
<span class="udiff-line-added">+ // ciMethod::can_be_statically_bound</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Tries to determine whether a method can be statically bound in some context.</span>
<span class="udiff-line-added">+ bool ciMethod::can_be_statically_bound(ciInstanceKlass* context) const {</span>
<span class="udiff-line-added">+   return (holder() == context) &amp;&amp; can_be_statically_bound();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // ------------------------------------------------------------------
  // ciMethod::resolve_invoke
  //
  // Given a known receiver klass, find the target for the call.
  // Return NULL if the call has no target or the target is abstract.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -779,11 +808,11 @@</span>
     Symbol* h_name      = name()-&gt;get_symbol();
     Symbol* h_signature = signature()-&gt;get_symbol();
  
     LinkInfo link_info(resolved, h_name, h_signature, caller_klass,
                        check_access ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
<span class="udiff-line-modified-removed">-    methodHandle m;</span>
<span class="udiff-line-modified-added">+    Method* m = NULL;</span>
     // Only do exact lookup if receiver klass has been linked.  Otherwise,
     // the vtable has not been setup, and the LinkResolver will fail.
     if (recv-&gt;is_array_klass()
          ||
         (InstanceKlass::cast(recv)-&gt;is_linked() &amp;&amp; !exact_receiver-&gt;is_interface())) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -792,18 +821,18 @@</span>
       } else {
         m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);
       }
     }
  
<span class="udiff-line-modified-removed">-    if (m.is_null()) {</span>
<span class="udiff-line-modified-added">+    if (m == NULL) {</span>
       // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
       return NULL;
     }
  
     ciMethod* result = this;
<span class="udiff-line-modified-removed">-    if (m() != get_Method()) {</span>
<span class="udiff-line-modified-removed">-      result = CURRENT_THREAD_ENV-&gt;get_method(m());</span>
<span class="udiff-line-modified-added">+    if (m != get_Method()) {</span>
<span class="udiff-line-modified-added">+      result = CURRENT_THREAD_ENV-&gt;get_method(m);</span>
     }
  
     // Don&#39;t return abstract methods because they aren&#39;t
     // optimizable or interesting.
     if (result-&gt;is_abstract()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -923,10 +952,17 @@</span>
    check_is_loaded();
    VM_ENTRY_MARK;
    return get_Method()-&gt;is_ignored_by_security_stack_walk();
  }
  
<span class="udiff-line-added">+ // ------------------------------------------------------------------</span>
<span class="udiff-line-added">+ // ciMethod::needs_clinit_barrier</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ bool ciMethod::needs_clinit_barrier() const {</span>
<span class="udiff-line-added">+   check_is_loaded();</span>
<span class="udiff-line-added">+   return is_static() &amp;&amp; !holder()-&gt;is_initialized();</span>
<span class="udiff-line-added">+ }</span>
  
  // ------------------------------------------------------------------
  // invokedynamic support
  
  // ------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -997,11 +1033,12 @@</span>
  // public, retroactive version
  bool ciMethod::ensure_method_data() {
    bool result = true;
    if (_method_data == NULL || _method_data-&gt;is_empty()) {
      GUARDED_VM_ENTRY({
<span class="udiff-line-modified-removed">-       result = ensure_method_data(get_Method());</span>
<span class="udiff-line-modified-added">+       methodHandle mh(Thread::current(), get_Method());</span>
<span class="udiff-line-added">+       result = ensure_method_data(mh);</span>
      });
    }
    return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1094,11 +1131,11 @@</span>
    if (is_c1_compile(env-&gt;comp_level())) {
      _is_c1_compilable = false;
    } else {
      _is_c2_compilable = false;
    }
<span class="udiff-line-modified-removed">-   get_Method()-&gt;set_not_compilable(env-&gt;comp_level(), true, reason);</span>
<span class="udiff-line-modified-added">+   get_Method()-&gt;set_not_compilable(reason, env-&gt;comp_level());</span>
  }
  
  // ------------------------------------------------------------------
  // ciMethod::can_be_osr_compiled
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1230,11 +1267,11 @@</span>
    {
      EXCEPTION_MARK;
      HandleMark hm(THREAD);
      constantPoolHandle pool (THREAD, get_Method()-&gt;constants());
      Bytecodes::Code code = (is_static ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual);
<span class="udiff-line-modified-removed">-     methodHandle spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);</span>
<span class="udiff-line-modified-added">+     Method* spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);</span>
      if (HAS_PENDING_EXCEPTION) {
        CLEAR_PENDING_EXCEPTION;
        return false;
      } else {
        return (spec_method-&gt;is_static() == is_static);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1416,12 +1453,12 @@</span>
  }
  
  // ------------------------------------------------------------------
  
  static BasicType erase_to_word_type(BasicType bt) {
<span class="udiff-line-modified-removed">-   if (is_subword_type(bt)) return T_INT;</span>
<span class="udiff-line-modified-removed">-   if (bt == T_ARRAY)       return T_OBJECT;</span>
<span class="udiff-line-modified-added">+   if (is_subword_type(bt))   return T_INT;</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(bt)) return T_OBJECT;</span>
    return bt;
  }
  
  static bool basic_types_match(ciType* t1, ciType* t2) {
    if (t1 == t2)  return true;
</pre>
<center><a href="ciMetadata.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethod.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
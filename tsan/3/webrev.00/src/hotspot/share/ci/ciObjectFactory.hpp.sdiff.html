<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciObjectFactory.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjectFactory.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciReplay.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciObjectFactory.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57 public:
 58   struct NonPermObject : public ResourceObj {
 59     ciObject*      _object;
 60     NonPermObject* _next;
 61 
 62     inline NonPermObject(NonPermObject* &amp;bucket, oop key, ciObject* object);
 63     ciObject*     object()  { return _object; }
 64     NonPermObject* &amp;next()  { return _next; }
 65   };
 66 private:
 67   enum { NON_PERM_BUCKETS = 61 };
 68   NonPermObject* _non_perm_bucket[NON_PERM_BUCKETS];
 69   int _non_perm_count;
 70 
 71   static int metadata_compare(Metadata* const&amp; key, ciMetadata* const&amp; elt);
 72 
 73   ciObject* create_new_object(oop o);
 74   ciMetadata* create_new_metadata(Metadata* o);
 75 
 76   static bool is_equal(NonPermObject* p, oop key) {
<span class="line-modified"> 77     return oopDesc::equals(p-&gt;object()-&gt;get_oop(), key);</span>
 78   }
 79 
 80   NonPermObject* &amp;find_non_perm(oop key);
 81   void insert_non_perm(NonPermObject* &amp;where, oop key, ciObject* obj);
 82 
 83   void init_ident_of(ciBaseObject* obj);
 84 
 85   Arena* arena() { return _arena; }
 86 
 87   void print_contents_impl();
 88 
 89   ciInstance* get_unloaded_instance(ciInstanceKlass* klass);
 90 
 91 public:
 92   static bool is_initialized() { return _initialized; }
 93 
 94   static void initialize();
 95   void init_shared_objects();
 96   void remove_symbols();
 97 
</pre>
<hr />
<pre>
123   // Get a ciInstance representing an unresolved method handle constant.
124   ciInstance* get_unloaded_method_handle_constant(ciKlass*  holder,
125                                                   ciSymbol* name,
126                                                   ciSymbol* signature,
127                                                   int       ref_kind);
128 
129   // Get a ciInstance representing an unresolved method type constant.
130   ciInstance* get_unloaded_method_type_constant(ciSymbol* signature);
131 
132 
133   ciInstance* get_unloaded_object_constant();
134 
135   // Get the ciMethodData representing the methodData for a method
136   // with none.
137   ciMethodData* get_empty_methodData();
138 
139   ciReturnAddress* get_return_address(int bci);
140 
141   GrowableArray&lt;ciMetadata*&gt;* get_ci_metadata() const { return _ci_metadata; }
142   // RedefineClasses support
<span class="line-modified">143   void metadata_do(void f(Metadata*));</span>
144 
145   void print_contents();
146   void print();
147 };
148 
149 #endif // SHARE_CI_CIOBJECTFACTORY_HPP
</pre>
</td>
<td>
<hr />
<pre>
 57 public:
 58   struct NonPermObject : public ResourceObj {
 59     ciObject*      _object;
 60     NonPermObject* _next;
 61 
 62     inline NonPermObject(NonPermObject* &amp;bucket, oop key, ciObject* object);
 63     ciObject*     object()  { return _object; }
 64     NonPermObject* &amp;next()  { return _next; }
 65   };
 66 private:
 67   enum { NON_PERM_BUCKETS = 61 };
 68   NonPermObject* _non_perm_bucket[NON_PERM_BUCKETS];
 69   int _non_perm_count;
 70 
 71   static int metadata_compare(Metadata* const&amp; key, ciMetadata* const&amp; elt);
 72 
 73   ciObject* create_new_object(oop o);
 74   ciMetadata* create_new_metadata(Metadata* o);
 75 
 76   static bool is_equal(NonPermObject* p, oop key) {
<span class="line-modified"> 77     return p-&gt;object()-&gt;get_oop() == key;</span>
 78   }
 79 
 80   NonPermObject* &amp;find_non_perm(oop key);
 81   void insert_non_perm(NonPermObject* &amp;where, oop key, ciObject* obj);
 82 
 83   void init_ident_of(ciBaseObject* obj);
 84 
 85   Arena* arena() { return _arena; }
 86 
 87   void print_contents_impl();
 88 
 89   ciInstance* get_unloaded_instance(ciInstanceKlass* klass);
 90 
 91 public:
 92   static bool is_initialized() { return _initialized; }
 93 
 94   static void initialize();
 95   void init_shared_objects();
 96   void remove_symbols();
 97 
</pre>
<hr />
<pre>
123   // Get a ciInstance representing an unresolved method handle constant.
124   ciInstance* get_unloaded_method_handle_constant(ciKlass*  holder,
125                                                   ciSymbol* name,
126                                                   ciSymbol* signature,
127                                                   int       ref_kind);
128 
129   // Get a ciInstance representing an unresolved method type constant.
130   ciInstance* get_unloaded_method_type_constant(ciSymbol* signature);
131 
132 
133   ciInstance* get_unloaded_object_constant();
134 
135   // Get the ciMethodData representing the methodData for a method
136   // with none.
137   ciMethodData* get_empty_methodData();
138 
139   ciReturnAddress* get_return_address(int bci);
140 
141   GrowableArray&lt;ciMetadata*&gt;* get_ci_metadata() const { return _ci_metadata; }
142   // RedefineClasses support
<span class="line-modified">143   void metadata_do(MetadataClosure* f);</span>
144 
145   void print_contents();
146   void print();
147 };
148 
149 #endif // SHARE_CI_CIOBJECTFACTORY_HPP
</pre>
</td>
</tr>
</table>
<center><a href="ciObjectFactory.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciReplay.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
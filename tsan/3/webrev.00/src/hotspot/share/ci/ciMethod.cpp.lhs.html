<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciCallProfile.hpp&quot;
  27 #include &quot;ci/ciExceptionHandler.hpp&quot;
  28 #include &quot;ci/ciInstanceKlass.hpp&quot;
  29 #include &quot;ci/ciMethod.hpp&quot;
  30 #include &quot;ci/ciMethodBlocks.hpp&quot;
  31 #include &quot;ci/ciMethodData.hpp&quot;
  32 #include &quot;ci/ciStreams.hpp&quot;
  33 #include &quot;ci/ciSymbol.hpp&quot;
  34 #include &quot;ci/ciReplay.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/methodLiveness.hpp&quot;
  39 #include &quot;interpreter/interpreter.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;interpreter/oopMapCache.hpp&quot;
  42 #include &quot;memory/allocation.inline.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;oops/generateOopMap.hpp&quot;
  45 #include &quot;oops/method.inline.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;prims/nativeLookup.hpp&quot;
  48 #include &quot;runtime/deoptimization.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;utilities/bitMap.inline.hpp&quot;
  51 #include &quot;utilities/xmlstream.hpp&quot;
  52 #ifdef COMPILER2
  53 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  54 #include &quot;ci/ciTypeFlow.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #endif
  57 
  58 // ciMethod
  59 //
  60 // This class represents a Method* in the HotSpot virtual
  61 // machine.
  62 
  63 
  64 // ------------------------------------------------------------------
  65 // ciMethod::ciMethod
  66 //
  67 // Loaded method.
  68 ciMethod::ciMethod(const methodHandle&amp; h_m, ciInstanceKlass* holder) :
  69   ciMetadata(h_m()),
  70   _holder(holder)
  71 {
  72   assert(h_m() != NULL, &quot;no null method&quot;);
  73 
  74   if (LogTouchedMethods) {
<a name="1" id="anc1"></a><span class="line-modified">  75     h_m()-&gt;log_touched(Thread::current());</span>
  76   }
  77   // These fields are always filled in in loaded methods.
<a name="2" id="anc2"></a><span class="line-modified">  78   _flags = ciFlags(h_m()-&gt;access_flags());</span>
  79 
  80   // Easy to compute, so fill them in now.
<a name="3" id="anc3"></a><span class="line-modified">  81   _max_stack          = h_m()-&gt;max_stack();</span>
<span class="line-modified">  82   _max_locals         = h_m()-&gt;max_locals();</span>
<span class="line-modified">  83   _code_size          = h_m()-&gt;code_size();</span>
<span class="line-modified">  84   _intrinsic_id       = h_m()-&gt;intrinsic_id();</span>
<span class="line-modified">  85   _handler_count      = h_m()-&gt;exception_table_length();</span>
<span class="line-modified">  86   _size_of_parameters = h_m()-&gt;size_of_parameters();</span>
<span class="line-modified">  87   _uses_monitors      = h_m()-&gt;access_flags().has_monitor_bytecodes();</span>
<span class="line-modified">  88   _balanced_monitors  = !_uses_monitors || h_m()-&gt;access_flags().is_monitor_matching();</span>
<span class="line-modified">  89   _is_c1_compilable   = !h_m()-&gt;is_not_c1_compilable();</span>
<span class="line-modified">  90   _is_c2_compilable   = !h_m()-&gt;is_not_c2_compilable();</span>
  91   _can_be_parsed      = true;
<a name="4" id="anc4"></a><span class="line-modified">  92   _has_reserved_stack_access = h_m()-&gt;has_reserved_stack_access();</span>
<span class="line-modified">  93   _is_overpass        = h_m()-&gt;is_overpass();</span>
  94   // Lazy fields, filled in on demand.  Require allocation.
  95   _code               = NULL;
  96   _exception_handlers = NULL;
  97   _liveness           = NULL;
  98   _method_blocks = NULL;
  99 #if defined(COMPILER2)
 100   _flow               = NULL;
 101   _bcea               = NULL;
 102 #endif // COMPILER2
 103 
 104   ciEnv *env = CURRENT_ENV;
 105   if (env-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
 106     // 6328518 check hotswap conditions under the right lock.
 107     MutexLocker locker(Compile_lock);
 108     if (Dependencies::check_evol_method(h_m()) != NULL) {
 109       _is_c1_compilable = false;
 110       _is_c2_compilable = false;
 111       _can_be_parsed = false;
 112     }
 113   } else {
<a name="5" id="anc5"></a><span class="line-modified"> 114     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
 115   }
 116 
<a name="6" id="anc6"></a><span class="line-modified"> 117   if (h_m()-&gt;method_holder()-&gt;is_linked()) {</span>
<span class="line-modified"> 118     _can_be_statically_bound = h_m()-&gt;can_be_statically_bound();</span>
 119   } else {
 120     // Have to use a conservative value in this case.
 121     _can_be_statically_bound = false;
 122   }
 123 
 124   // Adjust the definition of this condition to be more useful:
 125   // %%% take these conditions into account in vtable generation
<a name="7" id="anc7"></a><span class="line-modified"> 126   if (!_can_be_statically_bound &amp;&amp; h_m()-&gt;is_private())</span>
 127     _can_be_statically_bound = true;
<a name="8" id="anc8"></a><span class="line-modified"> 128   if (_can_be_statically_bound &amp;&amp; h_m()-&gt;is_abstract())</span>
 129     _can_be_statically_bound = false;
 130 
 131   // generating _signature may allow GC and therefore move m.
 132   // These fields are always filled in.
<a name="9" id="anc9"></a><span class="line-modified"> 133   _name = env-&gt;get_symbol(h_m()-&gt;name());</span>
<span class="line-modified"> 134   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m()-&gt;signature());</span>
<span class="line-modified"> 135   constantPoolHandle cpool = h_m()-&gt;constants();</span>
 136   _signature = new (env-&gt;arena()) ciSignature(_holder, cpool, sig_symbol);
 137   _method_data = NULL;
<a name="10" id="anc10"></a><span class="line-modified"> 138   _nmethod_age = h_m()-&gt;nmethod_age();</span>
 139   // Take a snapshot of these values, so they will be commensurate with the MDO.
 140   if (ProfileInterpreter || TieredCompilation) {
<a name="11" id="anc11"></a><span class="line-modified"> 141     int invcnt = h_m()-&gt;interpreter_invocation_count();</span>
 142     // if the value overflowed report it as max int
 143     _interpreter_invocation_count = invcnt &lt; 0 ? max_jint : invcnt ;
<a name="12" id="anc12"></a><span class="line-modified"> 144     _interpreter_throwout_count   = h_m()-&gt;interpreter_throwout_count();</span>
 145   } else {
 146     _interpreter_invocation_count = 0;
 147     _interpreter_throwout_count = 0;
 148   }
 149   if (_interpreter_invocation_count == 0)
 150     _interpreter_invocation_count = 1;
 151   _instructions_size = -1;
 152 #ifdef ASSERT
 153   if (ReplayCompiles) {
 154     ciReplay::initialize(this);
 155   }
 156 #endif
 157 }
 158 
 159 
 160 // ------------------------------------------------------------------
 161 // ciMethod::ciMethod
 162 //
 163 // Unloaded method.
 164 ciMethod::ciMethod(ciInstanceKlass* holder,
 165                    ciSymbol*        name,
 166                    ciSymbol*        signature,
 167                    ciInstanceKlass* accessor) :
 168   ciMetadata((Metadata*)NULL),
 169   _name(                   name),
 170   _holder(                 holder),
 171   _method_data(            NULL),
 172   _method_blocks(          NULL),
 173   _intrinsic_id(           vmIntrinsics::_none),
 174   _instructions_size(-1),
 175   _can_be_statically_bound(false),
 176   _liveness(               NULL)
 177 #if defined(COMPILER2)
 178   ,
 179   _flow(                   NULL),
 180   _bcea(                   NULL)
 181 #endif // COMPILER2
 182 {
 183   // Usually holder and accessor are the same type but in some cases
 184   // the holder has the wrong class loader (e.g. invokedynamic call
 185   // sites) so we pass the accessor.
 186   _signature = new (CURRENT_ENV-&gt;arena()) ciSignature(accessor, constantPoolHandle(), signature);
 187 }
 188 
 189 
 190 // ------------------------------------------------------------------
 191 // ciMethod::load_code
 192 //
 193 // Load the bytecodes and exception handler table for this method.
 194 void ciMethod::load_code() {
 195   VM_ENTRY_MARK;
 196   assert(is_loaded(), &quot;only loaded methods have code&quot;);
 197 
 198   Method* me = get_Method();
 199   Arena* arena = CURRENT_THREAD_ENV-&gt;arena();
 200 
 201   // Load the bytecodes.
 202   _code = (address)arena-&gt;Amalloc(code_size());
 203   memcpy(_code, me-&gt;code_base(), code_size());
 204 
 205 #if INCLUDE_JVMTI
 206   // Revert any breakpoint bytecodes in ci&#39;s copy
 207   if (me-&gt;number_of_breakpoints() &gt; 0) {
 208     BreakpointInfo* bp = me-&gt;method_holder()-&gt;breakpoints();
 209     for (; bp != NULL; bp = bp-&gt;next()) {
 210       if (bp-&gt;match(me)) {
 211         code_at_put(bp-&gt;bci(), bp-&gt;orig_bytecode());
 212       }
 213     }
 214   }
 215 #endif
 216 
 217   // And load the exception table.
 218   ExceptionTable exc_table(me);
 219 
 220   // Allocate one extra spot in our list of exceptions.  This
 221   // last entry will be used to represent the possibility that
 222   // an exception escapes the method.  See ciExceptionHandlerStream
 223   // for details.
 224   _exception_handlers =
 225     (ciExceptionHandler**)arena-&gt;Amalloc(sizeof(ciExceptionHandler*)
 226                                          * (_handler_count + 1));
 227   if (_handler_count &gt; 0) {
 228     for (int i=0; i&lt;_handler_count; i++) {
 229       _exception_handlers[i] = new (arena) ciExceptionHandler(
 230                                 holder(),
 231             /* start    */      exc_table.start_pc(i),
 232             /* limit    */      exc_table.end_pc(i),
 233             /* goto pc  */      exc_table.handler_pc(i),
 234             /* cp index */      exc_table.catch_type_index(i));
 235     }
 236   }
 237 
 238   // Put an entry at the end of our list to represent the possibility
 239   // of exceptional exit.
 240   _exception_handlers[_handler_count] =
 241     new (arena) ciExceptionHandler(holder(), 0, code_size(), -1, 0);
 242 
 243   if (CIPrintMethodCodes) {
 244     print_codes();
 245   }
 246 }
 247 
 248 
 249 // ------------------------------------------------------------------
 250 // ciMethod::has_linenumber_table
 251 //
 252 // length unknown until decompression
 253 bool    ciMethod::has_linenumber_table() const {
 254   check_is_loaded();
 255   VM_ENTRY_MARK;
 256   return get_Method()-&gt;has_linenumber_table();
 257 }
 258 
 259 
 260 // ------------------------------------------------------------------
 261 // ciMethod::compressed_linenumber_table
 262 u_char* ciMethod::compressed_linenumber_table() const {
 263   check_is_loaded();
 264   VM_ENTRY_MARK;
 265   return get_Method()-&gt;compressed_linenumber_table();
 266 }
 267 
 268 
 269 // ------------------------------------------------------------------
 270 // ciMethod::line_number_from_bci
 271 int ciMethod::line_number_from_bci(int bci) const {
 272   check_is_loaded();
 273   VM_ENTRY_MARK;
 274   return get_Method()-&gt;line_number_from_bci(bci);
 275 }
 276 
 277 
 278 // ------------------------------------------------------------------
 279 // ciMethod::vtable_index
 280 //
 281 // Get the position of this method&#39;s entry in the vtable, if any.
 282 int ciMethod::vtable_index() {
 283   check_is_loaded();
 284   assert(holder()-&gt;is_linked(), &quot;must be linked&quot;);
 285   VM_ENTRY_MARK;
 286   return get_Method()-&gt;vtable_index();
 287 }
 288 
 289 
 290 // ------------------------------------------------------------------
 291 // ciMethod::native_entry
 292 //
 293 // Get the address of this method&#39;s native code, if any.
 294 address ciMethod::native_entry() {
 295   check_is_loaded();
 296   assert(flags().is_native(), &quot;must be native method&quot;);
 297   VM_ENTRY_MARK;
 298   Method* method = get_Method();
 299   address entry = method-&gt;native_function();
 300   assert(entry != NULL, &quot;must be valid entry point&quot;);
 301   return entry;
 302 }
 303 
 304 
 305 // ------------------------------------------------------------------
 306 // ciMethod::interpreter_entry
 307 //
 308 // Get the entry point for running this method in the interpreter.
 309 address ciMethod::interpreter_entry() {
 310   check_is_loaded();
 311   VM_ENTRY_MARK;
 312   methodHandle mh(THREAD, get_Method());
 313   return Interpreter::entry_for_method(mh);
 314 }
 315 
 316 
 317 // ------------------------------------------------------------------
 318 // ciMethod::uses_balanced_monitors
 319 //
 320 // Does this method use monitors in a strict stack-disciplined manner?
 321 bool ciMethod::has_balanced_monitors() {
 322   check_is_loaded();
 323   if (_balanced_monitors) return true;
 324 
 325   // Analyze the method to see if monitors are used properly.
 326   VM_ENTRY_MARK;
 327   methodHandle method(THREAD, get_Method());
 328   assert(method-&gt;has_monitor_bytecodes(), &quot;should have checked this&quot;);
 329 
 330   // Check to see if a previous compilation computed the
 331   // monitor-matching analysis.
 332   if (method-&gt;guaranteed_monitor_matching()) {
 333     _balanced_monitors = true;
 334     return true;
 335   }
 336 
 337   {
 338     EXCEPTION_MARK;
 339     ResourceMark rm(THREAD);
 340     GeneratePairingInfo gpi(method);
 341     gpi.compute_map(CATCH);
 342     if (!gpi.monitor_safe()) {
 343       return false;
 344     }
 345     method-&gt;set_guaranteed_monitor_matching();
 346     _balanced_monitors = true;
 347   }
 348   return true;
 349 }
 350 
 351 
 352 // ------------------------------------------------------------------
 353 // ciMethod::get_flow_analysis
 354 ciTypeFlow* ciMethod::get_flow_analysis() {
 355 #if defined(COMPILER2)
 356   if (_flow == NULL) {
 357     ciEnv* env = CURRENT_ENV;
 358     _flow = new (env-&gt;arena()) ciTypeFlow(env, this);
 359     _flow-&gt;do_flow();
 360   }
 361   return _flow;
 362 #else // COMPILER2
 363   ShouldNotReachHere();
 364   return NULL;
 365 #endif // COMPILER2
 366 }
 367 
 368 
 369 // ------------------------------------------------------------------
 370 // ciMethod::get_osr_flow_analysis
 371 ciTypeFlow* ciMethod::get_osr_flow_analysis(int osr_bci) {
 372 #if defined(COMPILER2)
 373   // OSR entry points are always place after a call bytecode of some sort
 374   assert(osr_bci &gt;= 0, &quot;must supply valid OSR entry point&quot;);
 375   ciEnv* env = CURRENT_ENV;
 376   ciTypeFlow* flow = new (env-&gt;arena()) ciTypeFlow(env, this, osr_bci);
 377   flow-&gt;do_flow();
 378   return flow;
 379 #else // COMPILER2
 380   ShouldNotReachHere();
 381   return NULL;
 382 #endif // COMPILER2
 383 }
 384 
 385 // ------------------------------------------------------------------
 386 // ciMethod::raw_liveness_at_bci
 387 //
 388 // Which local variables are live at a specific bci?
 389 MethodLivenessResult ciMethod::raw_liveness_at_bci(int bci) {
 390   check_is_loaded();
 391   if (_liveness == NULL) {
 392     // Create the liveness analyzer.
 393     Arena* arena = CURRENT_ENV-&gt;arena();
 394     _liveness = new (arena) MethodLiveness(arena, this);
 395     _liveness-&gt;compute_liveness();
 396   }
 397   return _liveness-&gt;get_liveness_at(bci);
 398 }
 399 
 400 // ------------------------------------------------------------------
 401 // ciMethod::liveness_at_bci
 402 //
 403 // Which local variables are live at a specific bci?  When debugging
 404 // will return true for all locals in some cases to improve debug
 405 // information.
 406 MethodLivenessResult ciMethod::liveness_at_bci(int bci) {
 407   if (CURRENT_ENV-&gt;should_retain_local_variables() || DeoptimizeALot) {
 408     // Keep all locals live for the user&#39;s edification and amusement.
 409     MethodLivenessResult result(_max_locals);
 410     result.set_range(0, _max_locals);
 411     result.set_is_valid();
 412     return result;
 413   }
 414   return raw_liveness_at_bci(bci);
 415 }
 416 
 417 // ciMethod::live_local_oops_at_bci
 418 //
 419 // find all the live oops in the locals array for a particular bci
 420 // Compute what the interpreter believes by using the interpreter
 421 // oopmap generator. This is used as a double check during osr to
 422 // guard against conservative result from MethodLiveness making us
 423 // think a dead oop is live.  MethodLiveness is conservative in the
 424 // sense that it may consider locals to be live which cannot be live,
 425 // like in the case where a local could contain an oop or  a primitive
 426 // along different paths.  In that case the local must be dead when
 427 // those paths merge. Since the interpreter&#39;s viewpoint is used when
 428 // gc&#39;ing an interpreter frame we need to use its viewpoint  during
 429 // OSR when loading the locals.
 430 
 431 ResourceBitMap ciMethod::live_local_oops_at_bci(int bci) {
 432   VM_ENTRY_MARK;
 433   InterpreterOopMap mask;
<a name="13" id="anc13"></a><span class="line-modified"> 434   OopMapCache::compute_one_oop_map(get_Method(), bci, &amp;mask);</span>
 435   int mask_size = max_locals();
 436   ResourceBitMap result(mask_size);
 437   int i;
 438   for (i = 0; i &lt; mask_size ; i++ ) {
 439     if (mask.is_oop(i)) result.set_bit(i);
 440   }
 441   return result;
 442 }
 443 
 444 
 445 #ifdef COMPILER1
 446 // ------------------------------------------------------------------
 447 // ciMethod::bci_block_start
 448 //
 449 // Marks all bcis where a new basic block starts
 450 const BitMap&amp; ciMethod::bci_block_start() {
 451   check_is_loaded();
 452   if (_liveness == NULL) {
 453     // Create the liveness analyzer.
 454     Arena* arena = CURRENT_ENV-&gt;arena();
 455     _liveness = new (arena) MethodLiveness(arena, this);
 456     _liveness-&gt;compute_liveness();
 457   }
 458 
 459   return _liveness-&gt;get_bci_block_start();
 460 }
 461 #endif // COMPILER1
 462 
 463 
<a name="14" id="anc14"></a>




















 464 // ------------------------------------------------------------------
 465 // ciMethod::call_profile_at_bci
 466 //
 467 // Get the ciCallProfile for the invocation of this method.
 468 // Also reports receiver types for non-call type checks (if TypeProfileCasts).
 469 ciCallProfile ciMethod::call_profile_at_bci(int bci) {
 470   ResourceMark rm;
 471   ciCallProfile result;
 472   if (method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 473     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 474     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 475       // Every profiled call site has a counter.
<a name="15" id="anc15"></a><span class="line-modified"> 476       int count = data-&gt;as_CounterData()-&gt;count();</span>
 477 
 478       if (!data-&gt;is_ReceiverTypeData()) {
 479         result._receiver_count[0] = 0;  // that&#39;s a definite zero
 480       } else { // ReceiverTypeData is a subclass of CounterData
 481         ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
 482         // In addition, virtual call sites have receiver type information
 483         int receivers_count_total = 0;
 484         int morphism = 0;
 485         // Precompute morphism for the possible fixup
 486         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 487           ciKlass* receiver = call-&gt;receiver(i);
 488           if (receiver == NULL)  continue;
 489           morphism++;
 490         }
 491         int epsilon = 0;
 492         if (TieredCompilation) {
 493           // For a call, it is assumed that either the type of the receiver(s)
 494           // is recorded or an associated counter is incremented, but not both. With
 495           // tiered compilation, however, both can happen due to the interpreter and
 496           // C1 profiling invocations differently. Address that inconsistency here.
 497           if (morphism == 1 &amp;&amp; count &gt; 0) {
 498             epsilon = count;
 499             count = 0;
 500           }
 501         }
 502         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 503           ciKlass* receiver = call-&gt;receiver(i);
 504           if (receiver == NULL)  continue;
<a name="16" id="anc16"></a><span class="line-modified"> 505           int rcount = call-&gt;receiver_count(i) + epsilon;</span>
 506           if (rcount == 0) rcount = 1; // Should be valid value
<a name="17" id="anc17"></a><span class="line-modified"> 507           receivers_count_total += rcount;</span>
 508           // Add the receiver to result data.
 509           result.add_receiver(receiver, rcount);
 510           // If we extend profiling to record methods,
 511           // we will set result._method also.
 512         }
 513         // Determine call site&#39;s morphism.
 514         // The call site count is 0 with known morphism (only 1 or 2 receivers)
 515         // or &lt; 0 in the case of a type check failure for checkcast, aastore, instanceof.
 516         // The call site count is &gt; 0 in the case of a polymorphic virtual call.
 517         if (morphism &gt; 0 &amp;&amp; morphism == result._limit) {
 518            // The morphism &lt;= MorphismLimit.
 519            if ((morphism &lt;  ciCallProfile::MorphismLimit) ||
 520                (morphism == ciCallProfile::MorphismLimit &amp;&amp; count == 0)) {
 521 #ifdef ASSERT
 522              if (count &gt; 0) {
 523                this-&gt;print_short_name(tty);
 524                tty-&gt;print_cr(&quot; @ bci:%d&quot;, bci);
 525                this-&gt;print_codes();
 526                assert(false, &quot;this call site should not be polymorphic&quot;);
 527              }
 528 #endif
 529              result._morphism = morphism;
 530            }
 531         }
 532         // Make the count consistent if this is a call profile. If count is
 533         // zero or less, presume that this is a typecheck profile and
 534         // do nothing.  Otherwise, increase count to be the sum of all
 535         // receiver&#39;s counts.
 536         if (count &gt;= 0) {
<a name="18" id="anc18"></a><span class="line-modified"> 537           count += receivers_count_total;</span>
 538         }
 539       }
 540       result._count = count;
 541     }
 542   }
 543   return result;
 544 }
 545 
 546 // ------------------------------------------------------------------
 547 // Add new receiver and sort data by receiver&#39;s profile count.
 548 void ciCallProfile::add_receiver(ciKlass* receiver, int receiver_count) {
 549   // Add new receiver and sort data by receiver&#39;s counts when we have space
 550   // for it otherwise replace the less called receiver (less called receiver
 551   // is placed to the last array element which is not used).
 552   // First array&#39;s element contains most called receiver.
 553   int i = _limit;
 554   for (; i &gt; 0 &amp;&amp; receiver_count &gt; _receiver_count[i-1]; i--) {
 555     _receiver[i] = _receiver[i-1];
 556     _receiver_count[i] = _receiver_count[i-1];
 557   }
 558   _receiver[i] = receiver;
 559   _receiver_count[i] = receiver_count;
 560   if (_limit &lt; MorphismLimit) _limit++;
 561 }
 562 
 563 
 564 void ciMethod::assert_virtual_call_type_ok(int bci) {
 565   assert(java_code_at_bci(bci) == Bytecodes::_invokevirtual ||
 566          java_code_at_bci(bci) == Bytecodes::_invokeinterface, &quot;unexpected bytecode %s&quot;, Bytecodes::name(java_code_at_bci(bci)));
 567 }
 568 
 569 void ciMethod::assert_call_type_ok(int bci) {
 570   assert(java_code_at_bci(bci) == Bytecodes::_invokestatic ||
 571          java_code_at_bci(bci) == Bytecodes::_invokespecial ||
 572          java_code_at_bci(bci) == Bytecodes::_invokedynamic, &quot;unexpected bytecode %s&quot;, Bytecodes::name(java_code_at_bci(bci)));
 573 }
 574 
 575 /**
 576  * Check whether profiling provides a type for the argument i to the
 577  * call at bci bci
 578  *
 579  * @param [in]bci         bci of the call
 580  * @param [in]i           argument number
 581  * @param [out]type       profiled type of argument, NULL if none
 582  * @param [out]ptr_kind   whether always null, never null or maybe null
 583  * @return                true if profiling exists
 584  *
 585  */
 586 bool ciMethod::argument_profiled_type(int bci, int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind) {
 587   if (MethodData::profile_parameters() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 588     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 589     if (data != NULL) {
 590       if (data-&gt;is_VirtualCallTypeData()) {
 591         assert_virtual_call_type_ok(bci);
 592         ciVirtualCallTypeData* call = (ciVirtualCallTypeData*)data-&gt;as_VirtualCallTypeData();
 593         if (i &gt;= call-&gt;number_of_arguments()) {
 594           return false;
 595         }
 596         type = call-&gt;valid_argument_type(i);
 597         ptr_kind = call-&gt;argument_ptr_kind(i);
 598         return true;
 599       } else if (data-&gt;is_CallTypeData()) {
 600         assert_call_type_ok(bci);
 601         ciCallTypeData* call = (ciCallTypeData*)data-&gt;as_CallTypeData();
 602         if (i &gt;= call-&gt;number_of_arguments()) {
 603           return false;
 604         }
 605         type = call-&gt;valid_argument_type(i);
 606         ptr_kind = call-&gt;argument_ptr_kind(i);
 607         return true;
 608       }
 609     }
 610   }
 611   return false;
 612 }
 613 
 614 /**
 615  * Check whether profiling provides a type for the return value from
 616  * the call at bci bci
 617  *
 618  * @param [in]bci         bci of the call
 619  * @param [out]type       profiled type of argument, NULL if none
 620  * @param [out]ptr_kind   whether always null, never null or maybe null
 621  * @return                true if profiling exists
 622  *
 623  */
 624 bool ciMethod::return_profiled_type(int bci, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind) {
 625   if (MethodData::profile_return() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 626     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 627     if (data != NULL) {
 628       if (data-&gt;is_VirtualCallTypeData()) {
 629         assert_virtual_call_type_ok(bci);
 630         ciVirtualCallTypeData* call = (ciVirtualCallTypeData*)data-&gt;as_VirtualCallTypeData();
 631         if (call-&gt;has_return()) {
 632           type = call-&gt;valid_return_type();
 633           ptr_kind = call-&gt;return_ptr_kind();
 634           return true;
 635         }
 636       } else if (data-&gt;is_CallTypeData()) {
 637         assert_call_type_ok(bci);
 638         ciCallTypeData* call = (ciCallTypeData*)data-&gt;as_CallTypeData();
 639         if (call-&gt;has_return()) {
 640           type = call-&gt;valid_return_type();
 641           ptr_kind = call-&gt;return_ptr_kind();
 642         }
 643         return true;
 644       }
 645     }
 646   }
 647   return false;
 648 }
 649 
 650 /**
 651  * Check whether profiling provides a type for the parameter i
 652  *
 653  * @param [in]i           parameter number
 654  * @param [out]type       profiled type of parameter, NULL if none
 655  * @param [out]ptr_kind   whether always null, never null or maybe null
 656  * @return                true if profiling exists
 657  *
 658  */
 659 bool ciMethod::parameter_profiled_type(int i, ciKlass*&amp; type, ProfilePtrKind&amp; ptr_kind) {
 660   if (MethodData::profile_parameters() &amp;&amp; method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 661     ciParametersTypeData* parameters = method_data()-&gt;parameters_type_data();
 662     if (parameters != NULL &amp;&amp; i &lt; parameters-&gt;number_of_parameters()) {
 663       type = parameters-&gt;valid_parameter_type(i);
 664       ptr_kind = parameters-&gt;parameter_ptr_kind(i);
 665       return true;
 666     }
 667   }
 668   return false;
 669 }
 670 
 671 
 672 // ------------------------------------------------------------------
 673 // ciMethod::find_monomorphic_target
 674 //
 675 // Given a certain calling environment, find the monomorphic target
 676 // for the call.  Return NULL if the call is not monomorphic in
 677 // its calling environment, or if there are only abstract methods.
 678 // The returned method is never abstract.
 679 // Note: If caller uses a non-null result, it must inform dependencies
 680 // via assert_unique_concrete_method or assert_leaf_type.
 681 ciMethod* ciMethod::find_monomorphic_target(ciInstanceKlass* caller,
 682                                             ciInstanceKlass* callee_holder,
 683                                             ciInstanceKlass* actual_recv,
 684                                             bool check_access) {
 685   check_is_loaded();
 686 
 687   if (actual_recv-&gt;is_interface()) {
 688     // %%% We cannot trust interface types, yet.  See bug 6312651.
 689     return NULL;
 690   }
 691 
 692   ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access);
 693   if (root_m == NULL) {
 694     // Something went wrong looking up the actual receiver method.
 695     return NULL;
 696   }
 697   assert(!root_m-&gt;is_abstract(), &quot;resolve_invoke promise&quot;);
 698 
 699   // Make certain quick checks even if UseCHA is false.
 700 
 701   // Is it private or final?
 702   if (root_m-&gt;can_be_statically_bound()) {
 703     return root_m;
 704   }
 705 
 706   if (actual_recv-&gt;is_leaf_type() &amp;&amp; actual_recv == root_m-&gt;holder()) {
 707     // Easy case.  There is no other place to put a method, so don&#39;t bother
 708     // to go through the VM_ENTRY_MARK and all the rest.
 709     return root_m;
 710   }
 711 
 712   // Array methods (clone, hashCode, etc.) are always statically bound.
 713   // If we were to see an array type here, we&#39;d return root_m.
 714   // However, this method processes only ciInstanceKlasses.  (See 4962591.)
 715   // The inline_native_clone intrinsic narrows Object to T[] properly,
 716   // so there is no need to do the same job here.
 717 
 718   if (!UseCHA)  return NULL;
 719 
 720   VM_ENTRY_MARK;
 721 
 722   // Disable CHA for default methods for now
 723   if (root_m-&gt;is_default_method()) {
 724     return NULL;
 725   }
 726 
 727   methodHandle target;
 728   {
 729     MutexLocker locker(Compile_lock);
 730     Klass* context = actual_recv-&gt;get_Klass();
<a name="19" id="anc19"></a><span class="line-modified"> 731     target = Dependencies::find_unique_concrete_method(context,</span>
<span class="line-modified"> 732                                                        root_m-&gt;get_Method());</span>
 733     // %%% Should upgrade this ciMethod API to look for 1 or 2 concrete methods.
 734   }
 735 
 736 #ifndef PRODUCT
 737   if (TraceDependencies &amp;&amp; target() != NULL &amp;&amp; target() != root_m-&gt;get_Method()) {
 738     tty-&gt;print(&quot;found a non-root unique target method&quot;);
 739     tty-&gt;print_cr(&quot;  context = %s&quot;, actual_recv-&gt;get_Klass()-&gt;external_name());
 740     tty-&gt;print(&quot;  method  = &quot;);
 741     target-&gt;print_short_name(tty);
 742     tty-&gt;cr();
 743   }
 744 #endif //PRODUCT
 745 
 746   if (target() == NULL) {
 747     return NULL;
 748   }
 749   if (target() == root_m-&gt;get_Method()) {
 750     return root_m;
 751   }
 752   if (!root_m-&gt;is_public() &amp;&amp;
 753       !root_m-&gt;is_protected()) {
 754     // If we are going to reason about inheritance, it&#39;s easiest
 755     // if the method in question is public, protected, or private.
 756     // If the answer is not root_m, it is conservatively correct
 757     // to return NULL, even if the CHA encountered irrelevant
 758     // methods in other packages.
 759     // %%% TO DO: Work out logic for package-private methods
 760     // with the same name but different vtable indexes.
 761     return NULL;
 762   }
 763   assert(!target()-&gt;is_abstract(), &quot;not allowed&quot;);
 764   return CURRENT_THREAD_ENV-&gt;get_method(target());
 765 }
 766 
<a name="20" id="anc20"></a>







 767 // ------------------------------------------------------------------
 768 // ciMethod::resolve_invoke
 769 //
 770 // Given a known receiver klass, find the target for the call.
 771 // Return NULL if the call has no target or the target is abstract.
 772 ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {
 773    check_is_loaded();
 774    VM_ENTRY_MARK;
 775 
 776    Klass* caller_klass = caller-&gt;get_Klass();
 777    Klass* recv         = exact_receiver-&gt;get_Klass();
 778    Klass* resolved     = holder()-&gt;get_Klass();
 779    Symbol* h_name      = name()-&gt;get_symbol();
 780    Symbol* h_signature = signature()-&gt;get_symbol();
 781 
 782    LinkInfo link_info(resolved, h_name, h_signature, caller_klass,
 783                       check_access ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
<a name="21" id="anc21"></a><span class="line-modified"> 784    methodHandle m;</span>
 785    // Only do exact lookup if receiver klass has been linked.  Otherwise,
 786    // the vtable has not been setup, and the LinkResolver will fail.
 787    if (recv-&gt;is_array_klass()
 788         ||
 789        (InstanceKlass::cast(recv)-&gt;is_linked() &amp;&amp; !exact_receiver-&gt;is_interface())) {
 790      if (holder()-&gt;is_interface()) {
 791        m = LinkResolver::resolve_interface_call_or_null(recv, link_info);
 792      } else {
 793        m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);
 794      }
 795    }
 796 
<a name="22" id="anc22"></a><span class="line-modified"> 797    if (m.is_null()) {</span>
 798      // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 799      return NULL;
 800    }
 801 
 802    ciMethod* result = this;
<a name="23" id="anc23"></a><span class="line-modified"> 803    if (m() != get_Method()) {</span>
<span class="line-modified"> 804      result = CURRENT_THREAD_ENV-&gt;get_method(m());</span>
 805    }
 806 
 807    // Don&#39;t return abstract methods because they aren&#39;t
 808    // optimizable or interesting.
 809    if (result-&gt;is_abstract()) {
 810      return NULL;
 811    } else {
 812      return result;
 813    }
 814 }
 815 
 816 // ------------------------------------------------------------------
 817 // ciMethod::resolve_vtable_index
 818 //
 819 // Given a known receiver klass, find the vtable index for the call.
 820 // Return Method::invalid_vtable_index if the vtable_index is unknown.
 821 int ciMethod::resolve_vtable_index(ciKlass* caller, ciKlass* receiver) {
 822    check_is_loaded();
 823 
 824    int vtable_index = Method::invalid_vtable_index;
 825    // Only do lookup if receiver klass has been linked.  Otherwise,
 826    // the vtable has not been setup, and the LinkResolver will fail.
 827    if (!receiver-&gt;is_interface()
 828        &amp;&amp; (!receiver-&gt;is_instance_klass() ||
 829            receiver-&gt;as_instance_klass()-&gt;is_linked())) {
 830      VM_ENTRY_MARK;
 831 
 832      Klass* caller_klass = caller-&gt;get_Klass();
 833      Klass* recv         = receiver-&gt;get_Klass();
 834      Symbol* h_name = name()-&gt;get_symbol();
 835      Symbol* h_signature = signature()-&gt;get_symbol();
 836 
 837      LinkInfo link_info(recv, h_name, h_signature, caller_klass);
 838      vtable_index = LinkResolver::resolve_virtual_vtable_index(recv, link_info);
 839      if (vtable_index == Method::nonvirtual_vtable_index) {
 840        // A statically bound method.  Return &quot;no such index&quot;.
 841        vtable_index = Method::invalid_vtable_index;
 842      }
 843    }
 844 
 845    return vtable_index;
 846 }
 847 
 848 // ------------------------------------------------------------------
 849 // ciMethod::interpreter_call_site_count
 850 int ciMethod::interpreter_call_site_count(int bci) {
 851   if (method_data() != NULL) {
 852     ResourceMark rm;
 853     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 854     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 855       return scale_count(data-&gt;as_CounterData()-&gt;count());
 856     }
 857   }
 858   return -1;  // unknown
 859 }
 860 
 861 // ------------------------------------------------------------------
 862 // ciMethod::get_field_at_bci
 863 ciField* ciMethod::get_field_at_bci(int bci, bool &amp;will_link) {
 864   ciBytecodeStream iter(this);
 865   iter.reset_to_bci(bci);
 866   iter.next();
 867   return iter.get_field(will_link);
 868 }
 869 
 870 // ------------------------------------------------------------------
 871 // ciMethod::get_method_at_bci
 872 ciMethod* ciMethod::get_method_at_bci(int bci, bool &amp;will_link, ciSignature* *declared_signature) {
 873   ciBytecodeStream iter(this);
 874   iter.reset_to_bci(bci);
 875   iter.next();
 876   return iter.get_method(will_link, declared_signature);
 877 }
 878 
 879 // ------------------------------------------------------------------
 880 ciKlass* ciMethod::get_declared_method_holder_at_bci(int bci) {
 881   ciBytecodeStream iter(this);
 882   iter.reset_to_bci(bci);
 883   iter.next();
 884   return iter.get_declared_method_holder();
 885 }
 886 
 887 // ------------------------------------------------------------------
 888 // Adjust a CounterData count to be commensurate with
 889 // interpreter_invocation_count.  If the MDO exists for
 890 // only 25% of the time the method exists, then the
 891 // counts in the MDO should be scaled by 4X, so that
 892 // they can be usefully and stably compared against the
 893 // invocation counts in methods.
 894 int ciMethod::scale_count(int count, float prof_factor) {
 895   if (count &gt; 0 &amp;&amp; method_data() != NULL) {
 896     int counter_life;
 897     int method_life = interpreter_invocation_count();
 898     if (TieredCompilation) {
 899       // In tiered the MDO&#39;s life is measured directly, so just use the snapshotted counters
 900       counter_life = MAX2(method_data()-&gt;invocation_count(), method_data()-&gt;backedge_count());
 901     } else {
 902       int current_mileage = method_data()-&gt;current_mileage();
 903       int creation_mileage = method_data()-&gt;creation_mileage();
 904       counter_life = current_mileage - creation_mileage;
 905     }
 906 
 907     // counter_life due to backedge_counter could be &gt; method_life
 908     if (counter_life &gt; method_life)
 909       counter_life = method_life;
 910     if (0 &lt; counter_life &amp;&amp; counter_life &lt;= method_life) {
 911       count = (int)((double)count * prof_factor * method_life / counter_life + 0.5);
 912       count = (count &gt; 0) ? count : 1;
 913     }
 914   }
 915   return count;
 916 }
 917 
 918 
 919 // ------------------------------------------------------------------
 920 // ciMethod::is_special_get_caller_class_method
 921 //
 922 bool ciMethod::is_ignored_by_security_stack_walk() const {
 923   check_is_loaded();
 924   VM_ENTRY_MARK;
 925   return get_Method()-&gt;is_ignored_by_security_stack_walk();
 926 }
 927 
<a name="24" id="anc24"></a>






 928 
 929 // ------------------------------------------------------------------
 930 // invokedynamic support
 931 
 932 // ------------------------------------------------------------------
 933 // ciMethod::is_method_handle_intrinsic
 934 //
 935 // Return true if the method is an instance of the JVM-generated
 936 // signature-polymorphic MethodHandle methods, _invokeBasic, _linkToVirtual, etc.
 937 bool ciMethod::is_method_handle_intrinsic() const {
 938   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 939   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 940           MethodHandles::is_signature_polymorphic_intrinsic(iid));
 941 }
 942 
 943 // ------------------------------------------------------------------
 944 // ciMethod::is_compiled_lambda_form
 945 //
 946 // Return true if the method is a generated MethodHandle adapter.
 947 // These are built by Java code.
 948 bool ciMethod::is_compiled_lambda_form() const {
 949   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 950   return iid == vmIntrinsics::_compiledLambdaForm;
 951 }
 952 
 953 // ------------------------------------------------------------------
 954 // ciMethod::is_object_initializer
 955 //
 956 bool ciMethod::is_object_initializer() const {
 957    return name() == ciSymbol::object_initializer_name();
 958 }
 959 
 960 // ------------------------------------------------------------------
 961 // ciMethod::has_member_arg
 962 //
 963 // Return true if the method is a linker intrinsic like _linkToVirtual.
 964 // These are built by the JVM.
 965 bool ciMethod::has_member_arg() const {
 966   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 967   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 968           MethodHandles::has_member_arg(iid));
 969 }
 970 
 971 // ------------------------------------------------------------------
 972 // ciMethod::ensure_method_data
 973 //
 974 // Generate new MethodData* objects at compile time.
 975 // Return true if allocation was successful or no MDO is required.
 976 bool ciMethod::ensure_method_data(const methodHandle&amp; h_m) {
 977   EXCEPTION_CONTEXT;
 978   if (is_native() || is_abstract() || h_m()-&gt;is_accessor()) {
 979     return true;
 980   }
 981   if (h_m()-&gt;method_data() == NULL) {
 982     Method::build_interpreter_method_data(h_m, THREAD);
 983     if (HAS_PENDING_EXCEPTION) {
 984       CLEAR_PENDING_EXCEPTION;
 985     }
 986   }
 987   if (h_m()-&gt;method_data() != NULL) {
 988     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
 989     _method_data-&gt;load_data();
 990     return true;
 991   } else {
 992     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
 993     return false;
 994   }
 995 }
 996 
 997 // public, retroactive version
 998 bool ciMethod::ensure_method_data() {
 999   bool result = true;
1000   if (_method_data == NULL || _method_data-&gt;is_empty()) {
1001     GUARDED_VM_ENTRY({
<a name="25" id="anc25"></a><span class="line-modified">1002       result = ensure_method_data(get_Method());</span>

1003     });
1004   }
1005   return result;
1006 }
1007 
1008 
1009 // ------------------------------------------------------------------
1010 // ciMethod::method_data
1011 //
1012 ciMethodData* ciMethod::method_data() {
1013   if (_method_data != NULL) {
1014     return _method_data;
1015   }
1016   VM_ENTRY_MARK;
1017   ciEnv* env = CURRENT_ENV;
1018   Thread* my_thread = JavaThread::current();
1019   methodHandle h_m(my_thread, get_Method());
1020 
1021   if (h_m()-&gt;method_data() != NULL) {
1022     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
1023     _method_data-&gt;load_data();
1024   } else {
1025     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
1026   }
1027   return _method_data;
1028 
1029 }
1030 
1031 // ------------------------------------------------------------------
1032 // ciMethod::method_data_or_null
1033 // Returns a pointer to ciMethodData if MDO exists on the VM side,
1034 // NULL otherwise.
1035 ciMethodData* ciMethod::method_data_or_null() {
1036   ciMethodData *md = method_data();
1037   if (md-&gt;is_empty()) {
1038     return NULL;
1039   }
1040   return md;
1041 }
1042 
1043 // ------------------------------------------------------------------
1044 // ciMethod::ensure_method_counters
1045 //
1046 MethodCounters* ciMethod::ensure_method_counters() {
1047   check_is_loaded();
1048   VM_ENTRY_MARK;
1049   methodHandle mh(THREAD, get_Method());
1050   MethodCounters* method_counters = mh-&gt;get_method_counters(CHECK_NULL);
1051   return method_counters;
1052 }
1053 
1054 // ------------------------------------------------------------------
1055 // ciMethod::has_option
1056 //
1057 bool ciMethod::has_option(const char* option) {
1058   check_is_loaded();
1059   VM_ENTRY_MARK;
1060   methodHandle mh(THREAD, get_Method());
1061   return CompilerOracle::has_option_string(mh, option);
1062 }
1063 
1064 // ------------------------------------------------------------------
1065 // ciMethod::has_option_value
1066 //
1067 bool ciMethod::has_option_value(const char* option, double&amp; value) {
1068   check_is_loaded();
1069   VM_ENTRY_MARK;
1070   methodHandle mh(THREAD, get_Method());
1071   return CompilerOracle::has_option_value(mh, option, value);
1072 }
1073 // ------------------------------------------------------------------
1074 // ciMethod::can_be_compiled
1075 //
1076 // Have previous compilations of this method succeeded?
1077 bool ciMethod::can_be_compiled() {
1078   check_is_loaded();
1079   ciEnv* env = CURRENT_ENV;
1080   if (is_c1_compile(env-&gt;comp_level())) {
1081     return _is_c1_compilable;
1082   }
1083   return _is_c2_compilable;
1084 }
1085 
1086 // ------------------------------------------------------------------
1087 // ciMethod::set_not_compilable
1088 //
1089 // Tell the VM that this method cannot be compiled at all.
1090 void ciMethod::set_not_compilable(const char* reason) {
1091   check_is_loaded();
1092   VM_ENTRY_MARK;
1093   ciEnv* env = CURRENT_ENV;
1094   if (is_c1_compile(env-&gt;comp_level())) {
1095     _is_c1_compilable = false;
1096   } else {
1097     _is_c2_compilable = false;
1098   }
<a name="26" id="anc26"></a><span class="line-modified">1099   get_Method()-&gt;set_not_compilable(env-&gt;comp_level(), true, reason);</span>
1100 }
1101 
1102 // ------------------------------------------------------------------
1103 // ciMethod::can_be_osr_compiled
1104 //
1105 // Have previous compilations of this method succeeded?
1106 //
1107 // Implementation note: the VM does not currently keep track
1108 // of failed OSR compilations per bci.  The entry_bci parameter
1109 // is currently unused.
1110 bool ciMethod::can_be_osr_compiled(int entry_bci) {
1111   check_is_loaded();
1112   VM_ENTRY_MARK;
1113   ciEnv* env = CURRENT_ENV;
1114   return !get_Method()-&gt;is_not_osr_compilable(env-&gt;comp_level());
1115 }
1116 
1117 // ------------------------------------------------------------------
1118 // ciMethod::has_compiled_code
1119 bool ciMethod::has_compiled_code() {
1120   return instructions_size() &gt; 0;
1121 }
1122 
1123 int ciMethod::comp_level() {
1124   check_is_loaded();
1125   VM_ENTRY_MARK;
1126   CompiledMethod* nm = get_Method()-&gt;code();
1127   if (nm != NULL) return nm-&gt;comp_level();
1128   return 0;
1129 }
1130 
1131 int ciMethod::highest_osr_comp_level() {
1132   check_is_loaded();
1133   VM_ENTRY_MARK;
1134   return get_Method()-&gt;highest_osr_comp_level();
1135 }
1136 
1137 // ------------------------------------------------------------------
1138 // ciMethod::code_size_for_inlining
1139 //
1140 // Code size for inlining decisions.  This method returns a code
1141 // size of 1 for methods which has the ForceInline annotation.
1142 int ciMethod::code_size_for_inlining() {
1143   check_is_loaded();
1144   if (get_Method()-&gt;force_inline()) {
1145     return 1;
1146   }
1147   return code_size();
1148 }
1149 
1150 // ------------------------------------------------------------------
1151 // ciMethod::instructions_size
1152 //
1153 // This is a rough metric for &quot;fat&quot; methods, compared before inlining
1154 // with InlineSmallCode.  The CodeBlob::code_size accessor includes
1155 // junk like exception handler, stubs, and constant table, which are
1156 // not highly relevant to an inlined method.  So we use the more
1157 // specific accessor nmethod::insts_size.
1158 int ciMethod::instructions_size() {
1159   if (_instructions_size == -1) {
1160     GUARDED_VM_ENTRY(
1161                      CompiledMethod* code = get_Method()-&gt;code();
1162                      if (code != NULL &amp;&amp; (code-&gt;comp_level() == CompLevel_full_optimization)) {
1163                        _instructions_size = code-&gt;insts_end() - code-&gt;verified_entry_point();
1164                      } else {
1165                        _instructions_size = 0;
1166                      }
1167                      );
1168   }
1169   return _instructions_size;
1170 }
1171 
1172 // ------------------------------------------------------------------
1173 // ciMethod::log_nmethod_identity
1174 void ciMethod::log_nmethod_identity(xmlStream* log) {
1175   GUARDED_VM_ENTRY(
1176     CompiledMethod* code = get_Method()-&gt;code();
1177     if (code != NULL) {
1178       code-&gt;log_identity(log);
1179     }
1180   )
1181 }
1182 
1183 // ------------------------------------------------------------------
1184 // ciMethod::is_not_reached
1185 bool ciMethod::is_not_reached(int bci) {
1186   check_is_loaded();
1187   VM_ENTRY_MARK;
1188   return Interpreter::is_not_reached(
1189                methodHandle(THREAD, get_Method()), bci);
1190 }
1191 
1192 // ------------------------------------------------------------------
1193 // ciMethod::was_never_executed
1194 bool ciMethod::was_executed_more_than(int times) {
1195   VM_ENTRY_MARK;
1196   return get_Method()-&gt;was_executed_more_than(times);
1197 }
1198 
1199 // ------------------------------------------------------------------
1200 // ciMethod::has_unloaded_classes_in_signature
1201 bool ciMethod::has_unloaded_classes_in_signature() {
1202   VM_ENTRY_MARK;
1203   {
1204     EXCEPTION_MARK;
1205     methodHandle m(THREAD, get_Method());
1206     bool has_unloaded = Method::has_unloaded_classes_in_signature(m, (JavaThread *)THREAD);
1207     if( HAS_PENDING_EXCEPTION ) {
1208       CLEAR_PENDING_EXCEPTION;
1209       return true;     // Declare that we may have unloaded classes
1210     }
1211     return has_unloaded;
1212   }
1213 }
1214 
1215 // ------------------------------------------------------------------
1216 // ciMethod::is_klass_loaded
1217 bool ciMethod::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
1218   VM_ENTRY_MARK;
1219   return get_Method()-&gt;is_klass_loaded(refinfo_index, must_be_resolved);
1220 }
1221 
1222 // ------------------------------------------------------------------
1223 // ciMethod::check_call
1224 bool ciMethod::check_call(int refinfo_index, bool is_static) const {
1225   // This method is used only in C2 from InlineTree::ok_to_inline,
1226   // and is only used under -Xcomp.
1227   // It appears to fail when applied to an invokeinterface call site.
1228   // FIXME: Remove this method and resolve_method_statically; refactor to use the other LinkResolver entry points.
1229   VM_ENTRY_MARK;
1230   {
1231     EXCEPTION_MARK;
1232     HandleMark hm(THREAD);
1233     constantPoolHandle pool (THREAD, get_Method()-&gt;constants());
1234     Bytecodes::Code code = (is_static ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual);
<a name="27" id="anc27"></a><span class="line-modified">1235     methodHandle spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);</span>
1236     if (HAS_PENDING_EXCEPTION) {
1237       CLEAR_PENDING_EXCEPTION;
1238       return false;
1239     } else {
1240       return (spec_method-&gt;is_static() == is_static);
1241     }
1242   }
1243   return false;
1244 }
1245 
1246 // ------------------------------------------------------------------
1247 // ciMethod::profile_aging
1248 //
1249 // Should the method be compiled with an age counter?
1250 bool ciMethod::profile_aging() const {
1251   return UseCodeAging &amp;&amp; (!MethodCounters::is_nmethod_hot(nmethod_age()) &amp;&amp;
1252                           !MethodCounters::is_nmethod_age_unset(nmethod_age()));
1253 }
1254 // ------------------------------------------------------------------
1255 // ciMethod::print_codes
1256 //
1257 // Print the bytecodes for this method.
1258 void ciMethod::print_codes_on(outputStream* st) {
1259   check_is_loaded();
1260   GUARDED_VM_ENTRY(get_Method()-&gt;print_codes_on(st);)
1261 }
1262 
1263 
1264 #define FETCH_FLAG_FROM_VM(flag_accessor) { \
1265   check_is_loaded(); \
1266   VM_ENTRY_MARK; \
1267   return get_Method()-&gt;flag_accessor(); \
1268 }
1269 
1270 bool ciMethod::is_empty_method() const {         FETCH_FLAG_FROM_VM(is_empty_method); }
1271 bool ciMethod::is_vanilla_constructor() const {  FETCH_FLAG_FROM_VM(is_vanilla_constructor); }
1272 bool ciMethod::has_loops      () const {         FETCH_FLAG_FROM_VM(has_loops); }
1273 bool ciMethod::has_jsrs       () const {         FETCH_FLAG_FROM_VM(has_jsrs);  }
1274 bool ciMethod::is_getter      () const {         FETCH_FLAG_FROM_VM(is_getter); }
1275 bool ciMethod::is_setter      () const {         FETCH_FLAG_FROM_VM(is_setter); }
1276 bool ciMethod::is_accessor    () const {         FETCH_FLAG_FROM_VM(is_accessor); }
1277 bool ciMethod::is_initializer () const {         FETCH_FLAG_FROM_VM(is_initializer); }
1278 
1279 bool ciMethod::is_boxing_method() const {
1280   if (holder()-&gt;is_box_klass()) {
1281     switch (intrinsic_id()) {
1282       case vmIntrinsics::_Boolean_valueOf:
1283       case vmIntrinsics::_Byte_valueOf:
1284       case vmIntrinsics::_Character_valueOf:
1285       case vmIntrinsics::_Short_valueOf:
1286       case vmIntrinsics::_Integer_valueOf:
1287       case vmIntrinsics::_Long_valueOf:
1288       case vmIntrinsics::_Float_valueOf:
1289       case vmIntrinsics::_Double_valueOf:
1290         return true;
1291       default:
1292         return false;
1293     }
1294   }
1295   return false;
1296 }
1297 
1298 bool ciMethod::is_unboxing_method() const {
1299   if (holder()-&gt;is_box_klass()) {
1300     switch (intrinsic_id()) {
1301       case vmIntrinsics::_booleanValue:
1302       case vmIntrinsics::_byteValue:
1303       case vmIntrinsics::_charValue:
1304       case vmIntrinsics::_shortValue:
1305       case vmIntrinsics::_intValue:
1306       case vmIntrinsics::_longValue:
1307       case vmIntrinsics::_floatValue:
1308       case vmIntrinsics::_doubleValue:
1309         return true;
1310       default:
1311         return false;
1312     }
1313   }
1314   return false;
1315 }
1316 
1317 BCEscapeAnalyzer  *ciMethod::get_bcea() {
1318 #ifdef COMPILER2
1319   if (_bcea == NULL) {
1320     _bcea = new (CURRENT_ENV-&gt;arena()) BCEscapeAnalyzer(this, NULL);
1321   }
1322   return _bcea;
1323 #else // COMPILER2
1324   ShouldNotReachHere();
1325   return NULL;
1326 #endif // COMPILER2
1327 }
1328 
1329 ciMethodBlocks  *ciMethod::get_method_blocks() {
1330   Arena *arena = CURRENT_ENV-&gt;arena();
1331   if (_method_blocks == NULL) {
1332     _method_blocks = new (arena) ciMethodBlocks(arena, this);
1333   }
1334   return _method_blocks;
1335 }
1336 
1337 #undef FETCH_FLAG_FROM_VM
1338 
1339 void ciMethod::dump_name_as_ascii(outputStream* st) {
1340   Method* method = get_Method();
1341   st-&gt;print(&quot;%s %s %s&quot;,
1342             method-&gt;klass_name()-&gt;as_quoted_ascii(),
1343             method-&gt;name()-&gt;as_quoted_ascii(),
1344             method-&gt;signature()-&gt;as_quoted_ascii());
1345 }
1346 
1347 void ciMethod::dump_replay_data(outputStream* st) {
1348   ResourceMark rm;
1349   Method* method = get_Method();
1350   MethodCounters* mcs = method-&gt;method_counters();
1351   st-&gt;print(&quot;ciMethod &quot;);
1352   dump_name_as_ascii(st);
1353   st-&gt;print_cr(&quot; %d %d %d %d %d&quot;,
1354                mcs == NULL ? 0 : mcs-&gt;invocation_counter()-&gt;raw_counter(),
1355                mcs == NULL ? 0 : mcs-&gt;backedge_counter()-&gt;raw_counter(),
1356                interpreter_invocation_count(),
1357                interpreter_throwout_count(),
1358                _instructions_size);
1359 }
1360 
1361 // ------------------------------------------------------------------
1362 // ciMethod::print_codes
1363 //
1364 // Print a range of the bytecodes for this method.
1365 void ciMethod::print_codes_on(int from, int to, outputStream* st) {
1366   check_is_loaded();
1367   GUARDED_VM_ENTRY(get_Method()-&gt;print_codes_on(from, to, st);)
1368 }
1369 
1370 // ------------------------------------------------------------------
1371 // ciMethod::print_name
1372 //
1373 // Print the name of this method, including signature and some flags.
1374 void ciMethod::print_name(outputStream* st) {
1375   check_is_loaded();
1376   GUARDED_VM_ENTRY(get_Method()-&gt;print_name(st);)
1377 }
1378 
1379 // ------------------------------------------------------------------
1380 // ciMethod::print_short_name
1381 //
1382 // Print the name of this method, without signature.
1383 void ciMethod::print_short_name(outputStream* st) {
1384   if (is_loaded()) {
1385     GUARDED_VM_ENTRY(get_Method()-&gt;print_short_name(st););
1386   } else {
1387     // Fall back if method is not loaded.
1388     holder()-&gt;print_name_on(st);
1389     st-&gt;print(&quot;::&quot;);
1390     name()-&gt;print_symbol_on(st);
1391     if (WizardMode)
1392       signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1393   }
1394 }
1395 
1396 // ------------------------------------------------------------------
1397 // ciMethod::print_impl
1398 //
1399 // Implementation of the print method.
1400 void ciMethod::print_impl(outputStream* st) {
1401   ciMetadata::print_impl(st);
1402   st-&gt;print(&quot; name=&quot;);
1403   name()-&gt;print_symbol_on(st);
1404   st-&gt;print(&quot; holder=&quot;);
1405   holder()-&gt;print_name_on(st);
1406   st-&gt;print(&quot; signature=&quot;);
1407   signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1408   if (is_loaded()) {
1409     st-&gt;print(&quot; loaded=true&quot;);
1410     st-&gt;print(&quot; arg_size=%d&quot;, arg_size());
1411     st-&gt;print(&quot; flags=&quot;);
1412     flags().print_member_flags(st);
1413   } else {
1414     st-&gt;print(&quot; loaded=false&quot;);
1415   }
1416 }
1417 
1418 // ------------------------------------------------------------------
1419 
1420 static BasicType erase_to_word_type(BasicType bt) {
<a name="28" id="anc28"></a><span class="line-modified">1421   if (is_subword_type(bt)) return T_INT;</span>
<span class="line-modified">1422   if (bt == T_ARRAY)       return T_OBJECT;</span>
1423   return bt;
1424 }
1425 
1426 static bool basic_types_match(ciType* t1, ciType* t2) {
1427   if (t1 == t2)  return true;
1428   return erase_to_word_type(t1-&gt;basic_type()) == erase_to_word_type(t2-&gt;basic_type());
1429 }
1430 
1431 bool ciMethod::is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method) {
1432   bool invoke_through_mh_intrinsic = declared_method-&gt;is_method_handle_intrinsic() &amp;&amp;
1433                                   !resolved_method-&gt;is_method_handle_intrinsic();
1434 
1435   if (!invoke_through_mh_intrinsic) {
1436     // Method name &amp; descriptor should stay the same.
1437     // Signatures may reference unloaded types and thus they may be not strictly equal.
1438     ciSymbol* declared_signature = declared_method-&gt;signature()-&gt;as_symbol();
1439     ciSymbol* resolved_signature = resolved_method-&gt;signature()-&gt;as_symbol();
1440 
1441     return (declared_method-&gt;name()-&gt;equals(resolved_method-&gt;name())) &amp;&amp;
1442            (declared_signature-&gt;equals(resolved_signature));
1443   }
1444 
1445   ciMethod* linker = declared_method;
1446   ciMethod* target = resolved_method;
1447   // Linkers have appendix argument which is not passed to callee.
1448   int has_appendix = MethodHandles::has_member_arg(linker-&gt;intrinsic_id()) ? 1 : 0;
1449   if (linker-&gt;arg_size() != (target-&gt;arg_size() + has_appendix)) {
1450     return false; // argument slot count mismatch
1451   }
1452 
1453   ciSignature* linker_sig = linker-&gt;signature();
1454   ciSignature* target_sig = target-&gt;signature();
1455 
1456   if (linker_sig-&gt;count() + (linker-&gt;is_static() ? 0 : 1) !=
1457       target_sig-&gt;count() + (target-&gt;is_static() ? 0 : 1) + has_appendix) {
1458     return false; // argument count mismatch
1459   }
1460 
1461   int sbase = 0, rbase = 0;
1462   switch (linker-&gt;intrinsic_id()) {
1463     case vmIntrinsics::_linkToVirtual:
1464     case vmIntrinsics::_linkToInterface:
1465     case vmIntrinsics::_linkToSpecial: {
1466       if (target-&gt;is_static()) {
1467         return false;
1468       }
1469       if (linker_sig-&gt;type_at(0)-&gt;is_primitive_type()) {
1470         return false;  // receiver should be an oop
1471       }
1472       sbase = 1; // skip receiver
1473       break;
1474     }
1475     case vmIntrinsics::_linkToStatic: {
1476       if (!target-&gt;is_static()) {
1477         return false;
1478       }
1479       break;
1480     }
1481     case vmIntrinsics::_invokeBasic: {
1482       if (target-&gt;is_static()) {
1483         if (target_sig-&gt;type_at(0)-&gt;is_primitive_type()) {
1484           return false; // receiver should be an oop
1485         }
1486         rbase = 1; // skip receiver
1487       }
1488       break;
1489     }
1490     default:
1491       break;
1492   }
1493   assert(target_sig-&gt;count() - rbase == linker_sig-&gt;count() - sbase - has_appendix, &quot;argument count mismatch&quot;);
1494   int arg_count = target_sig-&gt;count() - rbase;
1495   for (int i = 0; i &lt; arg_count; i++) {
1496     if (!basic_types_match(linker_sig-&gt;type_at(sbase + i), target_sig-&gt;type_at(rbase + i))) {
1497       return false;
1498     }
1499   }
1500   // Only check the return type if the symbolic info has non-void return type.
1501   // I.e. the return value of the resolved method can be dropped.
1502   if (!linker-&gt;return_type()-&gt;is_void() &amp;&amp;
1503       !basic_types_match(linker-&gt;return_type(), target-&gt;return_type())) {
1504     return false;
1505   }
1506   return true; // no mismatch found
1507 }
1508 
1509 // ------------------------------------------------------------------
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
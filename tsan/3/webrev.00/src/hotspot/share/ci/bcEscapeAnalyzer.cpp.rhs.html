<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/bcEscapeAnalyzer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciField.hpp&quot;
  29 #include &quot;ci/ciMethodBlocks.hpp&quot;
  30 #include &quot;ci/ciStreams.hpp&quot;
  31 #include &quot;interpreter/bytecode.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 #include &quot;utilities/copy.hpp&quot;
  36 
  37 #ifndef PRODUCT
  38   #define TRACE_BCEA(level, code)                                            \
  39     if (EstimateArgEscape &amp;&amp; BCEATraceLevel &gt;= level) {                        \
  40       code;                                                                  \
  41     }
  42 #else
  43   #define TRACE_BCEA(level, code)
  44 #endif
  45 
  46 // Maintain a map of which arguments a local variable or
  47 // stack slot may contain.  In addition to tracking
  48 // arguments, it tracks two special values, &quot;allocated&quot;
  49 // which represents any object allocated in the current
  50 // method, and &quot;unknown&quot; which is any other object.
  51 // Up to 30 arguments are handled, with the last one
  52 // representing summary information for any extra arguments
  53 class BCEscapeAnalyzer::ArgumentMap {
  54   uint  _bits;
  55   enum {MAXBIT = 29,
  56         ALLOCATED = 1,
  57         UNKNOWN = 2};
  58 
  59   uint int_to_bit(uint e) const {
  60     if (e &gt; MAXBIT)
  61       e = MAXBIT;
  62     return (1 &lt;&lt; (e + 2));
  63   }
  64 
  65 public:
  66   ArgumentMap()                         { _bits = 0;}
  67   void set_bits(uint bits)              { _bits = bits;}
  68   uint get_bits() const                 { return _bits;}
  69   void clear()                          { _bits = 0;}
  70   void set_all()                        { _bits = ~0u; }
  71   bool is_empty() const                 { return _bits == 0; }
  72   bool contains(uint var) const         { return (_bits &amp; int_to_bit(var)) != 0; }
  73   bool is_singleton(uint var) const     { return (_bits == int_to_bit(var)); }
  74   bool contains_unknown() const         { return (_bits &amp; UNKNOWN) != 0; }
  75   bool contains_allocated() const       { return (_bits &amp; ALLOCATED) != 0; }
  76   bool contains_vars() const            { return (_bits &amp; (((1 &lt;&lt; MAXBIT) -1) &lt;&lt; 2)) != 0; }
  77   void set(uint var)                    { _bits = int_to_bit(var); }
  78   void add(uint var)                    { _bits |= int_to_bit(var); }
  79   void add_unknown()                    { _bits = UNKNOWN; }
  80   void add_allocated()                  { _bits = ALLOCATED; }
  81   void set_union(const ArgumentMap &amp;am)     { _bits |= am._bits; }
  82   void set_difference(const ArgumentMap &amp;am) { _bits &amp;=  ~am._bits; }
  83   void operator=(const ArgumentMap &amp;am) { _bits = am._bits; }
  84   bool operator==(const ArgumentMap &amp;am) { return _bits == am._bits; }
  85   bool operator!=(const ArgumentMap &amp;am) { return _bits != am._bits; }
  86 };
  87 
  88 class BCEscapeAnalyzer::StateInfo {
  89 public:
  90   ArgumentMap *_vars;
  91   ArgumentMap *_stack;
  92   int _stack_height;
  93   int _max_stack;
  94   bool _initialized;
  95   ArgumentMap empty_map;
  96 
  97   StateInfo() {
  98     empty_map.clear();
  99   }
 100 
 101   ArgumentMap raw_pop()  { guarantee(_stack_height &gt; 0, &quot;stack underflow&quot;); return _stack[--_stack_height]; }
 102   ArgumentMap  apop()    { return raw_pop(); }
 103   void spop()            { raw_pop(); }
 104   void lpop()            { spop(); spop(); }
 105   void raw_push(ArgumentMap i)   { guarantee(_stack_height &lt; _max_stack, &quot;stack overflow&quot;); _stack[_stack_height++] = i; }
 106   void apush(ArgumentMap i)      { raw_push(i); }
 107   void spush()           { raw_push(empty_map); }
 108   void lpush()           { spush(); spush(); }
 109 
 110 };
 111 
 112 void BCEscapeAnalyzer::set_returned(ArgumentMap vars) {
 113   for (int i = 0; i &lt; _arg_size; i++) {
 114     if (vars.contains(i))
 115       _arg_returned.set(i);
 116   }
 117   _return_local = _return_local &amp;&amp; !(vars.contains_unknown() || vars.contains_allocated());
 118   _return_allocated = _return_allocated &amp;&amp; vars.contains_allocated() &amp;&amp; !(vars.contains_unknown() || vars.contains_vars());
 119 }
 120 
 121 // return true if any element of vars is an argument
 122 bool BCEscapeAnalyzer::is_argument(ArgumentMap vars) {
 123   for (int i = 0; i &lt; _arg_size; i++) {
 124     if (vars.contains(i))
 125       return true;
 126   }
 127   return false;
 128 }
 129 
 130 // return true if any element of vars is an arg_stack argument
 131 bool BCEscapeAnalyzer::is_arg_stack(ArgumentMap vars){
 132   if (_conservative)
 133     return true;
 134   for (int i = 0; i &lt; _arg_size; i++) {
 135     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 136       return true;
 137   }
 138   return false;
 139 }
 140 
 141 // return true if all argument elements of vars are returned
 142 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 143   for (int i = 0; i &lt; _arg_size; i++) {
 144     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 145       return false;
 146     }
 147   }
 148   return true;
 149 }
 150 
 151 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 152   for (int i = 0; i &lt; _arg_size; i++) {
 153     if (vars.contains(i)) {
<a name="2" id="anc2"></a><span class="line-modified"> 154       bm.remove(i);</span>
 155     }
 156   }
 157 }
 158 
 159 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 160   clear_bits(vars, _arg_local);
 161   if (vars.contains_allocated()) {
 162     _allocated_escapes = true;
 163   }
 164 }
 165 
 166 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 167   clear_bits(vars, _arg_local);
 168   clear_bits(vars, _arg_stack);
 169   if (vars.contains_allocated())
 170     _allocated_escapes = true;
 171 
 172   if (merge &amp;&amp; !vars.is_empty()) {
 173     // Merge new state into already processed block.
 174     // New state is not taken into account and
 175     // it may invalidate set_returned() result.
 176     if (vars.contains_unknown() || vars.contains_allocated()) {
 177       _return_local = false;
 178     }
 179     if (vars.contains_unknown() || vars.contains_vars()) {
 180       _return_allocated = false;
 181     }
 182     if (_return_local &amp;&amp; vars.contains_vars() &amp;&amp; !returns_all(vars)) {
 183       // Return result should be invalidated if args in new
 184       // state are not recorded in return state.
 185       _return_local = false;
 186     }
 187   }
 188 }
 189 
 190 void BCEscapeAnalyzer::set_dirty(ArgumentMap vars) {
 191   clear_bits(vars, _dirty);
 192 }
 193 
 194 void BCEscapeAnalyzer::set_modified(ArgumentMap vars, int offs, int size) {
 195 
 196   for (int i = 0; i &lt; _arg_size; i++) {
 197     if (vars.contains(i)) {
 198       set_arg_modified(i, offs, size);
 199     }
 200   }
 201   if (vars.contains_unknown())
 202     _unknown_modified = true;
 203 }
 204 
 205 bool BCEscapeAnalyzer::is_recursive_call(ciMethod* callee) {
 206   for (BCEscapeAnalyzer* scope = this; scope != NULL; scope = scope-&gt;_parent) {
 207     if (scope-&gt;method() == callee) {
 208       return true;
 209     }
 210   }
 211   return false;
 212 }
 213 
 214 bool BCEscapeAnalyzer::is_arg_modified(int arg, int offset, int size_in_bytes) {
 215   if (offset == OFFSET_ANY)
 216     return _arg_modified[arg] != 0;
 217   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 218   bool modified = false;
 219   int l = offset / HeapWordSize;
 220   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 221   if (l &gt; ARG_OFFSET_MAX)
 222     l = ARG_OFFSET_MAX;
 223   if (h &gt; ARG_OFFSET_MAX+1)
 224     h = ARG_OFFSET_MAX + 1;
 225   for (int i = l; i &lt; h; i++) {
 226     modified = modified || (_arg_modified[arg] &amp; (1 &lt;&lt; i)) != 0;
 227   }
 228   return modified;
 229 }
 230 
 231 void BCEscapeAnalyzer::set_arg_modified(int arg, int offset, int size_in_bytes) {
 232   if (offset == OFFSET_ANY) {
 233     _arg_modified[arg] =  (uint) -1;
 234     return;
 235   }
 236   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 237   int l = offset / HeapWordSize;
 238   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 239   if (l &gt; ARG_OFFSET_MAX)
 240     l = ARG_OFFSET_MAX;
 241   if (h &gt; ARG_OFFSET_MAX+1)
 242     h = ARG_OFFSET_MAX + 1;
 243   for (int i = l; i &lt; h; i++) {
 244     _arg_modified[arg] |= (1 &lt;&lt; i);
 245   }
 246 }
 247 
 248 void BCEscapeAnalyzer::invoke(StateInfo &amp;state, Bytecodes::Code code, ciMethod* target, ciKlass* holder) {
 249   int i;
 250 
 251   // retrieve information about the callee
 252   ciInstanceKlass* klass = target-&gt;holder();
 253   ciInstanceKlass* calling_klass = method()-&gt;holder();
 254   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
 255   ciInstanceKlass* actual_recv = callee_holder;
 256 
 257   // Some methods are obviously bindable without any type checks so
 258   // convert them directly to an invokespecial or invokestatic.
 259   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
 260     switch (code) {
 261     case Bytecodes::_invokevirtual:
 262       code = Bytecodes::_invokespecial;
 263       break;
 264     case Bytecodes::_invokehandle:
 265       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
 266       break;
 267     default:
 268       break;
 269     }
 270   }
 271 
 272   // compute size of arguments
 273   int arg_size = target-&gt;invoke_arg_size(code);
 274   int arg_base = MAX2(state._stack_height - arg_size, 0);
 275 
 276   // direct recursive calls are skipped if they can be bound statically without introducing
 277   // dependencies and if parameters are passed at the same position as in the current method
 278   // other calls are skipped if there are no unescaped arguments passed to them
 279   bool directly_recursive = (method() == target) &amp;&amp;
 280                (code != Bytecodes::_invokevirtual || target-&gt;is_final_method() || state._stack[arg_base] .is_empty());
 281 
 282   // check if analysis of callee can safely be skipped
 283   bool skip_callee = true;
 284   for (i = state._stack_height - 1; i &gt;= arg_base &amp;&amp; skip_callee; i--) {
 285     ArgumentMap arg = state._stack[i];
 286     skip_callee = !is_argument(arg) || !is_arg_stack(arg) || (directly_recursive &amp;&amp; arg.is_singleton(i - arg_base));
 287   }
 288   // For now we conservatively skip invokedynamic.
 289   if (code == Bytecodes::_invokedynamic) {
 290     skip_callee = true;
 291   }
 292   if (skip_callee) {
 293     TRACE_BCEA(3, tty-&gt;print_cr(&quot;[EA] skipping method %s::%s&quot;, holder-&gt;name()-&gt;as_utf8(), target-&gt;name()-&gt;as_utf8()));
 294     for (i = 0; i &lt; arg_size; i++) {
 295       set_method_escape(state.raw_pop());
 296     }
 297     _unknown_modified = true;  // assume the worst since we don&#39;t analyze the called method
 298     return;
 299   }
 300 
 301   // determine actual method (use CHA if necessary)
 302   ciMethod* inline_target = NULL;
 303   if (target-&gt;is_loaded() &amp;&amp; klass-&gt;is_loaded()
 304       &amp;&amp; (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
 305       &amp;&amp; target-&gt;is_loaded()) {
 306     if (code == Bytecodes::_invokestatic
 307         || code == Bytecodes::_invokespecial
 308         || (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method())) {
 309       inline_target = target;
 310     } else {
 311       inline_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
 312     }
 313   }
 314 
 315   if (inline_target != NULL &amp;&amp; !is_recursive_call(inline_target)) {
 316     // analyze callee
 317     BCEscapeAnalyzer analyzer(inline_target, this);
 318 
 319     // adjust escape state of actual parameters
 320     bool must_record_dependencies = false;
 321     for (i = arg_size - 1; i &gt;= 0; i--) {
 322       ArgumentMap arg = state.raw_pop();
 323       // Check if callee arg is a caller arg or an allocated object
 324       bool allocated = arg.contains_allocated();
 325       if (!(is_argument(arg) || allocated))
 326         continue;
 327       for (int j = 0; j &lt; _arg_size; j++) {
 328         if (arg.contains(j)) {
 329           _arg_modified[j] |= analyzer._arg_modified[i];
 330         }
 331       }
 332       if (!(is_arg_stack(arg) || allocated)) {
 333         // arguments have already been recognized as escaping
 334       } else if (analyzer.is_arg_stack(i) &amp;&amp; !analyzer.is_arg_returned(i)) {
 335         set_method_escape(arg);
 336         must_record_dependencies = true;
 337       } else {
 338         set_global_escape(arg);
 339       }
 340     }
 341     _unknown_modified = _unknown_modified || analyzer.has_non_arg_side_affects();
 342 
 343     // record dependencies if at least one parameter retained stack-allocatable
 344     if (must_record_dependencies) {
 345       if (code == Bytecodes::_invokeinterface ||
 346           (code == Bytecodes::_invokevirtual &amp;&amp; !target-&gt;is_final_method())) {
 347         _dependencies.append(actual_recv);
 348         _dependencies.append(inline_target);
 349       }
 350       _dependencies.appendAll(analyzer.dependencies());
 351     }
 352   } else {
 353     TRACE_BCEA(1, tty-&gt;print_cr(&quot;[EA] virtual method %s is not monomorphic.&quot;,
 354                                 target-&gt;name()-&gt;as_utf8()));
 355     // conservatively mark all actual parameters as escaping globally
 356     for (i = 0; i &lt; arg_size; i++) {
 357       ArgumentMap arg = state.raw_pop();
 358       if (!is_argument(arg))
 359         continue;
 360       set_modified(arg, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 361       set_global_escape(arg);
 362     }
 363     _unknown_modified = true;  // assume the worst since we don&#39;t know the called method
 364   }
 365 }
 366 
 367 bool BCEscapeAnalyzer::contains(uint arg_set1, uint arg_set2) {
 368   return ((~arg_set1) | arg_set2) == 0;
 369 }
 370 
 371 
 372 void BCEscapeAnalyzer::iterate_one_block(ciBlock *blk, StateInfo &amp;state, GrowableArray&lt;ciBlock *&gt; &amp;successors) {
 373 
 374   blk-&gt;set_processed();
 375   ciBytecodeStream s(method());
 376   int limit_bci = blk-&gt;limit_bci();
 377   bool fall_through = false;
 378   ArgumentMap allocated_obj;
 379   allocated_obj.add_allocated();
 380   ArgumentMap unknown_obj;
 381   unknown_obj.add_unknown();
 382   ArgumentMap empty_map;
 383 
 384   s.reset_to_bci(blk-&gt;start_bci());
 385   while (s.next() != ciBytecodeStream::EOBC() &amp;&amp; s.cur_bci() &lt; limit_bci) {
 386     fall_through = true;
 387     switch (s.cur_bc()) {
 388       case Bytecodes::_nop:
 389         break;
 390       case Bytecodes::_aconst_null:
 391         state.apush(unknown_obj);
 392         break;
 393       case Bytecodes::_iconst_m1:
 394       case Bytecodes::_iconst_0:
 395       case Bytecodes::_iconst_1:
 396       case Bytecodes::_iconst_2:
 397       case Bytecodes::_iconst_3:
 398       case Bytecodes::_iconst_4:
 399       case Bytecodes::_iconst_5:
 400       case Bytecodes::_fconst_0:
 401       case Bytecodes::_fconst_1:
 402       case Bytecodes::_fconst_2:
 403       case Bytecodes::_bipush:
 404       case Bytecodes::_sipush:
 405         state.spush();
 406         break;
 407       case Bytecodes::_lconst_0:
 408       case Bytecodes::_lconst_1:
 409       case Bytecodes::_dconst_0:
 410       case Bytecodes::_dconst_1:
 411         state.lpush();
 412         break;
 413       case Bytecodes::_ldc:
 414       case Bytecodes::_ldc_w:
 415       case Bytecodes::_ldc2_w:
 416       {
 417         // Avoid calling get_constant() which will try to allocate
 418         // unloaded constant. We need only constant&#39;s type.
 419         int index = s.get_constant_pool_index();
 420         constantTag tag = s.get_constant_pool_tag(index);
 421         if (tag.is_long() || tag.is_double()) {
 422           // Only longs and doubles use 2 stack slots.
 423           state.lpush();
 424         } else if (tag.basic_type() == T_OBJECT) {
 425           state.apush(unknown_obj);
 426         } else {
 427           state.spush();
 428         }
 429         break;
 430       }
 431       case Bytecodes::_aload:
 432         state.apush(state._vars[s.get_index()]);
 433         break;
 434       case Bytecodes::_iload:
 435       case Bytecodes::_fload:
 436       case Bytecodes::_iload_0:
 437       case Bytecodes::_iload_1:
 438       case Bytecodes::_iload_2:
 439       case Bytecodes::_iload_3:
 440       case Bytecodes::_fload_0:
 441       case Bytecodes::_fload_1:
 442       case Bytecodes::_fload_2:
 443       case Bytecodes::_fload_3:
 444         state.spush();
 445         break;
 446       case Bytecodes::_lload:
 447       case Bytecodes::_dload:
 448       case Bytecodes::_lload_0:
 449       case Bytecodes::_lload_1:
 450       case Bytecodes::_lload_2:
 451       case Bytecodes::_lload_3:
 452       case Bytecodes::_dload_0:
 453       case Bytecodes::_dload_1:
 454       case Bytecodes::_dload_2:
 455       case Bytecodes::_dload_3:
 456         state.lpush();
 457         break;
 458       case Bytecodes::_aload_0:
 459         state.apush(state._vars[0]);
 460         break;
 461       case Bytecodes::_aload_1:
 462         state.apush(state._vars[1]);
 463         break;
 464       case Bytecodes::_aload_2:
 465         state.apush(state._vars[2]);
 466         break;
 467       case Bytecodes::_aload_3:
 468         state.apush(state._vars[3]);
 469         break;
 470       case Bytecodes::_iaload:
 471       case Bytecodes::_faload:
 472       case Bytecodes::_baload:
 473       case Bytecodes::_caload:
 474       case Bytecodes::_saload:
 475         state.spop();
 476         set_method_escape(state.apop());
 477         state.spush();
 478         break;
 479       case Bytecodes::_laload:
 480       case Bytecodes::_daload:
 481         state.spop();
 482         set_method_escape(state.apop());
 483         state.lpush();
 484         break;
 485       case Bytecodes::_aaload:
 486         { state.spop();
 487           ArgumentMap array = state.apop();
 488           set_method_escape(array);
 489           state.apush(unknown_obj);
 490           set_dirty(array);
 491         }
 492         break;
 493       case Bytecodes::_istore:
 494       case Bytecodes::_fstore:
 495       case Bytecodes::_istore_0:
 496       case Bytecodes::_istore_1:
 497       case Bytecodes::_istore_2:
 498       case Bytecodes::_istore_3:
 499       case Bytecodes::_fstore_0:
 500       case Bytecodes::_fstore_1:
 501       case Bytecodes::_fstore_2:
 502       case Bytecodes::_fstore_3:
 503         state.spop();
 504         break;
 505       case Bytecodes::_lstore:
 506       case Bytecodes::_dstore:
 507       case Bytecodes::_lstore_0:
 508       case Bytecodes::_lstore_1:
 509       case Bytecodes::_lstore_2:
 510       case Bytecodes::_lstore_3:
 511       case Bytecodes::_dstore_0:
 512       case Bytecodes::_dstore_1:
 513       case Bytecodes::_dstore_2:
 514       case Bytecodes::_dstore_3:
 515         state.lpop();
 516         break;
 517       case Bytecodes::_astore:
 518         state._vars[s.get_index()] = state.apop();
 519         break;
 520       case Bytecodes::_astore_0:
 521         state._vars[0] = state.apop();
 522         break;
 523       case Bytecodes::_astore_1:
 524         state._vars[1] = state.apop();
 525         break;
 526       case Bytecodes::_astore_2:
 527         state._vars[2] = state.apop();
 528         break;
 529       case Bytecodes::_astore_3:
 530         state._vars[3] = state.apop();
 531         break;
 532       case Bytecodes::_iastore:
 533       case Bytecodes::_fastore:
 534       case Bytecodes::_bastore:
 535       case Bytecodes::_castore:
 536       case Bytecodes::_sastore:
 537       {
 538         state.spop();
 539         state.spop();
 540         ArgumentMap arr = state.apop();
 541         set_method_escape(arr);
 542         set_modified(arr, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 543         break;
 544       }
 545       case Bytecodes::_lastore:
 546       case Bytecodes::_dastore:
 547       {
 548         state.lpop();
 549         state.spop();
 550         ArgumentMap arr = state.apop();
 551         set_method_escape(arr);
 552         set_modified(arr, OFFSET_ANY, type2size[T_LONG]*HeapWordSize);
 553         break;
 554       }
 555       case Bytecodes::_aastore:
 556       {
 557         set_global_escape(state.apop());
 558         state.spop();
 559         ArgumentMap arr = state.apop();
 560         set_modified(arr, OFFSET_ANY, type2size[T_OBJECT]*HeapWordSize);
 561         break;
 562       }
 563       case Bytecodes::_pop:
 564         state.raw_pop();
 565         break;
 566       case Bytecodes::_pop2:
 567         state.raw_pop();
 568         state.raw_pop();
 569         break;
 570       case Bytecodes::_dup:
 571         { ArgumentMap w1 = state.raw_pop();
 572           state.raw_push(w1);
 573           state.raw_push(w1);
 574         }
 575         break;
 576       case Bytecodes::_dup_x1:
 577         { ArgumentMap w1 = state.raw_pop();
 578           ArgumentMap w2 = state.raw_pop();
 579           state.raw_push(w1);
 580           state.raw_push(w2);
 581           state.raw_push(w1);
 582         }
 583         break;
 584       case Bytecodes::_dup_x2:
 585         { ArgumentMap w1 = state.raw_pop();
 586           ArgumentMap w2 = state.raw_pop();
 587           ArgumentMap w3 = state.raw_pop();
 588           state.raw_push(w1);
 589           state.raw_push(w3);
 590           state.raw_push(w2);
 591           state.raw_push(w1);
 592         }
 593         break;
 594       case Bytecodes::_dup2:
 595         { ArgumentMap w1 = state.raw_pop();
 596           ArgumentMap w2 = state.raw_pop();
 597           state.raw_push(w2);
 598           state.raw_push(w1);
 599           state.raw_push(w2);
 600           state.raw_push(w1);
 601         }
 602         break;
 603       case Bytecodes::_dup2_x1:
 604         { ArgumentMap w1 = state.raw_pop();
 605           ArgumentMap w2 = state.raw_pop();
 606           ArgumentMap w3 = state.raw_pop();
 607           state.raw_push(w2);
 608           state.raw_push(w1);
 609           state.raw_push(w3);
 610           state.raw_push(w2);
 611           state.raw_push(w1);
 612         }
 613         break;
 614       case Bytecodes::_dup2_x2:
 615         { ArgumentMap w1 = state.raw_pop();
 616           ArgumentMap w2 = state.raw_pop();
 617           ArgumentMap w3 = state.raw_pop();
 618           ArgumentMap w4 = state.raw_pop();
 619           state.raw_push(w2);
 620           state.raw_push(w1);
 621           state.raw_push(w4);
 622           state.raw_push(w3);
 623           state.raw_push(w2);
 624           state.raw_push(w1);
 625         }
 626         break;
 627       case Bytecodes::_swap:
 628         { ArgumentMap w1 = state.raw_pop();
 629           ArgumentMap w2 = state.raw_pop();
 630           state.raw_push(w1);
 631           state.raw_push(w2);
 632         }
 633         break;
 634       case Bytecodes::_iadd:
 635       case Bytecodes::_fadd:
 636       case Bytecodes::_isub:
 637       case Bytecodes::_fsub:
 638       case Bytecodes::_imul:
 639       case Bytecodes::_fmul:
 640       case Bytecodes::_idiv:
 641       case Bytecodes::_fdiv:
 642       case Bytecodes::_irem:
 643       case Bytecodes::_frem:
 644       case Bytecodes::_iand:
 645       case Bytecodes::_ior:
 646       case Bytecodes::_ixor:
 647         state.spop();
 648         state.spop();
 649         state.spush();
 650         break;
 651       case Bytecodes::_ladd:
 652       case Bytecodes::_dadd:
 653       case Bytecodes::_lsub:
 654       case Bytecodes::_dsub:
 655       case Bytecodes::_lmul:
 656       case Bytecodes::_dmul:
 657       case Bytecodes::_ldiv:
 658       case Bytecodes::_ddiv:
 659       case Bytecodes::_lrem:
 660       case Bytecodes::_drem:
 661       case Bytecodes::_land:
 662       case Bytecodes::_lor:
 663       case Bytecodes::_lxor:
 664         state.lpop();
 665         state.lpop();
 666         state.lpush();
 667         break;
 668       case Bytecodes::_ishl:
 669       case Bytecodes::_ishr:
 670       case Bytecodes::_iushr:
 671         state.spop();
 672         state.spop();
 673         state.spush();
 674         break;
 675       case Bytecodes::_lshl:
 676       case Bytecodes::_lshr:
 677       case Bytecodes::_lushr:
 678         state.spop();
 679         state.lpop();
 680         state.lpush();
 681         break;
 682       case Bytecodes::_ineg:
 683       case Bytecodes::_fneg:
 684         state.spop();
 685         state.spush();
 686         break;
 687       case Bytecodes::_lneg:
 688       case Bytecodes::_dneg:
 689         state.lpop();
 690         state.lpush();
 691         break;
 692       case Bytecodes::_iinc:
 693         break;
 694       case Bytecodes::_i2l:
 695       case Bytecodes::_i2d:
 696       case Bytecodes::_f2l:
 697       case Bytecodes::_f2d:
 698         state.spop();
 699         state.lpush();
 700         break;
 701       case Bytecodes::_i2f:
 702       case Bytecodes::_f2i:
 703         state.spop();
 704         state.spush();
 705         break;
 706       case Bytecodes::_l2i:
 707       case Bytecodes::_l2f:
 708       case Bytecodes::_d2i:
 709       case Bytecodes::_d2f:
 710         state.lpop();
 711         state.spush();
 712         break;
 713       case Bytecodes::_l2d:
 714       case Bytecodes::_d2l:
 715         state.lpop();
 716         state.lpush();
 717         break;
 718       case Bytecodes::_i2b:
 719       case Bytecodes::_i2c:
 720       case Bytecodes::_i2s:
 721         state.spop();
 722         state.spush();
 723         break;
 724       case Bytecodes::_lcmp:
 725       case Bytecodes::_dcmpl:
 726       case Bytecodes::_dcmpg:
 727         state.lpop();
 728         state.lpop();
 729         state.spush();
 730         break;
 731       case Bytecodes::_fcmpl:
 732       case Bytecodes::_fcmpg:
 733         state.spop();
 734         state.spop();
 735         state.spush();
 736         break;
 737       case Bytecodes::_ifeq:
 738       case Bytecodes::_ifne:
 739       case Bytecodes::_iflt:
 740       case Bytecodes::_ifge:
 741       case Bytecodes::_ifgt:
 742       case Bytecodes::_ifle:
 743       {
 744         state.spop();
 745         int dest_bci = s.get_dest();
 746         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 747         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 748         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 749         break;
 750       }
 751       case Bytecodes::_if_icmpeq:
 752       case Bytecodes::_if_icmpne:
 753       case Bytecodes::_if_icmplt:
 754       case Bytecodes::_if_icmpge:
 755       case Bytecodes::_if_icmpgt:
 756       case Bytecodes::_if_icmple:
 757       {
 758         state.spop();
 759         state.spop();
 760         int dest_bci = s.get_dest();
 761         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 762         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 763         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 764         break;
 765       }
 766       case Bytecodes::_if_acmpeq:
 767       case Bytecodes::_if_acmpne:
 768       {
 769         set_method_escape(state.apop());
 770         set_method_escape(state.apop());
 771         int dest_bci = s.get_dest();
 772         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 773         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 774         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 775         break;
 776       }
 777       case Bytecodes::_goto:
 778       {
 779         int dest_bci = s.get_dest();
 780         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 781         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 782         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 783         fall_through = false;
 784         break;
 785       }
 786       case Bytecodes::_jsr:
 787       {
 788         int dest_bci = s.get_dest();
 789         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 790         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 791         state.apush(empty_map);
 792         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 793         fall_through = false;
 794         break;
 795       }
 796       case Bytecodes::_ret:
 797         // we don&#39;t track  the destination of a &quot;ret&quot; instruction
 798         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 799         fall_through = false;
 800         break;
 801       case Bytecodes::_return:
 802         assert(s.next_bci() == limit_bci, &quot;return must end block&quot;);
 803         fall_through = false;
 804         break;
 805       case Bytecodes::_tableswitch:
 806         {
 807           state.spop();
 808           Bytecode_tableswitch sw(&amp;s);
 809           int len = sw.length();
 810           int dest_bci;
 811           for (int i = 0; i &lt; len; i++) {
 812             dest_bci = s.cur_bci() + sw.dest_offset_at(i);
 813             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 814             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 815           }
 816           dest_bci = s.cur_bci() + sw.default_offset();
 817           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 818           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 819           assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 820           fall_through = false;
 821           break;
 822         }
 823       case Bytecodes::_lookupswitch:
 824         {
 825           state.spop();
 826           Bytecode_lookupswitch sw(&amp;s);
 827           int len = sw.number_of_pairs();
 828           int dest_bci;
 829           for (int i = 0; i &lt; len; i++) {
 830             dest_bci = s.cur_bci() + sw.pair_at(i).offset();
 831             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 832             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 833           }
 834           dest_bci = s.cur_bci() + sw.default_offset();
 835           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 836           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 837           fall_through = false;
 838           break;
 839         }
 840       case Bytecodes::_ireturn:
 841       case Bytecodes::_freturn:
 842         state.spop();
 843         fall_through = false;
 844         break;
 845       case Bytecodes::_lreturn:
 846       case Bytecodes::_dreturn:
 847         state.lpop();
 848         fall_through = false;
 849         break;
 850       case Bytecodes::_areturn:
 851         set_returned(state.apop());
 852         fall_through = false;
 853         break;
 854       case Bytecodes::_getstatic:
 855       case Bytecodes::_getfield:
 856         { bool ignored_will_link;
 857           ciField* field = s.get_field(ignored_will_link);
 858           BasicType field_type = field-&gt;type()-&gt;basic_type();
 859           if (s.cur_bc() != Bytecodes::_getstatic) {
 860             set_method_escape(state.apop());
 861           }
<a name="3" id="anc3"></a><span class="line-modified"> 862           if (is_reference_type(field_type)) {</span>
 863             state.apush(unknown_obj);
 864           } else if (type2size[field_type] == 1) {
 865             state.spush();
 866           } else {
 867             state.lpush();
 868           }
 869         }
 870         break;
 871       case Bytecodes::_putstatic:
 872       case Bytecodes::_putfield:
 873         { bool will_link;
 874           ciField* field = s.get_field(will_link);
 875           BasicType field_type = field-&gt;type()-&gt;basic_type();
<a name="4" id="anc4"></a><span class="line-modified"> 876           if (is_reference_type(field_type)) {</span>
 877             set_global_escape(state.apop());
 878           } else if (type2size[field_type] == 1) {
 879             state.spop();
 880           } else {
 881             state.lpop();
 882           }
 883           if (s.cur_bc() != Bytecodes::_putstatic) {
 884             ArgumentMap p = state.apop();
 885             set_method_escape(p);
 886             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 887           }
 888         }
 889         break;
 890       case Bytecodes::_invokevirtual:
 891       case Bytecodes::_invokespecial:
 892       case Bytecodes::_invokestatic:
 893       case Bytecodes::_invokedynamic:
 894       case Bytecodes::_invokeinterface:
 895         { bool ignored_will_link;
 896           ciSignature* declared_signature = NULL;
 897           ciMethod* target = s.get_method(ignored_will_link, &amp;declared_signature);
 898           ciKlass*  holder = s.get_declared_method_holder();
 899           assert(declared_signature != NULL, &quot;cannot be null&quot;);
 900           // If the current bytecode has an attached appendix argument,
 901           // push an unknown object to represent that argument. (Analysis
 902           // of dynamic call sites, especially invokehandle calls, needs
 903           // the appendix argument on the stack, in addition to &quot;regular&quot; arguments
 904           // pushed onto the stack by bytecode instructions preceding the call.)
 905           //
 906           // The escape analyzer does _not_ use the ciBytecodeStream::has_appendix(s)
 907           // method to determine whether the current bytecode has an appendix argument.
 908           // The has_appendix() method obtains the appendix from the
 909           // ConstantPoolCacheEntry::_f1 field, which can happen concurrently with
 910           // resolution of dynamic call sites. Callees in the
 911           // ciBytecodeStream::get_method() call above also access the _f1 field;
 912           // interleaving the get_method() and has_appendix() calls in the current
 913           // method with call site resolution can lead to an inconsistent view of
 914           // the current method&#39;s argument count. In particular, some interleaving(s)
 915           // can cause the method&#39;s argument count to not include the appendix, which
 916           // then leads to stack over-/underflow in the escape analyzer.
 917           //
 918           // Instead of pushing the argument if has_appendix() is true, the escape analyzer
 919           // pushes an appendix for all call sites targeted by invokedynamic and invokehandle
 920           // instructions, except if the call site is the _invokeBasic intrinsic
 921           // (that intrinsic is always targeted by an invokehandle instruction but does
 922           // not have an appendix argument).
 923           if (target-&gt;is_loaded() &amp;&amp;
 924               Bytecodes::has_optional_appendix(s.cur_bc_raw()) &amp;&amp;
 925               target-&gt;intrinsic_id() != vmIntrinsics::_invokeBasic) {
 926             state.apush(unknown_obj);
 927           }
 928           // Pass in raw bytecode because we need to see invokehandle instructions.
 929           invoke(state, s.cur_bc_raw(), target, holder);
 930           // We are using the return type of the declared signature here because
 931           // it might be a more concrete type than the one from the target (for
 932           // e.g. invokedynamic and invokehandle).
 933           ciType* return_type = declared_signature-&gt;return_type();
 934           if (!return_type-&gt;is_primitive_type()) {
 935             state.apush(unknown_obj);
 936           } else if (return_type-&gt;is_one_word()) {
 937             state.spush();
 938           } else if (return_type-&gt;is_two_word()) {
 939             state.lpush();
 940           }
 941         }
 942         break;
 943       case Bytecodes::_new:
 944         state.apush(allocated_obj);
 945         break;
 946       case Bytecodes::_newarray:
 947       case Bytecodes::_anewarray:
 948         state.spop();
 949         state.apush(allocated_obj);
 950         break;
 951       case Bytecodes::_multianewarray:
 952         { int i = s.cur_bcp()[3];
 953           while (i-- &gt; 0) state.spop();
 954           state.apush(allocated_obj);
 955         }
 956         break;
 957       case Bytecodes::_arraylength:
 958         set_method_escape(state.apop());
 959         state.spush();
 960         break;
 961       case Bytecodes::_athrow:
 962         set_global_escape(state.apop());
 963         fall_through = false;
 964         break;
 965       case Bytecodes::_checkcast:
 966         { ArgumentMap obj = state.apop();
 967           set_method_escape(obj);
 968           state.apush(obj);
 969         }
 970         break;
 971       case Bytecodes::_instanceof:
 972         set_method_escape(state.apop());
 973         state.spush();
 974         break;
 975       case Bytecodes::_monitorenter:
 976       case Bytecodes::_monitorexit:
 977         state.apop();
 978         break;
 979       case Bytecodes::_wide:
 980         ShouldNotReachHere();
 981         break;
 982       case Bytecodes::_ifnull:
 983       case Bytecodes::_ifnonnull:
 984       {
 985         set_method_escape(state.apop());
 986         int dest_bci = s.get_dest();
 987         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 988         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 989         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 990         break;
 991       }
 992       case Bytecodes::_goto_w:
 993       {
 994         int dest_bci = s.get_far_dest();
 995         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 996         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 997         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 998         fall_through = false;
 999         break;
1000       }
1001       case Bytecodes::_jsr_w:
1002       {
1003         int dest_bci = s.get_far_dest();
1004         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1005         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1006         state.apush(empty_map);
1007         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1008         fall_through = false;
1009         break;
1010       }
1011       case Bytecodes::_breakpoint:
1012         break;
1013       default:
1014         ShouldNotReachHere();
1015         break;
1016     }
1017 
1018   }
1019   if (fall_through) {
1020     int fall_through_bci = s.cur_bci();
1021     if (fall_through_bci &lt; _method-&gt;code_size()) {
1022       assert(_methodBlocks-&gt;is_block_start(fall_through_bci), &quot;must fall through to block start.&quot;);
1023       successors.push(_methodBlocks-&gt;block_containing(fall_through_bci));
1024     }
1025   }
1026 }
1027 
1028 void BCEscapeAnalyzer::merge_block_states(StateInfo *blockstates, ciBlock *dest, StateInfo *s_state) {
1029   StateInfo *d_state = blockstates + dest-&gt;index();
1030   int nlocals = _method-&gt;max_locals();
1031 
1032   // exceptions may cause transfer of control to handlers in the middle of a
1033   // block, so we don&#39;t merge the incoming state of exception handlers
1034   if (dest-&gt;is_handler())
1035     return;
1036   if (!d_state-&gt;_initialized ) {
1037     // destination not initialized, just copy
1038     for (int i = 0; i &lt; nlocals; i++) {
1039       d_state-&gt;_vars[i] = s_state-&gt;_vars[i];
1040     }
1041     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1042       d_state-&gt;_stack[i] = s_state-&gt;_stack[i];
1043     }
1044     d_state-&gt;_stack_height = s_state-&gt;_stack_height;
1045     d_state-&gt;_max_stack = s_state-&gt;_max_stack;
1046     d_state-&gt;_initialized = true;
1047   } else if (!dest-&gt;processed()) {
1048     // we have not yet walked the bytecodes of dest, we can merge
1049     // the states
1050     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1051     for (int i = 0; i &lt; nlocals; i++) {
1052       d_state-&gt;_vars[i].set_union(s_state-&gt;_vars[i]);
1053     }
1054     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1055       d_state-&gt;_stack[i].set_union(s_state-&gt;_stack[i]);
1056     }
1057   } else {
1058     // the bytecodes of dest have already been processed, mark any
1059     // arguments in the source state which are not in the dest state
1060     // as global escape.
1061     // Future refinement:  we only need to mark these variable to the
1062     // maximum escape of any variables in dest state
1063     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1064     ArgumentMap extra_vars;
1065     for (int i = 0; i &lt; nlocals; i++) {
1066       ArgumentMap t;
1067       t = s_state-&gt;_vars[i];
1068       t.set_difference(d_state-&gt;_vars[i]);
1069       extra_vars.set_union(t);
1070     }
1071     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1072       ArgumentMap t;
1073       //extra_vars |= !d_state-&gt;_vars[i] &amp; s_state-&gt;_vars[i];
1074       t.clear();
1075       t = s_state-&gt;_stack[i];
1076       t.set_difference(d_state-&gt;_stack[i]);
1077       extra_vars.set_union(t);
1078     }
1079     set_global_escape(extra_vars, true);
1080   }
1081 }
1082 
1083 void BCEscapeAnalyzer::iterate_blocks(Arena *arena) {
1084   int numblocks = _methodBlocks-&gt;num_blocks();
1085   int stkSize   = _method-&gt;max_stack();
1086   int numLocals = _method-&gt;max_locals();
1087   StateInfo state;
1088 
1089   int datacount = (numblocks + 1) * (stkSize + numLocals);
1090   int datasize = datacount * sizeof(ArgumentMap);
1091   StateInfo *blockstates = (StateInfo *) arena-&gt;Amalloc(numblocks * sizeof(StateInfo));
1092   ArgumentMap *statedata  = (ArgumentMap *) arena-&gt;Amalloc(datasize);
1093   for (int i = 0; i &lt; datacount; i++) ::new ((void*)&amp;statedata[i]) ArgumentMap();
1094   ArgumentMap *dp = statedata;
1095   state._vars = dp;
1096   dp += numLocals;
1097   state._stack = dp;
1098   dp += stkSize;
1099   state._initialized = false;
1100   state._max_stack = stkSize;
1101   for (int i = 0; i &lt; numblocks; i++) {
1102     blockstates[i]._vars = dp;
1103     dp += numLocals;
1104     blockstates[i]._stack = dp;
1105     dp += stkSize;
1106     blockstates[i]._initialized = false;
1107     blockstates[i]._stack_height = 0;
1108     blockstates[i]._max_stack  = stkSize;
1109   }
1110   GrowableArray&lt;ciBlock *&gt; worklist(arena, numblocks / 4, 0, NULL);
1111   GrowableArray&lt;ciBlock *&gt; successors(arena, 4, 0, NULL);
1112 
1113   _methodBlocks-&gt;clear_processed();
1114 
1115   // initialize block 0 state from method signature
1116   ArgumentMap allVars;   // all oop arguments to method
1117   ciSignature* sig = method()-&gt;signature();
1118   int j = 0;
1119   ciBlock* first_blk = _methodBlocks-&gt;block_containing(0);
1120   int fb_i = first_blk-&gt;index();
1121   if (!method()-&gt;is_static()) {
1122     // record information for &quot;this&quot;
1123     blockstates[fb_i]._vars[j].set(j);
1124     allVars.add(j);
1125     j++;
1126   }
1127   for (int i = 0; i &lt; sig-&gt;count(); i++) {
1128     ciType* t = sig-&gt;type_at(i);
1129     if (!t-&gt;is_primitive_type()) {
1130       blockstates[fb_i]._vars[j].set(j);
1131       allVars.add(j);
1132     }
1133     j += t-&gt;size();
1134   }
1135   blockstates[fb_i]._initialized = true;
1136   assert(j == _arg_size, &quot;just checking&quot;);
1137 
1138   ArgumentMap unknown_map;
1139   unknown_map.add_unknown();
1140 
1141   worklist.push(first_blk);
1142   while(worklist.length() &gt; 0) {
1143     ciBlock *blk = worklist.pop();
1144     StateInfo *blkState = blockstates + blk-&gt;index();
1145     if (blk-&gt;is_handler() || blk-&gt;is_ret_target()) {
1146       // for an exception handler or a target of a ret instruction, we assume the worst case,
1147       // that any variable could contain any argument
1148       for (int i = 0; i &lt; numLocals; i++) {
1149         state._vars[i] = allVars;
1150       }
1151       if (blk-&gt;is_handler()) {
1152         state._stack_height = 1;
1153       } else {
1154         state._stack_height = blkState-&gt;_stack_height;
1155       }
1156       for (int i = 0; i &lt; state._stack_height; i++) {
1157 // ??? should this be unknown_map ???
1158         state._stack[i] = allVars;
1159       }
1160     } else {
1161       for (int i = 0; i &lt; numLocals; i++) {
1162         state._vars[i] = blkState-&gt;_vars[i];
1163       }
1164       for (int i = 0; i &lt; blkState-&gt;_stack_height; i++) {
1165         state._stack[i] = blkState-&gt;_stack[i];
1166       }
1167       state._stack_height = blkState-&gt;_stack_height;
1168     }
1169     iterate_one_block(blk, state, successors);
1170     // if this block has any exception handlers, push them
1171     // onto successor list
1172     if (blk-&gt;has_handler()) {
1173       DEBUG_ONLY(int handler_count = 0;)
1174       int blk_start = blk-&gt;start_bci();
1175       int blk_end = blk-&gt;limit_bci();
1176       for (int i = 0; i &lt; numblocks; i++) {
1177         ciBlock *b = _methodBlocks-&gt;block(i);
1178         if (b-&gt;is_handler()) {
1179           int ex_start = b-&gt;ex_start_bci();
1180           int ex_end = b-&gt;ex_limit_bci();
1181           if ((ex_start &gt;= blk_start &amp;&amp; ex_start &lt; blk_end) ||
1182               (ex_end &gt; blk_start &amp;&amp; ex_end &lt;= blk_end)) {
1183             successors.push(b);
1184           }
1185           DEBUG_ONLY(handler_count++;)
1186         }
1187       }
1188       assert(handler_count &gt; 0, &quot;must find at least one handler&quot;);
1189     }
1190     // merge computed variable state with successors
1191     while(successors.length() &gt; 0) {
1192       ciBlock *succ = successors.pop();
1193       merge_block_states(blockstates, succ, &amp;state);
1194       if (!succ-&gt;processed())
1195         worklist.push(succ);
1196     }
1197   }
1198 }
1199 
1200 void BCEscapeAnalyzer::do_analysis() {
1201   Arena* arena = CURRENT_ENV-&gt;arena();
1202   // identify basic blocks
1203   _methodBlocks = _method-&gt;get_method_blocks();
1204 
1205   iterate_blocks(arena);
1206 }
1207 
1208 vmIntrinsics::ID BCEscapeAnalyzer::known_intrinsic() {
1209   vmIntrinsics::ID iid = method()-&gt;intrinsic_id();
1210   if (iid == vmIntrinsics::_getClass ||
1211       iid == vmIntrinsics::_hashCode) {
1212     return iid;
1213   } else {
1214     return vmIntrinsics::_none;
1215   }
1216 }
1217 
1218 void BCEscapeAnalyzer::compute_escape_for_intrinsic(vmIntrinsics::ID iid) {
1219   switch (iid) {
1220     case vmIntrinsics::_getClass:
1221       _return_local = false;
1222       _return_allocated = false;
1223       break;
1224     case vmIntrinsics::_hashCode:
1225       // initialized state is correct
1226       break;
1227   default:
1228     assert(false, &quot;unexpected intrinsic&quot;);
1229   }
1230 }
1231 
1232 void BCEscapeAnalyzer::initialize() {
1233   int i;
1234 
1235   // clear escape information (method may have been deoptimized)
1236   methodData()-&gt;clear_escape_info();
1237 
1238   // initialize escape state of object parameters
1239   ciSignature* sig = method()-&gt;signature();
1240   int j = 0;
1241   if (!method()-&gt;is_static()) {
1242     _arg_local.set(0);
1243     _arg_stack.set(0);
1244     j++;
1245   }
1246   for (i = 0; i &lt; sig-&gt;count(); i++) {
1247     ciType* t = sig-&gt;type_at(i);
1248     if (!t-&gt;is_primitive_type()) {
1249       _arg_local.set(j);
1250       _arg_stack.set(j);
1251     }
1252     j += t-&gt;size();
1253   }
1254   assert(j == _arg_size, &quot;just checking&quot;);
1255 
1256   // start with optimistic assumption
1257   ciType *rt = _method-&gt;return_type();
1258   if (rt-&gt;is_primitive_type()) {
1259     _return_local = false;
1260     _return_allocated = false;
1261   } else {
1262     _return_local = true;
1263     _return_allocated = true;
1264   }
1265   _allocated_escapes = false;
1266   _unknown_modified = false;
1267 }
1268 
1269 void BCEscapeAnalyzer::clear_escape_info() {
1270   ciSignature* sig = method()-&gt;signature();
1271   int arg_count = sig-&gt;count();
1272   ArgumentMap var;
1273   if (!method()-&gt;is_static()) {
1274     arg_count++;  // allow for &quot;this&quot;
1275   }
1276   for (int i = 0; i &lt; arg_count; i++) {
1277     set_arg_modified(i, OFFSET_ANY, 4);
1278     var.clear();
1279     var.set(i);
1280     set_modified(var, OFFSET_ANY, 4);
1281     set_global_escape(var);
1282   }
<a name="5" id="anc5"></a><span class="line-modified">1283   _arg_local.clear();</span>
<span class="line-modified">1284   _arg_stack.clear();</span>
<span class="line-modified">1285   _arg_returned.clear();</span>
1286   _return_local = false;
1287   _return_allocated = false;
1288   _allocated_escapes = true;
1289   _unknown_modified = true;
1290 }
1291 
1292 
1293 void BCEscapeAnalyzer::compute_escape_info() {
1294   int i;
1295   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1296 
1297   vmIntrinsics::ID iid = known_intrinsic();
1298 
1299   // check if method can be analyzed
1300   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1301       || _level &gt; MaxBCEAEstimateLevel
1302       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1303     if (BCEATraceLevel &gt;= 1) {
1304       tty-&gt;print(&quot;Skipping method because: &quot;);
1305       if (method()-&gt;is_abstract())
1306         tty-&gt;print_cr(&quot;method is abstract.&quot;);
1307       else if (method()-&gt;is_native())
1308         tty-&gt;print_cr(&quot;method is native.&quot;);
1309       else if (!method()-&gt;holder()-&gt;is_initialized())
1310         tty-&gt;print_cr(&quot;class of method is not initialized.&quot;);
1311       else if (_level &gt; MaxBCEAEstimateLevel)
1312         tty-&gt;print_cr(&quot;level (%d) exceeds MaxBCEAEstimateLevel (%d).&quot;,
1313                       _level, (int) MaxBCEAEstimateLevel);
1314       else if (method()-&gt;code_size() &gt; MaxBCEAEstimateSize)
1315         tty-&gt;print_cr(&quot;code size (%d) exceeds MaxBCEAEstimateSize (%d).&quot;,
1316                       method()-&gt;code_size(), (int) MaxBCEAEstimateSize);
1317       else
1318         ShouldNotReachHere();
1319     }
1320     clear_escape_info();
1321 
1322     return;
1323   }
1324 
1325   if (BCEATraceLevel &gt;= 1) {
1326     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1327     if (iid != vmIntrinsics::_none)
1328       tty-&gt;print(&quot; intrinsic&quot;);
1329     method()-&gt;print_short_name();
1330     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1331   }
1332 
1333   initialize();
1334 
1335   // Do not scan method if it has no object parameters and
1336   // does not returns an object (_return_allocated is set in initialize()).
<a name="6" id="anc6"></a><span class="line-modified">1337   if (_arg_local.is_empty() &amp;&amp; !_return_allocated) {</span>
1338     // Clear all info since method&#39;s bytecode was not analysed and
1339     // set pessimistic escape information.
1340     clear_escape_info();
1341     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1342     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1343     methodData()-&gt;set_eflag(MethodData::estimated);
1344     return;
1345   }
1346 
1347   if (iid != vmIntrinsics::_none)
1348     compute_escape_for_intrinsic(iid);
1349   else {
1350     do_analysis();
1351   }
1352 
1353   // don&#39;t store interprocedural escape information if it introduces
1354   // dependencies or if method data is empty
1355   //
1356   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1357     for (i = 0; i &lt; _arg_size; i++) {
1358       if (_arg_local.test(i)) {
1359         assert(_arg_stack.test(i), &quot;inconsistent escape info&quot;);
1360         methodData()-&gt;set_arg_local(i);
1361         methodData()-&gt;set_arg_stack(i);
1362       } else if (_arg_stack.test(i)) {
1363         methodData()-&gt;set_arg_stack(i);
1364       }
1365       if (_arg_returned.test(i)) {
1366         methodData()-&gt;set_arg_returned(i);
1367       }
1368       methodData()-&gt;set_arg_modified(i, _arg_modified[i]);
1369     }
1370     if (_return_local) {
1371       methodData()-&gt;set_eflag(MethodData::return_local);
1372     }
1373     if (_return_allocated) {
1374       methodData()-&gt;set_eflag(MethodData::return_allocated);
1375     }
1376     if (_allocated_escapes) {
1377       methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1378     }
1379     if (_unknown_modified) {
1380       methodData()-&gt;set_eflag(MethodData::unknown_modified);
1381     }
1382     methodData()-&gt;set_eflag(MethodData::estimated);
1383   }
1384 }
1385 
1386 void BCEscapeAnalyzer::read_escape_info() {
1387   assert(methodData()-&gt;has_escape_info(), &quot;no escape info available&quot;);
1388 
1389   // read escape information from method descriptor
1390   for (int i = 0; i &lt; _arg_size; i++) {
1391     if (methodData()-&gt;is_arg_local(i))
1392       _arg_local.set(i);
1393     if (methodData()-&gt;is_arg_stack(i))
1394       _arg_stack.set(i);
1395     if (methodData()-&gt;is_arg_returned(i))
1396       _arg_returned.set(i);
1397     _arg_modified[i] = methodData()-&gt;arg_modified(i);
1398   }
1399   _return_local = methodData()-&gt;eflag_set(MethodData::return_local);
1400   _return_allocated = methodData()-&gt;eflag_set(MethodData::return_allocated);
1401   _allocated_escapes = methodData()-&gt;eflag_set(MethodData::allocated_escapes);
1402   _unknown_modified = methodData()-&gt;eflag_set(MethodData::unknown_modified);
1403 
1404 }
1405 
1406 #ifndef PRODUCT
1407 void BCEscapeAnalyzer::dump() {
1408   tty-&gt;print(&quot;[EA] estimated escape information for&quot;);
1409   method()-&gt;print_short_name();
1410   tty-&gt;print_cr(has_dependencies() ? &quot; (not stored)&quot; : &quot;&quot;);
1411   tty-&gt;print(&quot;     non-escaping args:      &quot;);
1412   _arg_local.print();
1413   tty-&gt;print(&quot;     stack-allocatable args: &quot;);
1414   _arg_stack.print();
1415   if (_return_local) {
1416     tty-&gt;print(&quot;     returned args:          &quot;);
1417     _arg_returned.print();
1418   } else if (is_return_allocated()) {
1419     tty-&gt;print_cr(&quot;     return allocated value&quot;);
1420   } else {
1421     tty-&gt;print_cr(&quot;     return non-local value&quot;);
1422   }
1423   tty-&gt;print(&quot;     modified args: &quot;);
1424   for (int i = 0; i &lt; _arg_size; i++) {
1425     if (_arg_modified[i] == 0)
1426       tty-&gt;print(&quot;    0&quot;);
1427     else
1428       tty-&gt;print(&quot;    0x%x&quot;, _arg_modified[i]);
1429   }
1430   tty-&gt;cr();
1431   tty-&gt;print(&quot;     flags: &quot;);
1432   if (_return_allocated)
1433     tty-&gt;print(&quot; return_allocated&quot;);
1434   if (_allocated_escapes)
1435     tty-&gt;print(&quot; allocated_escapes&quot;);
1436   if (_unknown_modified)
1437     tty-&gt;print(&quot; unknown_modified&quot;);
1438   tty-&gt;cr();
1439 }
1440 #endif
1441 
1442 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1443     : _arena(CURRENT_ENV-&gt;arena())
1444     , _conservative(method == NULL || !EstimateArgEscape)
1445     , _method(method)
1446     , _methodData(method ? method-&gt;method_data() : NULL)
1447     , _arg_size(method ? method-&gt;arg_size() : 0)
1448     , _arg_local(_arena)
1449     , _arg_stack(_arena)
1450     , _arg_returned(_arena)
1451     , _dirty(_arena)
1452     , _return_local(false)
1453     , _return_allocated(false)
1454     , _allocated_escapes(false)
1455     , _unknown_modified(false)
1456     , _dependencies(_arena, 4, 0, NULL)
1457     , _parent(parent)
1458     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1459   if (!_conservative) {
<a name="7" id="anc7"></a><span class="line-modified">1460     _arg_local.clear();</span>
<span class="line-modified">1461     _arg_stack.clear();</span>
<span class="line-modified">1462     _arg_returned.clear();</span>
<span class="line-modified">1463     _dirty.clear();</span>
1464     Arena* arena = CURRENT_ENV-&gt;arena();
1465     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1466     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1467 
1468     if (methodData() == NULL)
1469       return;
1470     if (methodData()-&gt;has_escape_info()) {
1471       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1472                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1473                                   method-&gt;name()-&gt;as_utf8()));
1474       read_escape_info();
1475     } else {
1476       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1477                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1478                                   method-&gt;name()-&gt;as_utf8()));
1479 
1480       compute_escape_info();
1481       methodData()-&gt;update_escape_info();
1482     }
1483 #ifndef PRODUCT
1484     if (BCEATraceLevel &gt;= 3) {
1485       // dump escape information
1486       dump();
1487     }
1488 #endif
1489   }
1490 }
1491 
1492 void BCEscapeAnalyzer::copy_dependencies(Dependencies *deps) {
1493   if (ciEnv::current()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
1494     // Also record evol dependencies so redefinition of the
1495     // callee will trigger recompilation.
1496     deps-&gt;assert_evol_method(method());
1497   }
1498   for (int i = 0; i &lt; _dependencies.length(); i+=2) {
1499     ciKlass *k = _dependencies.at(i)-&gt;as_klass();
1500     ciMethod *m = _dependencies.at(i+1)-&gt;as_method();
1501     deps-&gt;assert_unique_concrete_method(k, m);
1502   }
1503 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
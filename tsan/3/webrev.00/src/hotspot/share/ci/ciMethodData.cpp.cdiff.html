<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/ci/ciMethodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciMethod.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciMethodData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 79,17 ***</span>
  }
  
  // Check for entries that reference an unloaded method
  class PrepareExtraDataClosure : public CleanExtraDataClosure {
    MethodData*            _mdo;
<span class="line-modified">!   uint64_t               _safepoint_counter;</span>
    GrowableArray&lt;Method*&gt; _uncached_methods;
  
  public:
    PrepareExtraDataClosure(MethodData* mdo)
      : _mdo(mdo),
<span class="line-modified">!       _safepoint_counter(SafepointSynchronize::safepoint_counter()),</span>
        _uncached_methods()
    { }
  
    bool is_live(Method* m) {
      if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
<span class="line-new-header">--- 79,17 ---</span>
  }
  
  // Check for entries that reference an unloaded method
  class PrepareExtraDataClosure : public CleanExtraDataClosure {
    MethodData*            _mdo;
<span class="line-modified">!   SafepointStateTracker  _safepoint_tracker;</span>
    GrowableArray&lt;Method*&gt; _uncached_methods;
  
  public:
    PrepareExtraDataClosure(MethodData* mdo)
      : _mdo(mdo),
<span class="line-modified">!       _safepoint_tracker(SafepointSynchronize::safepoint_state_tracker()),</span>
        _uncached_methods()
    { }
  
    bool is_live(Method* m) {
      if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
      }
      return true;
    }
  
    bool has_safepointed() {
<span class="line-modified">!     return SafepointSynchronize::safepoint_counter() != _safepoint_counter;</span>
    }
  
    bool finish() {
      if (_uncached_methods.length() == 0) {
        // Preparation finished iff all Methods* were already cached.
<span class="line-new-header">--- 101,11 ---</span>
      }
      return true;
    }
  
    bool has_safepointed() {
<span class="line-modified">!     return _safepoint_tracker.safepoint_state_changed();</span>
    }
  
    bool finish() {
      if (_uncached_methods.length() == 0) {
        // Preparation finished iff all Methods* were already cached.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,40 ***</span>
        return;
      }
    }
  }
  
<span class="line-modified">! void ciMethodData::load_extra_data() {</span>
    MethodData* mdo = get_MethodData();
    MutexLocker ml(mdo-&gt;extra_data_lock());
    // Deferred metadata cleaning due to concurrent class unloading.
    prepare_metadata();
    // After metadata preparation, there is no stale metadata,
    // and no safepoints can introduce more stale metadata.
    NoSafepointVerifier no_safepoint;
  
    // speculative trap entries also hold a pointer to a Method so need to be translated
    DataLayout* dp_src  = mdo-&gt;extra_data_base();
    DataLayout* end_src = mdo-&gt;args_data_limit();
    DataLayout* dp_dst  = extra_data_base();
    for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
      assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
      assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
  
<span class="line-removed">-     // New traps in the MDO may have been added since we copied the</span>
<span class="line-removed">-     // data (concurrent deoptimizations before we acquired</span>
<span class="line-removed">-     // extra_data_lock above) or can be removed (a safepoint may occur</span>
<span class="line-removed">-     // in the prepare_metadata call above) as we translate the copy:</span>
<span class="line-removed">-     // update the copy as we go.</span>
      int tag = dp_src-&gt;tag();
<span class="line-removed">-     size_t entry_size = DataLayout::header_size_in_bytes();</span>
<span class="line-removed">-     if (tag != DataLayout::no_tag) {</span>
<span class="line-removed">-       ProfileData* src_data = dp_src-&gt;data_in();</span>
<span class="line-removed">-       entry_size = src_data-&gt;size_in_bytes();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     memcpy(dp_dst, dp_src, entry_size);</span>
<span class="line-removed">- </span>
      switch(tag) {
      case DataLayout::speculative_trap_data_tag: {
        ciSpeculativeTrapData data_dst(dp_dst);
        SpeculativeTrapData   data_src(dp_src);
        data_dst.translate_from(&amp;data_src);
<span class="line-new-header">--- 143,36 ---</span>
        return;
      }
    }
  }
  
<span class="line-modified">! void ciMethodData::load_remaining_extra_data() {</span>
    MethodData* mdo = get_MethodData();
    MutexLocker ml(mdo-&gt;extra_data_lock());
    // Deferred metadata cleaning due to concurrent class unloading.
    prepare_metadata();
    // After metadata preparation, there is no stale metadata,
    // and no safepoints can introduce more stale metadata.
    NoSafepointVerifier no_safepoint;
  
<span class="line-added">+   assert((mdo-&gt;data_size() == _data_size) &amp;&amp; (mdo-&gt;extra_data_size() == _extra_data_size), &quot;sanity, unchanged&quot;);</span>
<span class="line-added">+   assert(extra_data_base() == (DataLayout*)((address) _data + _data_size), &quot;sanity&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Copy the extra data once it is prepared (i.e. cache populated, no release of extra data lock anymore)</span>
<span class="line-added">+   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;extra_data_base(),</span>
<span class="line-added">+                               (HeapWord*)((address) _data + _data_size),</span>
<span class="line-added">+                               (_extra_data_size - mdo-&gt;parameters_size_in_bytes()) / HeapWordSize);</span>
<span class="line-added">+ </span>
    // speculative trap entries also hold a pointer to a Method so need to be translated
    DataLayout* dp_src  = mdo-&gt;extra_data_base();
    DataLayout* end_src = mdo-&gt;args_data_limit();
    DataLayout* dp_dst  = extra_data_base();
    for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
      assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
      assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
  
      int tag = dp_src-&gt;tag();
      switch(tag) {
      case DataLayout::speculative_trap_data_tag: {
        ciSpeculativeTrapData data_dst(dp_dst);
        SpeculativeTrapData   data_src(dp_src);
        data_dst.translate_from(&amp;data_src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,25 ***</span>
    }
  
    // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
    // of invocations.
  
<span class="line-modified">!   // Snapshot the data -- actually, take an approximate snapshot of</span>
<span class="line-modified">!   // the data.  Any concurrently executing threads may be changing the</span>
<span class="line-modified">!   // data as we copy it.</span>
    Copy::disjoint_words_atomic((HeapWord*) mdo,
                                (HeapWord*) &amp;_orig,
                                sizeof(_orig) / HeapWordSize);
    Arena* arena = CURRENT_ENV-&gt;arena();
    _data_size = mdo-&gt;data_size();
    _extra_data_size = mdo-&gt;extra_data_size();
    int total_size = _data_size + _extra_data_size;
    _data = (intptr_t *) arena-&gt;Amalloc(total_size);
    Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
                                (HeapWord*) _data,
<span class="line-modified">!                               total_size / HeapWordSize);</span>
  
    // Traverse the profile data, translating any oops into their
    // ci equivalents.
    ResourceMark rm;
    ciProfileData* ci_data = first_data();
    ProfileData* data = mdo-&gt;first_data();
<span class="line-new-header">--- 199,54 ---</span>
    }
  
    // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
    // of invocations.
  
<span class="line-modified">!   // Snapshot the data and extra parameter data first without the extra trap and arg info data.</span>
<span class="line-modified">!   // Those are copied in a second step. Actually, an approximate snapshot of the data is taken.</span>
<span class="line-modified">!   // Any concurrently executing threads may be changing the data as we copy it.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // The first snapshot step requires two copies (data entries and parameter data entries) since</span>
<span class="line-added">+   // the MDO is laid out as follows:</span>
<span class="line-added">+   //</span>
<span class="line-added">+   //  data_base:        ---------------------------</span>
<span class="line-added">+   //                    |       data entries      |</span>
<span class="line-added">+   //                    |           ...           |</span>
<span class="line-added">+   //  extra_data_base:  ---------------------------</span>
<span class="line-added">+   //                    |    trap data entries    |</span>
<span class="line-added">+   //                    |           ...           |</span>
<span class="line-added">+   //                    | one arg info data entry |</span>
<span class="line-added">+   //                    |    data for each arg    |</span>
<span class="line-added">+   //                    |           ...           |</span>
<span class="line-added">+   //  args_data_limit:  ---------------------------</span>
<span class="line-added">+   //                    |  parameter data entries |</span>
<span class="line-added">+   //                    |           ...           |</span>
<span class="line-added">+   //  extra_data_limit: ---------------------------</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // _data_size = extra_data_base - data_base</span>
<span class="line-added">+   // _extra_data_size = extra_data_limit - extra_data_base</span>
<span class="line-added">+   // total_size = _data_size + _extra_data_size</span>
<span class="line-added">+   // args_data_limit = data_base + total_size - parameter_data_size</span>
    Copy::disjoint_words_atomic((HeapWord*) mdo,
                                (HeapWord*) &amp;_orig,
                                sizeof(_orig) / HeapWordSize);
    Arena* arena = CURRENT_ENV-&gt;arena();
    _data_size = mdo-&gt;data_size();
    _extra_data_size = mdo-&gt;extra_data_size();
    int total_size = _data_size + _extra_data_size;
    _data = (intptr_t *) arena-&gt;Amalloc(total_size);
    Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
                                (HeapWord*) _data,
<span class="line-modified">!                               _data_size / HeapWordSize);</span>
  
<span class="line-added">+   int parameters_data_size = mdo-&gt;parameters_size_in_bytes();</span>
<span class="line-added">+   if (parameters_data_size &gt; 0) {</span>
<span class="line-added">+     // Snapshot the parameter data</span>
<span class="line-added">+     Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;args_data_limit(),</span>
<span class="line-added">+                                 (HeapWord*) ((address)_data + total_size - parameters_data_size),</span>
<span class="line-added">+                                 parameters_data_size / HeapWordSize);</span>
<span class="line-added">+   }</span>
    // Traverse the profile data, translating any oops into their
    // ci equivalents.
    ResourceMark rm;
    ciProfileData* ci_data = first_data();
    ProfileData* data = mdo-&gt;first_data();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,11 ***</span>
      _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
      ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
      parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
    }
  
<span class="line-modified">!   load_extra_data();</span>
  
    // Note:  Extra data are all BitData, and do not need translation.
    _current_mileage = MethodData::mileage_of(mdo-&gt;method());
    _invocation_counter = mdo-&gt;invocation_count();
    _backedge_counter = mdo-&gt;backedge_count();
<span class="line-new-header">--- 259,13 ---</span>
      _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
      ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
      parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
    }
  
<span class="line-modified">!   assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),</span>
<span class="line-added">+       &quot;sanity - parameter data starts after the argument data of the single ArgInfoData entry&quot;);</span>
<span class="line-added">+   load_remaining_extra_data();</span>
  
    // Note:  Extra data are all BitData, and do not need translation.
    _current_mileage = MethodData::mileage_of(mdo-&gt;method());
    _invocation_counter = mdo-&gt;invocation_count();
    _backedge_counter = mdo-&gt;backedge_count();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,10 ***</span>
<span class="line-new-header">--- 291,12 ---</span>
          set_receiver(row, klass);
        } else {
          // With concurrent class unloading, the MDO could have stale metadata; override it
          clear_row(row);
        }
<span class="line-added">+     } else {</span>
<span class="line-added">+       set_receiver(row, NULL);</span>
      }
    }
  }
  
  void ciTypeStackSlotEntries::translate_type_data_from(const TypeStackSlotEntries* entries) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,11 ***</span>
      case DataLayout::no_tag:
        _saw_free_extra_data = true;  // observed an empty slot (common case)
        two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
        return NULL;
      case DataLayout::arg_info_data_tag:
<span class="line-modified">!       return NULL; // ArgInfoData is at the end of extra data section.</span>
      case DataLayout::bit_data_tag:
        if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
          return new ciBitData(dp);
        }
        break;
<span class="line-new-header">--- 385,11 ---</span>
      case DataLayout::no_tag:
        _saw_free_extra_data = true;  // observed an empty slot (common case)
        two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
        return NULL;
      case DataLayout::arg_info_data_tag:
<span class="line-modified">!       return NULL; // ArgInfoData is after the trap data right before the parameter data.</span>
      case DataLayout::bit_data_tag:
        if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
          return new ciBitData(dp);
        }
        break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,11 ***</span>
      case DataLayout::bit_data_tag:
        data = new BitData(dp);
        break;
      case DataLayout::arg_info_data_tag:
        data = new ciArgInfoData(dp);
<span class="line-modified">!       dp = end; // ArgInfoData is at the end of extra data section.</span>
        break;
      case DataLayout::speculative_trap_data_tag:
        data = new ciSpeculativeTrapData(dp);
        break;
      default:
<span class="line-new-header">--- 792,11 ---</span>
      case DataLayout::bit_data_tag:
        data = new BitData(dp);
        break;
      case DataLayout::arg_info_data_tag:
        data = new ciArgInfoData(dp);
<span class="line-modified">!       dp = end; // ArgInfoData is after the trap data right before the parameter data.</span>
        break;
      case DataLayout::speculative_trap_data_tag:
        data = new ciSpeculativeTrapData(dp);
        break;
      default:
</pre>
<center><a href="ciMethod.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
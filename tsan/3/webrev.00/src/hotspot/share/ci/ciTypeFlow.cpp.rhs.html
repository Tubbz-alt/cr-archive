<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;
  34 #include &quot;compiler/compileLog.hpp&quot;
  35 #include &quot;interpreter/bytecode.hpp&quot;
  36 #include &quot;interpreter/bytecodes.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;opto/compile.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;utilities/growableArray.hpp&quot;
  44 
  45 // ciTypeFlow::JsrSet
  46 //
  47 // A JsrSet represents some set of JsrRecords.  This class
  48 // is used to record a set of all jsr routines which we permit
  49 // execution to return (ret) from.
  50 //
  51 // During abstract interpretation, JsrSets are used to determine
  52 // whether two paths which reach a given block are unique, and
  53 // should be cloned apart, or are compatible, and should merge
  54 // together.
  55 
  56 // ------------------------------------------------------------------
  57 // ciTypeFlow::JsrSet::JsrSet
  58 ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) {
  59   if (arena != NULL) {
  60     // Allocate growable array in Arena.
  61     _set = new (arena) GrowableArray&lt;JsrRecord*&gt;(arena, default_len, 0, NULL);
  62   } else {
  63     // Allocate growable array in current ResourceArea.
  64     _set = new GrowableArray&lt;JsrRecord*&gt;(4, 0, NULL, false);
  65   }
  66 }
  67 
  68 // ------------------------------------------------------------------
  69 // ciTypeFlow::JsrSet::copy_into
  70 void ciTypeFlow::JsrSet::copy_into(JsrSet* jsrs) {
  71   int len = size();
  72   jsrs-&gt;_set-&gt;clear();
  73   for (int i = 0; i &lt; len; i++) {
  74     jsrs-&gt;_set-&gt;append(_set-&gt;at(i));
  75   }
  76 }
  77 
  78 // ------------------------------------------------------------------
  79 // ciTypeFlow::JsrSet::is_compatible_with
  80 //
  81 // !!!! MISGIVINGS ABOUT THIS... disregard
  82 //
  83 // Is this JsrSet compatible with some other JsrSet?
  84 //
  85 // In set-theoretic terms, a JsrSet can be viewed as a partial function
  86 // from entry addresses to return addresses.  Two JsrSets A and B are
  87 // compatible iff
  88 //
  89 //   For any x,
  90 //   A(x) defined and B(x) defined implies A(x) == B(x)
  91 //
  92 // Less formally, two JsrSets are compatible when they have identical
  93 // return addresses for any entry addresses they share in common.
  94 bool ciTypeFlow::JsrSet::is_compatible_with(JsrSet* other) {
  95   // Walk through both sets in parallel.  If the same entry address
  96   // appears in both sets, then the return address must match for
  97   // the sets to be compatible.
  98   int size1 = size();
  99   int size2 = other-&gt;size();
 100 
 101   // Special case.  If nothing is on the jsr stack, then there can
 102   // be no ret.
 103   if (size2 == 0) {
 104     return true;
 105   } else if (size1 != size2) {
 106     return false;
 107   } else {
 108     for (int i = 0; i &lt; size1; i++) {
 109       JsrRecord* record1 = record_at(i);
 110       JsrRecord* record2 = other-&gt;record_at(i);
 111       if (record1-&gt;entry_address() != record2-&gt;entry_address() ||
 112           record1-&gt;return_address() != record2-&gt;return_address()) {
 113         return false;
 114       }
 115     }
 116     return true;
 117   }
 118 
 119 #if 0
 120   int pos1 = 0;
 121   int pos2 = 0;
 122   int size1 = size();
 123   int size2 = other-&gt;size();
 124   while (pos1 &lt; size1 &amp;&amp; pos2 &lt; size2) {
 125     JsrRecord* record1 = record_at(pos1);
 126     JsrRecord* record2 = other-&gt;record_at(pos2);
 127     int entry1 = record1-&gt;entry_address();
 128     int entry2 = record2-&gt;entry_address();
 129     if (entry1 &lt; entry2) {
 130       pos1++;
 131     } else if (entry1 &gt; entry2) {
 132       pos2++;
 133     } else {
 134       if (record1-&gt;return_address() == record2-&gt;return_address()) {
 135         pos1++;
 136         pos2++;
 137       } else {
 138         // These two JsrSets are incompatible.
 139         return false;
 140       }
 141     }
 142   }
 143   // The two JsrSets agree.
 144   return true;
 145 #endif
 146 }
 147 
 148 // ------------------------------------------------------------------
 149 // ciTypeFlow::JsrSet::insert_jsr_record
 150 //
 151 // Insert the given JsrRecord into the JsrSet, maintaining the order
 152 // of the set and replacing any element with the same entry address.
 153 void ciTypeFlow::JsrSet::insert_jsr_record(JsrRecord* record) {
 154   int len = size();
 155   int entry = record-&gt;entry_address();
 156   int pos = 0;
 157   for ( ; pos &lt; len; pos++) {
 158     JsrRecord* current = record_at(pos);
 159     if (entry == current-&gt;entry_address()) {
 160       // Stomp over this entry.
 161       _set-&gt;at_put(pos, record);
 162       assert(size() == len, &quot;must be same size&quot;);
 163       return;
 164     } else if (entry &lt; current-&gt;entry_address()) {
 165       break;
 166     }
 167   }
 168 
 169   // Insert the record into the list.
 170   JsrRecord* swap = record;
 171   JsrRecord* temp = NULL;
 172   for ( ; pos &lt; len; pos++) {
 173     temp = _set-&gt;at(pos);
 174     _set-&gt;at_put(pos, swap);
 175     swap = temp;
 176   }
 177   _set-&gt;append(swap);
 178   assert(size() == len+1, &quot;must be larger&quot;);
 179 }
 180 
 181 // ------------------------------------------------------------------
 182 // ciTypeFlow::JsrSet::remove_jsr_record
 183 //
 184 // Remove the JsrRecord with the given return address from the JsrSet.
 185 void ciTypeFlow::JsrSet::remove_jsr_record(int return_address) {
 186   int len = size();
 187   for (int i = 0; i &lt; len; i++) {
 188     if (record_at(i)-&gt;return_address() == return_address) {
 189       // We have found the proper entry.  Remove it from the
 190       // JsrSet and exit.
 191       for (int j = i+1; j &lt; len ; j++) {
 192         _set-&gt;at_put(j-1, _set-&gt;at(j));
 193       }
 194       _set-&gt;trunc_to(len-1);
 195       assert(size() == len-1, &quot;must be smaller&quot;);
 196       return;
 197     }
 198   }
 199   assert(false, &quot;verify: returning from invalid subroutine&quot;);
 200 }
 201 
 202 // ------------------------------------------------------------------
 203 // ciTypeFlow::JsrSet::apply_control
 204 //
 205 // Apply the effect of a control-flow bytecode on the JsrSet.  The
 206 // only bytecodes that modify the JsrSet are jsr and ret.
 207 void ciTypeFlow::JsrSet::apply_control(ciTypeFlow* analyzer,
 208                                        ciBytecodeStream* str,
 209                                        ciTypeFlow::StateVector* state) {
 210   Bytecodes::Code code = str-&gt;cur_bc();
 211   if (code == Bytecodes::_jsr) {
 212     JsrRecord* record =
 213       analyzer-&gt;make_jsr_record(str-&gt;get_dest(), str-&gt;next_bci());
 214     insert_jsr_record(record);
 215   } else if (code == Bytecodes::_jsr_w) {
 216     JsrRecord* record =
 217       analyzer-&gt;make_jsr_record(str-&gt;get_far_dest(), str-&gt;next_bci());
 218     insert_jsr_record(record);
 219   } else if (code == Bytecodes::_ret) {
 220     Cell local = state-&gt;local(str-&gt;get_index());
 221     ciType* return_address = state-&gt;type_at(local);
 222     assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
 223     if (size() == 0) {
 224       // Ret-state underflow:  Hit a ret w/o any previous jsrs.  Bail out.
 225       // This can happen when a loop is inside a finally clause (4614060).
 226       analyzer-&gt;record_failure(&quot;OSR in finally clause&quot;);
 227       return;
 228     }
 229     remove_jsr_record(return_address-&gt;as_return_address()-&gt;bci());
 230   }
 231 }
 232 
 233 #ifndef PRODUCT
 234 // ------------------------------------------------------------------
 235 // ciTypeFlow::JsrSet::print_on
 236 void ciTypeFlow::JsrSet::print_on(outputStream* st) const {
 237   st-&gt;print(&quot;{ &quot;);
 238   int num_elements = size();
 239   if (num_elements &gt; 0) {
 240     int i = 0;
 241     for( ; i &lt; num_elements - 1; i++) {
 242       _set-&gt;at(i)-&gt;print_on(st);
 243       st-&gt;print(&quot;, &quot;);
 244     }
 245     _set-&gt;at(i)-&gt;print_on(st);
 246     st-&gt;print(&quot; &quot;);
 247   }
 248   st-&gt;print(&quot;}&quot;);
 249 }
 250 #endif
 251 
 252 // ciTypeFlow::StateVector
 253 //
 254 // A StateVector summarizes the type information at some point in
 255 // the program.
 256 
 257 // ------------------------------------------------------------------
 258 // ciTypeFlow::StateVector::type_meet
 259 //
 260 // Meet two types.
 261 //
 262 // The semi-lattice of types use by this analysis are modeled on those
 263 // of the verifier.  The lattice is as follows:
 264 //
 265 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 266 //                             and
 267 //   Every primitive type is comparable only with itself.  The meet of
 268 //   reference types is determined by their kind: instance class,
 269 //   interface, or array class.  The meet of two types of the same
 270 //   kind is their least common ancestor.  The meet of two types of
 271 //   different kinds is always java.lang.Object.
 272 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 273   assert(t1 != t2, &quot;checked in caller&quot;);
 274   if (t1-&gt;equals(top_type())) {
 275     return t2;
 276   } else if (t2-&gt;equals(top_type())) {
 277     return t1;
 278   } else if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {
 279     // Special case null_type.  null_type meet any reference type T
 280     // is T.  null_type meet null_type is null_type.
 281     if (t1-&gt;equals(null_type())) {
 282       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
 283         return t2;
 284       }
 285     } else if (t2-&gt;equals(null_type())) {
 286       if (!t1-&gt;is_primitive_type()) {
 287         return t1;
 288       }
 289     }
 290 
 291     // At least one of the two types is a non-top primitive type.
 292     // The other type is not equal to it.  Fall to bottom.
 293     return bottom_type();
 294   } else {
 295     // Both types are non-top non-primitive types.  That is,
 296     // both types are either instanceKlasses or arrayKlasses.
 297     ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 298     ciKlass* k1 = t1-&gt;as_klass();
 299     ciKlass* k2 = t2-&gt;as_klass();
 300     if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 301       return object_klass;
 302     } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 303       // Unloaded classes fall to java.lang.Object at a merge.
 304       return object_klass;
 305     } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 306       // When an interface meets a non-interface, we get Object;
 307       // This is what the verifier does.
 308       return object_klass;
 309     } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 310       // When an array meets a non-array, we get Object.
 311       // When objArray meets typeArray, we also get Object.
 312       // And when typeArray meets different typeArray, we again get Object.
 313       // But when objArray meets objArray, we look carefully at element types.
 314       if (k1-&gt;is_obj_array_klass() &amp;&amp; k2-&gt;is_obj_array_klass()) {
 315         // Meet the element types, then construct the corresponding array type.
 316         ciKlass* elem1 = k1-&gt;as_obj_array_klass()-&gt;element_klass();
 317         ciKlass* elem2 = k2-&gt;as_obj_array_klass()-&gt;element_klass();
 318         ciKlass* elem  = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 319         // Do an easy shortcut if one type is a super of the other.
 320         if (elem == elem1) {
 321           assert(k1 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 322           return k1;
 323         } else if (elem == elem2) {
 324           assert(k2 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 325           return k2;
 326         } else {
 327           return ciObjArrayKlass::make(elem);
 328         }
 329       } else {
 330         return object_klass;
 331       }
 332     } else {
 333       // Must be two plain old instance klasses.
 334       assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 335       assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 336       return k1-&gt;least_common_ancestor(k2);
 337     }
 338   }
 339 }
 340 
 341 
 342 // ------------------------------------------------------------------
 343 // ciTypeFlow::StateVector::StateVector
 344 //
 345 // Build a new state vector
 346 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 347   _outer = analyzer;
 348   _stack_size = -1;
 349   _monitor_count = -1;
 350   // Allocate the _types array
 351   int max_cells = analyzer-&gt;max_cells();
 352   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 353   for (int i=0; i&lt;max_cells; i++) {
 354     _types[i] = top_type();
 355   }
 356   _trap_bci = -1;
 357   _trap_index = 0;
 358   _def_locals.clear();
 359 }
 360 
 361 
 362 // ------------------------------------------------------------------
 363 // ciTypeFlow::get_start_state
 364 //
 365 // Set this vector to the method entry state.
 366 const ciTypeFlow::StateVector* ciTypeFlow::get_start_state() {
 367   StateVector* state = new StateVector(this);
 368   if (is_osr_flow()) {
 369     ciTypeFlow* non_osr_flow = method()-&gt;get_flow_analysis();
 370     if (non_osr_flow-&gt;failing()) {
 371       record_failure(non_osr_flow-&gt;failure_reason());
 372       return NULL;
 373     }
 374     JsrSet* jsrs = new JsrSet(NULL, 16);
 375     Block* non_osr_block = non_osr_flow-&gt;existing_block_at(start_bci(), jsrs);
 376     if (non_osr_block == NULL) {
 377       record_failure(&quot;cannot reach OSR point&quot;);
 378       return NULL;
 379     }
 380     // load up the non-OSR state at this point
 381     non_osr_block-&gt;copy_state_into(state);
 382     int non_osr_start = non_osr_block-&gt;start();
 383     if (non_osr_start != start_bci()) {
 384       // must flow forward from it
 385       if (CITraceTypeFlow) {
 386         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 387       }
 388       Block* block = block_at(non_osr_start, jsrs);
 389       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 390       flow_block(block, state, jsrs);
 391     }
 392     return state;
 393     // Note:  The code below would be an incorrect for an OSR flow,
 394     // even if it were possible for an OSR entry point to be at bci zero.
 395   }
 396   // &quot;Push&quot; the method signature into the first few locals.
 397   state-&gt;set_stack_size(-max_locals());
 398   if (!method()-&gt;is_static()) {
 399     state-&gt;push(method()-&gt;holder());
 400     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 401   }
 402   for (ciSignatureStream str(method()-&gt;signature());
 403        !str.at_return_type();
 404        str.next()) {
 405     state-&gt;push_translate(str.type());
 406   }
 407   // Set the rest of the locals to bottom.
 408   Cell cell = state-&gt;next_cell(state-&gt;tos());
 409   state-&gt;set_stack_size(0);
 410   int limit = state-&gt;limit_cell();
 411   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 412     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 413   }
 414   // Lock an object, if necessary.
 415   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 416   return state;
 417 }
 418 
 419 // ------------------------------------------------------------------
 420 // ciTypeFlow::StateVector::copy_into
 421 //
 422 // Copy our value into some other StateVector
 423 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 424 const {
 425   copy-&gt;set_stack_size(stack_size());
 426   copy-&gt;set_monitor_count(monitor_count());
 427   Cell limit = limit_cell();
 428   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 429     copy-&gt;set_type_at(c, type_at(c));
 430   }
 431 }
 432 
 433 // ------------------------------------------------------------------
 434 // ciTypeFlow::StateVector::meet
 435 //
 436 // Meets this StateVector with another, destructively modifying this
 437 // one.  Returns true if any modification takes place.
 438 bool ciTypeFlow::StateVector::meet(const ciTypeFlow::StateVector* incoming) {
 439   if (monitor_count() == -1) {
 440     set_monitor_count(incoming-&gt;monitor_count());
 441   }
 442   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 443 
 444   if (stack_size() == -1) {
 445     set_stack_size(incoming-&gt;stack_size());
 446     Cell limit = limit_cell();
 447     #ifdef ASSERT
 448     { for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 449         assert(type_at(c) == top_type(), &quot;&quot;);
 450     } }
 451     #endif
 452     // Make a simple copy of the incoming state.
 453     for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 454       set_type_at(c, incoming-&gt;type_at(c));
 455     }
 456     return true;  // it is always different the first time
 457   }
 458 #ifdef ASSERT
 459   if (stack_size() != incoming-&gt;stack_size()) {
 460     _outer-&gt;method()-&gt;print_codes();
 461     tty-&gt;print_cr(&quot;!!!! Stack size conflict&quot;);
 462     tty-&gt;print_cr(&quot;Current state:&quot;);
 463     print_on(tty);
 464     tty-&gt;print_cr(&quot;Incoming state:&quot;);
 465     ((StateVector*)incoming)-&gt;print_on(tty);
 466   }
 467 #endif
 468   assert(stack_size() == incoming-&gt;stack_size(), &quot;sanity&quot;);
 469 
 470   bool different = false;
 471   Cell limit = limit_cell();
 472   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 473     ciType* t1 = type_at(c);
 474     ciType* t2 = incoming-&gt;type_at(c);
 475     if (!t1-&gt;equals(t2)) {
 476       ciType* new_type = type_meet(t1, t2);
 477       if (!t1-&gt;equals(new_type)) {
 478         set_type_at(c, new_type);
 479         different = true;
 480       }
 481     }
 482   }
 483   return different;
 484 }
 485 
 486 // ------------------------------------------------------------------
 487 // ciTypeFlow::StateVector::meet_exception
 488 //
 489 // Meets this StateVector with another, destructively modifying this
 490 // one.  The incoming state is coming via an exception.  Returns true
 491 // if any modification takes place.
 492 bool ciTypeFlow::StateVector::meet_exception(ciInstanceKlass* exc,
 493                                      const ciTypeFlow::StateVector* incoming) {
 494   if (monitor_count() == -1) {
 495     set_monitor_count(incoming-&gt;monitor_count());
 496   }
 497   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 498 
 499   if (stack_size() == -1) {
 500     set_stack_size(1);
 501   }
 502 
 503   assert(stack_size() ==  1, &quot;must have one-element stack&quot;);
 504 
 505   bool different = false;
 506 
 507   // Meet locals from incoming array.
 508   Cell limit = local(_outer-&gt;max_locals()-1);
 509   for (Cell c = start_cell(); c &lt;= limit; c = next_cell(c)) {
 510     ciType* t1 = type_at(c);
 511     ciType* t2 = incoming-&gt;type_at(c);
 512     if (!t1-&gt;equals(t2)) {
 513       ciType* new_type = type_meet(t1, t2);
 514       if (!t1-&gt;equals(new_type)) {
 515         set_type_at(c, new_type);
 516         different = true;
 517       }
 518     }
 519   }
 520 
 521   // Handle stack separately.  When an exception occurs, the
 522   // only stack entry is the exception instance.
 523   ciType* tos_type = type_at_tos();
 524   if (!tos_type-&gt;equals(exc)) {
 525     ciType* new_type = type_meet(tos_type, exc);
 526     if (!tos_type-&gt;equals(new_type)) {
 527       set_type_at_tos(new_type);
 528       different = true;
 529     }
 530   }
 531 
 532   return different;
 533 }
 534 
 535 // ------------------------------------------------------------------
 536 // ciTypeFlow::StateVector::push_translate
 537 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 538   BasicType basic_type = type-&gt;basic_type();
 539   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 540       basic_type == T_BYTE    || basic_type == T_SHORT) {
 541     push_int();
 542   } else {
 543     push(type);
 544     if (type-&gt;is_two_word()) {
 545       push(half_type(type));
 546     }
 547   }
 548 }
 549 
 550 // ------------------------------------------------------------------
 551 // ciTypeFlow::StateVector::do_aaload
 552 void ciTypeFlow::StateVector::do_aaload(ciBytecodeStream* str) {
 553   pop_int();
 554   ciObjArrayKlass* array_klass = pop_objArray();
 555   if (array_klass == NULL) {
 556     // Did aaload on a null reference; push a null and ignore the exception.
 557     // This instruction will never continue normally.  All we have to do
 558     // is report a value that will meet correctly with any downstream
 559     // reference types on paths that will truly be executed.  This null type
 560     // meets with any reference type to yield that same reference type.
 561     // (The compiler will generate an unconditional exception here.)
 562     push(null_type());
 563     return;
 564   }
 565   if (!array_klass-&gt;is_loaded()) {
 566     // Only fails for some -Xcomp runs
 567     trap(str, array_klass,
 568          Deoptimization::make_trap_request
 569          (Deoptimization::Reason_unloaded,
 570           Deoptimization::Action_reinterpret));
 571     return;
 572   }
 573   ciKlass* element_klass = array_klass-&gt;element_klass();
 574   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 575     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 576     trap(str, element_klass,
 577          Deoptimization::make_trap_request
 578          (Deoptimization::Reason_unloaded,
 579           Deoptimization::Action_reinterpret));
 580   } else {
 581     push_object(element_klass);
 582   }
 583 }
 584 
 585 
 586 // ------------------------------------------------------------------
 587 // ciTypeFlow::StateVector::do_checkcast
 588 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 589   bool will_link;
 590   ciKlass* klass = str-&gt;get_klass(will_link);
 591   if (!will_link) {
 592     // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 593     // Type flow after this block may still be needed in two situations:
 594     // 1) C2 uses do_null_assert() and continues compilation for later blocks
 595     // 2) C2 does an OSR compile in a later block (see bug 4778368).
 596     pop_object();
 597     do_null_assert(klass);
 598   } else {
 599     pop_object();
 600     push_object(klass);
 601   }
 602 }
 603 
 604 // ------------------------------------------------------------------
 605 // ciTypeFlow::StateVector::do_getfield
 606 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 607   // could add assert here for type of object.
 608   pop_object();
 609   do_getstatic(str);
 610 }
 611 
 612 // ------------------------------------------------------------------
 613 // ciTypeFlow::StateVector::do_getstatic
 614 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 615   bool will_link;
 616   ciField* field = str-&gt;get_field(will_link);
 617   if (!will_link) {
 618     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 619   } else {
 620     ciType* field_type = field-&gt;type();
 621     if (!field_type-&gt;is_loaded()) {
 622       // Normally, we need the field&#39;s type to be loaded if we are to
 623       // do anything interesting with its value.
 624       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 625       //
 626       // There is one good reason not to trap here.  Execution can
 627       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 628       // the field is null.  As long as the value is null, the class
 629       // does not need to be loaded!  The compiler must assume that
 630       // the value of the unloaded class reference is null; if the code
 631       // ever sees a non-null value, loading has occurred.
 632       //
 633       // This actually happens often enough to be annoying.  If the
 634       // compiler throws an uncommon trap at this bytecode, you can
 635       // get an endless loop of recompilations, when all the code
 636       // needs to do is load a series of null values.  Also, a trap
 637       // here can make an OSR entry point unreachable, triggering the
 638       // assert on non_osr_block in ciTypeFlow::get_start_state.
 639       // (See bug 4379915.)
 640       do_null_assert(field_type-&gt;as_klass());
 641     } else {
 642       push_translate(field_type);
 643     }
 644   }
 645 }
 646 
 647 // ------------------------------------------------------------------
 648 // ciTypeFlow::StateVector::do_invoke
 649 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 650                                         bool has_receiver) {
 651   bool will_link;
 652   ciSignature* declared_signature = NULL;
 653   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 654   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 655   if (!will_link) {
 656     // We weren&#39;t able to find the method.
 657     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 658       trap(str, NULL,
 659            Deoptimization::make_trap_request
 660            (Deoptimization::Reason_uninitialized,
 661             Deoptimization::Action_reinterpret));
 662     } else {
 663       ciKlass* unloaded_holder = callee-&gt;holder();
 664       trap(str, unloaded_holder, str-&gt;get_method_holder_index());
 665     }
 666   } else {
 667     // We are using the declared signature here because it might be
 668     // different from the callee signature (Cf. invokedynamic and
 669     // invokehandle).
 670     ciSignatureStream sigstr(declared_signature);
 671     const int arg_size = declared_signature-&gt;size();
 672     const int stack_base = stack_size() - arg_size;
 673     int i = 0;
 674     for( ; !sigstr.at_return_type(); sigstr.next()) {
 675       ciType* type = sigstr.type();
 676       ciType* stack_type = type_at(stack(stack_base + i++));
 677       // Do I want to check this type?
 678       // assert(stack_type-&gt;is_subtype_of(type), &quot;bad type for field value&quot;);
 679       if (type-&gt;is_two_word()) {
 680         ciType* stack_type2 = type_at(stack(stack_base + i++));
 681         assert(stack_type2-&gt;equals(half_type(type)), &quot;must be 2nd half&quot;);
 682       }
 683     }
 684     assert(arg_size == i, &quot;must match&quot;);
 685     for (int j = 0; j &lt; arg_size; j++) {
 686       pop();
 687     }
 688     if (has_receiver) {
 689       // Check this?
 690       pop_object();
 691     }
 692     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 693     ciType* return_type = sigstr.type();
 694     if (!return_type-&gt;is_void()) {
 695       if (!return_type-&gt;is_loaded()) {
 696         // As in do_getstatic(), generally speaking, we need the return type to
 697         // be loaded if we are to do anything interesting with its value.
 698         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 699         //
 700         // We do not trap here since execution can get past this invoke if
 701         // the return value is null.  As long as the value is null, the class
 702         // does not need to be loaded!  The compiler must assume that
 703         // the value of the unloaded class reference is null; if the code
 704         // ever sees a non-null value, loading has occurred.
 705         //
 706         // See do_getstatic() for similar explanation, as well as bug 4684993.
 707         do_null_assert(return_type-&gt;as_klass());
 708       } else {
 709         push_translate(return_type);
 710       }
 711     }
 712   }
 713 }
 714 
 715 // ------------------------------------------------------------------
 716 // ciTypeFlow::StateVector::do_jsr
 717 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 718   push(ciReturnAddress::make(str-&gt;next_bci()));
 719 }
 720 
 721 // ------------------------------------------------------------------
 722 // ciTypeFlow::StateVector::do_ldc
 723 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 724   ciConstant con = str-&gt;get_constant();
 725   BasicType basic_type = con.basic_type();
 726   if (basic_type == T_ILLEGAL) {
 727     // OutOfMemoryError in the CI while loading constant
 728     push_null();
 729     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 730     return;
 731   }
<a name="1" id="anc1"></a><span class="line-modified"> 732   if (is_reference_type(basic_type)) {</span>
 733     ciObject* obj = con.as_object();
 734     if (obj-&gt;is_null_object()) {
 735       push_null();
 736     } else {
 737       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
 738       push_object(obj-&gt;klass());
 739     }
 740   } else {
 741     push_translate(ciType::make(basic_type));
 742   }
 743 }
 744 
 745 // ------------------------------------------------------------------
 746 // ciTypeFlow::StateVector::do_multianewarray
 747 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 748   int dimensions = str-&gt;get_dimensions();
 749   bool will_link;
 750   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 751   if (!will_link) {
 752     trap(str, array_klass, str-&gt;get_klass_index());
 753   } else {
 754     for (int i = 0; i &lt; dimensions; i++) {
 755       pop_int();
 756     }
 757     push_object(array_klass);
 758   }
 759 }
 760 
 761 // ------------------------------------------------------------------
 762 // ciTypeFlow::StateVector::do_new
 763 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 764   bool will_link;
 765   ciKlass* klass = str-&gt;get_klass(will_link);
 766   if (!will_link || str-&gt;is_unresolved_klass()) {
 767     trap(str, klass, str-&gt;get_klass_index());
 768   } else {
 769     push_object(klass);
 770   }
 771 }
 772 
 773 // ------------------------------------------------------------------
 774 // ciTypeFlow::StateVector::do_newarray
 775 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 776   pop_int();
 777   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 778   push_object(klass);
 779 }
 780 
 781 // ------------------------------------------------------------------
 782 // ciTypeFlow::StateVector::do_putfield
 783 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 784   do_putstatic(str);
 785   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 786   // could add assert here for type of object.
 787   pop_object();
 788 }
 789 
 790 // ------------------------------------------------------------------
 791 // ciTypeFlow::StateVector::do_putstatic
 792 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
 793   bool will_link;
 794   ciField* field = str-&gt;get_field(will_link);
 795   if (!will_link) {
 796     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 797   } else {
 798     ciType* field_type = field-&gt;type();
 799     ciType* type = pop_value();
 800     // Do I want to check this type?
 801     //      assert(type-&gt;is_subtype_of(field_type), &quot;bad type for field value&quot;);
 802     if (field_type-&gt;is_two_word()) {
 803       ciType* type2 = pop_value();
 804       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 805       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 806     }
 807   }
 808 }
 809 
 810 // ------------------------------------------------------------------
 811 // ciTypeFlow::StateVector::do_ret
 812 void ciTypeFlow::StateVector::do_ret(ciBytecodeStream* str) {
 813   Cell index = local(str-&gt;get_index());
 814 
 815   ciType* address = type_at(index);
 816   assert(address-&gt;is_return_address(), &quot;bad return address&quot;);
 817   set_type_at(index, bottom_type());
 818 }
 819 
 820 // ------------------------------------------------------------------
 821 // ciTypeFlow::StateVector::trap
 822 //
 823 // Stop interpretation of this path with a trap.
 824 void ciTypeFlow::StateVector::trap(ciBytecodeStream* str, ciKlass* klass, int index) {
 825   _trap_bci = str-&gt;cur_bci();
 826   _trap_index = index;
 827 
 828   // Log information about this trap:
 829   CompileLog* log = outer()-&gt;env()-&gt;log();
 830   if (log != NULL) {
 831     int mid = log-&gt;identify(outer()-&gt;method());
 832     int kid = (klass == NULL)? -1: log-&gt;identify(klass);
 833     log-&gt;begin_elem(&quot;uncommon_trap method=&#39;%d&#39; bci=&#39;%d&#39;&quot;, mid, str-&gt;cur_bci());
 834     char buf[100];
 835     log-&gt;print(&quot; %s&quot;, Deoptimization::format_trap_request(buf, sizeof(buf),
 836                                                           index));
 837     if (kid &gt;= 0)
 838       log-&gt;print(&quot; klass=&#39;%d&#39;&quot;, kid);
 839     log-&gt;end_elem();
 840   }
 841 }
 842 
 843 // ------------------------------------------------------------------
 844 // ciTypeFlow::StateVector::do_null_assert
 845 // Corresponds to graphKit::do_null_assert.
 846 void ciTypeFlow::StateVector::do_null_assert(ciKlass* unloaded_klass) {
 847   if (unloaded_klass-&gt;is_loaded()) {
 848     // We failed to link, but we can still compute with this class,
 849     // since it is loaded somewhere.  The compiler will uncommon_trap
 850     // if the object is not null, but the typeflow pass can not assume
 851     // that the object will be null, otherwise it may incorrectly tell
 852     // the parser that an object is known to be null. 4761344, 4807707
 853     push_object(unloaded_klass);
 854   } else {
 855     // The class is not loaded anywhere.  It is safe to model the
 856     // null in the typestates, because we can compile in a null check
 857     // which will deoptimize us if someone manages to load the
 858     // class later.
 859     push_null();
 860   }
 861 }
 862 
 863 
 864 // ------------------------------------------------------------------
 865 // ciTypeFlow::StateVector::apply_one_bytecode
 866 //
 867 // Apply the effect of one bytecode to this StateVector
 868 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 869   _trap_bci = -1;
 870   _trap_index = 0;
 871 
 872   if (CITraceTypeFlow) {
 873     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 874                   Bytecodes::name(str-&gt;cur_bc()));
 875   }
 876 
 877   switch(str-&gt;cur_bc()) {
 878   case Bytecodes::_aaload: do_aaload(str);                       break;
 879 
 880   case Bytecodes::_aastore:
 881     {
 882       pop_object();
 883       pop_int();
 884       pop_objArray();
 885       break;
 886     }
 887   case Bytecodes::_aconst_null:
 888     {
 889       push_null();
 890       break;
 891     }
 892   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 893   case Bytecodes::_aload_0: load_local_object(0);                   break;
 894   case Bytecodes::_aload_1: load_local_object(1);                   break;
 895   case Bytecodes::_aload_2: load_local_object(2);                   break;
 896   case Bytecodes::_aload_3: load_local_object(3);                   break;
 897 
 898   case Bytecodes::_anewarray:
 899     {
 900       pop_int();
 901       bool will_link;
 902       ciKlass* element_klass = str-&gt;get_klass(will_link);
 903       if (!will_link) {
 904         trap(str, element_klass, str-&gt;get_klass_index());
 905       } else {
 906         push_object(ciObjArrayKlass::make(element_klass));
 907       }
 908       break;
 909     }
 910   case Bytecodes::_areturn:
 911   case Bytecodes::_ifnonnull:
 912   case Bytecodes::_ifnull:
 913     {
 914       pop_object();
 915       break;
 916     }
 917   case Bytecodes::_monitorenter:
 918     {
 919       pop_object();
 920       set_monitor_count(monitor_count() + 1);
 921       break;
 922     }
 923   case Bytecodes::_monitorexit:
 924     {
 925       pop_object();
 926       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
 927       set_monitor_count(monitor_count() - 1);
 928       break;
 929     }
 930   case Bytecodes::_arraylength:
 931     {
 932       pop_array();
 933       push_int();
 934       break;
 935     }
 936   case Bytecodes::_astore:   store_local_object(str-&gt;get_index());  break;
 937   case Bytecodes::_astore_0: store_local_object(0);                 break;
 938   case Bytecodes::_astore_1: store_local_object(1);                 break;
 939   case Bytecodes::_astore_2: store_local_object(2);                 break;
 940   case Bytecodes::_astore_3: store_local_object(3);                 break;
 941 
 942   case Bytecodes::_athrow:
 943     {
 944       NEEDS_CLEANUP;
 945       pop_object();
 946       break;
 947     }
 948   case Bytecodes::_baload:
 949   case Bytecodes::_caload:
 950   case Bytecodes::_iaload:
 951   case Bytecodes::_saload:
 952     {
 953       pop_int();
 954       ciTypeArrayKlass* array_klass = pop_typeArray();
 955       // Put assert here for right type?
 956       push_int();
 957       break;
 958     }
 959   case Bytecodes::_bastore:
 960   case Bytecodes::_castore:
 961   case Bytecodes::_iastore:
 962   case Bytecodes::_sastore:
 963     {
 964       pop_int();
 965       pop_int();
 966       pop_typeArray();
 967       // assert here?
 968       break;
 969     }
 970   case Bytecodes::_bipush:
 971   case Bytecodes::_iconst_m1:
 972   case Bytecodes::_iconst_0:
 973   case Bytecodes::_iconst_1:
 974   case Bytecodes::_iconst_2:
 975   case Bytecodes::_iconst_3:
 976   case Bytecodes::_iconst_4:
 977   case Bytecodes::_iconst_5:
 978   case Bytecodes::_sipush:
 979     {
 980       push_int();
 981       break;
 982     }
 983   case Bytecodes::_checkcast: do_checkcast(str);                  break;
 984 
 985   case Bytecodes::_d2f:
 986     {
 987       pop_double();
 988       push_float();
 989       break;
 990     }
 991   case Bytecodes::_d2i:
 992     {
 993       pop_double();
 994       push_int();
 995       break;
 996     }
 997   case Bytecodes::_d2l:
 998     {
 999       pop_double();
1000       push_long();
1001       break;
1002     }
1003   case Bytecodes::_dadd:
1004   case Bytecodes::_ddiv:
1005   case Bytecodes::_dmul:
1006   case Bytecodes::_drem:
1007   case Bytecodes::_dsub:
1008     {
1009       pop_double();
1010       pop_double();
1011       push_double();
1012       break;
1013     }
1014   case Bytecodes::_daload:
1015     {
1016       pop_int();
1017       ciTypeArrayKlass* array_klass = pop_typeArray();
1018       // Put assert here for right type?
1019       push_double();
1020       break;
1021     }
1022   case Bytecodes::_dastore:
1023     {
1024       pop_double();
1025       pop_int();
1026       pop_typeArray();
1027       // assert here?
1028       break;
1029     }
1030   case Bytecodes::_dcmpg:
1031   case Bytecodes::_dcmpl:
1032     {
1033       pop_double();
1034       pop_double();
1035       push_int();
1036       break;
1037     }
1038   case Bytecodes::_dconst_0:
1039   case Bytecodes::_dconst_1:
1040     {
1041       push_double();
1042       break;
1043     }
1044   case Bytecodes::_dload:   load_local_double(str-&gt;get_index());    break;
1045   case Bytecodes::_dload_0: load_local_double(0);                   break;
1046   case Bytecodes::_dload_1: load_local_double(1);                   break;
1047   case Bytecodes::_dload_2: load_local_double(2);                   break;
1048   case Bytecodes::_dload_3: load_local_double(3);                   break;
1049 
1050   case Bytecodes::_dneg:
1051     {
1052       pop_double();
1053       push_double();
1054       break;
1055     }
1056   case Bytecodes::_dreturn:
1057     {
1058       pop_double();
1059       break;
1060     }
1061   case Bytecodes::_dstore:   store_local_double(str-&gt;get_index());  break;
1062   case Bytecodes::_dstore_0: store_local_double(0);                 break;
1063   case Bytecodes::_dstore_1: store_local_double(1);                 break;
1064   case Bytecodes::_dstore_2: store_local_double(2);                 break;
1065   case Bytecodes::_dstore_3: store_local_double(3);                 break;
1066 
1067   case Bytecodes::_dup:
1068     {
1069       push(type_at_tos());
1070       break;
1071     }
1072   case Bytecodes::_dup_x1:
1073     {
1074       ciType* value1 = pop_value();
1075       ciType* value2 = pop_value();
1076       push(value1);
1077       push(value2);
1078       push(value1);
1079       break;
1080     }
1081   case Bytecodes::_dup_x2:
1082     {
1083       ciType* value1 = pop_value();
1084       ciType* value2 = pop_value();
1085       ciType* value3 = pop_value();
1086       push(value1);
1087       push(value3);
1088       push(value2);
1089       push(value1);
1090       break;
1091     }
1092   case Bytecodes::_dup2:
1093     {
1094       ciType* value1 = pop_value();
1095       ciType* value2 = pop_value();
1096       push(value2);
1097       push(value1);
1098       push(value2);
1099       push(value1);
1100       break;
1101     }
1102   case Bytecodes::_dup2_x1:
1103     {
1104       ciType* value1 = pop_value();
1105       ciType* value2 = pop_value();
1106       ciType* value3 = pop_value();
1107       push(value2);
1108       push(value1);
1109       push(value3);
1110       push(value2);
1111       push(value1);
1112       break;
1113     }
1114   case Bytecodes::_dup2_x2:
1115     {
1116       ciType* value1 = pop_value();
1117       ciType* value2 = pop_value();
1118       ciType* value3 = pop_value();
1119       ciType* value4 = pop_value();
1120       push(value2);
1121       push(value1);
1122       push(value4);
1123       push(value3);
1124       push(value2);
1125       push(value1);
1126       break;
1127     }
1128   case Bytecodes::_f2d:
1129     {
1130       pop_float();
1131       push_double();
1132       break;
1133     }
1134   case Bytecodes::_f2i:
1135     {
1136       pop_float();
1137       push_int();
1138       break;
1139     }
1140   case Bytecodes::_f2l:
1141     {
1142       pop_float();
1143       push_long();
1144       break;
1145     }
1146   case Bytecodes::_fadd:
1147   case Bytecodes::_fdiv:
1148   case Bytecodes::_fmul:
1149   case Bytecodes::_frem:
1150   case Bytecodes::_fsub:
1151     {
1152       pop_float();
1153       pop_float();
1154       push_float();
1155       break;
1156     }
1157   case Bytecodes::_faload:
1158     {
1159       pop_int();
1160       ciTypeArrayKlass* array_klass = pop_typeArray();
1161       // Put assert here.
1162       push_float();
1163       break;
1164     }
1165   case Bytecodes::_fastore:
1166     {
1167       pop_float();
1168       pop_int();
1169       ciTypeArrayKlass* array_klass = pop_typeArray();
1170       // Put assert here.
1171       break;
1172     }
1173   case Bytecodes::_fcmpg:
1174   case Bytecodes::_fcmpl:
1175     {
1176       pop_float();
1177       pop_float();
1178       push_int();
1179       break;
1180     }
1181   case Bytecodes::_fconst_0:
1182   case Bytecodes::_fconst_1:
1183   case Bytecodes::_fconst_2:
1184     {
1185       push_float();
1186       break;
1187     }
1188   case Bytecodes::_fload:   load_local_float(str-&gt;get_index());     break;
1189   case Bytecodes::_fload_0: load_local_float(0);                    break;
1190   case Bytecodes::_fload_1: load_local_float(1);                    break;
1191   case Bytecodes::_fload_2: load_local_float(2);                    break;
1192   case Bytecodes::_fload_3: load_local_float(3);                    break;
1193 
1194   case Bytecodes::_fneg:
1195     {
1196       pop_float();
1197       push_float();
1198       break;
1199     }
1200   case Bytecodes::_freturn:
1201     {
1202       pop_float();
1203       break;
1204     }
1205   case Bytecodes::_fstore:    store_local_float(str-&gt;get_index());   break;
1206   case Bytecodes::_fstore_0:  store_local_float(0);                  break;
1207   case Bytecodes::_fstore_1:  store_local_float(1);                  break;
1208   case Bytecodes::_fstore_2:  store_local_float(2);                  break;
1209   case Bytecodes::_fstore_3:  store_local_float(3);                  break;
1210 
1211   case Bytecodes::_getfield:  do_getfield(str);                      break;
1212   case Bytecodes::_getstatic: do_getstatic(str);                     break;
1213 
1214   case Bytecodes::_goto:
1215   case Bytecodes::_goto_w:
1216   case Bytecodes::_nop:
1217   case Bytecodes::_return:
1218     {
1219       // do nothing.
1220       break;
1221     }
1222   case Bytecodes::_i2b:
1223   case Bytecodes::_i2c:
1224   case Bytecodes::_i2s:
1225   case Bytecodes::_ineg:
1226     {
1227       pop_int();
1228       push_int();
1229       break;
1230     }
1231   case Bytecodes::_i2d:
1232     {
1233       pop_int();
1234       push_double();
1235       break;
1236     }
1237   case Bytecodes::_i2f:
1238     {
1239       pop_int();
1240       push_float();
1241       break;
1242     }
1243   case Bytecodes::_i2l:
1244     {
1245       pop_int();
1246       push_long();
1247       break;
1248     }
1249   case Bytecodes::_iadd:
1250   case Bytecodes::_iand:
1251   case Bytecodes::_idiv:
1252   case Bytecodes::_imul:
1253   case Bytecodes::_ior:
1254   case Bytecodes::_irem:
1255   case Bytecodes::_ishl:
1256   case Bytecodes::_ishr:
1257   case Bytecodes::_isub:
1258   case Bytecodes::_iushr:
1259   case Bytecodes::_ixor:
1260     {
1261       pop_int();
1262       pop_int();
1263       push_int();
1264       break;
1265     }
1266   case Bytecodes::_if_acmpeq:
1267   case Bytecodes::_if_acmpne:
1268     {
1269       pop_object();
1270       pop_object();
1271       break;
1272     }
1273   case Bytecodes::_if_icmpeq:
1274   case Bytecodes::_if_icmpge:
1275   case Bytecodes::_if_icmpgt:
1276   case Bytecodes::_if_icmple:
1277   case Bytecodes::_if_icmplt:
1278   case Bytecodes::_if_icmpne:
1279     {
1280       pop_int();
1281       pop_int();
1282       break;
1283     }
1284   case Bytecodes::_ifeq:
1285   case Bytecodes::_ifle:
1286   case Bytecodes::_iflt:
1287   case Bytecodes::_ifge:
1288   case Bytecodes::_ifgt:
1289   case Bytecodes::_ifne:
1290   case Bytecodes::_ireturn:
1291   case Bytecodes::_lookupswitch:
1292   case Bytecodes::_tableswitch:
1293     {
1294       pop_int();
1295       break;
1296     }
1297   case Bytecodes::_iinc:
1298     {
1299       int lnum = str-&gt;get_index();
1300       check_int(local(lnum));
1301       store_to_local(lnum);
1302       break;
1303     }
1304   case Bytecodes::_iload:   load_local_int(str-&gt;get_index()); break;
1305   case Bytecodes::_iload_0: load_local_int(0);                      break;
1306   case Bytecodes::_iload_1: load_local_int(1);                      break;
1307   case Bytecodes::_iload_2: load_local_int(2);                      break;
1308   case Bytecodes::_iload_3: load_local_int(3);                      break;
1309 
1310   case Bytecodes::_instanceof:
1311     {
1312       // Check for uncommon trap:
1313       do_checkcast(str);
1314       pop_object();
1315       push_int();
1316       break;
1317     }
1318   case Bytecodes::_invokeinterface: do_invoke(str, true);           break;
1319   case Bytecodes::_invokespecial:   do_invoke(str, true);           break;
1320   case Bytecodes::_invokestatic:    do_invoke(str, false);          break;
1321   case Bytecodes::_invokevirtual:   do_invoke(str, true);           break;
1322   case Bytecodes::_invokedynamic:   do_invoke(str, false);          break;
1323 
1324   case Bytecodes::_istore:   store_local_int(str-&gt;get_index());     break;
1325   case Bytecodes::_istore_0: store_local_int(0);                    break;
1326   case Bytecodes::_istore_1: store_local_int(1);                    break;
1327   case Bytecodes::_istore_2: store_local_int(2);                    break;
1328   case Bytecodes::_istore_3: store_local_int(3);                    break;
1329 
1330   case Bytecodes::_jsr:
1331   case Bytecodes::_jsr_w: do_jsr(str);                              break;
1332 
1333   case Bytecodes::_l2d:
1334     {
1335       pop_long();
1336       push_double();
1337       break;
1338     }
1339   case Bytecodes::_l2f:
1340     {
1341       pop_long();
1342       push_float();
1343       break;
1344     }
1345   case Bytecodes::_l2i:
1346     {
1347       pop_long();
1348       push_int();
1349       break;
1350     }
1351   case Bytecodes::_ladd:
1352   case Bytecodes::_land:
1353   case Bytecodes::_ldiv:
1354   case Bytecodes::_lmul:
1355   case Bytecodes::_lor:
1356   case Bytecodes::_lrem:
1357   case Bytecodes::_lsub:
1358   case Bytecodes::_lxor:
1359     {
1360       pop_long();
1361       pop_long();
1362       push_long();
1363       break;
1364     }
1365   case Bytecodes::_laload:
1366     {
1367       pop_int();
1368       ciTypeArrayKlass* array_klass = pop_typeArray();
1369       // Put assert here for right type?
1370       push_long();
1371       break;
1372     }
1373   case Bytecodes::_lastore:
1374     {
1375       pop_long();
1376       pop_int();
1377       pop_typeArray();
1378       // assert here?
1379       break;
1380     }
1381   case Bytecodes::_lcmp:
1382     {
1383       pop_long();
1384       pop_long();
1385       push_int();
1386       break;
1387     }
1388   case Bytecodes::_lconst_0:
1389   case Bytecodes::_lconst_1:
1390     {
1391       push_long();
1392       break;
1393     }
1394   case Bytecodes::_ldc:
1395   case Bytecodes::_ldc_w:
1396   case Bytecodes::_ldc2_w:
1397     {
1398       do_ldc(str);
1399       break;
1400     }
1401 
1402   case Bytecodes::_lload:   load_local_long(str-&gt;get_index());      break;
1403   case Bytecodes::_lload_0: load_local_long(0);                     break;
1404   case Bytecodes::_lload_1: load_local_long(1);                     break;
1405   case Bytecodes::_lload_2: load_local_long(2);                     break;
1406   case Bytecodes::_lload_3: load_local_long(3);                     break;
1407 
1408   case Bytecodes::_lneg:
1409     {
1410       pop_long();
1411       push_long();
1412       break;
1413     }
1414   case Bytecodes::_lreturn:
1415     {
1416       pop_long();
1417       break;
1418     }
1419   case Bytecodes::_lshl:
1420   case Bytecodes::_lshr:
1421   case Bytecodes::_lushr:
1422     {
1423       pop_int();
1424       pop_long();
1425       push_long();
1426       break;
1427     }
1428   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1429   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1430   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1431   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1432   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1433 
1434   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1435 
1436   case Bytecodes::_new:      do_new(str);                           break;
1437 
1438   case Bytecodes::_newarray: do_newarray(str);                      break;
1439 
1440   case Bytecodes::_pop:
1441     {
1442       pop();
1443       break;
1444     }
1445   case Bytecodes::_pop2:
1446     {
1447       pop();
1448       pop();
1449       break;
1450     }
1451 
1452   case Bytecodes::_putfield:       do_putfield(str);                 break;
1453   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1454 
1455   case Bytecodes::_ret: do_ret(str);                                 break;
1456 
1457   case Bytecodes::_swap:
1458     {
1459       ciType* value1 = pop_value();
1460       ciType* value2 = pop_value();
1461       push(value1);
1462       push(value2);
1463       break;
1464     }
1465   case Bytecodes::_wide:
1466   default:
1467     {
1468       // The iterator should skip this.
1469       ShouldNotReachHere();
1470       break;
1471     }
1472   }
1473 
1474   if (CITraceTypeFlow) {
1475     print_on(tty);
1476   }
1477 
1478   return (_trap_bci != -1);
1479 }
1480 
1481 #ifndef PRODUCT
1482 // ------------------------------------------------------------------
1483 // ciTypeFlow::StateVector::print_cell_on
1484 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
1485   ciType* type = type_at(c);
1486   if (type == top_type()) {
1487     st-&gt;print(&quot;top&quot;);
1488   } else if (type == bottom_type()) {
1489     st-&gt;print(&quot;bottom&quot;);
1490   } else if (type == null_type()) {
1491     st-&gt;print(&quot;null&quot;);
1492   } else if (type == long2_type()) {
1493     st-&gt;print(&quot;long2&quot;);
1494   } else if (type == double2_type()) {
1495     st-&gt;print(&quot;double2&quot;);
1496   } else if (is_int(type)) {
1497     st-&gt;print(&quot;int&quot;);
1498   } else if (is_long(type)) {
1499     st-&gt;print(&quot;long&quot;);
1500   } else if (is_float(type)) {
1501     st-&gt;print(&quot;float&quot;);
1502   } else if (is_double(type)) {
1503     st-&gt;print(&quot;double&quot;);
1504   } else if (type-&gt;is_return_address()) {
1505     st-&gt;print(&quot;address(%d)&quot;, type-&gt;as_return_address()-&gt;bci());
1506   } else {
1507     if (type-&gt;is_klass()) {
1508       type-&gt;as_klass()-&gt;name()-&gt;print_symbol_on(st);
1509     } else {
1510       st-&gt;print(&quot;UNEXPECTED TYPE&quot;);
1511       type-&gt;print();
1512     }
1513   }
1514 }
1515 
1516 // ------------------------------------------------------------------
1517 // ciTypeFlow::StateVector::print_on
1518 void ciTypeFlow::StateVector::print_on(outputStream* st) const {
1519   int num_locals   = _outer-&gt;max_locals();
1520   int num_stack    = stack_size();
1521   int num_monitors = monitor_count();
1522   st-&gt;print_cr(&quot;  State : locals %d, stack %d, monitors %d&quot;, num_locals, num_stack, num_monitors);
1523   if (num_stack &gt;= 0) {
1524     int i;
1525     for (i = 0; i &lt; num_locals; i++) {
1526       st-&gt;print(&quot;    local %2d : &quot;, i);
1527       print_cell_on(st, local(i));
1528       st-&gt;cr();
1529     }
1530     for (i = 0; i &lt; num_stack; i++) {
1531       st-&gt;print(&quot;    stack %2d : &quot;, i);
1532       print_cell_on(st, stack(i));
1533       st-&gt;cr();
1534     }
1535   }
1536 }
1537 #endif
1538 
1539 
1540 // ------------------------------------------------------------------
1541 // ciTypeFlow::SuccIter::next
1542 //
1543 void ciTypeFlow::SuccIter::next() {
1544   int succ_ct = _pred-&gt;successors()-&gt;length();
1545   int next = _index + 1;
1546   if (next &lt; succ_ct) {
1547     _index = next;
1548     _succ = _pred-&gt;successors()-&gt;at(next);
1549     return;
1550   }
1551   for (int i = next - succ_ct; i &lt; _pred-&gt;exceptions()-&gt;length(); i++) {
1552     // Do not compile any code for unloaded exception types.
1553     // Following compiler passes are responsible for doing this also.
1554     ciInstanceKlass* exception_klass = _pred-&gt;exc_klasses()-&gt;at(i);
1555     if (exception_klass-&gt;is_loaded()) {
1556       _index = next;
1557       _succ = _pred-&gt;exceptions()-&gt;at(i);
1558       return;
1559     }
1560     next++;
1561   }
1562   _index = -1;
1563   _succ = NULL;
1564 }
1565 
1566 // ------------------------------------------------------------------
1567 // ciTypeFlow::SuccIter::set_succ
1568 //
1569 void ciTypeFlow::SuccIter::set_succ(Block* succ) {
1570   int succ_ct = _pred-&gt;successors()-&gt;length();
1571   if (_index &lt; succ_ct) {
1572     _pred-&gt;successors()-&gt;at_put(_index, succ);
1573   } else {
1574     int idx = _index - succ_ct;
1575     _pred-&gt;exceptions()-&gt;at_put(idx, succ);
1576   }
1577 }
1578 
1579 // ciTypeFlow::Block
1580 //
1581 // A basic block.
1582 
1583 // ------------------------------------------------------------------
1584 // ciTypeFlow::Block::Block
1585 ciTypeFlow::Block::Block(ciTypeFlow* outer,
1586                          ciBlock *ciblk,
1587                          ciTypeFlow::JsrSet* jsrs) {
1588   _ciblock = ciblk;
1589   _exceptions = NULL;
1590   _exc_klasses = NULL;
1591   _successors = NULL;
1592   _predecessors = new (outer-&gt;arena()) GrowableArray&lt;Block*&gt;(outer-&gt;arena(), 1, 0, NULL);
1593   _state = new (outer-&gt;arena()) StateVector(outer);
1594   JsrSet* new_jsrs =
1595     new (outer-&gt;arena()) JsrSet(outer-&gt;arena(), jsrs-&gt;size());
1596   jsrs-&gt;copy_into(new_jsrs);
1597   _jsrs = new_jsrs;
1598   _next = NULL;
1599   _on_work_list = false;
1600   _backedge_copy = false;
1601   _has_monitorenter = false;
1602   _trap_bci = -1;
1603   _trap_index = 0;
1604   df_init();
1605 
1606   if (CITraceTypeFlow) {
1607     tty-&gt;print_cr(&quot;&gt;&gt; Created new block&quot;);
1608     print_on(tty);
1609   }
1610 
1611   assert(this-&gt;outer() == outer, &quot;outer link set up&quot;);
1612   assert(!outer-&gt;have_block_count(), &quot;must not have mapped blocks yet&quot;);
1613 }
1614 
1615 // ------------------------------------------------------------------
1616 // ciTypeFlow::Block::df_init
1617 void ciTypeFlow::Block::df_init() {
1618   _pre_order = -1; assert(!has_pre_order(), &quot;&quot;);
1619   _post_order = -1; assert(!has_post_order(), &quot;&quot;);
1620   _loop = NULL;
1621   _irreducible_entry = false;
1622   _rpo_next = NULL;
1623 }
1624 
1625 // ------------------------------------------------------------------
1626 // ciTypeFlow::Block::successors
1627 //
1628 // Get the successors for this Block.
1629 GrowableArray&lt;ciTypeFlow::Block*&gt;*
1630 ciTypeFlow::Block::successors(ciBytecodeStream* str,
1631                               ciTypeFlow::StateVector* state,
1632                               ciTypeFlow::JsrSet* jsrs) {
1633   if (_successors == NULL) {
1634     if (CITraceTypeFlow) {
1635       tty-&gt;print(&quot;&gt;&gt; Computing successors for block &quot;);
1636       print_value_on(tty);
1637       tty-&gt;cr();
1638     }
1639 
1640     ciTypeFlow* analyzer = outer();
1641     Arena* arena = analyzer-&gt;arena();
1642     Block* block = NULL;
1643     bool has_successor = !has_trap() &amp;&amp;
1644                          (control() != ciBlock::fall_through_bci || limit() &lt; analyzer-&gt;code_size());
1645     if (!has_successor) {
1646       _successors =
1647         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1648       // No successors
1649     } else if (control() == ciBlock::fall_through_bci) {
1650       assert(str-&gt;cur_bci() == limit(), &quot;bad block end&quot;);
1651       // This block simply falls through to the next.
1652       _successors =
1653         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1654 
1655       Block* block = analyzer-&gt;block_at(limit(), _jsrs);
1656       assert(_successors-&gt;length() == FALL_THROUGH, &quot;&quot;);
1657       _successors-&gt;append(block);
1658     } else {
1659       int current_bci = str-&gt;cur_bci();
1660       int next_bci = str-&gt;next_bci();
1661       int branch_bci = -1;
1662       Block* target = NULL;
1663       assert(str-&gt;next_bci() == limit(), &quot;bad block end&quot;);
1664       // This block is not a simple fall-though.  Interpret
1665       // the current bytecode to find our successors.
1666       switch (str-&gt;cur_bc()) {
1667       case Bytecodes::_ifeq:         case Bytecodes::_ifne:
1668       case Bytecodes::_iflt:         case Bytecodes::_ifge:
1669       case Bytecodes::_ifgt:         case Bytecodes::_ifle:
1670       case Bytecodes::_if_icmpeq:    case Bytecodes::_if_icmpne:
1671       case Bytecodes::_if_icmplt:    case Bytecodes::_if_icmpge:
1672       case Bytecodes::_if_icmpgt:    case Bytecodes::_if_icmple:
1673       case Bytecodes::_if_acmpeq:    case Bytecodes::_if_acmpne:
1674       case Bytecodes::_ifnull:       case Bytecodes::_ifnonnull:
1675         // Our successors are the branch target and the next bci.
1676         branch_bci = str-&gt;get_dest();
1677         _successors =
1678           new (arena) GrowableArray&lt;Block*&gt;(arena, 2, 0, NULL);
1679         assert(_successors-&gt;length() == IF_NOT_TAKEN, &quot;&quot;);
1680         _successors-&gt;append(analyzer-&gt;block_at(next_bci, jsrs));
1681         assert(_successors-&gt;length() == IF_TAKEN, &quot;&quot;);
1682         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1683         break;
1684 
1685       case Bytecodes::_goto:
1686         branch_bci = str-&gt;get_dest();
1687         _successors =
1688           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1689         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1690         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1691         break;
1692 
1693       case Bytecodes::_jsr:
1694         branch_bci = str-&gt;get_dest();
1695         _successors =
1696           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1697         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1698         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1699         break;
1700 
1701       case Bytecodes::_goto_w:
1702       case Bytecodes::_jsr_w:
1703         _successors =
1704           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1705         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1706         _successors-&gt;append(analyzer-&gt;block_at(str-&gt;get_far_dest(), jsrs));
1707         break;
1708 
1709       case Bytecodes::_tableswitch:  {
1710         Bytecode_tableswitch tableswitch(str);
1711 
1712         int len = tableswitch.length();
1713         _successors =
1714           new (arena) GrowableArray&lt;Block*&gt;(arena, len+1, 0, NULL);
1715         int bci = current_bci + tableswitch.default_offset();
1716         Block* block = analyzer-&gt;block_at(bci, jsrs);
1717         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1718         _successors-&gt;append(block);
1719         while (--len &gt;= 0) {
1720           int bci = current_bci + tableswitch.dest_offset_at(len);
1721           block = analyzer-&gt;block_at(bci, jsrs);
1722           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1723           _successors-&gt;append_if_missing(block);
1724         }
1725         break;
1726       }
1727 
1728       case Bytecodes::_lookupswitch: {
1729         Bytecode_lookupswitch lookupswitch(str);
1730 
1731         int npairs = lookupswitch.number_of_pairs();
1732         _successors =
1733           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1734         int bci = current_bci + lookupswitch.default_offset();
1735         Block* block = analyzer-&gt;block_at(bci, jsrs);
1736         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1737         _successors-&gt;append(block);
1738         while(--npairs &gt;= 0) {
1739           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1740           int bci = current_bci + pair.offset();
1741           Block* block = analyzer-&gt;block_at(bci, jsrs);
1742           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1743           _successors-&gt;append_if_missing(block);
1744         }
1745         break;
1746       }
1747 
1748       case Bytecodes::_athrow:     case Bytecodes::_ireturn:
1749       case Bytecodes::_lreturn:    case Bytecodes::_freturn:
1750       case Bytecodes::_dreturn:    case Bytecodes::_areturn:
1751       case Bytecodes::_return:
1752         _successors =
1753           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1754         // No successors
1755         break;
1756 
1757       case Bytecodes::_ret: {
1758         _successors =
1759           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1760 
1761         Cell local = state-&gt;local(str-&gt;get_index());
1762         ciType* return_address = state-&gt;type_at(local);
1763         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1764         int bci = return_address-&gt;as_return_address()-&gt;bci();
1765         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1766         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1767         break;
1768       }
1769 
1770       case Bytecodes::_wide:
1771       default:
1772         ShouldNotReachHere();
1773         break;
1774       }
1775     }
1776 
1777     // Set predecessor information
1778     for (int i = 0; i &lt; _successors-&gt;length(); i++) {
1779       Block* block = _successors-&gt;at(i);
1780       block-&gt;predecessors()-&gt;append(this);
1781     }
1782   }
1783   return _successors;
1784 }
1785 
1786 // ------------------------------------------------------------------
1787 // ciTypeFlow::Block:compute_exceptions
1788 //
1789 // Compute the exceptional successors and types for this Block.
1790 void ciTypeFlow::Block::compute_exceptions() {
1791   assert(_exceptions == NULL &amp;&amp; _exc_klasses == NULL, &quot;repeat&quot;);
1792 
1793   if (CITraceTypeFlow) {
1794     tty-&gt;print(&quot;&gt;&gt; Computing exceptions for block &quot;);
1795     print_value_on(tty);
1796     tty-&gt;cr();
1797   }
1798 
1799   ciTypeFlow* analyzer = outer();
1800   Arena* arena = analyzer-&gt;arena();
1801 
1802   // Any bci in the block will do.
1803   ciExceptionHandlerStream str(analyzer-&gt;method(), start());
1804 
1805   // Allocate our growable arrays.
1806   int exc_count = str.count();
1807   _exceptions = new (arena) GrowableArray&lt;Block*&gt;(arena, exc_count, 0, NULL);
1808   _exc_klasses = new (arena) GrowableArray&lt;ciInstanceKlass*&gt;(arena, exc_count,
1809                                                              0, NULL);
1810 
1811   for ( ; !str.is_done(); str.next()) {
1812     ciExceptionHandler* handler = str.handler();
1813     int bci = handler-&gt;handler_bci();
1814     ciInstanceKlass* klass = NULL;
1815     if (bci == -1) {
1816       // There is no catch all.  It is possible to exit the method.
1817       break;
1818     }
1819     if (handler-&gt;is_catch_all()) {
1820       klass = analyzer-&gt;env()-&gt;Throwable_klass();
1821     } else {
1822       klass = handler-&gt;catch_klass();
1823     }
1824     Block* block = analyzer-&gt;block_at(bci, _jsrs);
1825     _exceptions-&gt;append(block);
1826     block-&gt;predecessors()-&gt;append(this);
1827     _exc_klasses-&gt;append(klass);
1828   }
1829 }
1830 
1831 // ------------------------------------------------------------------
1832 // ciTypeFlow::Block::set_backedge_copy
1833 // Use this only to make a pre-existing public block into a backedge copy.
1834 void ciTypeFlow::Block::set_backedge_copy(bool z) {
1835   assert(z || (z == is_backedge_copy()), &quot;cannot make a backedge copy public&quot;);
1836   _backedge_copy = z;
1837 }
1838 
1839 // ------------------------------------------------------------------
1840 // ciTypeFlow::Block::is_clonable_exit
1841 //
1842 // At most 2 normal successors, one of which continues looping,
1843 // and all exceptional successors must exit.
1844 bool ciTypeFlow::Block::is_clonable_exit(ciTypeFlow::Loop* lp) {
1845   int normal_cnt  = 0;
1846   int in_loop_cnt = 0;
1847   for (SuccIter iter(this); !iter.done(); iter.next()) {
1848     Block* succ = iter.succ();
1849     if (iter.is_normal_ctrl()) {
1850       if (++normal_cnt &gt; 2) return false;
1851       if (lp-&gt;contains(succ-&gt;loop())) {
1852         if (++in_loop_cnt &gt; 1) return false;
1853       }
1854     } else {
1855       if (lp-&gt;contains(succ-&gt;loop())) return false;
1856     }
1857   }
1858   return in_loop_cnt == 1;
1859 }
1860 
1861 // ------------------------------------------------------------------
1862 // ciTypeFlow::Block::looping_succ
1863 //
1864 ciTypeFlow::Block* ciTypeFlow::Block::looping_succ(ciTypeFlow::Loop* lp) {
1865   assert(successors()-&gt;length() &lt;= 2, &quot;at most 2 normal successors&quot;);
1866   for (SuccIter iter(this); !iter.done(); iter.next()) {
1867     Block* succ = iter.succ();
1868     if (lp-&gt;contains(succ-&gt;loop())) {
1869       return succ;
1870     }
1871   }
1872   return NULL;
1873 }
1874 
1875 #ifndef PRODUCT
1876 // ------------------------------------------------------------------
1877 // ciTypeFlow::Block::print_value_on
1878 void ciTypeFlow::Block::print_value_on(outputStream* st) const {
1879   if (has_pre_order()) st-&gt;print(&quot;#%-2d &quot;, pre_order());
1880   if (has_rpo())       st-&gt;print(&quot;rpo#%-2d &quot;, rpo());
1881   st-&gt;print(&quot;[%d - %d)&quot;, start(), limit());
1882   if (is_loop_head()) st-&gt;print(&quot; lphd&quot;);
1883   if (is_irreducible_entry()) st-&gt;print(&quot; irred&quot;);
1884   if (_jsrs-&gt;size() &gt; 0) { st-&gt;print(&quot;/&quot;);  _jsrs-&gt;print_on(st); }
1885   if (is_backedge_copy())  st-&gt;print(&quot;/backedge_copy&quot;);
1886 }
1887 
1888 // ------------------------------------------------------------------
1889 // ciTypeFlow::Block::print_on
1890 void ciTypeFlow::Block::print_on(outputStream* st) const {
1891   if ((Verbose || WizardMode) &amp;&amp; (limit() &gt;= 0)) {
1892     // Don&#39;t print &#39;dummy&#39; blocks (i.e. blocks with limit() &#39;-1&#39;)
1893     outer()-&gt;method()-&gt;print_codes_on(start(), limit(), st);
1894   }
1895   st-&gt;print_cr(&quot;  ====================================================  &quot;);
1896   st-&gt;print (&quot;  &quot;);
1897   print_value_on(st);
1898   st-&gt;print(&quot; Stored locals: &quot;); def_locals()-&gt;print_on(st, outer()-&gt;method()-&gt;max_locals()); tty-&gt;cr();
1899   if (loop() &amp;&amp; loop()-&gt;parent() != NULL) {
1900     st-&gt;print(&quot; loops:&quot;);
1901     Loop* lp = loop();
1902     do {
1903       st-&gt;print(&quot; %d&lt;-%d&quot;, lp-&gt;head()-&gt;pre_order(),lp-&gt;tail()-&gt;pre_order());
1904       if (lp-&gt;is_irreducible()) st-&gt;print(&quot;(ir)&quot;);
1905       lp = lp-&gt;parent();
1906     } while (lp-&gt;parent() != NULL);
1907   }
1908   st-&gt;cr();
1909   _state-&gt;print_on(st);
1910   if (_successors == NULL) {
1911     st-&gt;print_cr(&quot;  No successor information&quot;);
1912   } else {
1913     int num_successors = _successors-&gt;length();
1914     st-&gt;print_cr(&quot;  Successors : %d&quot;, num_successors);
1915     for (int i = 0; i &lt; num_successors; i++) {
1916       Block* successor = _successors-&gt;at(i);
1917       st-&gt;print(&quot;    &quot;);
1918       successor-&gt;print_value_on(st);
1919       st-&gt;cr();
1920     }
1921   }
1922   if (_predecessors == NULL) {
1923     st-&gt;print_cr(&quot;  No predecessor information&quot;);
1924   } else {
1925     int num_predecessors = _predecessors-&gt;length();
1926     st-&gt;print_cr(&quot;  Predecessors : %d&quot;, num_predecessors);
1927     for (int i = 0; i &lt; num_predecessors; i++) {
1928       Block* predecessor = _predecessors-&gt;at(i);
1929       st-&gt;print(&quot;    &quot;);
1930       predecessor-&gt;print_value_on(st);
1931       st-&gt;cr();
1932     }
1933   }
1934   if (_exceptions == NULL) {
1935     st-&gt;print_cr(&quot;  No exception information&quot;);
1936   } else {
1937     int num_exceptions = _exceptions-&gt;length();
1938     st-&gt;print_cr(&quot;  Exceptions : %d&quot;, num_exceptions);
1939     for (int i = 0; i &lt; num_exceptions; i++) {
1940       Block* exc_succ = _exceptions-&gt;at(i);
1941       ciInstanceKlass* exc_klass = _exc_klasses-&gt;at(i);
1942       st-&gt;print(&quot;    &quot;);
1943       exc_succ-&gt;print_value_on(st);
1944       st-&gt;print(&quot; -- &quot;);
1945       exc_klass-&gt;name()-&gt;print_symbol_on(st);
1946       st-&gt;cr();
1947     }
1948   }
1949   if (has_trap()) {
1950     st-&gt;print_cr(&quot;  Traps on %d with trap index %d&quot;, trap_bci(), trap_index());
1951   }
1952   st-&gt;print_cr(&quot;  ====================================================  &quot;);
1953 }
1954 #endif
1955 
1956 #ifndef PRODUCT
1957 // ------------------------------------------------------------------
1958 // ciTypeFlow::LocalSet::print_on
1959 void ciTypeFlow::LocalSet::print_on(outputStream* st, int limit) const {
1960   st-&gt;print(&quot;{&quot;);
1961   for (int i = 0; i &lt; max; i++) {
1962     if (test(i)) st-&gt;print(&quot; %d&quot;, i);
1963   }
1964   if (limit &gt; max) {
1965     st-&gt;print(&quot; %d..%d &quot;, max, limit);
1966   }
1967   st-&gt;print(&quot; }&quot;);
1968 }
1969 #endif
1970 
1971 // ciTypeFlow
1972 //
1973 // This is a pass over the bytecodes which computes the following:
1974 //   basic block structure
1975 //   interpreter type-states (a la the verifier)
1976 
1977 // ------------------------------------------------------------------
1978 // ciTypeFlow::ciTypeFlow
1979 ciTypeFlow::ciTypeFlow(ciEnv* env, ciMethod* method, int osr_bci) {
1980   _env = env;
1981   _method = method;
1982   _methodBlocks = method-&gt;get_method_blocks();
1983   _max_locals = method-&gt;max_locals();
1984   _max_stack = method-&gt;max_stack();
1985   _code_size = method-&gt;code_size();
1986   _has_irreducible_entry = false;
1987   _osr_bci = osr_bci;
1988   _failure_reason = NULL;
1989   assert(0 &lt;= start_bci() &amp;&amp; start_bci() &lt; code_size() , &quot;correct osr_bci argument: 0 &lt;= %d &lt; %d&quot;, start_bci(), code_size());
1990   _work_list = NULL;
1991 
1992   _ciblock_count = _methodBlocks-&gt;num_blocks();
1993   _idx_to_blocklist = NEW_ARENA_ARRAY(arena(), GrowableArray&lt;Block*&gt;*, _ciblock_count);
1994   for (int i = 0; i &lt; _ciblock_count; i++) {
1995     _idx_to_blocklist[i] = NULL;
1996   }
1997   _block_map = NULL;  // until all blocks are seen
1998   _jsr_count = 0;
1999   _jsr_records = NULL;
2000 }
2001 
2002 // ------------------------------------------------------------------
2003 // ciTypeFlow::work_list_next
2004 //
2005 // Get the next basic block from our work list.
2006 ciTypeFlow::Block* ciTypeFlow::work_list_next() {
2007   assert(!work_list_empty(), &quot;work list must not be empty&quot;);
2008   Block* next_block = _work_list;
2009   _work_list = next_block-&gt;next();
2010   next_block-&gt;set_next(NULL);
2011   next_block-&gt;set_on_work_list(false);
2012   return next_block;
2013 }
2014 
2015 // ------------------------------------------------------------------
2016 // ciTypeFlow::add_to_work_list
2017 //
2018 // Add a basic block to our work list.
2019 // List is sorted by decreasing postorder sort (same as increasing RPO)
2020 void ciTypeFlow::add_to_work_list(ciTypeFlow::Block* block) {
2021   assert(!block-&gt;is_on_work_list(), &quot;must not already be on work list&quot;);
2022 
2023   if (CITraceTypeFlow) {
2024     tty-&gt;print(&quot;&gt;&gt; Adding block &quot;);
2025     block-&gt;print_value_on(tty);
2026     tty-&gt;print_cr(&quot; to the work list : &quot;);
2027   }
2028 
2029   block-&gt;set_on_work_list(true);
2030 
2031   // decreasing post order sort
2032 
2033   Block* prev = NULL;
2034   Block* current = _work_list;
2035   int po = block-&gt;post_order();
2036   while (current != NULL) {
2037     if (!current-&gt;has_post_order() || po &gt; current-&gt;post_order())
2038       break;
2039     prev = current;
2040     current = current-&gt;next();
2041   }
2042   if (prev == NULL) {
2043     block-&gt;set_next(_work_list);
2044     _work_list = block;
2045   } else {
2046     block-&gt;set_next(current);
2047     prev-&gt;set_next(block);
2048   }
2049 
2050   if (CITraceTypeFlow) {
2051     tty-&gt;cr();
2052   }
2053 }
2054 
2055 // ------------------------------------------------------------------
2056 // ciTypeFlow::block_at
2057 //
2058 // Return the block beginning at bci which has a JsrSet compatible
2059 // with jsrs.
2060 ciTypeFlow::Block* ciTypeFlow::block_at(int bci, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2061   // First find the right ciBlock.
2062   if (CITraceTypeFlow) {
2063     tty-&gt;print(&quot;&gt;&gt; Requesting block for %d/&quot;, bci);
2064     jsrs-&gt;print_on(tty);
2065     tty-&gt;cr();
2066   }
2067 
2068   ciBlock* ciblk = _methodBlocks-&gt;block_containing(bci);
2069   assert(ciblk-&gt;start_bci() == bci, &quot;bad ciBlock boundaries&quot;);
2070   Block* block = get_block_for(ciblk-&gt;index(), jsrs, option);
2071 
2072   assert(block == NULL? (option == no_create): block-&gt;is_backedge_copy() == (option == create_backedge_copy), &quot;create option consistent with result&quot;);
2073 
2074   if (CITraceTypeFlow) {
2075     if (block != NULL) {
2076       tty-&gt;print(&quot;&gt;&gt; Found block &quot;);
2077       block-&gt;print_value_on(tty);
2078       tty-&gt;cr();
2079     } else {
2080       tty-&gt;print_cr(&quot;&gt;&gt; No such block.&quot;);
2081     }
2082   }
2083 
2084   return block;
2085 }
2086 
2087 // ------------------------------------------------------------------
2088 // ciTypeFlow::make_jsr_record
2089 //
2090 // Make a JsrRecord for a given (entry, return) pair, if such a record
2091 // does not already exist.
2092 ciTypeFlow::JsrRecord* ciTypeFlow::make_jsr_record(int entry_address,
2093                                                    int return_address) {
2094   if (_jsr_records == NULL) {
2095     _jsr_records = new (arena()) GrowableArray&lt;JsrRecord*&gt;(arena(),
2096                                                            _jsr_count,
2097                                                            0,
2098                                                            NULL);
2099   }
2100   JsrRecord* record = NULL;
2101   int len = _jsr_records-&gt;length();
2102   for (int i = 0; i &lt; len; i++) {
2103     JsrRecord* record = _jsr_records-&gt;at(i);
2104     if (record-&gt;entry_address() == entry_address &amp;&amp;
2105         record-&gt;return_address() == return_address) {
2106       return record;
2107     }
2108   }
2109 
2110   record = new (arena()) JsrRecord(entry_address, return_address);
2111   _jsr_records-&gt;append(record);
2112   return record;
2113 }
2114 
2115 // ------------------------------------------------------------------
2116 // ciTypeFlow::flow_exceptions
2117 //
2118 // Merge the current state into all exceptional successors at the
2119 // current point in the code.
2120 void ciTypeFlow::flow_exceptions(GrowableArray&lt;ciTypeFlow::Block*&gt;* exceptions,
2121                                  GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses,
2122                                  ciTypeFlow::StateVector* state) {
2123   int len = exceptions-&gt;length();
2124   assert(exc_klasses-&gt;length() == len, &quot;must have same length&quot;);
2125   for (int i = 0; i &lt; len; i++) {
2126     Block* block = exceptions-&gt;at(i);
2127     ciInstanceKlass* exception_klass = exc_klasses-&gt;at(i);
2128 
2129     if (!exception_klass-&gt;is_loaded()) {
2130       // Do not compile any code for unloaded exception types.
2131       // Following compiler passes are responsible for doing this also.
2132       continue;
2133     }
2134 
2135     if (block-&gt;meet_exception(exception_klass, state)) {
2136       // Block was modified and has PO.  Add it to the work list.
2137       if (block-&gt;has_post_order() &amp;&amp;
2138           !block-&gt;is_on_work_list()) {
2139         add_to_work_list(block);
2140       }
2141     }
2142   }
2143 }
2144 
2145 // ------------------------------------------------------------------
2146 // ciTypeFlow::flow_successors
2147 //
2148 // Merge the current state into all successors at the current point
2149 // in the code.
2150 void ciTypeFlow::flow_successors(GrowableArray&lt;ciTypeFlow::Block*&gt;* successors,
2151                                  ciTypeFlow::StateVector* state) {
2152   int len = successors-&gt;length();
2153   for (int i = 0; i &lt; len; i++) {
2154     Block* block = successors-&gt;at(i);
2155     if (block-&gt;meet(state)) {
2156       // Block was modified and has PO.  Add it to the work list.
2157       if (block-&gt;has_post_order() &amp;&amp;
2158           !block-&gt;is_on_work_list()) {
2159         add_to_work_list(block);
2160       }
2161     }
2162   }
2163 }
2164 
2165 // ------------------------------------------------------------------
2166 // ciTypeFlow::can_trap
2167 //
2168 // Tells if a given instruction is able to generate an exception edge.
2169 bool ciTypeFlow::can_trap(ciBytecodeStream&amp; str) {
2170   // Cf. GenerateOopMap::do_exception_edge.
2171   if (!Bytecodes::can_trap(str.cur_bc()))  return false;
2172 
2173   switch (str.cur_bc()) {
2174     // %%% FIXME: ldc of Class can generate an exception
2175     case Bytecodes::_ldc:
2176     case Bytecodes::_ldc_w:
2177     case Bytecodes::_ldc2_w:
2178     case Bytecodes::_aload_0:
2179       // These bytecodes can trap for rewriting.  We need to assume that
2180       // they do not throw exceptions to make the monitor analysis work.
2181       return false;
2182 
2183     case Bytecodes::_ireturn:
2184     case Bytecodes::_lreturn:
2185     case Bytecodes::_freturn:
2186     case Bytecodes::_dreturn:
2187     case Bytecodes::_areturn:
2188     case Bytecodes::_return:
2189       // We can assume the monitor stack is empty in this analysis.
2190       return false;
2191 
2192     case Bytecodes::_monitorexit:
2193       // We can assume monitors are matched in this analysis.
2194       return false;
2195 
2196     default:
2197       return true;
2198   }
2199 }
2200 
2201 // ------------------------------------------------------------------
2202 // ciTypeFlow::clone_loop_heads
2203 //
2204 // Clone the loop heads
2205 bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2206   bool rslt = false;
2207   for (PreorderLoops iter(loop_tree_root()); !iter.done(); iter.next()) {
2208     lp = iter.current();
2209     Block* head = lp-&gt;head();
2210     if (lp == loop_tree_root() ||
2211         lp-&gt;is_irreducible() ||
2212         !head-&gt;is_clonable_exit(lp))
2213       continue;
2214 
2215     // Avoid BoxLock merge.
2216     if (EliminateNestedLocks &amp;&amp; head-&gt;has_monitorenter())
2217       continue;
2218 
2219     // check not already cloned
2220     if (head-&gt;backedge_copy_count() != 0)
2221       continue;
2222 
2223     // Don&#39;t clone head of OSR loop to get correct types in start block.
2224     if (is_osr_flow() &amp;&amp; head-&gt;start() == start_bci())
2225       continue;
2226 
2227     // check _no_ shared head below us
2228     Loop* ch;
2229     for (ch = lp-&gt;child(); ch != NULL &amp;&amp; ch-&gt;head() != head; ch = ch-&gt;sibling());
2230     if (ch != NULL)
2231       continue;
2232 
2233     // Clone head
2234     Block* new_head = head-&gt;looping_succ(lp);
2235     Block* clone = clone_loop_head(lp, temp_vector, temp_set);
2236     // Update lp&#39;s info
2237     clone-&gt;set_loop(lp);
2238     lp-&gt;set_head(new_head);
2239     lp-&gt;set_tail(clone);
2240     // And move original head into outer loop
2241     head-&gt;set_loop(lp-&gt;parent());
2242 
2243     rslt = true;
2244   }
2245   return rslt;
2246 }
2247 
2248 // ------------------------------------------------------------------
2249 // ciTypeFlow::clone_loop_head
2250 //
2251 // Clone lp&#39;s head and replace tail&#39;s successors with clone.
2252 //
2253 //  |
2254 //  v
2255 // head &lt;-&gt; body
2256 //  |
2257 //  v
2258 // exit
2259 //
2260 // new_head
2261 //
2262 //  |
2263 //  v
2264 // head ----------\
2265 //  |             |
2266 //  |             v
2267 //  |  clone &lt;-&gt; body
2268 //  |    |
2269 //  | /--/
2270 //  | |
2271 //  v v
2272 // exit
2273 //
2274 ciTypeFlow::Block* ciTypeFlow::clone_loop_head(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2275   Block* head = lp-&gt;head();
2276   Block* tail = lp-&gt;tail();
2277   if (CITraceTypeFlow) {
2278     tty-&gt;print(&quot;&gt;&gt; Requesting clone of loop head &quot;); head-&gt;print_value_on(tty);
2279     tty-&gt;print(&quot;  for predecessor &quot;);                tail-&gt;print_value_on(tty);
2280     tty-&gt;cr();
2281   }
2282   Block* clone = block_at(head-&gt;start(), head-&gt;jsrs(), create_backedge_copy);
2283   assert(clone-&gt;backedge_copy_count() == 1, &quot;one backedge copy for all back edges&quot;);
2284 
2285   assert(!clone-&gt;has_pre_order(), &quot;just created&quot;);
2286   clone-&gt;set_next_pre_order();
2287 
2288   // Insert clone after (orig) tail in reverse post order
2289   clone-&gt;set_rpo_next(tail-&gt;rpo_next());
2290   tail-&gt;set_rpo_next(clone);
2291 
2292   // tail-&gt;head becomes tail-&gt;clone
2293   for (SuccIter iter(tail); !iter.done(); iter.next()) {
2294     if (iter.succ() == head) {
2295       iter.set_succ(clone);
2296       // Update predecessor information
2297       head-&gt;predecessors()-&gt;remove(tail);
2298       clone-&gt;predecessors()-&gt;append(tail);
2299     }
2300   }
2301   flow_block(tail, temp_vector, temp_set);
2302   if (head == tail) {
2303     // For self-loops, clone-&gt;head becomes clone-&gt;clone
2304     flow_block(clone, temp_vector, temp_set);
2305     for (SuccIter iter(clone); !iter.done(); iter.next()) {
2306       if (iter.succ() == head) {
2307         iter.set_succ(clone);
2308         // Update predecessor information
2309         head-&gt;predecessors()-&gt;remove(clone);
2310         clone-&gt;predecessors()-&gt;append(clone);
2311         break;
2312       }
2313     }
2314   }
2315   flow_block(clone, temp_vector, temp_set);
2316 
2317   return clone;
2318 }
2319 
2320 // ------------------------------------------------------------------
2321 // ciTypeFlow::flow_block
2322 //
2323 // Interpret the effects of the bytecodes on the incoming state
2324 // vector of a basic block.  Push the changed state to succeeding
2325 // basic blocks.
2326 void ciTypeFlow::flow_block(ciTypeFlow::Block* block,
2327                             ciTypeFlow::StateVector* state,
2328                             ciTypeFlow::JsrSet* jsrs) {
2329   if (CITraceTypeFlow) {
2330     tty-&gt;print(&quot;\n&gt;&gt; ANALYZING BLOCK : &quot;);
2331     tty-&gt;cr();
2332     block-&gt;print_on(tty);
2333   }
2334   assert(block-&gt;has_pre_order(), &quot;pre-order is assigned before 1st flow&quot;);
2335 
2336   int start = block-&gt;start();
2337   int limit = block-&gt;limit();
2338   int control = block-&gt;control();
2339   if (control != ciBlock::fall_through_bci) {
2340     limit = control;
2341   }
2342 
2343   // Grab the state from the current block.
2344   block-&gt;copy_state_into(state);
2345   state-&gt;def_locals()-&gt;clear();
2346 
2347   GrowableArray&lt;Block*&gt;*           exceptions = block-&gt;exceptions();
2348   GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses = block-&gt;exc_klasses();
2349   bool has_exceptions = exceptions-&gt;length() &gt; 0;
2350 
2351   bool exceptions_used = false;
2352 
2353   ciBytecodeStream str(method());
2354   str.reset_to_bci(start);
2355   Bytecodes::Code code;
2356   while ((code = str.next()) != ciBytecodeStream::EOBC() &amp;&amp;
2357          str.cur_bci() &lt; limit) {
2358     // Check for exceptional control flow from this point.
2359     if (has_exceptions &amp;&amp; can_trap(str)) {
2360       flow_exceptions(exceptions, exc_klasses, state);
2361       exceptions_used = true;
2362     }
2363     // Apply the effects of the current bytecode to our state.
2364     bool res = state-&gt;apply_one_bytecode(&amp;str);
2365 
2366     // Watch for bailouts.
2367     if (failing())  return;
2368 
2369     if (str.cur_bc() == Bytecodes::_monitorenter) {
2370       block-&gt;set_has_monitorenter();
2371     }
2372 
2373     if (res) {
2374 
2375       // We have encountered a trap.  Record it in this block.
2376       block-&gt;set_trap(state-&gt;trap_bci(), state-&gt;trap_index());
2377 
2378       if (CITraceTypeFlow) {
2379         tty-&gt;print_cr(&quot;&gt;&gt; Found trap&quot;);
2380         block-&gt;print_on(tty);
2381       }
2382 
2383       // Save set of locals defined in this block
2384       block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2385 
2386       // Record (no) successors.
2387       block-&gt;successors(&amp;str, state, jsrs);
2388 
2389       assert(!has_exceptions || exceptions_used, &quot;Not removing exceptions&quot;);
2390 
2391       // Discontinue interpretation of this Block.
2392       return;
2393     }
2394   }
2395 
2396   GrowableArray&lt;Block*&gt;* successors = NULL;
2397   if (control != ciBlock::fall_through_bci) {
2398     // Check for exceptional control flow from this point.
2399     if (has_exceptions &amp;&amp; can_trap(str)) {
2400       flow_exceptions(exceptions, exc_klasses, state);
2401       exceptions_used = true;
2402     }
2403 
2404     // Fix the JsrSet to reflect effect of the bytecode.
2405     block-&gt;copy_jsrs_into(jsrs);
2406     jsrs-&gt;apply_control(this, &amp;str, state);
2407 
2408     // Find successor edges based on old state and new JsrSet.
2409     successors = block-&gt;successors(&amp;str, state, jsrs);
2410 
2411     // Apply the control changes to the state.
2412     state-&gt;apply_one_bytecode(&amp;str);
2413   } else {
2414     // Fall through control
2415     successors = block-&gt;successors(&amp;str, NULL, NULL);
2416   }
2417 
2418   // Save set of locals defined in this block
2419   block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2420 
2421   // Remove untaken exception paths
2422   if (!exceptions_used)
2423     exceptions-&gt;clear();
2424 
2425   // Pass our state to successors.
2426   flow_successors(successors, state);
2427 }
2428 
2429 // ------------------------------------------------------------------
2430 // ciTypeFlow::PreOrderLoops::next
2431 //
2432 // Advance to next loop tree using a preorder, left-to-right traversal.
2433 void ciTypeFlow::PreorderLoops::next() {
2434   assert(!done(), &quot;must not be done.&quot;);
2435   if (_current-&gt;child() != NULL) {
2436     _current = _current-&gt;child();
2437   } else if (_current-&gt;sibling() != NULL) {
2438     _current = _current-&gt;sibling();
2439   } else {
2440     while (_current != _root &amp;&amp; _current-&gt;sibling() == NULL) {
2441       _current = _current-&gt;parent();
2442     }
2443     if (_current == _root) {
2444       _current = NULL;
2445       assert(done(), &quot;must be done.&quot;);
2446     } else {
2447       assert(_current-&gt;sibling() != NULL, &quot;must be more to do&quot;);
2448       _current = _current-&gt;sibling();
2449     }
2450   }
2451 }
2452 
2453 // ------------------------------------------------------------------
2454 // ciTypeFlow::Loop::sorted_merge
2455 //
2456 // Merge the branch lp into this branch, sorting on the loop head
2457 // pre_orders. Returns the leaf of the merged branch.
2458 // Child and sibling pointers will be setup later.
2459 // Sort is (looking from leaf towards the root)
2460 //  descending on primary key: loop head&#39;s pre_order, and
2461 //  ascending  on secondary key: loop tail&#39;s pre_order.
2462 ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {
2463   Loop* leaf = this;
2464   Loop* prev = NULL;
2465   Loop* current = leaf;
2466   while (lp != NULL) {
2467     int lp_pre_order = lp-&gt;head()-&gt;pre_order();
2468     // Find insertion point for &quot;lp&quot;
2469     while (current != NULL) {
2470       if (current == lp)
2471         return leaf; // Already in list
2472       if (current-&gt;head()-&gt;pre_order() &lt; lp_pre_order)
2473         break;
2474       if (current-&gt;head()-&gt;pre_order() == lp_pre_order &amp;&amp;
2475           current-&gt;tail()-&gt;pre_order() &gt; lp-&gt;tail()-&gt;pre_order()) {
2476         break;
2477       }
2478       prev = current;
2479       current = current-&gt;parent();
2480     }
2481     Loop* next_lp = lp-&gt;parent(); // Save future list of items to insert
2482     // Insert lp before current
2483     lp-&gt;set_parent(current);
2484     if (prev != NULL) {
2485       prev-&gt;set_parent(lp);
2486     } else {
2487       leaf = lp;
2488     }
2489     prev = lp;     // Inserted item is new prev[ious]
2490     lp = next_lp;  // Next item to insert
2491   }
2492   return leaf;
2493 }
2494 
2495 // ------------------------------------------------------------------
2496 // ciTypeFlow::build_loop_tree
2497 //
2498 // Incrementally build loop tree.
2499 void ciTypeFlow::build_loop_tree(Block* blk) {
2500   assert(!blk-&gt;is_post_visited(), &quot;precondition&quot;);
2501   Loop* innermost = NULL; // merge of loop tree branches over all successors
2502 
2503   for (SuccIter iter(blk); !iter.done(); iter.next()) {
2504     Loop*  lp   = NULL;
2505     Block* succ = iter.succ();
2506     if (!succ-&gt;is_post_visited()) {
2507       // Found backedge since predecessor post visited, but successor is not
2508       assert(succ-&gt;pre_order() &lt;= blk-&gt;pre_order(), &quot;should be backedge&quot;);
2509 
2510       // Create a LoopNode to mark this loop.
2511       lp = new (arena()) Loop(succ, blk);
2512       if (succ-&gt;loop() == NULL)
2513         succ-&gt;set_loop(lp);
2514       // succ-&gt;loop will be updated to innermost loop on a later call, when blk==succ
2515 
2516     } else {  // Nested loop
2517       lp = succ-&gt;loop();
2518 
2519       // If succ is loop head, find outer loop.
2520       while (lp != NULL &amp;&amp; lp-&gt;head() == succ) {
2521         lp = lp-&gt;parent();
2522       }
2523       if (lp == NULL) {
2524         // Infinite loop, it&#39;s parent is the root
2525         lp = loop_tree_root();
2526       }
2527     }
2528 
2529     // Check for irreducible loop.
2530     // Successor has already been visited. If the successor&#39;s loop head
2531     // has already been post-visited, then this is another entry into the loop.
2532     while (lp-&gt;head()-&gt;is_post_visited() &amp;&amp; lp != loop_tree_root()) {
2533       _has_irreducible_entry = true;
2534       lp-&gt;set_irreducible(succ);
2535       if (!succ-&gt;is_on_work_list()) {
2536         // Assume irreducible entries need more data flow
2537         add_to_work_list(succ);
2538       }
2539       Loop* plp = lp-&gt;parent();
2540       if (plp == NULL) {
2541         // This only happens for some irreducible cases.  The parent
2542         // will be updated during a later pass.
2543         break;
2544       }
2545       lp = plp;
2546     }
2547 
2548     // Merge loop tree branch for all successors.
2549     innermost = innermost == NULL ? lp : innermost-&gt;sorted_merge(lp);
2550 
2551   } // end loop
2552 
2553   if (innermost == NULL) {
2554     assert(blk-&gt;successors()-&gt;length() == 0, &quot;CFG exit&quot;);
2555     blk-&gt;set_loop(loop_tree_root());
2556   } else if (innermost-&gt;head() == blk) {
2557     // If loop header, complete the tree pointers
2558     if (blk-&gt;loop() != innermost) {
2559 #ifdef ASSERT
2560       assert(blk-&gt;loop()-&gt;head() == innermost-&gt;head(), &quot;same head&quot;);
2561       Loop* dl;
2562       for (dl = innermost; dl != NULL &amp;&amp; dl != blk-&gt;loop(); dl = dl-&gt;parent());
2563       assert(dl == blk-&gt;loop(), &quot;blk-&gt;loop() already in innermost list&quot;);
2564 #endif
2565       blk-&gt;set_loop(innermost);
2566     }
2567     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2568     Loop* l = innermost;
2569     Loop* p = l-&gt;parent();
2570     while (p &amp;&amp; l-&gt;head() == blk) {
2571       l-&gt;set_sibling(p-&gt;child());  // Put self on parents &#39;next child&#39;
2572       p-&gt;set_child(l);             // Make self the first child of parent
2573       p-&gt;def_locals()-&gt;add(l-&gt;def_locals());
2574       l = p;                       // Walk up the parent chain
2575       p = l-&gt;parent();
2576     }
2577   } else {
2578     blk-&gt;set_loop(innermost);
2579     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2580   }
2581 }
2582 
2583 // ------------------------------------------------------------------
2584 // ciTypeFlow::Loop::contains
2585 //
2586 // Returns true if lp is nested loop.
2587 bool ciTypeFlow::Loop::contains(ciTypeFlow::Loop* lp) const {
2588   assert(lp != NULL, &quot;&quot;);
2589   if (this == lp || head() == lp-&gt;head()) return true;
2590   int depth1 = depth();
2591   int depth2 = lp-&gt;depth();
2592   if (depth1 &gt; depth2)
2593     return false;
2594   while (depth1 &lt; depth2) {
2595     depth2--;
2596     lp = lp-&gt;parent();
2597   }
2598   return this == lp;
2599 }
2600 
2601 // ------------------------------------------------------------------
2602 // ciTypeFlow::Loop::depth
2603 //
2604 // Loop depth
2605 int ciTypeFlow::Loop::depth() const {
2606   int dp = 0;
2607   for (Loop* lp = this-&gt;parent(); lp != NULL; lp = lp-&gt;parent())
2608     dp++;
2609   return dp;
2610 }
2611 
2612 #ifndef PRODUCT
2613 // ------------------------------------------------------------------
2614 // ciTypeFlow::Loop::print
2615 void ciTypeFlow::Loop::print(outputStream* st, int indent) const {
2616   for (int i = 0; i &lt; indent; i++) st-&gt;print(&quot; &quot;);
2617   st-&gt;print(&quot;%d&lt;-%d %s&quot;,
2618             is_root() ? 0 : this-&gt;head()-&gt;pre_order(),
2619             is_root() ? 0 : this-&gt;tail()-&gt;pre_order(),
2620             is_irreducible()?&quot; irr&quot;:&quot;&quot;);
2621   st-&gt;print(&quot; defs: &quot;);
2622   def_locals()-&gt;print_on(st, _head-&gt;outer()-&gt;method()-&gt;max_locals());
2623   st-&gt;cr();
2624   for (Loop* ch = child(); ch != NULL; ch = ch-&gt;sibling())
2625     ch-&gt;print(st, indent+2);
2626 }
2627 #endif
2628 
2629 // ------------------------------------------------------------------
2630 // ciTypeFlow::df_flow_types
2631 //
2632 // Perform the depth first type flow analysis. Helper for flow_types.
2633 void ciTypeFlow::df_flow_types(Block* start,
2634                                bool do_flow,
2635                                StateVector* temp_vector,
2636                                JsrSet* temp_set) {
2637   int dft_len = 100;
2638   GrowableArray&lt;Block*&gt; stk(dft_len);
2639 
2640   ciBlock* dummy = _methodBlocks-&gt;make_dummy_block();
2641   JsrSet* root_set = new JsrSet(NULL, 0);
2642   Block* root_head = new (arena()) Block(this, dummy, root_set);
2643   Block* root_tail = new (arena()) Block(this, dummy, root_set);
2644   root_head-&gt;set_pre_order(0);
2645   root_head-&gt;set_post_order(0);
2646   root_tail-&gt;set_pre_order(max_jint);
2647   root_tail-&gt;set_post_order(max_jint);
2648   set_loop_tree_root(new (arena()) Loop(root_head, root_tail));
2649 
2650   stk.push(start);
2651 
2652   _next_pre_order = 0;  // initialize pre_order counter
2653   _rpo_list = NULL;
2654   int next_po = 0;      // initialize post_order counter
2655 
2656   // Compute RPO and the control flow graph
2657   int size;
2658   while ((size = stk.length()) &gt; 0) {
2659     Block* blk = stk.top(); // Leave node on stack
2660     if (!blk-&gt;is_visited()) {
2661       // forward arc in graph
2662       assert (!blk-&gt;has_pre_order(), &quot;&quot;);
2663       blk-&gt;set_next_pre_order();
2664 
2665       if (_next_pre_order &gt;= (int)Compile::current()-&gt;max_node_limit() / 2) {
2666         // Too many basic blocks.  Bail out.
2667         // This can happen when try/finally constructs are nested to depth N,
2668         // and there is O(2**N) cloning of jsr bodies.  See bug 4697245!
2669         // &quot;MaxNodeLimit / 2&quot; is used because probably the parser will
2670         // generate at least twice that many nodes and bail out.
2671         record_failure(&quot;too many basic blocks&quot;);
2672         return;
2673       }
2674       if (do_flow) {
2675         flow_block(blk, temp_vector, temp_set);
2676         if (failing()) return; // Watch for bailouts.
2677       }
2678     } else if (!blk-&gt;is_post_visited()) {
2679       // cross or back arc
2680       for (SuccIter iter(blk); !iter.done(); iter.next()) {
2681         Block* succ = iter.succ();
2682         if (!succ-&gt;is_visited()) {
2683           stk.push(succ);
2684         }
2685       }
2686       if (stk.length() == size) {
2687         // There were no additional children, post visit node now
2688         stk.pop(); // Remove node from stack
2689 
2690         build_loop_tree(blk);
2691         blk-&gt;set_post_order(next_po++);   // Assign post order
2692         prepend_to_rpo_list(blk);
2693         assert(blk-&gt;is_post_visited(), &quot;&quot;);
2694 
2695         if (blk-&gt;is_loop_head() &amp;&amp; !blk-&gt;is_on_work_list()) {
2696           // Assume loop heads need more data flow
2697           add_to_work_list(blk);
2698         }
2699       }
2700     } else {
2701       stk.pop(); // Remove post-visited node from stack
2702     }
2703   }
2704 }
2705 
2706 // ------------------------------------------------------------------
2707 // ciTypeFlow::flow_types
2708 //
2709 // Perform the type flow analysis, creating and cloning Blocks as
2710 // necessary.
2711 void ciTypeFlow::flow_types() {
2712   ResourceMark rm;
2713   StateVector* temp_vector = new StateVector(this);
2714   JsrSet* temp_set = new JsrSet(NULL, 16);
2715 
2716   // Create the method entry block.
2717   Block* start = block_at(start_bci(), temp_set);
2718 
2719   // Load the initial state into it.
2720   const StateVector* start_state = get_start_state();
2721   if (failing())  return;
2722   start-&gt;meet(start_state);
2723 
2724   // Depth first visit
2725   df_flow_types(start, true /*do flow*/, temp_vector, temp_set);
2726 
2727   if (failing())  return;
2728   assert(_rpo_list == start, &quot;must be start&quot;);
2729 
2730   // Any loops found?
2731   if (loop_tree_root()-&gt;child() != NULL &amp;&amp;
2732       env()-&gt;comp_level() &gt;= CompLevel_full_optimization) {
2733       // Loop optimizations are not performed on Tier1 compiles.
2734 
2735     bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);
2736 
2737     // If some loop heads were cloned, recompute postorder and loop tree
2738     if (changed) {
2739       loop_tree_root()-&gt;set_child(NULL);
2740       for (Block* blk = _rpo_list; blk != NULL;) {
2741         Block* next = blk-&gt;rpo_next();
2742         blk-&gt;df_init();
2743         blk = next;
2744       }
2745       df_flow_types(start, false /*no flow*/, temp_vector, temp_set);
2746     }
2747   }
2748 
2749   if (CITraceTypeFlow) {
2750     tty-&gt;print_cr(&quot;\nLoop tree&quot;);
2751     loop_tree_root()-&gt;print();
2752   }
2753 
2754   // Continue flow analysis until fixed point reached
2755 
2756   debug_only(int max_block = _next_pre_order;)
2757 
2758   while (!work_list_empty()) {
2759     Block* blk = work_list_next();
2760     assert (blk-&gt;has_post_order(), &quot;post order assigned above&quot;);
2761 
2762     flow_block(blk, temp_vector, temp_set);
2763 
2764     assert (max_block == _next_pre_order, &quot;no new blocks&quot;);
2765     assert (!failing(), &quot;no more bailouts&quot;);
2766   }
2767 }
2768 
2769 // ------------------------------------------------------------------
2770 // ciTypeFlow::map_blocks
2771 //
2772 // Create the block map, which indexes blocks in reverse post-order.
2773 void ciTypeFlow::map_blocks() {
2774   assert(_block_map == NULL, &quot;single initialization&quot;);
2775   int block_ct = _next_pre_order;
2776   _block_map = NEW_ARENA_ARRAY(arena(), Block*, block_ct);
2777   assert(block_ct == block_count(), &quot;&quot;);
2778 
2779   Block* blk = _rpo_list;
2780   for (int m = 0; m &lt; block_ct; m++) {
2781     int rpo = blk-&gt;rpo();
2782     assert(rpo == m, &quot;should be sequential&quot;);
2783     _block_map[rpo] = blk;
2784     blk = blk-&gt;rpo_next();
2785   }
2786   assert(blk == NULL, &quot;should be done&quot;);
2787 
2788   for (int j = 0; j &lt; block_ct; j++) {
2789     assert(_block_map[j] != NULL, &quot;must not drop any blocks&quot;);
2790     Block* block = _block_map[j];
2791     // Remove dead blocks from successor lists:
2792     for (int e = 0; e &lt;= 1; e++) {
2793       GrowableArray&lt;Block*&gt;* l = e? block-&gt;exceptions(): block-&gt;successors();
2794       for (int k = 0; k &lt; l-&gt;length(); k++) {
2795         Block* s = l-&gt;at(k);
2796         if (!s-&gt;has_post_order()) {
2797           if (CITraceTypeFlow) {
2798             tty-&gt;print(&quot;Removing dead %s successor of #%d: &quot;, (e? &quot;exceptional&quot;:  &quot;normal&quot;), block-&gt;pre_order());
2799             s-&gt;print_value_on(tty);
2800             tty-&gt;cr();
2801           }
2802           l-&gt;remove(s);
2803           --k;
2804         }
2805       }
2806     }
2807   }
2808 }
2809 
2810 // ------------------------------------------------------------------
2811 // ciTypeFlow::get_block_for
2812 //
2813 // Find a block with this ciBlock which has a compatible JsrSet.
2814 // If no such block exists, create it, unless the option is no_create.
2815 // If the option is create_backedge_copy, always create a fresh backedge copy.
2816 ciTypeFlow::Block* ciTypeFlow::get_block_for(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2817   Arena* a = arena();
2818   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2819   if (blocks == NULL) {
2820     // Query only?
2821     if (option == no_create)  return NULL;
2822 
2823     // Allocate the growable array.
2824     blocks = new (a) GrowableArray&lt;Block*&gt;(a, 4, 0, NULL);
2825     _idx_to_blocklist[ciBlockIndex] = blocks;
2826   }
2827 
2828   if (option != create_backedge_copy) {
2829     int len = blocks-&gt;length();
2830     for (int i = 0; i &lt; len; i++) {
2831       Block* block = blocks-&gt;at(i);
2832       if (!block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2833         return block;
2834       }
2835     }
2836   }
2837 
2838   // Query only?
2839   if (option == no_create)  return NULL;
2840 
2841   // We did not find a compatible block.  Create one.
2842   Block* new_block = new (a) Block(this, _methodBlocks-&gt;block(ciBlockIndex), jsrs);
2843   if (option == create_backedge_copy)  new_block-&gt;set_backedge_copy(true);
2844   blocks-&gt;append(new_block);
2845   return new_block;
2846 }
2847 
2848 // ------------------------------------------------------------------
2849 // ciTypeFlow::backedge_copy_count
2850 //
2851 int ciTypeFlow::backedge_copy_count(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs) const {
2852   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2853 
2854   if (blocks == NULL) {
2855     return 0;
2856   }
2857 
2858   int count = 0;
2859   int len = blocks-&gt;length();
2860   for (int i = 0; i &lt; len; i++) {
2861     Block* block = blocks-&gt;at(i);
2862     if (block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2863       count++;
2864     }
2865   }
2866 
2867   return count;
2868 }
2869 
2870 // ------------------------------------------------------------------
2871 // ciTypeFlow::do_flow
2872 //
2873 // Perform type inference flow analysis.
2874 void ciTypeFlow::do_flow() {
2875   if (CITraceTypeFlow) {
2876     tty-&gt;print_cr(&quot;\nPerforming flow analysis on method&quot;);
2877     method()-&gt;print();
2878     if (is_osr_flow())  tty-&gt;print(&quot; at OSR bci %d&quot;, start_bci());
2879     tty-&gt;cr();
2880     method()-&gt;print_codes();
2881   }
2882   if (CITraceTypeFlow) {
2883     tty-&gt;print_cr(&quot;Initial CI Blocks&quot;);
2884     print_on(tty);
2885   }
2886   flow_types();
2887   // Watch for bailouts.
2888   if (failing()) {
2889     return;
2890   }
2891 
2892   map_blocks();
2893 
2894   if (CIPrintTypeFlow || CITraceTypeFlow) {
2895     rpo_print_on(tty);
2896   }
2897 }
2898 
2899 // ------------------------------------------------------------------
2900 // ciTypeFlow::is_dominated_by
2901 //
2902 // Determine if the instruction at bci is dominated by the instruction at dom_bci.
2903 bool ciTypeFlow::is_dominated_by(int bci, int dom_bci) {
2904   assert(!method()-&gt;has_jsrs(), &quot;jsrs are not supported&quot;);
2905 
2906   ResourceMark rm;
2907   JsrSet* jsrs = new ciTypeFlow::JsrSet(NULL);
2908   int        index = _methodBlocks-&gt;block_containing(bci)-&gt;index();
2909   int    dom_index = _methodBlocks-&gt;block_containing(dom_bci)-&gt;index();
2910   Block*     block = get_block_for(index, jsrs, ciTypeFlow::no_create);
2911   Block* dom_block = get_block_for(dom_index, jsrs, ciTypeFlow::no_create);
2912 
2913   // Start block dominates all other blocks
2914   if (start_block()-&gt;rpo() == dom_block-&gt;rpo()) {
2915     return true;
2916   }
2917 
2918   // Dominated[i] is true if block i is dominated by dom_block
2919   int num_blocks = block_count();
2920   bool* dominated = NEW_RESOURCE_ARRAY(bool, num_blocks);
2921   for (int i = 0; i &lt; num_blocks; ++i) {
2922     dominated[i] = true;
2923   }
2924   dominated[start_block()-&gt;rpo()] = false;
2925 
2926   // Iterative dominator algorithm
2927   bool changed = true;
2928   while (changed) {
2929     changed = false;
2930     // Use reverse postorder iteration
2931     for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
2932       if (blk-&gt;is_start()) {
2933         // Ignore start block
2934         continue;
2935       }
2936       // The block is dominated if it is the dominating block
2937       // itself or if all predecessors are dominated.
2938       int index = blk-&gt;rpo();
2939       bool dom = (index == dom_block-&gt;rpo());
2940       if (!dom) {
2941         // Check if all predecessors are dominated
2942         dom = true;
2943         for (int i = 0; i &lt; blk-&gt;predecessors()-&gt;length(); ++i) {
2944           Block* pred = blk-&gt;predecessors()-&gt;at(i);
2945           if (!dominated[pred-&gt;rpo()]) {
2946             dom = false;
2947             break;
2948           }
2949         }
2950       }
2951       // Update dominator information
2952       if (dominated[index] != dom) {
2953         changed = true;
2954         dominated[index] = dom;
2955       }
2956     }
2957   }
2958   // block dominated by dom_block?
2959   return dominated[block-&gt;rpo()];
2960 }
2961 
2962 // ------------------------------------------------------------------
2963 // ciTypeFlow::record_failure()
2964 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
2965 // This is required because there is not a 1-1 relation between the ciEnv and
2966 // the TypeFlow passes within a compilation task.  For example, if the compiler
2967 // is considering inlining a method, it will request a TypeFlow.  If that fails,
2968 // the compilation as a whole may continue without the inlining.  Some TypeFlow
2969 // requests are not optional; if they fail the requestor is responsible for
2970 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
2971 void ciTypeFlow::record_failure(const char* reason) {
2972   if (env()-&gt;log() != NULL) {
2973     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
2974   }
2975   if (_failure_reason == NULL) {
2976     // Record the first failure reason.
2977     _failure_reason = reason;
2978   }
2979 }
2980 
2981 #ifndef PRODUCT
2982 // ------------------------------------------------------------------
2983 // ciTypeFlow::print_on
2984 void ciTypeFlow::print_on(outputStream* st) const {
2985   // Walk through CI blocks
2986   st-&gt;print_cr(&quot;********************************************************&quot;);
2987   st-&gt;print   (&quot;TypeFlow for &quot;);
2988   method()-&gt;name()-&gt;print_symbol_on(st);
2989   int limit_bci = code_size();
2990   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
2991   ciMethodBlocks  *mblks = _methodBlocks;
2992   ciBlock* current = NULL;
2993   for (int bci = 0; bci &lt; limit_bci; bci++) {
2994     ciBlock* blk = mblks-&gt;block_containing(bci);
2995     if (blk != NULL &amp;&amp; blk != current) {
2996       current = blk;
2997       current-&gt;print_on(st);
2998 
2999       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3000       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
3001 
3002       if (num_blocks == 0) {
3003         st-&gt;print_cr(&quot;  No Blocks&quot;);
3004       } else {
3005         for (int i = 0; i &lt; num_blocks; i++) {
3006           Block* block = blocks-&gt;at(i);
3007           block-&gt;print_on(st);
3008         }
3009       }
3010       st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3011       st-&gt;cr();
3012     }
3013   }
3014   st-&gt;print_cr(&quot;********************************************************&quot;);
3015   st-&gt;cr();
3016 }
3017 
3018 void ciTypeFlow::rpo_print_on(outputStream* st) const {
3019   st-&gt;print_cr(&quot;********************************************************&quot;);
3020   st-&gt;print   (&quot;TypeFlow for &quot;);
3021   method()-&gt;name()-&gt;print_symbol_on(st);
3022   int limit_bci = code_size();
3023   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3024   for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3025     blk-&gt;print_on(st);
3026     st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3027     st-&gt;cr();
3028   }
3029   st-&gt;print_cr(&quot;********************************************************&quot;);
3030   st-&gt;cr();
3031 }
3032 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
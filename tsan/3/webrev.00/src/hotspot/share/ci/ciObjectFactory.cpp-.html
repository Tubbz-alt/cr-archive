<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/ci/ciObjectFactory.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciCallSite.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciMemberName.hpp&quot;
 30 #include &quot;ci/ciMethod.hpp&quot;
 31 #include &quot;ci/ciMethodData.hpp&quot;
 32 #include &quot;ci/ciMethodHandle.hpp&quot;
 33 #include &quot;ci/ciMethodType.hpp&quot;
 34 #include &quot;ci/ciNullObject.hpp&quot;
 35 #include &quot;ci/ciObjArray.hpp&quot;
 36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
 37 #include &quot;ci/ciObject.hpp&quot;
 38 #include &quot;ci/ciObjectFactory.hpp&quot;
 39 #include &quot;ci/ciSymbol.hpp&quot;
 40 #include &quot;ci/ciTypeArray.hpp&quot;
 41 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
 42 #include &quot;ci/ciUtilities.inline.hpp&quot;
 43 #include &quot;classfile/javaClasses.inline.hpp&quot;
 44 #include &quot;classfile/systemDictionary.hpp&quot;
 45 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 46 #include &quot;memory/allocation.inline.hpp&quot;
 47 #include &quot;oops/oop.inline.hpp&quot;
 48 #include &quot;runtime/fieldType.hpp&quot;
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;utilities/macros.hpp&quot;
 51 
 52 // ciObjectFactory
 53 //
 54 // This class handles requests for the creation of new instances
 55 // of ciObject and its subclasses.  It contains a caching mechanism
 56 // which ensures that for each oop, at most one ciObject is created.
 57 // This invariant allows more efficient implementation of ciObject.
 58 //
 59 // Implementation note: the oop-&gt;ciObject mapping is represented as
 60 // a table stored in an array.  Even though objects are moved
 61 // by the garbage collector, the compactor preserves their relative
 62 // order; address comparison of oops (in perm space) is safe so long
 63 // as we prohibit GC during our comparisons.  We currently use binary
 64 // search to find the oop in the table, and inserting a new oop
 65 // into the table may be costly.  If this cost ends up being
 66 // problematic the underlying data structure can be switched to some
 67 // sort of balanced binary tree.
 68 
 69 GrowableArray&lt;ciMetadata*&gt;* ciObjectFactory::_shared_ci_metadata = NULL;
 70 ciSymbol*                 ciObjectFactory::_shared_ci_symbols[vmSymbols::SID_LIMIT];
 71 int                       ciObjectFactory::_shared_ident_limit = 0;
 72 volatile bool             ciObjectFactory::_initialized = false;
 73 
 74 
 75 // ------------------------------------------------------------------
 76 // ciObjectFactory::ciObjectFactory
 77 ciObjectFactory::ciObjectFactory(Arena* arena,
 78                                  int expected_size) {
 79 
 80   for (int i = 0; i &lt; NON_PERM_BUCKETS; i++) {
 81     _non_perm_bucket[i] = NULL;
 82   }
 83   _non_perm_count = 0;
 84 
 85   _next_ident = _shared_ident_limit;
 86   _arena = arena;
 87   _ci_metadata = new (arena) GrowableArray&lt;ciMetadata*&gt;(arena, expected_size, 0, NULL);
 88 
 89   // If the shared ci objects exist append them to this factory&#39;s objects
 90 
 91   if (_shared_ci_metadata != NULL) {
 92     _ci_metadata-&gt;appendAll(_shared_ci_metadata);
 93   }
 94 
 95   _unloaded_methods = new (arena) GrowableArray&lt;ciMethod*&gt;(arena, 4, 0, NULL);
 96   _unloaded_klasses = new (arena) GrowableArray&lt;ciKlass*&gt;(arena, 8, 0, NULL);
 97   _unloaded_instances = new (arena) GrowableArray&lt;ciInstance*&gt;(arena, 4, 0, NULL);
 98   _return_addresses =
 99     new (arena) GrowableArray&lt;ciReturnAddress*&gt;(arena, 8, 0, NULL);
100 
101   _symbols = new (arena) GrowableArray&lt;ciSymbol*&gt;(arena, 100, 0, NULL);
102 }
103 
104 // ------------------------------------------------------------------
105 // ciObjectFactory::ciObjectFactory
106 void ciObjectFactory::initialize() {
107   ASSERT_IN_VM;
108   JavaThread* thread = JavaThread::current();
109   HandleMark  handle_mark(thread);
110 
111   // This Arena is long lived and exists in the resource mark of the
112   // compiler thread that initializes the initial ciObjectFactory which
113   // creates the shared ciObjects that all later ciObjectFactories use.
114   Arena* arena = new (mtCompiler) Arena(mtCompiler);
115   ciEnv initial(arena);
116   ciEnv* env = ciEnv::current();
117   env-&gt;_factory-&gt;init_shared_objects();
118 
119   _initialized = true;
120 
121 }
122 
123 void ciObjectFactory::init_shared_objects() {
124 
125   _next_ident = 1;  // start numbering CI objects at 1
126 
127   {
128     // Create the shared symbols, but not in _shared_ci_metadata.
129     int i;
130     for (i = vmSymbols::FIRST_SID; i &lt; vmSymbols::SID_LIMIT; i++) {
131       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
132       assert(vmSymbols::find_sid(vmsym) == i, &quot;1-1 mapping&quot;);
133       ciSymbol* sym = new (_arena) ciSymbol(vmsym, (vmSymbols::SID) i);
134       init_ident_of(sym);
135       _shared_ci_symbols[i] = sym;
136     }
137 #ifdef ASSERT
138     for (i = vmSymbols::FIRST_SID; i &lt; vmSymbols::SID_LIMIT; i++) {
139       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
140       ciSymbol* sym = vm_symbol_at((vmSymbols::SID) i);
141       assert(sym-&gt;get_symbol() == vmsym, &quot;oop must match&quot;);
142     }
143     assert(ciSymbol::void_class_signature()-&gt;get_symbol() == vmSymbols::void_class_signature(), &quot;spot check&quot;);
144 #endif
145   }
146 
147   _ci_metadata = new (_arena) GrowableArray&lt;ciMetadata*&gt;(_arena, 64, 0, NULL);
148 
149   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
150     BasicType t = (BasicType)i;
151     if (type2name(t) != NULL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY &amp;&amp; t != T_NARROWOOP &amp;&amp; t != T_NARROWKLASS) {
152       ciType::_basic_types[t] = new (_arena) ciType(t);
153       init_ident_of(ciType::_basic_types[t]);
154     }
155   }
156 
157   ciEnv::_null_object_instance = new (_arena) ciNullObject();
158   init_ident_of(ciEnv::_null_object_instance);
159 
160 #define WK_KLASS_DEFN(name, ignore_s)                              \
161   if (SystemDictionary::name##_is_loaded()) \
162     ciEnv::_##name = get_metadata(SystemDictionary::name())-&gt;as_instance_klass();
163 
164   WK_KLASSES_DO(WK_KLASS_DEFN)
165 #undef WK_KLASS_DEFN
166 
167   for (int len = -1; len != _ci_metadata-&gt;length(); ) {
168     len = _ci_metadata-&gt;length();
169     for (int i2 = 0; i2 &lt; len; i2++) {
170       ciMetadata* obj = _ci_metadata-&gt;at(i2);
171       assert (obj-&gt;is_metadata(), &quot;what else would it be?&quot;);
172       if (obj-&gt;is_loaded() &amp;&amp; obj-&gt;is_instance_klass()) {
173         obj-&gt;as_instance_klass()-&gt;compute_nonstatic_fields();
174       }
175     }
176   }
177 
178   ciEnv::_unloaded_cisymbol = ciObjectFactory::get_symbol(vmSymbols::dummy_symbol());
179   // Create dummy InstanceKlass and ObjArrayKlass object and assign them idents
180   ciEnv::_unloaded_ciinstance_klass = new (_arena) ciInstanceKlass(ciEnv::_unloaded_cisymbol, NULL, NULL);
181   init_ident_of(ciEnv::_unloaded_ciinstance_klass);
182   ciEnv::_unloaded_ciobjarrayklass = new (_arena) ciObjArrayKlass(ciEnv::_unloaded_cisymbol, ciEnv::_unloaded_ciinstance_klass, 1);
183   init_ident_of(ciEnv::_unloaded_ciobjarrayklass);
184   assert(ciEnv::_unloaded_ciobjarrayklass-&gt;is_obj_array_klass(), &quot;just checking&quot;);
185 
186   get_metadata(Universe::boolArrayKlassObj());
187   get_metadata(Universe::charArrayKlassObj());
188   get_metadata(Universe::floatArrayKlassObj());
189   get_metadata(Universe::doubleArrayKlassObj());
190   get_metadata(Universe::byteArrayKlassObj());
191   get_metadata(Universe::shortArrayKlassObj());
192   get_metadata(Universe::intArrayKlassObj());
193   get_metadata(Universe::longArrayKlassObj());
194 
195 
196 
197   assert(_non_perm_count == 0, &quot;no shared non-perm objects&quot;);
198 
199   // The shared_ident_limit is the first ident number that will
200   // be used for non-shared objects.  That is, numbers less than
201   // this limit are permanently assigned to shared CI objects,
202   // while the higher numbers are recycled afresh by each new ciEnv.
203 
204   _shared_ident_limit = _next_ident;
205   _shared_ci_metadata = _ci_metadata;
206 }
207 
208 
209 ciSymbol* ciObjectFactory::get_symbol(Symbol* key) {
210   vmSymbols::SID sid = vmSymbols::find_sid(key);
211   if (sid != vmSymbols::NO_SID) {
212     // do not pollute the main cache with it
213     return vm_symbol_at(sid);
214   }
215 
216   assert(vmSymbols::find_sid(key) == vmSymbols::NO_SID, &quot;&quot;);
217   ciSymbol* s = new (arena()) ciSymbol(key, vmSymbols::NO_SID);
218   _symbols-&gt;push(s);
219   return s;
220 }
221 
222 // Decrement the refcount when done on symbols referenced by this compilation.
223 void ciObjectFactory::remove_symbols() {
224   for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
225     ciSymbol* s = _symbols-&gt;at(i);
226     s-&gt;get_symbol()-&gt;decrement_refcount();
227   }
228   // Since _symbols is resource allocated we&#39;re not allowed to delete it
229   // but it&#39;ll go away just the same.
230 }
231 
232 // ------------------------------------------------------------------
233 // ciObjectFactory::get
234 //
235 // Get the ciObject corresponding to some oop.  If the ciObject has
236 // already been created, it is returned.  Otherwise, a new ciObject
237 // is created.
238 ciObject* ciObjectFactory::get(oop key) {
239   ASSERT_IN_VM;
240 
241   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);
242 
243   NonPermObject* &amp;bucket = find_non_perm(key);
244   if (bucket != NULL) {
245     return bucket-&gt;object();
246   }
247 
248   // The ciObject does not yet exist.  Create it and insert it
249   // into the cache.
250   Handle keyHandle(Thread::current(), key);
251   ciObject* new_object = create_new_object(keyHandle());
252   assert(oopDesc::equals(keyHandle(), new_object-&gt;get_oop()), &quot;must be properly recorded&quot;);
253   init_ident_of(new_object);
254   assert(Universe::heap()-&gt;is_in_reserved(new_object-&gt;get_oop()), &quot;must be&quot;);
255 
256   // Not a perm-space object.
257   insert_non_perm(bucket, keyHandle(), new_object);
258   return new_object;
259 }
260 
261 int ciObjectFactory::metadata_compare(Metadata* const&amp; key, ciMetadata* const&amp; elt) {
262   Metadata* value = elt-&gt;constant_encoding();
263   if (key &lt; value)      return -1;
264   else if (key &gt; value) return 1;
265   else                  return 0;
266 }
267 
268 // ------------------------------------------------------------------
269 // ciObjectFactory::cached_metadata
270 //
271 // Get the ciMetadata corresponding to some Metadata. If the ciMetadata has
272 // already been created, it is returned. Otherwise, null is returned.
273 ciMetadata* ciObjectFactory::cached_metadata(Metadata* key) {
274   ASSERT_IN_VM;
275 
276   bool found = false;
277   int index = _ci_metadata-&gt;find_sorted&lt;Metadata*, ciObjectFactory::metadata_compare&gt;(key, found);
278 
279   if (!found) {
280     return NULL;
281   }
282   return _ci_metadata-&gt;at(index)-&gt;as_metadata();
283 }
284 
285 
286 // ------------------------------------------------------------------
287 // ciObjectFactory::get_metadata
288 //
289 // Get the ciMetadata corresponding to some Metadata. If the ciMetadata has
290 // already been created, it is returned. Otherwise, a new ciMetadata
291 // is created.
292 ciMetadata* ciObjectFactory::get_metadata(Metadata* key) {
293   ASSERT_IN_VM;
294 
295 #ifdef ASSERT
296   if (CIObjectFactoryVerify) {
297     Metadata* last = NULL;
298     for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
299       Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
300       assert(last &lt; o, &quot;out of order&quot;);
301       last = o;
302     }
303   }
304 #endif // ASSERT
305   int len = _ci_metadata-&gt;length();
306   bool found = false;
307   int index = _ci_metadata-&gt;find_sorted&lt;Metadata*, ciObjectFactory::metadata_compare&gt;(key, found);
308 #ifdef ASSERT
309   if (CIObjectFactoryVerify) {
310     for (int i=0; i&lt;_ci_metadata-&gt;length(); i++) {
311       if (_ci_metadata-&gt;at(i)-&gt;constant_encoding() == key) {
312         assert(index == i, &quot; bad lookup&quot;);
313       }
314     }
315   }
316 #endif
317 
318   if (!found) {
319     // The ciMetadata does not yet exist. Create it and insert it
320     // into the cache.
321     ciMetadata* new_object = create_new_metadata(key);
322     init_ident_of(new_object);
323     assert(new_object-&gt;is_metadata(), &quot;must be&quot;);
324 
325     if (len != _ci_metadata-&gt;length()) {
326       // creating the new object has recursively entered new objects
327       // into the table.  We need to recompute our index.
328       index = _ci_metadata-&gt;find_sorted&lt;Metadata*, ciObjectFactory::metadata_compare&gt;(key, found);
329     }
330     assert(!found, &quot;no double insert&quot;);
331     _ci_metadata-&gt;insert_before(index, new_object);
332     return new_object;
333   }
334   return _ci_metadata-&gt;at(index)-&gt;as_metadata();
335 }
336 
337 // ------------------------------------------------------------------
338 // ciObjectFactory::create_new_object
339 //
340 // Create a new ciObject from an oop.
341 //
342 // Implementation note: this functionality could be virtual behavior
343 // of the oop itself.  For now, we explicitly marshal the object.
344 ciObject* ciObjectFactory::create_new_object(oop o) {
345   EXCEPTION_CONTEXT;
346 
347   if (o-&gt;is_instance()) {
348     instanceHandle h_i(THREAD, (instanceOop)o);
349     if (java_lang_invoke_CallSite::is_instance(o))
350       return new (arena()) ciCallSite(h_i);
351     else if (java_lang_invoke_MemberName::is_instance(o))
352       return new (arena()) ciMemberName(h_i);
353     else if (java_lang_invoke_MethodHandle::is_instance(o))
354       return new (arena()) ciMethodHandle(h_i);
355     else if (java_lang_invoke_MethodType::is_instance(o))
356       return new (arena()) ciMethodType(h_i);
357     else
358       return new (arena()) ciInstance(h_i);
359   } else if (o-&gt;is_objArray()) {
360     objArrayHandle h_oa(THREAD, (objArrayOop)o);
361     return new (arena()) ciObjArray(h_oa);
362   } else if (o-&gt;is_typeArray()) {
363     typeArrayHandle h_ta(THREAD, (typeArrayOop)o);
364     return new (arena()) ciTypeArray(h_ta);
365   }
366 
367   // The oop is of some type not supported by the compiler interface.
368   ShouldNotReachHere();
369   return NULL;
370 }
371 
372 // ------------------------------------------------------------------
373 // ciObjectFactory::create_new_metadata
374 //
375 // Create a new ciMetadata from a Metadata*.
376 //
377 // Implementation note: in order to keep Metadata live, an auxiliary ciObject
378 // is used, which points to it&#39;s holder.
379 ciMetadata* ciObjectFactory::create_new_metadata(Metadata* o) {
380   EXCEPTION_CONTEXT;
381 
382   if (o-&gt;is_klass()) {
383     Klass* k = (Klass*)o;
384     if (k-&gt;is_instance_klass()) {
385       return new (arena()) ciInstanceKlass(k);
386     } else if (k-&gt;is_objArray_klass()) {
387       return new (arena()) ciObjArrayKlass(k);
388     } else if (k-&gt;is_typeArray_klass()) {
389       return new (arena()) ciTypeArrayKlass(k);
390     }
391   } else if (o-&gt;is_method()) {
392     methodHandle h_m(THREAD, (Method*)o);
393     ciEnv *env = CURRENT_THREAD_ENV;
394     ciInstanceKlass* holder = env-&gt;get_instance_klass(h_m()-&gt;method_holder());
395     return new (arena()) ciMethod(h_m, holder);
396   } else if (o-&gt;is_methodData()) {
397     // Hold methodHandle alive - might not be necessary ???
398     methodHandle h_m(THREAD, ((MethodData*)o)-&gt;method());
399     return new (arena()) ciMethodData((MethodData*)o);
400   }
401 
402   // The Metadata* is of some type not supported by the compiler interface.
403   ShouldNotReachHere();
404   return NULL;
405 }
406 
407 //------------------------------------------------------------------
408 // ciObjectFactory::get_unloaded_method
409 //
410 // Get the ciMethod representing an unloaded/unfound method.
411 //
412 // Implementation note: unloaded methods are currently stored in
413 // an unordered array, requiring a linear-time lookup for each
414 // unloaded method.  This may need to change.
415 ciMethod* ciObjectFactory::get_unloaded_method(ciInstanceKlass* holder,
416                                                ciSymbol*        name,
417                                                ciSymbol*        signature,
418                                                ciInstanceKlass* accessor) {
419   ciSignature* that = NULL;
420   for (int i = 0; i &lt; _unloaded_methods-&gt;length(); i++) {
421     ciMethod* entry = _unloaded_methods-&gt;at(i);
422     if (entry-&gt;holder()-&gt;equals(holder) &amp;&amp;
423         entry-&gt;name()-&gt;equals(name) &amp;&amp;
424         entry-&gt;signature()-&gt;as_symbol()-&gt;equals(signature)) {
425       // Short-circuit slow resolve.
426       if (entry-&gt;signature()-&gt;accessing_klass() == accessor) {
427         // We&#39;ve found a match.
428         return entry;
429       } else {
430         // Lazily create ciSignature
431         if (that == NULL)  that = new (arena()) ciSignature(accessor, constantPoolHandle(), signature);
432         if (entry-&gt;signature()-&gt;equals(that)) {
433           // We&#39;ve found a match.
434           return entry;
435         }
436       }
437     }
438   }
439 
440   // This is a new unloaded method.  Create it and stick it in
441   // the cache.
442   ciMethod* new_method = new (arena()) ciMethod(holder, name, signature, accessor);
443 
444   init_ident_of(new_method);
445   _unloaded_methods-&gt;append(new_method);
446 
447   return new_method;
448 }
449 
450 //------------------------------------------------------------------
451 // ciObjectFactory::get_unloaded_klass
452 //
453 // Get a ciKlass representing an unloaded klass.
454 //
455 // Implementation note: unloaded klasses are currently stored in
456 // an unordered array, requiring a linear-time lookup for each
457 // unloaded klass.  This may need to change.
458 ciKlass* ciObjectFactory::get_unloaded_klass(ciKlass* accessing_klass,
459                                              ciSymbol* name,
460                                              bool create_if_not_found) {
461   EXCEPTION_CONTEXT;
462   oop loader = NULL;
463   oop domain = NULL;
464   if (accessing_klass != NULL) {
465     loader = accessing_klass-&gt;loader();
466     domain = accessing_klass-&gt;protection_domain();
467   }
468   for (int i=0; i&lt;_unloaded_klasses-&gt;length(); i++) {
469     ciKlass* entry = _unloaded_klasses-&gt;at(i);
470     if (entry-&gt;name()-&gt;equals(name) &amp;&amp;
471         oopDesc::equals(entry-&gt;loader(), loader) &amp;&amp;
472         oopDesc::equals(entry-&gt;protection_domain(), domain)) {
473       // We&#39;ve found a match.
474       return entry;
475     }
476   }
477 
478   if (!create_if_not_found)
479     return NULL;
480 
481   // This is a new unloaded klass.  Create it and stick it in
482   // the cache.
483   ciKlass* new_klass = NULL;
484 
485   // Two cases: this is an unloaded ObjArrayKlass or an
486   // unloaded InstanceKlass.  Deal with both.
487   if (name-&gt;char_at(0) == &#39;[&#39;) {
488     // Decompose the name.&#39;
489     FieldArrayInfo fd;
490     BasicType element_type = FieldType::get_array_info(name-&gt;get_symbol(),
491                                                        fd, THREAD);
492     if (HAS_PENDING_EXCEPTION) {
493       CLEAR_PENDING_EXCEPTION;
494       CURRENT_THREAD_ENV-&gt;record_out_of_memory_failure();
495       return ciEnv::_unloaded_ciobjarrayklass;
496     }
497     int dimension = fd.dimension();
498     assert(element_type != T_ARRAY, &quot;unsuccessful decomposition&quot;);
499     ciKlass* element_klass = NULL;
500     if (element_type == T_OBJECT) {
501       ciEnv *env = CURRENT_THREAD_ENV;
502       ciSymbol* ci_name = env-&gt;get_symbol(fd.object_key());
503       element_klass =
504         env-&gt;get_klass_by_name(accessing_klass, ci_name, false)-&gt;as_instance_klass();
505     } else {
506       assert(dimension &gt; 1, &quot;one dimensional type arrays are always loaded.&quot;);
507 
508       // The type array itself takes care of one of the dimensions.
509       dimension--;
510 
511       // The element klass is a TypeArrayKlass.
512       element_klass = ciTypeArrayKlass::make(element_type);
513     }
514     new_klass = new (arena()) ciObjArrayKlass(name, element_klass, dimension);
515   } else {
516     jobject loader_handle = NULL;
517     jobject domain_handle = NULL;
518     if (accessing_klass != NULL) {
519       loader_handle = accessing_klass-&gt;loader_handle();
520       domain_handle = accessing_klass-&gt;protection_domain_handle();
521     }
522     new_klass = new (arena()) ciInstanceKlass(name, loader_handle, domain_handle);
523   }
524   init_ident_of(new_klass);
525   _unloaded_klasses-&gt;append(new_klass);
526 
527   return new_klass;
528 }
529 
530 
531 //------------------------------------------------------------------
532 // ciObjectFactory::get_unloaded_instance
533 //
534 // Get a ciInstance representing an as-yet undetermined instance of a given class.
535 //
536 ciInstance* ciObjectFactory::get_unloaded_instance(ciInstanceKlass* instance_klass) {
537   for (int i=0; i&lt;_unloaded_instances-&gt;length(); i++) {
538     ciInstance* entry = _unloaded_instances-&gt;at(i);
539     if (entry-&gt;klass()-&gt;equals(instance_klass)) {
540       // We&#39;ve found a match.
541       return entry;
542     }
543   }
544 
545   // This is a new unloaded instance.  Create it and stick it in
546   // the cache.
547   ciInstance* new_instance = new (arena()) ciInstance(instance_klass);
548 
549   init_ident_of(new_instance);
550   _unloaded_instances-&gt;append(new_instance);
551 
552   // make sure it looks the way we want:
553   assert(!new_instance-&gt;is_loaded(), &quot;&quot;);
554   assert(new_instance-&gt;klass() == instance_klass, &quot;&quot;);
555 
556   return new_instance;
557 }
558 
559 
560 //------------------------------------------------------------------
561 // ciObjectFactory::get_unloaded_klass_mirror
562 //
563 // Get a ciInstance representing an unresolved klass mirror.
564 //
565 // Currently, this ignores the parameters and returns a unique unloaded instance.
566 ciInstance* ciObjectFactory::get_unloaded_klass_mirror(ciKlass*  type) {
567   assert(ciEnv::_Class_klass != NULL, &quot;&quot;);
568   return get_unloaded_instance(ciEnv::_Class_klass-&gt;as_instance_klass());
569 }
570 
571 //------------------------------------------------------------------
572 // ciObjectFactory::get_unloaded_method_handle_constant
573 //
574 // Get a ciInstance representing an unresolved method handle constant.
575 //
576 // Currently, this ignores the parameters and returns a unique unloaded instance.
577 ciInstance* ciObjectFactory::get_unloaded_method_handle_constant(ciKlass*  holder,
578                                                                  ciSymbol* name,
579                                                                  ciSymbol* signature,
580                                                                  int       ref_kind) {
581   if (ciEnv::_MethodHandle_klass == NULL)  return NULL;
582   return get_unloaded_instance(ciEnv::_MethodHandle_klass-&gt;as_instance_klass());
583 }
584 
585 //------------------------------------------------------------------
586 // ciObjectFactory::get_unloaded_method_type_constant
587 //
588 // Get a ciInstance representing an unresolved method type constant.
589 //
590 // Currently, this ignores the parameters and returns a unique unloaded instance.
591 ciInstance* ciObjectFactory::get_unloaded_method_type_constant(ciSymbol* signature) {
592   if (ciEnv::_MethodType_klass == NULL)  return NULL;
593   return get_unloaded_instance(ciEnv::_MethodType_klass-&gt;as_instance_klass());
594 }
595 
596 ciInstance* ciObjectFactory::get_unloaded_object_constant() {
597   if (ciEnv::_Object_klass == NULL)  return NULL;
598   return get_unloaded_instance(ciEnv::_Object_klass-&gt;as_instance_klass());
599 }
600 
601 //------------------------------------------------------------------
602 // ciObjectFactory::get_empty_methodData
603 //
604 // Get the ciMethodData representing the methodData for a method with
605 // none.
606 ciMethodData* ciObjectFactory::get_empty_methodData() {
607   ciMethodData* new_methodData = new (arena()) ciMethodData();
608   init_ident_of(new_methodData);
609   return new_methodData;
610 }
611 
612 //------------------------------------------------------------------
613 // ciObjectFactory::get_return_address
614 //
615 // Get a ciReturnAddress for a specified bci.
616 ciReturnAddress* ciObjectFactory::get_return_address(int bci) {
617   for (int i=0; i&lt;_return_addresses-&gt;length(); i++) {
618     ciReturnAddress* entry = _return_addresses-&gt;at(i);
619     if (entry-&gt;bci() == bci) {
620       // We&#39;ve found a match.
621       return entry;
622     }
623   }
624 
625   ciReturnAddress* new_ret_addr = new (arena()) ciReturnAddress(bci);
626   init_ident_of(new_ret_addr);
627   _return_addresses-&gt;append(new_ret_addr);
628   return new_ret_addr;
629 }
630 
631 // ------------------------------------------------------------------
632 // ciObjectFactory::init_ident_of
633 void ciObjectFactory::init_ident_of(ciBaseObject* obj) {
634   obj-&gt;set_ident(_next_ident++);
635 }
636 
637 static ciObjectFactory::NonPermObject* emptyBucket = NULL;
638 
639 // ------------------------------------------------------------------
640 // ciObjectFactory::find_non_perm
641 //
642 // Use a small hash table, hashed on the klass of the key.
643 // If there is no entry in the cache corresponding to this oop, return
644 // the null tail of the bucket into which the oop should be inserted.
645 ciObjectFactory::NonPermObject* &amp;ciObjectFactory::find_non_perm(oop key) {
646   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);
647   ciMetadata* klass = get_metadata(key-&gt;klass());
648   NonPermObject* *bp = &amp;_non_perm_bucket[(unsigned) klass-&gt;hash() % NON_PERM_BUCKETS];
649   for (NonPermObject* p; (p = (*bp)) != NULL; bp = &amp;p-&gt;next()) {
650     if (is_equal(p, key))  break;
651   }
652   return (*bp);
653 }
654 
655 
656 
657 // ------------------------------------------------------------------
658 // Code for for NonPermObject
659 //
660 inline ciObjectFactory::NonPermObject::NonPermObject(ciObjectFactory::NonPermObject* &amp;bucket, oop key, ciObject* object) {
661   assert(ciObjectFactory::is_initialized(), &quot;&quot;);
662   _object = object;
663   _next = bucket;
664   bucket = this;
665 }
666 
667 
668 
669 // ------------------------------------------------------------------
670 // ciObjectFactory::insert_non_perm
671 //
672 // Insert a ciObject into the non-perm table.
673 void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &amp;where, oop key, ciObject* obj) {
674   assert(Universe::heap()-&gt;is_in_reserved_or_null(key), &quot;must be&quot;);
675   assert(&amp;where != &amp;emptyBucket, &quot;must not try to fill empty bucket&quot;);
676   NonPermObject* p = new (arena()) NonPermObject(where, key, obj);
677   assert(where == p &amp;&amp; is_equal(p, key) &amp;&amp; p-&gt;object() == obj, &quot;entry must match&quot;);
678   assert(find_non_perm(key) == p, &quot;must find the same spot&quot;);
679   ++_non_perm_count;
680 }
681 
682 // ------------------------------------------------------------------
683 // ciObjectFactory::vm_symbol_at
684 // Get the ciSymbol corresponding to some index in vmSymbols.
685 ciSymbol* ciObjectFactory::vm_symbol_at(int index) {
686   assert(index &gt;= vmSymbols::FIRST_SID &amp;&amp; index &lt; vmSymbols::SID_LIMIT, &quot;oob&quot;);
687   return _shared_ci_symbols[index];
688 }
689 
690 // ------------------------------------------------------------------
691 // ciObjectFactory::metadata_do
692 void ciObjectFactory::metadata_do(void f(Metadata*)) {
693   if (_ci_metadata == NULL) return;
694   for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
695     Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
696     f(o);
697   }
698 }
699 
700 // ------------------------------------------------------------------
701 // ciObjectFactory::print_contents_impl
702 void ciObjectFactory::print_contents_impl() {
703   int len = _ci_metadata-&gt;length();
704   tty-&gt;print_cr(&quot;ciObjectFactory (%d) meta data contents:&quot;, len);
705   for (int i=0; i&lt;len; i++) {
706     _ci_metadata-&gt;at(i)-&gt;print();
707     tty-&gt;cr();
708   }
709 }
710 
711 // ------------------------------------------------------------------
712 // ciObjectFactory::print_contents
713 void ciObjectFactory::print_contents() {
714   print();
715   tty-&gt;cr();
716   GUARDED_VM_ENTRY(print_contents_impl();)
717 }
718 
719 // ------------------------------------------------------------------
720 // ciObjectFactory::print
721 //
722 // Print debugging information about the object factory
723 void ciObjectFactory::print() {
724   tty-&gt;print(&quot;&lt;ciObjectFactory oops=%d metadata=%d unloaded_methods=%d unloaded_instances=%d unloaded_klasses=%d&gt;&quot;,
725              _non_perm_count, _ci_metadata-&gt;length(), _unloaded_methods-&gt;length(),
726              _unloaded_instances-&gt;length(),
727              _unloaded_klasses-&gt;length());
728 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciMethodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciMethodData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 65   _data = NULL;
 66   _data_size = 0;
 67   _extra_data_size = 0;
 68   _current_mileage = 0;
 69   _invocation_counter = 0;
 70   _backedge_counter = 0;
 71   _state = empty_state;
 72   _saw_free_extra_data = false;
 73   // Set an initial hint. Don&#39;t use set_hint_di() because
 74   // first_di() may be out of bounds if data_size is 0.
 75   _hint_di = first_di();
 76   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 77   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 78   _parameters = NULL;
 79 }
 80 
 81 // Check for entries that reference an unloaded method
 82 class PrepareExtraDataClosure : public CleanExtraDataClosure {
 83   MethodData*            _mdo;
<span class="line-modified"> 84   uint64_t               _safepoint_counter;</span>
 85   GrowableArray&lt;Method*&gt; _uncached_methods;
 86 
 87 public:
 88   PrepareExtraDataClosure(MethodData* mdo)
 89     : _mdo(mdo),
<span class="line-modified"> 90       _safepoint_counter(SafepointSynchronize::safepoint_counter()),</span>
 91       _uncached_methods()
 92   { }
 93 
 94   bool is_live(Method* m) {
 95     if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
 96       return false;
 97     }
 98     if (CURRENT_ENV-&gt;cached_metadata(m) == NULL) {
 99       // Uncached entries need to be pre-populated.
100       _uncached_methods.append(m);
101     }
102     return true;
103   }
104 
105   bool has_safepointed() {
<span class="line-modified">106     return SafepointSynchronize::safepoint_counter() != _safepoint_counter;</span>
107   }
108 
109   bool finish() {
110     if (_uncached_methods.length() == 0) {
111       // Preparation finished iff all Methods* were already cached.
112       return true;
113     }
114     // Holding locks through safepoints is bad practice.
115     MutexUnlocker mu(_mdo-&gt;extra_data_lock());
116     for (int i = 0; i &lt; _uncached_methods.length(); ++i) {
117       if (has_safepointed()) {
118         // The metadata in the growable array might contain stale
119         // entries after a safepoint.
120         return false;
121       }
122       Method* method = _uncached_methods.at(i);
123       // Populating ciEnv caches may cause safepoints due
124       // to taking the Compile_lock with safepoint checks.
125       (void)CURRENT_ENV-&gt;get_method(method);
126     }
</pre>
<hr />
<pre>
128   }
129 };
130 
131 void ciMethodData::prepare_metadata() {
132   MethodData* mdo = get_MethodData();
133 
134   for (;;) {
135     ResourceMark rm;
136     PrepareExtraDataClosure cl(mdo);
137     mdo-&gt;clean_extra_data(&amp;cl);
138     if (cl.finish()) {
139       // When encountering uncached metadata, the Compile_lock might be
140       // acquired when creating ciMetadata handles, causing safepoints
141       // which requires a new round of preparation to clean out potentially
142       // new unloading metadata.
143       return;
144     }
145   }
146 }
147 
<span class="line-modified">148 void ciMethodData::load_extra_data() {</span>
149   MethodData* mdo = get_MethodData();
150   MutexLocker ml(mdo-&gt;extra_data_lock());
151   // Deferred metadata cleaning due to concurrent class unloading.
152   prepare_metadata();
153   // After metadata preparation, there is no stale metadata,
154   // and no safepoints can introduce more stale metadata.
155   NoSafepointVerifier no_safepoint;
156 








157   // speculative trap entries also hold a pointer to a Method so need to be translated
158   DataLayout* dp_src  = mdo-&gt;extra_data_base();
159   DataLayout* end_src = mdo-&gt;args_data_limit();
160   DataLayout* dp_dst  = extra_data_base();
161   for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
162     assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
163     assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
164 
<span class="line-removed">165     // New traps in the MDO may have been added since we copied the</span>
<span class="line-removed">166     // data (concurrent deoptimizations before we acquired</span>
<span class="line-removed">167     // extra_data_lock above) or can be removed (a safepoint may occur</span>
<span class="line-removed">168     // in the prepare_metadata call above) as we translate the copy:</span>
<span class="line-removed">169     // update the copy as we go.</span>
170     int tag = dp_src-&gt;tag();
<span class="line-removed">171     size_t entry_size = DataLayout::header_size_in_bytes();</span>
<span class="line-removed">172     if (tag != DataLayout::no_tag) {</span>
<span class="line-removed">173       ProfileData* src_data = dp_src-&gt;data_in();</span>
<span class="line-removed">174       entry_size = src_data-&gt;size_in_bytes();</span>
<span class="line-removed">175     }</span>
<span class="line-removed">176     memcpy(dp_dst, dp_src, entry_size);</span>
<span class="line-removed">177 </span>
178     switch(tag) {
179     case DataLayout::speculative_trap_data_tag: {
180       ciSpeculativeTrapData data_dst(dp_dst);
181       SpeculativeTrapData   data_src(dp_src);
182       data_dst.translate_from(&amp;data_src);
183       break;
184     }
185     case DataLayout::bit_data_tag:
186       break;
187     case DataLayout::no_tag:
188     case DataLayout::arg_info_data_tag:
189       // An empty slot or ArgInfoData entry marks the end of the trap data
190       {
191         return; // Need a block to avoid SS compiler bug
192       }
193     default:
194       fatal(&quot;bad tag = %d&quot;, tag);
195     }
196   }
197 }
198 
199 void ciMethodData::load_data() {
200   MethodData* mdo = get_MethodData();
201   if (mdo == NULL) {
202     return;
203   }
204 
205   // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
206   // of invocations.
207 
<span class="line-modified">208   // Snapshot the data -- actually, take an approximate snapshot of</span>
<span class="line-modified">209   // the data.  Any concurrently executing threads may be changing the</span>
<span class="line-modified">210   // data as we copy it.</span>






















211   Copy::disjoint_words_atomic((HeapWord*) mdo,
212                               (HeapWord*) &amp;_orig,
213                               sizeof(_orig) / HeapWordSize);
214   Arena* arena = CURRENT_ENV-&gt;arena();
215   _data_size = mdo-&gt;data_size();
216   _extra_data_size = mdo-&gt;extra_data_size();
217   int total_size = _data_size + _extra_data_size;
218   _data = (intptr_t *) arena-&gt;Amalloc(total_size);
219   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
220                               (HeapWord*) _data,
<span class="line-modified">221                               total_size / HeapWordSize);</span>
222 







223   // Traverse the profile data, translating any oops into their
224   // ci equivalents.
225   ResourceMark rm;
226   ciProfileData* ci_data = first_data();
227   ProfileData* data = mdo-&gt;first_data();
228   while (is_valid(ci_data)) {
229     ci_data-&gt;translate_from(data);
230     ci_data = next_data(ci_data);
231     data = mdo-&gt;next_data(data);
232   }
233   if (mdo-&gt;parameters_type_data() != NULL) {
234     _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
235     ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
236     parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
237   }
238 
<span class="line-modified">239   load_extra_data();</span>


240 
241   // Note:  Extra data are all BitData, and do not need translation.
242   _current_mileage = MethodData::mileage_of(mdo-&gt;method());
243   _invocation_counter = mdo-&gt;invocation_count();
244   _backedge_counter = mdo-&gt;backedge_count();
245   _state = mdo-&gt;is_mature()? mature_state: immature_state;
246 
247   _eflags = mdo-&gt;eflags();
248   _arg_local = mdo-&gt;arg_local();
249   _arg_stack = mdo-&gt;arg_stack();
250   _arg_returned  = mdo-&gt;arg_returned();
251 #ifndef PRODUCT
252   if (ReplayCompiles) {
253     ciReplay::initialize(this);
254   }
255 #endif
256 }
257 
258 void ciReceiverTypeData::translate_receiver_data_from(const ProfileData* data) {
259   for (uint row = 0; row &lt; row_limit(); row++) {
260     Klass* k = data-&gt;as_ReceiverTypeData()-&gt;receiver(row);
261     if (k != NULL) {
262       if (k-&gt;is_loader_alive()) {
263         ciKlass* klass = CURRENT_ENV-&gt;get_klass(k);
264         set_receiver(row, klass);
265       } else {
266         // With concurrent class unloading, the MDO could have stale metadata; override it
267         clear_row(row);
268       }


269     }
270   }
271 }
272 
273 void ciTypeStackSlotEntries::translate_type_data_from(const TypeStackSlotEntries* entries) {
274   for (int i = 0; i &lt; number_of_entries(); i++) {
275     intptr_t k = entries-&gt;type(i);
276     Klass* klass = (Klass*)klass_part(k);
277     if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
278       // With concurrent class unloading, the MDO could have stale metadata; override it
279       TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)NULL, k));
280     } else {
281       TypeStackSlotEntries::set_type(i, translate_klass(k));
282     }
283   }
284 }
285 
286 void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {
287   intptr_t k = ret-&gt;type();
288   Klass* klass = (Klass*)klass_part(k);
</pre>
<hr />
<pre>
341 
342 // Iteration over data.
343 ciProfileData* ciMethodData::next_data(ciProfileData* current) {
344   int current_index = dp_to_di(current-&gt;dp());
345   int next_index = current_index + current-&gt;size_in_bytes();
346   ciProfileData* next = data_at(next_index);
347   return next;
348 }
349 
350 ciProfileData* ciMethodData::bci_to_extra_data(int bci, ciMethod* m, bool&amp; two_free_slots) {
351   DataLayout* dp  = extra_data_base();
352   DataLayout* end = args_data_limit();
353   two_free_slots = false;
354   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
355     switch(dp-&gt;tag()) {
356     case DataLayout::no_tag:
357       _saw_free_extra_data = true;  // observed an empty slot (common case)
358       two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
359       return NULL;
360     case DataLayout::arg_info_data_tag:
<span class="line-modified">361       return NULL; // ArgInfoData is at the end of extra data section.</span>
362     case DataLayout::bit_data_tag:
363       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
364         return new ciBitData(dp);
365       }
366       break;
367     case DataLayout::speculative_trap_data_tag: {
368       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
369       // data-&gt;method() might be null if the MDO is snapshotted
370       // concurrently with a trap
371       if (m != NULL &amp;&amp; data-&gt;method() == m &amp;&amp; dp-&gt;bci() == bci) {
372         return data;
373       }
374       break;
375     }
376     default:
377       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
378     }
379   }
380   return NULL;
381 }
</pre>
<hr />
<pre>
748   }
749   ciProfileData* data;
750   for (data = first_data(); is_valid(data); data = next_data(data)) {
751     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
752     st-&gt;fill_to(6);
753     data-&gt;print_data_on(st);
754   }
755   st-&gt;print_cr(&quot;--- Extra data:&quot;);
756   DataLayout* dp  = extra_data_base();
757   DataLayout* end = args_data_limit();
758   for (;; dp = MethodData::next_extra(dp)) {
759     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
760     switch (dp-&gt;tag()) {
761     case DataLayout::no_tag:
762       continue;
763     case DataLayout::bit_data_tag:
764       data = new BitData(dp);
765       break;
766     case DataLayout::arg_info_data_tag:
767       data = new ciArgInfoData(dp);
<span class="line-modified">768       dp = end; // ArgInfoData is at the end of extra data section.</span>
769       break;
770     case DataLayout::speculative_trap_data_tag:
771       data = new ciSpeculativeTrapData(dp);
772       break;
773     default:
774       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
775     }
776     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
777     st-&gt;fill_to(6);
778     data-&gt;print_data_on(st);
779     if (dp &gt;= end) return;
780   }
781 }
782 
783 void ciTypeEntries::print_ciklass(outputStream* st, intptr_t k) {
784   if (TypeEntries::is_type_none(k)) {
785     st-&gt;print(&quot;none&quot;);
786   } else if (TypeEntries::is_type_unknown(k)) {
787     st-&gt;print(&quot;unknown&quot;);
788   } else {
</pre>
</td>
<td>
<hr />
<pre>
 64   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 65   _data = NULL;
 66   _data_size = 0;
 67   _extra_data_size = 0;
 68   _current_mileage = 0;
 69   _invocation_counter = 0;
 70   _backedge_counter = 0;
 71   _state = empty_state;
 72   _saw_free_extra_data = false;
 73   // Set an initial hint. Don&#39;t use set_hint_di() because
 74   // first_di() may be out of bounds if data_size is 0.
 75   _hint_di = first_di();
 76   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 77   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 78   _parameters = NULL;
 79 }
 80 
 81 // Check for entries that reference an unloaded method
 82 class PrepareExtraDataClosure : public CleanExtraDataClosure {
 83   MethodData*            _mdo;
<span class="line-modified"> 84   SafepointStateTracker  _safepoint_tracker;</span>
 85   GrowableArray&lt;Method*&gt; _uncached_methods;
 86 
 87 public:
 88   PrepareExtraDataClosure(MethodData* mdo)
 89     : _mdo(mdo),
<span class="line-modified"> 90       _safepoint_tracker(SafepointSynchronize::safepoint_state_tracker()),</span>
 91       _uncached_methods()
 92   { }
 93 
 94   bool is_live(Method* m) {
 95     if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
 96       return false;
 97     }
 98     if (CURRENT_ENV-&gt;cached_metadata(m) == NULL) {
 99       // Uncached entries need to be pre-populated.
100       _uncached_methods.append(m);
101     }
102     return true;
103   }
104 
105   bool has_safepointed() {
<span class="line-modified">106     return _safepoint_tracker.safepoint_state_changed();</span>
107   }
108 
109   bool finish() {
110     if (_uncached_methods.length() == 0) {
111       // Preparation finished iff all Methods* were already cached.
112       return true;
113     }
114     // Holding locks through safepoints is bad practice.
115     MutexUnlocker mu(_mdo-&gt;extra_data_lock());
116     for (int i = 0; i &lt; _uncached_methods.length(); ++i) {
117       if (has_safepointed()) {
118         // The metadata in the growable array might contain stale
119         // entries after a safepoint.
120         return false;
121       }
122       Method* method = _uncached_methods.at(i);
123       // Populating ciEnv caches may cause safepoints due
124       // to taking the Compile_lock with safepoint checks.
125       (void)CURRENT_ENV-&gt;get_method(method);
126     }
</pre>
<hr />
<pre>
128   }
129 };
130 
131 void ciMethodData::prepare_metadata() {
132   MethodData* mdo = get_MethodData();
133 
134   for (;;) {
135     ResourceMark rm;
136     PrepareExtraDataClosure cl(mdo);
137     mdo-&gt;clean_extra_data(&amp;cl);
138     if (cl.finish()) {
139       // When encountering uncached metadata, the Compile_lock might be
140       // acquired when creating ciMetadata handles, causing safepoints
141       // which requires a new round of preparation to clean out potentially
142       // new unloading metadata.
143       return;
144     }
145   }
146 }
147 
<span class="line-modified">148 void ciMethodData::load_remaining_extra_data() {</span>
149   MethodData* mdo = get_MethodData();
150   MutexLocker ml(mdo-&gt;extra_data_lock());
151   // Deferred metadata cleaning due to concurrent class unloading.
152   prepare_metadata();
153   // After metadata preparation, there is no stale metadata,
154   // and no safepoints can introduce more stale metadata.
155   NoSafepointVerifier no_safepoint;
156 
<span class="line-added">157   assert((mdo-&gt;data_size() == _data_size) &amp;&amp; (mdo-&gt;extra_data_size() == _extra_data_size), &quot;sanity, unchanged&quot;);</span>
<span class="line-added">158   assert(extra_data_base() == (DataLayout*)((address) _data + _data_size), &quot;sanity&quot;);</span>
<span class="line-added">159 </span>
<span class="line-added">160   // Copy the extra data once it is prepared (i.e. cache populated, no release of extra data lock anymore)</span>
<span class="line-added">161   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;extra_data_base(),</span>
<span class="line-added">162                               (HeapWord*)((address) _data + _data_size),</span>
<span class="line-added">163                               (_extra_data_size - mdo-&gt;parameters_size_in_bytes()) / HeapWordSize);</span>
<span class="line-added">164 </span>
165   // speculative trap entries also hold a pointer to a Method so need to be translated
166   DataLayout* dp_src  = mdo-&gt;extra_data_base();
167   DataLayout* end_src = mdo-&gt;args_data_limit();
168   DataLayout* dp_dst  = extra_data_base();
169   for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
170     assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
171     assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
172 





173     int tag = dp_src-&gt;tag();







174     switch(tag) {
175     case DataLayout::speculative_trap_data_tag: {
176       ciSpeculativeTrapData data_dst(dp_dst);
177       SpeculativeTrapData   data_src(dp_src);
178       data_dst.translate_from(&amp;data_src);
179       break;
180     }
181     case DataLayout::bit_data_tag:
182       break;
183     case DataLayout::no_tag:
184     case DataLayout::arg_info_data_tag:
185       // An empty slot or ArgInfoData entry marks the end of the trap data
186       {
187         return; // Need a block to avoid SS compiler bug
188       }
189     default:
190       fatal(&quot;bad tag = %d&quot;, tag);
191     }
192   }
193 }
194 
195 void ciMethodData::load_data() {
196   MethodData* mdo = get_MethodData();
197   if (mdo == NULL) {
198     return;
199   }
200 
201   // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
202   // of invocations.
203 
<span class="line-modified">204   // Snapshot the data and extra parameter data first without the extra trap and arg info data.</span>
<span class="line-modified">205   // Those are copied in a second step. Actually, an approximate snapshot of the data is taken.</span>
<span class="line-modified">206   // Any concurrently executing threads may be changing the data as we copy it.</span>
<span class="line-added">207   //</span>
<span class="line-added">208   // The first snapshot step requires two copies (data entries and parameter data entries) since</span>
<span class="line-added">209   // the MDO is laid out as follows:</span>
<span class="line-added">210   //</span>
<span class="line-added">211   //  data_base:        ---------------------------</span>
<span class="line-added">212   //                    |       data entries      |</span>
<span class="line-added">213   //                    |           ...           |</span>
<span class="line-added">214   //  extra_data_base:  ---------------------------</span>
<span class="line-added">215   //                    |    trap data entries    |</span>
<span class="line-added">216   //                    |           ...           |</span>
<span class="line-added">217   //                    | one arg info data entry |</span>
<span class="line-added">218   //                    |    data for each arg    |</span>
<span class="line-added">219   //                    |           ...           |</span>
<span class="line-added">220   //  args_data_limit:  ---------------------------</span>
<span class="line-added">221   //                    |  parameter data entries |</span>
<span class="line-added">222   //                    |           ...           |</span>
<span class="line-added">223   //  extra_data_limit: ---------------------------</span>
<span class="line-added">224   //</span>
<span class="line-added">225   // _data_size = extra_data_base - data_base</span>
<span class="line-added">226   // _extra_data_size = extra_data_limit - extra_data_base</span>
<span class="line-added">227   // total_size = _data_size + _extra_data_size</span>
<span class="line-added">228   // args_data_limit = data_base + total_size - parameter_data_size</span>
229   Copy::disjoint_words_atomic((HeapWord*) mdo,
230                               (HeapWord*) &amp;_orig,
231                               sizeof(_orig) / HeapWordSize);
232   Arena* arena = CURRENT_ENV-&gt;arena();
233   _data_size = mdo-&gt;data_size();
234   _extra_data_size = mdo-&gt;extra_data_size();
235   int total_size = _data_size + _extra_data_size;
236   _data = (intptr_t *) arena-&gt;Amalloc(total_size);
237   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
238                               (HeapWord*) _data,
<span class="line-modified">239                               _data_size / HeapWordSize);</span>
240 
<span class="line-added">241   int parameters_data_size = mdo-&gt;parameters_size_in_bytes();</span>
<span class="line-added">242   if (parameters_data_size &gt; 0) {</span>
<span class="line-added">243     // Snapshot the parameter data</span>
<span class="line-added">244     Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;args_data_limit(),</span>
<span class="line-added">245                                 (HeapWord*) ((address)_data + total_size - parameters_data_size),</span>
<span class="line-added">246                                 parameters_data_size / HeapWordSize);</span>
<span class="line-added">247   }</span>
248   // Traverse the profile data, translating any oops into their
249   // ci equivalents.
250   ResourceMark rm;
251   ciProfileData* ci_data = first_data();
252   ProfileData* data = mdo-&gt;first_data();
253   while (is_valid(ci_data)) {
254     ci_data-&gt;translate_from(data);
255     ci_data = next_data(ci_data);
256     data = mdo-&gt;next_data(data);
257   }
258   if (mdo-&gt;parameters_type_data() != NULL) {
259     _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
260     ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
261     parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
262   }
263 
<span class="line-modified">264   assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),</span>
<span class="line-added">265       &quot;sanity - parameter data starts after the argument data of the single ArgInfoData entry&quot;);</span>
<span class="line-added">266   load_remaining_extra_data();</span>
267 
268   // Note:  Extra data are all BitData, and do not need translation.
269   _current_mileage = MethodData::mileage_of(mdo-&gt;method());
270   _invocation_counter = mdo-&gt;invocation_count();
271   _backedge_counter = mdo-&gt;backedge_count();
272   _state = mdo-&gt;is_mature()? mature_state: immature_state;
273 
274   _eflags = mdo-&gt;eflags();
275   _arg_local = mdo-&gt;arg_local();
276   _arg_stack = mdo-&gt;arg_stack();
277   _arg_returned  = mdo-&gt;arg_returned();
278 #ifndef PRODUCT
279   if (ReplayCompiles) {
280     ciReplay::initialize(this);
281   }
282 #endif
283 }
284 
285 void ciReceiverTypeData::translate_receiver_data_from(const ProfileData* data) {
286   for (uint row = 0; row &lt; row_limit(); row++) {
287     Klass* k = data-&gt;as_ReceiverTypeData()-&gt;receiver(row);
288     if (k != NULL) {
289       if (k-&gt;is_loader_alive()) {
290         ciKlass* klass = CURRENT_ENV-&gt;get_klass(k);
291         set_receiver(row, klass);
292       } else {
293         // With concurrent class unloading, the MDO could have stale metadata; override it
294         clear_row(row);
295       }
<span class="line-added">296     } else {</span>
<span class="line-added">297       set_receiver(row, NULL);</span>
298     }
299   }
300 }
301 
302 void ciTypeStackSlotEntries::translate_type_data_from(const TypeStackSlotEntries* entries) {
303   for (int i = 0; i &lt; number_of_entries(); i++) {
304     intptr_t k = entries-&gt;type(i);
305     Klass* klass = (Klass*)klass_part(k);
306     if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
307       // With concurrent class unloading, the MDO could have stale metadata; override it
308       TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)NULL, k));
309     } else {
310       TypeStackSlotEntries::set_type(i, translate_klass(k));
311     }
312   }
313 }
314 
315 void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {
316   intptr_t k = ret-&gt;type();
317   Klass* klass = (Klass*)klass_part(k);
</pre>
<hr />
<pre>
370 
371 // Iteration over data.
372 ciProfileData* ciMethodData::next_data(ciProfileData* current) {
373   int current_index = dp_to_di(current-&gt;dp());
374   int next_index = current_index + current-&gt;size_in_bytes();
375   ciProfileData* next = data_at(next_index);
376   return next;
377 }
378 
379 ciProfileData* ciMethodData::bci_to_extra_data(int bci, ciMethod* m, bool&amp; two_free_slots) {
380   DataLayout* dp  = extra_data_base();
381   DataLayout* end = args_data_limit();
382   two_free_slots = false;
383   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
384     switch(dp-&gt;tag()) {
385     case DataLayout::no_tag:
386       _saw_free_extra_data = true;  // observed an empty slot (common case)
387       two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
388       return NULL;
389     case DataLayout::arg_info_data_tag:
<span class="line-modified">390       return NULL; // ArgInfoData is after the trap data right before the parameter data.</span>
391     case DataLayout::bit_data_tag:
392       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
393         return new ciBitData(dp);
394       }
395       break;
396     case DataLayout::speculative_trap_data_tag: {
397       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
398       // data-&gt;method() might be null if the MDO is snapshotted
399       // concurrently with a trap
400       if (m != NULL &amp;&amp; data-&gt;method() == m &amp;&amp; dp-&gt;bci() == bci) {
401         return data;
402       }
403       break;
404     }
405     default:
406       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
407     }
408   }
409   return NULL;
410 }
</pre>
<hr />
<pre>
777   }
778   ciProfileData* data;
779   for (data = first_data(); is_valid(data); data = next_data(data)) {
780     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
781     st-&gt;fill_to(6);
782     data-&gt;print_data_on(st);
783   }
784   st-&gt;print_cr(&quot;--- Extra data:&quot;);
785   DataLayout* dp  = extra_data_base();
786   DataLayout* end = args_data_limit();
787   for (;; dp = MethodData::next_extra(dp)) {
788     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
789     switch (dp-&gt;tag()) {
790     case DataLayout::no_tag:
791       continue;
792     case DataLayout::bit_data_tag:
793       data = new BitData(dp);
794       break;
795     case DataLayout::arg_info_data_tag:
796       data = new ciArgInfoData(dp);
<span class="line-modified">797       dp = end; // ArgInfoData is after the trap data right before the parameter data.</span>
798       break;
799     case DataLayout::speculative_trap_data_tag:
800       data = new ciSpeculativeTrapData(dp);
801       break;
802     default:
803       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
804     }
805     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
806     st-&gt;fill_to(6);
807     data-&gt;print_data_on(st);
808     if (dp &gt;= end) return;
809   }
810 }
811 
812 void ciTypeEntries::print_ciklass(outputStream* st, intptr_t k) {
813   if (TypeEntries::is_type_none(k)) {
814     st-&gt;print(&quot;none&quot;);
815   } else if (TypeEntries::is_type_unknown(k)) {
816     st-&gt;print(&quot;unknown&quot;);
817   } else {
</pre>
</td>
</tr>
</table>
<center><a href="ciMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethodData.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciMethodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CI_CIMETHODDATA_HPP
 26 #define SHARE_CI_CIMETHODDATA_HPP
 27 
 28 #include &quot;ci/ciClassList.hpp&quot;
 29 #include &quot;ci/ciKlass.hpp&quot;
 30 #include &quot;ci/ciObject.hpp&quot;
 31 #include &quot;ci/ciUtilities.hpp&quot;
 32 #include &quot;oops/methodData.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;runtime/deoptimization.hpp&quot;
 35 
 36 class ciBitData;
 37 class ciCounterData;
 38 class ciJumpData;
 39 class ciReceiverTypeData;
 40 class ciRetData;
 41 class ciBranchData;
 42 class ciArrayData;
 43 class ciMultiBranchData;
 44 class ciArgInfoData;
 45 class ciCallTypeData;
 46 class ciVirtualCallTypeData;
 47 class ciParametersTypeData;
 48 class ciSpeculativeTrapData;
 49 
 50 typedef ProfileData ciProfileData;
 51 
 52 class ciBitData : public BitData {
 53 public:
 54   ciBitData(DataLayout* layout) : BitData(layout) {};
 55 };
 56 
 57 class ciCounterData : public CounterData {
 58 public:
 59   ciCounterData(DataLayout* layout) : CounterData(layout) {};
 60 };
 61 
 62 class ciJumpData : public JumpData {
 63 public:
 64   ciJumpData(DataLayout* layout) : JumpData(layout) {};
 65 };
 66 
 67 class ciTypeEntries {
 68 protected:
 69   static intptr_t translate_klass(intptr_t k) {
 70     Klass* v = TypeEntries::valid_klass(k);
 71     if (v != NULL) {
 72       ciKlass* klass = CURRENT_ENV-&gt;get_klass(v);
 73       return with_status(klass, k);
 74     }
 75     return with_status(NULL, k);
 76   }
 77 
 78 public:
 79   static ciKlass* valid_ciklass(intptr_t k) {
 80     if (!TypeEntries::is_type_none(k) &amp;&amp;
 81         !TypeEntries::is_type_unknown(k)) {
 82       ciKlass* res = (ciKlass*)TypeEntries::klass_part(k);
 83       assert(res != NULL, &quot;invalid&quot;);
 84       return res;
 85     } else {
 86       return NULL;
 87     }
 88   }
 89 
 90   static ProfilePtrKind ptr_kind(intptr_t v) {
 91     bool maybe_null = TypeEntries::was_null_seen(v);
 92     if (!maybe_null) {
 93       return ProfileNeverNull;
 94     } else if (TypeEntries::is_type_none(v)) {
 95       return ProfileAlwaysNull;
 96     } else {
 97       return ProfileMaybeNull;
 98     }
 99   }
100 
101   static intptr_t with_status(ciKlass* k, intptr_t in) {
102     return TypeEntries::with_status((intptr_t)k, in);
103   }
104 
105 #ifndef PRODUCT
106   static void print_ciklass(outputStream* st, intptr_t k);
107 #endif
108 };
109 
110 class ciTypeStackSlotEntries : public TypeStackSlotEntries, ciTypeEntries {
111 public:
112   void translate_type_data_from(const TypeStackSlotEntries* args);
113 
114   ciKlass* valid_type(int i) const {
115     return valid_ciklass(type(i));
116   }
117 
118   ProfilePtrKind ptr_kind(int i) const {
119     return ciTypeEntries::ptr_kind(type(i));
120   }
121 
122 #ifndef PRODUCT
123   void print_data_on(outputStream* st) const;
124 #endif
125 };
126 
127 class ciReturnTypeEntry : public ReturnTypeEntry, ciTypeEntries {
128 public:
129   void translate_type_data_from(const ReturnTypeEntry* ret);
130 
131   ciKlass* valid_type() const {
132     return valid_ciklass(type());
133   }
134 
135   ProfilePtrKind ptr_kind() const {
136     return ciTypeEntries::ptr_kind(type());
137   }
138 
139 #ifndef PRODUCT
140   void print_data_on(outputStream* st) const;
141 #endif
142 };
143 
144 class ciCallTypeData : public CallTypeData {
145 public:
146   ciCallTypeData(DataLayout* layout) : CallTypeData(layout) {}
147 
148   ciTypeStackSlotEntries* args() const { return (ciTypeStackSlotEntries*)CallTypeData::args(); }
149   ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)CallTypeData::ret(); }
150 
151   void translate_from(const ProfileData* data) {
152     if (has_arguments()) {
153       args()-&gt;translate_type_data_from(data-&gt;as_CallTypeData()-&gt;args());
154     }
155     if (has_return()) {
156       ret()-&gt;translate_type_data_from(data-&gt;as_CallTypeData()-&gt;ret());
157     }
158   }
159 
160   intptr_t argument_type(int i) const {
161     assert(has_arguments(), &quot;no arg type profiling data&quot;);
162     return args()-&gt;type(i);
163   }
164 
165   ciKlass* valid_argument_type(int i) const {
166     assert(has_arguments(), &quot;no arg type profiling data&quot;);
167     return args()-&gt;valid_type(i);
168   }
169 
170   intptr_t return_type() const {
171     assert(has_return(), &quot;no ret type profiling data&quot;);
172     return ret()-&gt;type();
173   }
174 
175   ciKlass* valid_return_type() const {
176     assert(has_return(), &quot;no ret type profiling data&quot;);
177     return ret()-&gt;valid_type();
178   }
179 
180   ProfilePtrKind argument_ptr_kind(int i) const {
181     return args()-&gt;ptr_kind(i);
182   }
183 
184   ProfilePtrKind return_ptr_kind() const {
185     return ret()-&gt;ptr_kind();
186   }
187 
188 #ifndef PRODUCT
189   void print_data_on(outputStream* st, const char* extra = NULL) const;
190 #endif
191 };
192 
193 class ciReceiverTypeData : public ReceiverTypeData {
194 public:
195   ciReceiverTypeData(DataLayout* layout) : ReceiverTypeData(layout) {};
196 
197   void set_receiver(uint row, ciKlass* recv) {
198     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
199     set_intptr_at(receiver0_offset + row * receiver_type_row_cell_count,
200                   (intptr_t) recv);
201   }
202 
203   ciKlass* receiver(uint row) const {
204     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
205     ciKlass* recv = (ciKlass*)intptr_at(receiver0_offset + row * receiver_type_row_cell_count);
206     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
207     return recv;
208   }
209 
210   // Copy &amp; translate from oop based ReceiverTypeData
211   virtual void translate_from(const ProfileData* data) {
212     translate_receiver_data_from(data);
213   }
214   void translate_receiver_data_from(const ProfileData* data);
215 #ifndef PRODUCT
216   void print_data_on(outputStream* st, const char* extra = NULL) const;
217   void print_receiver_data_on(outputStream* st) const;
218 #endif
219 };
220 
221 class ciVirtualCallData : public VirtualCallData {
222   // Fake multiple inheritance...  It&#39;s a ciReceiverTypeData also.
223   ciReceiverTypeData* rtd_super() const { return (ciReceiverTypeData*) this; }
224 
225 public:
226   ciVirtualCallData(DataLayout* layout) : VirtualCallData(layout) {};
227 
228   void set_receiver(uint row, ciKlass* recv) {
229     rtd_super()-&gt;set_receiver(row, recv);
230   }
231 
232   ciKlass* receiver(uint row) {
233     return rtd_super()-&gt;receiver(row);
234   }
235 
236   // Copy &amp; translate from oop based VirtualCallData
237   virtual void translate_from(const ProfileData* data) {
238     rtd_super()-&gt;translate_receiver_data_from(data);
239   }
240 #ifndef PRODUCT
241   void print_data_on(outputStream* st, const char* extra = NULL) const;
242 #endif
243 };
244 
245 class ciVirtualCallTypeData : public VirtualCallTypeData {
246 private:
247   // Fake multiple inheritance...  It&#39;s a ciReceiverTypeData also.
248   ciReceiverTypeData* rtd_super() const { return (ciReceiverTypeData*) this; }
249 public:
250   ciVirtualCallTypeData(DataLayout* layout) : VirtualCallTypeData(layout) {}
251 
252   void set_receiver(uint row, ciKlass* recv) {
253     rtd_super()-&gt;set_receiver(row, recv);
254   }
255 
256   ciKlass* receiver(uint row) const {
257     return rtd_super()-&gt;receiver(row);
258   }
259 
260   ciTypeStackSlotEntries* args() const { return (ciTypeStackSlotEntries*)VirtualCallTypeData::args(); }
261   ciReturnTypeEntry* ret() const { return (ciReturnTypeEntry*)VirtualCallTypeData::ret(); }
262 
263   // Copy &amp; translate from oop based VirtualCallData
264   virtual void translate_from(const ProfileData* data) {
265     rtd_super()-&gt;translate_receiver_data_from(data);
266     if (has_arguments()) {
267       args()-&gt;translate_type_data_from(data-&gt;as_VirtualCallTypeData()-&gt;args());
268     }
269     if (has_return()) {
270       ret()-&gt;translate_type_data_from(data-&gt;as_VirtualCallTypeData()-&gt;ret());
271     }
272   }
273 
274   ciKlass* valid_argument_type(int i) const {
275     assert(has_arguments(), &quot;no arg type profiling data&quot;);
276     return args()-&gt;valid_type(i);
277   }
278 
279   intptr_t return_type() const {
280     assert(has_return(), &quot;no ret type profiling data&quot;);
281     return ret()-&gt;type();
282   }
283 
284   ciKlass* valid_return_type() const {
285     assert(has_return(), &quot;no ret type profiling data&quot;);
286     return ret()-&gt;valid_type();
287   }
288 
289   ProfilePtrKind argument_ptr_kind(int i) const {
290     return args()-&gt;ptr_kind(i);
291   }
292 
293   ProfilePtrKind return_ptr_kind() const {
294     return ret()-&gt;ptr_kind();
295   }
296 
297 #ifndef PRODUCT
298   void print_data_on(outputStream* st, const char* extra = NULL) const;
299 #endif
300 };
301 
302 
303 class ciRetData : public RetData {
304 public:
305   ciRetData(DataLayout* layout) : RetData(layout) {};
306 };
307 
308 class ciBranchData : public BranchData {
309 public:
310   ciBranchData(DataLayout* layout) : BranchData(layout) {};
311 };
312 
313 class ciMultiBranchData : public MultiBranchData {
314 public:
315   ciMultiBranchData(DataLayout* layout) : MultiBranchData(layout) {};
316 };
317 
318 class ciArgInfoData : public ArgInfoData {
319 public:
320   ciArgInfoData(DataLayout* layout) : ArgInfoData(layout) {};
321 };
322 
323 class ciParametersTypeData : public ParametersTypeData {
324 public:
325   ciParametersTypeData(DataLayout* layout) : ParametersTypeData(layout) {}
326 
327   virtual void translate_from(const ProfileData* data) {
328     parameters()-&gt;translate_type_data_from(data-&gt;as_ParametersTypeData()-&gt;parameters());
329   }
330 
331   ciTypeStackSlotEntries* parameters() const { return (ciTypeStackSlotEntries*)ParametersTypeData::parameters(); }
332 
333   ciKlass* valid_parameter_type(int i) const {
334     return parameters()-&gt;valid_type(i);
335   }
336 
337   ProfilePtrKind parameter_ptr_kind(int i) const {
338     return parameters()-&gt;ptr_kind(i);
339   }
340 
341 #ifndef PRODUCT
342   void print_data_on(outputStream* st, const char* extra = NULL) const;
343 #endif
344 };
345 
346 class ciSpeculativeTrapData : public SpeculativeTrapData {
347 public:
348   ciSpeculativeTrapData(DataLayout* layout) : SpeculativeTrapData(layout) {}
349 
350   virtual void translate_from(const ProfileData* data);
351 
352   ciMethod* method() const {
353     return (ciMethod*)intptr_at(speculative_trap_method);
354   }
355 
356   void set_method(ciMethod* m) {
357     set_intptr_at(speculative_trap_method, (intptr_t)m);
358   }
359 
360 #ifndef PRODUCT
361   void print_data_on(outputStream* st, const char* extra = NULL) const;
362 #endif
363 };
364 
365 // ciMethodData
366 //
367 // This class represents a MethodData* in the HotSpot virtual
368 // machine.
369 
370 class ciMethodData : public ciMetadata {
371   CI_PACKAGE_ACCESS
372   friend class ciReplay;
373 
374 private:
375   // Size in bytes
376   int _data_size;
377   int _extra_data_size;
378 
379   // Data entries
380   intptr_t* _data;
381 
382   // Cached hint for data_before()
383   int _hint_di;
384 
385   // Is data attached?  And is it mature?
386   enum { empty_state, immature_state, mature_state };
387   u_char _state;
388 
389   // Set this true if empty extra_data slots are ever witnessed.
390   u_char _saw_free_extra_data;
391 
392   // Support for interprocedural escape analysis
393   intx              _eflags;          // flags on escape information
394   intx              _arg_local;       // bit set of non-escaping arguments
395   intx              _arg_stack;       // bit set of stack-allocatable arguments
396   intx              _arg_returned;    // bit set of returned arguments
397 
398   // Maturity of the oop when the snapshot is taken.
399   int _current_mileage;
400 
401   // These counters hold the age of MDO in tiered. In tiered we can have the same method
402   // running at different compilation levels concurrently. So, in order to precisely measure
403   // its maturity we need separate counters.
404   int _invocation_counter;
405   int _backedge_counter;
406 
407   // Coherent snapshot of original header.
408   MethodData _orig;
409 
410   // Area dedicated to parameters. NULL if no parameter profiling for
411   // this method.
412   DataLayout* _parameters;
413   int parameters_size() const {
414     return _parameters == NULL ? 0 : parameters_type_data()-&gt;size_in_bytes();
415   }
416 
417   ciMethodData(MethodData* md);
418   ciMethodData();
419 
420   // Accessors
421   int data_size() const { return _data_size; }
422   int extra_data_size() const { return _extra_data_size; }
423   intptr_t * data() const { return _data; }
424 
425   MethodData* get_MethodData() const {
426     return (MethodData*)_metadata;
427   }
428 
429   const char* type_string()                      { return &quot;ciMethodData&quot;; }
430 
431   void print_impl(outputStream* st);
432 
433   DataLayout* data_layout_at(int data_index) const {
434     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
435     return (DataLayout*) (((address)_data) + data_index);
436   }
437 
438   bool out_of_bounds(int data_index) {
439     return data_index &gt;= data_size();
440   }
441 
442   // hint accessors
443   int      hint_di() const  { return _hint_di; }
444   void set_hint_di(int di)  {
445     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
446     _hint_di = di;
447   }
448   ciProfileData* data_before(int bci) {
449     // avoid SEGV on this edge case
450     if (data_size() == 0)
451       return NULL;
452     int hint = hint_di();
453     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
454       return data_at(hint);
455     return first_data();
456   }
457 
458 
459   // What is the index of the first data entry?
460   int first_di() { return 0; }
461 
462   ciArgInfoData *arg_info() const;
463 
464   void prepare_metadata();
<a name="1" id="anc1"></a><span class="line-modified">465   void load_remaining_extra_data();</span>
466   ciProfileData* bci_to_extra_data(int bci, ciMethod* m, bool&amp; two_free_slots);
467 
468   void dump_replay_data_type_helper(outputStream* out, int round, int&amp; count, ProfileData* pdata, ByteSize offset, ciKlass* k);
469   template&lt;class T&gt; void dump_replay_data_call_type_helper(outputStream* out, int round, int&amp; count, T* call_type_data);
470   template&lt;class T&gt; void dump_replay_data_receiver_type_helper(outputStream* out, int round, int&amp; count, T* call_type_data);
471   void dump_replay_data_extra_data_helper(outputStream* out, int round, int&amp; count);
472 
473 public:
474   bool is_method_data() const { return true; }
475 
476   bool is_empty()  { return _state == empty_state; }
477   bool is_mature() { return _state == mature_state; }
478 
479   int creation_mileage() { return _orig.creation_mileage(); }
480   int current_mileage()  { return _current_mileage; }
481 
482   int invocation_count() { return _invocation_counter; }
483   int backedge_count()   { return _backedge_counter;   }
484 
485 #if INCLUDE_RTM_OPT
486   // return cached value
487   int rtm_state() {
488     if (is_empty()) {
489       return NoRTM;
490     } else {
491       return get_MethodData()-&gt;rtm_state();
492     }
493   }
494 #endif
495 
496   // Transfer information about the method to MethodData*.
497   // would_profile means we would like to profile this method,
498   // meaning it&#39;s not trivial.
499   void set_would_profile(bool p);
500   // Also set the numer of loops and blocks in the method.
501   // Again, this is used to determine if a method is trivial.
502   void set_compilation_stats(short loops, short blocks);
503   // If the compiler finds a profiled type that is known statically
504   // for sure, set it in the MethodData
505   void set_argument_type(int bci, int i, ciKlass* k);
506   void set_parameter_type(int i, ciKlass* k);
507   void set_return_type(int bci, ciKlass* k);
508 
509   void load_data();
510 
511   // Convert a dp (data pointer) to a di (data index).
512   int dp_to_di(address dp) {
513     return dp - ((address)_data);
514   }
515 
516   // Get the data at an arbitrary (sort of) data index.
517   ciProfileData* data_at(int data_index);
518 
519   // Walk through the data in order.
520   ciProfileData* first_data() { return data_at(first_di()); }
521   ciProfileData* next_data(ciProfileData* current);
522   bool is_valid(ciProfileData* current) { return current != NULL; }
523 
524   DataLayout* extra_data_base() const  { return data_layout_at(data_size()); }
525   DataLayout* args_data_limit() const  { return data_layout_at(data_size() + extra_data_size() -
526                                                                parameters_size()); }
527 
528   // Get the data at an arbitrary bci, or NULL if there is none. If m
529   // is not NULL look for a SpeculativeTrapData if any first.
530   ciProfileData* bci_to_data(int bci, ciMethod* m = NULL);
531 
532   uint overflow_trap_count() const {
533     return _orig.overflow_trap_count();
534   }
535   uint overflow_recompile_count() const {
536     return _orig.overflow_recompile_count();
537   }
538   uint decompile_count() const {
539     return _orig.decompile_count();
540   }
541   uint trap_count(int reason) const {
542     return _orig.trap_count(reason);
543   }
544   uint trap_reason_limit() const { return _orig.trap_reason_limit(); }
545   uint trap_count_limit()  const { return _orig.trap_count_limit(); }
546 
547   // Helpful query functions that decode trap_state.
548   int has_trap_at(ciProfileData* data, int reason);
549   int has_trap_at(int bci, ciMethod* m, int reason) {
550     assert((m != NULL) == Deoptimization::reason_is_speculate(reason), &quot;inconsistent method/reason&quot;);
551     return has_trap_at(bci_to_data(bci, m), reason);
552   }
553   int trap_recompiled_at(ciProfileData* data);
554   int trap_recompiled_at(int bci, ciMethod* m) {
555     return trap_recompiled_at(bci_to_data(bci, m));
556   }
557 
558   void clear_escape_info();
559   bool has_escape_info();
560   void update_escape_info();
561 
562   void set_eflag(MethodData::EscapeFlag f);
563   bool eflag_set(MethodData::EscapeFlag f) const;
564 
565   void set_arg_local(int i);
566   void set_arg_stack(int i);
567   void set_arg_returned(int i);
568   void set_arg_modified(int arg, uint val);
569 
570   bool is_arg_local(int i) const;
571   bool is_arg_stack(int i) const;
572   bool is_arg_returned(int i) const;
573   uint arg_modified(int arg) const;
574 
575   ciParametersTypeData* parameters_type_data() const {
576     return _parameters != NULL ? new ciParametersTypeData(_parameters) : NULL;
577   }
578 
579   // Code generation helper
580   ByteSize offset_of_slot(ciProfileData* data, ByteSize slot_offset_in_data);
581   int      byte_offset_of_slot(ciProfileData* data, ByteSize slot_offset_in_data) { return in_bytes(offset_of_slot(data, slot_offset_in_data)); }
582 
583 #ifndef PRODUCT
584   // printing support for method data
585   void print();
586   void print_data_on(outputStream* st);
587 #endif
588   void dump_replay_data(outputStream* out);
589 };
590 
591 #endif // SHARE_CI_CIMETHODDATA_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
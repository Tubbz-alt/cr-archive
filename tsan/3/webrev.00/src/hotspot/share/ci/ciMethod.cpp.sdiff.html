<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciMetadata.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 #include &quot;oops/method.hpp&quot;
  56 #endif
  57 
  58 // ciMethod
  59 //
  60 // This class represents a Method* in the HotSpot virtual
  61 // machine.
  62 
  63 
  64 // ------------------------------------------------------------------
  65 // ciMethod::ciMethod
  66 //
  67 // Loaded method.
  68 ciMethod::ciMethod(const methodHandle&amp; h_m, ciInstanceKlass* holder) :
  69   ciMetadata(h_m()),
  70   _holder(holder)
  71 {
  72   assert(h_m() != NULL, &quot;no null method&quot;);
  73 
  74   if (LogTouchedMethods) {
<span class="line-modified">  75     h_m()-&gt;log_touched(Thread::current());</span>
  76   }
  77   // These fields are always filled in in loaded methods.
<span class="line-modified">  78   _flags = ciFlags(h_m()-&gt;access_flags());</span>
  79 
  80   // Easy to compute, so fill them in now.
<span class="line-modified">  81   _max_stack          = h_m()-&gt;max_stack();</span>
<span class="line-modified">  82   _max_locals         = h_m()-&gt;max_locals();</span>
<span class="line-modified">  83   _code_size          = h_m()-&gt;code_size();</span>
<span class="line-modified">  84   _intrinsic_id       = h_m()-&gt;intrinsic_id();</span>
<span class="line-modified">  85   _handler_count      = h_m()-&gt;exception_table_length();</span>
<span class="line-modified">  86   _size_of_parameters = h_m()-&gt;size_of_parameters();</span>
<span class="line-modified">  87   _uses_monitors      = h_m()-&gt;access_flags().has_monitor_bytecodes();</span>
<span class="line-modified">  88   _balanced_monitors  = !_uses_monitors || h_m()-&gt;access_flags().is_monitor_matching();</span>
<span class="line-modified">  89   _is_c1_compilable   = !h_m()-&gt;is_not_c1_compilable();</span>
<span class="line-modified">  90   _is_c2_compilable   = !h_m()-&gt;is_not_c2_compilable();</span>
  91   _can_be_parsed      = true;
<span class="line-modified">  92   _has_reserved_stack_access = h_m()-&gt;has_reserved_stack_access();</span>
<span class="line-modified">  93   _is_overpass        = h_m()-&gt;is_overpass();</span>
  94   // Lazy fields, filled in on demand.  Require allocation.
  95   _code               = NULL;
  96   _exception_handlers = NULL;
  97   _liveness           = NULL;
  98   _method_blocks = NULL;
  99 #if defined(COMPILER2)
 100   _flow               = NULL;
 101   _bcea               = NULL;
 102 #endif // COMPILER2
 103 
 104   ciEnv *env = CURRENT_ENV;
 105   if (env-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
 106     // 6328518 check hotswap conditions under the right lock.
 107     MutexLocker locker(Compile_lock);
 108     if (Dependencies::check_evol_method(h_m()) != NULL) {
 109       _is_c1_compilable = false;
 110       _is_c2_compilable = false;
 111       _can_be_parsed = false;
 112     }
 113   } else {
<span class="line-modified"> 114     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
 115   }
 116 
<span class="line-modified"> 117   if (h_m()-&gt;method_holder()-&gt;is_linked()) {</span>
<span class="line-modified"> 118     _can_be_statically_bound = h_m()-&gt;can_be_statically_bound();</span>
 119   } else {
 120     // Have to use a conservative value in this case.
 121     _can_be_statically_bound = false;
 122   }
 123 
 124   // Adjust the definition of this condition to be more useful:
 125   // %%% take these conditions into account in vtable generation
<span class="line-modified"> 126   if (!_can_be_statically_bound &amp;&amp; h_m()-&gt;is_private())</span>
 127     _can_be_statically_bound = true;
<span class="line-modified"> 128   if (_can_be_statically_bound &amp;&amp; h_m()-&gt;is_abstract())</span>
 129     _can_be_statically_bound = false;
 130 
 131   // generating _signature may allow GC and therefore move m.
 132   // These fields are always filled in.
<span class="line-modified"> 133   _name = env-&gt;get_symbol(h_m()-&gt;name());</span>
<span class="line-modified"> 134   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m()-&gt;signature());</span>
<span class="line-modified"> 135   constantPoolHandle cpool = h_m()-&gt;constants();</span>
 136   _signature = new (env-&gt;arena()) ciSignature(_holder, cpool, sig_symbol);
 137   _method_data = NULL;
<span class="line-modified"> 138   _nmethod_age = h_m()-&gt;nmethod_age();</span>
 139   // Take a snapshot of these values, so they will be commensurate with the MDO.
 140   if (ProfileInterpreter || TieredCompilation) {
<span class="line-modified"> 141     int invcnt = h_m()-&gt;interpreter_invocation_count();</span>
 142     // if the value overflowed report it as max int
 143     _interpreter_invocation_count = invcnt &lt; 0 ? max_jint : invcnt ;
<span class="line-modified"> 144     _interpreter_throwout_count   = h_m()-&gt;interpreter_throwout_count();</span>
 145   } else {
 146     _interpreter_invocation_count = 0;
 147     _interpreter_throwout_count = 0;
 148   }
 149   if (_interpreter_invocation_count == 0)
 150     _interpreter_invocation_count = 1;
 151   _instructions_size = -1;
 152 #ifdef ASSERT
 153   if (ReplayCompiles) {
 154     ciReplay::initialize(this);
 155   }
 156 #endif
 157 }
 158 
 159 
 160 // ------------------------------------------------------------------
 161 // ciMethod::ciMethod
 162 //
 163 // Unloaded method.
 164 ciMethod::ciMethod(ciInstanceKlass* holder,
</pre>
<hr />
<pre>
 414   return raw_liveness_at_bci(bci);
 415 }
 416 
 417 // ciMethod::live_local_oops_at_bci
 418 //
 419 // find all the live oops in the locals array for a particular bci
 420 // Compute what the interpreter believes by using the interpreter
 421 // oopmap generator. This is used as a double check during osr to
 422 // guard against conservative result from MethodLiveness making us
 423 // think a dead oop is live.  MethodLiveness is conservative in the
 424 // sense that it may consider locals to be live which cannot be live,
 425 // like in the case where a local could contain an oop or  a primitive
 426 // along different paths.  In that case the local must be dead when
 427 // those paths merge. Since the interpreter&#39;s viewpoint is used when
 428 // gc&#39;ing an interpreter frame we need to use its viewpoint  during
 429 // OSR when loading the locals.
 430 
 431 ResourceBitMap ciMethod::live_local_oops_at_bci(int bci) {
 432   VM_ENTRY_MARK;
 433   InterpreterOopMap mask;
<span class="line-modified"> 434   OopMapCache::compute_one_oop_map(get_Method(), bci, &amp;mask);</span>
 435   int mask_size = max_locals();
 436   ResourceBitMap result(mask_size);
 437   int i;
 438   for (i = 0; i &lt; mask_size ; i++ ) {
 439     if (mask.is_oop(i)) result.set_bit(i);
 440   }
 441   return result;
 442 }
 443 
 444 
 445 #ifdef COMPILER1
 446 // ------------------------------------------------------------------
 447 // ciMethod::bci_block_start
 448 //
 449 // Marks all bcis where a new basic block starts
 450 const BitMap&amp; ciMethod::bci_block_start() {
 451   check_is_loaded();
 452   if (_liveness == NULL) {
 453     // Create the liveness analyzer.
 454     Arena* arena = CURRENT_ENV-&gt;arena();
 455     _liveness = new (arena) MethodLiveness(arena, this);
 456     _liveness-&gt;compute_liveness();
 457   }
 458 
 459   return _liveness-&gt;get_bci_block_start();
 460 }
 461 #endif // COMPILER1
 462 
 463 





















 464 // ------------------------------------------------------------------
 465 // ciMethod::call_profile_at_bci
 466 //
 467 // Get the ciCallProfile for the invocation of this method.
 468 // Also reports receiver types for non-call type checks (if TypeProfileCasts).
 469 ciCallProfile ciMethod::call_profile_at_bci(int bci) {
 470   ResourceMark rm;
 471   ciCallProfile result;
 472   if (method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 473     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 474     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 475       // Every profiled call site has a counter.
<span class="line-modified"> 476       int count = data-&gt;as_CounterData()-&gt;count();</span>
 477 
 478       if (!data-&gt;is_ReceiverTypeData()) {
 479         result._receiver_count[0] = 0;  // that&#39;s a definite zero
 480       } else { // ReceiverTypeData is a subclass of CounterData
 481         ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
 482         // In addition, virtual call sites have receiver type information
 483         int receivers_count_total = 0;
 484         int morphism = 0;
 485         // Precompute morphism for the possible fixup
 486         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 487           ciKlass* receiver = call-&gt;receiver(i);
 488           if (receiver == NULL)  continue;
 489           morphism++;
 490         }
 491         int epsilon = 0;
 492         if (TieredCompilation) {
 493           // For a call, it is assumed that either the type of the receiver(s)
 494           // is recorded or an associated counter is incremented, but not both. With
 495           // tiered compilation, however, both can happen due to the interpreter and
 496           // C1 profiling invocations differently. Address that inconsistency here.
 497           if (morphism == 1 &amp;&amp; count &gt; 0) {
 498             epsilon = count;
 499             count = 0;
 500           }
 501         }
 502         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 503           ciKlass* receiver = call-&gt;receiver(i);
 504           if (receiver == NULL)  continue;
<span class="line-modified"> 505           int rcount = call-&gt;receiver_count(i) + epsilon;</span>
 506           if (rcount == 0) rcount = 1; // Should be valid value
<span class="line-modified"> 507           receivers_count_total += rcount;</span>
 508           // Add the receiver to result data.
 509           result.add_receiver(receiver, rcount);
 510           // If we extend profiling to record methods,
 511           // we will set result._method also.
 512         }
 513         // Determine call site&#39;s morphism.
 514         // The call site count is 0 with known morphism (only 1 or 2 receivers)
 515         // or &lt; 0 in the case of a type check failure for checkcast, aastore, instanceof.
 516         // The call site count is &gt; 0 in the case of a polymorphic virtual call.
 517         if (morphism &gt; 0 &amp;&amp; morphism == result._limit) {
 518            // The morphism &lt;= MorphismLimit.
 519            if ((morphism &lt;  ciCallProfile::MorphismLimit) ||
 520                (morphism == ciCallProfile::MorphismLimit &amp;&amp; count == 0)) {
 521 #ifdef ASSERT
 522              if (count &gt; 0) {
 523                this-&gt;print_short_name(tty);
 524                tty-&gt;print_cr(&quot; @ bci:%d&quot;, bci);
 525                this-&gt;print_codes();
 526                assert(false, &quot;this call site should not be polymorphic&quot;);
 527              }
 528 #endif
 529              result._morphism = morphism;
 530            }
 531         }
 532         // Make the count consistent if this is a call profile. If count is
 533         // zero or less, presume that this is a typecheck profile and
 534         // do nothing.  Otherwise, increase count to be the sum of all
 535         // receiver&#39;s counts.
 536         if (count &gt;= 0) {
<span class="line-modified"> 537           count += receivers_count_total;</span>
 538         }
 539       }
 540       result._count = count;
 541     }
 542   }
 543   return result;
 544 }
 545 
 546 // ------------------------------------------------------------------
 547 // Add new receiver and sort data by receiver&#39;s profile count.
 548 void ciCallProfile::add_receiver(ciKlass* receiver, int receiver_count) {
 549   // Add new receiver and sort data by receiver&#39;s counts when we have space
 550   // for it otherwise replace the less called receiver (less called receiver
 551   // is placed to the last array element which is not used).
 552   // First array&#39;s element contains most called receiver.
 553   int i = _limit;
 554   for (; i &gt; 0 &amp;&amp; receiver_count &gt; _receiver_count[i-1]; i--) {
 555     _receiver[i] = _receiver[i-1];
 556     _receiver_count[i] = _receiver_count[i-1];
 557   }
</pre>
<hr />
<pre>
 711 
 712   // Array methods (clone, hashCode, etc.) are always statically bound.
 713   // If we were to see an array type here, we&#39;d return root_m.
 714   // However, this method processes only ciInstanceKlasses.  (See 4962591.)
 715   // The inline_native_clone intrinsic narrows Object to T[] properly,
 716   // so there is no need to do the same job here.
 717 
 718   if (!UseCHA)  return NULL;
 719 
 720   VM_ENTRY_MARK;
 721 
 722   // Disable CHA for default methods for now
 723   if (root_m-&gt;is_default_method()) {
 724     return NULL;
 725   }
 726 
 727   methodHandle target;
 728   {
 729     MutexLocker locker(Compile_lock);
 730     Klass* context = actual_recv-&gt;get_Klass();
<span class="line-modified"> 731     target = Dependencies::find_unique_concrete_method(context,</span>
<span class="line-modified"> 732                                                        root_m-&gt;get_Method());</span>
 733     // %%% Should upgrade this ciMethod API to look for 1 or 2 concrete methods.
 734   }
 735 
 736 #ifndef PRODUCT
 737   if (TraceDependencies &amp;&amp; target() != NULL &amp;&amp; target() != root_m-&gt;get_Method()) {
 738     tty-&gt;print(&quot;found a non-root unique target method&quot;);
 739     tty-&gt;print_cr(&quot;  context = %s&quot;, actual_recv-&gt;get_Klass()-&gt;external_name());
 740     tty-&gt;print(&quot;  method  = &quot;);
 741     target-&gt;print_short_name(tty);
 742     tty-&gt;cr();
 743   }
 744 #endif //PRODUCT
 745 
 746   if (target() == NULL) {
 747     return NULL;
 748   }
 749   if (target() == root_m-&gt;get_Method()) {
 750     return root_m;
 751   }
 752   if (!root_m-&gt;is_public() &amp;&amp;
 753       !root_m-&gt;is_protected()) {
 754     // If we are going to reason about inheritance, it&#39;s easiest
 755     // if the method in question is public, protected, or private.
 756     // If the answer is not root_m, it is conservatively correct
 757     // to return NULL, even if the CHA encountered irrelevant
 758     // methods in other packages.
 759     // %%% TO DO: Work out logic for package-private methods
 760     // with the same name but different vtable indexes.
 761     return NULL;
 762   }
 763   assert(!target()-&gt;is_abstract(), &quot;not allowed&quot;);
 764   return CURRENT_THREAD_ENV-&gt;get_method(target());
 765 }
 766 








 767 // ------------------------------------------------------------------
 768 // ciMethod::resolve_invoke
 769 //
 770 // Given a known receiver klass, find the target for the call.
 771 // Return NULL if the call has no target or the target is abstract.
 772 ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {
 773    check_is_loaded();
 774    VM_ENTRY_MARK;
 775 
 776    Klass* caller_klass = caller-&gt;get_Klass();
 777    Klass* recv         = exact_receiver-&gt;get_Klass();
 778    Klass* resolved     = holder()-&gt;get_Klass();
 779    Symbol* h_name      = name()-&gt;get_symbol();
 780    Symbol* h_signature = signature()-&gt;get_symbol();
 781 
 782    LinkInfo link_info(resolved, h_name, h_signature, caller_klass,
 783                       check_access ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
<span class="line-modified"> 784    methodHandle m;</span>
 785    // Only do exact lookup if receiver klass has been linked.  Otherwise,
 786    // the vtable has not been setup, and the LinkResolver will fail.
 787    if (recv-&gt;is_array_klass()
 788         ||
 789        (InstanceKlass::cast(recv)-&gt;is_linked() &amp;&amp; !exact_receiver-&gt;is_interface())) {
 790      if (holder()-&gt;is_interface()) {
 791        m = LinkResolver::resolve_interface_call_or_null(recv, link_info);
 792      } else {
 793        m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);
 794      }
 795    }
 796 
<span class="line-modified"> 797    if (m.is_null()) {</span>
 798      // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 799      return NULL;
 800    }
 801 
 802    ciMethod* result = this;
<span class="line-modified"> 803    if (m() != get_Method()) {</span>
<span class="line-modified"> 804      result = CURRENT_THREAD_ENV-&gt;get_method(m());</span>
 805    }
 806 
 807    // Don&#39;t return abstract methods because they aren&#39;t
 808    // optimizable or interesting.
 809    if (result-&gt;is_abstract()) {
 810      return NULL;
 811    } else {
 812      return result;
 813    }
 814 }
 815 
 816 // ------------------------------------------------------------------
 817 // ciMethod::resolve_vtable_index
 818 //
 819 // Given a known receiver klass, find the vtable index for the call.
 820 // Return Method::invalid_vtable_index if the vtable_index is unknown.
 821 int ciMethod::resolve_vtable_index(ciKlass* caller, ciKlass* receiver) {
 822    check_is_loaded();
 823 
 824    int vtable_index = Method::invalid_vtable_index;
</pre>
<hr />
<pre>
 908     if (counter_life &gt; method_life)
 909       counter_life = method_life;
 910     if (0 &lt; counter_life &amp;&amp; counter_life &lt;= method_life) {
 911       count = (int)((double)count * prof_factor * method_life / counter_life + 0.5);
 912       count = (count &gt; 0) ? count : 1;
 913     }
 914   }
 915   return count;
 916 }
 917 
 918 
 919 // ------------------------------------------------------------------
 920 // ciMethod::is_special_get_caller_class_method
 921 //
 922 bool ciMethod::is_ignored_by_security_stack_walk() const {
 923   check_is_loaded();
 924   VM_ENTRY_MARK;
 925   return get_Method()-&gt;is_ignored_by_security_stack_walk();
 926 }
 927 







 928 
 929 // ------------------------------------------------------------------
 930 // invokedynamic support
 931 
 932 // ------------------------------------------------------------------
 933 // ciMethod::is_method_handle_intrinsic
 934 //
 935 // Return true if the method is an instance of the JVM-generated
 936 // signature-polymorphic MethodHandle methods, _invokeBasic, _linkToVirtual, etc.
 937 bool ciMethod::is_method_handle_intrinsic() const {
 938   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 939   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 940           MethodHandles::is_signature_polymorphic_intrinsic(iid));
 941 }
 942 
 943 // ------------------------------------------------------------------
 944 // ciMethod::is_compiled_lambda_form
 945 //
 946 // Return true if the method is a generated MethodHandle adapter.
 947 // These are built by Java code.
</pre>
<hr />
<pre>
 982     Method::build_interpreter_method_data(h_m, THREAD);
 983     if (HAS_PENDING_EXCEPTION) {
 984       CLEAR_PENDING_EXCEPTION;
 985     }
 986   }
 987   if (h_m()-&gt;method_data() != NULL) {
 988     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
 989     _method_data-&gt;load_data();
 990     return true;
 991   } else {
 992     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
 993     return false;
 994   }
 995 }
 996 
 997 // public, retroactive version
 998 bool ciMethod::ensure_method_data() {
 999   bool result = true;
1000   if (_method_data == NULL || _method_data-&gt;is_empty()) {
1001     GUARDED_VM_ENTRY({
<span class="line-modified">1002       result = ensure_method_data(get_Method());</span>

1003     });
1004   }
1005   return result;
1006 }
1007 
1008 
1009 // ------------------------------------------------------------------
1010 // ciMethod::method_data
1011 //
1012 ciMethodData* ciMethod::method_data() {
1013   if (_method_data != NULL) {
1014     return _method_data;
1015   }
1016   VM_ENTRY_MARK;
1017   ciEnv* env = CURRENT_ENV;
1018   Thread* my_thread = JavaThread::current();
1019   methodHandle h_m(my_thread, get_Method());
1020 
1021   if (h_m()-&gt;method_data() != NULL) {
1022     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
</pre>
<hr />
<pre>
1079   ciEnv* env = CURRENT_ENV;
1080   if (is_c1_compile(env-&gt;comp_level())) {
1081     return _is_c1_compilable;
1082   }
1083   return _is_c2_compilable;
1084 }
1085 
1086 // ------------------------------------------------------------------
1087 // ciMethod::set_not_compilable
1088 //
1089 // Tell the VM that this method cannot be compiled at all.
1090 void ciMethod::set_not_compilable(const char* reason) {
1091   check_is_loaded();
1092   VM_ENTRY_MARK;
1093   ciEnv* env = CURRENT_ENV;
1094   if (is_c1_compile(env-&gt;comp_level())) {
1095     _is_c1_compilable = false;
1096   } else {
1097     _is_c2_compilable = false;
1098   }
<span class="line-modified">1099   get_Method()-&gt;set_not_compilable(env-&gt;comp_level(), true, reason);</span>
1100 }
1101 
1102 // ------------------------------------------------------------------
1103 // ciMethod::can_be_osr_compiled
1104 //
1105 // Have previous compilations of this method succeeded?
1106 //
1107 // Implementation note: the VM does not currently keep track
1108 // of failed OSR compilations per bci.  The entry_bci parameter
1109 // is currently unused.
1110 bool ciMethod::can_be_osr_compiled(int entry_bci) {
1111   check_is_loaded();
1112   VM_ENTRY_MARK;
1113   ciEnv* env = CURRENT_ENV;
1114   return !get_Method()-&gt;is_not_osr_compilable(env-&gt;comp_level());
1115 }
1116 
1117 // ------------------------------------------------------------------
1118 // ciMethod::has_compiled_code
1119 bool ciMethod::has_compiled_code() {
</pre>
<hr />
<pre>
1215 // ------------------------------------------------------------------
1216 // ciMethod::is_klass_loaded
1217 bool ciMethod::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
1218   VM_ENTRY_MARK;
1219   return get_Method()-&gt;is_klass_loaded(refinfo_index, must_be_resolved);
1220 }
1221 
1222 // ------------------------------------------------------------------
1223 // ciMethod::check_call
1224 bool ciMethod::check_call(int refinfo_index, bool is_static) const {
1225   // This method is used only in C2 from InlineTree::ok_to_inline,
1226   // and is only used under -Xcomp.
1227   // It appears to fail when applied to an invokeinterface call site.
1228   // FIXME: Remove this method and resolve_method_statically; refactor to use the other LinkResolver entry points.
1229   VM_ENTRY_MARK;
1230   {
1231     EXCEPTION_MARK;
1232     HandleMark hm(THREAD);
1233     constantPoolHandle pool (THREAD, get_Method()-&gt;constants());
1234     Bytecodes::Code code = (is_static ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual);
<span class="line-modified">1235     methodHandle spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);</span>
1236     if (HAS_PENDING_EXCEPTION) {
1237       CLEAR_PENDING_EXCEPTION;
1238       return false;
1239     } else {
1240       return (spec_method-&gt;is_static() == is_static);
1241     }
1242   }
1243   return false;
1244 }
1245 
1246 // ------------------------------------------------------------------
1247 // ciMethod::profile_aging
1248 //
1249 // Should the method be compiled with an age counter?
1250 bool ciMethod::profile_aging() const {
1251   return UseCodeAging &amp;&amp; (!MethodCounters::is_nmethod_hot(nmethod_age()) &amp;&amp;
1252                           !MethodCounters::is_nmethod_age_unset(nmethod_age()));
1253 }
1254 // ------------------------------------------------------------------
1255 // ciMethod::print_codes
</pre>
<hr />
<pre>
1401   ciMetadata::print_impl(st);
1402   st-&gt;print(&quot; name=&quot;);
1403   name()-&gt;print_symbol_on(st);
1404   st-&gt;print(&quot; holder=&quot;);
1405   holder()-&gt;print_name_on(st);
1406   st-&gt;print(&quot; signature=&quot;);
1407   signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1408   if (is_loaded()) {
1409     st-&gt;print(&quot; loaded=true&quot;);
1410     st-&gt;print(&quot; arg_size=%d&quot;, arg_size());
1411     st-&gt;print(&quot; flags=&quot;);
1412     flags().print_member_flags(st);
1413   } else {
1414     st-&gt;print(&quot; loaded=false&quot;);
1415   }
1416 }
1417 
1418 // ------------------------------------------------------------------
1419 
1420 static BasicType erase_to_word_type(BasicType bt) {
<span class="line-modified">1421   if (is_subword_type(bt)) return T_INT;</span>
<span class="line-modified">1422   if (bt == T_ARRAY)       return T_OBJECT;</span>
1423   return bt;
1424 }
1425 
1426 static bool basic_types_match(ciType* t1, ciType* t2) {
1427   if (t1 == t2)  return true;
1428   return erase_to_word_type(t1-&gt;basic_type()) == erase_to_word_type(t2-&gt;basic_type());
1429 }
1430 
1431 bool ciMethod::is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method) {
1432   bool invoke_through_mh_intrinsic = declared_method-&gt;is_method_handle_intrinsic() &amp;&amp;
1433                                   !resolved_method-&gt;is_method_handle_intrinsic();
1434 
1435   if (!invoke_through_mh_intrinsic) {
1436     // Method name &amp; descriptor should stay the same.
1437     // Signatures may reference unloaded types and thus they may be not strictly equal.
1438     ciSymbol* declared_signature = declared_method-&gt;signature()-&gt;as_symbol();
1439     ciSymbol* resolved_signature = resolved_method-&gt;signature()-&gt;as_symbol();
1440 
1441     return (declared_method-&gt;name()-&gt;equals(resolved_method-&gt;name())) &amp;&amp;
1442            (declared_signature-&gt;equals(resolved_signature));
</pre>
</td>
<td>
<hr />
<pre>
  55 #include &quot;oops/method.hpp&quot;
  56 #endif
  57 
  58 // ciMethod
  59 //
  60 // This class represents a Method* in the HotSpot virtual
  61 // machine.
  62 
  63 
  64 // ------------------------------------------------------------------
  65 // ciMethod::ciMethod
  66 //
  67 // Loaded method.
  68 ciMethod::ciMethod(const methodHandle&amp; h_m, ciInstanceKlass* holder) :
  69   ciMetadata(h_m()),
  70   _holder(holder)
  71 {
  72   assert(h_m() != NULL, &quot;no null method&quot;);
  73 
  74   if (LogTouchedMethods) {
<span class="line-modified">  75     h_m-&gt;log_touched(Thread::current());</span>
  76   }
  77   // These fields are always filled in in loaded methods.
<span class="line-modified">  78   _flags = ciFlags(h_m-&gt;access_flags());</span>
  79 
  80   // Easy to compute, so fill them in now.
<span class="line-modified">  81   _max_stack          = h_m-&gt;max_stack();</span>
<span class="line-modified">  82   _max_locals         = h_m-&gt;max_locals();</span>
<span class="line-modified">  83   _code_size          = h_m-&gt;code_size();</span>
<span class="line-modified">  84   _intrinsic_id       = h_m-&gt;intrinsic_id();</span>
<span class="line-modified">  85   _handler_count      = h_m-&gt;exception_table_length();</span>
<span class="line-modified">  86   _size_of_parameters = h_m-&gt;size_of_parameters();</span>
<span class="line-modified">  87   _uses_monitors      = h_m-&gt;access_flags().has_monitor_bytecodes();</span>
<span class="line-modified">  88   _balanced_monitors  = !_uses_monitors || h_m-&gt;access_flags().is_monitor_matching();</span>
<span class="line-modified">  89   _is_c1_compilable   = !h_m-&gt;is_not_c1_compilable();</span>
<span class="line-modified">  90   _is_c2_compilable   = !h_m-&gt;is_not_c2_compilable();</span>
  91   _can_be_parsed      = true;
<span class="line-modified">  92   _has_reserved_stack_access = h_m-&gt;has_reserved_stack_access();</span>
<span class="line-modified">  93   _is_overpass        = h_m-&gt;is_overpass();</span>
  94   // Lazy fields, filled in on demand.  Require allocation.
  95   _code               = NULL;
  96   _exception_handlers = NULL;
  97   _liveness           = NULL;
  98   _method_blocks = NULL;
  99 #if defined(COMPILER2)
 100   _flow               = NULL;
 101   _bcea               = NULL;
 102 #endif // COMPILER2
 103 
 104   ciEnv *env = CURRENT_ENV;
 105   if (env-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
 106     // 6328518 check hotswap conditions under the right lock.
 107     MutexLocker locker(Compile_lock);
 108     if (Dependencies::check_evol_method(h_m()) != NULL) {
 109       _is_c1_compilable = false;
 110       _is_c2_compilable = false;
 111       _can_be_parsed = false;
 112     }
 113   } else {
<span class="line-modified"> 114     DEBUG_ONLY(CompilerThread::current()-&gt;check_possible_safepoint());</span>
 115   }
 116 
<span class="line-modified"> 117   if (h_m-&gt;method_holder()-&gt;is_linked()) {</span>
<span class="line-modified"> 118     _can_be_statically_bound = h_m-&gt;can_be_statically_bound();</span>
 119   } else {
 120     // Have to use a conservative value in this case.
 121     _can_be_statically_bound = false;
 122   }
 123 
 124   // Adjust the definition of this condition to be more useful:
 125   // %%% take these conditions into account in vtable generation
<span class="line-modified"> 126   if (!_can_be_statically_bound &amp;&amp; h_m-&gt;is_private())</span>
 127     _can_be_statically_bound = true;
<span class="line-modified"> 128   if (_can_be_statically_bound &amp;&amp; h_m-&gt;is_abstract())</span>
 129     _can_be_statically_bound = false;
 130 
 131   // generating _signature may allow GC and therefore move m.
 132   // These fields are always filled in.
<span class="line-modified"> 133   _name = env-&gt;get_symbol(h_m-&gt;name());</span>
<span class="line-modified"> 134   ciSymbol* sig_symbol = env-&gt;get_symbol(h_m-&gt;signature());</span>
<span class="line-modified"> 135   constantPoolHandle cpool(Thread::current(), h_m-&gt;constants());</span>
 136   _signature = new (env-&gt;arena()) ciSignature(_holder, cpool, sig_symbol);
 137   _method_data = NULL;
<span class="line-modified"> 138   _nmethod_age = h_m-&gt;nmethod_age();</span>
 139   // Take a snapshot of these values, so they will be commensurate with the MDO.
 140   if (ProfileInterpreter || TieredCompilation) {
<span class="line-modified"> 141     int invcnt = h_m-&gt;interpreter_invocation_count();</span>
 142     // if the value overflowed report it as max int
 143     _interpreter_invocation_count = invcnt &lt; 0 ? max_jint : invcnt ;
<span class="line-modified"> 144     _interpreter_throwout_count   = h_m-&gt;interpreter_throwout_count();</span>
 145   } else {
 146     _interpreter_invocation_count = 0;
 147     _interpreter_throwout_count = 0;
 148   }
 149   if (_interpreter_invocation_count == 0)
 150     _interpreter_invocation_count = 1;
 151   _instructions_size = -1;
 152 #ifdef ASSERT
 153   if (ReplayCompiles) {
 154     ciReplay::initialize(this);
 155   }
 156 #endif
 157 }
 158 
 159 
 160 // ------------------------------------------------------------------
 161 // ciMethod::ciMethod
 162 //
 163 // Unloaded method.
 164 ciMethod::ciMethod(ciInstanceKlass* holder,
</pre>
<hr />
<pre>
 414   return raw_liveness_at_bci(bci);
 415 }
 416 
 417 // ciMethod::live_local_oops_at_bci
 418 //
 419 // find all the live oops in the locals array for a particular bci
 420 // Compute what the interpreter believes by using the interpreter
 421 // oopmap generator. This is used as a double check during osr to
 422 // guard against conservative result from MethodLiveness making us
 423 // think a dead oop is live.  MethodLiveness is conservative in the
 424 // sense that it may consider locals to be live which cannot be live,
 425 // like in the case where a local could contain an oop or  a primitive
 426 // along different paths.  In that case the local must be dead when
 427 // those paths merge. Since the interpreter&#39;s viewpoint is used when
 428 // gc&#39;ing an interpreter frame we need to use its viewpoint  during
 429 // OSR when loading the locals.
 430 
 431 ResourceBitMap ciMethod::live_local_oops_at_bci(int bci) {
 432   VM_ENTRY_MARK;
 433   InterpreterOopMap mask;
<span class="line-modified"> 434   OopMapCache::compute_one_oop_map(methodHandle(THREAD, get_Method()), bci, &amp;mask);</span>
 435   int mask_size = max_locals();
 436   ResourceBitMap result(mask_size);
 437   int i;
 438   for (i = 0; i &lt; mask_size ; i++ ) {
 439     if (mask.is_oop(i)) result.set_bit(i);
 440   }
 441   return result;
 442 }
 443 
 444 
 445 #ifdef COMPILER1
 446 // ------------------------------------------------------------------
 447 // ciMethod::bci_block_start
 448 //
 449 // Marks all bcis where a new basic block starts
 450 const BitMap&amp; ciMethod::bci_block_start() {
 451   check_is_loaded();
 452   if (_liveness == NULL) {
 453     // Create the liveness analyzer.
 454     Arena* arena = CURRENT_ENV-&gt;arena();
 455     _liveness = new (arena) MethodLiveness(arena, this);
 456     _liveness-&gt;compute_liveness();
 457   }
 458 
 459   return _liveness-&gt;get_bci_block_start();
 460 }
 461 #endif // COMPILER1
 462 
 463 
<span class="line-added"> 464 // ------------------------------------------------------------------</span>
<span class="line-added"> 465 // ciMethod::check_overflow</span>
<span class="line-added"> 466 //</span>
<span class="line-added"> 467 // Check whether the profile counter is overflowed and adjust if true.</span>
<span class="line-added"> 468 // For invoke* it will turn negative values into max_jint,</span>
<span class="line-added"> 469 // and for checkcast/aastore/instanceof turn positive values into min_jint.</span>
<span class="line-added"> 470 int ciMethod::check_overflow(int c, Bytecodes::Code code) {</span>
<span class="line-added"> 471   switch (code) {</span>
<span class="line-added"> 472     case Bytecodes::_aastore:    // fall-through</span>
<span class="line-added"> 473     case Bytecodes::_checkcast:  // fall-through</span>
<span class="line-added"> 474     case Bytecodes::_instanceof: {</span>
<span class="line-added"> 475       return (c &gt; 0 ? min_jint : c); // always non-positive</span>
<span class="line-added"> 476     }</span>
<span class="line-added"> 477     default: {</span>
<span class="line-added"> 478       assert(Bytecodes::is_invoke(code), &quot;%s&quot;, Bytecodes::name(code));</span>
<span class="line-added"> 479       return (c &lt; 0 ? max_jint : c); // always non-negative</span>
<span class="line-added"> 480     }</span>
<span class="line-added"> 481   }</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 </span>
 485 // ------------------------------------------------------------------
 486 // ciMethod::call_profile_at_bci
 487 //
 488 // Get the ciCallProfile for the invocation of this method.
 489 // Also reports receiver types for non-call type checks (if TypeProfileCasts).
 490 ciCallProfile ciMethod::call_profile_at_bci(int bci) {
 491   ResourceMark rm;
 492   ciCallProfile result;
 493   if (method_data() != NULL &amp;&amp; method_data()-&gt;is_mature()) {
 494     ciProfileData* data = method_data()-&gt;bci_to_data(bci);
 495     if (data != NULL &amp;&amp; data-&gt;is_CounterData()) {
 496       // Every profiled call site has a counter.
<span class="line-modified"> 497       int count = check_overflow(data-&gt;as_CounterData()-&gt;count(), java_code_at_bci(bci));</span>
 498 
 499       if (!data-&gt;is_ReceiverTypeData()) {
 500         result._receiver_count[0] = 0;  // that&#39;s a definite zero
 501       } else { // ReceiverTypeData is a subclass of CounterData
 502         ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
 503         // In addition, virtual call sites have receiver type information
 504         int receivers_count_total = 0;
 505         int morphism = 0;
 506         // Precompute morphism for the possible fixup
 507         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 508           ciKlass* receiver = call-&gt;receiver(i);
 509           if (receiver == NULL)  continue;
 510           morphism++;
 511         }
 512         int epsilon = 0;
 513         if (TieredCompilation) {
 514           // For a call, it is assumed that either the type of the receiver(s)
 515           // is recorded or an associated counter is incremented, but not both. With
 516           // tiered compilation, however, both can happen due to the interpreter and
 517           // C1 profiling invocations differently. Address that inconsistency here.
 518           if (morphism == 1 &amp;&amp; count &gt; 0) {
 519             epsilon = count;
 520             count = 0;
 521           }
 522         }
 523         for (uint i = 0; i &lt; call-&gt;row_limit(); i++) {
 524           ciKlass* receiver = call-&gt;receiver(i);
 525           if (receiver == NULL)  continue;
<span class="line-modified"> 526           int rcount = saturated_add(call-&gt;receiver_count(i), epsilon);</span>
 527           if (rcount == 0) rcount = 1; // Should be valid value
<span class="line-modified"> 528           receivers_count_total = saturated_add(receivers_count_total, rcount);</span>
 529           // Add the receiver to result data.
 530           result.add_receiver(receiver, rcount);
 531           // If we extend profiling to record methods,
 532           // we will set result._method also.
 533         }
 534         // Determine call site&#39;s morphism.
 535         // The call site count is 0 with known morphism (only 1 or 2 receivers)
 536         // or &lt; 0 in the case of a type check failure for checkcast, aastore, instanceof.
 537         // The call site count is &gt; 0 in the case of a polymorphic virtual call.
 538         if (morphism &gt; 0 &amp;&amp; morphism == result._limit) {
 539            // The morphism &lt;= MorphismLimit.
 540            if ((morphism &lt;  ciCallProfile::MorphismLimit) ||
 541                (morphism == ciCallProfile::MorphismLimit &amp;&amp; count == 0)) {
 542 #ifdef ASSERT
 543              if (count &gt; 0) {
 544                this-&gt;print_short_name(tty);
 545                tty-&gt;print_cr(&quot; @ bci:%d&quot;, bci);
 546                this-&gt;print_codes();
 547                assert(false, &quot;this call site should not be polymorphic&quot;);
 548              }
 549 #endif
 550              result._morphism = morphism;
 551            }
 552         }
 553         // Make the count consistent if this is a call profile. If count is
 554         // zero or less, presume that this is a typecheck profile and
 555         // do nothing.  Otherwise, increase count to be the sum of all
 556         // receiver&#39;s counts.
 557         if (count &gt;= 0) {
<span class="line-modified"> 558           count = saturated_add(count, receivers_count_total);</span>
 559         }
 560       }
 561       result._count = count;
 562     }
 563   }
 564   return result;
 565 }
 566 
 567 // ------------------------------------------------------------------
 568 // Add new receiver and sort data by receiver&#39;s profile count.
 569 void ciCallProfile::add_receiver(ciKlass* receiver, int receiver_count) {
 570   // Add new receiver and sort data by receiver&#39;s counts when we have space
 571   // for it otherwise replace the less called receiver (less called receiver
 572   // is placed to the last array element which is not used).
 573   // First array&#39;s element contains most called receiver.
 574   int i = _limit;
 575   for (; i &gt; 0 &amp;&amp; receiver_count &gt; _receiver_count[i-1]; i--) {
 576     _receiver[i] = _receiver[i-1];
 577     _receiver_count[i] = _receiver_count[i-1];
 578   }
</pre>
<hr />
<pre>
 732 
 733   // Array methods (clone, hashCode, etc.) are always statically bound.
 734   // If we were to see an array type here, we&#39;d return root_m.
 735   // However, this method processes only ciInstanceKlasses.  (See 4962591.)
 736   // The inline_native_clone intrinsic narrows Object to T[] properly,
 737   // so there is no need to do the same job here.
 738 
 739   if (!UseCHA)  return NULL;
 740 
 741   VM_ENTRY_MARK;
 742 
 743   // Disable CHA for default methods for now
 744   if (root_m-&gt;is_default_method()) {
 745     return NULL;
 746   }
 747 
 748   methodHandle target;
 749   {
 750     MutexLocker locker(Compile_lock);
 751     Klass* context = actual_recv-&gt;get_Klass();
<span class="line-modified"> 752     target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,</span>
<span class="line-modified"> 753                                                        root_m-&gt;get_Method()));</span>
 754     // %%% Should upgrade this ciMethod API to look for 1 or 2 concrete methods.
 755   }
 756 
 757 #ifndef PRODUCT
 758   if (TraceDependencies &amp;&amp; target() != NULL &amp;&amp; target() != root_m-&gt;get_Method()) {
 759     tty-&gt;print(&quot;found a non-root unique target method&quot;);
 760     tty-&gt;print_cr(&quot;  context = %s&quot;, actual_recv-&gt;get_Klass()-&gt;external_name());
 761     tty-&gt;print(&quot;  method  = &quot;);
 762     target-&gt;print_short_name(tty);
 763     tty-&gt;cr();
 764   }
 765 #endif //PRODUCT
 766 
 767   if (target() == NULL) {
 768     return NULL;
 769   }
 770   if (target() == root_m-&gt;get_Method()) {
 771     return root_m;
 772   }
 773   if (!root_m-&gt;is_public() &amp;&amp;
 774       !root_m-&gt;is_protected()) {
 775     // If we are going to reason about inheritance, it&#39;s easiest
 776     // if the method in question is public, protected, or private.
 777     // If the answer is not root_m, it is conservatively correct
 778     // to return NULL, even if the CHA encountered irrelevant
 779     // methods in other packages.
 780     // %%% TO DO: Work out logic for package-private methods
 781     // with the same name but different vtable indexes.
 782     return NULL;
 783   }
 784   assert(!target()-&gt;is_abstract(), &quot;not allowed&quot;);
 785   return CURRENT_THREAD_ENV-&gt;get_method(target());
 786 }
 787 
<span class="line-added"> 788 // ------------------------------------------------------------------</span>
<span class="line-added"> 789 // ciMethod::can_be_statically_bound</span>
<span class="line-added"> 790 //</span>
<span class="line-added"> 791 // Tries to determine whether a method can be statically bound in some context.</span>
<span class="line-added"> 792 bool ciMethod::can_be_statically_bound(ciInstanceKlass* context) const {</span>
<span class="line-added"> 793   return (holder() == context) &amp;&amp; can_be_statically_bound();</span>
<span class="line-added"> 794 }</span>
<span class="line-added"> 795 </span>
 796 // ------------------------------------------------------------------
 797 // ciMethod::resolve_invoke
 798 //
 799 // Given a known receiver klass, find the target for the call.
 800 // Return NULL if the call has no target or the target is abstract.
 801 ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {
 802    check_is_loaded();
 803    VM_ENTRY_MARK;
 804 
 805    Klass* caller_klass = caller-&gt;get_Klass();
 806    Klass* recv         = exact_receiver-&gt;get_Klass();
 807    Klass* resolved     = holder()-&gt;get_Klass();
 808    Symbol* h_name      = name()-&gt;get_symbol();
 809    Symbol* h_signature = signature()-&gt;get_symbol();
 810 
 811    LinkInfo link_info(resolved, h_name, h_signature, caller_klass,
 812                       check_access ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
<span class="line-modified"> 813    Method* m = NULL;</span>
 814    // Only do exact lookup if receiver klass has been linked.  Otherwise,
 815    // the vtable has not been setup, and the LinkResolver will fail.
 816    if (recv-&gt;is_array_klass()
 817         ||
 818        (InstanceKlass::cast(recv)-&gt;is_linked() &amp;&amp; !exact_receiver-&gt;is_interface())) {
 819      if (holder()-&gt;is_interface()) {
 820        m = LinkResolver::resolve_interface_call_or_null(recv, link_info);
 821      } else {
 822        m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);
 823      }
 824    }
 825 
<span class="line-modified"> 826    if (m == NULL) {</span>
 827      // Return NULL only if there was a problem with lookup (uninitialized class, etc.)
 828      return NULL;
 829    }
 830 
 831    ciMethod* result = this;
<span class="line-modified"> 832    if (m != get_Method()) {</span>
<span class="line-modified"> 833      result = CURRENT_THREAD_ENV-&gt;get_method(m);</span>
 834    }
 835 
 836    // Don&#39;t return abstract methods because they aren&#39;t
 837    // optimizable or interesting.
 838    if (result-&gt;is_abstract()) {
 839      return NULL;
 840    } else {
 841      return result;
 842    }
 843 }
 844 
 845 // ------------------------------------------------------------------
 846 // ciMethod::resolve_vtable_index
 847 //
 848 // Given a known receiver klass, find the vtable index for the call.
 849 // Return Method::invalid_vtable_index if the vtable_index is unknown.
 850 int ciMethod::resolve_vtable_index(ciKlass* caller, ciKlass* receiver) {
 851    check_is_loaded();
 852 
 853    int vtable_index = Method::invalid_vtable_index;
</pre>
<hr />
<pre>
 937     if (counter_life &gt; method_life)
 938       counter_life = method_life;
 939     if (0 &lt; counter_life &amp;&amp; counter_life &lt;= method_life) {
 940       count = (int)((double)count * prof_factor * method_life / counter_life + 0.5);
 941       count = (count &gt; 0) ? count : 1;
 942     }
 943   }
 944   return count;
 945 }
 946 
 947 
 948 // ------------------------------------------------------------------
 949 // ciMethod::is_special_get_caller_class_method
 950 //
 951 bool ciMethod::is_ignored_by_security_stack_walk() const {
 952   check_is_loaded();
 953   VM_ENTRY_MARK;
 954   return get_Method()-&gt;is_ignored_by_security_stack_walk();
 955 }
 956 
<span class="line-added"> 957 // ------------------------------------------------------------------</span>
<span class="line-added"> 958 // ciMethod::needs_clinit_barrier</span>
<span class="line-added"> 959 //</span>
<span class="line-added"> 960 bool ciMethod::needs_clinit_barrier() const {</span>
<span class="line-added"> 961   check_is_loaded();</span>
<span class="line-added"> 962   return is_static() &amp;&amp; !holder()-&gt;is_initialized();</span>
<span class="line-added"> 963 }</span>
 964 
 965 // ------------------------------------------------------------------
 966 // invokedynamic support
 967 
 968 // ------------------------------------------------------------------
 969 // ciMethod::is_method_handle_intrinsic
 970 //
 971 // Return true if the method is an instance of the JVM-generated
 972 // signature-polymorphic MethodHandle methods, _invokeBasic, _linkToVirtual, etc.
 973 bool ciMethod::is_method_handle_intrinsic() const {
 974   vmIntrinsics::ID iid = _intrinsic_id;  // do not check if loaded
 975   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
 976           MethodHandles::is_signature_polymorphic_intrinsic(iid));
 977 }
 978 
 979 // ------------------------------------------------------------------
 980 // ciMethod::is_compiled_lambda_form
 981 //
 982 // Return true if the method is a generated MethodHandle adapter.
 983 // These are built by Java code.
</pre>
<hr />
<pre>
1018     Method::build_interpreter_method_data(h_m, THREAD);
1019     if (HAS_PENDING_EXCEPTION) {
1020       CLEAR_PENDING_EXCEPTION;
1021     }
1022   }
1023   if (h_m()-&gt;method_data() != NULL) {
1024     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
1025     _method_data-&gt;load_data();
1026     return true;
1027   } else {
1028     _method_data = CURRENT_ENV-&gt;get_empty_methodData();
1029     return false;
1030   }
1031 }
1032 
1033 // public, retroactive version
1034 bool ciMethod::ensure_method_data() {
1035   bool result = true;
1036   if (_method_data == NULL || _method_data-&gt;is_empty()) {
1037     GUARDED_VM_ENTRY({
<span class="line-modified">1038       methodHandle mh(Thread::current(), get_Method());</span>
<span class="line-added">1039       result = ensure_method_data(mh);</span>
1040     });
1041   }
1042   return result;
1043 }
1044 
1045 
1046 // ------------------------------------------------------------------
1047 // ciMethod::method_data
1048 //
1049 ciMethodData* ciMethod::method_data() {
1050   if (_method_data != NULL) {
1051     return _method_data;
1052   }
1053   VM_ENTRY_MARK;
1054   ciEnv* env = CURRENT_ENV;
1055   Thread* my_thread = JavaThread::current();
1056   methodHandle h_m(my_thread, get_Method());
1057 
1058   if (h_m()-&gt;method_data() != NULL) {
1059     _method_data = CURRENT_ENV-&gt;get_method_data(h_m()-&gt;method_data());
</pre>
<hr />
<pre>
1116   ciEnv* env = CURRENT_ENV;
1117   if (is_c1_compile(env-&gt;comp_level())) {
1118     return _is_c1_compilable;
1119   }
1120   return _is_c2_compilable;
1121 }
1122 
1123 // ------------------------------------------------------------------
1124 // ciMethod::set_not_compilable
1125 //
1126 // Tell the VM that this method cannot be compiled at all.
1127 void ciMethod::set_not_compilable(const char* reason) {
1128   check_is_loaded();
1129   VM_ENTRY_MARK;
1130   ciEnv* env = CURRENT_ENV;
1131   if (is_c1_compile(env-&gt;comp_level())) {
1132     _is_c1_compilable = false;
1133   } else {
1134     _is_c2_compilable = false;
1135   }
<span class="line-modified">1136   get_Method()-&gt;set_not_compilable(reason, env-&gt;comp_level());</span>
1137 }
1138 
1139 // ------------------------------------------------------------------
1140 // ciMethod::can_be_osr_compiled
1141 //
1142 // Have previous compilations of this method succeeded?
1143 //
1144 // Implementation note: the VM does not currently keep track
1145 // of failed OSR compilations per bci.  The entry_bci parameter
1146 // is currently unused.
1147 bool ciMethod::can_be_osr_compiled(int entry_bci) {
1148   check_is_loaded();
1149   VM_ENTRY_MARK;
1150   ciEnv* env = CURRENT_ENV;
1151   return !get_Method()-&gt;is_not_osr_compilable(env-&gt;comp_level());
1152 }
1153 
1154 // ------------------------------------------------------------------
1155 // ciMethod::has_compiled_code
1156 bool ciMethod::has_compiled_code() {
</pre>
<hr />
<pre>
1252 // ------------------------------------------------------------------
1253 // ciMethod::is_klass_loaded
1254 bool ciMethod::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
1255   VM_ENTRY_MARK;
1256   return get_Method()-&gt;is_klass_loaded(refinfo_index, must_be_resolved);
1257 }
1258 
1259 // ------------------------------------------------------------------
1260 // ciMethod::check_call
1261 bool ciMethod::check_call(int refinfo_index, bool is_static) const {
1262   // This method is used only in C2 from InlineTree::ok_to_inline,
1263   // and is only used under -Xcomp.
1264   // It appears to fail when applied to an invokeinterface call site.
1265   // FIXME: Remove this method and resolve_method_statically; refactor to use the other LinkResolver entry points.
1266   VM_ENTRY_MARK;
1267   {
1268     EXCEPTION_MARK;
1269     HandleMark hm(THREAD);
1270     constantPoolHandle pool (THREAD, get_Method()-&gt;constants());
1271     Bytecodes::Code code = (is_static ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual);
<span class="line-modified">1272     Method* spec_method = LinkResolver::resolve_method_statically(code, pool, refinfo_index, THREAD);</span>
1273     if (HAS_PENDING_EXCEPTION) {
1274       CLEAR_PENDING_EXCEPTION;
1275       return false;
1276     } else {
1277       return (spec_method-&gt;is_static() == is_static);
1278     }
1279   }
1280   return false;
1281 }
1282 
1283 // ------------------------------------------------------------------
1284 // ciMethod::profile_aging
1285 //
1286 // Should the method be compiled with an age counter?
1287 bool ciMethod::profile_aging() const {
1288   return UseCodeAging &amp;&amp; (!MethodCounters::is_nmethod_hot(nmethod_age()) &amp;&amp;
1289                           !MethodCounters::is_nmethod_age_unset(nmethod_age()));
1290 }
1291 // ------------------------------------------------------------------
1292 // ciMethod::print_codes
</pre>
<hr />
<pre>
1438   ciMetadata::print_impl(st);
1439   st-&gt;print(&quot; name=&quot;);
1440   name()-&gt;print_symbol_on(st);
1441   st-&gt;print(&quot; holder=&quot;);
1442   holder()-&gt;print_name_on(st);
1443   st-&gt;print(&quot; signature=&quot;);
1444   signature()-&gt;as_symbol()-&gt;print_symbol_on(st);
1445   if (is_loaded()) {
1446     st-&gt;print(&quot; loaded=true&quot;);
1447     st-&gt;print(&quot; arg_size=%d&quot;, arg_size());
1448     st-&gt;print(&quot; flags=&quot;);
1449     flags().print_member_flags(st);
1450   } else {
1451     st-&gt;print(&quot; loaded=false&quot;);
1452   }
1453 }
1454 
1455 // ------------------------------------------------------------------
1456 
1457 static BasicType erase_to_word_type(BasicType bt) {
<span class="line-modified">1458   if (is_subword_type(bt))   return T_INT;</span>
<span class="line-modified">1459   if (is_reference_type(bt)) return T_OBJECT;</span>
1460   return bt;
1461 }
1462 
1463 static bool basic_types_match(ciType* t1, ciType* t2) {
1464   if (t1 == t2)  return true;
1465   return erase_to_word_type(t1-&gt;basic_type()) == erase_to_word_type(t2-&gt;basic_type());
1466 }
1467 
1468 bool ciMethod::is_consistent_info(ciMethod* declared_method, ciMethod* resolved_method) {
1469   bool invoke_through_mh_intrinsic = declared_method-&gt;is_method_handle_intrinsic() &amp;&amp;
1470                                   !resolved_method-&gt;is_method_handle_intrinsic();
1471 
1472   if (!invoke_through_mh_intrinsic) {
1473     // Method name &amp; descriptor should stay the same.
1474     // Signatures may reference unloaded types and thus they may be not strictly equal.
1475     ciSymbol* declared_signature = declared_method-&gt;signature()-&gt;as_symbol();
1476     ciSymbol* resolved_signature = resolved_method-&gt;signature()-&gt;as_symbol();
1477 
1478     return (declared_method-&gt;name()-&gt;equals(resolved_method-&gt;name())) &amp;&amp;
1479            (declared_signature-&gt;equals(resolved_signature));
</pre>
</td>
</tr>
</table>
<center><a href="ciMetadata.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
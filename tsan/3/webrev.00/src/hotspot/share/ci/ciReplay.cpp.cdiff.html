<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/ci/ciReplay.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjectFactory.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciSignature.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciReplay.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;ci/ciMethodData.hpp&quot;
  #include &quot;ci/ciReplay.hpp&quot;
  #include &quot;ci/ciSymbol.hpp&quot;
  #include &quot;ci/ciKlass.hpp&quot;
  #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  
  #ifndef PRODUCT
  
  // ciReplay
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,20 ***</span>
  
    // Parse a possibly quoted version of a symbol into a symbolOop
    Symbol* parse_symbol(TRAPS) {
      const char* str = parse_escaped_string();
      if (str != NULL) {
<span class="line-modified">!       Symbol* sym = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
        return sym;
      }
      return NULL;
    }
  
    // Parse a valid klass name and look it up
    Klass* parse_klass(TRAPS) {
      const char* str = parse_escaped_string();
<span class="line-modified">!     Symbol* klass_name = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
      if (klass_name != NULL) {
        Klass* k = NULL;
        if (_iklass != NULL) {
          k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
        } else {
<span class="line-new-header">--- 334,20 ---</span>
  
    // Parse a possibly quoted version of a symbol into a symbolOop
    Symbol* parse_symbol(TRAPS) {
      const char* str = parse_escaped_string();
      if (str != NULL) {
<span class="line-modified">!       Symbol* sym = SymbolTable::new_symbol(str);</span>
        return sym;
      }
      return NULL;
    }
  
    // Parse a valid klass name and look it up
    Klass* parse_klass(TRAPS) {
      const char* str = parse_escaped_string();
<span class="line-modified">!     Symbol* klass_name = SymbolTable::new_symbol(str);</span>
      if (klass_name != NULL) {
        Klass* k = NULL;
        if (_iklass != NULL) {
          k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,11 ***</span>
      return NULL;
    }
  
    // Lookup a klass
    Klass* resolve_klass(const char* klass, TRAPS) {
<span class="line-modified">!     Symbol* klass_name = SymbolTable::lookup(klass, (int)strlen(klass), CHECK_NULL);</span>
      return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
    }
  
    // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
    Method* parse_method(TRAPS) {
<span class="line-new-header">--- 369,11 ---</span>
      return NULL;
    }
  
    // Lookup a klass
    Klass* resolve_klass(const char* klass, TRAPS) {
<span class="line-modified">!     Symbol* klass_name = SymbolTable::new_symbol(klass);</span>
      return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
    }
  
    // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
    Method* parse_method(TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 528,11 ***</span>
      const char* comp_level_label = &quot;comp_level&quot;;
      int comp_level = parse_int(comp_level_label);
      // old version w/o comp_level
      if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
        // use highest available tier
<span class="line-modified">!       comp_level = TieredCompilation ? TieredStopAtLevel : CompLevel_highest_tier;</span>
      }
      if (!is_valid_comp_level(comp_level)) {
        return;
      }
      if (_imethod != NULL) {
<span class="line-new-header">--- 530,15 ---</span>
      const char* comp_level_label = &quot;comp_level&quot;;
      int comp_level = parse_int(comp_level_label);
      // old version w/o comp_level
      if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
        // use highest available tier
<span class="line-modified">!       if (TieredCompilation) {</span>
<span class="line-added">+         comp_level = TieredStopAtLevel;</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         comp_level = CompLevel_highest_tier;</span>
<span class="line-added">+       }</span>
      }
      if (!is_valid_comp_level(comp_level)) {
        return;
      }
      if (_imethod != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,11 ***</span>
      CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
      if (nm != NULL) {
        nm-&gt;make_not_entrant();
      }
      replay_state = this;
<span class="line-modified">!     CompileBroker::compile_method(method, entry_bci, comp_level,</span>
                                    methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
      replay_state = NULL;
      reset();
    }
  
<span class="line-new-header">--- 595,11 ---</span>
      CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
      if (nm != NULL) {
        nm-&gt;make_not_entrant();
      }
      replay_state = this;
<span class="line-modified">!     CompileBroker::compile_method(methodHandle(THREAD, method), entry_bci, comp_level,</span>
                                    methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
      replay_state = NULL;
      reset();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,14 ***</span>
      method-&gt;method_holder()-&gt;link_class(CHECK);
      // methodOopDesc::build_interpreter_method_data(method, CHECK);
      {
        // Grab a lock here to prevent multiple
        // MethodData*s from being created.
<span class="line-modified">!       MutexLocker ml(MethodData_lock, THREAD);</span>
        if (method-&gt;method_data() == NULL) {
          ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
<span class="line-modified">!         MethodData* method_data = MethodData::allocate(loader_data, method, CHECK);</span>
          method-&gt;set_method_data(method_data);
        }
      }
  
      // collect and record all the needed information for later
<span class="line-new-header">--- 629,14 ---</span>
      method-&gt;method_holder()-&gt;link_class(CHECK);
      // methodOopDesc::build_interpreter_method_data(method, CHECK);
      {
        // Grab a lock here to prevent multiple
        // MethodData*s from being created.
<span class="line-modified">!       MutexLocker ml(THREAD, MethodData_lock);</span>
        if (method-&gt;method_data() == NULL) {
          ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
<span class="line-modified">!         MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);</span>
          method-&gt;set_method_data(method_data);
        }
      }
  
      // collect and record all the needed information for later
</pre>
<hr />
<pre>
<span class="line-old-header">*** 796,32 ***</span>
      assert(k-&gt;is_initialized(), &quot;must be&quot;);
  
      const char* field_name = parse_escaped_string();
      const char* field_signature = parse_string();
      fieldDescriptor fd;
<span class="line-modified">!     Symbol* name = SymbolTable::lookup(field_name, (int)strlen(field_name), CHECK);</span>
<span class="line-modified">!     Symbol* sig = SymbolTable::lookup(field_signature, (int)strlen(field_signature), CHECK);</span>
      if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
          !fd.is_static() ||
          fd.has_initial_value()) {
        report_error(field_name);
        return;
      }
  
      oop java_mirror = k-&gt;java_mirror();
<span class="line-modified">!     if (field_signature[0] == &#39;[&#39;) {</span>
        int length = parse_int(&quot;array length&quot;);
        oop value = NULL;
  
<span class="line-modified">!       if (field_signature[1] == &#39;[&#39;) {</span>
          // multi dimensional array
          ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
          if (kelem == NULL) {
            return;
          }
          int rank = 0;
<span class="line-modified">!         while (field_signature[rank] == &#39;[&#39;) {</span>
            rank++;
          }
          jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
          dims[0] = length;
          for (int i = 1; i &lt; rank; i++) {
<span class="line-new-header">--- 802,32 ---</span>
      assert(k-&gt;is_initialized(), &quot;must be&quot;);
  
      const char* field_name = parse_escaped_string();
      const char* field_signature = parse_string();
      fieldDescriptor fd;
<span class="line-modified">!     Symbol* name = SymbolTable::new_symbol(field_name);</span>
<span class="line-modified">!     Symbol* sig = SymbolTable::new_symbol(field_signature);</span>
      if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
          !fd.is_static() ||
          fd.has_initial_value()) {
        report_error(field_name);
        return;
      }
  
      oop java_mirror = k-&gt;java_mirror();
<span class="line-modified">!     if (field_signature[0] == JVM_SIGNATURE_ARRAY) {</span>
        int length = parse_int(&quot;array length&quot;);
        oop value = NULL;
  
<span class="line-modified">!       if (field_signature[1] == JVM_SIGNATURE_ARRAY) {</span>
          // multi dimensional array
          ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
          if (kelem == NULL) {
            return;
          }
          int rank = 0;
<span class="line-modified">!         while (field_signature[rank] == JVM_SIGNATURE_ARRAY) {</span>
            rank++;
          }
          jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
          dims[0] = length;
          for (int i = 1; i &lt; rank; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 843,11 ***</span>
            value = oopFactory::new_doubleArray(length, CHECK);
          } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
            value = oopFactory::new_intArray(length, CHECK);
          } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
            value = oopFactory::new_longArray(length, CHECK);
<span class="line-modified">!         } else if (field_signature[0] == &#39;[&#39; &amp;&amp; field_signature[1] == &#39;L&#39;) {</span>
            Klass* kelem = resolve_klass(field_signature + 1, CHECK);
            value = oopFactory::new_objArray(kelem, length, CHECK);
          } else {
            report_error(&quot;unhandled array staticfield&quot;);
          }
<span class="line-new-header">--- 849,12 ---</span>
            value = oopFactory::new_doubleArray(length, CHECK);
          } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
            value = oopFactory::new_intArray(length, CHECK);
          } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
            value = oopFactory::new_longArray(length, CHECK);
<span class="line-modified">!         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">+                    field_signature[1] == JVM_SIGNATURE_CLASS) {</span>
            Klass* kelem = resolve_klass(field_signature + 1, CHECK);
            value = oopFactory::new_objArray(kelem, length, CHECK);
          } else {
            report_error(&quot;unhandled array staticfield&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,11 ***</span>
          double value = atof(string_value);
          java_mirror-&gt;double_field_put(fd.offset(), value);
        } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
          Handle value = java_lang_String::create_from_str(string_value, CHECK);
          java_mirror-&gt;obj_field_put(fd.offset(), value());
<span class="line-modified">!       } else if (field_signature[0] == &#39;L&#39;) {</span>
          Klass* k = resolve_klass(string_value, CHECK);
          oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
          java_mirror-&gt;obj_field_put(fd.offset(), value);
        } else {
          report_error(&quot;unhandled staticfield&quot;);
<span class="line-new-header">--- 891,11 ---</span>
          double value = atof(string_value);
          java_mirror-&gt;double_field_put(fd.offset(), value);
        } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
          Handle value = java_lang_String::create_from_str(string_value, CHECK);
          java_mirror-&gt;obj_field_put(fd.offset(), value());
<span class="line-modified">!       } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {</span>
          Klass* k = resolve_klass(string_value, CHECK);
          oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
          java_mirror-&gt;obj_field_put(fd.offset(), value);
        } else {
          report_error(&quot;unhandled staticfield&quot;);
</pre>
<center><a href="ciObjectFactory.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciSignature.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciReplay.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;ci/ciSymbol.hpp&quot;
  30 #include &quot;ci/ciKlass.hpp&quot;
  31 #include &quot;ci/ciUtilities.inline.hpp&quot;
<a name="2" id="anc2"></a>
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/constantPool.hpp&quot;
  37 #include &quot;oops/method.inline.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  40 #include &quot;runtime/handles.inline.hpp&quot;
  41 #include &quot;utilities/copy.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
<a name="3" id="anc3"></a>
  43 
  44 #ifndef PRODUCT
  45 
  46 // ciReplay
  47 
  48 typedef struct _ciMethodDataRecord {
  49   const char* _klass_name;
  50   const char* _method_name;
  51   const char* _signature;
  52 
  53   int _state;
  54   int _current_mileage;
  55 
  56   intptr_t* _data;
  57   char*     _orig_data;
  58   Klass**   _classes;
  59   Method**  _methods;
  60   int*      _classes_offsets;
  61   int*      _methods_offsets;
  62   int       _data_length;
  63   int       _orig_data_length;
  64   int       _classes_length;
  65   int       _methods_length;
  66 } ciMethodDataRecord;
  67 
  68 typedef struct _ciMethodRecord {
  69   const char* _klass_name;
  70   const char* _method_name;
  71   const char* _signature;
  72 
  73   int _instructions_size;
  74   int _interpreter_invocation_count;
  75   int _interpreter_throwout_count;
  76   int _invocation_counter;
  77   int _backedge_counter;
  78 } ciMethodRecord;
  79 
  80 typedef struct _ciInlineRecord {
  81   const char* _klass_name;
  82   const char* _method_name;
  83   const char* _signature;
  84 
  85   int _inline_depth;
  86   int _inline_bci;
  87 } ciInlineRecord;
  88 
  89 class  CompileReplay;
  90 static CompileReplay* replay_state;
  91 
  92 class CompileReplay : public StackObj {
  93  private:
  94   FILE*   _stream;
  95   Thread* _thread;
  96   Handle  _protection_domain;
  97   Handle  _loader;
  98 
  99   GrowableArray&lt;ciMethodRecord*&gt;     _ci_method_records;
 100   GrowableArray&lt;ciMethodDataRecord*&gt; _ci_method_data_records;
 101 
 102   // Use pointer because we may need to return inline records
 103   // without destroying them.
 104   GrowableArray&lt;ciInlineRecord*&gt;*    _ci_inline_records;
 105 
 106   const char* _error_message;
 107 
 108   char* _bufptr;
 109   char* _buffer;
 110   int   _buffer_length;
 111   int   _buffer_pos;
 112 
 113   // &quot;compile&quot; data
 114   ciKlass* _iklass;
 115   Method*  _imethod;
 116   int      _entry_bci;
 117   int      _comp_level;
 118 
 119  public:
 120   CompileReplay(const char* filename, TRAPS) {
 121     _thread = THREAD;
 122     _loader = Handle(_thread, SystemDictionary::java_system_loader());
 123     _protection_domain = Handle();
 124 
 125     _stream = fopen(filename, &quot;rt&quot;);
 126     if (_stream == NULL) {
 127       fprintf(stderr, &quot;ERROR: Can&#39;t open replay file %s\n&quot;, filename);
 128     }
 129 
 130     _ci_inline_records = NULL;
 131     _error_message = NULL;
 132 
 133     _buffer_length = 32;
 134     _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);
 135     _bufptr = _buffer;
 136     _buffer_pos = 0;
 137 
 138     _imethod = NULL;
 139     _iklass  = NULL;
 140     _entry_bci  = 0;
 141     _comp_level = 0;
 142 
 143     test();
 144   }
 145 
 146   ~CompileReplay() {
 147     if (_stream != NULL) fclose(_stream);
 148   }
 149 
 150   void test() {
 151     strcpy(_buffer, &quot;1 2 foo 4 bar 0x9 \&quot;this is it\&quot;&quot;);
 152     _bufptr = _buffer;
 153     assert(parse_int(&quot;test&quot;) == 1, &quot;what&quot;);
 154     assert(parse_int(&quot;test&quot;) == 2, &quot;what&quot;);
 155     assert(strcmp(parse_string(), &quot;foo&quot;) == 0, &quot;what&quot;);
 156     assert(parse_int(&quot;test&quot;) == 4, &quot;what&quot;);
 157     assert(strcmp(parse_string(), &quot;bar&quot;) == 0, &quot;what&quot;);
 158     assert(parse_intptr_t(&quot;test&quot;) == 9, &quot;what&quot;);
 159     assert(strcmp(parse_quoted_string(), &quot;this is it&quot;) == 0, &quot;what&quot;);
 160   }
 161 
 162   bool had_error() {
 163     return _error_message != NULL || _thread-&gt;has_pending_exception();
 164   }
 165 
 166   bool can_replay() {
 167     return !(_stream == NULL || had_error());
 168   }
 169 
 170   void report_error(const char* msg) {
 171     _error_message = msg;
 172     // Restore the _buffer contents for error reporting
 173     for (int i = 0; i &lt; _buffer_pos; i++) {
 174       if (_buffer[i] == &#39;\0&#39;) _buffer[i] = &#39; &#39;;
 175     }
 176   }
 177 
 178   int parse_int(const char* label) {
 179     if (had_error()) {
 180       return 0;
 181     }
 182 
 183     int v = 0;
 184     int read;
 185     if (sscanf(_bufptr, &quot;%i%n&quot;, &amp;v, &amp;read) != 1) {
 186       report_error(label);
 187     } else {
 188       _bufptr += read;
 189     }
 190     return v;
 191   }
 192 
 193   intptr_t parse_intptr_t(const char* label) {
 194     if (had_error()) {
 195       return 0;
 196     }
 197 
 198     intptr_t v = 0;
 199     int read;
 200     if (sscanf(_bufptr, INTPTR_FORMAT &quot;%n&quot;, &amp;v, &amp;read) != 1) {
 201       report_error(label);
 202     } else {
 203       _bufptr += read;
 204     }
 205     return v;
 206   }
 207 
 208   void skip_ws() {
 209     // Skip any leading whitespace
 210     while (*_bufptr == &#39; &#39; || *_bufptr == &#39;\t&#39;) {
 211       _bufptr++;
 212     }
 213   }
 214 
 215 
 216   char* scan_and_terminate(char delim) {
 217     char* str = _bufptr;
 218     while (*_bufptr != delim &amp;&amp; *_bufptr != &#39;\0&#39;) {
 219       _bufptr++;
 220     }
 221     if (*_bufptr != &#39;\0&#39;) {
 222       *_bufptr++ = &#39;\0&#39;;
 223     }
 224     if (_bufptr == str) {
 225       // nothing here
 226       return NULL;
 227     }
 228     return str;
 229   }
 230 
 231   char* parse_string() {
 232     if (had_error()) return NULL;
 233 
 234     skip_ws();
 235     return scan_and_terminate(&#39; &#39;);
 236   }
 237 
 238   char* parse_quoted_string() {
 239     if (had_error()) return NULL;
 240 
 241     skip_ws();
 242 
 243     if (*_bufptr == &#39;&quot;&#39;) {
 244       _bufptr++;
 245       return scan_and_terminate(&#39;&quot;&#39;);
 246     } else {
 247       return scan_and_terminate(&#39; &#39;);
 248     }
 249   }
 250 
 251   const char* parse_escaped_string() {
 252     char* result = parse_quoted_string();
 253     if (result != NULL) {
 254       unescape_string(result);
 255     }
 256     return result;
 257   }
 258 
 259   // Look for the tag &#39;tag&#39; followed by an
 260   bool parse_tag_and_count(const char* tag, int&amp; length) {
 261     const char* t = parse_string();
 262     if (t == NULL) {
 263       return false;
 264     }
 265 
 266     if (strcmp(tag, t) != 0) {
 267       report_error(tag);
 268       return false;
 269     }
 270     length = parse_int(&quot;parse_tag_and_count&quot;);
 271     return !had_error();
 272   }
 273 
 274   // Parse a sequence of raw data encoded as bytes and return the
 275   // resulting data.
 276   char* parse_data(const char* tag, int&amp; length) {
 277     int read_size = 0;
 278     if (!parse_tag_and_count(tag, read_size)) {
 279       return NULL;
 280     }
 281 
 282     int actual_size = sizeof(MethodData);
 283     char *result = NEW_RESOURCE_ARRAY(char, actual_size);
 284     int i = 0;
 285     if (read_size != actual_size) {
 286       tty-&gt;print_cr(&quot;Warning: ciMethodData parsing sees MethodData size %i in file, current is %i&quot;, read_size,
 287                     actual_size);
 288       // Replay serializes the entire MethodData, but the data is at the end.
 289       // If the MethodData instance size has changed, we can pad or truncate in the beginning
 290       int padding = actual_size - read_size;
 291       if (padding &gt; 0) {
 292         // pad missing data with zeros
 293         tty-&gt;print_cr(&quot;- Padding MethodData&quot;);
 294         for (; i &lt; padding; i++) {
 295           result[i] = 0;
 296         }
 297       } else if (padding &lt; 0) {
 298         // drop some data
 299         tty-&gt;print_cr(&quot;- Truncating MethodData&quot;);
 300         for (int j = 0; j &lt; -padding; j++) {
 301           int val = parse_int(&quot;data&quot;);
 302           // discard val
 303         }
 304       }
 305     }
 306 
 307     assert(i &lt; actual_size, &quot;At least some data must remain to be copied&quot;);
 308     for (; i &lt; actual_size; i++) {
 309       int val = parse_int(&quot;data&quot;);
 310       result[i] = val;
 311     }
 312     length = actual_size;
 313     return result;
 314   }
 315 
 316   // Parse a standard chunk of data emitted as:
 317   //   &#39;tag&#39; &lt;length&gt; # # ...
 318   // Where each # is an intptr_t item
 319   intptr_t* parse_intptr_data(const char* tag, int&amp; length) {
 320     if (!parse_tag_and_count(tag, length)) {
 321       return NULL;
 322     }
 323 
 324     intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
 325     for (int i = 0; i &lt; length; i++) {
 326       skip_ws();
 327       intptr_t val = parse_intptr_t(&quot;data&quot;);
 328       result[i] = val;
 329     }
 330     return result;
 331   }
 332 
 333   // Parse a possibly quoted version of a symbol into a symbolOop
 334   Symbol* parse_symbol(TRAPS) {
 335     const char* str = parse_escaped_string();
 336     if (str != NULL) {
<a name="4" id="anc4"></a><span class="line-modified"> 337       Symbol* sym = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
 338       return sym;
 339     }
 340     return NULL;
 341   }
 342 
 343   // Parse a valid klass name and look it up
 344   Klass* parse_klass(TRAPS) {
 345     const char* str = parse_escaped_string();
<a name="5" id="anc5"></a><span class="line-modified"> 346     Symbol* klass_name = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
 347     if (klass_name != NULL) {
 348       Klass* k = NULL;
 349       if (_iklass != NULL) {
 350         k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
 351       } else {
 352         k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 353       }
 354       if (HAS_PENDING_EXCEPTION) {
 355         oop throwable = PENDING_EXCEPTION;
 356         java_lang_Throwable::print(throwable, tty);
 357         tty-&gt;cr();
 358         report_error(str);
 359         if (ReplayIgnoreInitErrors) {
 360           CLEAR_PENDING_EXCEPTION;
 361           _error_message = NULL;
 362         }
 363         return NULL;
 364       }
 365       return k;
 366     }
 367     return NULL;
 368   }
 369 
 370   // Lookup a klass
 371   Klass* resolve_klass(const char* klass, TRAPS) {
<a name="6" id="anc6"></a><span class="line-modified"> 372     Symbol* klass_name = SymbolTable::lookup(klass, (int)strlen(klass), CHECK_NULL);</span>
 373     return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 374   }
 375 
 376   // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
 377   Method* parse_method(TRAPS) {
 378     InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
 379     if (k == NULL) {
 380       report_error(&quot;Can&#39;t find holder klass&quot;);
 381       return NULL;
 382     }
 383     Symbol* method_name = parse_symbol(CHECK_NULL);
 384     Symbol* method_signature = parse_symbol(CHECK_NULL);
 385     Method* m = k-&gt;find_method(method_name, method_signature);
 386     if (m == NULL) {
 387       report_error(&quot;Can&#39;t find method&quot;);
 388     }
 389     return m;
 390   }
 391 
 392   int get_line(int c) {
 393     while(c != EOF) {
 394       if (_buffer_pos + 1 &gt;= _buffer_length) {
 395         int new_length = _buffer_length * 2;
 396         // Next call will throw error in case of OOM.
 397         _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);
 398         _buffer_length = new_length;
 399       }
 400       if (c == &#39;\n&#39;) {
 401         c = getc(_stream); // get next char
 402         break;
 403       } else if (c == &#39;\r&#39;) {
 404         // skip LF
 405       } else {
 406         _buffer[_buffer_pos++] = c;
 407       }
 408       c = getc(_stream);
 409     }
 410     // null terminate it, reset the pointer
 411     _buffer[_buffer_pos] = &#39;\0&#39;; // NL or EOF
 412     _buffer_pos = 0;
 413     _bufptr = _buffer;
 414     return c;
 415   }
 416 
 417   // Process each line of the replay file executing each command until
 418   // the file ends.
 419   void process(TRAPS) {
 420     int line_no = 1;
 421     int c = getc(_stream);
 422     while(c != EOF) {
 423       c = get_line(c);
 424       process_command(THREAD);
 425       if (had_error()) {
 426         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 427         if (ReplayIgnoreInitErrors) {
 428           CLEAR_PENDING_EXCEPTION;
 429           _error_message = NULL;
 430         } else {
 431           return;
 432         }
 433       }
 434       line_no++;
 435     }
 436   }
 437 
 438   void process_command(TRAPS) {
 439     char* cmd = parse_string();
 440     if (cmd == NULL) {
 441       return;
 442     }
 443     if (strcmp(&quot;#&quot;, cmd) == 0) {
 444       // ignore
 445     } else if (strcmp(&quot;compile&quot;, cmd) == 0) {
 446       process_compile(CHECK);
 447     } else if (strcmp(&quot;ciMethod&quot;, cmd) == 0) {
 448       process_ciMethod(CHECK);
 449     } else if (strcmp(&quot;ciMethodData&quot;, cmd) == 0) {
 450       process_ciMethodData(CHECK);
 451     } else if (strcmp(&quot;staticfield&quot;, cmd) == 0) {
 452       process_staticfield(CHECK);
 453     } else if (strcmp(&quot;ciInstanceKlass&quot;, cmd) == 0) {
 454       process_ciInstanceKlass(CHECK);
 455     } else if (strcmp(&quot;instanceKlass&quot;, cmd) == 0) {
 456       process_instanceKlass(CHECK);
 457 #if INCLUDE_JVMTI
 458     } else if (strcmp(&quot;JvmtiExport&quot;, cmd) == 0) {
 459       process_JvmtiExport(CHECK);
 460 #endif // INCLUDE_JVMTI
 461     } else {
 462       report_error(&quot;unknown command&quot;);
 463     }
 464   }
 465 
 466   // validation of comp_level
 467   bool is_valid_comp_level(int comp_level) {
 468     const int msg_len = 256;
 469     char* msg = NULL;
 470     if (!is_compile(comp_level)) {
 471       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 472       jio_snprintf(msg, msg_len, &quot;%d isn&#39;t compilation level&quot;, comp_level);
 473     } else if (!TieredCompilation &amp;&amp; (comp_level != CompLevel_highest_tier)) {
 474       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 475       switch (comp_level) {
 476         case CompLevel_simple:
 477           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Client VM or TieredCompilation&quot;, comp_level);
 478           break;
 479         case CompLevel_full_optimization:
 480           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Server VM&quot;, comp_level);
 481           break;
 482         default:
 483           jio_snprintf(msg, msg_len, &quot;compilation level %d requires TieredCompilation&quot;, comp_level);
 484       }
 485     }
 486     if (msg != NULL) {
 487       report_error(msg);
 488       return false;
 489     }
 490     return true;
 491   }
 492 
 493   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 494   void* process_inline(ciMethod* imethod, Method* m, int entry_bci, int comp_level, TRAPS) {
 495     _imethod    = m;
 496     _iklass     = imethod-&gt;holder();
 497     _entry_bci  = entry_bci;
 498     _comp_level = comp_level;
 499     int line_no = 1;
 500     int c = getc(_stream);
 501     while(c != EOF) {
 502       c = get_line(c);
 503       // Expecting only lines with &quot;compile&quot; command in inline replay file.
 504       char* cmd = parse_string();
 505       if (cmd == NULL || strcmp(&quot;compile&quot;, cmd) != 0) {
 506         return NULL;
 507       }
 508       process_compile(CHECK_NULL);
 509       if (had_error()) {
 510         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 511         tty-&gt;print_cr(&quot;%s&quot;, _buffer);
 512         return NULL;
 513       }
 514       if (_ci_inline_records != NULL &amp;&amp; _ci_inline_records-&gt;length() &gt; 0) {
 515         // Found inlining record for the requested method.
 516         return _ci_inline_records;
 517       }
 518       line_no++;
 519     }
 520     return NULL;
 521   }
 522 
 523   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 524   void process_compile(TRAPS) {
 525     Method* method = parse_method(CHECK);
 526     if (had_error()) return;
 527     int entry_bci = parse_int(&quot;entry_bci&quot;);
 528     const char* comp_level_label = &quot;comp_level&quot;;
 529     int comp_level = parse_int(comp_level_label);
 530     // old version w/o comp_level
 531     if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
 532       // use highest available tier
<a name="7" id="anc7"></a><span class="line-modified"> 533       comp_level = TieredCompilation ? TieredStopAtLevel : CompLevel_highest_tier;</span>




 534     }
 535     if (!is_valid_comp_level(comp_level)) {
 536       return;
 537     }
 538     if (_imethod != NULL) {
 539       // Replay Inlining
 540       if (entry_bci != _entry_bci || comp_level != _comp_level) {
 541         return;
 542       }
 543       const char* iklass_name  = _imethod-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 544       const char* imethod_name = _imethod-&gt;name()-&gt;as_utf8();
 545       const char* isignature   = _imethod-&gt;signature()-&gt;as_utf8();
 546       const char* klass_name   = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 547       const char* method_name  = method-&gt;name()-&gt;as_utf8();
 548       const char* signature    = method-&gt;signature()-&gt;as_utf8();
 549       if (strcmp(iklass_name,  klass_name)  != 0 ||
 550           strcmp(imethod_name, method_name) != 0 ||
 551           strcmp(isignature,   signature)   != 0) {
 552         return;
 553       }
 554     }
 555     int inline_count = 0;
 556     if (parse_tag_and_count(&quot;inline&quot;, inline_count)) {
 557       // Record inlining data
 558       _ci_inline_records = new GrowableArray&lt;ciInlineRecord*&gt;();
 559       for (int i = 0; i &lt; inline_count; i++) {
 560         int depth = parse_int(&quot;inline_depth&quot;);
 561         int bci = parse_int(&quot;inline_bci&quot;);
 562         if (had_error()) {
 563           break;
 564         }
 565         Method* inl_method = parse_method(CHECK);
 566         if (had_error()) {
 567           break;
 568         }
 569         new_ciInlineRecord(inl_method, bci, depth);
 570       }
 571     }
 572     if (_imethod != NULL) {
 573       return; // Replay Inlining
 574     }
 575     InstanceKlass* ik = method-&gt;method_holder();
 576     ik-&gt;initialize(THREAD);
 577     if (HAS_PENDING_EXCEPTION) {
 578       oop throwable = PENDING_EXCEPTION;
 579       java_lang_Throwable::print(throwable, tty);
 580       tty-&gt;cr();
 581       if (ReplayIgnoreInitErrors) {
 582         CLEAR_PENDING_EXCEPTION;
 583         ik-&gt;set_init_state(InstanceKlass::fully_initialized);
 584       } else {
 585         return;
 586       }
 587     }
 588     // Make sure the existence of a prior compile doesn&#39;t stop this one
 589     CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
 590     if (nm != NULL) {
 591       nm-&gt;make_not_entrant();
 592     }
 593     replay_state = this;
<a name="8" id="anc8"></a><span class="line-modified"> 594     CompileBroker::compile_method(method, entry_bci, comp_level,</span>
 595                                   methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
 596     replay_state = NULL;
 597     reset();
 598   }
 599 
 600   // ciMethod &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;invocation_counter&gt; &lt;backedge_counter&gt; &lt;interpreter_invocation_count&gt; &lt;interpreter_throwout_count&gt; &lt;instructions_size&gt;
 601   //
 602   //
 603   void process_ciMethod(TRAPS) {
 604     Method* method = parse_method(CHECK);
 605     if (had_error()) return;
 606     ciMethodRecord* rec = new_ciMethod(method);
 607     rec-&gt;_invocation_counter = parse_int(&quot;invocation_counter&quot;);
 608     rec-&gt;_backedge_counter = parse_int(&quot;backedge_counter&quot;);
 609     rec-&gt;_interpreter_invocation_count = parse_int(&quot;interpreter_invocation_count&quot;);
 610     rec-&gt;_interpreter_throwout_count = parse_int(&quot;interpreter_throwout_count&quot;);
 611     rec-&gt;_instructions_size = parse_int(&quot;instructions_size&quot;);
 612   }
 613 
 614   // ciMethodData &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;state&gt; &lt;current mileage&gt; orig &lt;length&gt; # # ... data &lt;length&gt; # # ... oops &lt;length&gt; # ... methods &lt;length&gt;
 615   void process_ciMethodData(TRAPS) {
 616     Method* method = parse_method(CHECK);
 617     if (had_error()) return;
 618     /* just copied from Method, to build interpret data*/
 619 
 620     // To be properly initialized, some profiling in the MDO needs the
 621     // method to be rewritten (number of arguments at a call for
 622     // instance)
 623     method-&gt;method_holder()-&gt;link_class(CHECK);
 624     // methodOopDesc::build_interpreter_method_data(method, CHECK);
 625     {
 626       // Grab a lock here to prevent multiple
 627       // MethodData*s from being created.
<a name="9" id="anc9"></a><span class="line-modified"> 628       MutexLocker ml(MethodData_lock, THREAD);</span>
 629       if (method-&gt;method_data() == NULL) {
 630         ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
<a name="10" id="anc10"></a><span class="line-modified"> 631         MethodData* method_data = MethodData::allocate(loader_data, method, CHECK);</span>
 632         method-&gt;set_method_data(method_data);
 633       }
 634     }
 635 
 636     // collect and record all the needed information for later
 637     ciMethodDataRecord* rec = new_ciMethodData(method);
 638     rec-&gt;_state = parse_int(&quot;state&quot;);
 639     rec-&gt;_current_mileage = parse_int(&quot;current_mileage&quot;);
 640 
 641     rec-&gt;_orig_data = parse_data(&quot;orig&quot;, rec-&gt;_orig_data_length);
 642     if (rec-&gt;_orig_data == NULL) {
 643       return;
 644     }
 645     rec-&gt;_data = parse_intptr_data(&quot;data&quot;, rec-&gt;_data_length);
 646     if (rec-&gt;_data == NULL) {
 647       return;
 648     }
 649     if (!parse_tag_and_count(&quot;oops&quot;, rec-&gt;_classes_length)) {
 650       return;
 651     }
 652     rec-&gt;_classes = NEW_RESOURCE_ARRAY(Klass*, rec-&gt;_classes_length);
 653     rec-&gt;_classes_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_classes_length);
 654     for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
 655       int offset = parse_int(&quot;offset&quot;);
 656       if (had_error()) {
 657         return;
 658       }
 659       Klass* k = parse_klass(CHECK);
 660       rec-&gt;_classes_offsets[i] = offset;
 661       rec-&gt;_classes[i] = k;
 662     }
 663 
 664     if (!parse_tag_and_count(&quot;methods&quot;, rec-&gt;_methods_length)) {
 665       return;
 666     }
 667     rec-&gt;_methods = NEW_RESOURCE_ARRAY(Method*, rec-&gt;_methods_length);
 668     rec-&gt;_methods_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_methods_length);
 669     for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
 670       int offset = parse_int(&quot;offset&quot;);
 671       if (had_error()) {
 672         return;
 673       }
 674       Method* m = parse_method(CHECK);
 675       rec-&gt;_methods_offsets[i] = offset;
 676       rec-&gt;_methods[i] = m;
 677     }
 678   }
 679 
 680   // instanceKlass &lt;name&gt;
 681   //
 682   // Loads and initializes the klass &#39;name&#39;.  This can be used to
 683   // create particular class loading environments
 684   void process_instanceKlass(TRAPS) {
 685     // just load the referenced class
 686     Klass* k = parse_klass(CHECK);
 687   }
 688 
 689   // ciInstanceKlass &lt;name&gt; &lt;is_linked&gt; &lt;is_initialized&gt; &lt;length&gt; tag # # # ...
 690   //
 691   // Load the klass &#39;name&#39; and link or initialize it.  Verify that the
 692   // constant pool is the same length as &#39;length&#39; and make sure the
 693   // constant pool tags are in the same state.
 694   void process_ciInstanceKlass(TRAPS) {
 695     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 696     if (k == NULL) {
 697       return;
 698     }
 699     int is_linked = parse_int(&quot;is_linked&quot;);
 700     int is_initialized = parse_int(&quot;is_initialized&quot;);
 701     int length = parse_int(&quot;length&quot;);
 702     if (is_initialized) {
 703       k-&gt;initialize(THREAD);
 704       if (HAS_PENDING_EXCEPTION) {
 705         oop throwable = PENDING_EXCEPTION;
 706         java_lang_Throwable::print(throwable, tty);
 707         tty-&gt;cr();
 708         if (ReplayIgnoreInitErrors) {
 709           CLEAR_PENDING_EXCEPTION;
 710           k-&gt;set_init_state(InstanceKlass::fully_initialized);
 711         } else {
 712           return;
 713         }
 714       }
 715     } else if (is_linked) {
 716       k-&gt;link_class(CHECK);
 717     }
 718     ConstantPool* cp = k-&gt;constants();
 719     if (length != cp-&gt;length()) {
 720       report_error(&quot;constant pool length mismatch: wrong class files?&quot;);
 721       return;
 722     }
 723 
 724     int parsed_two_word = 0;
 725     for (int i = 1; i &lt; length; i++) {
 726       int tag = parse_int(&quot;tag&quot;);
 727       if (had_error()) {
 728         return;
 729       }
 730       switch (cp-&gt;tag_at(i).value()) {
 731         case JVM_CONSTANT_UnresolvedClass: {
 732           if (tag == JVM_CONSTANT_Class) {
 733             tty-&gt;print_cr(&quot;Resolving klass %s at %d&quot;, cp-&gt;klass_name_at(i)-&gt;as_utf8(), i);
 734             Klass* k = cp-&gt;klass_at(i, CHECK);
 735           }
 736           break;
 737         }
 738         case JVM_CONSTANT_Long:
 739         case JVM_CONSTANT_Double:
 740           parsed_two_word = i + 1;
 741 
 742         case JVM_CONSTANT_ClassIndex:
 743         case JVM_CONSTANT_StringIndex:
 744         case JVM_CONSTANT_String:
 745         case JVM_CONSTANT_UnresolvedClassInError:
 746         case JVM_CONSTANT_Fieldref:
 747         case JVM_CONSTANT_Methodref:
 748         case JVM_CONSTANT_InterfaceMethodref:
 749         case JVM_CONSTANT_NameAndType:
 750         case JVM_CONSTANT_Utf8:
 751         case JVM_CONSTANT_Integer:
 752         case JVM_CONSTANT_Float:
 753         case JVM_CONSTANT_MethodHandle:
 754         case JVM_CONSTANT_MethodType:
 755         case JVM_CONSTANT_Dynamic:
 756         case JVM_CONSTANT_InvokeDynamic:
 757           if (tag != cp-&gt;tag_at(i).value()) {
 758             report_error(&quot;tag mismatch: wrong class files?&quot;);
 759             return;
 760           }
 761           break;
 762 
 763         case JVM_CONSTANT_Class:
 764           if (tag == JVM_CONSTANT_Class) {
 765           } else if (tag == JVM_CONSTANT_UnresolvedClass) {
 766             tty-&gt;print_cr(&quot;Warning: entry was unresolved in the replay data&quot;);
 767           } else {
 768             report_error(&quot;Unexpected tag&quot;);
 769             return;
 770           }
 771           break;
 772 
 773         case 0:
 774           if (parsed_two_word == i) continue;
 775 
 776         default:
 777           fatal(&quot;Unexpected tag: %d&quot;, cp-&gt;tag_at(i).value());
 778           break;
 779       }
 780 
 781     }
 782   }
 783 
 784   // Initialize a class and fill in the value for a static field.
 785   // This is useful when the compile was dependent on the value of
 786   // static fields but it&#39;s impossible to properly rerun the static
 787   // initiailizer.
 788   void process_staticfield(TRAPS) {
 789     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 790 
 791     if (k == NULL || ReplaySuppressInitializers == 0 ||
 792         (ReplaySuppressInitializers == 2 &amp;&amp; k-&gt;class_loader() == NULL)) {
 793       return;
 794     }
 795 
 796     assert(k-&gt;is_initialized(), &quot;must be&quot;);
 797 
 798     const char* field_name = parse_escaped_string();
 799     const char* field_signature = parse_string();
 800     fieldDescriptor fd;
<a name="11" id="anc11"></a><span class="line-modified"> 801     Symbol* name = SymbolTable::lookup(field_name, (int)strlen(field_name), CHECK);</span>
<span class="line-modified"> 802     Symbol* sig = SymbolTable::lookup(field_signature, (int)strlen(field_signature), CHECK);</span>
 803     if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
 804         !fd.is_static() ||
 805         fd.has_initial_value()) {
 806       report_error(field_name);
 807       return;
 808     }
 809 
 810     oop java_mirror = k-&gt;java_mirror();
<a name="12" id="anc12"></a><span class="line-modified"> 811     if (field_signature[0] == &#39;[&#39;) {</span>
 812       int length = parse_int(&quot;array length&quot;);
 813       oop value = NULL;
 814 
<a name="13" id="anc13"></a><span class="line-modified"> 815       if (field_signature[1] == &#39;[&#39;) {</span>
 816         // multi dimensional array
 817         ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
 818         if (kelem == NULL) {
 819           return;
 820         }
 821         int rank = 0;
<a name="14" id="anc14"></a><span class="line-modified"> 822         while (field_signature[rank] == &#39;[&#39;) {</span>
 823           rank++;
 824         }
 825         jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
 826         dims[0] = length;
 827         for (int i = 1; i &lt; rank; i++) {
 828           dims[i] = 1; // These aren&#39;t relevant to the compiler
 829         }
 830         value = kelem-&gt;multi_allocate(rank, dims, CHECK);
 831       } else {
 832         if (strcmp(field_signature, &quot;[B&quot;) == 0) {
 833           value = oopFactory::new_byteArray(length, CHECK);
 834         } else if (strcmp(field_signature, &quot;[Z&quot;) == 0) {
 835           value = oopFactory::new_boolArray(length, CHECK);
 836         } else if (strcmp(field_signature, &quot;[C&quot;) == 0) {
 837           value = oopFactory::new_charArray(length, CHECK);
 838         } else if (strcmp(field_signature, &quot;[S&quot;) == 0) {
 839           value = oopFactory::new_shortArray(length, CHECK);
 840         } else if (strcmp(field_signature, &quot;[F&quot;) == 0) {
 841           value = oopFactory::new_floatArray(length, CHECK);
 842         } else if (strcmp(field_signature, &quot;[D&quot;) == 0) {
 843           value = oopFactory::new_doubleArray(length, CHECK);
 844         } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
 845           value = oopFactory::new_intArray(length, CHECK);
 846         } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
 847           value = oopFactory::new_longArray(length, CHECK);
<a name="15" id="anc15"></a><span class="line-modified"> 848         } else if (field_signature[0] == &#39;[&#39; &amp;&amp; field_signature[1] == &#39;L&#39;) {</span>

 849           Klass* kelem = resolve_klass(field_signature + 1, CHECK);
 850           value = oopFactory::new_objArray(kelem, length, CHECK);
 851         } else {
 852           report_error(&quot;unhandled array staticfield&quot;);
 853         }
 854       }
 855       java_mirror-&gt;obj_field_put(fd.offset(), value);
 856     } else {
 857       const char* string_value = parse_escaped_string();
 858       if (strcmp(field_signature, &quot;I&quot;) == 0) {
 859         int value = atoi(string_value);
 860         java_mirror-&gt;int_field_put(fd.offset(), value);
 861       } else if (strcmp(field_signature, &quot;B&quot;) == 0) {
 862         int value = atoi(string_value);
 863         java_mirror-&gt;byte_field_put(fd.offset(), value);
 864       } else if (strcmp(field_signature, &quot;C&quot;) == 0) {
 865         int value = atoi(string_value);
 866         java_mirror-&gt;char_field_put(fd.offset(), value);
 867       } else if (strcmp(field_signature, &quot;S&quot;) == 0) {
 868         int value = atoi(string_value);
 869         java_mirror-&gt;short_field_put(fd.offset(), value);
 870       } else if (strcmp(field_signature, &quot;Z&quot;) == 0) {
 871         int value = atoi(string_value);
 872         java_mirror-&gt;bool_field_put(fd.offset(), value);
 873       } else if (strcmp(field_signature, &quot;J&quot;) == 0) {
 874         jlong value;
 875         if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 876           fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 877           return;
 878         }
 879         java_mirror-&gt;long_field_put(fd.offset(), value);
 880       } else if (strcmp(field_signature, &quot;F&quot;) == 0) {
 881         float value = atof(string_value);
 882         java_mirror-&gt;float_field_put(fd.offset(), value);
 883       } else if (strcmp(field_signature, &quot;D&quot;) == 0) {
 884         double value = atof(string_value);
 885         java_mirror-&gt;double_field_put(fd.offset(), value);
 886       } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
 887         Handle value = java_lang_String::create_from_str(string_value, CHECK);
 888         java_mirror-&gt;obj_field_put(fd.offset(), value());
<a name="16" id="anc16"></a><span class="line-modified"> 889       } else if (field_signature[0] == &#39;L&#39;) {</span>
 890         Klass* k = resolve_klass(string_value, CHECK);
 891         oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
 892         java_mirror-&gt;obj_field_put(fd.offset(), value);
 893       } else {
 894         report_error(&quot;unhandled staticfield&quot;);
 895       }
 896     }
 897   }
 898 
 899 #if INCLUDE_JVMTI
 900   void process_JvmtiExport(TRAPS) {
 901     const char* field = parse_string();
 902     bool value = parse_int(&quot;JvmtiExport flag&quot;) != 0;
 903     if (strcmp(field, &quot;can_access_local_variables&quot;) == 0) {
 904       JvmtiExport::set_can_access_local_variables(value);
 905     } else if (strcmp(field, &quot;can_hotswap_or_post_breakpoint&quot;) == 0) {
 906       JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
 907     } else if (strcmp(field, &quot;can_post_on_exceptions&quot;) == 0) {
 908       JvmtiExport::set_can_post_on_exceptions(value);
 909     } else {
 910       report_error(&quot;Unrecognized JvmtiExport directive&quot;);
 911     }
 912   }
 913 #endif // INCLUDE_JVMTI
 914 
 915   // Create and initialize a record for a ciMethod
 916   ciMethodRecord* new_ciMethod(Method* method) {
 917     ciMethodRecord* rec = NEW_RESOURCE_OBJ(ciMethodRecord);
 918     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 919     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
 920     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
 921     _ci_method_records.append(rec);
 922     return rec;
 923   }
 924 
 925   // Lookup data for a ciMethod
 926   ciMethodRecord* find_ciMethodRecord(Method* method) {
 927     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 928     const char* method_name = method-&gt;name()-&gt;as_utf8();
 929     const char* signature = method-&gt;signature()-&gt;as_utf8();
 930     for (int i = 0; i &lt; _ci_method_records.length(); i++) {
 931       ciMethodRecord* rec = _ci_method_records.at(i);
 932       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
 933           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
 934           strcmp(rec-&gt;_signature, signature) == 0) {
 935         return rec;
 936       }
 937     }
 938     return NULL;
 939   }
 940 
 941   // Create and initialize a record for a ciMethodData
 942   ciMethodDataRecord* new_ciMethodData(Method* method) {
 943     ciMethodDataRecord* rec = NEW_RESOURCE_OBJ(ciMethodDataRecord);
 944     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 945     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
 946     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
 947     _ci_method_data_records.append(rec);
 948     return rec;
 949   }
 950 
 951   // Lookup data for a ciMethodData
 952   ciMethodDataRecord* find_ciMethodDataRecord(Method* method) {
 953     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 954     const char* method_name = method-&gt;name()-&gt;as_utf8();
 955     const char* signature = method-&gt;signature()-&gt;as_utf8();
 956     for (int i = 0; i &lt; _ci_method_data_records.length(); i++) {
 957       ciMethodDataRecord* rec = _ci_method_data_records.at(i);
 958       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
 959           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
 960           strcmp(rec-&gt;_signature, signature) == 0) {
 961         return rec;
 962       }
 963     }
 964     return NULL;
 965   }
 966 
 967   // Create and initialize a record for a ciInlineRecord
 968   ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {
 969     ciInlineRecord* rec = NEW_RESOURCE_OBJ(ciInlineRecord);
 970     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 971     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
 972     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
 973     rec-&gt;_inline_bci = bci;
 974     rec-&gt;_inline_depth = depth;
 975     _ci_inline_records-&gt;append(rec);
 976     return rec;
 977   }
 978 
 979   // Lookup inlining data for a ciMethod
 980   ciInlineRecord* find_ciInlineRecord(Method* method, int bci, int depth) {
 981     if (_ci_inline_records != NULL) {
 982       return find_ciInlineRecord(_ci_inline_records, method, bci, depth);
 983     }
 984     return NULL;
 985   }
 986 
 987   static ciInlineRecord* find_ciInlineRecord(GrowableArray&lt;ciInlineRecord*&gt;*  records,
 988                                       Method* method, int bci, int depth) {
 989     if (records != NULL) {
 990       const char* klass_name  = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 991       const char* method_name = method-&gt;name()-&gt;as_utf8();
 992       const char* signature   = method-&gt;signature()-&gt;as_utf8();
 993       for (int i = 0; i &lt; records-&gt;length(); i++) {
 994         ciInlineRecord* rec = records-&gt;at(i);
 995         if ((rec-&gt;_inline_bci == bci) &amp;&amp;
 996             (rec-&gt;_inline_depth == depth) &amp;&amp;
 997             (strcmp(rec-&gt;_klass_name, klass_name) == 0) &amp;&amp;
 998             (strcmp(rec-&gt;_method_name, method_name) == 0) &amp;&amp;
 999             (strcmp(rec-&gt;_signature, signature) == 0)) {
1000           return rec;
1001         }
1002       }
1003     }
1004     return NULL;
1005   }
1006 
1007   const char* error_message() {
1008     return _error_message;
1009   }
1010 
1011   void reset() {
1012     _error_message = NULL;
1013     _ci_method_records.clear();
1014     _ci_method_data_records.clear();
1015   }
1016 
1017   // Take an ascii string contain \u#### escapes and convert it to utf8
1018   // in place.
1019   static void unescape_string(char* value) {
1020     char* from = value;
1021     char* to = value;
1022     while (*from != &#39;\0&#39;) {
1023       if (*from != &#39;\\&#39;) {
1024         *from++ = *to++;
1025       } else {
1026         switch (from[1]) {
1027           case &#39;u&#39;: {
1028             from += 2;
1029             jchar value=0;
1030             for (int i=0; i&lt;4; i++) {
1031               char c = *from++;
1032               switch (c) {
1033                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
1034                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
1035                   value = (value &lt;&lt; 4) + c - &#39;0&#39;;
1036                   break;
1037                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
1038                 case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
1039                   value = (value &lt;&lt; 4) + 10 + c - &#39;a&#39;;
1040                   break;
1041                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
1042                 case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
1043                   value = (value &lt;&lt; 4) + 10 + c - &#39;A&#39;;
1044                   break;
1045                 default:
1046                   ShouldNotReachHere();
1047               }
1048             }
1049             UNICODE::convert_to_utf8(&amp;value, 1, to);
1050             to++;
1051             break;
1052           }
1053           case &#39;t&#39;: *to++ = &#39;\t&#39;; from += 2; break;
1054           case &#39;n&#39;: *to++ = &#39;\n&#39;; from += 2; break;
1055           case &#39;r&#39;: *to++ = &#39;\r&#39;; from += 2; break;
1056           case &#39;f&#39;: *to++ = &#39;\f&#39;; from += 2; break;
1057           default:
1058             ShouldNotReachHere();
1059         }
1060       }
1061     }
1062     *from = *to;
1063   }
1064 };
1065 
1066 void ciReplay::replay(TRAPS) {
1067   int exit_code = replay_impl(THREAD);
1068 
1069   Threads::destroy_vm();
1070 
1071   vm_exit(exit_code);
1072 }
1073 
1074 void* ciReplay::load_inline_data(ciMethod* method, int entry_bci, int comp_level) {
1075   if (FLAG_IS_DEFAULT(InlineDataFile)) {
1076     tty-&gt;print_cr(&quot;ERROR: no inline replay data file specified (use -XX:InlineDataFile=inline_pid12345.txt).&quot;);
1077     return NULL;
1078   }
1079 
1080   VM_ENTRY_MARK;
1081   // Load and parse the replay data
1082   CompileReplay rp(InlineDataFile, THREAD);
1083   if (!rp.can_replay()) {
1084     tty-&gt;print_cr(&quot;ciReplay: !rp.can_replay()&quot;);
1085     return NULL;
1086   }
1087   void* data = rp.process_inline(method, method-&gt;get_Method(), entry_bci, comp_level, THREAD);
1088   if (HAS_PENDING_EXCEPTION) {
1089     Handle throwable(THREAD, PENDING_EXCEPTION);
1090     CLEAR_PENDING_EXCEPTION;
1091     java_lang_Throwable::print_stack_trace(throwable, tty);
1092     tty-&gt;cr();
1093     return NULL;
1094   }
1095 
1096   if (rp.had_error()) {
1097     tty-&gt;print_cr(&quot;ciReplay: Failed on %s&quot;, rp.error_message());
1098     return NULL;
1099   }
1100   return data;
1101 }
1102 
1103 int ciReplay::replay_impl(TRAPS) {
1104   HandleMark hm;
1105   ResourceMark rm;
1106 
1107   if (ReplaySuppressInitializers &gt; 2) {
1108     // ReplaySuppressInitializers &gt; 2 means that we want to allow
1109     // normal VM bootstrap but once we get into the replay itself
1110     // don&#39;t allow any intializers to be run.
1111     ReplaySuppressInitializers = 1;
1112   }
1113 
1114   if (FLAG_IS_DEFAULT(ReplayDataFile)) {
1115     tty-&gt;print_cr(&quot;ERROR: no compiler replay data file specified (use -XX:ReplayDataFile=replay_pid12345.txt).&quot;);
1116     return 1;
1117   }
1118 
1119   // Load and parse the replay data
1120   CompileReplay rp(ReplayDataFile, THREAD);
1121   int exit_code = 0;
1122   if (rp.can_replay()) {
1123     rp.process(THREAD);
1124   } else {
1125     exit_code = 1;
1126     return exit_code;
1127   }
1128 
1129   if (HAS_PENDING_EXCEPTION) {
1130     Handle throwable(THREAD, PENDING_EXCEPTION);
1131     CLEAR_PENDING_EXCEPTION;
1132     java_lang_Throwable::print_stack_trace(throwable, tty);
1133     tty-&gt;cr();
1134     exit_code = 2;
1135   }
1136 
1137   if (rp.had_error()) {
1138     tty-&gt;print_cr(&quot;Failed on %s&quot;, rp.error_message());
1139     exit_code = 1;
1140   }
1141   return exit_code;
1142 }
1143 
1144 void ciReplay::initialize(ciMethodData* m) {
1145   if (replay_state == NULL) {
1146     return;
1147   }
1148 
1149   ASSERT_IN_VM;
1150   ResourceMark rm;
1151 
1152   Method* method = m-&gt;get_MethodData()-&gt;method();
1153   ciMethodDataRecord* rec = replay_state-&gt;find_ciMethodDataRecord(method);
1154   if (rec == NULL) {
1155     // This indicates some mismatch with the original environment and
1156     // the replay environment though it&#39;s not always enough to
1157     // interfere with reproducing a bug
1158     tty-&gt;print_cr(&quot;Warning: requesting ciMethodData record for method with no data: &quot;);
1159     method-&gt;print_name(tty);
1160     tty-&gt;cr();
1161   } else {
1162     m-&gt;_state = rec-&gt;_state;
1163     m-&gt;_current_mileage = rec-&gt;_current_mileage;
1164     if (rec-&gt;_data_length != 0) {
1165       assert(m-&gt;_data_size + m-&gt;_extra_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]) ||
1166              m-&gt;_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]), &quot;must agree&quot;);
1167 
1168       // Write the correct ciObjects back into the profile data
1169       ciEnv* env = ciEnv::current();
1170       for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
1171         Klass *k = rec-&gt;_classes[i];
1172         // In case this class pointer is is tagged, preserve the tag bits
1173         intptr_t status = 0;
1174         if (k != NULL) {
1175           status = ciTypeEntries::with_status(env-&gt;get_metadata(k)-&gt;as_klass(), rec-&gt;_data[rec-&gt;_classes_offsets[i]]);
1176         }
1177         rec-&gt;_data[rec-&gt;_classes_offsets[i]] = status;
1178       }
1179       for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
1180         Method *m = rec-&gt;_methods[i];
1181         *(ciMetadata**)(rec-&gt;_data + rec-&gt;_methods_offsets[i]) =
1182           env-&gt;get_metadata(m);
1183       }
1184       // Copy the updated profile data into place as intptr_ts
1185 #ifdef _LP64
1186       Copy::conjoint_jlongs_atomic((jlong *)rec-&gt;_data, (jlong *)m-&gt;_data, rec-&gt;_data_length);
1187 #else
1188       Copy::conjoint_jints_atomic((jint *)rec-&gt;_data, (jint *)m-&gt;_data, rec-&gt;_data_length);
1189 #endif
1190     }
1191 
1192     // copy in the original header
1193     Copy::conjoint_jbytes(rec-&gt;_orig_data, (char*)&amp;m-&gt;_orig, rec-&gt;_orig_data_length);
1194   }
1195 }
1196 
1197 
1198 bool ciReplay::should_not_inline(ciMethod* method) {
1199   if (replay_state == NULL) {
1200     return false;
1201   }
1202   VM_ENTRY_MARK;
1203   // ciMethod without a record shouldn&#39;t be inlined.
1204   return replay_state-&gt;find_ciMethodRecord(method-&gt;get_Method()) == NULL;
1205 }
1206 
1207 bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1208   if (data != NULL) {
1209     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1210     VM_ENTRY_MARK;
1211     // Inline record are ordered by bci and depth.
1212     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) != NULL;
1213   } else if (replay_state != NULL) {
1214     VM_ENTRY_MARK;
1215     // Inline record are ordered by bci and depth.
1216     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) != NULL;
1217   }
1218   return false;
1219 }
1220 
1221 bool ciReplay::should_not_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1222   if (data != NULL) {
1223     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1224     VM_ENTRY_MARK;
1225     // Inline record are ordered by bci and depth.
1226     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) == NULL;
1227   } else if (replay_state != NULL) {
1228     VM_ENTRY_MARK;
1229     // Inline record are ordered by bci and depth.
1230     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) == NULL;
1231   }
1232   return false;
1233 }
1234 
1235 void ciReplay::initialize(ciMethod* m) {
1236   if (replay_state == NULL) {
1237     return;
1238   }
1239 
1240   ASSERT_IN_VM;
1241   ResourceMark rm;
1242 
1243   Method* method = m-&gt;get_Method();
1244   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1245   if (rec == NULL) {
1246     // This indicates some mismatch with the original environment and
1247     // the replay environment though it&#39;s not always enough to
1248     // interfere with reproducing a bug
1249     tty-&gt;print_cr(&quot;Warning: requesting ciMethod record for method with no data: &quot;);
1250     method-&gt;print_name(tty);
1251     tty-&gt;cr();
1252   } else {
1253     EXCEPTION_CONTEXT;
1254     // m-&gt;_instructions_size = rec-&gt;_instructions_size;
1255     m-&gt;_instructions_size = -1;
1256     m-&gt;_interpreter_invocation_count = rec-&gt;_interpreter_invocation_count;
1257     m-&gt;_interpreter_throwout_count = rec-&gt;_interpreter_throwout_count;
1258     MethodCounters* mcs = method-&gt;get_method_counters(CHECK_AND_CLEAR);
1259     guarantee(mcs != NULL, &quot;method counters allocation failed&quot;);
1260     mcs-&gt;invocation_counter()-&gt;_counter = rec-&gt;_invocation_counter;
1261     mcs-&gt;backedge_counter()-&gt;_counter = rec-&gt;_backedge_counter;
1262   }
1263 }
1264 
1265 bool ciReplay::is_loaded(Method* method) {
1266   if (replay_state == NULL) {
1267     return true;
1268   }
1269 
1270   ASSERT_IN_VM;
1271   ResourceMark rm;
1272 
1273   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1274   return rec != NULL;
1275 }
1276 #endif // PRODUCT
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
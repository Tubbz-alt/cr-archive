<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 35 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/jniHandles.inline.hpp&quot;
 39 
 40 // ciInstanceKlass
 41 //
 42 // This class represents a Klass* in the HotSpot virtual machine
 43 // whose Klass part in an InstanceKlass.
 44 
 45 
 46 // ------------------------------------------------------------------
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
 56 
 57   AccessFlags access_flags = ik-&gt;access_flags();
 58   _flags = ciFlags(access_flags);
 59   _has_finalizer = access_flags.has_finalizer();
 60   _has_subklass = flags().is_final() ? subklass_false : subklass_unknown;
 61   _init_state = ik-&gt;init_state();
 62   _nonstatic_field_size = ik-&gt;nonstatic_field_size();
 63   _has_nonstatic_fields = ik-&gt;has_nonstatic_fields();
 64   _has_nonstatic_concrete_methods = ik-&gt;has_nonstatic_concrete_methods();
 65   _is_unsafe_anonymous = ik-&gt;is_unsafe_anonymous();
 66   _nonstatic_fields = NULL; // initialized lazily by compute_nonstatic_fields:
 67   _has_injected_fields = -1;
 68   _implementor = NULL; // we will fill these lazily
 69 
 70   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
 71   // This is primarily useful for metadata which is considered as weak roots
 72   // by the GC but need to be strong roots if reachable from a current compilation.
 73   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
 74   // alive covers the cases where there are weak roots without performance cost.
 75   oop holder = ik-&gt;klass_holder();
 76   if (ik-&gt;is_unsafe_anonymous()) {
 77     // Though ciInstanceKlass records class loader oop, it&#39;s not enough to keep
 78     // VM unsafe anonymous classes alive (loader == NULL). Klass holder should
 79     // be used instead. It is enough to record a ciObject, since cached elements are never removed
 80     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
 81     // every compilation and lives for the whole duration of the compilation.
 82     assert(holder != NULL, &quot;holder of unsafe anonymous class is the mirror which is never null&quot;);
 83     (void)CURRENT_ENV-&gt;get_object(holder);
 84   }
 85 
 86   Thread *thread = Thread::current();
 87   if (ciObjectFactory::is_initialized()) {
 88     _loader = JNIHandles::make_local(thread, ik-&gt;class_loader());
 89     _protection_domain = JNIHandles::make_local(thread,
 90                                                 ik-&gt;protection_domain());
 91     _is_shared = false;
 92   } else {
 93     Handle h_loader(thread, ik-&gt;class_loader());
 94     Handle h_protection_domain(thread, ik-&gt;protection_domain());
 95     _loader = JNIHandles::make_global(h_loader);
 96     _protection_domain = JNIHandles::make_global(h_protection_domain);
 97     _is_shared = true;
 98   }
 99 
100   // Lazy fields get filled in only upon request.
101   _super  = NULL;
102   _java_mirror = NULL;
103 
104   if (is_shared()) {
105     if (k != SystemDictionary::Object_klass()) {
106       super();
107     }
108     //compute_nonstatic_fields();  // done outside of constructor
109   }
110 
111   _field_cache = NULL;
112 }
113 
114 // Version for unloaded classes:
115 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
116                                  jobject loader, jobject protection_domain)
117   : ciKlass(name, T_OBJECT)
118 {
<a name="3" id="anc3"></a><span class="line-modified">119   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);</span>
120   _init_state = (InstanceKlass::ClassState)0;
121   _nonstatic_field_size = -1;
122   _has_nonstatic_fields = false;
123   _nonstatic_fields = NULL;
124   _has_injected_fields = -1;
125   _is_unsafe_anonymous = false;
126   _loader = loader;
127   _protection_domain = protection_domain;
128   _is_shared = false;
129   _super = NULL;
130   _java_mirror = NULL;
131   _field_cache = NULL;
132 }
133 
134 
135 
136 // ------------------------------------------------------------------
137 // ciInstanceKlass::compute_shared_is_initialized
138 void ciInstanceKlass::compute_shared_init_state() {
139   GUARDED_VM_ENTRY(
140     InstanceKlass* ik = get_instanceKlass();
141     _init_state = ik-&gt;init_state();
142   )
143 }
144 
145 // ------------------------------------------------------------------
146 // ciInstanceKlass::compute_shared_has_subklass
147 bool ciInstanceKlass::compute_shared_has_subklass() {
148   GUARDED_VM_ENTRY(
149     InstanceKlass* ik = get_instanceKlass();
150     _has_subklass = ik-&gt;subklass() != NULL ? subklass_true : subklass_false;
151     return _has_subklass == subklass_true;
152   )
153 }
154 
155 // ------------------------------------------------------------------
156 // ciInstanceKlass::loader
157 oop ciInstanceKlass::loader() {
158   ASSERT_IN_VM;
159   return JNIHandles::resolve(_loader);
160 }
161 
162 // ------------------------------------------------------------------
163 // ciInstanceKlass::loader_handle
164 jobject ciInstanceKlass::loader_handle() {
165   return _loader;
166 }
167 
168 // ------------------------------------------------------------------
169 // ciInstanceKlass::protection_domain
170 oop ciInstanceKlass::protection_domain() {
171   ASSERT_IN_VM;
172   return JNIHandles::resolve(_protection_domain);
173 }
174 
175 // ------------------------------------------------------------------
176 // ciInstanceKlass::protection_domain_handle
177 jobject ciInstanceKlass::protection_domain_handle() {
178   return _protection_domain;
179 }
180 
181 // ------------------------------------------------------------------
182 // ciInstanceKlass::field_cache
183 //
184 // Get the field cache associated with this klass.
185 ciConstantPoolCache* ciInstanceKlass::field_cache() {
186   if (is_shared()) {
187     return NULL;
188   }
189   if (_field_cache == NULL) {
190     assert(!is_java_lang_Object(), &quot;Object has no fields&quot;);
191     Arena* arena = CURRENT_ENV-&gt;arena();
192     _field_cache = new (arena) ciConstantPoolCache(arena, 5);
193   }
194   return _field_cache;
195 }
196 
197 // ------------------------------------------------------------------
198 // ciInstanceKlass::get_canonical_holder
199 //
200 ciInstanceKlass* ciInstanceKlass::get_canonical_holder(int offset) {
201   #ifdef ASSERT
202   if (!(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper())) {
203     tty-&gt;print(&quot;*** get_canonical_holder(%d) on &quot;, offset);
204     this-&gt;print();
205     tty-&gt;print_cr(&quot; ***&quot;);
206   };
207   assert(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper(), &quot;offset must be tame&quot;);
208   #endif
209 
210   if (offset &lt; instanceOopDesc::base_offset_in_bytes()) {
211     // All header offsets belong properly to java/lang/Object.
212     return CURRENT_ENV-&gt;Object_klass();
213   }
214 
215   ciInstanceKlass* self = this;
<a name="4" id="anc4"></a><span class="line-modified">216   assert(self-&gt;is_loaded(), &quot;must be loaded to access field info&quot;);</span>
<span class="line-modified">217   ciField* field = self-&gt;get_field_by_offset(offset, false);</span>
<span class="line-modified">218   if (field != NULL) {</span>
<span class="line-modified">219     return field-&gt;holder();</span>
<span class="line-modified">220   } else {</span>
<span class="line-modified">221     for (;;) {</span>
<span class="line-modified">222       assert(self-&gt;is_loaded(), &quot;must be loaded to have size&quot;);</span>
<span class="line-modified">223       ciInstanceKlass* super = self-&gt;super();</span>
<span class="line-added">224       if (super == NULL || super-&gt;nof_nonstatic_fields() == 0) {</span>
<span class="line-added">225         return self;</span>
<span class="line-added">226       } else {</span>
<span class="line-added">227         self = super;  // return super-&gt;get_canonical_holder(offset)</span>
<span class="line-added">228       }</span>
229     }
230   }
231 }
232 
233 // ------------------------------------------------------------------
234 // ciInstanceKlass::is_java_lang_Object
235 //
236 // Is this klass java.lang.Object?
237 bool ciInstanceKlass::is_java_lang_Object() const {
238   return equals(CURRENT_ENV-&gt;Object_klass());
239 }
240 
241 // ------------------------------------------------------------------
242 // ciInstanceKlass::uses_default_loader
243 bool ciInstanceKlass::uses_default_loader() const {
244   // Note:  We do not need to resolve the handle or enter the VM
245   // in order to test null-ness.
246   return _loader == NULL;
247 }
248 
249 // ------------------------------------------------------------------
250 
251 /**
252  * Return basic type of boxed value for box klass or T_OBJECT if not.
253  */
254 BasicType ciInstanceKlass::box_klass_type() const {
255   if (uses_default_loader() &amp;&amp; is_loaded()) {
256     return SystemDictionary::box_klass_type(get_Klass());
257   } else {
258     return T_OBJECT;
259   }
260 }
261 
262 /**
263  * Is this boxing klass?
264  */
265 bool ciInstanceKlass::is_box_klass() const {
266   return is_java_primitive(box_klass_type());
267 }
268 
269 /**
270  *  Is this boxed value offset?
271  */
272 bool ciInstanceKlass::is_boxed_value_offset(int offset) const {
273   BasicType bt = box_klass_type();
274   return is_java_primitive(bt) &amp;&amp;
275          (offset == java_lang_boxing_object::value_offset_in_bytes(bt));
276 }
277 
278 // ------------------------------------------------------------------
279 // ciInstanceKlass::is_in_package
280 //
281 // Is this klass in the given package?
282 bool ciInstanceKlass::is_in_package(const char* packagename, int len) {
283   // To avoid class loader mischief, this test always rejects application classes.
284   if (!uses_default_loader())
285     return false;
286   GUARDED_VM_ENTRY(
287     return is_in_package_impl(packagename, len);
288   )
289 }
290 
291 bool ciInstanceKlass::is_in_package_impl(const char* packagename, int len) {
292   ASSERT_IN_VM;
293 
294   // If packagename contains trailing &#39;/&#39; exclude it from the
295   // prefix-test since we test for it explicitly.
296   if (packagename[len - 1] == &#39;/&#39;)
297     len--;
298 
299   if (!name()-&gt;starts_with(packagename, len))
300     return false;
301 
302   // Test if the class name is something like &quot;java/lang&quot;.
303   if ((len + 1) &gt; name()-&gt;utf8_length())
304     return false;
305 
306   // Test for trailing &#39;/&#39;
307   if (name()-&gt;char_at(len) != &#39;/&#39;)
308     return false;
309 
310   // Make sure it&#39;s not actually in a subpackage:
311   if (name()-&gt;index_of_at(len+1, &quot;/&quot;, 1) &gt;= 0)
312     return false;
313 
314   return true;
315 }
316 
317 // ------------------------------------------------------------------
318 // ciInstanceKlass::print_impl
319 //
320 // Implementation of the print method.
321 void ciInstanceKlass::print_impl(outputStream* st) {
322   ciKlass::print_impl(st);
<a name="5" id="anc5"></a><span class="line-modified">323   GUARDED_VM_ENTRY(st-&gt;print(&quot; loader=&quot; INTPTR_FORMAT, p2i(loader()));)</span>
324   if (is_loaded()) {
325     st-&gt;print(&quot; loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=&quot;,
326               bool_to_str(is_initialized()),
327               bool_to_str(has_finalizer()),
328               bool_to_str(has_subklass()),
329               layout_helper());
330 
331     _flags.print_klass_flags();
332 
333     if (_super) {
334       st-&gt;print(&quot; super=&quot;);
335       _super-&gt;print_name();
336     }
337     if (_java_mirror) {
338       st-&gt;print(&quot; mirror=PRESENT&quot;);
339     }
340   } else {
341     st-&gt;print(&quot; loaded=false&quot;);
342   }
343 }
344 
345 // ------------------------------------------------------------------
346 // ciInstanceKlass::super
347 //
348 // Get the superklass of this klass.
349 ciInstanceKlass* ciInstanceKlass::super() {
350   assert(is_loaded(), &quot;must be loaded&quot;);
351   if (_super == NULL &amp;&amp; !is_java_lang_Object()) {
352     GUARDED_VM_ENTRY(
353       Klass* super_klass = get_instanceKlass()-&gt;super();
354       _super = CURRENT_ENV-&gt;get_instance_klass(super_klass);
355     )
356   }
357   return _super;
358 }
359 
360 // ------------------------------------------------------------------
361 // ciInstanceKlass::java_mirror
362 //
363 // Get the instance of java.lang.Class corresponding to this klass.
364 // Cache it on this-&gt;_java_mirror.
365 ciInstance* ciInstanceKlass::java_mirror() {
366   if (is_shared()) {
367     return ciKlass::java_mirror();
368   }
369   if (_java_mirror == NULL) {
370     _java_mirror = ciKlass::java_mirror();
371   }
372   return _java_mirror;
373 }
374 
375 // ------------------------------------------------------------------
376 // ciInstanceKlass::unique_concrete_subklass
377 ciInstanceKlass* ciInstanceKlass::unique_concrete_subklass() {
378   if (!is_loaded())     return NULL; // No change if class is not loaded
379   if (!is_abstract())   return NULL; // Only applies to abstract classes.
380   if (!has_subklass())  return NULL; // Must have at least one subklass.
381   VM_ENTRY_MARK;
382   InstanceKlass* ik = get_instanceKlass();
383   Klass* up = ik-&gt;up_cast_abstract();
384   assert(up-&gt;is_instance_klass(), &quot;must be InstanceKlass&quot;);
385   if (ik == up) {
386     return NULL;
387   }
388   return CURRENT_THREAD_ENV-&gt;get_instance_klass(up);
389 }
390 
391 // ------------------------------------------------------------------
392 // ciInstanceKlass::has_finalizable_subclass
393 bool ciInstanceKlass::has_finalizable_subclass() {
394   if (!is_loaded())     return true;
395   VM_ENTRY_MARK;
396   return Dependencies::find_finalizable_subclass(get_instanceKlass()) != NULL;
397 }
398 
<a name="6" id="anc6"></a><span class="line-added">399 // ------------------------------------------------------------------</span>
<span class="line-added">400 // ciInstanceKlass::contains_field_offset</span>
<span class="line-added">401 bool ciInstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">402   VM_ENTRY_MARK;</span>
<span class="line-added">403   return get_instanceKlass()-&gt;contains_field_offset(offset);</span>
<span class="line-added">404 }</span>
<span class="line-added">405 </span>
406 // ------------------------------------------------------------------
407 // ciInstanceKlass::get_field_by_offset
408 ciField* ciInstanceKlass::get_field_by_offset(int field_offset, bool is_static) {
409   if (!is_static) {
410     for (int i = 0, len = nof_nonstatic_fields(); i &lt; len; i++) {
411       ciField* field = _nonstatic_fields-&gt;at(i);
412       int  field_off = field-&gt;offset_in_bytes();
413       if (field_off == field_offset)
414         return field;
415       if (field_off &gt; field_offset)
416         break;
417       // could do binary search or check bins, but probably not worth it
418     }
419     return NULL;
420   }
421   VM_ENTRY_MARK;
422   InstanceKlass* k = get_instanceKlass();
423   fieldDescriptor fd;
424   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
425     return NULL;
426   }
427   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
428   return field;
429 }
430 
431 // ------------------------------------------------------------------
432 // ciInstanceKlass::get_field_by_name
433 ciField* ciInstanceKlass::get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static) {
434   VM_ENTRY_MARK;
435   InstanceKlass* k = get_instanceKlass();
436   fieldDescriptor fd;
437   Klass* def = k-&gt;find_field(name-&gt;get_symbol(), signature-&gt;get_symbol(), is_static, &amp;fd);
438   if (def == NULL) {
439     return NULL;
440   }
441   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
442   return field;
443 }
444 
445 
446 static int sort_field_by_offset(ciField** a, ciField** b) {
447   return (*a)-&gt;offset_in_bytes() - (*b)-&gt;offset_in_bytes();
448   // (no worries about 32-bit overflow...)
449 }
450 
451 // ------------------------------------------------------------------
452 // ciInstanceKlass::compute_nonstatic_fields
453 int ciInstanceKlass::compute_nonstatic_fields() {
454   assert(is_loaded(), &quot;must be loaded&quot;);
455 
456   if (_nonstatic_fields != NULL)
457     return _nonstatic_fields-&gt;length();
458 
459   if (!has_nonstatic_fields()) {
460     Arena* arena = CURRENT_ENV-&gt;arena();
461     _nonstatic_fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, 0, 0, NULL);
462     return 0;
463   }
464   assert(!is_java_lang_Object(), &quot;bootstrap OK&quot;);
465 
466   // Size in bytes of my fields, including inherited fields.
467   int fsize = nonstatic_field_size() * heapOopSize;
468 
469   ciInstanceKlass* super = this-&gt;super();
470   GrowableArray&lt;ciField*&gt;* super_fields = NULL;
471   if (super != NULL &amp;&amp; super-&gt;has_nonstatic_fields()) {
<a name="7" id="anc7"></a>
472     int super_flen   = super-&gt;nof_nonstatic_fields();
473     super_fields = super-&gt;_nonstatic_fields;
474     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
<a name="8" id="anc8"></a>




475   }
476 
477   GrowableArray&lt;ciField*&gt;* fields = NULL;
478   GUARDED_VM_ENTRY({
479       fields = compute_nonstatic_fields_impl(super_fields);
480     });
481 
482   if (fields == NULL) {
483     // This can happen if this class (java.lang.Class) has invisible fields.
484     if (super_fields != NULL) {
485       _nonstatic_fields = super_fields;
486       return super_fields-&gt;length();
487     } else {
488       return 0;
489     }
490   }
491 
492   int flen = fields-&gt;length();
493 
494   // Now sort them by offset, ascending.
495   // (In principle, they could mix with superclass fields.)
496   fields-&gt;sort(sort_field_by_offset);
497   _nonstatic_fields = fields;
498   return flen;
499 }
500 
501 GrowableArray&lt;ciField*&gt;*
502 ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray&lt;ciField*&gt;*
503                                                super_fields) {
504   ASSERT_IN_VM;
505   Arena* arena = CURRENT_ENV-&gt;arena();
506   int flen = 0;
507   GrowableArray&lt;ciField*&gt;* fields = NULL;
508   InstanceKlass* k = get_instanceKlass();
509   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
510     if (fs.access_flags().is_static())  continue;
511     flen += 1;
512   }
513 
514   // allocate the array:
515   if (flen == 0) {
516     return NULL;  // return nothing if none are locally declared
517   }
518   if (super_fields != NULL) {
519     flen += super_fields-&gt;length();
520   }
521   fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, flen, 0, NULL);
522   if (super_fields != NULL) {
523     fields-&gt;appendAll(super_fields);
524   }
525 
526   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
527     if (fs.access_flags().is_static())  continue;
528     fieldDescriptor&amp; fd = fs.field_descriptor();
529     ciField* field = new (arena) ciField(&amp;fd);
530     fields-&gt;append(field);
531   }
532   assert(fields-&gt;length() == flen, &quot;sanity&quot;);
533   return fields;
534 }
535 
536 bool ciInstanceKlass::compute_injected_fields_helper() {
537   ASSERT_IN_VM;
538   InstanceKlass* k = get_instanceKlass();
539 
540   for (InternalFieldStream fs(k); !fs.done(); fs.next()) {
541     if (fs.access_flags().is_static())  continue;
542     return true;
543   }
544   return false;
545 }
546 
547 void ciInstanceKlass::compute_injected_fields() {
548   assert(is_loaded(), &quot;must be loaded&quot;);
549 
550   int has_injected_fields = 0;
551   if (super() != NULL &amp;&amp; super()-&gt;has_injected_fields()) {
552     has_injected_fields = 1;
553   } else {
554     GUARDED_VM_ENTRY({
555         has_injected_fields = compute_injected_fields_helper() ? 1 : 0;
556       });
557   }
558   // may be concurrently initialized for shared ciInstanceKlass objects
559   assert(_has_injected_fields == -1 || _has_injected_fields == has_injected_fields, &quot;broken concurrent initialization&quot;);
560   _has_injected_fields = has_injected_fields;
561 }
562 
563 bool ciInstanceKlass::has_object_fields() const {
564   GUARDED_VM_ENTRY(
565       return get_instanceKlass()-&gt;nonstatic_oop_map_size() &gt; 0;
566     );
567 }
568 
569 // ------------------------------------------------------------------
570 // ciInstanceKlass::find_method
571 //
572 // Find a method in this klass.
573 ciMethod* ciInstanceKlass::find_method(ciSymbol* name, ciSymbol* signature) {
574   VM_ENTRY_MARK;
575   InstanceKlass* k = get_instanceKlass();
576   Symbol* name_sym = name-&gt;get_symbol();
577   Symbol* sig_sym= signature-&gt;get_symbol();
578 
579   Method* m = k-&gt;find_method(name_sym, sig_sym);
580   if (m == NULL)  return NULL;
581 
582   return CURRENT_THREAD_ENV-&gt;get_method(m);
583 }
584 
585 // ------------------------------------------------------------------
586 // ciInstanceKlass::is_leaf_type
587 bool ciInstanceKlass::is_leaf_type() {
588   assert(is_loaded(), &quot;must be loaded&quot;);
589   if (is_shared()) {
590     return is_final();  // approximately correct
591   } else {
592     return !has_subklass() &amp;&amp; (nof_implementors() == 0);
593   }
594 }
595 
596 // ------------------------------------------------------------------
597 // ciInstanceKlass::implementor
598 //
599 // Report an implementor of this interface.
600 // Note that there are various races here, since my copy
601 // of _nof_implementors might be out of date with respect
602 // to results returned by InstanceKlass::implementor.
603 // This is OK, since any dependencies we decide to assert
604 // will be checked later under the Compile_lock.
605 ciInstanceKlass* ciInstanceKlass::implementor() {
606   ciInstanceKlass* impl = _implementor;
607   if (impl == NULL) {
608     // Go into the VM to fetch the implementor.
609     {
610       VM_ENTRY_MARK;
611       MutexLocker ml(Compile_lock);
612       Klass* k = get_instanceKlass()-&gt;implementor();
613       if (k != NULL) {
614         if (k == get_instanceKlass()) {
615           // More than one implementors. Use &#39;this&#39; in this case.
616           impl = this;
617         } else {
618           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
619         }
620       }
621     }
622     // Memoize this result.
623     if (!is_shared()) {
624       _implementor = impl;
625     }
626   }
627   return impl;
628 }
629 
630 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
631   assert(is_loaded(), &quot;must be loaded&quot;);
632   if (is_unsafe_anonymous()) {
633     VM_ENTRY_MARK
634     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
635     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
636   }
637   return NULL;
638 }
639 
640 // Utility class for printing of the contents of the static fields for
641 // use by compilation replay.  It only prints out the information that
642 // could be consumed by the compiler, so for primitive types it prints
643 // out the actual value.  For Strings it&#39;s the actual string value.
644 // For array types it it&#39;s first level array size since that&#39;s the
645 // only value which statically unchangeable.  For all other reference
646 // types it simply prints out the dynamic type.
647 
648 class StaticFinalFieldPrinter : public FieldClosure {
649   outputStream* _out;
650   const char*   _holder;
651  public:
652   StaticFinalFieldPrinter(outputStream* out, const char* holder) :
653     _out(out),
654     _holder(holder) {
655   }
656   void do_field(fieldDescriptor* fd) {
657     if (fd-&gt;is_final() &amp;&amp; !fd-&gt;has_initial_value()) {
658       ResourceMark rm;
659       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
660       _out-&gt;print(&quot;staticfield %s %s %s &quot;, _holder, fd-&gt;name()-&gt;as_quoted_ascii(), fd-&gt;signature()-&gt;as_quoted_ascii());
661       switch (fd-&gt;field_type()) {
662         case T_BYTE:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;byte_field(fd-&gt;offset()));   break;
663         case T_BOOLEAN: _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;bool_field(fd-&gt;offset()));   break;
664         case T_SHORT:   _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;short_field(fd-&gt;offset()));  break;
665         case T_CHAR:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;char_field(fd-&gt;offset()));   break;
666         case T_INT:     _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;int_field(fd-&gt;offset()));    break;
667         case T_LONG:    _out-&gt;print_cr(INT64_FORMAT, (int64_t)(mirror-&gt;long_field(fd-&gt;offset())));   break;
668         case T_FLOAT: {
669           float f = mirror-&gt;float_field(fd-&gt;offset());
670           _out-&gt;print_cr(&quot;%d&quot;, *(int*)&amp;f);
671           break;
672         }
673         case T_DOUBLE: {
674           double d = mirror-&gt;double_field(fd-&gt;offset());
675           _out-&gt;print_cr(INT64_FORMAT, *(int64_t*)&amp;d);
676           break;
677         }
678         case T_ARRAY:  // fall-through
679         case T_OBJECT: {
680           oop value =  mirror-&gt;obj_field_acquire(fd-&gt;offset());
681           if (value == NULL) {
682             _out-&gt;print_cr(&quot;null&quot;);
683           } else if (value-&gt;is_instance()) {
684             assert(fd-&gt;field_type() == T_OBJECT, &quot;&quot;);
685             if (value-&gt;is_a(SystemDictionary::String_klass())) {
686               const char* ascii_value = java_lang_String::as_quoted_ascii(value);
687               _out-&gt;print(&quot;\&quot;%s\&quot;&quot;, (ascii_value != NULL) ? ascii_value : &quot;&quot;);
688             } else {
689               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();
690               _out-&gt;print_cr(&quot;%s&quot;, klass_name);
691             }
692           } else if (value-&gt;is_array()) {
693             typeArrayOop ta = (typeArrayOop)value;
694             _out-&gt;print(&quot;%d&quot;, ta-&gt;length());
695             if (value-&gt;is_objArray()) {
696               objArrayOop oa = (objArrayOop)value;
697               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();
698               _out-&gt;print(&quot; %s&quot;, klass_name);
699             }
700             _out-&gt;cr();
701           } else {
702             ShouldNotReachHere();
703           }
704           break;
705         }
706         default:
707           ShouldNotReachHere();
708         }
709     }
710   }
711 };
712 
713 
714 void ciInstanceKlass::dump_replay_data(outputStream* out) {
715   ResourceMark rm;
716 
717   InstanceKlass* ik = get_instanceKlass();
718   ConstantPool*  cp = ik-&gt;constants();
719 
720   // Try to record related loaded classes
721   Klass* sub = ik-&gt;subklass();
722   while (sub != NULL) {
723     if (sub-&gt;is_instance_klass()) {
724       out-&gt;print_cr(&quot;instanceKlass %s&quot;, sub-&gt;name()-&gt;as_quoted_ascii());
725     }
726     sub = sub-&gt;next_sibling();
727   }
728 
729   // Dump out the state of the constant pool tags.  During replay the
730   // tags will be validated for things which shouldn&#39;t change and
731   // classes will be resolved if the tags indicate that they were
732   // resolved at compile time.
733   out-&gt;print(&quot;ciInstanceKlass %s %d %d %d&quot;, ik-&gt;name()-&gt;as_quoted_ascii(),
734              is_linked(), is_initialized(), cp-&gt;length());
735   for (int index = 1; index &lt; cp-&gt;length(); index++) {
736     out-&gt;print(&quot; %d&quot;, cp-&gt;tags()-&gt;at(index));
737   }
738   out-&gt;cr();
739   if (is_initialized()) {
740     //  Dump out the static final fields in case the compilation relies
741     //  on their value for correct replay.
742     StaticFinalFieldPrinter sffp(out, ik-&gt;name()-&gt;as_quoted_ascii());
743     ik-&gt;do_local_static_fields(&amp;sffp);
744   }
745 }
746 
747 #ifdef ASSERT
748 bool ciInstanceKlass::debug_final_field_at(int offset) {
749   GUARDED_VM_ENTRY(
750     InstanceKlass* ik = get_instanceKlass();
751     fieldDescriptor fd;
752     if (ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
753       return fd.is_final();
754     }
755   );
756   return false;
757 }
758 
759 bool ciInstanceKlass::debug_stable_field_at(int offset) {
760   GUARDED_VM_ENTRY(
761     InstanceKlass* ik = get_instanceKlass();
762     fieldDescriptor fd;
763     if (ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
764       return fd.is_stable();
765     }
766   );
767   return false;
768 }
769 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
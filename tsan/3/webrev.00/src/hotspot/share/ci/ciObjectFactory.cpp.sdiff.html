<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciObjectFactory.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciObjectFactory.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciObjectFactory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciMemberName.hpp&quot;
 30 #include &quot;ci/ciMethod.hpp&quot;
 31 #include &quot;ci/ciMethodData.hpp&quot;
 32 #include &quot;ci/ciMethodHandle.hpp&quot;
 33 #include &quot;ci/ciMethodType.hpp&quot;
 34 #include &quot;ci/ciNullObject.hpp&quot;
 35 #include &quot;ci/ciObjArray.hpp&quot;
 36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
 37 #include &quot;ci/ciObject.hpp&quot;
 38 #include &quot;ci/ciObjectFactory.hpp&quot;
 39 #include &quot;ci/ciSymbol.hpp&quot;
 40 #include &quot;ci/ciTypeArray.hpp&quot;
 41 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
 42 #include &quot;ci/ciUtilities.inline.hpp&quot;
 43 #include &quot;classfile/javaClasses.inline.hpp&quot;
 44 #include &quot;classfile/systemDictionary.hpp&quot;
 45 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 46 #include &quot;memory/allocation.inline.hpp&quot;

 47 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed"> 48 #include &quot;runtime/fieldType.hpp&quot;</span>
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;utilities/macros.hpp&quot;
 51 
 52 // ciObjectFactory
 53 //
 54 // This class handles requests for the creation of new instances
 55 // of ciObject and its subclasses.  It contains a caching mechanism
 56 // which ensures that for each oop, at most one ciObject is created.
 57 // This invariant allows more efficient implementation of ciObject.
 58 //
 59 // Implementation note: the oop-&gt;ciObject mapping is represented as
 60 // a table stored in an array.  Even though objects are moved
 61 // by the garbage collector, the compactor preserves their relative
 62 // order; address comparison of oops (in perm space) is safe so long
 63 // as we prohibit GC during our comparisons.  We currently use binary
 64 // search to find the oop in the table, and inserting a new oop
 65 // into the table may be costly.  If this cost ends up being
 66 // problematic the underlying data structure can be switched to some
 67 // sort of balanced binary tree.
 68 
</pre>
<hr />
<pre>
131       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
132       assert(vmSymbols::find_sid(vmsym) == i, &quot;1-1 mapping&quot;);
133       ciSymbol* sym = new (_arena) ciSymbol(vmsym, (vmSymbols::SID) i);
134       init_ident_of(sym);
135       _shared_ci_symbols[i] = sym;
136     }
137 #ifdef ASSERT
138     for (i = vmSymbols::FIRST_SID; i &lt; vmSymbols::SID_LIMIT; i++) {
139       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
140       ciSymbol* sym = vm_symbol_at((vmSymbols::SID) i);
141       assert(sym-&gt;get_symbol() == vmsym, &quot;oop must match&quot;);
142     }
143     assert(ciSymbol::void_class_signature()-&gt;get_symbol() == vmSymbols::void_class_signature(), &quot;spot check&quot;);
144 #endif
145   }
146 
147   _ci_metadata = new (_arena) GrowableArray&lt;ciMetadata*&gt;(_arena, 64, 0, NULL);
148 
149   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
150     BasicType t = (BasicType)i;
<span class="line-modified">151     if (type2name(t) != NULL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY &amp;&amp; t != T_NARROWOOP &amp;&amp; t != T_NARROWKLASS) {</span>

152       ciType::_basic_types[t] = new (_arena) ciType(t);
153       init_ident_of(ciType::_basic_types[t]);
154     }
155   }
156 
157   ciEnv::_null_object_instance = new (_arena) ciNullObject();
158   init_ident_of(ciEnv::_null_object_instance);
159 
160 #define WK_KLASS_DEFN(name, ignore_s)                              \
161   if (SystemDictionary::name##_is_loaded()) \
162     ciEnv::_##name = get_metadata(SystemDictionary::name())-&gt;as_instance_klass();
163 
164   WK_KLASSES_DO(WK_KLASS_DEFN)
165 #undef WK_KLASS_DEFN
166 
167   for (int len = -1; len != _ci_metadata-&gt;length(); ) {
168     len = _ci_metadata-&gt;length();
169     for (int i2 = 0; i2 &lt; len; i2++) {
170       ciMetadata* obj = _ci_metadata-&gt;at(i2);
171       assert (obj-&gt;is_metadata(), &quot;what else would it be?&quot;);
</pre>
<hr />
<pre>
221 
222 // Decrement the refcount when done on symbols referenced by this compilation.
223 void ciObjectFactory::remove_symbols() {
224   for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
225     ciSymbol* s = _symbols-&gt;at(i);
226     s-&gt;get_symbol()-&gt;decrement_refcount();
227   }
228   // Since _symbols is resource allocated we&#39;re not allowed to delete it
229   // but it&#39;ll go away just the same.
230 }
231 
232 // ------------------------------------------------------------------
233 // ciObjectFactory::get
234 //
235 // Get the ciObject corresponding to some oop.  If the ciObject has
236 // already been created, it is returned.  Otherwise, a new ciObject
237 // is created.
238 ciObject* ciObjectFactory::get(oop key) {
239   ASSERT_IN_VM;
240 
<span class="line-modified">241   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);</span>
242 
243   NonPermObject* &amp;bucket = find_non_perm(key);
244   if (bucket != NULL) {
245     return bucket-&gt;object();
246   }
247 
248   // The ciObject does not yet exist.  Create it and insert it
249   // into the cache.
250   Handle keyHandle(Thread::current(), key);
251   ciObject* new_object = create_new_object(keyHandle());
<span class="line-modified">252   assert(oopDesc::equals(keyHandle(), new_object-&gt;get_oop()), &quot;must be properly recorded&quot;);</span>
253   init_ident_of(new_object);
<span class="line-modified">254   assert(Universe::heap()-&gt;is_in_reserved(new_object-&gt;get_oop()), &quot;must be&quot;);</span>
255 
256   // Not a perm-space object.
257   insert_non_perm(bucket, keyHandle(), new_object);
258   return new_object;
259 }
260 
261 int ciObjectFactory::metadata_compare(Metadata* const&amp; key, ciMetadata* const&amp; elt) {
262   Metadata* value = elt-&gt;constant_encoding();
263   if (key &lt; value)      return -1;
264   else if (key &gt; value) return 1;
265   else                  return 0;
266 }
267 
268 // ------------------------------------------------------------------
269 // ciObjectFactory::cached_metadata
270 //
271 // Get the ciMetadata corresponding to some Metadata. If the ciMetadata has
272 // already been created, it is returned. Otherwise, null is returned.
273 ciMetadata* ciObjectFactory::cached_metadata(Metadata* key) {
274   ASSERT_IN_VM;
</pre>
<hr />
<pre>
399     return new (arena()) ciMethodData((MethodData*)o);
400   }
401 
402   // The Metadata* is of some type not supported by the compiler interface.
403   ShouldNotReachHere();
404   return NULL;
405 }
406 
407 //------------------------------------------------------------------
408 // ciObjectFactory::get_unloaded_method
409 //
410 // Get the ciMethod representing an unloaded/unfound method.
411 //
412 // Implementation note: unloaded methods are currently stored in
413 // an unordered array, requiring a linear-time lookup for each
414 // unloaded method.  This may need to change.
415 ciMethod* ciObjectFactory::get_unloaded_method(ciInstanceKlass* holder,
416                                                ciSymbol*        name,
417                                                ciSymbol*        signature,
418                                                ciInstanceKlass* accessor) {

419   ciSignature* that = NULL;
420   for (int i = 0; i &lt; _unloaded_methods-&gt;length(); i++) {
421     ciMethod* entry = _unloaded_methods-&gt;at(i);
422     if (entry-&gt;holder()-&gt;equals(holder) &amp;&amp;
423         entry-&gt;name()-&gt;equals(name) &amp;&amp;
424         entry-&gt;signature()-&gt;as_symbol()-&gt;equals(signature)) {
425       // Short-circuit slow resolve.
426       if (entry-&gt;signature()-&gt;accessing_klass() == accessor) {
427         // We&#39;ve found a match.
428         return entry;
429       } else {
430         // Lazily create ciSignature
431         if (that == NULL)  that = new (arena()) ciSignature(accessor, constantPoolHandle(), signature);
432         if (entry-&gt;signature()-&gt;equals(that)) {
433           // We&#39;ve found a match.
434           return entry;
435         }
436       }
437     }
438   }
</pre>
<hr />
<pre>
451 // ciObjectFactory::get_unloaded_klass
452 //
453 // Get a ciKlass representing an unloaded klass.
454 //
455 // Implementation note: unloaded klasses are currently stored in
456 // an unordered array, requiring a linear-time lookup for each
457 // unloaded klass.  This may need to change.
458 ciKlass* ciObjectFactory::get_unloaded_klass(ciKlass* accessing_klass,
459                                              ciSymbol* name,
460                                              bool create_if_not_found) {
461   EXCEPTION_CONTEXT;
462   oop loader = NULL;
463   oop domain = NULL;
464   if (accessing_klass != NULL) {
465     loader = accessing_klass-&gt;loader();
466     domain = accessing_klass-&gt;protection_domain();
467   }
468   for (int i=0; i&lt;_unloaded_klasses-&gt;length(); i++) {
469     ciKlass* entry = _unloaded_klasses-&gt;at(i);
470     if (entry-&gt;name()-&gt;equals(name) &amp;&amp;
<span class="line-modified">471         oopDesc::equals(entry-&gt;loader(), loader) &amp;&amp;</span>
<span class="line-modified">472         oopDesc::equals(entry-&gt;protection_domain(), domain)) {</span>
473       // We&#39;ve found a match.
474       return entry;
475     }
476   }
477 
478   if (!create_if_not_found)
479     return NULL;
480 
481   // This is a new unloaded klass.  Create it and stick it in
482   // the cache.
483   ciKlass* new_klass = NULL;
484 
485   // Two cases: this is an unloaded ObjArrayKlass or an
486   // unloaded InstanceKlass.  Deal with both.
<span class="line-modified">487   if (name-&gt;char_at(0) == &#39;[&#39;) {</span>
488     // Decompose the name.&#39;
<span class="line-modified">489     FieldArrayInfo fd;</span>
<span class="line-modified">490     BasicType element_type = FieldType::get_array_info(name-&gt;get_symbol(),</span>
<span class="line-modified">491                                                        fd, THREAD);</span>
<span class="line-removed">492     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">493       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">494       CURRENT_THREAD_ENV-&gt;record_out_of_memory_failure();</span>
<span class="line-removed">495       return ciEnv::_unloaded_ciobjarrayklass;</span>
<span class="line-removed">496     }</span>
<span class="line-removed">497     int dimension = fd.dimension();</span>
498     assert(element_type != T_ARRAY, &quot;unsuccessful decomposition&quot;);
499     ciKlass* element_klass = NULL;
500     if (element_type == T_OBJECT) {
501       ciEnv *env = CURRENT_THREAD_ENV;
<span class="line-modified">502       ciSymbol* ci_name = env-&gt;get_symbol(fd.object_key());</span>
503       element_klass =
504         env-&gt;get_klass_by_name(accessing_klass, ci_name, false)-&gt;as_instance_klass();
505     } else {
506       assert(dimension &gt; 1, &quot;one dimensional type arrays are always loaded.&quot;);
507 
508       // The type array itself takes care of one of the dimensions.
509       dimension--;
510 
511       // The element klass is a TypeArrayKlass.
512       element_klass = ciTypeArrayKlass::make(element_type);
513     }
514     new_klass = new (arena()) ciObjArrayKlass(name, element_klass, dimension);
515   } else {
516     jobject loader_handle = NULL;
517     jobject domain_handle = NULL;
518     if (accessing_klass != NULL) {
519       loader_handle = accessing_klass-&gt;loader_handle();
520       domain_handle = accessing_klass-&gt;protection_domain_handle();
521     }
522     new_klass = new (arena()) ciInstanceKlass(name, loader_handle, domain_handle);
</pre>
<hr />
<pre>
626   init_ident_of(new_ret_addr);
627   _return_addresses-&gt;append(new_ret_addr);
628   return new_ret_addr;
629 }
630 
631 // ------------------------------------------------------------------
632 // ciObjectFactory::init_ident_of
633 void ciObjectFactory::init_ident_of(ciBaseObject* obj) {
634   obj-&gt;set_ident(_next_ident++);
635 }
636 
637 static ciObjectFactory::NonPermObject* emptyBucket = NULL;
638 
639 // ------------------------------------------------------------------
640 // ciObjectFactory::find_non_perm
641 //
642 // Use a small hash table, hashed on the klass of the key.
643 // If there is no entry in the cache corresponding to this oop, return
644 // the null tail of the bucket into which the oop should be inserted.
645 ciObjectFactory::NonPermObject* &amp;ciObjectFactory::find_non_perm(oop key) {
<span class="line-modified">646   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);</span>
647   ciMetadata* klass = get_metadata(key-&gt;klass());
648   NonPermObject* *bp = &amp;_non_perm_bucket[(unsigned) klass-&gt;hash() % NON_PERM_BUCKETS];
649   for (NonPermObject* p; (p = (*bp)) != NULL; bp = &amp;p-&gt;next()) {
650     if (is_equal(p, key))  break;
651   }
652   return (*bp);
653 }
654 
655 
656 
657 // ------------------------------------------------------------------
658 // Code for for NonPermObject
659 //
660 inline ciObjectFactory::NonPermObject::NonPermObject(ciObjectFactory::NonPermObject* &amp;bucket, oop key, ciObject* object) {
661   assert(ciObjectFactory::is_initialized(), &quot;&quot;);
662   _object = object;
663   _next = bucket;
664   bucket = this;
665 }
666 
667 
668 
669 // ------------------------------------------------------------------
670 // ciObjectFactory::insert_non_perm
671 //
672 // Insert a ciObject into the non-perm table.
673 void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &amp;where, oop key, ciObject* obj) {
<span class="line-modified">674   assert(Universe::heap()-&gt;is_in_reserved_or_null(key), &quot;must be&quot;);</span>
675   assert(&amp;where != &amp;emptyBucket, &quot;must not try to fill empty bucket&quot;);
676   NonPermObject* p = new (arena()) NonPermObject(where, key, obj);
677   assert(where == p &amp;&amp; is_equal(p, key) &amp;&amp; p-&gt;object() == obj, &quot;entry must match&quot;);
678   assert(find_non_perm(key) == p, &quot;must find the same spot&quot;);
679   ++_non_perm_count;
680 }
681 
682 // ------------------------------------------------------------------
683 // ciObjectFactory::vm_symbol_at
684 // Get the ciSymbol corresponding to some index in vmSymbols.
685 ciSymbol* ciObjectFactory::vm_symbol_at(int index) {
686   assert(index &gt;= vmSymbols::FIRST_SID &amp;&amp; index &lt; vmSymbols::SID_LIMIT, &quot;oob&quot;);
687   return _shared_ci_symbols[index];
688 }
689 
690 // ------------------------------------------------------------------
691 // ciObjectFactory::metadata_do
<span class="line-modified">692 void ciObjectFactory::metadata_do(void f(Metadata*)) {</span>
693   if (_ci_metadata == NULL) return;
694   for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
695     Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
<span class="line-modified">696     f(o);</span>
697   }
698 }
699 
700 // ------------------------------------------------------------------
701 // ciObjectFactory::print_contents_impl
702 void ciObjectFactory::print_contents_impl() {
703   int len = _ci_metadata-&gt;length();
704   tty-&gt;print_cr(&quot;ciObjectFactory (%d) meta data contents:&quot;, len);
705   for (int i=0; i&lt;len; i++) {
706     _ci_metadata-&gt;at(i)-&gt;print();
707     tty-&gt;cr();
708   }
709 }
710 
711 // ------------------------------------------------------------------
712 // ciObjectFactory::print_contents
713 void ciObjectFactory::print_contents() {
714   print();
715   tty-&gt;cr();
716   GUARDED_VM_ENTRY(print_contents_impl();)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciMemberName.hpp&quot;
 30 #include &quot;ci/ciMethod.hpp&quot;
 31 #include &quot;ci/ciMethodData.hpp&quot;
 32 #include &quot;ci/ciMethodHandle.hpp&quot;
 33 #include &quot;ci/ciMethodType.hpp&quot;
 34 #include &quot;ci/ciNullObject.hpp&quot;
 35 #include &quot;ci/ciObjArray.hpp&quot;
 36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
 37 #include &quot;ci/ciObject.hpp&quot;
 38 #include &quot;ci/ciObjectFactory.hpp&quot;
 39 #include &quot;ci/ciSymbol.hpp&quot;
 40 #include &quot;ci/ciTypeArray.hpp&quot;
 41 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
 42 #include &quot;ci/ciUtilities.inline.hpp&quot;
 43 #include &quot;classfile/javaClasses.inline.hpp&quot;
 44 #include &quot;classfile/systemDictionary.hpp&quot;
 45 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 46 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 47 #include &quot;memory/universe.hpp&quot;</span>
 48 #include &quot;oops/oop.inline.hpp&quot;

 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;utilities/macros.hpp&quot;
 51 
 52 // ciObjectFactory
 53 //
 54 // This class handles requests for the creation of new instances
 55 // of ciObject and its subclasses.  It contains a caching mechanism
 56 // which ensures that for each oop, at most one ciObject is created.
 57 // This invariant allows more efficient implementation of ciObject.
 58 //
 59 // Implementation note: the oop-&gt;ciObject mapping is represented as
 60 // a table stored in an array.  Even though objects are moved
 61 // by the garbage collector, the compactor preserves their relative
 62 // order; address comparison of oops (in perm space) is safe so long
 63 // as we prohibit GC during our comparisons.  We currently use binary
 64 // search to find the oop in the table, and inserting a new oop
 65 // into the table may be costly.  If this cost ends up being
 66 // problematic the underlying data structure can be switched to some
 67 // sort of balanced binary tree.
 68 
</pre>
<hr />
<pre>
131       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
132       assert(vmSymbols::find_sid(vmsym) == i, &quot;1-1 mapping&quot;);
133       ciSymbol* sym = new (_arena) ciSymbol(vmsym, (vmSymbols::SID) i);
134       init_ident_of(sym);
135       _shared_ci_symbols[i] = sym;
136     }
137 #ifdef ASSERT
138     for (i = vmSymbols::FIRST_SID; i &lt; vmSymbols::SID_LIMIT; i++) {
139       Symbol* vmsym = vmSymbols::symbol_at((vmSymbols::SID) i);
140       ciSymbol* sym = vm_symbol_at((vmSymbols::SID) i);
141       assert(sym-&gt;get_symbol() == vmsym, &quot;oop must match&quot;);
142     }
143     assert(ciSymbol::void_class_signature()-&gt;get_symbol() == vmSymbols::void_class_signature(), &quot;spot check&quot;);
144 #endif
145   }
146 
147   _ci_metadata = new (_arena) GrowableArray&lt;ciMetadata*&gt;(_arena, 64, 0, NULL);
148 
149   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
150     BasicType t = (BasicType)i;
<span class="line-modified">151     if (type2name(t) != NULL &amp;&amp; !is_reference_type(t) &amp;&amp;</span>
<span class="line-added">152         t != T_NARROWOOP &amp;&amp; t != T_NARROWKLASS) {</span>
153       ciType::_basic_types[t] = new (_arena) ciType(t);
154       init_ident_of(ciType::_basic_types[t]);
155     }
156   }
157 
158   ciEnv::_null_object_instance = new (_arena) ciNullObject();
159   init_ident_of(ciEnv::_null_object_instance);
160 
161 #define WK_KLASS_DEFN(name, ignore_s)                              \
162   if (SystemDictionary::name##_is_loaded()) \
163     ciEnv::_##name = get_metadata(SystemDictionary::name())-&gt;as_instance_klass();
164 
165   WK_KLASSES_DO(WK_KLASS_DEFN)
166 #undef WK_KLASS_DEFN
167 
168   for (int len = -1; len != _ci_metadata-&gt;length(); ) {
169     len = _ci_metadata-&gt;length();
170     for (int i2 = 0; i2 &lt; len; i2++) {
171       ciMetadata* obj = _ci_metadata-&gt;at(i2);
172       assert (obj-&gt;is_metadata(), &quot;what else would it be?&quot;);
</pre>
<hr />
<pre>
222 
223 // Decrement the refcount when done on symbols referenced by this compilation.
224 void ciObjectFactory::remove_symbols() {
225   for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
226     ciSymbol* s = _symbols-&gt;at(i);
227     s-&gt;get_symbol()-&gt;decrement_refcount();
228   }
229   // Since _symbols is resource allocated we&#39;re not allowed to delete it
230   // but it&#39;ll go away just the same.
231 }
232 
233 // ------------------------------------------------------------------
234 // ciObjectFactory::get
235 //
236 // Get the ciObject corresponding to some oop.  If the ciObject has
237 // already been created, it is returned.  Otherwise, a new ciObject
238 // is created.
239 ciObject* ciObjectFactory::get(oop key) {
240   ASSERT_IN_VM;
241 
<span class="line-modified">242   assert(Universe::heap()-&gt;is_in(key), &quot;must be&quot;);</span>
243 
244   NonPermObject* &amp;bucket = find_non_perm(key);
245   if (bucket != NULL) {
246     return bucket-&gt;object();
247   }
248 
249   // The ciObject does not yet exist.  Create it and insert it
250   // into the cache.
251   Handle keyHandle(Thread::current(), key);
252   ciObject* new_object = create_new_object(keyHandle());
<span class="line-modified">253   assert(keyHandle() == new_object-&gt;get_oop(), &quot;must be properly recorded&quot;);</span>
254   init_ident_of(new_object);
<span class="line-modified">255   assert(Universe::heap()-&gt;is_in(new_object-&gt;get_oop()), &quot;must be&quot;);</span>
256 
257   // Not a perm-space object.
258   insert_non_perm(bucket, keyHandle(), new_object);
259   return new_object;
260 }
261 
262 int ciObjectFactory::metadata_compare(Metadata* const&amp; key, ciMetadata* const&amp; elt) {
263   Metadata* value = elt-&gt;constant_encoding();
264   if (key &lt; value)      return -1;
265   else if (key &gt; value) return 1;
266   else                  return 0;
267 }
268 
269 // ------------------------------------------------------------------
270 // ciObjectFactory::cached_metadata
271 //
272 // Get the ciMetadata corresponding to some Metadata. If the ciMetadata has
273 // already been created, it is returned. Otherwise, null is returned.
274 ciMetadata* ciObjectFactory::cached_metadata(Metadata* key) {
275   ASSERT_IN_VM;
</pre>
<hr />
<pre>
400     return new (arena()) ciMethodData((MethodData*)o);
401   }
402 
403   // The Metadata* is of some type not supported by the compiler interface.
404   ShouldNotReachHere();
405   return NULL;
406 }
407 
408 //------------------------------------------------------------------
409 // ciObjectFactory::get_unloaded_method
410 //
411 // Get the ciMethod representing an unloaded/unfound method.
412 //
413 // Implementation note: unloaded methods are currently stored in
414 // an unordered array, requiring a linear-time lookup for each
415 // unloaded method.  This may need to change.
416 ciMethod* ciObjectFactory::get_unloaded_method(ciInstanceKlass* holder,
417                                                ciSymbol*        name,
418                                                ciSymbol*        signature,
419                                                ciInstanceKlass* accessor) {
<span class="line-added">420   assert(accessor != NULL, &quot;need origin of access&quot;);</span>
421   ciSignature* that = NULL;
422   for (int i = 0; i &lt; _unloaded_methods-&gt;length(); i++) {
423     ciMethod* entry = _unloaded_methods-&gt;at(i);
424     if (entry-&gt;holder()-&gt;equals(holder) &amp;&amp;
425         entry-&gt;name()-&gt;equals(name) &amp;&amp;
426         entry-&gt;signature()-&gt;as_symbol()-&gt;equals(signature)) {
427       // Short-circuit slow resolve.
428       if (entry-&gt;signature()-&gt;accessing_klass() == accessor) {
429         // We&#39;ve found a match.
430         return entry;
431       } else {
432         // Lazily create ciSignature
433         if (that == NULL)  that = new (arena()) ciSignature(accessor, constantPoolHandle(), signature);
434         if (entry-&gt;signature()-&gt;equals(that)) {
435           // We&#39;ve found a match.
436           return entry;
437         }
438       }
439     }
440   }
</pre>
<hr />
<pre>
453 // ciObjectFactory::get_unloaded_klass
454 //
455 // Get a ciKlass representing an unloaded klass.
456 //
457 // Implementation note: unloaded klasses are currently stored in
458 // an unordered array, requiring a linear-time lookup for each
459 // unloaded klass.  This may need to change.
460 ciKlass* ciObjectFactory::get_unloaded_klass(ciKlass* accessing_klass,
461                                              ciSymbol* name,
462                                              bool create_if_not_found) {
463   EXCEPTION_CONTEXT;
464   oop loader = NULL;
465   oop domain = NULL;
466   if (accessing_klass != NULL) {
467     loader = accessing_klass-&gt;loader();
468     domain = accessing_klass-&gt;protection_domain();
469   }
470   for (int i=0; i&lt;_unloaded_klasses-&gt;length(); i++) {
471     ciKlass* entry = _unloaded_klasses-&gt;at(i);
472     if (entry-&gt;name()-&gt;equals(name) &amp;&amp;
<span class="line-modified">473         entry-&gt;loader() == loader &amp;&amp;</span>
<span class="line-modified">474         entry-&gt;protection_domain() == domain) {</span>
475       // We&#39;ve found a match.
476       return entry;
477     }
478   }
479 
480   if (!create_if_not_found)
481     return NULL;
482 
483   // This is a new unloaded klass.  Create it and stick it in
484   // the cache.
485   ciKlass* new_klass = NULL;
486 
487   // Two cases: this is an unloaded ObjArrayKlass or an
488   // unloaded InstanceKlass.  Deal with both.
<span class="line-modified">489   if (name-&gt;char_at(0) == JVM_SIGNATURE_ARRAY) {</span>
490     // Decompose the name.&#39;
<span class="line-modified">491     SignatureStream ss(name-&gt;get_symbol(), false);</span>
<span class="line-modified">492     int dimension = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-modified">493     BasicType element_type = ss.type();</span>






494     assert(element_type != T_ARRAY, &quot;unsuccessful decomposition&quot;);
495     ciKlass* element_klass = NULL;
496     if (element_type == T_OBJECT) {
497       ciEnv *env = CURRENT_THREAD_ENV;
<span class="line-modified">498       ciSymbol* ci_name = env-&gt;get_symbol(ss.as_symbol());</span>
499       element_klass =
500         env-&gt;get_klass_by_name(accessing_klass, ci_name, false)-&gt;as_instance_klass();
501     } else {
502       assert(dimension &gt; 1, &quot;one dimensional type arrays are always loaded.&quot;);
503 
504       // The type array itself takes care of one of the dimensions.
505       dimension--;
506 
507       // The element klass is a TypeArrayKlass.
508       element_klass = ciTypeArrayKlass::make(element_type);
509     }
510     new_klass = new (arena()) ciObjArrayKlass(name, element_klass, dimension);
511   } else {
512     jobject loader_handle = NULL;
513     jobject domain_handle = NULL;
514     if (accessing_klass != NULL) {
515       loader_handle = accessing_klass-&gt;loader_handle();
516       domain_handle = accessing_klass-&gt;protection_domain_handle();
517     }
518     new_klass = new (arena()) ciInstanceKlass(name, loader_handle, domain_handle);
</pre>
<hr />
<pre>
622   init_ident_of(new_ret_addr);
623   _return_addresses-&gt;append(new_ret_addr);
624   return new_ret_addr;
625 }
626 
627 // ------------------------------------------------------------------
628 // ciObjectFactory::init_ident_of
629 void ciObjectFactory::init_ident_of(ciBaseObject* obj) {
630   obj-&gt;set_ident(_next_ident++);
631 }
632 
633 static ciObjectFactory::NonPermObject* emptyBucket = NULL;
634 
635 // ------------------------------------------------------------------
636 // ciObjectFactory::find_non_perm
637 //
638 // Use a small hash table, hashed on the klass of the key.
639 // If there is no entry in the cache corresponding to this oop, return
640 // the null tail of the bucket into which the oop should be inserted.
641 ciObjectFactory::NonPermObject* &amp;ciObjectFactory::find_non_perm(oop key) {
<span class="line-modified">642   assert(Universe::heap()-&gt;is_in(key), &quot;must be&quot;);</span>
643   ciMetadata* klass = get_metadata(key-&gt;klass());
644   NonPermObject* *bp = &amp;_non_perm_bucket[(unsigned) klass-&gt;hash() % NON_PERM_BUCKETS];
645   for (NonPermObject* p; (p = (*bp)) != NULL; bp = &amp;p-&gt;next()) {
646     if (is_equal(p, key))  break;
647   }
648   return (*bp);
649 }
650 
651 
652 
653 // ------------------------------------------------------------------
654 // Code for for NonPermObject
655 //
656 inline ciObjectFactory::NonPermObject::NonPermObject(ciObjectFactory::NonPermObject* &amp;bucket, oop key, ciObject* object) {
657   assert(ciObjectFactory::is_initialized(), &quot;&quot;);
658   _object = object;
659   _next = bucket;
660   bucket = this;
661 }
662 
663 
664 
665 // ------------------------------------------------------------------
666 // ciObjectFactory::insert_non_perm
667 //
668 // Insert a ciObject into the non-perm table.
669 void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &amp;where, oop key, ciObject* obj) {
<span class="line-modified">670   assert(Universe::heap()-&gt;is_in_or_null(key), &quot;must be&quot;);</span>
671   assert(&amp;where != &amp;emptyBucket, &quot;must not try to fill empty bucket&quot;);
672   NonPermObject* p = new (arena()) NonPermObject(where, key, obj);
673   assert(where == p &amp;&amp; is_equal(p, key) &amp;&amp; p-&gt;object() == obj, &quot;entry must match&quot;);
674   assert(find_non_perm(key) == p, &quot;must find the same spot&quot;);
675   ++_non_perm_count;
676 }
677 
678 // ------------------------------------------------------------------
679 // ciObjectFactory::vm_symbol_at
680 // Get the ciSymbol corresponding to some index in vmSymbols.
681 ciSymbol* ciObjectFactory::vm_symbol_at(int index) {
682   assert(index &gt;= vmSymbols::FIRST_SID &amp;&amp; index &lt; vmSymbols::SID_LIMIT, &quot;oob&quot;);
683   return _shared_ci_symbols[index];
684 }
685 
686 // ------------------------------------------------------------------
687 // ciObjectFactory::metadata_do
<span class="line-modified">688 void ciObjectFactory::metadata_do(MetadataClosure* f) {</span>
689   if (_ci_metadata == NULL) return;
690   for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
691     Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
<span class="line-modified">692     f-&gt;do_metadata(o);</span>
693   }
694 }
695 
696 // ------------------------------------------------------------------
697 // ciObjectFactory::print_contents_impl
698 void ciObjectFactory::print_contents_impl() {
699   int len = _ci_metadata-&gt;length();
700   tty-&gt;print_cr(&quot;ciObjectFactory (%d) meta data contents:&quot;, len);
701   for (int i=0; i&lt;len; i++) {
702     _ci_metadata-&gt;at(i)-&gt;print();
703     tty-&gt;cr();
704   }
705 }
706 
707 // ------------------------------------------------------------------
708 // ciObjectFactory::print_contents
709 void ciObjectFactory::print_contents() {
710   print();
711   tty-&gt;cr();
712   GUARDED_VM_ENTRY(print_contents_impl();)
</pre>
</td>
</tr>
</table>
<center><a href="ciObjArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciObjectFactory.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
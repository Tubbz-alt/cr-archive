<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified"> 35 #include &quot;oops/fieldStreams.hpp&quot;</span>
 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/jniHandles.inline.hpp&quot;
 39 
 40 // ciInstanceKlass
 41 //
 42 // This class represents a Klass* in the HotSpot virtual machine
 43 // whose Klass part in an InstanceKlass.
 44 
 45 
 46 // ------------------------------------------------------------------
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
 99 
100   // Lazy fields get filled in only upon request.
101   _super  = NULL;
102   _java_mirror = NULL;
103 
104   if (is_shared()) {
105     if (k != SystemDictionary::Object_klass()) {
106       super();
107     }
108     //compute_nonstatic_fields();  // done outside of constructor
109   }
110 
111   _field_cache = NULL;
112 }
113 
114 // Version for unloaded classes:
115 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
116                                  jobject loader, jobject protection_domain)
117   : ciKlass(name, T_OBJECT)
118 {
<span class="line-modified">119   assert(name-&gt;char_at(0) != &#39;[&#39;, &quot;not an instance klass&quot;);</span>
120   _init_state = (InstanceKlass::ClassState)0;
121   _nonstatic_field_size = -1;
122   _has_nonstatic_fields = false;
123   _nonstatic_fields = NULL;
124   _has_injected_fields = -1;
125   _is_unsafe_anonymous = false;
126   _loader = loader;
127   _protection_domain = protection_domain;
128   _is_shared = false;
129   _super = NULL;
130   _java_mirror = NULL;
131   _field_cache = NULL;
132 }
133 
134 
135 
136 // ------------------------------------------------------------------
137 // ciInstanceKlass::compute_shared_is_initialized
138 void ciInstanceKlass::compute_shared_init_state() {
139   GUARDED_VM_ENTRY(
</pre>
<hr />
<pre>
196 
197 // ------------------------------------------------------------------
198 // ciInstanceKlass::get_canonical_holder
199 //
200 ciInstanceKlass* ciInstanceKlass::get_canonical_holder(int offset) {
201   #ifdef ASSERT
202   if (!(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper())) {
203     tty-&gt;print(&quot;*** get_canonical_holder(%d) on &quot;, offset);
204     this-&gt;print();
205     tty-&gt;print_cr(&quot; ***&quot;);
206   };
207   assert(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper(), &quot;offset must be tame&quot;);
208   #endif
209 
210   if (offset &lt; instanceOopDesc::base_offset_in_bytes()) {
211     // All header offsets belong properly to java/lang/Object.
212     return CURRENT_ENV-&gt;Object_klass();
213   }
214 
215   ciInstanceKlass* self = this;
<span class="line-modified">216   for (;;) {</span>
<span class="line-modified">217     assert(self-&gt;is_loaded(), &quot;must be loaded to have size&quot;);</span>
<span class="line-modified">218     ciInstanceKlass* super = self-&gt;super();</span>
<span class="line-modified">219     if (super == NULL || super-&gt;nof_nonstatic_fields() == 0 ||</span>
<span class="line-modified">220         !super-&gt;contains_field_offset(offset)) {</span>
<span class="line-modified">221       return self;</span>
<span class="line-modified">222     } else {</span>
<span class="line-modified">223       self = super;  // return super-&gt;get_canonical_holder(offset)</span>





224     }
225   }
226 }
227 
228 // ------------------------------------------------------------------
229 // ciInstanceKlass::is_java_lang_Object
230 //
231 // Is this klass java.lang.Object?
232 bool ciInstanceKlass::is_java_lang_Object() const {
233   return equals(CURRENT_ENV-&gt;Object_klass());
234 }
235 
236 // ------------------------------------------------------------------
237 // ciInstanceKlass::uses_default_loader
238 bool ciInstanceKlass::uses_default_loader() const {
239   // Note:  We do not need to resolve the handle or enter the VM
240   // in order to test null-ness.
241   return _loader == NULL;
242 }
243 
</pre>
<hr />
<pre>
298   if ((len + 1) &gt; name()-&gt;utf8_length())
299     return false;
300 
301   // Test for trailing &#39;/&#39;
302   if (name()-&gt;char_at(len) != &#39;/&#39;)
303     return false;
304 
305   // Make sure it&#39;s not actually in a subpackage:
306   if (name()-&gt;index_of_at(len+1, &quot;/&quot;, 1) &gt;= 0)
307     return false;
308 
309   return true;
310 }
311 
312 // ------------------------------------------------------------------
313 // ciInstanceKlass::print_impl
314 //
315 // Implementation of the print method.
316 void ciInstanceKlass::print_impl(outputStream* st) {
317   ciKlass::print_impl(st);
<span class="line-modified">318   GUARDED_VM_ENTRY(st-&gt;print(&quot; loader=&quot; INTPTR_FORMAT, p2i((address)loader()));)</span>
319   if (is_loaded()) {
320     st-&gt;print(&quot; loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=&quot;,
321               bool_to_str(is_initialized()),
322               bool_to_str(has_finalizer()),
323               bool_to_str(has_subklass()),
324               layout_helper());
325 
326     _flags.print_klass_flags();
327 
328     if (_super) {
329       st-&gt;print(&quot; super=&quot;);
330       _super-&gt;print_name();
331     }
332     if (_java_mirror) {
333       st-&gt;print(&quot; mirror=PRESENT&quot;);
334     }
335   } else {
336     st-&gt;print(&quot; loaded=false&quot;);
337   }
338 }
</pre>
<hr />
<pre>
374   if (!is_abstract())   return NULL; // Only applies to abstract classes.
375   if (!has_subklass())  return NULL; // Must have at least one subklass.
376   VM_ENTRY_MARK;
377   InstanceKlass* ik = get_instanceKlass();
378   Klass* up = ik-&gt;up_cast_abstract();
379   assert(up-&gt;is_instance_klass(), &quot;must be InstanceKlass&quot;);
380   if (ik == up) {
381     return NULL;
382   }
383   return CURRENT_THREAD_ENV-&gt;get_instance_klass(up);
384 }
385 
386 // ------------------------------------------------------------------
387 // ciInstanceKlass::has_finalizable_subclass
388 bool ciInstanceKlass::has_finalizable_subclass() {
389   if (!is_loaded())     return true;
390   VM_ENTRY_MARK;
391   return Dependencies::find_finalizable_subclass(get_instanceKlass()) != NULL;
392 }
393 







394 // ------------------------------------------------------------------
395 // ciInstanceKlass::get_field_by_offset
396 ciField* ciInstanceKlass::get_field_by_offset(int field_offset, bool is_static) {
397   if (!is_static) {
398     for (int i = 0, len = nof_nonstatic_fields(); i &lt; len; i++) {
399       ciField* field = _nonstatic_fields-&gt;at(i);
400       int  field_off = field-&gt;offset_in_bytes();
401       if (field_off == field_offset)
402         return field;
403       if (field_off &gt; field_offset)
404         break;
405       // could do binary search or check bins, but probably not worth it
406     }
407     return NULL;
408   }
409   VM_ENTRY_MARK;
410   InstanceKlass* k = get_instanceKlass();
411   fieldDescriptor fd;
412   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
413     return NULL;
</pre>
<hr />
<pre>
440 // ciInstanceKlass::compute_nonstatic_fields
441 int ciInstanceKlass::compute_nonstatic_fields() {
442   assert(is_loaded(), &quot;must be loaded&quot;);
443 
444   if (_nonstatic_fields != NULL)
445     return _nonstatic_fields-&gt;length();
446 
447   if (!has_nonstatic_fields()) {
448     Arena* arena = CURRENT_ENV-&gt;arena();
449     _nonstatic_fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, 0, 0, NULL);
450     return 0;
451   }
452   assert(!is_java_lang_Object(), &quot;bootstrap OK&quot;);
453 
454   // Size in bytes of my fields, including inherited fields.
455   int fsize = nonstatic_field_size() * heapOopSize;
456 
457   ciInstanceKlass* super = this-&gt;super();
458   GrowableArray&lt;ciField*&gt;* super_fields = NULL;
459   if (super != NULL &amp;&amp; super-&gt;has_nonstatic_fields()) {
<span class="line-removed">460     int super_fsize  = super-&gt;nonstatic_field_size() * heapOopSize;</span>
461     int super_flen   = super-&gt;nof_nonstatic_fields();
462     super_fields = super-&gt;_nonstatic_fields;
463     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
<span class="line-removed">464     // See if I am no larger than my super; if so, I can use his fields.</span>
<span class="line-removed">465     if (fsize == super_fsize) {</span>
<span class="line-removed">466       _nonstatic_fields = super_fields;</span>
<span class="line-removed">467       return super_fields-&gt;length();</span>
<span class="line-removed">468     }</span>
469   }
470 
471   GrowableArray&lt;ciField*&gt;* fields = NULL;
472   GUARDED_VM_ENTRY({
473       fields = compute_nonstatic_fields_impl(super_fields);
474     });
475 
476   if (fields == NULL) {
477     // This can happen if this class (java.lang.Class) has invisible fields.
478     if (super_fields != NULL) {
479       _nonstatic_fields = super_fields;
480       return super_fields-&gt;length();
481     } else {
482       return 0;
483     }
484   }
485 
486   int flen = fields-&gt;length();
487 
488   // Now sort them by offset, ascending.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified"> 35 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/jniHandles.inline.hpp&quot;
 39 
 40 // ciInstanceKlass
 41 //
 42 // This class represents a Klass* in the HotSpot virtual machine
 43 // whose Klass part in an InstanceKlass.
 44 
 45 
 46 // ------------------------------------------------------------------
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
 99 
100   // Lazy fields get filled in only upon request.
101   _super  = NULL;
102   _java_mirror = NULL;
103 
104   if (is_shared()) {
105     if (k != SystemDictionary::Object_klass()) {
106       super();
107     }
108     //compute_nonstatic_fields();  // done outside of constructor
109   }
110 
111   _field_cache = NULL;
112 }
113 
114 // Version for unloaded classes:
115 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
116                                  jobject loader, jobject protection_domain)
117   : ciKlass(name, T_OBJECT)
118 {
<span class="line-modified">119   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);</span>
120   _init_state = (InstanceKlass::ClassState)0;
121   _nonstatic_field_size = -1;
122   _has_nonstatic_fields = false;
123   _nonstatic_fields = NULL;
124   _has_injected_fields = -1;
125   _is_unsafe_anonymous = false;
126   _loader = loader;
127   _protection_domain = protection_domain;
128   _is_shared = false;
129   _super = NULL;
130   _java_mirror = NULL;
131   _field_cache = NULL;
132 }
133 
134 
135 
136 // ------------------------------------------------------------------
137 // ciInstanceKlass::compute_shared_is_initialized
138 void ciInstanceKlass::compute_shared_init_state() {
139   GUARDED_VM_ENTRY(
</pre>
<hr />
<pre>
196 
197 // ------------------------------------------------------------------
198 // ciInstanceKlass::get_canonical_holder
199 //
200 ciInstanceKlass* ciInstanceKlass::get_canonical_holder(int offset) {
201   #ifdef ASSERT
202   if (!(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper())) {
203     tty-&gt;print(&quot;*** get_canonical_holder(%d) on &quot;, offset);
204     this-&gt;print();
205     tty-&gt;print_cr(&quot; ***&quot;);
206   };
207   assert(offset &gt;= 0 &amp;&amp; offset &lt; layout_helper(), &quot;offset must be tame&quot;);
208   #endif
209 
210   if (offset &lt; instanceOopDesc::base_offset_in_bytes()) {
211     // All header offsets belong properly to java/lang/Object.
212     return CURRENT_ENV-&gt;Object_klass();
213   }
214 
215   ciInstanceKlass* self = this;
<span class="line-modified">216   assert(self-&gt;is_loaded(), &quot;must be loaded to access field info&quot;);</span>
<span class="line-modified">217   ciField* field = self-&gt;get_field_by_offset(offset, false);</span>
<span class="line-modified">218   if (field != NULL) {</span>
<span class="line-modified">219     return field-&gt;holder();</span>
<span class="line-modified">220   } else {</span>
<span class="line-modified">221     for (;;) {</span>
<span class="line-modified">222       assert(self-&gt;is_loaded(), &quot;must be loaded to have size&quot;);</span>
<span class="line-modified">223       ciInstanceKlass* super = self-&gt;super();</span>
<span class="line-added">224       if (super == NULL || super-&gt;nof_nonstatic_fields() == 0) {</span>
<span class="line-added">225         return self;</span>
<span class="line-added">226       } else {</span>
<span class="line-added">227         self = super;  // return super-&gt;get_canonical_holder(offset)</span>
<span class="line-added">228       }</span>
229     }
230   }
231 }
232 
233 // ------------------------------------------------------------------
234 // ciInstanceKlass::is_java_lang_Object
235 //
236 // Is this klass java.lang.Object?
237 bool ciInstanceKlass::is_java_lang_Object() const {
238   return equals(CURRENT_ENV-&gt;Object_klass());
239 }
240 
241 // ------------------------------------------------------------------
242 // ciInstanceKlass::uses_default_loader
243 bool ciInstanceKlass::uses_default_loader() const {
244   // Note:  We do not need to resolve the handle or enter the VM
245   // in order to test null-ness.
246   return _loader == NULL;
247 }
248 
</pre>
<hr />
<pre>
303   if ((len + 1) &gt; name()-&gt;utf8_length())
304     return false;
305 
306   // Test for trailing &#39;/&#39;
307   if (name()-&gt;char_at(len) != &#39;/&#39;)
308     return false;
309 
310   // Make sure it&#39;s not actually in a subpackage:
311   if (name()-&gt;index_of_at(len+1, &quot;/&quot;, 1) &gt;= 0)
312     return false;
313 
314   return true;
315 }
316 
317 // ------------------------------------------------------------------
318 // ciInstanceKlass::print_impl
319 //
320 // Implementation of the print method.
321 void ciInstanceKlass::print_impl(outputStream* st) {
322   ciKlass::print_impl(st);
<span class="line-modified">323   GUARDED_VM_ENTRY(st-&gt;print(&quot; loader=&quot; INTPTR_FORMAT, p2i(loader()));)</span>
324   if (is_loaded()) {
325     st-&gt;print(&quot; loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=&quot;,
326               bool_to_str(is_initialized()),
327               bool_to_str(has_finalizer()),
328               bool_to_str(has_subklass()),
329               layout_helper());
330 
331     _flags.print_klass_flags();
332 
333     if (_super) {
334       st-&gt;print(&quot; super=&quot;);
335       _super-&gt;print_name();
336     }
337     if (_java_mirror) {
338       st-&gt;print(&quot; mirror=PRESENT&quot;);
339     }
340   } else {
341     st-&gt;print(&quot; loaded=false&quot;);
342   }
343 }
</pre>
<hr />
<pre>
379   if (!is_abstract())   return NULL; // Only applies to abstract classes.
380   if (!has_subklass())  return NULL; // Must have at least one subklass.
381   VM_ENTRY_MARK;
382   InstanceKlass* ik = get_instanceKlass();
383   Klass* up = ik-&gt;up_cast_abstract();
384   assert(up-&gt;is_instance_klass(), &quot;must be InstanceKlass&quot;);
385   if (ik == up) {
386     return NULL;
387   }
388   return CURRENT_THREAD_ENV-&gt;get_instance_klass(up);
389 }
390 
391 // ------------------------------------------------------------------
392 // ciInstanceKlass::has_finalizable_subclass
393 bool ciInstanceKlass::has_finalizable_subclass() {
394   if (!is_loaded())     return true;
395   VM_ENTRY_MARK;
396   return Dependencies::find_finalizable_subclass(get_instanceKlass()) != NULL;
397 }
398 
<span class="line-added">399 // ------------------------------------------------------------------</span>
<span class="line-added">400 // ciInstanceKlass::contains_field_offset</span>
<span class="line-added">401 bool ciInstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">402   VM_ENTRY_MARK;</span>
<span class="line-added">403   return get_instanceKlass()-&gt;contains_field_offset(offset);</span>
<span class="line-added">404 }</span>
<span class="line-added">405 </span>
406 // ------------------------------------------------------------------
407 // ciInstanceKlass::get_field_by_offset
408 ciField* ciInstanceKlass::get_field_by_offset(int field_offset, bool is_static) {
409   if (!is_static) {
410     for (int i = 0, len = nof_nonstatic_fields(); i &lt; len; i++) {
411       ciField* field = _nonstatic_fields-&gt;at(i);
412       int  field_off = field-&gt;offset_in_bytes();
413       if (field_off == field_offset)
414         return field;
415       if (field_off &gt; field_offset)
416         break;
417       // could do binary search or check bins, but probably not worth it
418     }
419     return NULL;
420   }
421   VM_ENTRY_MARK;
422   InstanceKlass* k = get_instanceKlass();
423   fieldDescriptor fd;
424   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
425     return NULL;
</pre>
<hr />
<pre>
452 // ciInstanceKlass::compute_nonstatic_fields
453 int ciInstanceKlass::compute_nonstatic_fields() {
454   assert(is_loaded(), &quot;must be loaded&quot;);
455 
456   if (_nonstatic_fields != NULL)
457     return _nonstatic_fields-&gt;length();
458 
459   if (!has_nonstatic_fields()) {
460     Arena* arena = CURRENT_ENV-&gt;arena();
461     _nonstatic_fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, 0, 0, NULL);
462     return 0;
463   }
464   assert(!is_java_lang_Object(), &quot;bootstrap OK&quot;);
465 
466   // Size in bytes of my fields, including inherited fields.
467   int fsize = nonstatic_field_size() * heapOopSize;
468 
469   ciInstanceKlass* super = this-&gt;super();
470   GrowableArray&lt;ciField*&gt;* super_fields = NULL;
471   if (super != NULL &amp;&amp; super-&gt;has_nonstatic_fields()) {

472     int super_flen   = super-&gt;nof_nonstatic_fields();
473     super_fields = super-&gt;_nonstatic_fields;
474     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);





475   }
476 
477   GrowableArray&lt;ciField*&gt;* fields = NULL;
478   GUARDED_VM_ENTRY({
479       fields = compute_nonstatic_fields_impl(super_fields);
480     });
481 
482   if (fields == NULL) {
483     // This can happen if this class (java.lang.Class) has invisible fields.
484     if (super_fields != NULL) {
485       _nonstatic_fields = super_fields;
486       return super_fields-&gt;length();
487     } else {
488       return 0;
489     }
490   }
491 
492   int flen = fields-&gt;length();
493 
494   // Now sort them by offset, ascending.
</pre>
</td>
</tr>
</table>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciReplay.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjectFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciSignature.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciReplay.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;ci/ciSymbol.hpp&quot;
  30 #include &quot;ci/ciKlass.hpp&quot;
  31 #include &quot;ci/ciUtilities.inline.hpp&quot;

  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/constantPool.hpp&quot;
  37 #include &quot;oops/method.inline.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  40 #include &quot;runtime/handles.inline.hpp&quot;
  41 #include &quot;utilities/copy.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;

  43 
  44 #ifndef PRODUCT
  45 
  46 // ciReplay
  47 
  48 typedef struct _ciMethodDataRecord {
  49   const char* _klass_name;
  50   const char* _method_name;
  51   const char* _signature;
  52 
  53   int _state;
  54   int _current_mileage;
  55 
  56   intptr_t* _data;
  57   char*     _orig_data;
  58   Klass**   _classes;
  59   Method**  _methods;
  60   int*      _classes_offsets;
  61   int*      _methods_offsets;
  62   int       _data_length;
</pre>
<hr />
<pre>
 317   //   &#39;tag&#39; &lt;length&gt; # # ...
 318   // Where each # is an intptr_t item
 319   intptr_t* parse_intptr_data(const char* tag, int&amp; length) {
 320     if (!parse_tag_and_count(tag, length)) {
 321       return NULL;
 322     }
 323 
 324     intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
 325     for (int i = 0; i &lt; length; i++) {
 326       skip_ws();
 327       intptr_t val = parse_intptr_t(&quot;data&quot;);
 328       result[i] = val;
 329     }
 330     return result;
 331   }
 332 
 333   // Parse a possibly quoted version of a symbol into a symbolOop
 334   Symbol* parse_symbol(TRAPS) {
 335     const char* str = parse_escaped_string();
 336     if (str != NULL) {
<span class="line-modified"> 337       Symbol* sym = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
 338       return sym;
 339     }
 340     return NULL;
 341   }
 342 
 343   // Parse a valid klass name and look it up
 344   Klass* parse_klass(TRAPS) {
 345     const char* str = parse_escaped_string();
<span class="line-modified"> 346     Symbol* klass_name = SymbolTable::lookup(str, (int)strlen(str), CHECK_NULL);</span>
 347     if (klass_name != NULL) {
 348       Klass* k = NULL;
 349       if (_iklass != NULL) {
 350         k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
 351       } else {
 352         k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 353       }
 354       if (HAS_PENDING_EXCEPTION) {
 355         oop throwable = PENDING_EXCEPTION;
 356         java_lang_Throwable::print(throwable, tty);
 357         tty-&gt;cr();
 358         report_error(str);
 359         if (ReplayIgnoreInitErrors) {
 360           CLEAR_PENDING_EXCEPTION;
 361           _error_message = NULL;
 362         }
 363         return NULL;
 364       }
 365       return k;
 366     }
 367     return NULL;
 368   }
 369 
 370   // Lookup a klass
 371   Klass* resolve_klass(const char* klass, TRAPS) {
<span class="line-modified"> 372     Symbol* klass_name = SymbolTable::lookup(klass, (int)strlen(klass), CHECK_NULL);</span>
 373     return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 374   }
 375 
 376   // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
 377   Method* parse_method(TRAPS) {
 378     InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
 379     if (k == NULL) {
 380       report_error(&quot;Can&#39;t find holder klass&quot;);
 381       return NULL;
 382     }
 383     Symbol* method_name = parse_symbol(CHECK_NULL);
 384     Symbol* method_signature = parse_symbol(CHECK_NULL);
 385     Method* m = k-&gt;find_method(method_name, method_signature);
 386     if (m == NULL) {
 387       report_error(&quot;Can&#39;t find method&quot;);
 388     }
 389     return m;
 390   }
 391 
 392   int get_line(int c) {
</pre>
<hr />
<pre>
 513       }
 514       if (_ci_inline_records != NULL &amp;&amp; _ci_inline_records-&gt;length() &gt; 0) {
 515         // Found inlining record for the requested method.
 516         return _ci_inline_records;
 517       }
 518       line_no++;
 519     }
 520     return NULL;
 521   }
 522 
 523   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 524   void process_compile(TRAPS) {
 525     Method* method = parse_method(CHECK);
 526     if (had_error()) return;
 527     int entry_bci = parse_int(&quot;entry_bci&quot;);
 528     const char* comp_level_label = &quot;comp_level&quot;;
 529     int comp_level = parse_int(comp_level_label);
 530     // old version w/o comp_level
 531     if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
 532       // use highest available tier
<span class="line-modified"> 533       comp_level = TieredCompilation ? TieredStopAtLevel : CompLevel_highest_tier;</span>




 534     }
 535     if (!is_valid_comp_level(comp_level)) {
 536       return;
 537     }
 538     if (_imethod != NULL) {
 539       // Replay Inlining
 540       if (entry_bci != _entry_bci || comp_level != _comp_level) {
 541         return;
 542       }
 543       const char* iklass_name  = _imethod-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 544       const char* imethod_name = _imethod-&gt;name()-&gt;as_utf8();
 545       const char* isignature   = _imethod-&gt;signature()-&gt;as_utf8();
 546       const char* klass_name   = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 547       const char* method_name  = method-&gt;name()-&gt;as_utf8();
 548       const char* signature    = method-&gt;signature()-&gt;as_utf8();
 549       if (strcmp(iklass_name,  klass_name)  != 0 ||
 550           strcmp(imethod_name, method_name) != 0 ||
 551           strcmp(isignature,   signature)   != 0) {
 552         return;
 553       }
</pre>
<hr />
<pre>
 574     }
 575     InstanceKlass* ik = method-&gt;method_holder();
 576     ik-&gt;initialize(THREAD);
 577     if (HAS_PENDING_EXCEPTION) {
 578       oop throwable = PENDING_EXCEPTION;
 579       java_lang_Throwable::print(throwable, tty);
 580       tty-&gt;cr();
 581       if (ReplayIgnoreInitErrors) {
 582         CLEAR_PENDING_EXCEPTION;
 583         ik-&gt;set_init_state(InstanceKlass::fully_initialized);
 584       } else {
 585         return;
 586       }
 587     }
 588     // Make sure the existence of a prior compile doesn&#39;t stop this one
 589     CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
 590     if (nm != NULL) {
 591       nm-&gt;make_not_entrant();
 592     }
 593     replay_state = this;
<span class="line-modified"> 594     CompileBroker::compile_method(method, entry_bci, comp_level,</span>
 595                                   methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
 596     replay_state = NULL;
 597     reset();
 598   }
 599 
 600   // ciMethod &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;invocation_counter&gt; &lt;backedge_counter&gt; &lt;interpreter_invocation_count&gt; &lt;interpreter_throwout_count&gt; &lt;instructions_size&gt;
 601   //
 602   //
 603   void process_ciMethod(TRAPS) {
 604     Method* method = parse_method(CHECK);
 605     if (had_error()) return;
 606     ciMethodRecord* rec = new_ciMethod(method);
 607     rec-&gt;_invocation_counter = parse_int(&quot;invocation_counter&quot;);
 608     rec-&gt;_backedge_counter = parse_int(&quot;backedge_counter&quot;);
 609     rec-&gt;_interpreter_invocation_count = parse_int(&quot;interpreter_invocation_count&quot;);
 610     rec-&gt;_interpreter_throwout_count = parse_int(&quot;interpreter_throwout_count&quot;);
 611     rec-&gt;_instructions_size = parse_int(&quot;instructions_size&quot;);
 612   }
 613 
 614   // ciMethodData &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;state&gt; &lt;current mileage&gt; orig &lt;length&gt; # # ... data &lt;length&gt; # # ... oops &lt;length&gt; # ... methods &lt;length&gt;
 615   void process_ciMethodData(TRAPS) {
 616     Method* method = parse_method(CHECK);
 617     if (had_error()) return;
 618     /* just copied from Method, to build interpret data*/
 619 
 620     // To be properly initialized, some profiling in the MDO needs the
 621     // method to be rewritten (number of arguments at a call for
 622     // instance)
 623     method-&gt;method_holder()-&gt;link_class(CHECK);
 624     // methodOopDesc::build_interpreter_method_data(method, CHECK);
 625     {
 626       // Grab a lock here to prevent multiple
 627       // MethodData*s from being created.
<span class="line-modified"> 628       MutexLocker ml(MethodData_lock, THREAD);</span>
 629       if (method-&gt;method_data() == NULL) {
 630         ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
<span class="line-modified"> 631         MethodData* method_data = MethodData::allocate(loader_data, method, CHECK);</span>
 632         method-&gt;set_method_data(method_data);
 633       }
 634     }
 635 
 636     // collect and record all the needed information for later
 637     ciMethodDataRecord* rec = new_ciMethodData(method);
 638     rec-&gt;_state = parse_int(&quot;state&quot;);
 639     rec-&gt;_current_mileage = parse_int(&quot;current_mileage&quot;);
 640 
 641     rec-&gt;_orig_data = parse_data(&quot;orig&quot;, rec-&gt;_orig_data_length);
 642     if (rec-&gt;_orig_data == NULL) {
 643       return;
 644     }
 645     rec-&gt;_data = parse_intptr_data(&quot;data&quot;, rec-&gt;_data_length);
 646     if (rec-&gt;_data == NULL) {
 647       return;
 648     }
 649     if (!parse_tag_and_count(&quot;oops&quot;, rec-&gt;_classes_length)) {
 650       return;
 651     }
</pre>
<hr />
<pre>
 781     }
 782   }
 783 
 784   // Initialize a class and fill in the value for a static field.
 785   // This is useful when the compile was dependent on the value of
 786   // static fields but it&#39;s impossible to properly rerun the static
 787   // initiailizer.
 788   void process_staticfield(TRAPS) {
 789     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 790 
 791     if (k == NULL || ReplaySuppressInitializers == 0 ||
 792         (ReplaySuppressInitializers == 2 &amp;&amp; k-&gt;class_loader() == NULL)) {
 793       return;
 794     }
 795 
 796     assert(k-&gt;is_initialized(), &quot;must be&quot;);
 797 
 798     const char* field_name = parse_escaped_string();
 799     const char* field_signature = parse_string();
 800     fieldDescriptor fd;
<span class="line-modified"> 801     Symbol* name = SymbolTable::lookup(field_name, (int)strlen(field_name), CHECK);</span>
<span class="line-modified"> 802     Symbol* sig = SymbolTable::lookup(field_signature, (int)strlen(field_signature), CHECK);</span>
 803     if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
 804         !fd.is_static() ||
 805         fd.has_initial_value()) {
 806       report_error(field_name);
 807       return;
 808     }
 809 
 810     oop java_mirror = k-&gt;java_mirror();
<span class="line-modified"> 811     if (field_signature[0] == &#39;[&#39;) {</span>
 812       int length = parse_int(&quot;array length&quot;);
 813       oop value = NULL;
 814 
<span class="line-modified"> 815       if (field_signature[1] == &#39;[&#39;) {</span>
 816         // multi dimensional array
 817         ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
 818         if (kelem == NULL) {
 819           return;
 820         }
 821         int rank = 0;
<span class="line-modified"> 822         while (field_signature[rank] == &#39;[&#39;) {</span>
 823           rank++;
 824         }
 825         jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
 826         dims[0] = length;
 827         for (int i = 1; i &lt; rank; i++) {
 828           dims[i] = 1; // These aren&#39;t relevant to the compiler
 829         }
 830         value = kelem-&gt;multi_allocate(rank, dims, CHECK);
 831       } else {
 832         if (strcmp(field_signature, &quot;[B&quot;) == 0) {
 833           value = oopFactory::new_byteArray(length, CHECK);
 834         } else if (strcmp(field_signature, &quot;[Z&quot;) == 0) {
 835           value = oopFactory::new_boolArray(length, CHECK);
 836         } else if (strcmp(field_signature, &quot;[C&quot;) == 0) {
 837           value = oopFactory::new_charArray(length, CHECK);
 838         } else if (strcmp(field_signature, &quot;[S&quot;) == 0) {
 839           value = oopFactory::new_shortArray(length, CHECK);
 840         } else if (strcmp(field_signature, &quot;[F&quot;) == 0) {
 841           value = oopFactory::new_floatArray(length, CHECK);
 842         } else if (strcmp(field_signature, &quot;[D&quot;) == 0) {
 843           value = oopFactory::new_doubleArray(length, CHECK);
 844         } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
 845           value = oopFactory::new_intArray(length, CHECK);
 846         } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
 847           value = oopFactory::new_longArray(length, CHECK);
<span class="line-modified"> 848         } else if (field_signature[0] == &#39;[&#39; &amp;&amp; field_signature[1] == &#39;L&#39;) {</span>

 849           Klass* kelem = resolve_klass(field_signature + 1, CHECK);
 850           value = oopFactory::new_objArray(kelem, length, CHECK);
 851         } else {
 852           report_error(&quot;unhandled array staticfield&quot;);
 853         }
 854       }
 855       java_mirror-&gt;obj_field_put(fd.offset(), value);
 856     } else {
 857       const char* string_value = parse_escaped_string();
 858       if (strcmp(field_signature, &quot;I&quot;) == 0) {
 859         int value = atoi(string_value);
 860         java_mirror-&gt;int_field_put(fd.offset(), value);
 861       } else if (strcmp(field_signature, &quot;B&quot;) == 0) {
 862         int value = atoi(string_value);
 863         java_mirror-&gt;byte_field_put(fd.offset(), value);
 864       } else if (strcmp(field_signature, &quot;C&quot;) == 0) {
 865         int value = atoi(string_value);
 866         java_mirror-&gt;char_field_put(fd.offset(), value);
 867       } else if (strcmp(field_signature, &quot;S&quot;) == 0) {
 868         int value = atoi(string_value);
 869         java_mirror-&gt;short_field_put(fd.offset(), value);
 870       } else if (strcmp(field_signature, &quot;Z&quot;) == 0) {
 871         int value = atoi(string_value);
 872         java_mirror-&gt;bool_field_put(fd.offset(), value);
 873       } else if (strcmp(field_signature, &quot;J&quot;) == 0) {
 874         jlong value;
 875         if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 876           fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 877           return;
 878         }
 879         java_mirror-&gt;long_field_put(fd.offset(), value);
 880       } else if (strcmp(field_signature, &quot;F&quot;) == 0) {
 881         float value = atof(string_value);
 882         java_mirror-&gt;float_field_put(fd.offset(), value);
 883       } else if (strcmp(field_signature, &quot;D&quot;) == 0) {
 884         double value = atof(string_value);
 885         java_mirror-&gt;double_field_put(fd.offset(), value);
 886       } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
 887         Handle value = java_lang_String::create_from_str(string_value, CHECK);
 888         java_mirror-&gt;obj_field_put(fd.offset(), value());
<span class="line-modified"> 889       } else if (field_signature[0] == &#39;L&#39;) {</span>
 890         Klass* k = resolve_klass(string_value, CHECK);
 891         oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
 892         java_mirror-&gt;obj_field_put(fd.offset(), value);
 893       } else {
 894         report_error(&quot;unhandled staticfield&quot;);
 895       }
 896     }
 897   }
 898 
 899 #if INCLUDE_JVMTI
 900   void process_JvmtiExport(TRAPS) {
 901     const char* field = parse_string();
 902     bool value = parse_int(&quot;JvmtiExport flag&quot;) != 0;
 903     if (strcmp(field, &quot;can_access_local_variables&quot;) == 0) {
 904       JvmtiExport::set_can_access_local_variables(value);
 905     } else if (strcmp(field, &quot;can_hotswap_or_post_breakpoint&quot;) == 0) {
 906       JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
 907     } else if (strcmp(field, &quot;can_post_on_exceptions&quot;) == 0) {
 908       JvmtiExport::set_can_post_on_exceptions(value);
 909     } else {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;ci/ciSymbol.hpp&quot;
  30 #include &quot;ci/ciKlass.hpp&quot;
  31 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">  32 #include &quot;classfile/symbolTable.hpp&quot;</span>
  33 #include &quot;compiler/compileBroker.hpp&quot;
  34 #include &quot;memory/allocation.inline.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/constantPool.hpp&quot;
  38 #include &quot;oops/method.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  44 #include &quot;utilities/utf8.hpp&quot;</span>
  45 
  46 #ifndef PRODUCT
  47 
  48 // ciReplay
  49 
  50 typedef struct _ciMethodDataRecord {
  51   const char* _klass_name;
  52   const char* _method_name;
  53   const char* _signature;
  54 
  55   int _state;
  56   int _current_mileage;
  57 
  58   intptr_t* _data;
  59   char*     _orig_data;
  60   Klass**   _classes;
  61   Method**  _methods;
  62   int*      _classes_offsets;
  63   int*      _methods_offsets;
  64   int       _data_length;
</pre>
<hr />
<pre>
 319   //   &#39;tag&#39; &lt;length&gt; # # ...
 320   // Where each # is an intptr_t item
 321   intptr_t* parse_intptr_data(const char* tag, int&amp; length) {
 322     if (!parse_tag_and_count(tag, length)) {
 323       return NULL;
 324     }
 325 
 326     intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
 327     for (int i = 0; i &lt; length; i++) {
 328       skip_ws();
 329       intptr_t val = parse_intptr_t(&quot;data&quot;);
 330       result[i] = val;
 331     }
 332     return result;
 333   }
 334 
 335   // Parse a possibly quoted version of a symbol into a symbolOop
 336   Symbol* parse_symbol(TRAPS) {
 337     const char* str = parse_escaped_string();
 338     if (str != NULL) {
<span class="line-modified"> 339       Symbol* sym = SymbolTable::new_symbol(str);</span>
 340       return sym;
 341     }
 342     return NULL;
 343   }
 344 
 345   // Parse a valid klass name and look it up
 346   Klass* parse_klass(TRAPS) {
 347     const char* str = parse_escaped_string();
<span class="line-modified"> 348     Symbol* klass_name = SymbolTable::new_symbol(str);</span>
 349     if (klass_name != NULL) {
 350       Klass* k = NULL;
 351       if (_iklass != NULL) {
 352         k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
 353       } else {
 354         k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 355       }
 356       if (HAS_PENDING_EXCEPTION) {
 357         oop throwable = PENDING_EXCEPTION;
 358         java_lang_Throwable::print(throwable, tty);
 359         tty-&gt;cr();
 360         report_error(str);
 361         if (ReplayIgnoreInitErrors) {
 362           CLEAR_PENDING_EXCEPTION;
 363           _error_message = NULL;
 364         }
 365         return NULL;
 366       }
 367       return k;
 368     }
 369     return NULL;
 370   }
 371 
 372   // Lookup a klass
 373   Klass* resolve_klass(const char* klass, TRAPS) {
<span class="line-modified"> 374     Symbol* klass_name = SymbolTable::new_symbol(klass);</span>
 375     return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 376   }
 377 
 378   // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
 379   Method* parse_method(TRAPS) {
 380     InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
 381     if (k == NULL) {
 382       report_error(&quot;Can&#39;t find holder klass&quot;);
 383       return NULL;
 384     }
 385     Symbol* method_name = parse_symbol(CHECK_NULL);
 386     Symbol* method_signature = parse_symbol(CHECK_NULL);
 387     Method* m = k-&gt;find_method(method_name, method_signature);
 388     if (m == NULL) {
 389       report_error(&quot;Can&#39;t find method&quot;);
 390     }
 391     return m;
 392   }
 393 
 394   int get_line(int c) {
</pre>
<hr />
<pre>
 515       }
 516       if (_ci_inline_records != NULL &amp;&amp; _ci_inline_records-&gt;length() &gt; 0) {
 517         // Found inlining record for the requested method.
 518         return _ci_inline_records;
 519       }
 520       line_no++;
 521     }
 522     return NULL;
 523   }
 524 
 525   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 526   void process_compile(TRAPS) {
 527     Method* method = parse_method(CHECK);
 528     if (had_error()) return;
 529     int entry_bci = parse_int(&quot;entry_bci&quot;);
 530     const char* comp_level_label = &quot;comp_level&quot;;
 531     int comp_level = parse_int(comp_level_label);
 532     // old version w/o comp_level
 533     if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
 534       // use highest available tier
<span class="line-modified"> 535       if (TieredCompilation) {</span>
<span class="line-added"> 536         comp_level = TieredStopAtLevel;</span>
<span class="line-added"> 537       } else {</span>
<span class="line-added"> 538         comp_level = CompLevel_highest_tier;</span>
<span class="line-added"> 539       }</span>
 540     }
 541     if (!is_valid_comp_level(comp_level)) {
 542       return;
 543     }
 544     if (_imethod != NULL) {
 545       // Replay Inlining
 546       if (entry_bci != _entry_bci || comp_level != _comp_level) {
 547         return;
 548       }
 549       const char* iklass_name  = _imethod-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 550       const char* imethod_name = _imethod-&gt;name()-&gt;as_utf8();
 551       const char* isignature   = _imethod-&gt;signature()-&gt;as_utf8();
 552       const char* klass_name   = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 553       const char* method_name  = method-&gt;name()-&gt;as_utf8();
 554       const char* signature    = method-&gt;signature()-&gt;as_utf8();
 555       if (strcmp(iklass_name,  klass_name)  != 0 ||
 556           strcmp(imethod_name, method_name) != 0 ||
 557           strcmp(isignature,   signature)   != 0) {
 558         return;
 559       }
</pre>
<hr />
<pre>
 580     }
 581     InstanceKlass* ik = method-&gt;method_holder();
 582     ik-&gt;initialize(THREAD);
 583     if (HAS_PENDING_EXCEPTION) {
 584       oop throwable = PENDING_EXCEPTION;
 585       java_lang_Throwable::print(throwable, tty);
 586       tty-&gt;cr();
 587       if (ReplayIgnoreInitErrors) {
 588         CLEAR_PENDING_EXCEPTION;
 589         ik-&gt;set_init_state(InstanceKlass::fully_initialized);
 590       } else {
 591         return;
 592       }
 593     }
 594     // Make sure the existence of a prior compile doesn&#39;t stop this one
 595     CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
 596     if (nm != NULL) {
 597       nm-&gt;make_not_entrant();
 598     }
 599     replay_state = this;
<span class="line-modified"> 600     CompileBroker::compile_method(methodHandle(THREAD, method), entry_bci, comp_level,</span>
 601                                   methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
 602     replay_state = NULL;
 603     reset();
 604   }
 605 
 606   // ciMethod &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;invocation_counter&gt; &lt;backedge_counter&gt; &lt;interpreter_invocation_count&gt; &lt;interpreter_throwout_count&gt; &lt;instructions_size&gt;
 607   //
 608   //
 609   void process_ciMethod(TRAPS) {
 610     Method* method = parse_method(CHECK);
 611     if (had_error()) return;
 612     ciMethodRecord* rec = new_ciMethod(method);
 613     rec-&gt;_invocation_counter = parse_int(&quot;invocation_counter&quot;);
 614     rec-&gt;_backedge_counter = parse_int(&quot;backedge_counter&quot;);
 615     rec-&gt;_interpreter_invocation_count = parse_int(&quot;interpreter_invocation_count&quot;);
 616     rec-&gt;_interpreter_throwout_count = parse_int(&quot;interpreter_throwout_count&quot;);
 617     rec-&gt;_instructions_size = parse_int(&quot;instructions_size&quot;);
 618   }
 619 
 620   // ciMethodData &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;state&gt; &lt;current mileage&gt; orig &lt;length&gt; # # ... data &lt;length&gt; # # ... oops &lt;length&gt; # ... methods &lt;length&gt;
 621   void process_ciMethodData(TRAPS) {
 622     Method* method = parse_method(CHECK);
 623     if (had_error()) return;
 624     /* just copied from Method, to build interpret data*/
 625 
 626     // To be properly initialized, some profiling in the MDO needs the
 627     // method to be rewritten (number of arguments at a call for
 628     // instance)
 629     method-&gt;method_holder()-&gt;link_class(CHECK);
 630     // methodOopDesc::build_interpreter_method_data(method, CHECK);
 631     {
 632       // Grab a lock here to prevent multiple
 633       // MethodData*s from being created.
<span class="line-modified"> 634       MutexLocker ml(THREAD, MethodData_lock);</span>
 635       if (method-&gt;method_data() == NULL) {
 636         ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
<span class="line-modified"> 637         MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);</span>
 638         method-&gt;set_method_data(method_data);
 639       }
 640     }
 641 
 642     // collect and record all the needed information for later
 643     ciMethodDataRecord* rec = new_ciMethodData(method);
 644     rec-&gt;_state = parse_int(&quot;state&quot;);
 645     rec-&gt;_current_mileage = parse_int(&quot;current_mileage&quot;);
 646 
 647     rec-&gt;_orig_data = parse_data(&quot;orig&quot;, rec-&gt;_orig_data_length);
 648     if (rec-&gt;_orig_data == NULL) {
 649       return;
 650     }
 651     rec-&gt;_data = parse_intptr_data(&quot;data&quot;, rec-&gt;_data_length);
 652     if (rec-&gt;_data == NULL) {
 653       return;
 654     }
 655     if (!parse_tag_and_count(&quot;oops&quot;, rec-&gt;_classes_length)) {
 656       return;
 657     }
</pre>
<hr />
<pre>
 787     }
 788   }
 789 
 790   // Initialize a class and fill in the value for a static field.
 791   // This is useful when the compile was dependent on the value of
 792   // static fields but it&#39;s impossible to properly rerun the static
 793   // initiailizer.
 794   void process_staticfield(TRAPS) {
 795     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 796 
 797     if (k == NULL || ReplaySuppressInitializers == 0 ||
 798         (ReplaySuppressInitializers == 2 &amp;&amp; k-&gt;class_loader() == NULL)) {
 799       return;
 800     }
 801 
 802     assert(k-&gt;is_initialized(), &quot;must be&quot;);
 803 
 804     const char* field_name = parse_escaped_string();
 805     const char* field_signature = parse_string();
 806     fieldDescriptor fd;
<span class="line-modified"> 807     Symbol* name = SymbolTable::new_symbol(field_name);</span>
<span class="line-modified"> 808     Symbol* sig = SymbolTable::new_symbol(field_signature);</span>
 809     if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
 810         !fd.is_static() ||
 811         fd.has_initial_value()) {
 812       report_error(field_name);
 813       return;
 814     }
 815 
 816     oop java_mirror = k-&gt;java_mirror();
<span class="line-modified"> 817     if (field_signature[0] == JVM_SIGNATURE_ARRAY) {</span>
 818       int length = parse_int(&quot;array length&quot;);
 819       oop value = NULL;
 820 
<span class="line-modified"> 821       if (field_signature[1] == JVM_SIGNATURE_ARRAY) {</span>
 822         // multi dimensional array
 823         ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);
 824         if (kelem == NULL) {
 825           return;
 826         }
 827         int rank = 0;
<span class="line-modified"> 828         while (field_signature[rank] == JVM_SIGNATURE_ARRAY) {</span>
 829           rank++;
 830         }
 831         jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
 832         dims[0] = length;
 833         for (int i = 1; i &lt; rank; i++) {
 834           dims[i] = 1; // These aren&#39;t relevant to the compiler
 835         }
 836         value = kelem-&gt;multi_allocate(rank, dims, CHECK);
 837       } else {
 838         if (strcmp(field_signature, &quot;[B&quot;) == 0) {
 839           value = oopFactory::new_byteArray(length, CHECK);
 840         } else if (strcmp(field_signature, &quot;[Z&quot;) == 0) {
 841           value = oopFactory::new_boolArray(length, CHECK);
 842         } else if (strcmp(field_signature, &quot;[C&quot;) == 0) {
 843           value = oopFactory::new_charArray(length, CHECK);
 844         } else if (strcmp(field_signature, &quot;[S&quot;) == 0) {
 845           value = oopFactory::new_shortArray(length, CHECK);
 846         } else if (strcmp(field_signature, &quot;[F&quot;) == 0) {
 847           value = oopFactory::new_floatArray(length, CHECK);
 848         } else if (strcmp(field_signature, &quot;[D&quot;) == 0) {
 849           value = oopFactory::new_doubleArray(length, CHECK);
 850         } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
 851           value = oopFactory::new_intArray(length, CHECK);
 852         } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
 853           value = oopFactory::new_longArray(length, CHECK);
<span class="line-modified"> 854         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added"> 855                    field_signature[1] == JVM_SIGNATURE_CLASS) {</span>
 856           Klass* kelem = resolve_klass(field_signature + 1, CHECK);
 857           value = oopFactory::new_objArray(kelem, length, CHECK);
 858         } else {
 859           report_error(&quot;unhandled array staticfield&quot;);
 860         }
 861       }
 862       java_mirror-&gt;obj_field_put(fd.offset(), value);
 863     } else {
 864       const char* string_value = parse_escaped_string();
 865       if (strcmp(field_signature, &quot;I&quot;) == 0) {
 866         int value = atoi(string_value);
 867         java_mirror-&gt;int_field_put(fd.offset(), value);
 868       } else if (strcmp(field_signature, &quot;B&quot;) == 0) {
 869         int value = atoi(string_value);
 870         java_mirror-&gt;byte_field_put(fd.offset(), value);
 871       } else if (strcmp(field_signature, &quot;C&quot;) == 0) {
 872         int value = atoi(string_value);
 873         java_mirror-&gt;char_field_put(fd.offset(), value);
 874       } else if (strcmp(field_signature, &quot;S&quot;) == 0) {
 875         int value = atoi(string_value);
 876         java_mirror-&gt;short_field_put(fd.offset(), value);
 877       } else if (strcmp(field_signature, &quot;Z&quot;) == 0) {
 878         int value = atoi(string_value);
 879         java_mirror-&gt;bool_field_put(fd.offset(), value);
 880       } else if (strcmp(field_signature, &quot;J&quot;) == 0) {
 881         jlong value;
 882         if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 883           fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 884           return;
 885         }
 886         java_mirror-&gt;long_field_put(fd.offset(), value);
 887       } else if (strcmp(field_signature, &quot;F&quot;) == 0) {
 888         float value = atof(string_value);
 889         java_mirror-&gt;float_field_put(fd.offset(), value);
 890       } else if (strcmp(field_signature, &quot;D&quot;) == 0) {
 891         double value = atof(string_value);
 892         java_mirror-&gt;double_field_put(fd.offset(), value);
 893       } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
 894         Handle value = java_lang_String::create_from_str(string_value, CHECK);
 895         java_mirror-&gt;obj_field_put(fd.offset(), value());
<span class="line-modified"> 896       } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {</span>
 897         Klass* k = resolve_klass(string_value, CHECK);
 898         oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
 899         java_mirror-&gt;obj_field_put(fd.offset(), value);
 900       } else {
 901         report_error(&quot;unhandled staticfield&quot;);
 902       }
 903     }
 904   }
 905 
 906 #if INCLUDE_JVMTI
 907   void process_JvmtiExport(TRAPS) {
 908     const char* field = parse_string();
 909     bool value = parse_int(&quot;JvmtiExport flag&quot;) != 0;
 910     if (strcmp(field, &quot;can_access_local_variables&quot;) == 0) {
 911       JvmtiExport::set_can_access_local_variables(value);
 912     } else if (strcmp(field, &quot;can_hotswap_or_post_breakpoint&quot;) == 0) {
 913       JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
 914     } else if (strcmp(field, &quot;can_post_on_exceptions&quot;) == 0) {
 915       JvmtiExport::set_can_post_on_exceptions(value);
 916     } else {
</pre>
</td>
</tr>
</table>
<center><a href="ciObjectFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciSignature.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/bcEscapeAnalyzer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciArray.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/bcEscapeAnalyzer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 134   for (int i = 0; i &lt; _arg_size; i++) {
 135     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 136       return true;
 137   }
 138   return false;
 139 }
 140 
 141 // return true if all argument elements of vars are returned
 142 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 143   for (int i = 0; i &lt; _arg_size; i++) {
 144     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 145       return false;
 146     }
 147   }
 148   return true;
 149 }
 150 
 151 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 152   for (int i = 0; i &lt; _arg_size; i++) {
 153     if (vars.contains(i)) {
<span class="line-modified"> 154       bm &gt;&gt;= i;</span>
 155     }
 156   }
 157 }
 158 
 159 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 160   clear_bits(vars, _arg_local);
 161   if (vars.contains_allocated()) {
 162     _allocated_escapes = true;
 163   }
 164 }
 165 
 166 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 167   clear_bits(vars, _arg_local);
 168   clear_bits(vars, _arg_stack);
 169   if (vars.contains_allocated())
 170     _allocated_escapes = true;
 171 
 172   if (merge &amp;&amp; !vars.is_empty()) {
 173     // Merge new state into already processed block.
 174     // New state is not taken into account and
</pre>
<hr />
<pre>
 842         state.spop();
 843         fall_through = false;
 844         break;
 845       case Bytecodes::_lreturn:
 846       case Bytecodes::_dreturn:
 847         state.lpop();
 848         fall_through = false;
 849         break;
 850       case Bytecodes::_areturn:
 851         set_returned(state.apop());
 852         fall_through = false;
 853         break;
 854       case Bytecodes::_getstatic:
 855       case Bytecodes::_getfield:
 856         { bool ignored_will_link;
 857           ciField* field = s.get_field(ignored_will_link);
 858           BasicType field_type = field-&gt;type()-&gt;basic_type();
 859           if (s.cur_bc() != Bytecodes::_getstatic) {
 860             set_method_escape(state.apop());
 861           }
<span class="line-modified"> 862           if (field_type == T_OBJECT || field_type == T_ARRAY) {</span>
 863             state.apush(unknown_obj);
 864           } else if (type2size[field_type] == 1) {
 865             state.spush();
 866           } else {
 867             state.lpush();
 868           }
 869         }
 870         break;
 871       case Bytecodes::_putstatic:
 872       case Bytecodes::_putfield:
 873         { bool will_link;
 874           ciField* field = s.get_field(will_link);
 875           BasicType field_type = field-&gt;type()-&gt;basic_type();
<span class="line-modified"> 876           if (field_type == T_OBJECT || field_type == T_ARRAY) {</span>
 877             set_global_escape(state.apop());
 878           } else if (type2size[field_type] == 1) {
 879             state.spop();
 880           } else {
 881             state.lpop();
 882           }
 883           if (s.cur_bc() != Bytecodes::_putstatic) {
 884             ArgumentMap p = state.apop();
 885             set_method_escape(p);
 886             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 887           }
 888         }
 889         break;
 890       case Bytecodes::_invokevirtual:
 891       case Bytecodes::_invokespecial:
 892       case Bytecodes::_invokestatic:
 893       case Bytecodes::_invokedynamic:
 894       case Bytecodes::_invokeinterface:
 895         { bool ignored_will_link;
 896           ciSignature* declared_signature = NULL;
</pre>
<hr />
<pre>
1263     _return_allocated = true;
1264   }
1265   _allocated_escapes = false;
1266   _unknown_modified = false;
1267 }
1268 
1269 void BCEscapeAnalyzer::clear_escape_info() {
1270   ciSignature* sig = method()-&gt;signature();
1271   int arg_count = sig-&gt;count();
1272   ArgumentMap var;
1273   if (!method()-&gt;is_static()) {
1274     arg_count++;  // allow for &quot;this&quot;
1275   }
1276   for (int i = 0; i &lt; arg_count; i++) {
1277     set_arg_modified(i, OFFSET_ANY, 4);
1278     var.clear();
1279     var.set(i);
1280     set_modified(var, OFFSET_ANY, 4);
1281     set_global_escape(var);
1282   }
<span class="line-modified">1283   _arg_local.Clear();</span>
<span class="line-modified">1284   _arg_stack.Clear();</span>
<span class="line-modified">1285   _arg_returned.Clear();</span>
1286   _return_local = false;
1287   _return_allocated = false;
1288   _allocated_escapes = true;
1289   _unknown_modified = true;
1290 }
1291 
1292 
1293 void BCEscapeAnalyzer::compute_escape_info() {
1294   int i;
1295   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1296 
1297   vmIntrinsics::ID iid = known_intrinsic();
1298 
1299   // check if method can be analyzed
1300   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1301       || _level &gt; MaxBCEAEstimateLevel
1302       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1303     if (BCEATraceLevel &gt;= 1) {
1304       tty-&gt;print(&quot;Skipping method because: &quot;);
1305       if (method()-&gt;is_abstract())
</pre>
<hr />
<pre>
1317       else
1318         ShouldNotReachHere();
1319     }
1320     clear_escape_info();
1321 
1322     return;
1323   }
1324 
1325   if (BCEATraceLevel &gt;= 1) {
1326     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1327     if (iid != vmIntrinsics::_none)
1328       tty-&gt;print(&quot; intrinsic&quot;);
1329     method()-&gt;print_short_name();
1330     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1331   }
1332 
1333   initialize();
1334 
1335   // Do not scan method if it has no object parameters and
1336   // does not returns an object (_return_allocated is set in initialize()).
<span class="line-modified">1337   if (_arg_local.Size() == 0 &amp;&amp; !_return_allocated) {</span>
1338     // Clear all info since method&#39;s bytecode was not analysed and
1339     // set pessimistic escape information.
1340     clear_escape_info();
1341     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1342     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1343     methodData()-&gt;set_eflag(MethodData::estimated);
1344     return;
1345   }
1346 
1347   if (iid != vmIntrinsics::_none)
1348     compute_escape_for_intrinsic(iid);
1349   else {
1350     do_analysis();
1351   }
1352 
1353   // don&#39;t store interprocedural escape information if it introduces
1354   // dependencies or if method data is empty
1355   //
1356   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1357     for (i = 0; i &lt; _arg_size; i++) {
</pre>
<hr />
<pre>
1440 #endif
1441 
1442 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1443     : _arena(CURRENT_ENV-&gt;arena())
1444     , _conservative(method == NULL || !EstimateArgEscape)
1445     , _method(method)
1446     , _methodData(method ? method-&gt;method_data() : NULL)
1447     , _arg_size(method ? method-&gt;arg_size() : 0)
1448     , _arg_local(_arena)
1449     , _arg_stack(_arena)
1450     , _arg_returned(_arena)
1451     , _dirty(_arena)
1452     , _return_local(false)
1453     , _return_allocated(false)
1454     , _allocated_escapes(false)
1455     , _unknown_modified(false)
1456     , _dependencies(_arena, 4, 0, NULL)
1457     , _parent(parent)
1458     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1459   if (!_conservative) {
<span class="line-modified">1460     _arg_local.Clear();</span>
<span class="line-modified">1461     _arg_stack.Clear();</span>
<span class="line-modified">1462     _arg_returned.Clear();</span>
<span class="line-modified">1463     _dirty.Clear();</span>
1464     Arena* arena = CURRENT_ENV-&gt;arena();
1465     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1466     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1467 
1468     if (methodData() == NULL)
1469       return;
1470     if (methodData()-&gt;has_escape_info()) {
1471       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1472                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1473                                   method-&gt;name()-&gt;as_utf8()));
1474       read_escape_info();
1475     } else {
1476       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1477                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1478                                   method-&gt;name()-&gt;as_utf8()));
1479 
1480       compute_escape_info();
1481       methodData()-&gt;update_escape_info();
1482     }
1483 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 134   for (int i = 0; i &lt; _arg_size; i++) {
 135     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 136       return true;
 137   }
 138   return false;
 139 }
 140 
 141 // return true if all argument elements of vars are returned
 142 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 143   for (int i = 0; i &lt; _arg_size; i++) {
 144     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 145       return false;
 146     }
 147   }
 148   return true;
 149 }
 150 
 151 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 152   for (int i = 0; i &lt; _arg_size; i++) {
 153     if (vars.contains(i)) {
<span class="line-modified"> 154       bm.remove(i);</span>
 155     }
 156   }
 157 }
 158 
 159 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 160   clear_bits(vars, _arg_local);
 161   if (vars.contains_allocated()) {
 162     _allocated_escapes = true;
 163   }
 164 }
 165 
 166 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 167   clear_bits(vars, _arg_local);
 168   clear_bits(vars, _arg_stack);
 169   if (vars.contains_allocated())
 170     _allocated_escapes = true;
 171 
 172   if (merge &amp;&amp; !vars.is_empty()) {
 173     // Merge new state into already processed block.
 174     // New state is not taken into account and
</pre>
<hr />
<pre>
 842         state.spop();
 843         fall_through = false;
 844         break;
 845       case Bytecodes::_lreturn:
 846       case Bytecodes::_dreturn:
 847         state.lpop();
 848         fall_through = false;
 849         break;
 850       case Bytecodes::_areturn:
 851         set_returned(state.apop());
 852         fall_through = false;
 853         break;
 854       case Bytecodes::_getstatic:
 855       case Bytecodes::_getfield:
 856         { bool ignored_will_link;
 857           ciField* field = s.get_field(ignored_will_link);
 858           BasicType field_type = field-&gt;type()-&gt;basic_type();
 859           if (s.cur_bc() != Bytecodes::_getstatic) {
 860             set_method_escape(state.apop());
 861           }
<span class="line-modified"> 862           if (is_reference_type(field_type)) {</span>
 863             state.apush(unknown_obj);
 864           } else if (type2size[field_type] == 1) {
 865             state.spush();
 866           } else {
 867             state.lpush();
 868           }
 869         }
 870         break;
 871       case Bytecodes::_putstatic:
 872       case Bytecodes::_putfield:
 873         { bool will_link;
 874           ciField* field = s.get_field(will_link);
 875           BasicType field_type = field-&gt;type()-&gt;basic_type();
<span class="line-modified"> 876           if (is_reference_type(field_type)) {</span>
 877             set_global_escape(state.apop());
 878           } else if (type2size[field_type] == 1) {
 879             state.spop();
 880           } else {
 881             state.lpop();
 882           }
 883           if (s.cur_bc() != Bytecodes::_putstatic) {
 884             ArgumentMap p = state.apop();
 885             set_method_escape(p);
 886             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 887           }
 888         }
 889         break;
 890       case Bytecodes::_invokevirtual:
 891       case Bytecodes::_invokespecial:
 892       case Bytecodes::_invokestatic:
 893       case Bytecodes::_invokedynamic:
 894       case Bytecodes::_invokeinterface:
 895         { bool ignored_will_link;
 896           ciSignature* declared_signature = NULL;
</pre>
<hr />
<pre>
1263     _return_allocated = true;
1264   }
1265   _allocated_escapes = false;
1266   _unknown_modified = false;
1267 }
1268 
1269 void BCEscapeAnalyzer::clear_escape_info() {
1270   ciSignature* sig = method()-&gt;signature();
1271   int arg_count = sig-&gt;count();
1272   ArgumentMap var;
1273   if (!method()-&gt;is_static()) {
1274     arg_count++;  // allow for &quot;this&quot;
1275   }
1276   for (int i = 0; i &lt; arg_count; i++) {
1277     set_arg_modified(i, OFFSET_ANY, 4);
1278     var.clear();
1279     var.set(i);
1280     set_modified(var, OFFSET_ANY, 4);
1281     set_global_escape(var);
1282   }
<span class="line-modified">1283   _arg_local.clear();</span>
<span class="line-modified">1284   _arg_stack.clear();</span>
<span class="line-modified">1285   _arg_returned.clear();</span>
1286   _return_local = false;
1287   _return_allocated = false;
1288   _allocated_escapes = true;
1289   _unknown_modified = true;
1290 }
1291 
1292 
1293 void BCEscapeAnalyzer::compute_escape_info() {
1294   int i;
1295   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1296 
1297   vmIntrinsics::ID iid = known_intrinsic();
1298 
1299   // check if method can be analyzed
1300   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1301       || _level &gt; MaxBCEAEstimateLevel
1302       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1303     if (BCEATraceLevel &gt;= 1) {
1304       tty-&gt;print(&quot;Skipping method because: &quot;);
1305       if (method()-&gt;is_abstract())
</pre>
<hr />
<pre>
1317       else
1318         ShouldNotReachHere();
1319     }
1320     clear_escape_info();
1321 
1322     return;
1323   }
1324 
1325   if (BCEATraceLevel &gt;= 1) {
1326     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1327     if (iid != vmIntrinsics::_none)
1328       tty-&gt;print(&quot; intrinsic&quot;);
1329     method()-&gt;print_short_name();
1330     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1331   }
1332 
1333   initialize();
1334 
1335   // Do not scan method if it has no object parameters and
1336   // does not returns an object (_return_allocated is set in initialize()).
<span class="line-modified">1337   if (_arg_local.is_empty() &amp;&amp; !_return_allocated) {</span>
1338     // Clear all info since method&#39;s bytecode was not analysed and
1339     // set pessimistic escape information.
1340     clear_escape_info();
1341     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1342     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1343     methodData()-&gt;set_eflag(MethodData::estimated);
1344     return;
1345   }
1346 
1347   if (iid != vmIntrinsics::_none)
1348     compute_escape_for_intrinsic(iid);
1349   else {
1350     do_analysis();
1351   }
1352 
1353   // don&#39;t store interprocedural escape information if it introduces
1354   // dependencies or if method data is empty
1355   //
1356   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1357     for (i = 0; i &lt; _arg_size; i++) {
</pre>
<hr />
<pre>
1440 #endif
1441 
1442 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1443     : _arena(CURRENT_ENV-&gt;arena())
1444     , _conservative(method == NULL || !EstimateArgEscape)
1445     , _method(method)
1446     , _methodData(method ? method-&gt;method_data() : NULL)
1447     , _arg_size(method ? method-&gt;arg_size() : 0)
1448     , _arg_local(_arena)
1449     , _arg_stack(_arena)
1450     , _arg_returned(_arena)
1451     , _dirty(_arena)
1452     , _return_local(false)
1453     , _return_allocated(false)
1454     , _allocated_escapes(false)
1455     , _unknown_modified(false)
1456     , _dependencies(_arena, 4, 0, NULL)
1457     , _parent(parent)
1458     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1459   if (!_conservative) {
<span class="line-modified">1460     _arg_local.clear();</span>
<span class="line-modified">1461     _arg_stack.clear();</span>
<span class="line-modified">1462     _arg_returned.clear();</span>
<span class="line-modified">1463     _dirty.clear();</span>
1464     Arena* arena = CURRENT_ENV-&gt;arena();
1465     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1466     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1467 
1468     if (methodData() == NULL)
1469       return;
1470     if (methodData()-&gt;has_escape_info()) {
1471       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1472                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1473                                   method-&gt;name()-&gt;as_utf8()));
1474       read_escape_info();
1475     } else {
1476       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1477                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1478                                   method-&gt;name()-&gt;as_utf8()));
1479 
1480       compute_escape_info();
1481       methodData()-&gt;update_escape_info();
1482     }
1483 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciArray.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/ci/ciObjectFactory.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjArrayKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciObjectFactory.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciObjectFactory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,12 ***</span>
  #include &quot;ci/ciUtilities.inline.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/fieldType.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // ciObjectFactory
  //
<span class="line-new-header">--- 42,12 ---</span>
  #include &quot;ci/ciUtilities.inline.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // ciObjectFactory
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
  
    _ci_metadata = new (_arena) GrowableArray&lt;ciMetadata*&gt;(_arena, 64, 0, NULL);
  
    for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
      BasicType t = (BasicType)i;
<span class="line-modified">!     if (type2name(t) != NULL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY &amp;&amp; t != T_NARROWOOP &amp;&amp; t != T_NARROWKLASS) {</span>
        ciType::_basic_types[t] = new (_arena) ciType(t);
        init_ident_of(ciType::_basic_types[t]);
      }
    }
  
<span class="line-new-header">--- 146,12 ---</span>
  
    _ci_metadata = new (_arena) GrowableArray&lt;ciMetadata*&gt;(_arena, 64, 0, NULL);
  
    for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
      BasicType t = (BasicType)i;
<span class="line-modified">!     if (type2name(t) != NULL &amp;&amp; !is_reference_type(t) &amp;&amp;</span>
<span class="line-added">+         t != T_NARROWOOP &amp;&amp; t != T_NARROWKLASS) {</span>
        ciType::_basic_types[t] = new (_arena) ciType(t);
        init_ident_of(ciType::_basic_types[t]);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,24 ***</span>
  // already been created, it is returned.  Otherwise, a new ciObject
  // is created.
  ciObject* ciObjectFactory::get(oop key) {
    ASSERT_IN_VM;
  
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);</span>
  
    NonPermObject* &amp;bucket = find_non_perm(key);
    if (bucket != NULL) {
      return bucket-&gt;object();
    }
  
    // The ciObject does not yet exist.  Create it and insert it
    // into the cache.
    Handle keyHandle(Thread::current(), key);
    ciObject* new_object = create_new_object(keyHandle());
<span class="line-modified">!   assert(oopDesc::equals(keyHandle(), new_object-&gt;get_oop()), &quot;must be properly recorded&quot;);</span>
    init_ident_of(new_object);
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved(new_object-&gt;get_oop()), &quot;must be&quot;);</span>
  
    // Not a perm-space object.
    insert_non_perm(bucket, keyHandle(), new_object);
    return new_object;
  }
<span class="line-new-header">--- 237,24 ---</span>
  // already been created, it is returned.  Otherwise, a new ciObject
  // is created.
  ciObject* ciObjectFactory::get(oop key) {
    ASSERT_IN_VM;
  
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in(key), &quot;must be&quot;);</span>
  
    NonPermObject* &amp;bucket = find_non_perm(key);
    if (bucket != NULL) {
      return bucket-&gt;object();
    }
  
    // The ciObject does not yet exist.  Create it and insert it
    // into the cache.
    Handle keyHandle(Thread::current(), key);
    ciObject* new_object = create_new_object(keyHandle());
<span class="line-modified">!   assert(keyHandle() == new_object-&gt;get_oop(), &quot;must be properly recorded&quot;);</span>
    init_ident_of(new_object);
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in(new_object-&gt;get_oop()), &quot;must be&quot;);</span>
  
    // Not a perm-space object.
    insert_non_perm(bucket, keyHandle(), new_object);
    return new_object;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,10 ***</span>
<span class="line-new-header">--- 415,11 ---</span>
  // unloaded method.  This may need to change.
  ciMethod* ciObjectFactory::get_unloaded_method(ciInstanceKlass* holder,
                                                 ciSymbol*        name,
                                                 ciSymbol*        signature,
                                                 ciInstanceKlass* accessor) {
<span class="line-added">+   assert(accessor != NULL, &quot;need origin of access&quot;);</span>
    ciSignature* that = NULL;
    for (int i = 0; i &lt; _unloaded_methods-&gt;length(); i++) {
      ciMethod* entry = _unloaded_methods-&gt;at(i);
      if (entry-&gt;holder()-&gt;equals(holder) &amp;&amp;
          entry-&gt;name()-&gt;equals(name) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,12 ***</span>
      domain = accessing_klass-&gt;protection_domain();
    }
    for (int i=0; i&lt;_unloaded_klasses-&gt;length(); i++) {
      ciKlass* entry = _unloaded_klasses-&gt;at(i);
      if (entry-&gt;name()-&gt;equals(name) &amp;&amp;
<span class="line-modified">!         oopDesc::equals(entry-&gt;loader(), loader) &amp;&amp;</span>
<span class="line-modified">!         oopDesc::equals(entry-&gt;protection_domain(), domain)) {</span>
        // We&#39;ve found a match.
        return entry;
      }
    }
  
<span class="line-new-header">--- 468,12 ---</span>
      domain = accessing_klass-&gt;protection_domain();
    }
    for (int i=0; i&lt;_unloaded_klasses-&gt;length(); i++) {
      ciKlass* entry = _unloaded_klasses-&gt;at(i);
      if (entry-&gt;name()-&gt;equals(name) &amp;&amp;
<span class="line-modified">!         entry-&gt;loader() == loader &amp;&amp;</span>
<span class="line-modified">!         entry-&gt;protection_domain() == domain) {</span>
        // We&#39;ve found a match.
        return entry;
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,26 ***</span>
    // the cache.
    ciKlass* new_klass = NULL;
  
    // Two cases: this is an unloaded ObjArrayKlass or an
    // unloaded InstanceKlass.  Deal with both.
<span class="line-modified">!   if (name-&gt;char_at(0) == &#39;[&#39;) {</span>
      // Decompose the name.&#39;
<span class="line-modified">!     FieldArrayInfo fd;</span>
<span class="line-modified">!     BasicType element_type = FieldType::get_array_info(name-&gt;get_symbol(),</span>
<span class="line-modified">!                                                        fd, THREAD);</span>
<span class="line-removed">-     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">-       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">-       CURRENT_THREAD_ENV-&gt;record_out_of_memory_failure();</span>
<span class="line-removed">-       return ciEnv::_unloaded_ciobjarrayklass;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     int dimension = fd.dimension();</span>
      assert(element_type != T_ARRAY, &quot;unsuccessful decomposition&quot;);
      ciKlass* element_klass = NULL;
      if (element_type == T_OBJECT) {
        ciEnv *env = CURRENT_THREAD_ENV;
<span class="line-modified">!       ciSymbol* ci_name = env-&gt;get_symbol(fd.object_key());</span>
        element_klass =
          env-&gt;get_klass_by_name(accessing_klass, ci_name, false)-&gt;as_instance_klass();
      } else {
        assert(dimension &gt; 1, &quot;one dimensional type arrays are always loaded.&quot;);
  
<span class="line-new-header">--- 484,20 ---</span>
    // the cache.
    ciKlass* new_klass = NULL;
  
    // Two cases: this is an unloaded ObjArrayKlass or an
    // unloaded InstanceKlass.  Deal with both.
<span class="line-modified">!   if (name-&gt;char_at(0) == JVM_SIGNATURE_ARRAY) {</span>
      // Decompose the name.&#39;
<span class="line-modified">!     SignatureStream ss(name-&gt;get_symbol(), false);</span>
<span class="line-modified">!     int dimension = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-modified">!     BasicType element_type = ss.type();</span>
      assert(element_type != T_ARRAY, &quot;unsuccessful decomposition&quot;);
      ciKlass* element_klass = NULL;
      if (element_type == T_OBJECT) {
        ciEnv *env = CURRENT_THREAD_ENV;
<span class="line-modified">!       ciSymbol* ci_name = env-&gt;get_symbol(ss.as_symbol());</span>
        element_klass =
          env-&gt;get_klass_by_name(accessing_klass, ci_name, false)-&gt;as_instance_klass();
      } else {
        assert(dimension &gt; 1, &quot;one dimensional type arrays are always loaded.&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,11 ***</span>
  //
  // Use a small hash table, hashed on the klass of the key.
  // If there is no entry in the cache corresponding to this oop, return
  // the null tail of the bucket into which the oop should be inserted.
  ciObjectFactory::NonPermObject* &amp;ciObjectFactory::find_non_perm(oop key) {
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved(key), &quot;must be&quot;);</span>
    ciMetadata* klass = get_metadata(key-&gt;klass());
    NonPermObject* *bp = &amp;_non_perm_bucket[(unsigned) klass-&gt;hash() % NON_PERM_BUCKETS];
    for (NonPermObject* p; (p = (*bp)) != NULL; bp = &amp;p-&gt;next()) {
      if (is_equal(p, key))  break;
    }
<span class="line-new-header">--- 637,11 ---</span>
  //
  // Use a small hash table, hashed on the klass of the key.
  // If there is no entry in the cache corresponding to this oop, return
  // the null tail of the bucket into which the oop should be inserted.
  ciObjectFactory::NonPermObject* &amp;ciObjectFactory::find_non_perm(oop key) {
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in(key), &quot;must be&quot;);</span>
    ciMetadata* klass = get_metadata(key-&gt;klass());
    NonPermObject* *bp = &amp;_non_perm_bucket[(unsigned) klass-&gt;hash() % NON_PERM_BUCKETS];
    for (NonPermObject* p; (p = (*bp)) != NULL; bp = &amp;p-&gt;next()) {
      if (is_equal(p, key))  break;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 669,11 ***</span>
  // ------------------------------------------------------------------
  // ciObjectFactory::insert_non_perm
  //
  // Insert a ciObject into the non-perm table.
  void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &amp;where, oop key, ciObject* obj) {
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved_or_null(key), &quot;must be&quot;);</span>
    assert(&amp;where != &amp;emptyBucket, &quot;must not try to fill empty bucket&quot;);
    NonPermObject* p = new (arena()) NonPermObject(where, key, obj);
    assert(where == p &amp;&amp; is_equal(p, key) &amp;&amp; p-&gt;object() == obj, &quot;entry must match&quot;);
    assert(find_non_perm(key) == p, &quot;must find the same spot&quot;);
    ++_non_perm_count;
<span class="line-new-header">--- 665,11 ---</span>
  // ------------------------------------------------------------------
  // ciObjectFactory::insert_non_perm
  //
  // Insert a ciObject into the non-perm table.
  void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &amp;where, oop key, ciObject* obj) {
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_or_null(key), &quot;must be&quot;);</span>
    assert(&amp;where != &amp;emptyBucket, &quot;must not try to fill empty bucket&quot;);
    NonPermObject* p = new (arena()) NonPermObject(where, key, obj);
    assert(where == p &amp;&amp; is_equal(p, key) &amp;&amp; p-&gt;object() == obj, &quot;entry must match&quot;);
    assert(find_non_perm(key) == p, &quot;must find the same spot&quot;);
    ++_non_perm_count;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,15 ***</span>
    return _shared_ci_symbols[index];
  }
  
  // ------------------------------------------------------------------
  // ciObjectFactory::metadata_do
<span class="line-modified">! void ciObjectFactory::metadata_do(void f(Metadata*)) {</span>
    if (_ci_metadata == NULL) return;
    for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
      Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
<span class="line-modified">!     f(o);</span>
    }
  }
  
  // ------------------------------------------------------------------
  // ciObjectFactory::print_contents_impl
<span class="line-new-header">--- 683,15 ---</span>
    return _shared_ci_symbols[index];
  }
  
  // ------------------------------------------------------------------
  // ciObjectFactory::metadata_do
<span class="line-modified">! void ciObjectFactory::metadata_do(MetadataClosure* f) {</span>
    if (_ci_metadata == NULL) return;
    for (int j = 0; j&lt; _ci_metadata-&gt;length(); j++) {
      Metadata* o = _ci_metadata-&gt;at(j)-&gt;constant_encoding();
<span class="line-modified">!     f-&gt;do_metadata(o);</span>
    }
  }
  
  // ------------------------------------------------------------------
  // ciObjectFactory::print_contents_impl
</pre>
<center><a href="ciObjArrayKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciObjectFactory.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
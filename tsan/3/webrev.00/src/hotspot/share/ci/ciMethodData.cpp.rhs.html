<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciMethodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciMetadata.hpp&quot;
 27 #include &quot;ci/ciMethodData.hpp&quot;
 28 #include &quot;ci/ciReplay.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/deoptimization.hpp&quot;
 33 #include &quot;utilities/copy.hpp&quot;
 34 
 35 // ciMethodData
 36 
 37 // ------------------------------------------------------------------
 38 // ciMethodData::ciMethodData
 39 //
 40 ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md) {
 41   assert(md != NULL, &quot;no null method data&quot;);
 42   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 43   _data = NULL;
 44   _data_size = 0;
 45   _extra_data_size = 0;
 46   _current_mileage = 0;
 47   _invocation_counter = 0;
 48   _backedge_counter = 0;
 49   _state = empty_state;
 50   _saw_free_extra_data = false;
 51   // Set an initial hint. Don&#39;t use set_hint_di() because
 52   // first_di() may be out of bounds if data_size is 0.
 53   _hint_di = first_di();
 54   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 55   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 56   _parameters = NULL;
 57 }
 58 
 59 // ------------------------------------------------------------------
 60 // ciMethodData::ciMethodData
 61 //
 62 // No MethodData*.
 63 ciMethodData::ciMethodData() : ciMetadata(NULL) {
 64   Copy::zero_to_words((HeapWord*) &amp;_orig, sizeof(_orig) / sizeof(HeapWord));
 65   _data = NULL;
 66   _data_size = 0;
 67   _extra_data_size = 0;
 68   _current_mileage = 0;
 69   _invocation_counter = 0;
 70   _backedge_counter = 0;
 71   _state = empty_state;
 72   _saw_free_extra_data = false;
 73   // Set an initial hint. Don&#39;t use set_hint_di() because
 74   // first_di() may be out of bounds if data_size is 0.
 75   _hint_di = first_di();
 76   // Initialize the escape information (to &quot;don&#39;t know.&quot;);
 77   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
 78   _parameters = NULL;
 79 }
 80 
 81 // Check for entries that reference an unloaded method
 82 class PrepareExtraDataClosure : public CleanExtraDataClosure {
 83   MethodData*            _mdo;
<a name="1" id="anc1"></a><span class="line-modified"> 84   SafepointStateTracker  _safepoint_tracker;</span>
 85   GrowableArray&lt;Method*&gt; _uncached_methods;
 86 
 87 public:
 88   PrepareExtraDataClosure(MethodData* mdo)
 89     : _mdo(mdo),
<a name="2" id="anc2"></a><span class="line-modified"> 90       _safepoint_tracker(SafepointSynchronize::safepoint_state_tracker()),</span>
 91       _uncached_methods()
 92   { }
 93 
 94   bool is_live(Method* m) {
 95     if (!m-&gt;method_holder()-&gt;is_loader_alive()) {
 96       return false;
 97     }
 98     if (CURRENT_ENV-&gt;cached_metadata(m) == NULL) {
 99       // Uncached entries need to be pre-populated.
100       _uncached_methods.append(m);
101     }
102     return true;
103   }
104 
105   bool has_safepointed() {
<a name="3" id="anc3"></a><span class="line-modified">106     return _safepoint_tracker.safepoint_state_changed();</span>
107   }
108 
109   bool finish() {
110     if (_uncached_methods.length() == 0) {
111       // Preparation finished iff all Methods* were already cached.
112       return true;
113     }
114     // Holding locks through safepoints is bad practice.
115     MutexUnlocker mu(_mdo-&gt;extra_data_lock());
116     for (int i = 0; i &lt; _uncached_methods.length(); ++i) {
117       if (has_safepointed()) {
118         // The metadata in the growable array might contain stale
119         // entries after a safepoint.
120         return false;
121       }
122       Method* method = _uncached_methods.at(i);
123       // Populating ciEnv caches may cause safepoints due
124       // to taking the Compile_lock with safepoint checks.
125       (void)CURRENT_ENV-&gt;get_method(method);
126     }
127     return false;
128   }
129 };
130 
131 void ciMethodData::prepare_metadata() {
132   MethodData* mdo = get_MethodData();
133 
134   for (;;) {
135     ResourceMark rm;
136     PrepareExtraDataClosure cl(mdo);
137     mdo-&gt;clean_extra_data(&amp;cl);
138     if (cl.finish()) {
139       // When encountering uncached metadata, the Compile_lock might be
140       // acquired when creating ciMetadata handles, causing safepoints
141       // which requires a new round of preparation to clean out potentially
142       // new unloading metadata.
143       return;
144     }
145   }
146 }
147 
<a name="4" id="anc4"></a><span class="line-modified">148 void ciMethodData::load_remaining_extra_data() {</span>
149   MethodData* mdo = get_MethodData();
150   MutexLocker ml(mdo-&gt;extra_data_lock());
151   // Deferred metadata cleaning due to concurrent class unloading.
152   prepare_metadata();
153   // After metadata preparation, there is no stale metadata,
154   // and no safepoints can introduce more stale metadata.
155   NoSafepointVerifier no_safepoint;
156 
<a name="5" id="anc5"></a><span class="line-added">157   assert((mdo-&gt;data_size() == _data_size) &amp;&amp; (mdo-&gt;extra_data_size() == _extra_data_size), &quot;sanity, unchanged&quot;);</span>
<span class="line-added">158   assert(extra_data_base() == (DataLayout*)((address) _data + _data_size), &quot;sanity&quot;);</span>
<span class="line-added">159 </span>
<span class="line-added">160   // Copy the extra data once it is prepared (i.e. cache populated, no release of extra data lock anymore)</span>
<span class="line-added">161   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;extra_data_base(),</span>
<span class="line-added">162                               (HeapWord*)((address) _data + _data_size),</span>
<span class="line-added">163                               (_extra_data_size - mdo-&gt;parameters_size_in_bytes()) / HeapWordSize);</span>
<span class="line-added">164 </span>
165   // speculative trap entries also hold a pointer to a Method so need to be translated
166   DataLayout* dp_src  = mdo-&gt;extra_data_base();
167   DataLayout* end_src = mdo-&gt;args_data_limit();
168   DataLayout* dp_dst  = extra_data_base();
169   for (;; dp_src = MethodData::next_extra(dp_src), dp_dst = MethodData::next_extra(dp_dst)) {
170     assert(dp_src &lt; end_src, &quot;moved past end of extra data&quot;);
171     assert(((intptr_t)dp_dst) - ((intptr_t)extra_data_base()) == ((intptr_t)dp_src) - ((intptr_t)mdo-&gt;extra_data_base()), &quot;source and destination don&#39;t match&quot;);
172 
<a name="6" id="anc6"></a>




173     int tag = dp_src-&gt;tag();
<a name="7" id="anc7"></a>






174     switch(tag) {
175     case DataLayout::speculative_trap_data_tag: {
176       ciSpeculativeTrapData data_dst(dp_dst);
177       SpeculativeTrapData   data_src(dp_src);
178       data_dst.translate_from(&amp;data_src);
179       break;
180     }
181     case DataLayout::bit_data_tag:
182       break;
183     case DataLayout::no_tag:
184     case DataLayout::arg_info_data_tag:
185       // An empty slot or ArgInfoData entry marks the end of the trap data
186       {
187         return; // Need a block to avoid SS compiler bug
188       }
189     default:
190       fatal(&quot;bad tag = %d&quot;, tag);
191     }
192   }
193 }
194 
195 void ciMethodData::load_data() {
196   MethodData* mdo = get_MethodData();
197   if (mdo == NULL) {
198     return;
199   }
200 
201   // To do: don&#39;t copy the data if it is not &quot;ripe&quot; -- require a minimum #
202   // of invocations.
203 
<a name="8" id="anc8"></a><span class="line-modified">204   // Snapshot the data and extra parameter data first without the extra trap and arg info data.</span>
<span class="line-modified">205   // Those are copied in a second step. Actually, an approximate snapshot of the data is taken.</span>
<span class="line-modified">206   // Any concurrently executing threads may be changing the data as we copy it.</span>
<span class="line-added">207   //</span>
<span class="line-added">208   // The first snapshot step requires two copies (data entries and parameter data entries) since</span>
<span class="line-added">209   // the MDO is laid out as follows:</span>
<span class="line-added">210   //</span>
<span class="line-added">211   //  data_base:        ---------------------------</span>
<span class="line-added">212   //                    |       data entries      |</span>
<span class="line-added">213   //                    |           ...           |</span>
<span class="line-added">214   //  extra_data_base:  ---------------------------</span>
<span class="line-added">215   //                    |    trap data entries    |</span>
<span class="line-added">216   //                    |           ...           |</span>
<span class="line-added">217   //                    | one arg info data entry |</span>
<span class="line-added">218   //                    |    data for each arg    |</span>
<span class="line-added">219   //                    |           ...           |</span>
<span class="line-added">220   //  args_data_limit:  ---------------------------</span>
<span class="line-added">221   //                    |  parameter data entries |</span>
<span class="line-added">222   //                    |           ...           |</span>
<span class="line-added">223   //  extra_data_limit: ---------------------------</span>
<span class="line-added">224   //</span>
<span class="line-added">225   // _data_size = extra_data_base - data_base</span>
<span class="line-added">226   // _extra_data_size = extra_data_limit - extra_data_base</span>
<span class="line-added">227   // total_size = _data_size + _extra_data_size</span>
<span class="line-added">228   // args_data_limit = data_base + total_size - parameter_data_size</span>
229   Copy::disjoint_words_atomic((HeapWord*) mdo,
230                               (HeapWord*) &amp;_orig,
231                               sizeof(_orig) / HeapWordSize);
232   Arena* arena = CURRENT_ENV-&gt;arena();
233   _data_size = mdo-&gt;data_size();
234   _extra_data_size = mdo-&gt;extra_data_size();
235   int total_size = _data_size + _extra_data_size;
236   _data = (intptr_t *) arena-&gt;Amalloc(total_size);
237   Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;data_base(),
238                               (HeapWord*) _data,
<a name="9" id="anc9"></a><span class="line-modified">239                               _data_size / HeapWordSize);</span>
240 
<a name="10" id="anc10"></a><span class="line-added">241   int parameters_data_size = mdo-&gt;parameters_size_in_bytes();</span>
<span class="line-added">242   if (parameters_data_size &gt; 0) {</span>
<span class="line-added">243     // Snapshot the parameter data</span>
<span class="line-added">244     Copy::disjoint_words_atomic((HeapWord*) mdo-&gt;args_data_limit(),</span>
<span class="line-added">245                                 (HeapWord*) ((address)_data + total_size - parameters_data_size),</span>
<span class="line-added">246                                 parameters_data_size / HeapWordSize);</span>
<span class="line-added">247   }</span>
248   // Traverse the profile data, translating any oops into their
249   // ci equivalents.
250   ResourceMark rm;
251   ciProfileData* ci_data = first_data();
252   ProfileData* data = mdo-&gt;first_data();
253   while (is_valid(ci_data)) {
254     ci_data-&gt;translate_from(data);
255     ci_data = next_data(ci_data);
256     data = mdo-&gt;next_data(data);
257   }
258   if (mdo-&gt;parameters_type_data() != NULL) {
259     _parameters = data_layout_at(mdo-&gt;parameters_type_data_di());
260     ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);
261     parameters-&gt;translate_from(mdo-&gt;parameters_type_data());
262   }
263 
<a name="11" id="anc11"></a><span class="line-modified">264   assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),</span>
<span class="line-added">265       &quot;sanity - parameter data starts after the argument data of the single ArgInfoData entry&quot;);</span>
<span class="line-added">266   load_remaining_extra_data();</span>
267 
268   // Note:  Extra data are all BitData, and do not need translation.
269   _current_mileage = MethodData::mileage_of(mdo-&gt;method());
270   _invocation_counter = mdo-&gt;invocation_count();
271   _backedge_counter = mdo-&gt;backedge_count();
272   _state = mdo-&gt;is_mature()? mature_state: immature_state;
273 
274   _eflags = mdo-&gt;eflags();
275   _arg_local = mdo-&gt;arg_local();
276   _arg_stack = mdo-&gt;arg_stack();
277   _arg_returned  = mdo-&gt;arg_returned();
278 #ifndef PRODUCT
279   if (ReplayCompiles) {
280     ciReplay::initialize(this);
281   }
282 #endif
283 }
284 
285 void ciReceiverTypeData::translate_receiver_data_from(const ProfileData* data) {
286   for (uint row = 0; row &lt; row_limit(); row++) {
287     Klass* k = data-&gt;as_ReceiverTypeData()-&gt;receiver(row);
288     if (k != NULL) {
289       if (k-&gt;is_loader_alive()) {
290         ciKlass* klass = CURRENT_ENV-&gt;get_klass(k);
291         set_receiver(row, klass);
292       } else {
293         // With concurrent class unloading, the MDO could have stale metadata; override it
294         clear_row(row);
295       }
<a name="12" id="anc12"></a><span class="line-added">296     } else {</span>
<span class="line-added">297       set_receiver(row, NULL);</span>
298     }
299   }
300 }
301 
302 void ciTypeStackSlotEntries::translate_type_data_from(const TypeStackSlotEntries* entries) {
303   for (int i = 0; i &lt; number_of_entries(); i++) {
304     intptr_t k = entries-&gt;type(i);
305     Klass* klass = (Klass*)klass_part(k);
306     if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
307       // With concurrent class unloading, the MDO could have stale metadata; override it
308       TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)NULL, k));
309     } else {
310       TypeStackSlotEntries::set_type(i, translate_klass(k));
311     }
312   }
313 }
314 
315 void ciReturnTypeEntry::translate_type_data_from(const ReturnTypeEntry* ret) {
316   intptr_t k = ret-&gt;type();
317   Klass* klass = (Klass*)klass_part(k);
318   if (klass != NULL &amp;&amp; !klass-&gt;is_loader_alive()) {
319     // With concurrent class unloading, the MDO could have stale metadata; override it
320     set_type(ReturnTypeEntry::with_status((Klass*)NULL, k));
321   } else {
322     set_type(translate_klass(k));
323   }
324 }
325 
326 void ciSpeculativeTrapData::translate_from(const ProfileData* data) {
327   Method* m = data-&gt;as_SpeculativeTrapData()-&gt;method();
328   ciMethod* ci_m = CURRENT_ENV-&gt;get_method(m);
329   set_method(ci_m);
330 }
331 
332 // Get the data at an arbitrary (sort of) data index.
333 ciProfileData* ciMethodData::data_at(int data_index) {
334   if (out_of_bounds(data_index)) {
335     return NULL;
336   }
337   DataLayout* data_layout = data_layout_at(data_index);
338 
339   switch (data_layout-&gt;tag()) {
340   case DataLayout::no_tag:
341   default:
342     ShouldNotReachHere();
343     return NULL;
344   case DataLayout::bit_data_tag:
345     return new ciBitData(data_layout);
346   case DataLayout::counter_data_tag:
347     return new ciCounterData(data_layout);
348   case DataLayout::jump_data_tag:
349     return new ciJumpData(data_layout);
350   case DataLayout::receiver_type_data_tag:
351     return new ciReceiverTypeData(data_layout);
352   case DataLayout::virtual_call_data_tag:
353     return new ciVirtualCallData(data_layout);
354   case DataLayout::ret_data_tag:
355     return new ciRetData(data_layout);
356   case DataLayout::branch_data_tag:
357     return new ciBranchData(data_layout);
358   case DataLayout::multi_branch_data_tag:
359     return new ciMultiBranchData(data_layout);
360   case DataLayout::arg_info_data_tag:
361     return new ciArgInfoData(data_layout);
362   case DataLayout::call_type_data_tag:
363     return new ciCallTypeData(data_layout);
364   case DataLayout::virtual_call_type_data_tag:
365     return new ciVirtualCallTypeData(data_layout);
366   case DataLayout::parameters_type_data_tag:
367     return new ciParametersTypeData(data_layout);
368   };
369 }
370 
371 // Iteration over data.
372 ciProfileData* ciMethodData::next_data(ciProfileData* current) {
373   int current_index = dp_to_di(current-&gt;dp());
374   int next_index = current_index + current-&gt;size_in_bytes();
375   ciProfileData* next = data_at(next_index);
376   return next;
377 }
378 
379 ciProfileData* ciMethodData::bci_to_extra_data(int bci, ciMethod* m, bool&amp; two_free_slots) {
380   DataLayout* dp  = extra_data_base();
381   DataLayout* end = args_data_limit();
382   two_free_slots = false;
383   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
384     switch(dp-&gt;tag()) {
385     case DataLayout::no_tag:
386       _saw_free_extra_data = true;  // observed an empty slot (common case)
387       two_free_slots = (MethodData::next_extra(dp)-&gt;tag() == DataLayout::no_tag);
388       return NULL;
389     case DataLayout::arg_info_data_tag:
<a name="13" id="anc13"></a><span class="line-modified">390       return NULL; // ArgInfoData is after the trap data right before the parameter data.</span>
391     case DataLayout::bit_data_tag:
392       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
393         return new ciBitData(dp);
394       }
395       break;
396     case DataLayout::speculative_trap_data_tag: {
397       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
398       // data-&gt;method() might be null if the MDO is snapshotted
399       // concurrently with a trap
400       if (m != NULL &amp;&amp; data-&gt;method() == m &amp;&amp; dp-&gt;bci() == bci) {
401         return data;
402       }
403       break;
404     }
405     default:
406       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
407     }
408   }
409   return NULL;
410 }
411 
412 // Translate a bci to its corresponding data, or NULL.
413 ciProfileData* ciMethodData::bci_to_data(int bci, ciMethod* m) {
414   // If m is not NULL we look for a SpeculativeTrapData entry
415   if (m == NULL) {
416     ciProfileData* data = data_before(bci);
417     for ( ; is_valid(data); data = next_data(data)) {
418       if (data-&gt;bci() == bci) {
419         set_hint_di(dp_to_di(data-&gt;dp()));
420         return data;
421       } else if (data-&gt;bci() &gt; bci) {
422         break;
423       }
424     }
425   }
426   bool two_free_slots = false;
427   ciProfileData* result = bci_to_extra_data(bci, m, two_free_slots);
428   if (result != NULL) {
429     return result;
430   }
431   if (m != NULL &amp;&amp; !two_free_slots) {
432     // We were looking for a SpeculativeTrapData entry we didn&#39;t
433     // find. Room is not available for more SpeculativeTrapData
434     // entries, look in the non SpeculativeTrapData entries.
435     return bci_to_data(bci, NULL);
436   }
437   return NULL;
438 }
439 
440 // Conservatively decode the trap_state of a ciProfileData.
441 int ciMethodData::has_trap_at(ciProfileData* data, int reason) {
442   typedef Deoptimization::DeoptReason DR_t;
443   int per_bc_reason
444     = Deoptimization::reason_recorded_per_bytecode_if_any((DR_t) reason);
445   if (trap_count(reason) == 0) {
446     // Impossible for this trap to have occurred, regardless of trap_state.
447     // Note:  This happens if the MDO is empty.
448     return 0;
449   } else if (per_bc_reason == Deoptimization::Reason_none) {
450     // We cannot conclude anything; a trap happened somewhere, maybe here.
451     return -1;
452   } else if (data == NULL) {
453     // No profile here, not even an extra_data record allocated on the fly.
454     // If there are empty extra_data records, and there had been a trap,
455     // there would have been a non-null data pointer.  If there are no
456     // free extra_data records, we must return a conservative -1.
457     if (_saw_free_extra_data)
458       return 0;                 // Q.E.D.
459     else
460       return -1;                // bail with a conservative answer
461   } else {
462     return Deoptimization::trap_state_has_reason(data-&gt;trap_state(), per_bc_reason);
463   }
464 }
465 
466 int ciMethodData::trap_recompiled_at(ciProfileData* data) {
467   if (data == NULL) {
468     return (_saw_free_extra_data? 0: -1);  // (see previous method)
469   } else {
470     return Deoptimization::trap_state_is_recompiled(data-&gt;trap_state())? 1: 0;
471   }
472 }
473 
474 void ciMethodData::clear_escape_info() {
475   VM_ENTRY_MARK;
476   MethodData* mdo = get_MethodData();
477   if (mdo != NULL) {
478     mdo-&gt;clear_escape_info();
479     ArgInfoData *aid = arg_info();
480     int arg_count = (aid == NULL) ? 0 : aid-&gt;number_of_args();
481     for (int i = 0; i &lt; arg_count; i++) {
482       set_arg_modified(i, 0);
483     }
484   }
485   _eflags = _arg_local = _arg_stack = _arg_returned = 0;
486 }
487 
488 // copy our escape info to the MethodData* if it exists
489 void ciMethodData::update_escape_info() {
490   VM_ENTRY_MARK;
491   MethodData* mdo = get_MethodData();
492   if ( mdo != NULL) {
493     mdo-&gt;set_eflags(_eflags);
494     mdo-&gt;set_arg_local(_arg_local);
495     mdo-&gt;set_arg_stack(_arg_stack);
496     mdo-&gt;set_arg_returned(_arg_returned);
497     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
498     for (int i = 0; i &lt; arg_count; i++) {
499       mdo-&gt;set_arg_modified(i, arg_modified(i));
500     }
501   }
502 }
503 
504 void ciMethodData::set_compilation_stats(short loops, short blocks) {
505   VM_ENTRY_MARK;
506   MethodData* mdo = get_MethodData();
507   if (mdo != NULL) {
508     mdo-&gt;set_num_loops(loops);
509     mdo-&gt;set_num_blocks(blocks);
510   }
511 }
512 
513 void ciMethodData::set_would_profile(bool p) {
514   VM_ENTRY_MARK;
515   MethodData* mdo = get_MethodData();
516   if (mdo != NULL) {
517     mdo-&gt;set_would_profile(p);
518   }
519 }
520 
521 void ciMethodData::set_argument_type(int bci, int i, ciKlass* k) {
522   VM_ENTRY_MARK;
523   MethodData* mdo = get_MethodData();
524   if (mdo != NULL) {
525     ProfileData* data = mdo-&gt;bci_to_data(bci);
526     if (data != NULL) {
527       if (data-&gt;is_CallTypeData()) {
528         data-&gt;as_CallTypeData()-&gt;set_argument_type(i, k-&gt;get_Klass());
529       } else {
530         assert(data-&gt;is_VirtualCallTypeData(), &quot;no arguments!&quot;);
531         data-&gt;as_VirtualCallTypeData()-&gt;set_argument_type(i, k-&gt;get_Klass());
532       }
533     }
534   }
535 }
536 
537 void ciMethodData::set_parameter_type(int i, ciKlass* k) {
538   VM_ENTRY_MARK;
539   MethodData* mdo = get_MethodData();
540   if (mdo != NULL) {
541     mdo-&gt;parameters_type_data()-&gt;set_type(i, k-&gt;get_Klass());
542   }
543 }
544 
545 void ciMethodData::set_return_type(int bci, ciKlass* k) {
546   VM_ENTRY_MARK;
547   MethodData* mdo = get_MethodData();
548   if (mdo != NULL) {
549     ProfileData* data = mdo-&gt;bci_to_data(bci);
550     if (data != NULL) {
551       if (data-&gt;is_CallTypeData()) {
552         data-&gt;as_CallTypeData()-&gt;set_return_type(k-&gt;get_Klass());
553       } else {
554         assert(data-&gt;is_VirtualCallTypeData(), &quot;no arguments!&quot;);
555         data-&gt;as_VirtualCallTypeData()-&gt;set_return_type(k-&gt;get_Klass());
556       }
557     }
558   }
559 }
560 
561 bool ciMethodData::has_escape_info() {
562   return eflag_set(MethodData::estimated);
563 }
564 
565 void ciMethodData::set_eflag(MethodData::EscapeFlag f) {
566   set_bits(_eflags, f);
567 }
568 
569 bool ciMethodData::eflag_set(MethodData::EscapeFlag f) const {
570   return mask_bits(_eflags, f) != 0;
571 }
572 
573 void ciMethodData::set_arg_local(int i) {
574   set_nth_bit(_arg_local, i);
575 }
576 
577 void ciMethodData::set_arg_stack(int i) {
578   set_nth_bit(_arg_stack, i);
579 }
580 
581 void ciMethodData::set_arg_returned(int i) {
582   set_nth_bit(_arg_returned, i);
583 }
584 
585 void ciMethodData::set_arg_modified(int arg, uint val) {
586   ArgInfoData *aid = arg_info();
587   if (aid == NULL)
588     return;
589   assert(arg &gt;= 0 &amp;&amp; arg &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
590   aid-&gt;set_arg_modified(arg, val);
591 }
592 
593 bool ciMethodData::is_arg_local(int i) const {
594   return is_set_nth_bit(_arg_local, i);
595 }
596 
597 bool ciMethodData::is_arg_stack(int i) const {
598   return is_set_nth_bit(_arg_stack, i);
599 }
600 
601 bool ciMethodData::is_arg_returned(int i) const {
602   return is_set_nth_bit(_arg_returned, i);
603 }
604 
605 uint ciMethodData::arg_modified(int arg) const {
606   ArgInfoData *aid = arg_info();
607   if (aid == NULL)
608     return 0;
609   assert(arg &gt;= 0 &amp;&amp; arg &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
610   return aid-&gt;arg_modified(arg);
611 }
612 
613 ByteSize ciMethodData::offset_of_slot(ciProfileData* data, ByteSize slot_offset_in_data) {
614   // Get offset within MethodData* of the data array
615   ByteSize data_offset = MethodData::data_offset();
616 
617   // Get cell offset of the ProfileData within data array
618   int cell_offset = dp_to_di(data-&gt;dp());
619 
620   // Add in counter_offset, the # of bytes into the ProfileData of counter or flag
621   int offset = in_bytes(data_offset) + cell_offset + in_bytes(slot_offset_in_data);
622 
623   return in_ByteSize(offset);
624 }
625 
626 ciArgInfoData *ciMethodData::arg_info() const {
627   // Should be last, have to skip all traps.
628   DataLayout* dp  = extra_data_base();
629   DataLayout* end = args_data_limit();
630   for (; dp &lt; end; dp = MethodData::next_extra(dp)) {
631     if (dp-&gt;tag() == DataLayout::arg_info_data_tag)
632       return new ciArgInfoData(dp);
633   }
634   return NULL;
635 }
636 
637 
638 // Implementation of the print method.
639 void ciMethodData::print_impl(outputStream* st) {
640   ciMetadata::print_impl(st);
641 }
642 
643 void ciMethodData::dump_replay_data_type_helper(outputStream* out, int round, int&amp; count, ProfileData* pdata, ByteSize offset, ciKlass* k) {
644   if (k != NULL) {
645     if (round == 0) {
646       count++;
647     } else {
648       out-&gt;print(&quot; %d %s&quot;, (int)(dp_to_di(pdata-&gt;dp() + in_bytes(offset)) / sizeof(intptr_t)), k-&gt;name()-&gt;as_quoted_ascii());
649     }
650   }
651 }
652 
653 template&lt;class T&gt; void ciMethodData::dump_replay_data_receiver_type_helper(outputStream* out, int round, int&amp; count, T* vdata) {
654   for (uint i = 0; i &lt; vdata-&gt;row_limit(); i++) {
655     dump_replay_data_type_helper(out, round, count, vdata, vdata-&gt;receiver_offset(i), vdata-&gt;receiver(i));
656   }
657 }
658 
659 template&lt;class T&gt; void ciMethodData::dump_replay_data_call_type_helper(outputStream* out, int round, int&amp; count, T* call_type_data) {
660   if (call_type_data-&gt;has_arguments()) {
661     for (int i = 0; i &lt; call_type_data-&gt;number_of_arguments(); i++) {
662       dump_replay_data_type_helper(out, round, count, call_type_data, call_type_data-&gt;argument_type_offset(i), call_type_data-&gt;valid_argument_type(i));
663     }
664   }
665   if (call_type_data-&gt;has_return()) {
666     dump_replay_data_type_helper(out, round, count, call_type_data, call_type_data-&gt;return_type_offset(), call_type_data-&gt;valid_return_type());
667   }
668 }
669 
670 void ciMethodData::dump_replay_data_extra_data_helper(outputStream* out, int round, int&amp; count) {
671   DataLayout* dp  = extra_data_base();
672   DataLayout* end = args_data_limit();
673 
674   for (;dp &lt; end; dp = MethodData::next_extra(dp)) {
675     switch(dp-&gt;tag()) {
676     case DataLayout::no_tag:
677     case DataLayout::arg_info_data_tag:
678       return;
679     case DataLayout::bit_data_tag:
680       break;
681     case DataLayout::speculative_trap_data_tag: {
682       ciSpeculativeTrapData* data = new ciSpeculativeTrapData(dp);
683       ciMethod* m = data-&gt;method();
684       if (m != NULL) {
685         if (round == 0) {
686           count++;
687         } else {
688           out-&gt;print(&quot; %d &quot;, (int)(dp_to_di(((address)dp) + in_bytes(ciSpeculativeTrapData::method_offset())) / sizeof(intptr_t)));
689           m-&gt;dump_name_as_ascii(out);
690         }
691       }
692       break;
693     }
694     default:
695       fatal(&quot;bad tag = %d&quot;, dp-&gt;tag());
696     }
697   }
698 }
699 
700 void ciMethodData::dump_replay_data(outputStream* out) {
701   ResourceMark rm;
702   MethodData* mdo = get_MethodData();
703   Method* method = mdo-&gt;method();
704   Klass* holder = method-&gt;method_holder();
705   out-&gt;print(&quot;ciMethodData %s %s %s %d %d&quot;,
706              holder-&gt;name()-&gt;as_quoted_ascii(),
707              method-&gt;name()-&gt;as_quoted_ascii(),
708              method-&gt;signature()-&gt;as_quoted_ascii(),
709              _state,
710              current_mileage());
711 
712   // dump the contents of the MDO header as raw data
713   unsigned char* orig = (unsigned char*)&amp;_orig;
714   int length = sizeof(_orig);
715   out-&gt;print(&quot; orig %d&quot;, length);
716   for (int i = 0; i &lt; length; i++) {
717     out-&gt;print(&quot; %d&quot;, orig[i]);
718   }
719 
720   // dump the MDO data as raw data
721   int elements = (data_size() + extra_data_size()) / sizeof(intptr_t);
722   out-&gt;print(&quot; data %d&quot;, elements);
723   for (int i = 0; i &lt; elements; i++) {
724     // We could use INTPTR_FORMAT here but that&#39;s zero justified
725     // which makes comparing it with the SA version of this output
726     // harder. data()&#39;s element type is intptr_t.
727     out-&gt;print(&quot; &quot; INTPTRNZ_FORMAT, data()[i]);
728   }
729 
730   // The MDO contained oop references as ciObjects, so scan for those
731   // and emit pairs of offset and klass name so that they can be
732   // reconstructed at runtime.  The first round counts the number of
733   // oop references and the second actually emits them.
734   ciParametersTypeData* parameters = parameters_type_data();
735   for (int count = 0, round = 0; round &lt; 2; round++) {
736     if (round == 1) out-&gt;print(&quot; oops %d&quot;, count);
737     ProfileData* pdata = first_data();
738     for ( ; is_valid(pdata); pdata = next_data(pdata)) {
739       if (pdata-&gt;is_VirtualCallData()) {
740         ciVirtualCallData* vdata = (ciVirtualCallData*)pdata;
741         dump_replay_data_receiver_type_helper&lt;ciVirtualCallData&gt;(out, round, count, vdata);
742         if (pdata-&gt;is_VirtualCallTypeData()) {
743           ciVirtualCallTypeData* call_type_data = (ciVirtualCallTypeData*)pdata;
744           dump_replay_data_call_type_helper&lt;ciVirtualCallTypeData&gt;(out, round, count, call_type_data);
745         }
746       } else if (pdata-&gt;is_ReceiverTypeData()) {
747         ciReceiverTypeData* vdata = (ciReceiverTypeData*)pdata;
748         dump_replay_data_receiver_type_helper&lt;ciReceiverTypeData&gt;(out, round, count, vdata);
749       } else if (pdata-&gt;is_CallTypeData()) {
750           ciCallTypeData* call_type_data = (ciCallTypeData*)pdata;
751           dump_replay_data_call_type_helper&lt;ciCallTypeData&gt;(out, round, count, call_type_data);
752       }
753     }
754     if (parameters != NULL) {
755       for (int i = 0; i &lt; parameters-&gt;number_of_parameters(); i++) {
756         dump_replay_data_type_helper(out, round, count, parameters, ParametersTypeData::type_offset(i), parameters-&gt;valid_parameter_type(i));
757       }
758     }
759   }
760   for (int count = 0, round = 0; round &lt; 2; round++) {
761     if (round == 1) out-&gt;print(&quot; methods %d&quot;, count);
762     dump_replay_data_extra_data_helper(out, round, count);
763   }
764   out-&gt;cr();
765 }
766 
767 #ifndef PRODUCT
768 void ciMethodData::print() {
769   print_data_on(tty);
770 }
771 
772 void ciMethodData::print_data_on(outputStream* st) {
773   ResourceMark rm;
774   ciParametersTypeData* parameters = parameters_type_data();
775   if (parameters != NULL) {
776     parameters-&gt;print_data_on(st);
777   }
778   ciProfileData* data;
779   for (data = first_data(); is_valid(data); data = next_data(data)) {
780     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
781     st-&gt;fill_to(6);
782     data-&gt;print_data_on(st);
783   }
784   st-&gt;print_cr(&quot;--- Extra data:&quot;);
785   DataLayout* dp  = extra_data_base();
786   DataLayout* end = args_data_limit();
787   for (;; dp = MethodData::next_extra(dp)) {
788     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
789     switch (dp-&gt;tag()) {
790     case DataLayout::no_tag:
791       continue;
792     case DataLayout::bit_data_tag:
793       data = new BitData(dp);
794       break;
795     case DataLayout::arg_info_data_tag:
796       data = new ciArgInfoData(dp);
<a name="14" id="anc14"></a><span class="line-modified">797       dp = end; // ArgInfoData is after the trap data right before the parameter data.</span>
798       break;
799     case DataLayout::speculative_trap_data_tag:
800       data = new ciSpeculativeTrapData(dp);
801       break;
802     default:
803       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
804     }
805     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
806     st-&gt;fill_to(6);
807     data-&gt;print_data_on(st);
808     if (dp &gt;= end) return;
809   }
810 }
811 
812 void ciTypeEntries::print_ciklass(outputStream* st, intptr_t k) {
813   if (TypeEntries::is_type_none(k)) {
814     st-&gt;print(&quot;none&quot;);
815   } else if (TypeEntries::is_type_unknown(k)) {
816     st-&gt;print(&quot;unknown&quot;);
817   } else {
818     valid_ciklass(k)-&gt;print_name_on(st);
819   }
820   if (TypeEntries::was_null_seen(k)) {
821     st-&gt;print(&quot; (null seen)&quot;);
822   }
823 }
824 
825 void ciTypeStackSlotEntries::print_data_on(outputStream* st) const {
826   for (int i = 0; i &lt; number_of_entries(); i++) {
827     _pd-&gt;tab(st);
828     st-&gt;print(&quot;%d: stack (%u) &quot;, i, stack_slot(i));
829     print_ciklass(st, type(i));
830     st-&gt;cr();
831   }
832 }
833 
834 void ciReturnTypeEntry::print_data_on(outputStream* st) const {
835   _pd-&gt;tab(st);
836   st-&gt;print(&quot;ret &quot;);
837   print_ciklass(st, type());
838   st-&gt;cr();
839 }
840 
841 void ciCallTypeData::print_data_on(outputStream* st, const char* extra) const {
842   print_shared(st, &quot;ciCallTypeData&quot;, extra);
843   if (has_arguments()) {
844     tab(st, true);
845     st-&gt;print_cr(&quot;argument types&quot;);
846     args()-&gt;print_data_on(st);
847   }
848   if (has_return()) {
849     tab(st, true);
850     st-&gt;print_cr(&quot;return type&quot;);
851     ret()-&gt;print_data_on(st);
852   }
853 }
854 
855 void ciReceiverTypeData::print_receiver_data_on(outputStream* st) const {
856   uint row;
857   int entries = 0;
858   for (row = 0; row &lt; row_limit(); row++) {
859     if (receiver(row) != NULL)  entries++;
860   }
861   st-&gt;print_cr(&quot;count(%u) entries(%u)&quot;, count(), entries);
862   for (row = 0; row &lt; row_limit(); row++) {
863     if (receiver(row) != NULL) {
864       tab(st);
865       receiver(row)-&gt;print_name_on(st);
866       st-&gt;print_cr(&quot;(%u)&quot;, receiver_count(row));
867     }
868   }
869 }
870 
871 void ciReceiverTypeData::print_data_on(outputStream* st, const char* extra) const {
872   print_shared(st, &quot;ciReceiverTypeData&quot;, extra);
873   print_receiver_data_on(st);
874 }
875 
876 void ciVirtualCallData::print_data_on(outputStream* st, const char* extra) const {
877   print_shared(st, &quot;ciVirtualCallData&quot;, extra);
878   rtd_super()-&gt;print_receiver_data_on(st);
879 }
880 
881 void ciVirtualCallTypeData::print_data_on(outputStream* st, const char* extra) const {
882   print_shared(st, &quot;ciVirtualCallTypeData&quot;, extra);
883   rtd_super()-&gt;print_receiver_data_on(st);
884   if (has_arguments()) {
885     tab(st, true);
886     st-&gt;print(&quot;argument types&quot;);
887     args()-&gt;print_data_on(st);
888   }
889   if (has_return()) {
890     tab(st, true);
891     st-&gt;print(&quot;return type&quot;);
892     ret()-&gt;print_data_on(st);
893   }
894 }
895 
896 void ciParametersTypeData::print_data_on(outputStream* st, const char* extra) const {
897   st-&gt;print_cr(&quot;ciParametersTypeData&quot;);
898   parameters()-&gt;print_data_on(st);
899 }
900 
901 void ciSpeculativeTrapData::print_data_on(outputStream* st, const char* extra) const {
902   st-&gt;print_cr(&quot;ciSpeculativeTrapData&quot;);
903   tab(st);
904   method()-&gt;print_short_name(st);
905   st-&gt;cr();
906 }
907 #endif
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/rewriter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopMapCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/rewriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,17 ***</span>
      _method_handle_invokers.at_grow(length, 0);
    }
  }
  
  // Unrewrite the bytecodes if an error occurs.
<span class="line-modified">! void Rewriter::restore_bytecodes() {</span>
    int len = _methods-&gt;length();
    bool invokespecial_error = false;
  
    for (int i = len-1; i &gt;= 0; i--) {
      Method* method = _methods-&gt;at(i);
<span class="line-modified">!     scan_method(method, true, &amp;invokespecial_error);</span>
      assert(!invokespecial_error, &quot;reversing should not get an invokespecial error&quot;);
    }
  }
  
  // Creates a constant pool cache given a CPC map
<span class="line-new-header">--- 78,17 ---</span>
      _method_handle_invokers.at_grow(length, 0);
    }
  }
  
  // Unrewrite the bytecodes if an error occurs.
<span class="line-modified">! void Rewriter::restore_bytecodes(Thread* thread) {</span>
    int len = _methods-&gt;length();
    bool invokespecial_error = false;
  
    for (int i = len-1; i &gt;= 0; i--) {
      Method* method = _methods-&gt;at(i);
<span class="line-modified">!     scan_method(thread, method, true, &amp;invokespecial_error);</span>
      assert(!invokespecial_error, &quot;reversing should not get an invokespecial error&quot;);
    }
  }
  
  // Creates a constant pool cache given a CPC map
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,11 ***</span>
      if (tag.is_method_handle() ||
          tag.is_method_type() ||
          tag.is_string() ||
          (tag.is_dynamic_constant() &amp;&amp;
           // keep regular ldc interpreter logic for condy primitives
<span class="line-modified">!          is_reference_type(FieldType::basic_type(_pool-&gt;uncached_signature_ref_at(cp_index))))</span>
          ) {
        int ref_index = cp_entry_to_resolved_references(cp_index);
        if (is_wide) {
          (*bcp) = Bytecodes::_fast_aldc_w;
          assert(ref_index == (u2)ref_index, &quot;index overflow&quot;);
<span class="line-new-header">--- 328,11 ---</span>
      if (tag.is_method_handle() ||
          tag.is_method_type() ||
          tag.is_string() ||
          (tag.is_dynamic_constant() &amp;&amp;
           // keep regular ldc interpreter logic for condy primitives
<span class="line-modified">!          is_reference_type(Signature::basic_type(_pool-&gt;uncached_signature_ref_at(cp_index))))</span>
          ) {
        int ref_index = cp_entry_to_resolved_references(cp_index);
        if (is_wide) {
          (*bcp) = Bytecodes::_fast_aldc_w;
          assert(ref_index == (u2)ref_index, &quot;index overflow&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,11 ***</span>
    }
  }
  
  
  // Rewrites a method given the index_map information
<span class="line-modified">! void Rewriter::scan_method(Method* method, bool reverse, bool* invokespecial_error) {</span>
  
    int nof_jsrs = 0;
    bool has_monitor_bytecodes = false;
    Bytecodes::Code c;
  
<span class="line-new-header">--- 363,11 ---</span>
    }
  }
  
  
  // Rewrites a method given the index_map information
<span class="line-modified">! void Rewriter::scan_method(Thread* thread, Method* method, bool reverse, bool* invokespecial_error) {</span>
  
    int nof_jsrs = 0;
    bool has_monitor_bytecodes = false;
    Bytecodes::Code c;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,11 ***</span>
            //
            // The check is performed after verification and only if verification has
            // succeeded. Therefore, the class is guaranteed to be well-formed.
            InstanceKlass* klass = method-&gt;method_holder();
            u2 bc_index = Bytes::get_Java_u2(bcp + prefix_length + 1);
<span class="line-modified">!           constantPoolHandle cp(method-&gt;constants());</span>
            Symbol* ref_class_name = cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(bc_index));
  
            if (klass-&gt;name() == ref_class_name) {
              Symbol* field_name = cp-&gt;name_ref_at(bc_index);
              Symbol* field_sig = cp-&gt;signature_ref_at(bc_index);
<span class="line-new-header">--- 437,11 ---</span>
            //
            // The check is performed after verification and only if verification has
            // succeeded. Therefore, the class is guaranteed to be well-formed.
            InstanceKlass* klass = method-&gt;method_holder();
            u2 bc_index = Bytes::get_Java_u2(bcp + prefix_length + 1);
<span class="line-modified">!           constantPoolHandle cp(thread, method-&gt;constants());</span>
            Symbol* ref_class_name = cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(bc_index));
  
            if (klass-&gt;name() == ref_class_name) {
              Symbol* field_name = cp-&gt;name_ref_at(bc_index);
              Symbol* field_sig = cp-&gt;signature_ref_at(bc_index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,11 ***</span>
    int len = _methods-&gt;length();
    bool invokespecial_error = false;
  
    for (int i = len-1; i &gt;= 0; i--) {
      Method* method = _methods-&gt;at(i);
<span class="line-modified">!     scan_method(method, false, &amp;invokespecial_error);</span>
      if (invokespecial_error) {
        // If you get an error here, there is no reversing bytecodes
        // This exception is stored for this class and no further attempt is
        // made at verifying or rewriting.
        THROW_MSG(vmSymbols::java_lang_InternalError(),
<span class="line-new-header">--- 546,11 ---</span>
    int len = _methods-&gt;length();
    bool invokespecial_error = false;
  
    for (int i = len-1; i &gt;= 0; i--) {
      Method* method = _methods-&gt;at(i);
<span class="line-modified">!     scan_method(THREAD, method, false, &amp;invokespecial_error);</span>
      if (invokespecial_error) {
        // If you get an error here, there is no reversing bytecodes
        // This exception is stored for this class and no further attempt is
        // made at verifying or rewriting.
        THROW_MSG(vmSymbols::java_lang_InternalError(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 568,11 ***</span>
  void Rewriter::rewrite(InstanceKlass* klass, TRAPS) {
    if (!DumpSharedSpaces) {
      assert(!klass-&gt;is_shared(), &quot;archive methods must not be rewritten at run time&quot;);
    }
    ResourceMark rm(THREAD);
<span class="line-modified">!   Rewriter     rw(klass, klass-&gt;constants(), klass-&gt;methods(), CHECK);</span>
    // (That&#39;s all, folks.)
  }
  
  Rewriter::Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS)
    : _klass(klass),
<span class="line-new-header">--- 568,12 ---</span>
  void Rewriter::rewrite(InstanceKlass* klass, TRAPS) {
    if (!DumpSharedSpaces) {
      assert(!klass-&gt;is_shared(), &quot;archive methods must not be rewritten at run time&quot;);
    }
    ResourceMark rm(THREAD);
<span class="line-modified">!   constantPoolHandle cpool(THREAD, klass-&gt;constants());</span>
<span class="line-added">+   Rewriter     rw(klass, cpool, klass-&gt;methods(), CHECK);</span>
    // (That&#39;s all, folks.)
  }
  
  Rewriter::Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS)
    : _klass(klass),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,21 ***</span>
    // Rewrite bytecodes - exception here exits.
    rewrite_bytecodes(CHECK);
  
    // Stress restoring bytecodes
    if (StressRewriter) {
<span class="line-modified">!     restore_bytecodes();</span>
      rewrite_bytecodes(CHECK);
    }
  
    // allocate constant pool cache, now that we&#39;ve seen all the bytecodes
    make_constant_pool_cache(THREAD);
  
    // Restore bytecodes to their unrewritten state if there are exceptions
    // rewriting bytecodes or allocating the cpCache
    if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">!     restore_bytecodes();</span>
      return;
    }
  
    // Relocate after everything, but still do this under the is_rewritten flag,
    // so methods with jsrs in custom class lists in aren&#39;t attempted to be
<span class="line-new-header">--- 591,21 ---</span>
    // Rewrite bytecodes - exception here exits.
    rewrite_bytecodes(CHECK);
  
    // Stress restoring bytecodes
    if (StressRewriter) {
<span class="line-modified">!     restore_bytecodes(THREAD);</span>
      rewrite_bytecodes(CHECK);
    }
  
    // allocate constant pool cache, now that we&#39;ve seen all the bytecodes
    make_constant_pool_cache(THREAD);
  
    // Restore bytecodes to their unrewritten state if there are exceptions
    // rewriting bytecodes or allocating the cpCache
    if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">!     restore_bytecodes(THREAD);</span>
      return;
    }
  
    // Relocate after everything, but still do this under the is_rewritten flag,
    // so methods with jsrs in custom class lists in aren&#39;t attempted to be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,11 ***</span>
        m = rewrite_jsrs(m, THREAD);
        // Restore bytecodes to their unrewritten state if there are exceptions
        // relocating bytecodes.  If some are relocated, that is ok because that
        // doesn&#39;t affect constant pool to cpCache rewriting.
        if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">!         restore_bytecodes();</span>
          return;
        }
        // Method might have gotten rewritten.
        methods-&gt;at_put(i, m());
      }
<span class="line-new-header">--- 619,11 ---</span>
        m = rewrite_jsrs(m, THREAD);
        // Restore bytecodes to their unrewritten state if there are exceptions
        // relocating bytecodes.  If some are relocated, that is ok because that
        // doesn&#39;t affect constant pool to cpCache rewriting.
        if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">!         restore_bytecodes(THREAD);</span>
          return;
        }
        // Method might have gotten rewritten.
        methods-&gt;at_put(i, m());
      }
</pre>
<center><a href="oopMapCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
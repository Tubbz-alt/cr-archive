<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/interpreter/bytecode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_BYTECODE_HPP
 26 #define SHARE_INTERPRETER_BYTECODE_HPP
 27 
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;utilities/align.hpp&quot;
 32 #include &quot;utilities/bytes.hpp&quot;
 33 
 34 class ciBytecodeStream;
 35 
 36 // The base class for different kinds of bytecode abstractions.
 37 // Provides the primitive operations to manipulate code relative
 38 // to the bcp.
 39 
 40 class Bytecode: public StackObj {
 41  protected:
 42   const address   _bcp;
 43   const Bytecodes::Code _code;
 44 
 45   // Address computation
 46   address addr_at            (int offset)        const     { return (address)_bcp + offset; }
 47   u_char byte_at(int offset) const               { return *addr_at(offset); }
 48   address aligned_addr_at    (int offset)        const     { return align_up(addr_at(offset), jintSize); }
 49 
 50   // Word access:
 51   int     get_Java_u2_at     (int offset)        const     { return Bytes::get_Java_u2(addr_at(offset)); }
 52   int     get_Java_u4_at     (int offset)        const     { return Bytes::get_Java_u4(addr_at(offset)); }
 53   int     get_aligned_Java_u4_at(int offset)     const     { return Bytes::get_Java_u4(aligned_addr_at(offset)); }
 54   int     get_native_u2_at   (int offset)        const     { return Bytes::get_native_u2(addr_at(offset)); }
 55   int     get_native_u4_at   (int offset)        const     { return Bytes::get_native_u4(addr_at(offset)); }
 56 
 57  public:
 58   Bytecode(Method* method, address bcp): _bcp(bcp), _code(Bytecodes::code_at(method, addr_at(0))) {
 59     assert(method != NULL, &quot;this form requires a valid Method*&quot;);
 60   }
 61   // Defined in ciStreams.hpp
 62   inline Bytecode(const ciBytecodeStream* stream, address bcp = NULL);
 63 
 64   // Attributes
 65   address bcp() const                            { return _bcp; }
 66   int instruction_size() const                   { return Bytecodes::length_for_code_at(_code, bcp()); }
 67 
 68   Bytecodes::Code code() const                   { return _code; }
 69   Bytecodes::Code java_code() const              { return Bytecodes::java_code(code()); }
 70   Bytecodes::Code invoke_code() const            { return (code() == Bytecodes::_invokehandle) ? code() : java_code(); }
 71 
 72   // Static functions for parsing bytecodes in place.
 73   int get_index_u1(Bytecodes::Code bc) const {
 74     assert_same_format_as(bc); assert_index_size(1, bc);
 75     return *(jubyte*)addr_at(1);
 76   }
 77   int get_index_u2(Bytecodes::Code bc, bool is_wide = false) const {
 78     assert_same_format_as(bc, is_wide); assert_index_size(2, bc, is_wide);
 79     address p = addr_at(is_wide ? 2 : 1);
 80     if (can_use_native_byte_order(bc, is_wide))
 81       return Bytes::get_native_u2(p);
 82     else  return Bytes::get_Java_u2(p);
 83   }
 84   int get_index_u1_cpcache(Bytecodes::Code bc) const {
 85     assert_same_format_as(bc); assert_index_size(1, bc);
 86     return *(jubyte*)addr_at(1) + ConstantPool::CPCACHE_INDEX_TAG;
 87   }
 88   int get_index_u2_cpcache(Bytecodes::Code bc) const {
 89     assert_same_format_as(bc); assert_index_size(2, bc); assert_native_index(bc);
 90     return Bytes::get_native_u2(addr_at(1)) + ConstantPool::CPCACHE_INDEX_TAG;
 91   }
 92   int get_index_u4(Bytecodes::Code bc) const {
 93     assert_same_format_as(bc); assert_index_size(4, bc);
 94     assert(can_use_native_byte_order(bc), &quot;&quot;);
 95     return Bytes::get_native_u4(addr_at(1));
 96   }
 97   bool has_index_u4(Bytecodes::Code bc) const {
 98     return bc == Bytecodes::_invokedynamic;
 99   }
100 
101   int get_offset_s2(Bytecodes::Code bc) const {
102     assert_same_format_as(bc); assert_offset_size(2, bc);
103     return (jshort) Bytes::get_Java_u2(addr_at(1));
104   }
105   int get_offset_s4(Bytecodes::Code bc) const {
106     assert_same_format_as(bc); assert_offset_size(4, bc);
107     return (jint) Bytes::get_Java_u4(addr_at(1));
108   }
109 
110   int get_constant_u1(int offset, Bytecodes::Code bc) const {
111     assert_same_format_as(bc); assert_constant_size(1, offset, bc);
112     return *(jbyte*)addr_at(offset);
113   }
114   int get_constant_u2(int offset, Bytecodes::Code bc, bool is_wide = false) const {
115     assert_same_format_as(bc, is_wide); assert_constant_size(2, offset, bc, is_wide);
116     return (jshort) Bytes::get_Java_u2(addr_at(offset));
117   }
118 
119   // These are used locally and also from bytecode streams.
120   void assert_same_format_as(Bytecodes::Code testbc, bool is_wide = false) const NOT_DEBUG_RETURN;
121   static void assert_index_size(int required_size, Bytecodes::Code bc, bool is_wide = false) NOT_DEBUG_RETURN;
122   static void assert_offset_size(int required_size, Bytecodes::Code bc, bool is_wide = false) NOT_DEBUG_RETURN;
123   static void assert_constant_size(int required_size, int where, Bytecodes::Code bc, bool is_wide = false) NOT_DEBUG_RETURN;
124   static void assert_native_index(Bytecodes::Code bc, bool is_wide = false) NOT_DEBUG_RETURN;
125   static bool can_use_native_byte_order(Bytecodes::Code bc, bool is_wide = false) {
126     return (!Endian::is_Java_byte_ordering_different() || Bytecodes::native_byte_order(bc /*, is_wide*/));
127   }
128 };
129 
130 
131 // Abstractions for lookupswitch bytecode
132 class LookupswitchPair {
133  private:
134   const address _bcp;
135 
136   address addr_at            (int offset)        const     { return _bcp + offset; }
137   int     get_Java_u4_at     (int offset)        const     { return Bytes::get_Java_u4(addr_at(offset)); }
138 
139  public:
140   LookupswitchPair(address bcp): _bcp(bcp) {}
141   int  match() const                             { return get_Java_u4_at(0 * jintSize); }
142   int  offset() const                            { return get_Java_u4_at(1 * jintSize); }
143 };
144 
145 
146 class Bytecode_lookupswitch: public Bytecode {
147  public:
148   Bytecode_lookupswitch(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
149   // Defined in ciStreams.hpp
150   inline Bytecode_lookupswitch(const ciBytecodeStream* stream);
151   void verify() const PRODUCT_RETURN;
152 
153   // Attributes
154   int  default_offset() const                    { return get_aligned_Java_u4_at(1 + 0*jintSize); }
155   int  number_of_pairs() const                   { return get_aligned_Java_u4_at(1 + 1*jintSize); }
156   LookupswitchPair pair_at(int i) const          {
157     assert(0 &lt;= i &amp;&amp; i &lt; number_of_pairs(), &quot;pair index out of bounds&quot;);
158     return LookupswitchPair(aligned_addr_at(1 + (1 + i)*2*jintSize));
159   }
160 };
161 
162 class Bytecode_tableswitch: public Bytecode {
163  public:
164   Bytecode_tableswitch(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
165   // Defined in ciStreams.hpp
166   inline Bytecode_tableswitch(const ciBytecodeStream* stream);
167   void verify() const PRODUCT_RETURN;
168 
169   // Attributes
170   int  default_offset() const                    { return get_aligned_Java_u4_at(1 + 0*jintSize); }
171   int  low_key() const                           { return get_aligned_Java_u4_at(1 + 1*jintSize); }
172   int  high_key() const                          { return get_aligned_Java_u4_at(1 + 2*jintSize); }
173   int  dest_offset_at(int i) const;
174   int  length()                                  { return high_key()-low_key()+1; }
175 };
176 
177 // Common code for decoding invokes and field references.
178 
179 class Bytecode_member_ref: public Bytecode {
180  protected:
181   const Method* _method;                          // method containing the bytecode
182 
183   Bytecode_member_ref(const methodHandle&amp; method, int bci)  : Bytecode(method(), method()-&gt;bcp_from(bci)), _method(method()) {}
184 
185   const Method* method() const                 { return _method; }
186   ConstantPool* constants() const              { return _method-&gt;constants(); }
187   ConstantPoolCache* cpcache() const           { return _method-&gt;constants()-&gt;cache(); }
188   ConstantPoolCacheEntry* cpcache_entry() const;
189 
190  public:
191   int          index() const;                    // cache index (loaded from instruction)
192   int          pool_index() const;               // constant pool index
193   Symbol*      klass() const;                    // returns the klass of the method or field
194   Symbol*      name() const;                     // returns the name of the method or field
195   Symbol*      signature() const;                // returns the signature of the method or field
196 
197   BasicType    result_type() const;              // returns the result type of the getfield or invoke
198 };
199 
200 // Abstraction for invoke_{virtual, static, interface, special, dynamic, handle}
201 
202 class Bytecode_invoke: public Bytecode_member_ref {
203  protected:
204   // Constructor that skips verification
205   Bytecode_invoke(const methodHandle&amp; method, int bci, bool unused)  : Bytecode_member_ref(method, bci) {}
206 
207  public:
208   Bytecode_invoke(const methodHandle&amp; method, int bci)  : Bytecode_member_ref(method, bci) { verify(); }
209   void verify() const;
210 
211   // Attributes
212   methodHandle static_target(TRAPS);             // &quot;specified&quot; method   (from constant pool)
213   Handle       appendix(TRAPS);                  // if CPCE::has_appendix (from constant pool)
214 
215   // Testers
216   bool is_invokeinterface() const                { return invoke_code() == Bytecodes::_invokeinterface; }
217   bool is_invokevirtual() const                  { return invoke_code() == Bytecodes::_invokevirtual; }
218   bool is_invokestatic() const                   { return invoke_code() == Bytecodes::_invokestatic; }
219   bool is_invokespecial() const                  { return invoke_code() == Bytecodes::_invokespecial; }
220   bool is_invokedynamic() const                  { return invoke_code() == Bytecodes::_invokedynamic; }
221   bool is_invokehandle() const                   { return invoke_code() == Bytecodes::_invokehandle; }
222 
223   bool has_receiver() const                      { return !is_invokestatic() &amp;&amp; !is_invokedynamic(); }
224 
225   bool is_valid() const                          { return is_invokeinterface() ||
226                                                           is_invokevirtual()   ||
227                                                           is_invokestatic()    ||
228                                                           is_invokespecial()   ||
229                                                           is_invokedynamic()   ||
230                                                           is_invokehandle(); }
231 
232   bool has_appendix();
233 
234   int size_of_parameters() const;
235 
236  private:
237   // Helper to skip verification.   Used is_valid() to check if the result is really an invoke
238   inline friend Bytecode_invoke Bytecode_invoke_check(const methodHandle&amp; method, int bci);
239 };
240 
241 inline Bytecode_invoke Bytecode_invoke_check(const methodHandle&amp; method, int bci) {
242   return Bytecode_invoke(method, bci, false);
243 }
244 
245 
246 // Abstraction for all field accesses (put/get field/static)
247 class Bytecode_field: public Bytecode_member_ref {
248  public:
249   Bytecode_field(const methodHandle&amp; method, int bci)  : Bytecode_member_ref(method, bci) { verify(); }
250 
251   // Testers
252   bool is_getfield() const                       { return java_code() == Bytecodes::_getfield; }
253   bool is_putfield() const                       { return java_code() == Bytecodes::_putfield; }
254   bool is_getstatic() const                      { return java_code() == Bytecodes::_getstatic; }
255   bool is_putstatic() const                      { return java_code() == Bytecodes::_putstatic; }
256 
257   bool is_getter() const                         { return is_getfield()  || is_getstatic(); }
258   bool is_static() const                         { return is_getstatic() || is_putstatic(); }
259 
260   bool is_valid() const                          { return is_getfield()   ||
261                                                           is_putfield()   ||
262                                                           is_getstatic()  ||
263                                                           is_putstatic(); }
264   void verify() const;
265 };
266 
267 // Abstraction for checkcast
268 class Bytecode_checkcast: public Bytecode {
269  public:
270   Bytecode_checkcast(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
271   void verify() const { assert(Bytecodes::java_code(code()) == Bytecodes::_checkcast, &quot;check checkcast&quot;); }
272 
273   // Returns index
274   long index() const   { return get_index_u2(Bytecodes::_checkcast); };
275 };
276 
277 // Abstraction for instanceof
278 class Bytecode_instanceof: public Bytecode {
279  public:
280   Bytecode_instanceof(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
281   void verify() const { assert(code() == Bytecodes::_instanceof, &quot;check instanceof&quot;); }
282 
283   // Returns index
284   long index() const   { return get_index_u2(Bytecodes::_instanceof); };
285 };
286 
287 class Bytecode_new: public Bytecode {
288  public:
289   Bytecode_new(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
290   void verify() const { assert(java_code() == Bytecodes::_new, &quot;check new&quot;); }
291 
292   // Returns index
293   long index() const   { return get_index_u2(Bytecodes::_new); };
294 };
295 
296 class Bytecode_multianewarray: public Bytecode {
297  public:
298   Bytecode_multianewarray(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
299   void verify() const { assert(java_code() == Bytecodes::_multianewarray, &quot;check new&quot;); }
300 
301   // Returns index
302   long index() const   { return get_index_u2(Bytecodes::_multianewarray); };
303 };
304 
305 class Bytecode_anewarray: public Bytecode {
306  public:
307   Bytecode_anewarray(Method* method, address bcp): Bytecode(method, bcp) { verify(); }
308   void verify() const { assert(java_code() == Bytecodes::_anewarray, &quot;check anewarray&quot;); }
309 
310   // Returns index
311   long index() const   { return get_index_u2(Bytecodes::_anewarray); };
312 };
313 
314 // Abstraction for ldc, ldc_w and ldc2_w
315 class Bytecode_loadconstant: public Bytecode {
316  private:
317   const Method* _method;
318 
319   int raw_index() const;
320 
321  public:
322   Bytecode_loadconstant(const methodHandle&amp; method, int bci): Bytecode(method(), method-&gt;bcp_from(bci)), _method(method()) { verify(); }
323 
324   void verify() const {
325     assert(_method != NULL, &quot;must supply method&quot;);
326     Bytecodes::Code stdc = Bytecodes::java_code(code());
327     assert(stdc == Bytecodes::_ldc ||
328            stdc == Bytecodes::_ldc_w ||
329            stdc == Bytecodes::_ldc2_w, &quot;load constant&quot;);
330   }
331 
332   // Only non-standard bytecodes (fast_aldc) have reference cache indexes.
333   bool has_cache_index() const { return code() &gt;= Bytecodes::number_of_java_codes; }
334 
335   int pool_index() const;               // index into constant pool
336   int cache_index() const {             // index into reference cache (or -1 if none)
337     return has_cache_index() ? raw_index() : -1;
338   }
339 
340   BasicType result_type() const;        // returns the result type of the ldc
341 
342   oop resolve_constant(TRAPS) const;
343 };
344 
345 #endif // SHARE_INTERPRETER_BYTECODE_HPP
    </pre>
  </body>
</html>
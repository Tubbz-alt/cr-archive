<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/templateInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/templateInterpreter.hpp&quot;
 30 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
 31 #include &quot;interpreter/templateTable.hpp&quot;
<a name="2" id="anc2"></a>
 32 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
 33 #include &quot;runtime/timerTrace.hpp&quot;
<a name="4" id="anc4"></a>
 34 
 35 #ifndef CC_INTERP
 36 
 37 # define __ _masm-&gt;
 38 
 39 void TemplateInterpreter::initialize() {
 40   if (_code != NULL) return;
 41   // assertions
 42   assert((int)Bytecodes::number_of_codes &lt;= (int)DispatchTable::length,
 43          &quot;dispatch table too small&quot;);
 44 
 45   AbstractInterpreter::initialize();
 46 
 47   TemplateTable::initialize();
 48 
 49   // generate interpreter
 50   { ResourceMark rm;
 51     TraceTime timer(&quot;Interpreter generation&quot;, TRACETIME_LOG(Info, startuptime));
 52     int code_size = InterpreterCodeSize;
 53     NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space
 54     _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,
 55                           &quot;Interpreter&quot;);
 56     TemplateInterpreterGenerator g(_code);
 57     // Free the unused memory not occupied by the interpreter and the stubs
 58     _code-&gt;deallocate_unused_tail();
 59   }
 60 
 61   if (PrintInterpreter) {
 62     ResourceMark rm;
 63     print();
 64   }
 65 
 66   // initialize dispatch table
 67   _active_table = _normal_table;
 68 }
 69 
 70 //------------------------------------------------------------------------------------------------------------------------
 71 // Implementation of EntryPoint
 72 
 73 EntryPoint::EntryPoint() {
 74   assert(number_of_states == 10, &quot;check the code below&quot;);
 75   _entry[btos] = NULL;
 76   _entry[ztos] = NULL;
 77   _entry[ctos] = NULL;
 78   _entry[stos] = NULL;
 79   _entry[atos] = NULL;
 80   _entry[itos] = NULL;
 81   _entry[ltos] = NULL;
 82   _entry[ftos] = NULL;
 83   _entry[dtos] = NULL;
 84   _entry[vtos] = NULL;
 85 }
 86 
 87 
 88 EntryPoint::EntryPoint(address bentry, address zentry, address centry, address sentry, address aentry, address ientry, address lentry, address fentry, address dentry, address ventry) {
 89   assert(number_of_states == 10, &quot;check the code below&quot;);
 90   _entry[btos] = bentry;
 91   _entry[ztos] = zentry;
 92   _entry[ctos] = centry;
 93   _entry[stos] = sentry;
 94   _entry[atos] = aentry;
 95   _entry[itos] = ientry;
 96   _entry[ltos] = lentry;
 97   _entry[ftos] = fentry;
 98   _entry[dtos] = dentry;
 99   _entry[vtos] = ventry;
100 }
101 
102 
103 void EntryPoint::set_entry(TosState state, address entry) {
104   assert(0 &lt;= state &amp;&amp; state &lt; number_of_states, &quot;state out of bounds&quot;);
105   _entry[state] = entry;
106 }
107 
108 
109 address EntryPoint::entry(TosState state) const {
110   assert(0 &lt;= state &amp;&amp; state &lt; number_of_states, &quot;state out of bounds&quot;);
111   return _entry[state];
112 }
113 
114 
115 void EntryPoint::print() {
116   tty-&gt;print(&quot;[&quot;);
117   for (int i = 0; i &lt; number_of_states; i++) {
118     if (i &gt; 0) tty-&gt;print(&quot;, &quot;);
119     tty-&gt;print(INTPTR_FORMAT, p2i(_entry[i]));
120   }
121   tty-&gt;print(&quot;]&quot;);
122 }
123 
124 
125 bool EntryPoint::operator == (const EntryPoint&amp; y) {
126   int i = number_of_states;
127   while (i-- &gt; 0) {
128     if (_entry[i] != y._entry[i]) return false;
129   }
130   return true;
131 }
132 
133 
134 //------------------------------------------------------------------------------------------------------------------------
135 // Implementation of DispatchTable
136 
137 EntryPoint DispatchTable::entry(int i) const {
138   assert(0 &lt;= i &amp;&amp; i &lt; length, &quot;index out of bounds&quot;);
139   return
140     EntryPoint(
141       _table[btos][i],
142       _table[ztos][i],
143       _table[ctos][i],
144       _table[stos][i],
145       _table[atos][i],
146       _table[itos][i],
147       _table[ltos][i],
148       _table[ftos][i],
149       _table[dtos][i],
150       _table[vtos][i]
151     );
152 }
153 
154 
155 void DispatchTable::set_entry(int i, EntryPoint&amp; entry) {
156   assert(0 &lt;= i &amp;&amp; i &lt; length, &quot;index out of bounds&quot;);
157   assert(number_of_states == 10, &quot;check the code below&quot;);
158   _table[btos][i] = entry.entry(btos);
159   _table[ztos][i] = entry.entry(ztos);
160   _table[ctos][i] = entry.entry(ctos);
161   _table[stos][i] = entry.entry(stos);
162   _table[atos][i] = entry.entry(atos);
163   _table[itos][i] = entry.entry(itos);
164   _table[ltos][i] = entry.entry(ltos);
165   _table[ftos][i] = entry.entry(ftos);
166   _table[dtos][i] = entry.entry(dtos);
167   _table[vtos][i] = entry.entry(vtos);
168 }
169 
170 
171 bool DispatchTable::operator == (DispatchTable&amp; y) {
172   int i = length;
173   while (i-- &gt; 0) {
174     EntryPoint t = y.entry(i); // for compiler compatibility (BugId 4150096)
175     if (!(entry(i) == t)) return false;
176   }
177   return true;
178 }
179 
180 address    TemplateInterpreter::_remove_activation_entry                    = NULL;
181 address    TemplateInterpreter::_remove_activation_preserving_args_entry    = NULL;
182 
183 
184 address    TemplateInterpreter::_throw_ArrayIndexOutOfBoundsException_entry = NULL;
185 address    TemplateInterpreter::_throw_ArrayStoreException_entry            = NULL;
186 address    TemplateInterpreter::_throw_ArithmeticException_entry            = NULL;
187 address    TemplateInterpreter::_throw_ClassCastException_entry             = NULL;
188 address    TemplateInterpreter::_throw_NullPointerException_entry           = NULL;
189 address    TemplateInterpreter::_throw_StackOverflowError_entry             = NULL;
190 address    TemplateInterpreter::_throw_exception_entry                      = NULL;
191 
192 #ifndef PRODUCT
193 EntryPoint TemplateInterpreter::_trace_code;
194 #endif // !PRODUCT
195 EntryPoint TemplateInterpreter::_return_entry[TemplateInterpreter::number_of_return_entries];
196 EntryPoint TemplateInterpreter::_earlyret_entry;
197 EntryPoint TemplateInterpreter::_deopt_entry [TemplateInterpreter::number_of_deopt_entries ];
198 address    TemplateInterpreter::_deopt_reexecute_return_entry;
199 EntryPoint TemplateInterpreter::_safept_entry;
200 
201 address TemplateInterpreter::_invoke_return_entry[TemplateInterpreter::number_of_return_addrs];
202 address TemplateInterpreter::_invokeinterface_return_entry[TemplateInterpreter::number_of_return_addrs];
203 address TemplateInterpreter::_invokedynamic_return_entry[TemplateInterpreter::number_of_return_addrs];
204 
205 DispatchTable TemplateInterpreter::_active_table;
206 DispatchTable TemplateInterpreter::_normal_table;
207 DispatchTable TemplateInterpreter::_safept_table;
208 address    TemplateInterpreter::_wentry_point[DispatchTable::length];
209 
210 
211 //------------------------------------------------------------------------------------------------------------------------
212 // Entry points
213 
214 /**
215  * Returns the return entry table for the given invoke bytecode.
216  */
217 address* TemplateInterpreter::invoke_return_entry_table_for(Bytecodes::Code code) {
218   switch (code) {
219   case Bytecodes::_invokestatic:
220   case Bytecodes::_invokespecial:
221   case Bytecodes::_invokevirtual:
222   case Bytecodes::_invokehandle:
223     return Interpreter::invoke_return_entry_table();
224   case Bytecodes::_invokeinterface:
225     return Interpreter::invokeinterface_return_entry_table();
226   case Bytecodes::_invokedynamic:
227     return Interpreter::invokedynamic_return_entry_table();
228   default:
229     fatal(&quot;invalid bytecode: %s&quot;, Bytecodes::name(code));
230     return NULL;
231   }
232 }
233 
234 /**
235  * Returns the return entry address for the given top-of-stack state and bytecode.
236  */
237 address TemplateInterpreter::return_entry(TosState state, int length, Bytecodes::Code code) {
238   guarantee(0 &lt;= length &amp;&amp; length &lt; Interpreter::number_of_return_entries, &quot;illegal length&quot;);
239   const int index = TosState_as_index(state);
240   switch (code) {
241   case Bytecodes::_invokestatic:
242   case Bytecodes::_invokespecial:
243   case Bytecodes::_invokevirtual:
244   case Bytecodes::_invokehandle:
245     return _invoke_return_entry[index];
246   case Bytecodes::_invokeinterface:
247     return _invokeinterface_return_entry[index];
248   case Bytecodes::_invokedynamic:
249     return _invokedynamic_return_entry[index];
250   default:
251     assert(!Bytecodes::is_invoke(code), &quot;invoke instructions should be handled separately: %s&quot;, Bytecodes::name(code));
252     address entry = _return_entry[length].entry(state);
253     vmassert(entry != NULL, &quot;unsupported return entry requested, length=%d state=%d&quot;, length, index);
254     return entry;
255   }
256 }
257 
258 
259 address TemplateInterpreter::deopt_entry(TosState state, int length) {
260   guarantee(0 &lt;= length &amp;&amp; length &lt; Interpreter::number_of_deopt_entries, &quot;illegal length&quot;);
261   address entry = _deopt_entry[length].entry(state);
262   vmassert(entry != NULL, &quot;unsupported deopt entry requested, length=%d state=%d&quot;, length, TosState_as_index(state));
263   return entry;
264 }
265 
266 //------------------------------------------------------------------------------------------------------------------------
267 // Suport for invokes
268 
269 int TemplateInterpreter::TosState_as_index(TosState state) {
270   assert( state &lt; number_of_states , &quot;Invalid state in TosState_as_index&quot;);
271   assert(0 &lt;= (int)state &amp;&amp; (int)state &lt; TemplateInterpreter::number_of_return_addrs, &quot;index out of bounds&quot;);
272   return (int)state;
273 }
274 
275 
276 //------------------------------------------------------------------------------------------------------------------------
<a name="5" id="anc5"></a><span class="line-modified">277 // Safepoint suppport</span>
278 
279 static inline void copy_table(address* from, address* to, int size) {
<a name="6" id="anc6"></a><span class="line-modified">280   // Copy non-overlapping tables. The copy has to occur word wise for MT safety.</span>
<span class="line-modified">281   while (size-- &gt; 0) *to++ = *from++;</span>






282 }
283 
284 void TemplateInterpreter::notice_safepoints() {
285   if (!_notice_safepoints) {
<a name="7" id="anc7"></a>
286     // switch to safepoint dispatch table
287     _notice_safepoints = true;
288     copy_table((address*)&amp;_safept_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));
<a name="8" id="anc8"></a>


289   }
290 }
291 
292 // switch from the dispatch table which notices safepoints back to the
293 // normal dispatch table.  So that we can notice single stepping points,
294 // keep the safepoint dispatch table if we are single stepping in JVMTI.
295 // Note that the should_post_single_step test is exactly as fast as the
296 // JvmtiExport::_enabled test and covers both cases.
297 void TemplateInterpreter::ignore_safepoints() {
298   if (_notice_safepoints) {
299     if (!JvmtiExport::should_post_single_step()) {
<a name="9" id="anc9"></a>
300       // switch to normal dispatch table
301       _notice_safepoints = false;
302       copy_table((address*)&amp;_normal_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));
<a name="10" id="anc10"></a>


303     }
<a name="11" id="anc11"></a>


304   }
305 }
306 
307 //------------------------------------------------------------------------------------------------------------------------
308 // Deoptimization support
309 
310 // If deoptimization happens, this function returns the point of next bytecode to continue execution
311 address TemplateInterpreter::deopt_continue_after_entry(Method* method, address bcp, int callee_parameters, bool is_top_frame) {
312   return AbstractInterpreter::deopt_continue_after_entry(method, bcp, callee_parameters, is_top_frame);
313 }
314 
315 // If deoptimization happens, this function returns the point where the interpreter reexecutes
316 // the bytecode.
317 // Note: Bytecodes::_athrow (C1 only) and Bytecodes::_return are the special cases
318 //       that do not return &quot;Interpreter::deopt_entry(vtos, 0)&quot;
319 address TemplateInterpreter::deopt_reexecute_entry(Method* method, address bcp) {
320   assert(method-&gt;contains(bcp), &quot;just checkin&#39;&quot;);
321   Bytecodes::Code code   = Bytecodes::code_at(method, bcp);
322   if (code == Bytecodes::_return_register_finalizer) {
323     // This is used for deopt during registration of finalizers
324     // during Object.&lt;init&gt;.  We simply need to resume execution at
325     // the standard return vtos bytecode to pop the frame normally.
326     // reexecuting the real bytecode would cause double registration
327     // of the finalizable object.
328     return Interpreter::deopt_reexecute_return_entry();
329   } else {
330     return AbstractInterpreter::deopt_reexecute_entry(method, bcp);
331   }
332 }
333 
334 // If deoptimization happens, the interpreter should reexecute this bytecode.
335 // This function mainly helps the compilers to set up the reexecute bit.
336 bool TemplateInterpreter::bytecode_should_reexecute(Bytecodes::Code code) {
337   if (code == Bytecodes::_return) {
338     //Yes, we consider Bytecodes::_return as a special case of reexecution
339     return true;
340   } else {
341     return AbstractInterpreter::bytecode_should_reexecute(code);
342   }
343 }
344 
345 InterpreterCodelet* TemplateInterpreter::codelet_containing(address pc) {
346   return (InterpreterCodelet*)_code-&gt;stub_containing(pc);
347 }
348 
349 #endif // !CC_INTERP
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/bytecodeInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeStream.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bytecodeInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #include &quot;interpreter/bytecodeInterpreterProfiling.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/methodCounters.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,43 ***</span>
          // The initial monitor is ours for the taking.
          // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
          BasicObjectLock* mon = &amp;istate-&gt;monitor_base()[-1];
          mon-&gt;set_obj(rcvr);
          bool success = false;
<span class="line-modified">!         uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
<span class="line-modified">!         markOop mark = rcvr-&gt;mark();</span>
<span class="line-modified">!         intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
          // Implies UseBiasedLocking.
<span class="line-modified">!         if (mark-&gt;has_bias_pattern()) {</span>
            uintptr_t thread_ident;
            uintptr_t anticipated_bias_locking_value;
            thread_ident = (uintptr_t)istate-&gt;thread();
            anticipated_bias_locking_value =
<span class="line-modified">!             (((uintptr_t)rcvr-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="line-modified">!             ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
  
            if (anticipated_bias_locking_value == 0) {
              // Already biased towards this thread, nothing to do.
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::biased_lock_entry_count_addr())++;
              }
              success = true;
<span class="line-modified">!           } else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
              // Try to revoke bias.
<span class="line-modified">!             markOop header = rcvr-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!             if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!               header = header-&gt;copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(header, mark) == mark) {
                if (PrintBiasedLockingStatistics)
                  (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) != 0) {
              // Try to rebias.
<span class="line-modified">!             markOop new_header = (markOop) ( (intptr_t) rcvr-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="line-modified">!             if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!               new_header = new_header-&gt;copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(new_header, mark) == mark) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
<span class="line-new-header">--- 664,43 ---</span>
          // The initial monitor is ours for the taking.
          // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
          BasicObjectLock* mon = &amp;istate-&gt;monitor_base()[-1];
          mon-&gt;set_obj(rcvr);
          bool success = false;
<span class="line-modified">!         uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
<span class="line-modified">!         markWord mark = rcvr-&gt;mark();</span>
<span class="line-modified">!         intptr_t hash = (intptr_t) markWord::no_hash;</span>
          // Implies UseBiasedLocking.
<span class="line-modified">!         if (mark.has_bias_pattern()) {</span>
            uintptr_t thread_ident;
            uintptr_t anticipated_bias_locking_value;
            thread_ident = (uintptr_t)istate-&gt;thread();
            anticipated_bias_locking_value =
<span class="line-modified">!             ((rcvr-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="line-modified">!             ~(markWord::age_mask_in_place);</span>
  
            if (anticipated_bias_locking_value == 0) {
              // Already biased towards this thread, nothing to do.
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::biased_lock_entry_count_addr())++;
              }
              success = true;
<span class="line-modified">!           } else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
              // Try to revoke bias.
<span class="line-modified">!             markWord header = rcvr-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!             if (hash != markWord::no_hash) {</span>
<span class="line-modified">!               header = header.copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(header, mark) == mark) {
                if (PrintBiasedLockingStatistics)
                  (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) != 0) {
              // Try to rebias.
<span class="line-modified">!             markWord new_header( (intptr_t) rcvr-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="line-modified">!             if (hash != markWord::no_hash) {</span>
<span class="line-modified">!               new_header = new_header.copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(new_header, mark) == mark) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,19 ***</span>
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
              success = true;
            } else {
              // Try to bias towards thread in case object is anonymously biased.
<span class="line-modified">!             markOop header = (markOop) ((uintptr_t) mark &amp;</span>
<span class="line-modified">!                                         ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="line-modified">!                                          (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));</span>
<span class="line-modified">!             if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!               header = header-&gt;copy_set_hash(hash);</span>
              }
<span class="line-modified">!             markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
              // Debugging hint.
<span class="line-modified">!             DEBUG_ONLY(mon-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
              if (rcvr-&gt;cas_set_mark(new_header, header) == header) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
              } else {
<span class="line-new-header">--- 708,19 ---</span>
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
              success = true;
            } else {
              // Try to bias towards thread in case object is anonymously biased.
<span class="line-modified">!             markWord header(mark.value() &amp;</span>
<span class="line-modified">!                             (markWord::biased_lock_mask_in_place |</span>
<span class="line-modified">!                              markWord::age_mask_in_place | epoch_mask_in_place));</span>
<span class="line-modified">!             if (hash != markWord::no_hash) {</span>
<span class="line-modified">!               header = header.copy_set_hash(hash);</span>
              }
<span class="line-modified">!             markWord new_header(header.value() | thread_ident);</span>
              // Debugging hint.
<span class="line-modified">!             DEBUG_ONLY(mon-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
              if (rcvr-&gt;cas_set_mark(new_header, header) == header) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
              } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 729,17 ***</span>
            }
          }
  
          // Traditional lightweight locking.
          if (!success) {
<span class="line-modified">!           markOop displaced = rcvr-&gt;mark()-&gt;set_unlocked();</span>
            mon-&gt;lock()-&gt;set_displaced_header(displaced);
            bool call_vm = UseHeavyMonitors;
<span class="line-modified">!           if (call_vm || rcvr-&gt;cas_set_mark((markOop)mon, displaced) != displaced) {</span>
              // Is it simple recursive case?
<span class="line-modified">!             if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="line-modified">!               mon-&gt;lock()-&gt;set_displaced_header(NULL);</span>
              } else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
            }
          }
<span class="line-new-header">--- 730,17 ---</span>
            }
          }
  
          // Traditional lightweight locking.
          if (!success) {
<span class="line-modified">!           markWord displaced = rcvr-&gt;mark().set_unlocked();</span>
            mon-&gt;lock()-&gt;set_displaced_header(displaced);
            bool call_vm = UseHeavyMonitors;
<span class="line-modified">!           if (call_vm || rcvr-&gt;cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {</span>
              // Is it simple recursive case?
<span class="line-modified">!             if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="line-modified">!               mon-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
              } else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
            }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,45 ***</span>
        // find a free monitor
        BasicObjectLock* entry = (BasicObjectLock*) istate-&gt;stack_base();
        assert(entry-&gt;obj() == NULL, &quot;Frame manager didn&#39;t allocate the monitor&quot;);
        entry-&gt;set_obj(lockee);
        bool success = false;
<span class="line-modified">!       uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
  
<span class="line-modified">!       markOop mark = lockee-&gt;mark();</span>
<span class="line-modified">!       intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
        // implies UseBiasedLocking
<span class="line-modified">!       if (mark-&gt;has_bias_pattern()) {</span>
          uintptr_t thread_ident;
          uintptr_t anticipated_bias_locking_value;
          thread_ident = (uintptr_t)istate-&gt;thread();
          anticipated_bias_locking_value =
<span class="line-modified">!           (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="line-modified">!           ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
  
          if  (anticipated_bias_locking_value == 0) {
            // already biased towards this thread, nothing to do
            if (PrintBiasedLockingStatistics) {
              (* BiasedLocking::biased_lock_entry_count_addr())++;
            }
            success = true;
<span class="line-modified">!         } else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
            // try revoke bias
<span class="line-modified">!           markOop header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!           if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!             header = header-&gt;copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            }
          } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
            // try rebias
<span class="line-modified">!           markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="line-modified">!           if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!                 new_header = new_header-&gt;copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::rebiased_lock_entry_count_addr())++;
              }
<span class="line-new-header">--- 849,45 ---</span>
        // find a free monitor
        BasicObjectLock* entry = (BasicObjectLock*) istate-&gt;stack_base();
        assert(entry-&gt;obj() == NULL, &quot;Frame manager didn&#39;t allocate the monitor&quot;);
        entry-&gt;set_obj(lockee);
        bool success = false;
<span class="line-modified">!       uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
  
<span class="line-modified">!       markWord mark = lockee-&gt;mark();</span>
<span class="line-modified">!       intptr_t hash = (intptr_t) markWord::no_hash;</span>
        // implies UseBiasedLocking
<span class="line-modified">!       if (mark.has_bias_pattern()) {</span>
          uintptr_t thread_ident;
          uintptr_t anticipated_bias_locking_value;
          thread_ident = (uintptr_t)istate-&gt;thread();
          anticipated_bias_locking_value =
<span class="line-modified">!           ((lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="line-modified">!           ~(markWord::age_mask_in_place);</span>
  
          if  (anticipated_bias_locking_value == 0) {
            // already biased towards this thread, nothing to do
            if (PrintBiasedLockingStatistics) {
              (* BiasedLocking::biased_lock_entry_count_addr())++;
            }
            success = true;
<span class="line-modified">!         } else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
            // try revoke bias
<span class="line-modified">!           markWord header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!           if (hash != markWord::no_hash) {</span>
<span class="line-modified">!             header = header.copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            }
          } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
            // try rebias
<span class="line-modified">!           markWord new_header( (intptr_t) lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="line-modified">!           if (hash != markWord::no_hash) {</span>
<span class="line-modified">!             new_header = new_header.copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::rebiased_lock_entry_count_addr())++;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,18 ***</span>
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
            success = true;
          } else {
            // try to bias towards thread in case object is anonymously biased
<span class="line-modified">!           markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="line-modified">!                                                           (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));</span>
<span class="line-modified">!           if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!             header = header-&gt;copy_set_hash(hash);</span>
            }
<span class="line-modified">!           markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
            // debugging hint
<span class="line-modified">!           DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
            if (lockee-&gt;cas_set_mark(new_header, header) == header) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
              }
            } else {
<span class="line-new-header">--- 895,18 ---</span>
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
            success = true;
          } else {
            // try to bias towards thread in case object is anonymously biased
<span class="line-modified">!           markWord header(mark.value() &amp; (markWord::biased_lock_mask_in_place |</span>
<span class="line-modified">!                                           markWord::age_mask_in_place | epoch_mask_in_place));</span>
<span class="line-modified">!           if (hash != markWord::no_hash) {</span>
<span class="line-modified">!             header = header.copy_set_hash(hash);</span>
            }
<span class="line-modified">!           markWord new_header(header.value() | thread_ident);</span>
            // debugging hint
<span class="line-modified">!           DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
            if (lockee-&gt;cas_set_mark(new_header, header) == header) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
              }
            } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,17 ***</span>
          }
        }
  
        // traditional lightweight locking
        if (!success) {
<span class="line-modified">!         markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span>
          entry-&gt;lock()-&gt;set_displaced_header(displaced);
          bool call_vm = UseHeavyMonitors;
<span class="line-modified">!         if (call_vm || lockee-&gt;cas_set_mark((markOop)entry, displaced) != displaced) {</span>
            // Is it simple recursive case?
<span class="line-modified">!           if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="line-modified">!             entry-&gt;lock()-&gt;set_displaced_header(NULL);</span>
            } else {
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
          }
        }
<span class="line-new-header">--- 916,17 ---</span>
          }
        }
  
        // traditional lightweight locking
        if (!success) {
<span class="line-modified">!         markWord displaced = lockee-&gt;mark().set_unlocked();</span>
          entry-&gt;lock()-&gt;set_displaced_header(displaced);
          bool call_vm = UseHeavyMonitors;
<span class="line-modified">!         if (call_vm || lockee-&gt;cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {</span>
            // Is it simple recursive case?
<span class="line-modified">!           if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="line-modified">!             entry-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
            } else {
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1788,46 ***</span>
            most_recent++;
          }
          if (entry != NULL) {
            entry-&gt;set_obj(lockee);
            int success = false;
<span class="line-modified">!           uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
  
<span class="line-modified">!           markOop mark = lockee-&gt;mark();</span>
<span class="line-modified">!           intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
            // implies UseBiasedLocking
<span class="line-modified">!           if (mark-&gt;has_bias_pattern()) {</span>
              uintptr_t thread_ident;
              uintptr_t anticipated_bias_locking_value;
              thread_ident = (uintptr_t)istate-&gt;thread();
              anticipated_bias_locking_value =
<span class="line-modified">!               (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="line-modified">!               ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
  
              if  (anticipated_bias_locking_value == 0) {
                // already biased towards this thread, nothing to do
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::biased_lock_entry_count_addr())++;
                }
                success = true;
              }
<span class="line-modified">!             else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
                // try revoke bias
<span class="line-modified">!               markOop header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!               if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!                 header = header-&gt;copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (*BiasedLocking::revoked_lock_entry_count_addr())++;
                }
              }
              else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
                // try rebias
<span class="line-modified">!               markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="line-modified">!               if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!                 new_header = new_header-&gt;copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
<span class="line-new-header">--- 1789,46 ---</span>
            most_recent++;
          }
          if (entry != NULL) {
            entry-&gt;set_obj(lockee);
            int success = false;
<span class="line-modified">!           uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
  
<span class="line-modified">!           markWord mark = lockee-&gt;mark();</span>
<span class="line-modified">!           intptr_t hash = (intptr_t) markWord::no_hash;</span>
            // implies UseBiasedLocking
<span class="line-modified">!           if (mark.has_bias_pattern()) {</span>
              uintptr_t thread_ident;
              uintptr_t anticipated_bias_locking_value;
              thread_ident = (uintptr_t)istate-&gt;thread();
              anticipated_bias_locking_value =
<span class="line-modified">!               ((lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="line-modified">!               ~(markWord::age_mask_in_place);</span>
  
              if  (anticipated_bias_locking_value == 0) {
                // already biased towards this thread, nothing to do
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::biased_lock_entry_count_addr())++;
                }
                success = true;
              }
<span class="line-modified">!             else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
                // try revoke bias
<span class="line-modified">!               markWord header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">!               if (hash != markWord::no_hash) {</span>
<span class="line-modified">!                 header = header.copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (*BiasedLocking::revoked_lock_entry_count_addr())++;
                }
              }
              else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
                // try rebias
<span class="line-modified">!               markWord new_header( (intptr_t) lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="line-modified">!               if (hash != markWord::no_hash) {</span>
<span class="line-modified">!                 new_header = new_header.copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1836,19 ***</span>
                }
                success = true;
              }
              else {
                // try to bias towards thread in case object is anonymously biased
<span class="line-modified">!               markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="line-modified">!                                                               (uintptr_t)markOopDesc::age_mask_in_place |</span>
<span class="line-modified">!                                                               epoch_mask_in_place));</span>
<span class="line-modified">!               if (hash != markOopDesc::no_hash) {</span>
<span class="line-modified">!                 header = header-&gt;copy_set_hash(hash);</span>
                }
<span class="line-modified">!               markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
                // debugging hint
<span class="line-modified">!               DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
                if (lockee-&gt;cas_set_mark(new_header, header) == header) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
                else {
<span class="line-new-header">--- 1837,19 ---</span>
                }
                success = true;
              }
              else {
                // try to bias towards thread in case object is anonymously biased
<span class="line-modified">!               markWord header(mark.value() &amp; (markWord::biased_lock_mask_in_place |</span>
<span class="line-modified">!                                               markWord::age_mask_in_place |</span>
<span class="line-modified">!                                               epoch_mask_in_place));</span>
<span class="line-modified">!               if (hash != markWord::no_hash) {</span>
<span class="line-modified">!                 header = header.copy_set_hash(hash);</span>
                }
<span class="line-modified">!               markWord new_header(header.value() | thread_ident);</span>
                // debugging hint
<span class="line-modified">!               DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
                if (lockee-&gt;cas_set_mark(new_header, header) == header) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
                else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1858,17 ***</span>
              }
            }
  
            // traditional lightweight locking
            if (!success) {
<span class="line-modified">!             markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span>
              entry-&gt;lock()-&gt;set_displaced_header(displaced);
              bool call_vm = UseHeavyMonitors;
<span class="line-modified">!             if (call_vm || lockee-&gt;cas_set_mark((markOop)entry, displaced) != displaced) {</span>
                // Is it simple recursive case?
<span class="line-modified">!               if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="line-modified">!                 entry-&gt;lock()-&gt;set_displaced_header(NULL);</span>
                } else {
                  CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
                }
              }
            }
<span class="line-new-header">--- 1859,17 ---</span>
              }
            }
  
            // traditional lightweight locking
            if (!success) {
<span class="line-modified">!             markWord displaced = lockee-&gt;mark().set_unlocked();</span>
              entry-&gt;lock()-&gt;set_displaced_header(displaced);
              bool call_vm = UseHeavyMonitors;
<span class="line-modified">!             if (call_vm || lockee-&gt;cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {</span>
                // Is it simple recursive case?
<span class="line-modified">!               if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="line-modified">!                 entry-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
                } else {
                  CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
                }
              }
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1887,17 ***</span>
          BasicObjectLock* limit = istate-&gt;monitor_base();
          BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();
          while (most_recent != limit ) {
            if ((most_recent)-&gt;obj() == lockee) {
              BasicLock* lock = most_recent-&gt;lock();
<span class="line-modified">!             markOop header = lock-&gt;displaced_header();</span>
              most_recent-&gt;set_obj(NULL);
<span class="line-modified">!             if (!lockee-&gt;mark()-&gt;has_bias_pattern()) {</span>
                bool call_vm = UseHeavyMonitors;
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!               if (header != NULL || call_vm) {</span>
<span class="line-modified">!                 markOop old_header = markOopDesc::encode(lock);</span>
                  if (call_vm || lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    most_recent-&gt;set_obj(lockee);
                    CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);
                  }
<span class="line-new-header">--- 1888,17 ---</span>
          BasicObjectLock* limit = istate-&gt;monitor_base();
          BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();
          while (most_recent != limit ) {
            if ((most_recent)-&gt;obj() == lockee) {
              BasicLock* lock = most_recent-&gt;lock();
<span class="line-modified">!             markWord header = lock-&gt;displaced_header();</span>
              most_recent-&gt;set_obj(NULL);
<span class="line-modified">!             if (!lockee-&gt;mark().has_bias_pattern()) {</span>
                bool call_vm = UseHeavyMonitors;
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!               if (header.to_pointer() != NULL || call_vm) {</span>
<span class="line-modified">!                 markWord old_header = markWord::encode(lock);</span>
                  if (call_vm || lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    most_recent-&gt;set_obj(lockee);
                    CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2160,30 ***</span>
                // Try allocate in shared eden
              retry:
                HeapWord* compare_to = *Universe::heap()-&gt;top_addr();
                HeapWord* new_top = compare_to + obj_size;
                if (new_top &lt;= *Universe::heap()-&gt;end_addr()) {
<span class="line-modified">!                 if (Atomic::cmpxchg(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) {</span>
                    goto retry;
                  }
                  result = (oop) compare_to;
                }
              }
  #endif
              if (result != NULL) {
                // Initialize object (if nonzero size and need) and then the header
                if (need_zero ) {
<span class="line-modified">!                 HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;</span>
                  obj_size -= sizeof(oopDesc) / oopSize;
                  if (obj_size &gt; 0 ) {
                    memset(to_zero, 0, obj_size * HeapWordSize);
                  }
                }
                if (UseBiasedLocking) {
                  result-&gt;set_mark(ik-&gt;prototype_header());
                } else {
<span class="line-modified">!                 result-&gt;set_mark(markOopDesc::prototype());</span>
                }
                result-&gt;set_klass_gap(0);
                result-&gt;set_klass(ik);
                // Must prevent reordering of stores for object initialization
                // with stores that publish the new object.
<span class="line-new-header">--- 2161,30 ---</span>
                // Try allocate in shared eden
              retry:
                HeapWord* compare_to = *Universe::heap()-&gt;top_addr();
                HeapWord* new_top = compare_to + obj_size;
                if (new_top &lt;= *Universe::heap()-&gt;end_addr()) {
<span class="line-modified">!                 if (Atomic::cmpxchg(Universe::heap()-&gt;top_addr(), compare_to, new_top) != compare_to) {</span>
                    goto retry;
                  }
                  result = (oop) compare_to;
                }
              }
  #endif
              if (result != NULL) {
                // Initialize object (if nonzero size and need) and then the header
                if (need_zero ) {
<span class="line-modified">!                 HeapWord* to_zero = cast_from_oop&lt;HeapWord*&gt;(result) + sizeof(oopDesc) / oopSize;</span>
                  obj_size -= sizeof(oopDesc) / oopSize;
                  if (obj_size &gt; 0 ) {
                    memset(to_zero, 0, obj_size * HeapWordSize);
                  }
                }
                if (UseBiasedLocking) {
                  result-&gt;set_mark(ik-&gt;prototype_header());
                } else {
<span class="line-modified">!                 result-&gt;set_mark(markWord::prototype());</span>
                }
                result-&gt;set_klass_gap(0);
                result-&gt;set_klass(ik);
                // Must prevent reordering of stores for object initialization
                // with stores that publish the new object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2433,11 ***</span>
          if (result == NULL) {
            CALL_VM(InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode),
                    handle_exception);
            result = THREAD-&gt;vm_result();
          }
<span class="line-modified">!         if (oopDesc::equals(result, Universe::the_null_sentinel()))</span>
            result = NULL;
  
          VERIFY_OOP(result);
          SET_STACK_OBJECT(result, 0);
          UPDATE_PC_AND_TOS_AND_CONTINUE(incr, 1);
<span class="line-new-header">--- 2434,11 ---</span>
          if (result == NULL) {
            CALL_VM(InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode),
                    handle_exception);
            result = THREAD-&gt;vm_result();
          }
<span class="line-modified">!         if (result == Universe::the_null_sentinel())</span>
            result = NULL;
  
          VERIFY_OOP(result);
          SET_STACK_OBJECT(result, 0);
          UPDATE_PC_AND_TOS_AND_CONTINUE(incr, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2459,12 ***</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="line-modified">!           ConstantPool* constants = METHOD-&gt;constants();</span>
<span class="line-modified">!           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(constants), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
<span class="line-new-header">--- 2460,12 ---</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="line-modified">!           constantPoolHandle cp(THREAD, METHOD-&gt;constants());</span>
<span class="line-modified">!           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(cp), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2490,12 ***</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="line-modified">!           ConstantPool* constants = METHOD-&gt;constants();</span>
<span class="line-modified">!           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(constants), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
<span class="line-new-header">--- 2491,12 ---</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="line-modified">!           constantPoolHandle cp(THREAD, METHOD-&gt;constants());</span>
<span class="line-modified">!           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(cp), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2868,11 ***</span>
          tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
                       &quot; at bci %d, continuing at %d for thread &quot; INTPTR_FORMAT,
                       METHOD-&gt;print_value_string(),
                       (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
                       (int)continuation_bci, p2i(THREAD));
<span class="line-modified">!         Exceptions::log_exception(except_oop, tempst);</span>
        }
        // for AbortVMOnException flag
        Exceptions::debug_check_abort(except_oop);
  
        // Update profiling data.
<span class="line-new-header">--- 2869,11 ---</span>
          tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
                       &quot; at bci %d, continuing at %d for thread &quot; INTPTR_FORMAT,
                       METHOD-&gt;print_value_string(),
                       (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
                       (int)continuation_bci, p2i(THREAD));
<span class="line-modified">!         Exceptions::log_exception(except_oop, tempst.as_string());</span>
        }
        // for AbortVMOnException flag
        Exceptions::debug_check_abort(except_oop);
  
        // Update profiling data.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2885,11 ***</span>
        tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
               &quot; at bci %d, unwinding for thread &quot; INTPTR_FORMAT,
               METHOD-&gt;print_value_string(),
               (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
               p2i(THREAD));
<span class="line-modified">!       Exceptions::log_exception(except_oop, tempst);</span>
      }
      // for AbortVMOnException flag
      Exceptions::debug_check_abort(except_oop);
  
      // No handler in this activation, unwind and try again
<span class="line-new-header">--- 2886,11 ---</span>
        tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
               &quot; at bci %d, unwinding for thread &quot; INTPTR_FORMAT,
               METHOD-&gt;print_value_string(),
               (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
               p2i(THREAD));
<span class="line-modified">!       Exceptions::log_exception(except_oop, tempst.as_string());</span>
      }
      // for AbortVMOnException flag
      Exceptions::debug_check_abort(except_oop);
  
      // No handler in this activation, unwind and try again
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3032,17 ***</span>
        // Check all the monitors to see they are unlocked. Install exception if found to be locked.
        while (end &lt; base) {
          oop lockee = end-&gt;obj();
          if (lockee != NULL) {
            BasicLock* lock = end-&gt;lock();
<span class="line-modified">!           markOop header = lock-&gt;displaced_header();</span>
            end-&gt;set_obj(NULL);
  
<span class="line-modified">!           if (!lockee-&gt;mark()-&gt;has_bias_pattern()) {</span>
              // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!             if (header != NULL) {</span>
<span class="line-modified">!               markOop old_header = markOopDesc::encode(lock);</span>
                if (lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                  // restore object for the slow case
                  end-&gt;set_obj(lockee);
                  {
                    // Prevent any HandleMarkCleaner from freeing our live handles
<span class="line-new-header">--- 3033,17 ---</span>
        // Check all the monitors to see they are unlocked. Install exception if found to be locked.
        while (end &lt; base) {
          oop lockee = end-&gt;obj();
          if (lockee != NULL) {
            BasicLock* lock = end-&gt;lock();
<span class="line-modified">!           markWord header = lock-&gt;displaced_header();</span>
            end-&gt;set_obj(NULL);
  
<span class="line-modified">!           if (!lockee-&gt;mark().has_bias_pattern()) {</span>
              // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!             if (header.to_pointer() != NULL) {</span>
<span class="line-modified">!               markWord old_header = markWord::encode(lock);</span>
                if (lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                  // restore object for the slow case
                  end-&gt;set_obj(lockee);
                  {
                    // Prevent any HandleMarkCleaner from freeing our live handles
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3107,18 ***</span>
                if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD-&gt;pending_exception());
                THREAD-&gt;clear_pending_exception();
              }
            } else {
              BasicLock* lock = base-&gt;lock();
<span class="line-modified">!             markOop header = lock-&gt;displaced_header();</span>
              base-&gt;set_obj(NULL);
  
<span class="line-modified">!             if (!rcvr-&gt;mark()-&gt;has_bias_pattern()) {</span>
                base-&gt;set_obj(NULL);
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!               if (header != NULL) {</span>
<span class="line-modified">!                 markOop old_header = markOopDesc::encode(lock);</span>
                  if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    base-&gt;set_obj(rcvr);
                    {
                      // Prevent any HandleMarkCleaner from freeing our live handles
<span class="line-new-header">--- 3108,18 ---</span>
                if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD-&gt;pending_exception());
                THREAD-&gt;clear_pending_exception();
              }
            } else {
              BasicLock* lock = base-&gt;lock();
<span class="line-modified">!             markWord header = lock-&gt;displaced_header();</span>
              base-&gt;set_obj(NULL);
  
<span class="line-modified">!             if (!rcvr-&gt;mark().has_bias_pattern()) {</span>
                base-&gt;set_obj(NULL);
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="line-modified">!               if (header.to_pointer() != NULL) {</span>
<span class="line-modified">!                 markWord old_header = markWord::encode(lock);</span>
                  if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    base-&gt;set_obj(rcvr);
                    {
                      // Prevent any HandleMarkCleaner from freeing our live handles
</pre>
<center><a href="bytecode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeStream.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
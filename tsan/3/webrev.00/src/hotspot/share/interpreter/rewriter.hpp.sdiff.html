<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/rewriter.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rewriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/rewriter.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
167     _invokedynamic_references_map.at_put_grow(ref_index, cache_index, -1);
168     return ref_index;
169   }
170 
171   int resolved_references_entry_to_pool_index(int ref_index) {
172     int cp_index = _resolved_references_map.at(ref_index);
173     return cp_index;
174   }
175 
176   // Access the contents of _cp_cache_map to determine CP cache layout.
177   int cp_cache_entry_pool_index(int cache_index) {
178     int cp_index = _cp_cache_map.at(cache_index);
179     return cp_index;
180   }
181 
182   // All the work goes in here:
183   Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS);
184 
185   void compute_index_maps();
186   void make_constant_pool_cache(TRAPS);
<span class="line-modified">187   void scan_method(Method* m, bool reverse, bool* invokespecial_error);</span>
188   void rewrite_Object_init(const methodHandle&amp; m, TRAPS);
189   void rewrite_member_reference(address bcp, int offset, bool reverse);
190   void maybe_rewrite_invokehandle(address opc, int cp_index, int cache_index, bool reverse);
191   void rewrite_invokedynamic(address bcp, int offset, bool reverse);
192   void maybe_rewrite_ldc(address bcp, int offset, bool is_wide, bool reverse);
193   void rewrite_invokespecial(address bcp, int offset, bool reverse, bool* invokespecial_error);
194 
195   void patch_invokedynamic_bytecodes();
196 
197   // Do all the work.
198   void rewrite_bytecodes(TRAPS);
199 
200   // Revert bytecodes in case of an exception.
<span class="line-modified">201   void restore_bytecodes();</span>
202 
203   static methodHandle rewrite_jsrs(const methodHandle&amp; m, TRAPS);
204  public:
205   // Driver routine:
206   static void rewrite(InstanceKlass* klass, TRAPS);
207 };
208 
209 #endif // SHARE_INTERPRETER_REWRITER_HPP
</pre>
</td>
<td>
<hr />
<pre>
167     _invokedynamic_references_map.at_put_grow(ref_index, cache_index, -1);
168     return ref_index;
169   }
170 
171   int resolved_references_entry_to_pool_index(int ref_index) {
172     int cp_index = _resolved_references_map.at(ref_index);
173     return cp_index;
174   }
175 
176   // Access the contents of _cp_cache_map to determine CP cache layout.
177   int cp_cache_entry_pool_index(int cache_index) {
178     int cp_index = _cp_cache_map.at(cache_index);
179     return cp_index;
180   }
181 
182   // All the work goes in here:
183   Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS);
184 
185   void compute_index_maps();
186   void make_constant_pool_cache(TRAPS);
<span class="line-modified">187   void scan_method(Thread* thread, Method* m, bool reverse, bool* invokespecial_error);</span>
188   void rewrite_Object_init(const methodHandle&amp; m, TRAPS);
189   void rewrite_member_reference(address bcp, int offset, bool reverse);
190   void maybe_rewrite_invokehandle(address opc, int cp_index, int cache_index, bool reverse);
191   void rewrite_invokedynamic(address bcp, int offset, bool reverse);
192   void maybe_rewrite_ldc(address bcp, int offset, bool is_wide, bool reverse);
193   void rewrite_invokespecial(address bcp, int offset, bool reverse, bool* invokespecial_error);
194 
195   void patch_invokedynamic_bytecodes();
196 
197   // Do all the work.
198   void rewrite_bytecodes(TRAPS);
199 
200   // Revert bytecodes in case of an exception.
<span class="line-modified">201   void restore_bytecodes(Thread* thread);</span>
202 
203   static methodHandle rewrite_jsrs(const methodHandle&amp; m, TRAPS);
204  public:
205   // Driver routine:
206   static void rewrite(InstanceKlass* klass, TRAPS);
207 };
208 
209 #endif // SHARE_INTERPRETER_REWRITER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="rewriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
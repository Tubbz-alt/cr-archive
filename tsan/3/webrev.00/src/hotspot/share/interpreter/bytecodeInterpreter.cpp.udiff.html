<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/interpreter/bytecodeInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeStream.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bytecodeInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32,10 +32,11 @@</span>
  #include &quot;interpreter/bytecodeInterpreterProfiling.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/methodCounters.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -663,43 +664,43 @@</span>
          // The initial monitor is ours for the taking.
          // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
          BasicObjectLock* mon = &amp;istate-&gt;monitor_base()[-1];
          mon-&gt;set_obj(rcvr);
          bool success = false;
<span class="udiff-line-modified-removed">-         uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
<span class="udiff-line-modified-removed">-         markOop mark = rcvr-&gt;mark();</span>
<span class="udiff-line-modified-removed">-         intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
<span class="udiff-line-modified-added">+         uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
<span class="udiff-line-modified-added">+         markWord mark = rcvr-&gt;mark();</span>
<span class="udiff-line-modified-added">+         intptr_t hash = (intptr_t) markWord::no_hash;</span>
          // Implies UseBiasedLocking.
<span class="udiff-line-modified-removed">-         if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+         if (mark.has_bias_pattern()) {</span>
            uintptr_t thread_ident;
            uintptr_t anticipated_bias_locking_value;
            thread_ident = (uintptr_t)istate-&gt;thread();
            anticipated_bias_locking_value =
<span class="udiff-line-modified-removed">-             (((uintptr_t)rcvr-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="udiff-line-modified-removed">-             ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
<span class="udiff-line-modified-added">+             ((rcvr-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="udiff-line-modified-added">+             ~(markWord::age_mask_in_place);</span>
  
            if (anticipated_bias_locking_value == 0) {
              // Already biased towards this thread, nothing to do.
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::biased_lock_entry_count_addr())++;
              }
              success = true;
<span class="udiff-line-modified-removed">-           } else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
<span class="udiff-line-modified-added">+           } else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
              // Try to revoke bias.
<span class="udiff-line-modified-removed">-             markOop header = rcvr-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-removed">-             if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-               header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+             markWord header = rcvr-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-added">+             if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+               header = header.copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(header, mark) == mark) {
                if (PrintBiasedLockingStatistics)
                  (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) != 0) {
              // Try to rebias.
<span class="udiff-line-modified-removed">-             markOop new_header = (markOop) ( (intptr_t) rcvr-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="udiff-line-modified-removed">-             if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-               new_header = new_header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+             markWord new_header( (intptr_t) rcvr-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="udiff-line-modified-added">+             if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+               new_header = new_header.copy_set_hash(hash);</span>
              }
              if (rcvr-&gt;cas_set_mark(new_header, mark) == mark) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -707,19 +708,19 @@</span>
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
              success = true;
            } else {
              // Try to bias towards thread in case object is anonymously biased.
<span class="udiff-line-modified-removed">-             markOop header = (markOop) ((uintptr_t) mark &amp;</span>
<span class="udiff-line-modified-removed">-                                         ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-removed">-                                          (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));</span>
<span class="udiff-line-modified-removed">-             if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-               header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+             markWord header(mark.value() &amp;</span>
<span class="udiff-line-modified-added">+                             (markWord::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-added">+                              markWord::age_mask_in_place | epoch_mask_in_place));</span>
<span class="udiff-line-modified-added">+             if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+               header = header.copy_set_hash(hash);</span>
              }
<span class="udiff-line-modified-removed">-             markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
<span class="udiff-line-modified-added">+             markWord new_header(header.value() | thread_ident);</span>
              // Debugging hint.
<span class="udiff-line-modified-removed">-             DEBUG_ONLY(mon-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
<span class="udiff-line-modified-added">+             DEBUG_ONLY(mon-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
              if (rcvr-&gt;cas_set_mark(new_header, header) == header) {
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -729,17 +730,17 @@</span>
            }
          }
  
          // Traditional lightweight locking.
          if (!success) {
<span class="udiff-line-modified-removed">-           markOop displaced = rcvr-&gt;mark()-&gt;set_unlocked();</span>
<span class="udiff-line-modified-added">+           markWord displaced = rcvr-&gt;mark().set_unlocked();</span>
            mon-&gt;lock()-&gt;set_displaced_header(displaced);
            bool call_vm = UseHeavyMonitors;
<span class="udiff-line-modified-removed">-           if (call_vm || rcvr-&gt;cas_set_mark((markOop)mon, displaced) != displaced) {</span>
<span class="udiff-line-modified-added">+           if (call_vm || rcvr-&gt;cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {</span>
              // Is it simple recursive case?
<span class="udiff-line-modified-removed">-             if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="udiff-line-modified-removed">-               mon-&gt;lock()-&gt;set_displaced_header(NULL);</span>
<span class="udiff-line-modified-added">+             if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="udiff-line-modified-added">+               mon-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
              } else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
              }
            }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -848,45 +849,45 @@</span>
        // find a free monitor
        BasicObjectLock* entry = (BasicObjectLock*) istate-&gt;stack_base();
        assert(entry-&gt;obj() == NULL, &quot;Frame manager didn&#39;t allocate the monitor&quot;);
        entry-&gt;set_obj(lockee);
        bool success = false;
<span class="udiff-line-modified-removed">-       uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
<span class="udiff-line-modified-added">+       uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
  
<span class="udiff-line-modified-removed">-       markOop mark = lockee-&gt;mark();</span>
<span class="udiff-line-modified-removed">-       intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
<span class="udiff-line-modified-added">+       markWord mark = lockee-&gt;mark();</span>
<span class="udiff-line-modified-added">+       intptr_t hash = (intptr_t) markWord::no_hash;</span>
        // implies UseBiasedLocking
<span class="udiff-line-modified-removed">-       if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+       if (mark.has_bias_pattern()) {</span>
          uintptr_t thread_ident;
          uintptr_t anticipated_bias_locking_value;
          thread_ident = (uintptr_t)istate-&gt;thread();
          anticipated_bias_locking_value =
<span class="udiff-line-modified-removed">-           (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="udiff-line-modified-removed">-           ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
<span class="udiff-line-modified-added">+           ((lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="udiff-line-modified-added">+           ~(markWord::age_mask_in_place);</span>
  
          if  (anticipated_bias_locking_value == 0) {
            // already biased towards this thread, nothing to do
            if (PrintBiasedLockingStatistics) {
              (* BiasedLocking::biased_lock_entry_count_addr())++;
            }
            success = true;
<span class="udiff-line-modified-removed">-         } else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
<span class="udiff-line-modified-added">+         } else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
            // try revoke bias
<span class="udiff-line-modified-removed">-           markOop header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-removed">-           if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-             header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+           markWord header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-added">+           if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+             header = header.copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            }
          } else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
            // try rebias
<span class="udiff-line-modified-removed">-           markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="udiff-line-modified-removed">-           if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-                 new_header = new_header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+           markWord new_header( (intptr_t) lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="udiff-line-modified-added">+           if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+             new_header = new_header.copy_set_hash(hash);</span>
            }
            if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::rebiased_lock_entry_count_addr())++;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -894,18 +895,18 @@</span>
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
            success = true;
          } else {
            // try to bias towards thread in case object is anonymously biased
<span class="udiff-line-modified-removed">-           markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-removed">-                                                           (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));</span>
<span class="udiff-line-modified-removed">-           if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-             header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+           markWord header(mark.value() &amp; (markWord::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-added">+                                           markWord::age_mask_in_place | epoch_mask_in_place));</span>
<span class="udiff-line-modified-added">+           if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+             header = header.copy_set_hash(hash);</span>
            }
<span class="udiff-line-modified-removed">-           markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
<span class="udiff-line-modified-added">+           markWord new_header(header.value() | thread_ident);</span>
            // debugging hint
<span class="udiff-line-modified-removed">-           DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
<span class="udiff-line-modified-added">+           DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
            if (lockee-&gt;cas_set_mark(new_header, header) == header) {
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
              }
            } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -915,17 +916,17 @@</span>
          }
        }
  
        // traditional lightweight locking
        if (!success) {
<span class="udiff-line-modified-removed">-         markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span>
<span class="udiff-line-modified-added">+         markWord displaced = lockee-&gt;mark().set_unlocked();</span>
          entry-&gt;lock()-&gt;set_displaced_header(displaced);
          bool call_vm = UseHeavyMonitors;
<span class="udiff-line-modified-removed">-         if (call_vm || lockee-&gt;cas_set_mark((markOop)entry, displaced) != displaced) {</span>
<span class="udiff-line-modified-added">+         if (call_vm || lockee-&gt;cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {</span>
            // Is it simple recursive case?
<span class="udiff-line-modified-removed">-           if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="udiff-line-modified-removed">-             entry-&gt;lock()-&gt;set_displaced_header(NULL);</span>
<span class="udiff-line-modified-added">+           if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="udiff-line-modified-added">+             entry-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
            } else {
              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
            }
          }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1788,46 +1789,46 @@</span>
            most_recent++;
          }
          if (entry != NULL) {
            entry-&gt;set_obj(lockee);
            int success = false;
<span class="udiff-line-modified-removed">-           uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span>
<span class="udiff-line-modified-added">+           uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;</span>
  
<span class="udiff-line-modified-removed">-           markOop mark = lockee-&gt;mark();</span>
<span class="udiff-line-modified-removed">-           intptr_t hash = (intptr_t) markOopDesc::no_hash;</span>
<span class="udiff-line-modified-added">+           markWord mark = lockee-&gt;mark();</span>
<span class="udiff-line-modified-added">+           intptr_t hash = (intptr_t) markWord::no_hash;</span>
            // implies UseBiasedLocking
<span class="udiff-line-modified-removed">-           if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+           if (mark.has_bias_pattern()) {</span>
              uintptr_t thread_ident;
              uintptr_t anticipated_bias_locking_value;
              thread_ident = (uintptr_t)istate-&gt;thread();
              anticipated_bias_locking_value =
<span class="udiff-line-modified-removed">-               (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) ^ (uintptr_t)mark) &amp;</span>
<span class="udiff-line-modified-removed">-               ~((uintptr_t) markOopDesc::age_mask_in_place);</span>
<span class="udiff-line-modified-added">+               ((lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident) ^ mark.value()) &amp;</span>
<span class="udiff-line-modified-added">+               ~(markWord::age_mask_in_place);</span>
  
              if  (anticipated_bias_locking_value == 0) {
                // already biased towards this thread, nothing to do
                if (PrintBiasedLockingStatistics) {
                  (* BiasedLocking::biased_lock_entry_count_addr())++;
                }
                success = true;
              }
<span class="udiff-line-modified-removed">-             else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) {</span>
<span class="udiff-line-modified-added">+             else if ((anticipated_bias_locking_value &amp; markWord::biased_lock_mask_in_place) != 0) {</span>
                // try revoke bias
<span class="udiff-line-modified-removed">-               markOop header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-removed">-               if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-                 header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+               markWord header = lockee-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-added">+               if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+                 header = header.copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (*BiasedLocking::revoked_lock_entry_count_addr())++;
                }
              }
              else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) {
                // try rebias
<span class="udiff-line-modified-removed">-               markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span>
<span class="udiff-line-modified-removed">-               if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-                 new_header = new_header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+               markWord new_header( (intptr_t) lockee-&gt;klass()-&gt;prototype_header().value() | thread_ident);</span>
<span class="udiff-line-modified-added">+               if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+                 new_header = new_header.copy_set_hash(hash);</span>
                }
                if (lockee-&gt;cas_set_mark(new_header, mark) == mark) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::rebiased_lock_entry_count_addr())++;
                }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1836,19 +1837,19 @@</span>
                }
                success = true;
              }
              else {
                // try to bias towards thread in case object is anonymously biased
<span class="udiff-line-modified-removed">-               markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-removed">-                                                               (uintptr_t)markOopDesc::age_mask_in_place |</span>
<span class="udiff-line-modified-removed">-                                                               epoch_mask_in_place));</span>
<span class="udiff-line-modified-removed">-               if (hash != markOopDesc::no_hash) {</span>
<span class="udiff-line-modified-removed">-                 header = header-&gt;copy_set_hash(hash);</span>
<span class="udiff-line-modified-added">+               markWord header(mark.value() &amp; (markWord::biased_lock_mask_in_place |</span>
<span class="udiff-line-modified-added">+                                               markWord::age_mask_in_place |</span>
<span class="udiff-line-modified-added">+                                               epoch_mask_in_place));</span>
<span class="udiff-line-modified-added">+               if (hash != markWord::no_hash) {</span>
<span class="udiff-line-modified-added">+                 header = header.copy_set_hash(hash);</span>
                }
<span class="udiff-line-modified-removed">-               markOop new_header = (markOop) ((uintptr_t) header | thread_ident);</span>
<span class="udiff-line-modified-added">+               markWord new_header(header.value() | thread_ident);</span>
                // debugging hint
<span class="udiff-line-modified-removed">-               DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)</span>
<span class="udiff-line-modified-added">+               DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header(markWord((uintptr_t) 0xdeaddead));)</span>
                if (lockee-&gt;cas_set_mark(new_header, header) == header) {
                  if (PrintBiasedLockingStatistics)
                    (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
                }
                else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1858,17 +1859,17 @@</span>
              }
            }
  
            // traditional lightweight locking
            if (!success) {
<span class="udiff-line-modified-removed">-             markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span>
<span class="udiff-line-modified-added">+             markWord displaced = lockee-&gt;mark().set_unlocked();</span>
              entry-&gt;lock()-&gt;set_displaced_header(displaced);
              bool call_vm = UseHeavyMonitors;
<span class="udiff-line-modified-removed">-             if (call_vm || lockee-&gt;cas_set_mark((markOop)entry, displaced) != displaced) {</span>
<span class="udiff-line-modified-added">+             if (call_vm || lockee-&gt;cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {</span>
                // Is it simple recursive case?
<span class="udiff-line-modified-removed">-               if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) {</span>
<span class="udiff-line-modified-removed">-                 entry-&gt;lock()-&gt;set_displaced_header(NULL);</span>
<span class="udiff-line-modified-added">+               if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {</span>
<span class="udiff-line-modified-added">+                 entry-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
                } else {
                  CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
                }
              }
            }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1887,17 +1888,17 @@</span>
          BasicObjectLock* limit = istate-&gt;monitor_base();
          BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();
          while (most_recent != limit ) {
            if ((most_recent)-&gt;obj() == lockee) {
              BasicLock* lock = most_recent-&gt;lock();
<span class="udiff-line-modified-removed">-             markOop header = lock-&gt;displaced_header();</span>
<span class="udiff-line-modified-added">+             markWord header = lock-&gt;displaced_header();</span>
              most_recent-&gt;set_obj(NULL);
<span class="udiff-line-modified-removed">-             if (!lockee-&gt;mark()-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+             if (!lockee-&gt;mark().has_bias_pattern()) {</span>
                bool call_vm = UseHeavyMonitors;
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="udiff-line-modified-removed">-               if (header != NULL || call_vm) {</span>
<span class="udiff-line-modified-removed">-                 markOop old_header = markOopDesc::encode(lock);</span>
<span class="udiff-line-modified-added">+               if (header.to_pointer() != NULL || call_vm) {</span>
<span class="udiff-line-modified-added">+                 markWord old_header = markWord::encode(lock);</span>
                  if (call_vm || lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    most_recent-&gt;set_obj(lockee);
                    CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2160,30 +2161,30 @@</span>
                // Try allocate in shared eden
              retry:
                HeapWord* compare_to = *Universe::heap()-&gt;top_addr();
                HeapWord* new_top = compare_to + obj_size;
                if (new_top &lt;= *Universe::heap()-&gt;end_addr()) {
<span class="udiff-line-modified-removed">-                 if (Atomic::cmpxchg(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) {</span>
<span class="udiff-line-modified-added">+                 if (Atomic::cmpxchg(Universe::heap()-&gt;top_addr(), compare_to, new_top) != compare_to) {</span>
                    goto retry;
                  }
                  result = (oop) compare_to;
                }
              }
  #endif
              if (result != NULL) {
                // Initialize object (if nonzero size and need) and then the header
                if (need_zero ) {
<span class="udiff-line-modified-removed">-                 HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;</span>
<span class="udiff-line-modified-added">+                 HeapWord* to_zero = cast_from_oop&lt;HeapWord*&gt;(result) + sizeof(oopDesc) / oopSize;</span>
                  obj_size -= sizeof(oopDesc) / oopSize;
                  if (obj_size &gt; 0 ) {
                    memset(to_zero, 0, obj_size * HeapWordSize);
                  }
                }
                if (UseBiasedLocking) {
                  result-&gt;set_mark(ik-&gt;prototype_header());
                } else {
<span class="udiff-line-modified-removed">-                 result-&gt;set_mark(markOopDesc::prototype());</span>
<span class="udiff-line-modified-added">+                 result-&gt;set_mark(markWord::prototype());</span>
                }
                result-&gt;set_klass_gap(0);
                result-&gt;set_klass(ik);
                // Must prevent reordering of stores for object initialization
                // with stores that publish the new object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2433,11 +2434,11 @@</span>
          if (result == NULL) {
            CALL_VM(InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode),
                    handle_exception);
            result = THREAD-&gt;vm_result();
          }
<span class="udiff-line-modified-removed">-         if (oopDesc::equals(result, Universe::the_null_sentinel()))</span>
<span class="udiff-line-modified-added">+         if (result == Universe::the_null_sentinel())</span>
            result = NULL;
  
          VERIFY_OOP(result);
          SET_STACK_OBJECT(result, 0);
          UPDATE_PC_AND_TOS_AND_CONTINUE(incr, 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2459,12 +2460,12 @@</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="udiff-line-modified-removed">-           ConstantPool* constants = METHOD-&gt;constants();</span>
<span class="udiff-line-modified-removed">-           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(constants), 0);</span>
<span class="udiff-line-modified-added">+           constantPoolHandle cp(THREAD, METHOD-&gt;constants());</span>
<span class="udiff-line-modified-added">+           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(cp), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2490,12 +2491,12 @@</span>
  
          Method* method = cache-&gt;f1_as_method();
          if (VerifyOops) method-&gt;verify();
  
          if (cache-&gt;has_appendix()) {
<span class="udiff-line-modified-removed">-           ConstantPool* constants = METHOD-&gt;constants();</span>
<span class="udiff-line-modified-removed">-           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(constants), 0);</span>
<span class="udiff-line-modified-added">+           constantPoolHandle cp(THREAD, METHOD-&gt;constants());</span>
<span class="udiff-line-modified-added">+           SET_STACK_OBJECT(cache-&gt;appendix_if_resolved(cp), 0);</span>
            MORE_STACK(1);
          }
  
          istate-&gt;set_msg(call_method);
          istate-&gt;set_callee(method);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2868,11 +2869,11 @@</span>
          tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
                       &quot; at bci %d, continuing at %d for thread &quot; INTPTR_FORMAT,
                       METHOD-&gt;print_value_string(),
                       (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
                       (int)continuation_bci, p2i(THREAD));
<span class="udiff-line-modified-removed">-         Exceptions::log_exception(except_oop, tempst);</span>
<span class="udiff-line-modified-added">+         Exceptions::log_exception(except_oop, tempst.as_string());</span>
        }
        // for AbortVMOnException flag
        Exceptions::debug_check_abort(except_oop);
  
        // Update profiling data.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2885,11 +2886,11 @@</span>
        tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
               &quot; at bci %d, unwinding for thread &quot; INTPTR_FORMAT,
               METHOD-&gt;print_value_string(),
               (int)(istate-&gt;bcp() - METHOD-&gt;code_base()),
               p2i(THREAD));
<span class="udiff-line-modified-removed">-       Exceptions::log_exception(except_oop, tempst);</span>
<span class="udiff-line-modified-added">+       Exceptions::log_exception(except_oop, tempst.as_string());</span>
      }
      // for AbortVMOnException flag
      Exceptions::debug_check_abort(except_oop);
  
      // No handler in this activation, unwind and try again
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3032,17 +3033,17 @@</span>
        // Check all the monitors to see they are unlocked. Install exception if found to be locked.
        while (end &lt; base) {
          oop lockee = end-&gt;obj();
          if (lockee != NULL) {
            BasicLock* lock = end-&gt;lock();
<span class="udiff-line-modified-removed">-           markOop header = lock-&gt;displaced_header();</span>
<span class="udiff-line-modified-added">+           markWord header = lock-&gt;displaced_header();</span>
            end-&gt;set_obj(NULL);
  
<span class="udiff-line-modified-removed">-           if (!lockee-&gt;mark()-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+           if (!lockee-&gt;mark().has_bias_pattern()) {</span>
              // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="udiff-line-modified-removed">-             if (header != NULL) {</span>
<span class="udiff-line-modified-removed">-               markOop old_header = markOopDesc::encode(lock);</span>
<span class="udiff-line-modified-added">+             if (header.to_pointer() != NULL) {</span>
<span class="udiff-line-modified-added">+               markWord old_header = markWord::encode(lock);</span>
                if (lockee-&gt;cas_set_mark(header, old_header) != old_header) {
                  // restore object for the slow case
                  end-&gt;set_obj(lockee);
                  {
                    // Prevent any HandleMarkCleaner from freeing our live handles
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3107,18 +3108,18 @@</span>
                if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD-&gt;pending_exception());
                THREAD-&gt;clear_pending_exception();
              }
            } else {
              BasicLock* lock = base-&gt;lock();
<span class="udiff-line-modified-removed">-             markOop header = lock-&gt;displaced_header();</span>
<span class="udiff-line-modified-added">+             markWord header = lock-&gt;displaced_header();</span>
              base-&gt;set_obj(NULL);
  
<span class="udiff-line-modified-removed">-             if (!rcvr-&gt;mark()-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+             if (!rcvr-&gt;mark().has_bias_pattern()) {</span>
                base-&gt;set_obj(NULL);
                // If it isn&#39;t recursive we either must swap old header or call the runtime
<span class="udiff-line-modified-removed">-               if (header != NULL) {</span>
<span class="udiff-line-modified-removed">-                 markOop old_header = markOopDesc::encode(lock);</span>
<span class="udiff-line-modified-added">+               if (header.to_pointer() != NULL) {</span>
<span class="udiff-line-modified-added">+                 markWord old_header = markWord::encode(lock);</span>
                  if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
                    // restore object for the slow case
                    base-&gt;set_obj(rcvr);
                    {
                      // Prevent any HandleMarkCleaner from freeing our live handles
</pre>
<center><a href="bytecode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeStream.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
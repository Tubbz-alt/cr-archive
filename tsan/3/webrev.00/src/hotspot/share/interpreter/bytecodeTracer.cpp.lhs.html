<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/bytecodeTracer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 28 #include &quot;interpreter/bytecodeTracer.hpp&quot;
 29 #include &quot;interpreter/bytecodes.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
 31 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;oops/constantPool.inline.hpp&quot;
 34 #include &quot;oops/methodData.hpp&quot;
 35 #include &quot;oops/method.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/timer.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
 40 
 41 // Standard closure for BytecodeTracer: prints the current bytecode
 42 // and its attributes using bytecode-specific information.
 43 
 44 class BytecodePrinter: public BytecodeClosure {
 45  private:
 46   // %%% This field is not GC-ed, and so can contain garbage
 47   // between critical sections.  Use only pointer-comparison
 48   // operations on the pointer, except within a critical section.
 49   // (Also, ensure that occasional false positives are benign.)
 50   Method* _current_method;
 51   bool      _is_wide;
 52   Bytecodes::Code _code;
 53   address   _next_pc;                // current decoding position
 54 
 55   void      align()                  { _next_pc = align_up(_next_pc, sizeof(jint)); }
 56   int       get_byte()               { return *(jbyte*) _next_pc++; }  // signed
 57   short     get_short()              { short i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }
 58   int       get_int()                { int i=Bytes::get_Java_u4(_next_pc); _next_pc+=4; return i; }
 59 
 60   int       get_index_u1()           { return *(address)_next_pc++; }
 61   int       get_index_u2()           { int i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }
 62   int       get_index_u1_cpcache()   { return get_index_u1() + ConstantPool::CPCACHE_INDEX_TAG; }
 63   int       get_index_u2_cpcache()   { int i=Bytes::get_native_u2(_next_pc); _next_pc+=2; return i + ConstantPool::CPCACHE_INDEX_TAG; }
 64   int       get_index_u4()           { int i=Bytes::get_native_u4(_next_pc); _next_pc+=4; return i; }
 65   int       get_index_special()      { return (is_wide()) ? get_index_u2() : get_index_u1(); }
 66   Method* method()                 { return _current_method; }
 67   bool      is_wide()                { return _is_wide; }
 68   Bytecodes::Code raw_code()         { return Bytecodes::Code(_code); }
 69 
 70 
 71   bool      check_index(int i, int&amp; cp_index, outputStream* st = tty);
 72   bool      check_cp_cache_index(int i, int&amp; cp_index, outputStream* st = tty);
 73   bool      check_obj_index(int i, int&amp; cp_index, outputStream* st = tty);
 74   bool      check_invokedynamic_index(int i, int&amp; cp_index, outputStream* st = tty);
 75   void      print_constant(int i, outputStream* st = tty);
 76   void      print_field_or_method(int i, outputStream* st = tty);
 77   void      print_field_or_method(int orig_i, int i, outputStream* st = tty);
 78   void      print_attributes(int bci, outputStream* st = tty);
 79   void      bytecode_epilog(int bci, outputStream* st = tty);
 80 
 81  public:
 82   BytecodePrinter() {
 83     _is_wide = false;
 84     _code = Bytecodes::_illegal;
 85   }
 86 
 87   // This method is called while executing the raw bytecodes, so none of
 88   // the adjustments that BytecodeStream performs applies.
 89   void trace(const methodHandle&amp; method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {
 90     ResourceMark rm;
 91     if (_current_method != method()) {
 92       // Note 1: This code will not work as expected with true MT/MP.
 93       //         Need an explicit lock or a different solution.
 94       // It is possible for this block to be skipped, if a garbage
 95       // _current_method pointer happens to have the same bits as
 96       // the incoming method.  We could lose a line of trace output.
 97       // This is acceptable in a debug-only feature.
 98       st-&gt;cr();
 99       st-&gt;print(&quot;[%ld] &quot;, (long) Thread::current()-&gt;osthread()-&gt;thread_id());
100       method-&gt;print_name(st);
101       st-&gt;cr();
102       _current_method = method();
103     }
104     Bytecodes::Code code;
105     if (is_wide()) {
106       // bcp wasn&#39;t advanced if previous bytecode was _wide.
107       code = Bytecodes::code_at(method(), bcp+1);
108     } else {
109       code = Bytecodes::code_at(method(), bcp);
110     }
111     _code = code;
112      int bci = bcp - method-&gt;code_base();
113     st-&gt;print(&quot;[%ld] &quot;, (long) Thread::current()-&gt;osthread()-&gt;thread_id());
114     if (Verbose) {
115       st-&gt;print(&quot;%8d  %4d  &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; %s&quot;,
116            BytecodeCounter::counter_value(), bci, tos, tos2, Bytecodes::name(code));
117     } else {
118       st-&gt;print(&quot;%8d  %4d  %s&quot;,
119            BytecodeCounter::counter_value(), bci, Bytecodes::name(code));
120     }
121     _next_pc = is_wide() ? bcp+2 : bcp+1;
122     print_attributes(bci);
123     // Set is_wide for the next one, since the caller of this doesn&#39;t skip
124     // the next bytecode.
125     _is_wide = (code == Bytecodes::_wide);
126     _code = Bytecodes::_illegal;
127   }
128 
129   // Used for Method*::print_codes().  The input bcp comes from
130   // BytecodeStream, which will skip wide bytecodes.
131   void trace(const methodHandle&amp; method, address bcp, outputStream* st) {
132     _current_method = method();
133     ResourceMark rm;
134     Bytecodes::Code code = Bytecodes::code_at(method(), bcp);
135     // Set is_wide
136     _is_wide = (code == Bytecodes::_wide);
137     if (is_wide()) {
138       code = Bytecodes::code_at(method(), bcp+1);
139     }
140     _code = code;
141     int bci = bcp - method-&gt;code_base();
142     // Print bytecode index and name
143     if (is_wide()) {
144       st-&gt;print(&quot;%d %s_w&quot;, bci, Bytecodes::name(code));
145     } else {
146       st-&gt;print(&quot;%d %s&quot;, bci, Bytecodes::name(code));
147     }
148     _next_pc = is_wide() ? bcp+2 : bcp+1;
149     print_attributes(bci, st);
150     bytecode_epilog(bci, st);
151   }
152 };
153 
154 
155 // Implementation of BytecodeTracer
156 
157 // %%% This set_closure thing seems overly general, given that
158 // nobody uses it.  Also, if BytecodePrinter weren&#39;t hidden
159 // then Method* could use instances of it directly and it
160 // would be easier to remove races on _current_method and bcp.
161 // Since this is not product functionality, we can defer cleanup.
162 
163 BytecodeClosure* BytecodeTracer::_closure = NULL;
164 
165 static BytecodePrinter std_closure;
166 BytecodeClosure* BytecodeTracer::std_closure() {
167   return &amp;::std_closure;
168 }
169 
170 
171 void BytecodeTracer::trace(const methodHandle&amp; method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {
172   if (TraceBytecodes &amp;&amp; BytecodeCounter::counter_value() &gt;= TraceBytecodesAt) {
173     ttyLocker ttyl;  // 5065316: keep the following output coherent
174     // The ttyLocker also prevents races between two threads
175     // trying to use the single instance of BytecodePrinter.
176     // Using the ttyLocker prevents the system from coming to
177     // a safepoint within this code, which is sensitive to Method*
178     // movement.
179     //
180     // There used to be a leaf mutex here, but the ttyLocker will
181     // work just as well, as long as the printing operations never block.
182     //
183     // We put the locker on the static trace method, not the
184     // virtual one, because the clients of this module go through
185     // the static method.
186     _closure-&gt;trace(method, bcp, tos, tos2, st);
187   }
188 }
189 
190 void BytecodeTracer::trace(const methodHandle&amp; method, address bcp, outputStream* st) {
191   ttyLocker ttyl;  // 5065316: keep the following output coherent
192   _closure-&gt;trace(method, bcp, st);
193 }
194 
195 void print_symbol(Symbol* sym, outputStream* st) {
196   char buf[40];
197   int len = sym-&gt;utf8_length();
198   if (len &gt;= (int)sizeof(buf)) {
199     st-&gt;print_cr(&quot; %s...[%d]&quot;, sym-&gt;as_C_string(buf, sizeof(buf)), len);
200   } else {
201     st-&gt;print(&quot; &quot;);
202     sym-&gt;print_on(st); st-&gt;cr();
203   }
204 }
205 
206 void print_oop(oop value, outputStream* st) {
207   if (value == NULL) {
208     st-&gt;print_cr(&quot; NULL&quot;);
209   } else if (java_lang_String::is_instance(value)) {
210     char buf[40];
211     int len = java_lang_String::utf8_length(value);
212     java_lang_String::as_utf8_string(value, buf, sizeof(buf));
213     if (len &gt;= (int)sizeof(buf)) {
214       st-&gt;print_cr(&quot; %s...[%d]&quot;, buf, len);
215     } else {
216       st-&gt;print_cr(&quot; %s&quot;, buf);
217     }
218   } else {
219     st-&gt;print_cr(&quot; &quot; INTPTR_FORMAT, p2i((void *)value));
220   }
221 }
222 
223 bool BytecodePrinter::check_index(int i, int&amp; cp_index, outputStream* st) {
224   ConstantPool* constants = method()-&gt;constants();
225   int ilimit = constants-&gt;length();
226   Bytecodes::Code code = raw_code();
227 
228   if (Bytecodes::uses_cp_cache(code)) {
229     bool okay = true;
230     switch (code) {
231     case Bytecodes::_fast_aldc:
232     case Bytecodes::_fast_aldc_w:
233       okay = check_obj_index(i, cp_index, st);
234       break;
235     case Bytecodes::_invokedynamic:
236       okay = check_invokedynamic_index(i, cp_index, st);
237       break;
238     default:
239       okay = check_cp_cache_index(i, cp_index, st);
240       break;
241     }
242     if (!okay) return false;
243   }
244 
245 
246   // check cp index
247   if (cp_index &gt;= 0 &amp;&amp; cp_index &lt; ilimit) {
248     if (WizardMode)  st-&gt;print(&quot; cp[%d]&quot;, cp_index);
249     return true;
250   }
251 
252   st-&gt;print_cr(&quot; CP[%d] not in CP&quot;, cp_index);
253   return false;
254 }
255 
256 bool BytecodePrinter::check_cp_cache_index(int i, int&amp; cp_index, outputStream* st) {
257   ConstantPool* constants = method()-&gt;constants();
258   int climit = 0;
259 
260   ConstantPoolCache* cache = constants-&gt;cache();
261   // If rewriter hasn&#39;t run, the index is the cp_index
262   if (cache == NULL) {
263     cp_index = i;
264     return true;
265   }
266   //climit = cache-&gt;length();  // %%% private!
267   size_t size = cache-&gt;size() * wordSize;
268   size -= sizeof(ConstantPoolCache);
269   size /= sizeof(ConstantPoolCacheEntry);
270   climit = (int) size;
271 
272 #ifdef ASSERT
273   {
274     const int CPCACHE_INDEX_TAG = ConstantPool::CPCACHE_INDEX_TAG;
275     if (i &gt;= CPCACHE_INDEX_TAG &amp;&amp; i &lt; climit + CPCACHE_INDEX_TAG) {
276       i -= CPCACHE_INDEX_TAG;
277     } else {
278       st-&gt;print_cr(&quot; CP[%d] missing bias?&quot;, i);
279       return false;
280     }
281   }
282 #endif //ASSERT
283   if (i &gt;= 0 &amp;&amp; i &lt; climit) {
284     cp_index = cache-&gt;entry_at(i)-&gt;constant_pool_index();
285   } else {
286     st-&gt;print_cr(&quot;%d not in CP[*]?&quot;, i);
287       return false;
288     }
289   return true;
290   }
291 
292 
293 bool BytecodePrinter::check_obj_index(int i, int&amp; cp_index, outputStream* st) {
294   ConstantPool* constants = method()-&gt;constants();
295   i -= ConstantPool::CPCACHE_INDEX_TAG;
296 
297   if (i &gt;= 0 &amp;&amp; i &lt; constants-&gt;resolved_references()-&gt;length()) {
298      cp_index = constants-&gt;object_to_cp_index(i);
299      return true;
300   } else {
301     st-&gt;print_cr(&quot;%d not in OBJ[*]?&quot;, i);
302   return false;
303 }
304 }
305 
306 
307 bool BytecodePrinter::check_invokedynamic_index(int i, int&amp; cp_index, outputStream* st) {
308   assert(ConstantPool::is_invokedynamic_index(i), &quot;not secondary index?&quot;);
309   i = ConstantPool::decode_invokedynamic_index(i) + ConstantPool::CPCACHE_INDEX_TAG;
310 
311   return check_cp_cache_index(i, cp_index, st);
312 }
313 
314 void BytecodePrinter::print_constant(int i, outputStream* st) {
315   int orig_i = i;
316   if (!check_index(orig_i, i, st))  return;
317 
318   ConstantPool* constants = method()-&gt;constants();
319   constantTag tag = constants-&gt;tag_at(i);
320 
321   if (tag.is_int()) {
322     st-&gt;print_cr(&quot; &quot; INT32_FORMAT, constants-&gt;int_at(i));
323   } else if (tag.is_long()) {
324     st-&gt;print_cr(&quot; &quot; INT64_FORMAT, (int64_t)(constants-&gt;long_at(i)));
325   } else if (tag.is_float()) {
326     st-&gt;print_cr(&quot; %f&quot;, constants-&gt;float_at(i));
327   } else if (tag.is_double()) {
328     st-&gt;print_cr(&quot; %f&quot;, constants-&gt;double_at(i));
329   } else if (tag.is_string()) {
330     const char* string = constants-&gt;string_at_noresolve(i);
331     st-&gt;print_cr(&quot; %s&quot;, string);
332   } else if (tag.is_klass()) {
333     st-&gt;print_cr(&quot; %s&quot;, constants-&gt;resolved_klass_at(i)-&gt;external_name());
334   } else if (tag.is_unresolved_klass()) {
335     st-&gt;print_cr(&quot; &lt;unresolved klass at %d&gt;&quot;, i);
336   } else if (tag.is_method_type()) {
337     int i2 = constants-&gt;method_type_index_at(i);
338     st-&gt;print(&quot; &lt;MethodType&gt; %d&quot;, i2);
339     print_symbol(constants-&gt;symbol_at(i2), st);
340   } else if (tag.is_method_handle()) {
341     int kind = constants-&gt;method_handle_ref_kind_at(i);
342     int i2 = constants-&gt;method_handle_index_at(i);
343     st-&gt;print(&quot; &lt;MethodHandle of kind %d index at %d&gt;&quot;, kind, i2);
344     print_field_or_method(-i, i2, st);
345   } else {
346     st-&gt;print_cr(&quot; bad tag=%d at %d&quot;, tag.value(), i);
347   }
348 }
349 
350 void BytecodePrinter::print_field_or_method(int i, outputStream* st) {
351   int orig_i = i;
352   if (!check_index(orig_i, i, st))  return;
353   print_field_or_method(orig_i, i, st);
354 }
355 
356 void BytecodePrinter::print_field_or_method(int orig_i, int i, outputStream* st) {
357   ConstantPool* constants = method()-&gt;constants();
358   constantTag tag = constants-&gt;tag_at(i);
359 
360   bool has_klass = true;
361 
362   switch (tag.value()) {
363   case JVM_CONSTANT_InterfaceMethodref:
364   case JVM_CONSTANT_Methodref:
365   case JVM_CONSTANT_Fieldref:
366     break;
367   case JVM_CONSTANT_NameAndType:
368   case JVM_CONSTANT_Dynamic:
369   case JVM_CONSTANT_InvokeDynamic:
370     has_klass = false;
371     break;
372   default:
373     st-&gt;print_cr(&quot; bad tag=%d at %d&quot;, tag.value(), i);
374     return;
375   }
376 
377   Symbol* name = constants-&gt;uncached_name_ref_at(i);
378   Symbol* signature = constants-&gt;uncached_signature_ref_at(i);
379   const char* sep = (tag.is_field() ? &quot;/&quot; : &quot;&quot;);
380   if (has_klass) {
381     Symbol* klass = constants-&gt;klass_name_at(constants-&gt;uncached_klass_ref_index_at(i));
382     st-&gt;print_cr(&quot; %d &lt;%s.%s%s%s&gt; &quot;, i, klass-&gt;as_C_string(), name-&gt;as_C_string(), sep, signature-&gt;as_C_string());
383   } else {
384     if (tag.is_dynamic_constant() || tag.is_invoke_dynamic()) {
385       int bsm = constants-&gt;bootstrap_method_ref_index_at(i);
386       st-&gt;print(&quot; bsm=%d&quot;, bsm);
387     }
388     st-&gt;print_cr(&quot; %d &lt;%s%s%s&gt;&quot;, i, name-&gt;as_C_string(), sep, signature-&gt;as_C_string());
389   }
390 }
391 
392 
393 void BytecodePrinter::print_attributes(int bci, outputStream* st) {
394   // Show attributes of pre-rewritten codes
395   Bytecodes::Code code = Bytecodes::java_code(raw_code());
396   // If the code doesn&#39;t have any fields there&#39;s nothing to print.
397   // note this is ==1 because the tableswitch and lookupswitch are
398   // zero size (for some reason) and we want to print stuff out for them.
399   if (Bytecodes::length_for(code) == 1) {
400     st-&gt;cr();
401     return;
402   }
403 
404   switch(code) {
405     // Java specific bytecodes only matter.
406     case Bytecodes::_bipush:
407       st-&gt;print_cr(&quot; &quot; INT32_FORMAT, get_byte());
408       break;
409     case Bytecodes::_sipush:
410       st-&gt;print_cr(&quot; &quot; INT32_FORMAT, get_short());
411       break;
412     case Bytecodes::_ldc:
413       if (Bytecodes::uses_cp_cache(raw_code())) {
414         print_constant(get_index_u1_cpcache(), st);
415       } else {
416         print_constant(get_index_u1(), st);
417       }
418       break;
419 
420     case Bytecodes::_ldc_w:
421     case Bytecodes::_ldc2_w:
422       if (Bytecodes::uses_cp_cache(raw_code())) {
423         print_constant(get_index_u2_cpcache(), st);
424       } else {
425         print_constant(get_index_u2(), st);
426       }
427       break;
428 
429     case Bytecodes::_iload:
430     case Bytecodes::_lload:
431     case Bytecodes::_fload:
432     case Bytecodes::_dload:
433     case Bytecodes::_aload:
434     case Bytecodes::_istore:
435     case Bytecodes::_lstore:
436     case Bytecodes::_fstore:
437     case Bytecodes::_dstore:
438     case Bytecodes::_astore:
439       st-&gt;print_cr(&quot; #%d&quot;, get_index_special());
440       break;
441 
442     case Bytecodes::_iinc:
443       { int index = get_index_special();
444         jint offset = is_wide() ? get_short(): get_byte();
445         st-&gt;print_cr(&quot; #%d &quot; INT32_FORMAT, index, offset);
446       }
447       break;
448 
449     case Bytecodes::_newarray: {
450         BasicType atype = (BasicType)get_index_u1();
451         const char* str = type2name(atype);
<a name="1" id="anc1"></a><span class="line-modified">452         if (str == NULL || atype == T_OBJECT || atype == T_ARRAY) {</span>
453           assert(false, &quot;Unidentified basic type&quot;);
454         }
455         st-&gt;print_cr(&quot; %s&quot;, str);
456       }
457       break;
458     case Bytecodes::_anewarray: {
459         int klass_index = get_index_u2();
460         ConstantPool* constants = method()-&gt;constants();
461         Symbol* name = constants-&gt;klass_name_at(klass_index);
462         st-&gt;print_cr(&quot; %s &quot;, name-&gt;as_C_string());
463       }
464       break;
465     case Bytecodes::_multianewarray: {
466         int klass_index = get_index_u2();
467         int nof_dims = get_index_u1();
468         ConstantPool* constants = method()-&gt;constants();
469         Symbol* name = constants-&gt;klass_name_at(klass_index);
470         st-&gt;print_cr(&quot; %s %d&quot;, name-&gt;as_C_string(), nof_dims);
471       }
472       break;
473 
474     case Bytecodes::_ifeq:
475     case Bytecodes::_ifnull:
476     case Bytecodes::_iflt:
477     case Bytecodes::_ifle:
478     case Bytecodes::_ifne:
479     case Bytecodes::_ifnonnull:
480     case Bytecodes::_ifgt:
481     case Bytecodes::_ifge:
482     case Bytecodes::_if_icmpeq:
483     case Bytecodes::_if_icmpne:
484     case Bytecodes::_if_icmplt:
485     case Bytecodes::_if_icmpgt:
486     case Bytecodes::_if_icmple:
487     case Bytecodes::_if_icmpge:
488     case Bytecodes::_if_acmpeq:
489     case Bytecodes::_if_acmpne:
490     case Bytecodes::_goto:
491     case Bytecodes::_jsr:
492       st-&gt;print_cr(&quot; %d&quot;, bci + get_short());
493       break;
494 
495     case Bytecodes::_goto_w:
496     case Bytecodes::_jsr_w:
497       st-&gt;print_cr(&quot; %d&quot;, bci + get_int());
498       break;
499 
500     case Bytecodes::_ret: st-&gt;print_cr(&quot; %d&quot;, get_index_special()); break;
501 
502     case Bytecodes::_tableswitch:
503       { align();
504         int  default_dest = bci + get_int();
505         int  lo           = get_int();
506         int  hi           = get_int();
507         int  len          = hi - lo + 1;
508         jint* dest        = NEW_RESOURCE_ARRAY(jint, len);
509         for (int i = 0; i &lt; len; i++) {
510           dest[i] = bci + get_int();
511         }
512         st-&gt;print(&quot; %d &quot; INT32_FORMAT &quot; &quot; INT32_FORMAT &quot; &quot;,
513                       default_dest, lo, hi);
514         const char *comma = &quot;&quot;;
515         for (int ll = lo; ll &lt;= hi; ll++) {
516           int idx = ll - lo;
517           st-&gt;print(&quot;%s %d:&quot; INT32_FORMAT &quot; (delta: %d)&quot;, comma, ll, dest[idx], dest[idx]-bci);
518           comma = &quot;,&quot;;
519         }
520         st-&gt;cr();
521       }
522       break;
523     case Bytecodes::_lookupswitch:
524       { align();
525         int  default_dest = bci + get_int();
526         int  len          = get_int();
527         jint* key         = NEW_RESOURCE_ARRAY(jint, len);
528         jint* dest        = NEW_RESOURCE_ARRAY(jint, len);
529         for (int i = 0; i &lt; len; i++) {
530           key [i] = get_int();
531           dest[i] = bci + get_int();
532         };
533         st-&gt;print(&quot; %d %d &quot;, default_dest, len);
534         const char *comma = &quot;&quot;;
535         for (int ll = 0; ll &lt; len; ll++)  {
536           st-&gt;print(&quot;%s &quot; INT32_FORMAT &quot;:&quot; INT32_FORMAT, comma, key[ll], dest[ll]);
537           comma = &quot;,&quot;;
538         }
539         st-&gt;cr();
540       }
541       break;
542 
543     case Bytecodes::_putstatic:
544     case Bytecodes::_getstatic:
545     case Bytecodes::_putfield:
546     case Bytecodes::_getfield:
547       print_field_or_method(get_index_u2_cpcache(), st);
548       break;
549 
550     case Bytecodes::_invokevirtual:
551     case Bytecodes::_invokespecial:
552     case Bytecodes::_invokestatic:
553       print_field_or_method(get_index_u2_cpcache(), st);
554       break;
555 
556     case Bytecodes::_invokeinterface:
557       { int i = get_index_u2_cpcache();
558         int n = get_index_u1();
559         get_byte();            // ignore zero byte
560         print_field_or_method(i, st);
561       }
562       break;
563 
564     case Bytecodes::_invokedynamic:
565       print_field_or_method(get_index_u4(), st);
566       break;
567 
568     case Bytecodes::_new:
569     case Bytecodes::_checkcast:
570     case Bytecodes::_instanceof:
571       { int i = get_index_u2();
572         ConstantPool* constants = method()-&gt;constants();
573         Symbol* name = constants-&gt;klass_name_at(i);
574         st-&gt;print_cr(&quot; %d &lt;%s&gt;&quot;, i, name-&gt;as_C_string());
575       }
576       break;
577 
578     case Bytecodes::_wide:
579       // length is zero not one, but printed with no more info.
580       break;
581 
582     default:
583       ShouldNotReachHere();
584       break;
585   }
586 }
587 
588 
589 void BytecodePrinter::bytecode_epilog(int bci, outputStream* st) {
590   MethodData* mdo = method()-&gt;method_data();
591   if (mdo != NULL) {
592     ProfileData* data = mdo-&gt;bci_to_data(bci);
593     if (data != NULL) {
594       st-&gt;print(&quot;  %d&quot;, mdo-&gt;dp_to_di(data-&gt;dp()));
595       st-&gt;fill_to(6);
596       data-&gt;print_data_on(st, mdo);
597     }
598   }
599 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
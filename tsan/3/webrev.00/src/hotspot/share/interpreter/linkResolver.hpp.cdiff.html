<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/linkResolver.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="linkResolver.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMapCache.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   */
  
  #ifndef SHARE_INTERPRETER_LINKRESOLVER_HPP
  #define SHARE_INTERPRETER_LINKRESOLVER_HPP
  
<span class="line-added">+ #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
  #include &quot;oops/method.hpp&quot;
  
  // All the necessary definitions for run-time link resolution.
  
  // CallInfo provides all the information gathered for a particular
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,10 ***</span>
<span class="line-new-header">--- 76,11 ---</span>
                    const methodHandle&amp; resolved_method,
                    const methodHandle&amp; selected_method,
                    CallKind kind,
                    int index, TRAPS);
  
<span class="line-added">+   friend class BootstrapInfo;</span>
    friend class LinkResolver;
  
   public:
    CallInfo() {
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,12 ***</span>
    // object for the resolved_method.
    CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
  
    Klass*  resolved_klass() const                 { return _resolved_klass; }
    Klass*  selected_klass() const                 { return _selected_klass; }
<span class="line-modified">!   methodHandle resolved_method() const           { return _resolved_method; }</span>
<span class="line-modified">!   methodHandle selected_method() const           { return _selected_method; }</span>
    Handle       resolved_appendix() const         { return _resolved_appendix; }
    Handle       resolved_method_name() const      { return _resolved_method_name; }
    // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
    void     set_resolved_method_name(TRAPS);
  
<span class="line-new-header">--- 94,12 ---</span>
    // object for the resolved_method.
    CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
  
    Klass*  resolved_klass() const                 { return _resolved_klass; }
    Klass*  selected_klass() const                 { return _selected_klass; }
<span class="line-modified">!   Method* resolved_method() const                { return _resolved_method(); }</span>
<span class="line-modified">!   Method* selected_method() const                { return _selected_method(); }</span>
    Handle       resolved_appendix() const         { return _resolved_appendix; }
    Handle       resolved_method_name() const      { return _resolved_method_name; }
    // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
    void     set_resolved_method_name(TRAPS);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,14 ***</span>
    // accessors
    Symbol* name() const               { return _name; }
    Symbol* signature() const          { return _signature; }
    Klass* resolved_klass() const      { return _resolved_klass; }
    Klass* current_klass() const       { return _current_klass; }
<span class="line-modified">!   methodHandle current_method() const { return _current_method; }</span>
    constantTag tag() const            { return _tag; }
    bool check_access() const          { return _check_access; }
<span class="line-removed">-   char* method_string() const;</span>
  
    void         print()  PRODUCT_RETURN;
  };
  
  // Link information for getfield/putfield &amp; getstatic/putstatic bytecodes
<span class="line-new-header">--- 179,13 ---</span>
    // accessors
    Symbol* name() const               { return _name; }
    Symbol* signature() const          { return _signature; }
    Klass* resolved_klass() const      { return _resolved_klass; }
    Klass* current_klass() const       { return _current_klass; }
<span class="line-modified">!   Method* current_method() const     { return _current_method(); }</span>
    constantTag tag() const            { return _tag; }
    bool check_access() const          { return _check_access; }
  
    void         print()  PRODUCT_RETURN;
  };
  
  // Link information for getfield/putfield &amp; getstatic/putstatic bytecodes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,16 ***</span>
    static Method* lookup_method_in_klasses(const LinkInfo&amp; link_info,
                                            bool checkpolymorphism,
                                            bool in_imethod_resolve);
    static Method* lookup_method_in_interfaces(const LinkInfo&amp; link_info);
  
<span class="line-modified">!   static methodHandle lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified">!                                                 Handle *appendix_result_or_null, TRAPS);</span>
   JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
    // Not Linktime so doesn&#39;t take LinkInfo
<span class="line-modified">!   static methodHandle lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,</span>
<span class="line-modified">!                                                          Klass::PrivateLookupMode private_mode, TRAPS);</span>
   JVMCI_ONLY(private:)
  
    // Similar loader constraint checking functions that throw
    // LinkageError with descriptive message.
    static void check_method_loader_constraints(const LinkInfo&amp; link_info,
<span class="line-new-header">--- 203,16 ---</span>
    static Method* lookup_method_in_klasses(const LinkInfo&amp; link_info,
                                            bool checkpolymorphism,
                                            bool in_imethod_resolve);
    static Method* lookup_method_in_interfaces(const LinkInfo&amp; link_info);
  
<span class="line-modified">!   static Method* lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified">!                                            Handle *appendix_result_or_null, TRAPS);</span>
   JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
    // Not Linktime so doesn&#39;t take LinkInfo
<span class="line-modified">!   static Method* lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,</span>
<span class="line-modified">!                                                     Klass::PrivateLookupMode private_mode, TRAPS);</span>
   JVMCI_ONLY(private:)
  
    // Similar loader constraint checking functions that throw
    // LinkageError with descriptive message.
    static void check_method_loader_constraints(const LinkInfo&amp; link_info,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,17 ***</span>
                                                const char* method_type, TRAPS);
    static void check_field_loader_constraints(Symbol* field, Symbol* sig,
                                               Klass* current_klass,
                                               Klass* sel_klass, TRAPS);
  
<span class="line-modified">!   static methodHandle resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
<span class="line-modified">!   static methodHandle resolve_method          (const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
  
<span class="line-modified">!   static methodHandle linktime_resolve_static_method    (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static methodHandle linktime_resolve_special_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static methodHandle linktime_resolve_virtual_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static methodHandle linktime_resolve_interface_method (const LinkInfo&amp; link_info, TRAPS);</span>
  
    static void runtime_resolve_special_method    (CallInfo&amp; result,
                                                   const LinkInfo&amp; link_info,
                                                   const methodHandle&amp; resolved_method,
                                                   Handle recv, TRAPS);
<span class="line-new-header">--- 220,17 ---</span>
                                                const char* method_type, TRAPS);
    static void check_field_loader_constraints(Symbol* field, Symbol* sig,
                                               Klass* current_klass,
                                               Klass* sel_klass, TRAPS);
  
<span class="line-modified">!   static Method* resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
<span class="line-modified">!   static Method* resolve_method          (const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
  
<span class="line-modified">!   static Method* linktime_resolve_static_method    (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static Method* linktime_resolve_special_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static Method* linktime_resolve_virtual_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">!   static Method* linktime_resolve_interface_method (const LinkInfo&amp; link_info, TRAPS);</span>
  
    static void runtime_resolve_special_method    (CallInfo&amp; result,
                                                   const LinkInfo&amp; link_info,
                                                   const methodHandle&amp; resolved_method,
                                                   Handle recv, TRAPS);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,13 ***</span>
      return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
    }
  
    // static resolving calls (will not run any Java code);
    // used only from Bytecode_invoke::static_target
<span class="line-modified">!   static methodHandle resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified">!                                                 const constantPoolHandle&amp; pool,</span>
<span class="line-modified">!                                                 int index, TRAPS);</span>
  
    static void resolve_field_access(fieldDescriptor&amp; result,
                                     const constantPoolHandle&amp; pool,
                                     int index,
                                     const methodHandle&amp; method,
<span class="line-new-header">--- 283,13 ---</span>
      return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
    }
  
    // static resolving calls (will not run any Java code);
    // used only from Bytecode_invoke::static_target
<span class="line-modified">!   static Method* resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified">!                                            const constantPoolHandle&amp; pool,</span>
<span class="line-modified">!                                            int index, TRAPS);</span>
  
    static void resolve_field_access(fieldDescriptor&amp; result,
                                     const constantPoolHandle&amp; pool,
                                     int index,
                                     const methodHandle&amp; method,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,32 ***</span>
    static void resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
                                       const LinkInfo&amp; link_info,
                                       bool check_null_and_abstract, TRAPS);
    static void resolve_handle_call   (CallInfo&amp; result,
                                       const LinkInfo&amp; link_info, TRAPS);
<span class="line-modified">!   static void resolve_dynamic_call  (CallInfo&amp; result, int pool_index, Handle bootstrap_specifier,</span>
<span class="line-modified">!                                      Symbol* method_name, Symbol* method_signature,</span>
<span class="line-removed">-                                      Klass* current_klass, TRAPS);</span>
  
    // same as above for compile-time resolution; but returns null handle instead of throwing
    // an exception on error also, does not initialize klass (i.e., no side effects)
<span class="line-modified">!   static methodHandle resolve_virtual_call_or_null  (Klass* receiver_klass,</span>
<span class="line-modified">!                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static methodHandle resolve_interface_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">!                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static methodHandle resolve_static_call_or_null   (const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static methodHandle resolve_special_call_or_null  (const LinkInfo&amp; link_info);</span>
  
    static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
  
    // same as above for compile-time resolution; returns vtable_index if current_klass if linked
    static int resolve_virtual_vtable_index  (Klass* receiver_klass,
                                              const LinkInfo&amp; link_info);
  
    // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
<span class="line-modified">!   static methodHandle linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static methodHandle linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);</span>
  
    // runtime resolving from constant pool
    static void resolve_invoke(CallInfo&amp; result, Handle recv,
                               const constantPoolHandle&amp; pool, int index,
                               Bytecodes::Code byte, TRAPS);
<span class="line-new-header">--- 311,31 ---</span>
    static void resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
                                       const LinkInfo&amp; link_info,
                                       bool check_null_and_abstract, TRAPS);
    static void resolve_handle_call   (CallInfo&amp; result,
                                       const LinkInfo&amp; link_info, TRAPS);
<span class="line-modified">!   static void resolve_dynamic_call  (CallInfo&amp; result,</span>
<span class="line-modified">!                                      BootstrapInfo&amp; bootstrap_specifier, TRAPS);</span>
  
    // same as above for compile-time resolution; but returns null handle instead of throwing
    // an exception on error also, does not initialize klass (i.e., no side effects)
<span class="line-modified">!   static Method* resolve_virtual_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">!                                               const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static Method* resolve_interface_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">!                                                 const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static Method* resolve_static_call_or_null(const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static Method* resolve_special_call_or_null(const LinkInfo&amp; link_info);</span>
  
    static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
  
    // same as above for compile-time resolution; returns vtable_index if current_klass if linked
    static int resolve_virtual_vtable_index  (Klass* receiver_klass,
                                              const LinkInfo&amp; link_info);
  
    // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
<span class="line-modified">!   static Method* linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);</span>
<span class="line-modified">!   static Method* linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);</span>
  
    // runtime resolving from constant pool
    static void resolve_invoke(CallInfo&amp; result, Handle recv,
                               const constantPoolHandle&amp; pool, int index,
                               Bytecodes::Code byte, TRAPS);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,15 ***</span>
                               Bytecodes::Code byte, TRAPS);
  
   public:
    // Only resolved method known.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
<span class="line-modified">!     throw_abstract_method_error(resolved_method, NULL, NULL, CHECK);</span>
    }
    // Resolved method and receiver klass know.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
<span class="line-modified">!     throw_abstract_method_error(resolved_method, NULL, recv_klass, CHECK);</span>
    }
    // Selected method is abstract.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
                                            const methodHandle&amp; selected_method,
                                            Klass *recv_klass, TRAPS);
<span class="line-new-header">--- 346,15 ---</span>
                               Bytecodes::Code byte, TRAPS);
  
   public:
    // Only resolved method known.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
<span class="line-modified">!     throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);</span>
    }
    // Resolved method and receiver klass know.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
<span class="line-modified">!     throw_abstract_method_error(resolved_method, methodHandle(), recv_klass, CHECK);</span>
    }
    // Selected method is abstract.
    static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
                                            const methodHandle&amp; selected_method,
                                            Klass *recv_klass, TRAPS);
</pre>
<center><a href="linkResolver.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMapCache.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
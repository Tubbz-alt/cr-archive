<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="invocationCounter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/resolutionErrors.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;

  33 #include &quot;compiler/compileBroker.hpp&quot;
  34 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;

  35 #include &quot;interpreter/bytecode.hpp&quot;
  36 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed">  41 #include &quot;memory/universe.hpp&quot;</span>
  42 #include &quot;oops/constantPool.hpp&quot;
  43 #include &quot;oops/cpCache.inline.hpp&quot;
  44 #include &quot;oops/instanceKlass.hpp&quot;
  45 #include &quot;oops/method.hpp&quot;
  46 #include &quot;oops/objArrayKlass.hpp&quot;
  47 #include &quot;oops/objArrayOop.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;prims/methodHandles.hpp&quot;
  50 #include &quot;prims/nativeLookup.hpp&quot;
<span class="line-removed">  51 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
  67   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
</pre>
<hr />
<pre>
 123   _resolved_klass  = resolved_klass;
 124   _selected_klass  = selected_klass;
 125   _resolved_method = resolved_method;
 126   _selected_method = selected_method;
 127   _call_kind       = kind;
 128   _call_index      = index;
 129   _resolved_appendix = Handle();
 130   DEBUG_ONLY(verify());  // verify before making side effects
 131 
 132   CompilationPolicy::compile_if_required(selected_method, THREAD);
 133 }
 134 
 135 // utility query for unreflecting a method
 136 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 137   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 138   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 139     resolved_klass = resolved_method_holder;
 140   }
 141   _resolved_klass  = resolved_klass;
 142   _selected_klass  = resolved_klass;
<span class="line-modified"> 143   _resolved_method = resolved_method;</span>
<span class="line-modified"> 144   _selected_method = resolved_method;</span>
 145   // classify:
 146   CallKind kind = CallInfo::unknown_kind;
 147   int index = resolved_method-&gt;vtable_index();
 148   if (resolved_method-&gt;can_be_statically_bound()) {
 149     kind = CallInfo::direct_call;
 150   } else if (!resolved_method_holder-&gt;is_interface()) {
 151     // Could be an Object method inherited into an interface, but still a vtable call.
 152     kind = CallInfo::vtable_call;
 153   } else if (!resolved_klass-&gt;is_interface()) {
 154     // A default or miranda method.  Compute the vtable index.
 155     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
<span class="line-modified"> 156                            resolved_method);</span>
 157     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 158 
 159     kind = CallInfo::vtable_call;
 160   } else if (resolved_method-&gt;has_vtable_index()) {
 161     // Can occur if an interface redeclares a method of Object.
 162 
 163 #ifdef ASSERT
 164     // Ensure that this is really the case.
 165     Klass* object_klass = SystemDictionary::Object_klass();
 166     Method * object_resolved_method = object_klass-&gt;vtable().method_at(index);
 167     assert(object_resolved_method-&gt;name() == resolved_method-&gt;name(),
 168       &quot;Object and interface method names should match at vtable index %d, %s != %s&quot;,
 169       index, object_resolved_method-&gt;name()-&gt;as_C_string(), resolved_method-&gt;name()-&gt;as_C_string());
 170     assert(object_resolved_method-&gt;signature() == resolved_method-&gt;signature(),
 171       &quot;Object and interface method signatures should match at vtable index %d, %s != %s&quot;,
 172       index, object_resolved_method-&gt;signature()-&gt;as_C_string(), resolved_method-&gt;signature()-&gt;as_C_string());
 173 #endif // ASSERT
 174 
 175     kind = CallInfo::vtable_call;
 176   } else {
 177     // A regular interface call.
 178     kind = CallInfo::itable_call;
 179     index = resolved_method-&gt;itable_index();
 180   }
 181   assert(index == Method::nonvirtual_vtable_index || index &gt;= 0, &quot;bad index %d&quot;, index);
 182   _call_kind  = kind;
 183   _call_index = index;
 184   _resolved_appendix = Handle();
 185   // Find or create a ResolvedMethod instance for this Method*
 186   set_resolved_method_name(CHECK);
 187 
 188   DEBUG_ONLY(verify());
 189 }
 190 
 191 void CallInfo::set_resolved_method_name(TRAPS) {
<span class="line-modified"> 192   Method* m = _resolved_method();</span>
<span class="line-modified"> 193   assert(m != NULL, &quot;Should already have a Method*&quot;);</span>
<span class="line-removed"> 194   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);</span>
 195   _resolved_method_name = Handle(THREAD, rmethod_name);
 196 }
 197 
 198 #ifdef ASSERT
 199 void CallInfo::verify() {
 200   switch (call_kind()) {  // the meaning and allowed value of index depends on kind
 201   case CallInfo::direct_call:
 202     if (_call_index == Method::nonvirtual_vtable_index)  break;
 203     // else fall through to check vtable index:
 204   case CallInfo::vtable_call:
 205     assert(resolved_klass()-&gt;verify_vtable_index(_call_index), &quot;&quot;);
 206     break;
 207   case CallInfo::itable_call:
 208     assert(resolved_method()-&gt;method_holder()-&gt;verify_itable_index(_call_index), &quot;&quot;);
 209     break;
 210   case CallInfo::unknown_kind:
 211     assert(call_kind() != CallInfo::unknown_kind, &quot;CallInfo must be set&quot;);
 212     break;
 213   default:
 214     fatal(&quot;Unexpected call kind %d&quot;, call_kind());
</pre>
<hr />
<pre>
 247 
 248   // Coming from the constant pool always checks access
 249   _check_access  = true;
 250 }
 251 
 252 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, TRAPS) {
 253    // resolve klass
 254   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 255 
 256   // Get name, signature, and static klass
 257   _name          = pool-&gt;name_ref_at(index);
 258   _signature     = pool-&gt;signature_ref_at(index);
 259   _tag           = pool-&gt;tag_ref_at(index);
 260   _current_klass = pool-&gt;pool_holder();
 261   _current_method = methodHandle();
 262 
 263   // Coming from the constant pool always checks access
 264   _check_access  = true;
 265 }
 266 
<span class="line-removed"> 267 char* LinkInfo::method_string() const {</span>
<span class="line-removed"> 268   return Method::name_and_sig_as_C_string(_resolved_klass, _name, _signature);</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
 271 #ifndef PRODUCT
 272 void LinkInfo::print() {
 273   ResourceMark rm;
 274   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 275                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 276                 _name-&gt;as_C_string(),
 277                 _signature-&gt;as_C_string(),
 278                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 279                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 280 }
 281 #endif // PRODUCT
 282 //------------------------------------------------------------------------------------------------------------------------
 283 // Klass resolution
 284 
 285 void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,
 286                                              bool fold_type_to_class, TRAPS) {
 287   Klass* base_klass = sel_klass;
 288   if (fold_type_to_class) {
 289     if (sel_klass-&gt;is_objArray_klass()) {
 290       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();
</pre>
<hr />
<pre>
 368 
 369   if (result == NULL) {
 370     Array&lt;Method*&gt;* default_methods = ik-&gt;default_methods();
 371     if (default_methods != NULL) {
 372       result = InstanceKlass::find_method(default_methods, name, signature);
 373     }
 374   }
 375 
 376   if (checkpolymorphism &amp;&amp; result != NULL) {
 377     vmIntrinsics::ID iid = result-&gt;intrinsic_id();
 378     if (MethodHandles::is_signature_polymorphic(iid)) {
 379       // Do not link directly to these.  The VM must produce a synthetic one using lookup_polymorphic_method.
 380       return NULL;
 381     }
 382   }
 383   return result;
 384 }
 385 
 386 // returns first instance method
 387 // Looks up method in classes, then looks up local default methods
<span class="line-modified"> 388 methodHandle LinkResolver::lookup_instance_method_in_klasses(Klass* klass,</span>
<span class="line-modified"> 389                                                              Symbol* name,</span>
<span class="line-modified"> 390                                                              Symbol* signature,</span>
<span class="line-modified"> 391                                                              Klass::PrivateLookupMode private_mode, TRAPS) {</span>
 392   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 393 
 394   while (result != NULL &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
 395     Klass* super_klass = result-&gt;method_holder()-&gt;super();
 396     result = super_klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 397   }
 398 
 399   if (klass-&gt;is_array_klass()) {
 400     // Only consider klass and super klass for arrays
<span class="line-modified"> 401     return methodHandle(THREAD, result);</span>
 402   }
 403 
 404   if (result == NULL) {
 405     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass)-&gt;default_methods();
 406     if (default_methods != NULL) {
 407       result = InstanceKlass::find_method(default_methods, name, signature);
 408       assert(result == NULL || !result-&gt;is_static(), &quot;static defaults not allowed&quot;);
 409     }
 410   }
<span class="line-modified"> 411   return methodHandle(THREAD, result);</span>
 412 }
 413 
 414 int LinkResolver::vtable_index_of_interface_method(Klass* klass,
 415                                                    const methodHandle&amp; resolved_method) {
 416 
 417   int vtable_index = Method::invalid_vtable_index;
 418   Symbol* name = resolved_method-&gt;name();
 419   Symbol* signature = resolved_method-&gt;signature();
 420   InstanceKlass* ik = InstanceKlass::cast(klass);
 421 
 422   // First check in default method array
 423   if (!resolved_method-&gt;is_abstract() &amp;&amp; ik-&gt;default_methods() != NULL) {
 424     int index = InstanceKlass::find_method_index(ik-&gt;default_methods(),
 425                                                  name, signature, Klass::find_overpass,
 426                                                  Klass::find_static, Klass::find_private);
 427     if (index &gt;= 0 ) {
 428       vtable_index = ik-&gt;default_vtable_indices()-&gt;at(index);
 429     }
 430   }
 431   if (vtable_index == Method::invalid_vtable_index) {
 432     // get vtable_index for miranda methods
 433     klassVtable vt = ik-&gt;vtable();
 434     vtable_index = vt.index_of_miranda(name, signature);
 435   }
 436   return vtable_index;
 437 }
 438 
 439 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 440   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 441 
 442   // Specify &#39;true&#39; in order to skip default methods when searching the
 443   // interfaces.  Function lookup_method_in_klasses() already looked for
 444   // the method in the default methods table.
 445   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 446 }
 447 
<span class="line-modified"> 448 methodHandle LinkResolver::lookup_polymorphic_method(</span>
<span class="line-modified"> 449                                              const LinkInfo&amp; link_info,</span>
<span class="line-modified"> 450                                              Handle *appendix_result_or_null,</span>
<span class="line-removed"> 451                                              TRAPS) {</span>
 452   Klass* klass = link_info.resolved_klass();
 453   Symbol* name = link_info.name();
 454   Symbol* full_signature = link_info.signature();
 455 
 456   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
 457   if (TraceMethodHandles) {
 458     ResourceMark rm(THREAD);
 459     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,
 460                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),
 461                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());
 462   }
 463   if ((klass == SystemDictionary::MethodHandle_klass() ||
 464        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 465       iid != vmIntrinsics::_none) {
 466     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 467       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 468       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 469       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 470       TempNewSymbol basic_signature =
 471         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
 472       if (TraceMethodHandles) {
 473         ResourceMark rm(THREAD);
 474         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,
 475                       name-&gt;as_C_string(),
 476                       full_signature-&gt;as_C_string(),
 477                       basic_signature-&gt;as_C_string());
 478       }
<span class="line-modified"> 479       methodHandle result = SystemDictionary::find_method_handle_intrinsic(iid,</span>
 480                                                               basic_signature,
 481                                                               CHECK_NULL);
<span class="line-modified"> 482       if (result.not_null()) {</span>
 483         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 484         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 485         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
 486         if (TraceMethodHandles) {
 487           ttyLocker ttyl;
 488           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);
 489           result-&gt;print_on(tty);
 490         }
 491       }
 492       return result;
 493     } else if (iid == vmIntrinsics::_invokeGeneric
 494                &amp;&amp; THREAD-&gt;can_call_java()
 495                &amp;&amp; appendix_result_or_null != NULL) {
 496       // This is a method with type-checking semantics.
 497       // We will ask Java code to spin an adapter method for it.
 498       if (!MethodHandles::enabled()) {
 499         // Make sure the Java part of the runtime has been booted up.
 500         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 501         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 502           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 503                                             Handle(),
 504                                             Handle(),
 505                                             true,
 506                                             CHECK_NULL);
 507         }
 508       }
 509 
 510       Handle appendix;
 511       Handle method_type;
<span class="line-modified"> 512       methodHandle result = SystemDictionary::find_method_handle_invoker(</span>
 513                                                             klass,
 514                                                             name,
 515                                                             full_signature,
 516                                                             link_info.current_klass(),
 517                                                             &amp;appendix,
 518                                                             CHECK_NULL);
 519       if (TraceMethodHandles) {
 520         ttyLocker ttyl;
 521         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);
 522         result-&gt;print_on(tty);
 523         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);
 524         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);
 525         else                     appendix-&gt;print_on(tty);
 526       }
<span class="line-modified"> 527       if (result.not_null()) {</span>
 528 #ifdef ASSERT
 529         ResourceMark rm(THREAD);
 530 
 531         TempNewSymbol basic_signature =
 532           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 533         int actual_size_of_params = result-&gt;size_of_parameters();
 534         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 535         // +1 for MethodHandle.this, +1 for trailing MethodType
 536         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 537         if (appendix.not_null())                                   expected_size_of_params += 1;
 538         if (actual_size_of_params != expected_size_of_params) {
 539           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 540           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 541           result-&gt;print();
 542         }
 543         assert(actual_size_of_params == expected_size_of_params,
 544                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 545 #endif //ASSERT
 546 
 547         assert(appendix_result_or_null != NULL, &quot;&quot;);
</pre>
<hr />
<pre>
 576     jint new_flags = flags.as_int();
 577     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 578     new_flags = new_flags | JVM_ACC_PUBLIC;
 579     flags.set_flags(new_flags);
 580   }
 581 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 582 
 583   bool can_access = Reflection::verify_member_access(ref_klass,
 584                                                      resolved_klass,
 585                                                      sel_klass,
 586                                                      flags,
 587                                                      true, false, CHECK);
 588   // Any existing exceptions that may have been thrown, for example LinkageErrors
 589   // from nest-host resolution, have been allowed to propagate.
 590   if (!can_access) {
 591     ResourceMark rm(THREAD);
 592     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 593     Exceptions::fthrow(
 594       THREAD_AND_LOCATION,
 595       vmSymbols::java_lang_IllegalAccessError(),
<span class="line-modified"> 596       &quot;class %s tried to access %s%s%smethod %s.%s%s (%s%s%s)&quot;,</span>
 597       ref_klass-&gt;external_name(),
 598       sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,
 599       sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,
 600       sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,
<span class="line-modified"> 601       sel_klass-&gt;external_name(),</span>
<span class="line-removed"> 602       sel_method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-removed"> 603       sel_method-&gt;signature()-&gt;as_C_string(),</span>
 604       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 605       (same_module) ? &quot;&quot; : &quot;; &quot;,
 606       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 607     );
 608     return;
 609   }
 610 }
 611 
<span class="line-modified"> 612 methodHandle LinkResolver::resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified"> 613                                                      const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
 614   // This method is used only
 615   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 616   // and
 617   // (2) in Bytecode_invoke::static_target
 618   // It appears to fail when applied to an invokeinterface call site.
 619   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 620   // resolve klass
 621   if (code == Bytecodes::_invokedynamic) {
 622     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 623     Symbol* method_name = vmSymbols::invoke_name();
 624     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 625     Klass*  current_klass = pool-&gt;pool_holder();
 626     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 627     return resolve_method(link_info, code, THREAD);
 628   }
 629 
 630   LinkInfo link_info(pool, index, methodHandle(), CHECK_NULL);
 631   Klass* resolved_klass = link_info.resolved_klass();
 632 
 633   if (pool-&gt;has_preresolution()
 634       || (resolved_klass == SystemDictionary::MethodHandle_klass() &amp;&amp;
 635           MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
 636     Method* result = ConstantPool::method_at_if_loaded(pool, index);
 637     if (result != NULL) {
<span class="line-modified"> 638       return methodHandle(THREAD, result);</span>
 639     }
 640   }
 641 
 642   if (code == Bytecodes::_invokeinterface) {
 643     return resolve_interface_method(link_info, code, THREAD);
 644   } else if (code == Bytecodes::_invokevirtual) {
 645     return resolve_method(link_info, code, THREAD);
 646   } else if (!resolved_klass-&gt;is_interface()) {
 647     return resolve_method(link_info, code, THREAD);
 648   } else {
 649     return resolve_interface_method(link_info, code, THREAD);
 650   }
 651 }
 652 
 653 // Check and print a loader constraint violation message for method or interface method
 654 void LinkResolver::check_method_loader_constraints(const LinkInfo&amp; link_info,
 655                                                    const methodHandle&amp; resolved_method,
 656                                                    const char* method_type, TRAPS) {
 657   Handle current_loader(THREAD, link_info.current_klass()-&gt;class_loader());
 658   Handle resolved_loader(THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 659 
 660   ResourceMark rm(THREAD);
 661   Symbol* failed_type_symbol =
 662     SystemDictionary::check_signature_loaders(link_info.signature(), current_loader,
 663                                               resolved_loader, true, CHECK);
 664   if (failed_type_symbol != NULL) {
 665     Klass* current_class = link_info.current_klass();
 666     ClassLoaderData* current_loader_data = current_class-&gt;class_loader_data();
 667     assert(current_loader_data != NULL, &quot;current class has no class loader data&quot;);
 668     Klass* resolved_method_class = resolved_method-&gt;method_holder();
 669     ClassLoaderData* target_loader_data = resolved_method_class-&gt;class_loader_data();
 670     assert(target_loader_data != NULL, &quot;resolved method&#39;s class has no class loader data&quot;);
 671 
 672     stringStream ss;
<span class="line-modified"> 673     ss.print(&quot;loader constraint violation: when resolving %s&quot;</span>
<span class="line-modified"> 674              &quot; \&quot;%s\&quot; the class loader %s of the current class, %s,&quot;</span>

 675              &quot; and the class loader %s for the method&#39;s defining class, %s, have&quot;
 676              &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="line-removed"> 677              method_type,</span>
<span class="line-removed"> 678              link_info.method_string(),</span>
 679              current_loader_data-&gt;loader_name_and_id(),
 680              current_class-&gt;name()-&gt;as_C_string(),
 681              target_loader_data-&gt;loader_name_and_id(),
 682              resolved_method_class-&gt;name()-&gt;as_C_string(),
 683              failed_type_symbol-&gt;as_C_string(),
 684              current_class-&gt;class_in_module_of_loader(false, true),
 685              resolved_method_class-&gt;class_in_module_of_loader(false, true));
 686     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 687   }
 688 }
 689 
 690 void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,
 691                                                   Klass* current_klass,
 692                                                   Klass* sel_klass, TRAPS) {
 693   Handle ref_loader(THREAD, current_klass-&gt;class_loader());
 694   Handle sel_loader(THREAD, sel_klass-&gt;class_loader());
 695 
 696   ResourceMark rm(THREAD);  // needed for check_signature_loaders
 697   Symbol* failed_type_symbol =
 698     SystemDictionary::check_signature_loaders(sig,
</pre>
<hr />
<pre>
 704     const char* failed_type_name = failed_type_symbol-&gt;as_klass_external_name();
 705 
 706     ss.print(&quot;loader constraint violation: when resolving field \&quot;%s\&quot; of type %s, &quot;
 707              &quot;the class loader %s of the current class, %s, &quot;
 708              &quot;and the class loader %s for the field&#39;s defining %s, %s, &quot;
 709              &quot;have different Class objects for type %s (%s; %s)&quot;,
 710              field-&gt;as_C_string(),
 711              failed_type_name,
 712              current_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 713              current_klass-&gt;external_name(),
 714              sel_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 715              sel_klass-&gt;external_kind(),
 716              sel_klass-&gt;external_name(),
 717              failed_type_name,
 718              current_klass-&gt;class_in_module_of_loader(false, true),
 719              sel_klass-&gt;class_in_module_of_loader(false, true));
 720     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 721   }
 722 }
 723 
<span class="line-modified"> 724 methodHandle LinkResolver::resolve_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified"> 725                                           Bytecodes::Code code, TRAPS) {</span>
 726 
 727   Handle nested_exception;
 728   Klass* resolved_klass = link_info.resolved_klass();
 729 
 730   // 1. For invokevirtual, cannot call an interface method
 731   if (code == Bytecodes::_invokevirtual &amp;&amp; resolved_klass-&gt;is_interface()) {
 732     ResourceMark rm(THREAD);
 733     char buf[200];
 734     jio_snprintf(buf, sizeof(buf), &quot;Found interface %s, but class was expected&quot;,
 735         resolved_klass-&gt;external_name());
 736     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 737   }
 738 
 739   // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
 740   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_method()) {
 741     ResourceMark rm(THREAD);
<span class="line-modified"> 742     char buf[200];</span>
<span class="line-modified"> 743     jio_snprintf(buf, sizeof(buf), &quot;Method %s must be Methodref constant&quot;, link_info.method_string());</span>
<span class="line-modified"> 744     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>


 745   }
 746 
 747   // 3. lookup method in resolved klass and its super klasses
 748   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
 749 
 750   // 4. lookup method in all the interfaces implemented by the resolved klass
 751   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) { // not found in the class hierarchy
 752     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 753 
 754     if (resolved_method.is_null()) {
 755       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
<span class="line-modified"> 756       resolved_method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);</span>

 757       if (HAS_PENDING_EXCEPTION) {
 758         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
 759         CLEAR_PENDING_EXCEPTION;
 760       }
 761     }
 762   }
 763 
 764   // 5. method lookup failed
 765   if (resolved_method.is_null()) {
 766     ResourceMark rm(THREAD);




 767     THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
<span class="line-modified"> 768                     Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-removed"> 769                                                      link_info.name(),</span>
<span class="line-removed"> 770                                                      link_info.signature()),</span>
<span class="line-removed"> 771                     nested_exception, NULL);</span>
 772   }
 773 
 774   // 6. access checks, access checking may be turned off when calling from within the VM.
 775   Klass* current_klass = link_info.current_klass();
 776   if (link_info.check_access()) {
 777     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 778 
 779     // check if method can be accessed by the referring class
 780     check_method_accessability(current_klass,
 781                                resolved_klass,
 782                                resolved_method-&gt;method_holder(),
 783                                resolved_method,
 784                                CHECK_NULL);
 785 
 786     // check loader constraints
 787     check_method_loader_constraints(link_info, resolved_method, &quot;method&quot;, CHECK_NULL);
 788   }
 789 
<span class="line-modified"> 790   return resolved_method;</span>
 791 }
 792 
 793 static void trace_method_resolution(const char* prefix,
 794                                     Klass* klass,
 795                                     Klass* resolved_klass,
<span class="line-modified"> 796                                     const methodHandle&amp; method,</span>
 797                                     bool logitables,
 798                                     int index = -1) {
 799 #ifndef PRODUCT
 800   ResourceMark rm;
 801   Log(itables) logi;
 802   LogStream lsi(logi.trace());
 803   Log(vtables) logv;
 804   LogStream lsv(logv.trace());
 805   outputStream* st;
 806   if (logitables) {
 807     st = &amp;lsi;
 808   } else {
 809     st = &amp;lsv;
 810   }
 811   st-&gt;print(&quot;%s%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: &quot;,
 812             prefix,
 813             (klass == NULL ? &quot;&lt;NULL&gt;&quot; : klass-&gt;internal_name()),
 814             (resolved_klass == NULL ? &quot;&lt;NULL&gt;&quot; : resolved_klass-&gt;internal_name()),
 815             Method::name_and_sig_as_C_string(resolved_klass,
 816                                              method-&gt;name(),
 817                                              method-&gt;signature()),
 818             method-&gt;method_holder()-&gt;internal_name());
 819   method-&gt;print_linkage_flags(st);
 820   if (index != -1) {
 821     st-&gt;print(&quot;vtable_index:%d&quot;, index);
 822   }
 823   st-&gt;cr();
 824 #endif // PRODUCT
 825 }
 826 
 827 // Do linktime resolution of a method in the interface within the context of the specied bytecode.
<span class="line-modified"> 828 methodHandle LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {</span>
 829 
 830   Klass* resolved_klass = link_info.resolved_klass();
 831 
 832   // check if klass is interface
 833   if (!resolved_klass-&gt;is_interface()) {
 834     ResourceMark rm(THREAD);
 835     char buf[200];
 836     jio_snprintf(buf, sizeof(buf), &quot;Found class %s, but interface was expected&quot;, resolved_klass-&gt;external_name());
 837     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 838   }
 839 
 840   // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
 841   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_interface_method()) {
 842     ResourceMark rm(THREAD);
<span class="line-modified"> 843     char buf[200];</span>
<span class="line-modified"> 844     jio_snprintf(buf, sizeof(buf), &quot;Method %s must be InterfaceMethodref constant&quot;, link_info.method_string());</span>
<span class="line-modified"> 845     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>


 846   }
 847 
 848   // lookup method in this interface or its super, java.lang.Object
 849   // JDK8: also look for static methods
 850   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
 851 
 852   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) {
 853     // lookup method in all the super-interfaces
 854     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 855   }
 856 
 857   if (resolved_method.is_null()) {
 858     // no method found
 859     ResourceMark rm(THREAD);
<span class="line-modified"> 860     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(),</span>
<span class="line-modified"> 861                    Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified"> 862                                                     link_info.name(),</span>
<span class="line-modified"> 863                                                     link_info.signature()));</span>

 864   }
 865 
 866   if (link_info.check_access()) {
 867     // JDK8 adds non-public interface methods, and accessability check requirement
 868     Klass* current_klass = link_info.current_klass();
 869 
 870     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 871 
 872     // check if method can be accessed by the referring class
 873     check_method_accessability(current_klass,
 874                                resolved_klass,
 875                                resolved_method-&gt;method_holder(),
 876                                resolved_method,
 877                                CHECK_NULL);
 878 
 879     check_method_loader_constraints(link_info, resolved_method, &quot;interface method&quot;, CHECK_NULL);
 880   }
 881 
 882   if (code != Bytecodes::_invokestatic &amp;&amp; resolved_method-&gt;is_static()) {
 883     ResourceMark rm(THREAD);
<span class="line-modified"> 884     char buf[200];</span>
<span class="line-modified"> 885     jio_snprintf(buf, sizeof(buf), &quot;Expected instance not static method %s&quot;,</span>
<span class="line-modified"> 886                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified"> 887                  resolved_method-&gt;name(), resolved_method-&gt;signature()));</span>
<span class="line-modified"> 888     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>

 889   }
 890 
 891   if (log_develop_is_enabled(Trace, itables)) {
 892     char buf[200];
 893     jio_snprintf(buf, sizeof(buf), &quot;%s resolved interface method: caller-class:&quot;,
 894                  Bytecodes::name(code));
<span class="line-modified"> 895     trace_method_resolution(buf, link_info.current_klass(), resolved_klass,</span>
<span class="line-removed"> 896                             resolved_method, true);</span>
 897   }
 898 
<span class="line-modified"> 899   return resolved_method;</span>
 900 }
 901 
 902 //------------------------------------------------------------------------------------------------------------------------
 903 // Field resolution
 904 
 905 void LinkResolver::check_field_accessability(Klass* ref_klass,
 906                                              Klass* resolved_klass,
 907                                              Klass* sel_klass,
 908                                              const fieldDescriptor&amp; fd,
 909                                              TRAPS) {
 910   bool can_access = Reflection::verify_member_access(ref_klass,
 911                                                      resolved_klass,
 912                                                      sel_klass,
 913                                                      fd.access_flags(),
 914                                                      true, false, CHECK);
 915   // Any existing exceptions that may have been thrown, for example LinkageErrors
 916   // from nest-host resolution, have been allowed to propagate.
 917   if (!can_access) {
 918     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 919     ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 982       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 983       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 984     }
 985 
 986     // A final field can be modified only
 987     // (1) by methods declared in the class declaring the field and
 988     // (2) by the &lt;clinit&gt; method (in case of a static field)
 989     //     or by the &lt;init&gt; method (in case of an instance field).
 990     if (is_put &amp;&amp; fd.access_flags().is_final()) {
 991       ResourceMark rm(THREAD);
 992       stringStream ss;
 993 
 994       if (sel_klass != current_klass) {
 995         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
 996                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
 997                 current_klass-&gt;external_name());
 998         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
 999       }
1000 
1001       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
<span class="line-modified">1002         methodHandle m = link_info.current_method();</span>
<span class="line-modified">1003         assert(!m.is_null(), &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);</span>
1004         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1005                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1006                                                    !m()-&gt;is_static_initializer());</span>
1007         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1008                                                      !fd.is_static() &amp;&amp;
1009                                                      !m-&gt;is_object_initializer());
1010 
1011         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1012           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1013                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1014                    m()-&gt;name()-&gt;as_C_string(),</span>
1015                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1016           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1017         }
1018       }
1019     }
1020 
1021     // initialize resolved_klass if necessary
1022     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1023     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1024     //
1025     // note 2: we don&#39;t want to force initialization if we are just checking
1026     //         if the field access is legal; e.g., during compilation
1027     if (is_static &amp;&amp; initialize_class) {
1028       sel_klass-&gt;initialize(CHECK);
1029     }
1030   }
1031 
1032   if ((sel_klass != current_klass) &amp;&amp; (current_klass != NULL)) {
1033     check_field_loader_constraints(field, sig, current_klass, sel_klass, CHECK);
1034   }
1035 
1036   // return information. note that the klass is set to the actual klass containing the
1037   // field, otherwise access of static fields in superclasses will not work.
1038 }
1039 
1040 
1041 //------------------------------------------------------------------------------------------------------------------------
1042 // Invoke resolution
1043 //
1044 // Naming conventions:
1045 //
1046 // resolved_method    the specified method (i.e., static receiver specified via constant pool index)
1047 // sel_method         the selected method  (selected via run-time lookup; e.g., based on dynamic receiver class)
1048 // resolved_klass     the specified klass  (i.e., specified via constant pool index)
1049 // recv_klass         the receiver klass
1050 
1051 
1052 void LinkResolver::resolve_static_call(CallInfo&amp; result,
1053                                        const LinkInfo&amp; link_info,
1054                                        bool initialize_class, TRAPS) {
<span class="line-modified">1055   methodHandle resolved_method = linktime_resolve_static_method(link_info, CHECK);</span>
1056 
1057   // The resolved class can change as a result of this resolution.
1058   Klass* resolved_klass = resolved_method-&gt;method_holder();
1059 
1060   // Initialize klass (this should only happen if everything is ok)
1061   if (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) {
1062     resolved_klass-&gt;initialize(CHECK);
1063     // Use updated LinkInfo to reresolve with resolved method holder
1064     LinkInfo new_info(resolved_klass, link_info.name(), link_info.signature(),
1065                       link_info.current_klass(),
1066                       link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
1067     resolved_method = linktime_resolve_static_method(new_info, CHECK);
1068   }
1069 
1070   // setup result
<span class="line-modified">1071   result.set_static(resolved_klass, resolved_method, CHECK);</span>
1072 }
1073 
1074 // throws linktime exceptions
<span class="line-modified">1075 methodHandle LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {</span>
1076 
1077   Klass* resolved_klass = link_info.resolved_klass();
<span class="line-modified">1078   methodHandle resolved_method;</span>
1079   if (!resolved_klass-&gt;is_interface()) {
1080     resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1081   } else {
1082     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1083   }
1084   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), &quot;should have been checked in verifier&quot;);
1085 
1086   // check if static
1087   if (!resolved_method-&gt;is_static()) {
1088     ResourceMark rm(THREAD);
<span class="line-modified">1089     char buf[200];</span>
<span class="line-modified">1090     jio_snprintf(buf, sizeof(buf), &quot;Expected static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1091                                                       resolved_method-&gt;name(),</span>
<span class="line-modified">1092                                                       resolved_method-&gt;signature()));</span>
<span class="line-modified">1093     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1094   }
1095   return resolved_method;
1096 }
1097 
1098 
1099 void LinkResolver::resolve_special_call(CallInfo&amp; result,
1100                                         Handle recv,
1101                                         const LinkInfo&amp; link_info,
1102                                         TRAPS) {
<span class="line-modified">1103   methodHandle resolved_method = linktime_resolve_special_method(link_info, CHECK);</span>
<span class="line-modified">1104   runtime_resolve_special_method(result, link_info, resolved_method, recv, CHECK);</span>
1105 }
1106 
1107 // throws linktime exceptions
<span class="line-modified">1108 methodHandle LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info,</span>
<span class="line-removed">1109                                                            TRAPS) {</span>
1110 
1111   // Invokespecial is called for multiple special reasons:
1112   // &lt;init&gt;
1113   // local private method invocation, for classes and interfaces
1114   // superclass.method, which can also resolve to a default method
1115   // and the selected method is recalculated relative to the direct superclass
1116   // superinterface.method, which explicitly does not check shadowing
1117   Klass* resolved_klass = link_info.resolved_klass();
<span class="line-modified">1118   methodHandle resolved_method;</span>
1119 
1120   if (!resolved_klass-&gt;is_interface()) {
1121     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1122   } else {
1123     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1124   }
1125 
1126   // check if method name is &lt;init&gt;, that it is found in same klass as static type
1127   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1128       resolved_method-&gt;method_holder() != resolved_klass) {
1129     ResourceMark rm(THREAD);






1130     Exceptions::fthrow(
1131       THREAD_AND_LOCATION,
1132       vmSymbols::java_lang_NoSuchMethodError(),
<span class="line-modified">1133       &quot;%s: method %s%s not found&quot;,</span>
<span class="line-removed">1134       resolved_klass-&gt;external_name(),</span>
<span class="line-removed">1135       resolved_method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-removed">1136       resolved_method-&gt;signature()-&gt;as_C_string()</span>
<span class="line-removed">1137     );</span>
1138     return NULL;
1139   }
1140 
1141   // ensure that invokespecial&#39;s interface method reference is in
1142   // a direct superinterface, not an indirect superinterface
1143   Klass* current_klass = link_info.current_klass();
1144   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
1145     InstanceKlass* ck = InstanceKlass::cast(current_klass);
1146     InstanceKlass *klass_to_check = !ck-&gt;is_unsafe_anonymous() ?
1147                                     ck :
1148                                     ck-&gt;unsafe_anonymous_host();
1149     // Disable verification for the dynamically-generated reflection bytecodes.
1150     bool is_reflect = klass_to_check-&gt;is_subclass_of(
1151                         SystemDictionary::reflect_MagicAccessorImpl_klass());
1152 
1153     if (!is_reflect &amp;&amp;
1154         !klass_to_check-&gt;is_same_or_direct_interface(resolved_klass)) {
1155       ResourceMark rm(THREAD);
<span class="line-modified">1156       char buf[200];</span>
<span class="line-modified">1157       jio_snprintf(buf, sizeof(buf),</span>
<span class="line-modified">1158                    &quot;Interface method reference: %s, is in an indirect superinterface of %s&quot;,</span>
<span class="line-modified">1159                    Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1160                                                                            resolved_method-&gt;name(),</span>
<span class="line-modified">1161                                                                            resolved_method-&gt;signature()),</span>
<span class="line-removed">1162                    current_klass-&gt;external_name());</span>
<span class="line-removed">1163       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1164     }
1165   }
1166 
1167   // check if not static
1168   if (resolved_method-&gt;is_static()) {
1169     ResourceMark rm(THREAD);
<span class="line-modified">1170     char buf[200];</span>
<span class="line-modified">1171     jio_snprintf(buf, sizeof(buf),</span>
<span class="line-modified">1172                  &quot;Expecting non-static method %s&quot;,</span>
<span class="line-modified">1173                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1174                                                   resolved_method-&gt;name(),</span>
<span class="line-removed">1175                                                   resolved_method-&gt;signature()));</span>
<span class="line-removed">1176     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1177   }
1178 
1179   if (log_develop_is_enabled(Trace, itables)) {
1180     trace_method_resolution(&quot;invokespecial resolved method: caller-class:&quot;,
1181                             current_klass, resolved_klass, resolved_method, true);
1182   }
1183 
1184   return resolved_method;
1185 }
1186 
1187 // throws runtime exceptions
1188 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1189                                                   const LinkInfo&amp; link_info,
1190                                                   const methodHandle&amp; resolved_method,
1191                                                   Handle recv, TRAPS) {
1192 
1193   Klass* resolved_klass = link_info.resolved_klass();
1194 
1195   // resolved method is selected method unless we have an old-style lookup
1196   // for a superclass method
1197   // Invokespecial for a superinterface, resolved method is selected method,
1198   // no checks for shadowing
1199   methodHandle sel_method(THREAD, resolved_method());
1200 
1201   if (link_info.check_access() &amp;&amp;
1202       // check if the method is not &lt;init&gt;
1203       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1204 
1205     Klass* current_klass = link_info.current_klass();
1206 
1207     // Check if the class of the resolved_klass is a superclass
1208     // (not supertype in order to exclude interface classes) of the current class.
1209     // This check is not performed for super.invoke for interface methods
1210     // in super interfaces.
1211     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1212         current_klass != resolved_klass) {
1213       // Lookup super method
1214       Klass* super_klass = current_klass-&gt;super();
<span class="line-modified">1215       sel_method = lookup_instance_method_in_klasses(super_klass,</span>
1216                                                      resolved_method-&gt;name(),
1217                                                      resolved_method-&gt;signature(),
1218                                                      Klass::find_private, CHECK);


1219       // check if found
1220       if (sel_method.is_null()) {
1221         ResourceMark rm(THREAD);
<span class="line-modified">1222         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="line-modified">1223                   Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1224                                             resolved_method-&gt;name(),</span>
<span class="line-modified">1225                                             resolved_method-&gt;signature()));</span>

1226       // check loader constraints if found a different method
1227       } else if (sel_method() != resolved_method()) {
1228         check_method_loader_constraints(link_info, sel_method, &quot;method&quot;, CHECK);
1229       }
1230     }
1231 
1232     // Check that the class of objectref (the receiver) is the current class or interface,
1233     // or a subtype of the current class or interface (the sender), otherwise invokespecial
1234     // throws IllegalAccessError.
1235     // The verifier checks that the sender is a subtype of the class in the I/MR operand.
1236     // The verifier also checks that the receiver is a subtype of the sender, if the sender is
1237     // a class.  If the sender is an interface, the check has to be performed at runtime.
1238     InstanceKlass* sender = InstanceKlass::cast(current_klass);
1239     sender = sender-&gt;is_unsafe_anonymous() ? sender-&gt;unsafe_anonymous_host() : sender;
1240     if (sender-&gt;is_interface() &amp;&amp; recv.not_null()) {
1241       Klass* receiver_klass = recv-&gt;klass();
1242       if (!receiver_klass-&gt;is_subtype_of(sender)) {
1243         ResourceMark rm(THREAD);
1244         char buf[500];
1245         jio_snprintf(buf, sizeof(buf),
1246                      &quot;Receiver class %s must be the current class or a subtype of interface %s&quot;,
<span class="line-modified">1247                      receiver_klass-&gt;name()-&gt;as_C_string(),</span>
<span class="line-modified">1248                      sender-&gt;name()-&gt;as_C_string());</span>
1249         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
1250       }
1251     }
1252   }
1253 
1254   // check if not static
1255   if (sel_method-&gt;is_static()) {
1256     ResourceMark rm(THREAD);
<span class="line-modified">1257     char buf[200];</span>
<span class="line-modified">1258     jio_snprintf(buf, sizeof(buf), &quot;Expecting non-static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1259                                                                                       resolved_method-&gt;name(),</span>
<span class="line-modified">1260                                                                                       resolved_method-&gt;signature()));</span>
<span class="line-modified">1261     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1262   }
1263 
1264   // check if abstract
1265   if (sel_method-&gt;is_abstract()) {
1266     ResourceMark rm(THREAD);
<span class="line-modified">1267     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="line-modified">1268               Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1269                                                sel_method-&gt;name(),</span>
<span class="line-modified">1270                                                sel_method-&gt;signature()));</span>

1271   }
1272 
1273   if (log_develop_is_enabled(Trace, itables)) {
1274     trace_method_resolution(&quot;invokespecial selected method: resolved-class:&quot;,
<span class="line-modified">1275                             resolved_klass, resolved_klass, sel_method, true);</span>
1276   }
1277 
1278   // setup result
1279   result.set_static(resolved_klass, sel_method, CHECK);
1280 }
1281 
1282 void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, Klass* receiver_klass,
1283                                         const LinkInfo&amp; link_info,
1284                                         bool check_null_and_abstract, TRAPS) {
<span class="line-modified">1285   methodHandle resolved_method = linktime_resolve_virtual_method(link_info, CHECK);</span>
<span class="line-modified">1286   runtime_resolve_virtual_method(result, resolved_method,</span>
1287                                  link_info.resolved_klass(),
1288                                  recv, receiver_klass,
1289                                  check_null_and_abstract, CHECK);
1290 }
1291 
1292 // throws linktime exceptions
<span class="line-modified">1293 methodHandle LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,</span>
1294                                                            TRAPS) {
1295   // normal method resolution
<span class="line-modified">1296   methodHandle resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);</span>
1297 
1298   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1299   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1300 
1301   // check if private interface method
1302   Klass* resolved_klass = link_info.resolved_klass();
1303   Klass* current_klass = link_info.current_klass();
1304 
1305   // This is impossible, if resolve_klass is an interface, we&#39;ve thrown icce in resolve_method
1306   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1307     ResourceMark rm(THREAD);
<span class="line-modified">1308     char buf[200];</span>
<span class="line-modified">1309     jio_snprintf(buf, sizeof(buf), &quot;private interface method requires invokespecial, not invokevirtual: method %s, caller-class:%s&quot;,</span>
<span class="line-modified">1310                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1311                                                   resolved_method-&gt;name(),</span>
<span class="line-modified">1312                                                   resolved_method-&gt;signature()),</span>
<span class="line-modified">1313                    (current_klass == NULL ? &quot;&lt;NULL&gt;&quot; : current_klass-&gt;internal_name()));</span>
<span class="line-removed">1314     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1315   }
1316 
1317   // check if not static
1318   if (resolved_method-&gt;is_static()) {
1319     ResourceMark rm(THREAD);
<span class="line-modified">1320     char buf[200];</span>
<span class="line-modified">1321     jio_snprintf(buf, sizeof(buf), &quot;Expecting non-static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="line-modified">1322                                                                                            resolved_method-&gt;name(),</span>
<span class="line-modified">1323                                                                                            resolved_method-&gt;signature()));</span>
<span class="line-modified">1324     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
1325   }
1326 
1327   if (log_develop_is_enabled(Trace, vtables)) {
1328     trace_method_resolution(&quot;invokevirtual resolved method: caller-class:&quot;,
1329                             current_klass, resolved_klass, resolved_method, false);
1330   }
1331 
1332   return resolved_method;
1333 }
1334 
1335 // throws runtime exceptions
1336 void LinkResolver::runtime_resolve_virtual_method(CallInfo&amp; result,
1337                                                   const methodHandle&amp; resolved_method,
1338                                                   Klass* resolved_klass,
1339                                                   Handle recv,
1340                                                   Klass* recv_klass,
1341                                                   bool check_null_and_abstract,
1342                                                   TRAPS) {
1343 
1344   // setup default return values
</pre>
<hr />
<pre>
1376       assert(resolved_method-&gt;can_be_statically_bound(), &quot;cannot override this method&quot;);
1377       selected_method = resolved_method;
1378     } else {
1379       selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1380     }
1381   }
1382 
1383   // check if method exists
1384   if (selected_method.is_null()) {
1385     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1386   }
1387 
1388   // check if abstract
1389   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1390     // Pass arguments for generating a verbose error message.
1391     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1392   }
1393 
1394   if (log_develop_is_enabled(Trace, vtables)) {
1395     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
<span class="line-modified">1396                             recv_klass, resolved_klass, selected_method,</span>
1397                             false, vtable_index);
1398   }
1399   // setup result
1400   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
1401 }
1402 
1403 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1404                                           const LinkInfo&amp; link_info,
1405                                           bool check_null_and_abstract, TRAPS) {
1406   // throws linktime exceptions
<span class="line-modified">1407   methodHandle resolved_method = linktime_resolve_interface_method(link_info, CHECK);</span>
<span class="line-modified">1408   runtime_resolve_interface_method(result, resolved_method,link_info.resolved_klass(),</span>

1409                                    recv, recv_klass, check_null_and_abstract, CHECK);
1410 }
1411 
<span class="line-modified">1412 methodHandle LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,</span>
1413                                                              TRAPS) {
1414   // normal interface method resolution
<span class="line-modified">1415   methodHandle resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);</span>
1416   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1417   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1418 
1419   return resolved_method;
1420 }
1421 
1422 // throws runtime exceptions
1423 void LinkResolver::runtime_resolve_interface_method(CallInfo&amp; result,
1424                                                     const methodHandle&amp; resolved_method,
1425                                                     Klass* resolved_klass,
1426                                                     Handle recv,
1427                                                     Klass* recv_klass,
1428                                                     bool check_null_and_abstract, TRAPS) {
1429 
1430   // check if receiver exists
1431   if (check_null_and_abstract &amp;&amp; recv.is_null()) {
1432     THROW(vmSymbols::java_lang_NullPointerException());
1433   }
1434 
1435   // check if receiver klass implements the resolved interface
1436   if (!recv_klass-&gt;is_subtype_of(resolved_klass)) {
1437     ResourceMark rm(THREAD);
1438     char buf[200];
1439     jio_snprintf(buf, sizeof(buf), &quot;Class %s does not implement the requested interface %s&quot;,
1440                  recv_klass-&gt;external_name(),
1441                  resolved_klass-&gt;external_name());
1442     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1443   }
1444 
1445   methodHandle selected_method = resolved_method;
1446 
1447   // resolve the method in the receiver class, unless it is private
1448   if (!resolved_method()-&gt;is_private()) {
1449     // do lookup based on receiver klass
1450     // This search must match the linktime preparation search for itable initialization
1451     // to correctly enforce loader constraints for interface method inheritance.
1452     // Private methods are skipped as the resolved method was not private.
<span class="line-modified">1453     selected_method = lookup_instance_method_in_klasses(recv_klass,</span>
<span class="line-modified">1454                                                         resolved_method-&gt;name(),</span>
<span class="line-modified">1455                                                         resolved_method-&gt;signature(),</span>
<span class="line-modified">1456                                                         Klass::skip_private, CHECK);</span>

1457 
1458     if (selected_method.is_null() &amp;&amp; !check_null_and_abstract) {
1459       // In theory this is a harmless placeholder value, but
1460       // in practice leaving in null affects the nsk default method tests.
1461       // This needs further study.
1462       selected_method = resolved_method;
1463     }
1464     // check if method exists
1465     if (selected_method.is_null()) {
1466       // Pass arguments for generating a verbose error message.
1467       throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1468     }
1469     // check access
1470     // Throw Illegal Access Error if selected_method is not public.
1471     if (!selected_method-&gt;is_public()) {
1472       ResourceMark rm(THREAD);
<span class="line-modified">1473       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="line-modified">1474                 Method::name_and_sig_as_C_string(recv_klass,</span>
<span class="line-modified">1475                                                  selected_method-&gt;name(),</span>
<span class="line-modified">1476                                                  selected_method-&gt;signature()));</span>

1477     }
1478     // check if abstract
1479     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1480       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1481     }
1482   }
1483 
1484   if (log_develop_is_enabled(Trace, itables)) {
1485     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
<span class="line-modified">1486                             recv_klass, resolved_klass, selected_method, true);</span>
1487   }
1488   // setup result
1489   if (resolved_method-&gt;has_vtable_index()) {
1490     int vtable_index = resolved_method-&gt;vtable_index();
1491     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1492     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
1493     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
1494   } else if (resolved_method-&gt;has_itable_index()) {
1495     int itable_index = resolved_method()-&gt;itable_index();
1496     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
1497     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);
1498   } else {
1499     int index = resolved_method-&gt;vtable_index();
1500     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1501     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1502     assert(resolved_method()-&gt;is_private() ||
1503            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1504            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1505     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1506     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
1507     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);
1508   }
1509 }
1510 
1511 
<span class="line-modified">1512 methodHandle LinkResolver::linktime_resolve_interface_method_or_null(</span>
1513                                                  const LinkInfo&amp; link_info) {
1514   EXCEPTION_MARK;
<span class="line-modified">1515   methodHandle method_result = linktime_resolve_interface_method(link_info, THREAD);</span>
1516   if (HAS_PENDING_EXCEPTION) {
1517     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1518     return methodHandle();</span>
1519   } else {
1520     return method_result;
1521   }
1522 }
1523 
<span class="line-modified">1524 methodHandle LinkResolver::linktime_resolve_virtual_method_or_null(</span>
1525                                                  const LinkInfo&amp; link_info) {
1526   EXCEPTION_MARK;
<span class="line-modified">1527   methodHandle method_result = linktime_resolve_virtual_method(link_info, THREAD);</span>
1528   if (HAS_PENDING_EXCEPTION) {
1529     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1530     return methodHandle();</span>
1531   } else {
1532     return method_result;
1533   }
1534 }
1535 
<span class="line-modified">1536 methodHandle LinkResolver::resolve_virtual_call_or_null(</span>
1537                                                  Klass* receiver_klass,
1538                                                  const LinkInfo&amp; link_info) {
1539   EXCEPTION_MARK;
1540   CallInfo info;
1541   resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1542   if (HAS_PENDING_EXCEPTION) {
1543     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1544     return methodHandle();</span>
1545   }
1546   return info.selected_method();
1547 }
1548 
<span class="line-modified">1549 methodHandle LinkResolver::resolve_interface_call_or_null(</span>
1550                                                  Klass* receiver_klass,
1551                                                  const LinkInfo&amp; link_info) {
1552   EXCEPTION_MARK;
1553   CallInfo info;
1554   resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1555   if (HAS_PENDING_EXCEPTION) {
1556     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1557     return methodHandle();</span>
1558   }
1559   return info.selected_method();
1560 }
1561 
1562 int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
1563                                                const LinkInfo&amp; link_info) {
1564   EXCEPTION_MARK;
1565   CallInfo info;
1566   resolve_virtual_call(info, Handle(), receiver_klass, link_info,
1567                        /*check_null_or_abstract*/false, THREAD);
1568   if (HAS_PENDING_EXCEPTION) {
1569     CLEAR_PENDING_EXCEPTION;
1570     return Method::invalid_vtable_index;
1571   }
1572   return info.vtable_index();
1573 }
1574 
<span class="line-modified">1575 methodHandle LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {</span>
1576   EXCEPTION_MARK;
1577   CallInfo info;
1578   resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
1579   if (HAS_PENDING_EXCEPTION) {
1580     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1581     return methodHandle();</span>
1582   }
1583   return info.selected_method();
1584 }
1585 
<span class="line-modified">1586 methodHandle LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {</span>
1587   EXCEPTION_MARK;
1588   CallInfo info;
1589   resolve_special_call(info, Handle(), link_info, THREAD);
1590   if (HAS_PENDING_EXCEPTION) {
1591     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1592     return methodHandle();</span>
1593   }
1594   return info.selected_method();
1595 }
1596 
1597 
1598 
1599 //------------------------------------------------------------------------------------------------------------------------
1600 // ConstantPool entries
1601 
1602 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1603   switch (byte) {
1604     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1605     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1606     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1607     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1608     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1609     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1610     default                         :                                                            break;
1611   }
1612   return;
</pre>
<hr />
<pre>
1673 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1674   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1675   LinkInfo link_info(pool, index, CHECK);
1676   if (TraceMethodHandles) {
1677     ResourceMark rm(THREAD);
1678     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),
1679                   link_info.signature()-&gt;as_C_string());
1680   }
1681   resolve_handle_call(result, link_info, CHECK);
1682 }
1683 
1684 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1685                                        const LinkInfo&amp; link_info,
1686                                        TRAPS) {
1687   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1688   Klass* resolved_klass = link_info.resolved_klass();
1689   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1690          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1691   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1692   Handle       resolved_appendix;
<span class="line-modified">1693   methodHandle resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);</span>
<span class="line-modified">1694   result.set_handle(resolved_klass, resolved_method, resolved_appendix, CHECK);</span>
1695 }
1696 
<span class="line-modified">1697 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
<span class="line-modified">1698   Symbol* method_name       = pool-&gt;name_ref_at(index);</span>
<span class="line-removed">1699   Symbol* method_signature  = pool-&gt;signature_ref_at(index);</span>
<span class="line-removed">1700   Klass* current_klass = pool-&gt;pool_holder();</span>
<span class="line-removed">1701 </span>
<span class="line-removed">1702   // Resolve the bootstrap specifier (BSM + optional arguments).</span>
<span class="line-removed">1703   Handle bootstrap_specifier;</span>
<span class="line-removed">1704   // Check if CallSite has been bound already:</span>
<span class="line-removed">1705   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
1706   int pool_index = cpce-&gt;constant_pool_index();
1707 
<span class="line-modified">1708   if (cpce-&gt;is_f1_null()) {</span>
<span class="line-modified">1709     if (cpce-&gt;indy_resolution_failed()) {</span>
<span class="line-removed">1710       ConstantPool::throw_resolution_error(pool,</span>
<span class="line-removed">1711                                            ResolutionErrorTable::encode_cpcache_index(index),</span>
<span class="line-removed">1712                                            CHECK);</span>
<span class="line-removed">1713     }</span>
1714 
<span class="line-modified">1715     // The initial step in Call Site Specifier Resolution is to resolve the symbolic</span>
<span class="line-modified">1716     // reference to a method handle which will be the bootstrap method for a dynamic</span>
<span class="line-modified">1717     // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap</span>
<span class="line-modified">1718     // method fails, then a MethodHandleInError is stored at the corresponding bootstrap</span>
<span class="line-removed">1719     // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to</span>
<span class="line-removed">1720     // set the indy_rf flag since any subsequent invokedynamic instruction which shares</span>
<span class="line-removed">1721     // this bootstrap method will encounter the resolution of MethodHandleInError.</span>
<span class="line-removed">1722     oop bsm_info = pool-&gt;resolve_bootstrap_specifier_at(pool_index, THREAD);</span>
<span class="line-removed">1723     Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="line-removed">1724     assert(bsm_info != NULL, &quot;&quot;);</span>
<span class="line-removed">1725     // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_InvokeDynamic.</span>
<span class="line-removed">1726     bootstrap_specifier = Handle(THREAD, bsm_info);</span>
<span class="line-removed">1727   }</span>
<span class="line-removed">1728   if (!cpce-&gt;is_f1_null()) {</span>
<span class="line-removed">1729     methodHandle method(     THREAD, cpce-&gt;f1_as_method());</span>
<span class="line-removed">1730     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(pool));</span>
<span class="line-removed">1731     result.set_handle(method, appendix, THREAD);</span>
<span class="line-removed">1732     Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="line-removed">1733     return;</span>
1734   }
1735 










1736   if (TraceMethodHandles) {
<span class="line-modified">1737     ResourceMark rm(THREAD);</span>
<span class="line-removed">1738     tty-&gt;print_cr(&quot;resolve_invokedynamic #%d %s %s in %s&quot;,</span>
<span class="line-removed">1739                   ConstantPool::decode_invokedynamic_index(index),</span>
<span class="line-removed">1740                   method_name-&gt;as_C_string(), method_signature-&gt;as_C_string(),</span>
<span class="line-removed">1741                   current_klass-&gt;name()-&gt;as_C_string());</span>
<span class="line-removed">1742     tty-&gt;print(&quot;  BSM info: &quot;); bootstrap_specifier-&gt;print();</span>
<span class="line-removed">1743   }</span>
<span class="line-removed">1744 </span>
<span class="line-removed">1745   resolve_dynamic_call(result, pool_index, bootstrap_specifier, method_name,</span>
<span class="line-removed">1746                        method_signature, current_klass, THREAD);</span>
<span class="line-removed">1747   if (HAS_PENDING_EXCEPTION &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {</span>
<span class="line-removed">1748     int encoded_index = ResolutionErrorTable::encode_cpcache_index(index);</span>
<span class="line-removed">1749     bool recorded_res_status = cpce-&gt;save_and_throw_indy_exc(pool, pool_index,</span>
<span class="line-removed">1750                                                              encoded_index,</span>
<span class="line-removed">1751                                                              pool()-&gt;tag_at(pool_index),</span>
<span class="line-removed">1752                                                              CHECK);</span>
<span class="line-removed">1753     if (!recorded_res_status) {</span>
<span class="line-removed">1754       // Another thread got here just before we did.  So, either use the method</span>
<span class="line-removed">1755       // that it resolved or throw the LinkageError exception that it threw.</span>
<span class="line-removed">1756       if (!cpce-&gt;is_f1_null()) {</span>
<span class="line-removed">1757         methodHandle method(     THREAD, cpce-&gt;f1_as_method());</span>
<span class="line-removed">1758         Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(pool));</span>
<span class="line-removed">1759         result.set_handle(method, appendix, THREAD);</span>
<span class="line-removed">1760         Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="line-removed">1761       } else {</span>
<span class="line-removed">1762         assert(cpce-&gt;indy_resolution_failed(), &quot;Resolution failure flag not set&quot;);</span>
<span class="line-removed">1763         ConstantPool::throw_resolution_error(pool, encoded_index, CHECK);</span>
<span class="line-removed">1764       }</span>
<span class="line-removed">1765       return;</span>
<span class="line-removed">1766     }</span>
<span class="line-removed">1767     assert(cpce-&gt;indy_resolution_failed(), &quot;Resolution failure flag wasn&#39;t set&quot;);</span>
1768   }







1769 }
1770 
1771 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
<span class="line-modified">1772                                         int pool_index,</span>
<span class="line-removed">1773                                         Handle bootstrap_specifier,</span>
<span class="line-removed">1774                                         Symbol* method_name, Symbol* method_signature,</span>
<span class="line-removed">1775                                         Klass* current_klass,</span>
1776                                         TRAPS) {
<span class="line-modified">1777   // JSR 292:  this must resolve to an implicitly generated method MH.linkToCallSite(*...)</span>

1778   // The appendix argument is likely to be a freshly-created CallSite.
<span class="line-modified">1779   Handle       resolved_appendix;</span>
<span class="line-modified">1780   methodHandle resolved_method =</span>
<span class="line-modified">1781     SystemDictionary::find_dynamic_call_site_invoker(current_klass,</span>
<span class="line-modified">1782                                                      pool_index,</span>
<span class="line-modified">1783                                                      bootstrap_specifier,</span>
<span class="line-modified">1784                                                      method_name, method_signature,</span>
<span class="line-modified">1785                                                      &amp;resolved_appendix,</span>
<span class="line-modified">1786                                                      THREAD);</span>
<span class="line-modified">1787   Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="line-modified">1788   result.set_handle(resolved_method, resolved_appendix, THREAD);</span>
<span class="line-modified">1789   Exceptions::wrap_dynamic_exception(CHECK);</span>






















1790 }
1791 
1792 // Selected method is abstract.
1793 void LinkResolver::throw_abstract_method_error(const methodHandle&amp; resolved_method,
1794                                                const methodHandle&amp; selected_method,
1795                                                Klass *recv_klass, TRAPS) {
1796   Klass *resolved_klass = resolved_method-&gt;method_holder();
1797   ResourceMark rm(THREAD);
1798   stringStream ss;
1799 
1800   if (recv_klass != NULL) {
1801     ss.print(&quot;Receiver class %s does not define or inherit an &quot;
1802              &quot;implementation of the&quot;,
1803              recv_klass-&gt;external_name());
1804   } else {
1805     ss.print(&quot;Missing implementation of&quot;);
1806   }
1807 
1808   assert(resolved_method.not_null(), &quot;Sanity&quot;);
<span class="line-modified">1809   ss.print(&quot; resolved method %s%s%s%s of %s %s.&quot;,</span>
1810            resolved_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="line-modified">1811            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;,</span>
<span class="line-modified">1812            resolved_method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-modified">1813            resolved_method-&gt;signature()-&gt;as_C_string(),</span>


1814            resolved_klass-&gt;external_kind(),
1815            resolved_klass-&gt;external_name());
1816 
1817   if (selected_method.not_null() &amp;&amp; !(resolved_method == selected_method)) {
<span class="line-modified">1818     ss.print(&quot; Selected method is %s%s%s.&quot;,</span>
1819              selected_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="line-modified">1820              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;,</span>
<span class="line-modified">1821              selected_method-&gt;name_and_sig_as_C_string());</span>

1822   }
1823 
1824   THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1825 }
</pre>
</td>
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/resolutionErrors.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
<span class="line-added">  33 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  34 #include &quot;compiler/compileBroker.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
<span class="line-added">  36 #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  39 #include &quot;interpreter/linkResolver.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;

  43 #include &quot;oops/constantPool.hpp&quot;
  44 #include &quot;oops/cpCache.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/method.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;

  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
  67   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
</pre>
<hr />
<pre>
 123   _resolved_klass  = resolved_klass;
 124   _selected_klass  = selected_klass;
 125   _resolved_method = resolved_method;
 126   _selected_method = selected_method;
 127   _call_kind       = kind;
 128   _call_index      = index;
 129   _resolved_appendix = Handle();
 130   DEBUG_ONLY(verify());  // verify before making side effects
 131 
 132   CompilationPolicy::compile_if_required(selected_method, THREAD);
 133 }
 134 
 135 // utility query for unreflecting a method
 136 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 137   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 138   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 139     resolved_klass = resolved_method_holder;
 140   }
 141   _resolved_klass  = resolved_klass;
 142   _selected_klass  = resolved_klass;
<span class="line-modified"> 143   _resolved_method = methodHandle(THREAD, resolved_method);</span>
<span class="line-modified"> 144   _selected_method = methodHandle(THREAD, resolved_method);</span>
 145   // classify:
 146   CallKind kind = CallInfo::unknown_kind;
 147   int index = resolved_method-&gt;vtable_index();
 148   if (resolved_method-&gt;can_be_statically_bound()) {
 149     kind = CallInfo::direct_call;
 150   } else if (!resolved_method_holder-&gt;is_interface()) {
 151     // Could be an Object method inherited into an interface, but still a vtable call.
 152     kind = CallInfo::vtable_call;
 153   } else if (!resolved_klass-&gt;is_interface()) {
 154     // A default or miranda method.  Compute the vtable index.
 155     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
<span class="line-modified"> 156                            _resolved_method);</span>
 157     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 158 
 159     kind = CallInfo::vtable_call;
 160   } else if (resolved_method-&gt;has_vtable_index()) {
 161     // Can occur if an interface redeclares a method of Object.
 162 
 163 #ifdef ASSERT
 164     // Ensure that this is really the case.
 165     Klass* object_klass = SystemDictionary::Object_klass();
 166     Method * object_resolved_method = object_klass-&gt;vtable().method_at(index);
 167     assert(object_resolved_method-&gt;name() == resolved_method-&gt;name(),
 168       &quot;Object and interface method names should match at vtable index %d, %s != %s&quot;,
 169       index, object_resolved_method-&gt;name()-&gt;as_C_string(), resolved_method-&gt;name()-&gt;as_C_string());
 170     assert(object_resolved_method-&gt;signature() == resolved_method-&gt;signature(),
 171       &quot;Object and interface method signatures should match at vtable index %d, %s != %s&quot;,
 172       index, object_resolved_method-&gt;signature()-&gt;as_C_string(), resolved_method-&gt;signature()-&gt;as_C_string());
 173 #endif // ASSERT
 174 
 175     kind = CallInfo::vtable_call;
 176   } else {
 177     // A regular interface call.
 178     kind = CallInfo::itable_call;
 179     index = resolved_method-&gt;itable_index();
 180   }
 181   assert(index == Method::nonvirtual_vtable_index || index &gt;= 0, &quot;bad index %d&quot;, index);
 182   _call_kind  = kind;
 183   _call_index = index;
 184   _resolved_appendix = Handle();
 185   // Find or create a ResolvedMethod instance for this Method*
 186   set_resolved_method_name(CHECK);
 187 
 188   DEBUG_ONLY(verify());
 189 }
 190 
 191 void CallInfo::set_resolved_method_name(TRAPS) {
<span class="line-modified"> 192   assert(_resolved_method() != NULL, &quot;Should already have a Method*&quot;);</span>
<span class="line-modified"> 193   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(_resolved_method, CHECK);</span>

 194   _resolved_method_name = Handle(THREAD, rmethod_name);
 195 }
 196 
 197 #ifdef ASSERT
 198 void CallInfo::verify() {
 199   switch (call_kind()) {  // the meaning and allowed value of index depends on kind
 200   case CallInfo::direct_call:
 201     if (_call_index == Method::nonvirtual_vtable_index)  break;
 202     // else fall through to check vtable index:
 203   case CallInfo::vtable_call:
 204     assert(resolved_klass()-&gt;verify_vtable_index(_call_index), &quot;&quot;);
 205     break;
 206   case CallInfo::itable_call:
 207     assert(resolved_method()-&gt;method_holder()-&gt;verify_itable_index(_call_index), &quot;&quot;);
 208     break;
 209   case CallInfo::unknown_kind:
 210     assert(call_kind() != CallInfo::unknown_kind, &quot;CallInfo must be set&quot;);
 211     break;
 212   default:
 213     fatal(&quot;Unexpected call kind %d&quot;, call_kind());
</pre>
<hr />
<pre>
 246 
 247   // Coming from the constant pool always checks access
 248   _check_access  = true;
 249 }
 250 
 251 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, TRAPS) {
 252    // resolve klass
 253   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 254 
 255   // Get name, signature, and static klass
 256   _name          = pool-&gt;name_ref_at(index);
 257   _signature     = pool-&gt;signature_ref_at(index);
 258   _tag           = pool-&gt;tag_ref_at(index);
 259   _current_klass = pool-&gt;pool_holder();
 260   _current_method = methodHandle();
 261 
 262   // Coming from the constant pool always checks access
 263   _check_access  = true;
 264 }
 265 




 266 #ifndef PRODUCT
 267 void LinkInfo::print() {
 268   ResourceMark rm;
 269   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 270                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 271                 _name-&gt;as_C_string(),
 272                 _signature-&gt;as_C_string(),
 273                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 274                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 275 }
 276 #endif // PRODUCT
 277 //------------------------------------------------------------------------------------------------------------------------
 278 // Klass resolution
 279 
 280 void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,
 281                                              bool fold_type_to_class, TRAPS) {
 282   Klass* base_klass = sel_klass;
 283   if (fold_type_to_class) {
 284     if (sel_klass-&gt;is_objArray_klass()) {
 285       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();
</pre>
<hr />
<pre>
 363 
 364   if (result == NULL) {
 365     Array&lt;Method*&gt;* default_methods = ik-&gt;default_methods();
 366     if (default_methods != NULL) {
 367       result = InstanceKlass::find_method(default_methods, name, signature);
 368     }
 369   }
 370 
 371   if (checkpolymorphism &amp;&amp; result != NULL) {
 372     vmIntrinsics::ID iid = result-&gt;intrinsic_id();
 373     if (MethodHandles::is_signature_polymorphic(iid)) {
 374       // Do not link directly to these.  The VM must produce a synthetic one using lookup_polymorphic_method.
 375       return NULL;
 376     }
 377   }
 378   return result;
 379 }
 380 
 381 // returns first instance method
 382 // Looks up method in classes, then looks up local default methods
<span class="line-modified"> 383 Method* LinkResolver::lookup_instance_method_in_klasses(Klass* klass,</span>
<span class="line-modified"> 384                                                         Symbol* name,</span>
<span class="line-modified"> 385                                                         Symbol* signature,</span>
<span class="line-modified"> 386                                                         Klass::PrivateLookupMode private_mode, TRAPS) {</span>
 387   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 388 
 389   while (result != NULL &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
 390     Klass* super_klass = result-&gt;method_holder()-&gt;super();
 391     result = super_klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 392   }
 393 
 394   if (klass-&gt;is_array_klass()) {
 395     // Only consider klass and super klass for arrays
<span class="line-modified"> 396     return result;</span>
 397   }
 398 
 399   if (result == NULL) {
 400     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass)-&gt;default_methods();
 401     if (default_methods != NULL) {
 402       result = InstanceKlass::find_method(default_methods, name, signature);
 403       assert(result == NULL || !result-&gt;is_static(), &quot;static defaults not allowed&quot;);
 404     }
 405   }
<span class="line-modified"> 406   return result;</span>
 407 }
 408 
 409 int LinkResolver::vtable_index_of_interface_method(Klass* klass,
 410                                                    const methodHandle&amp; resolved_method) {
 411 
 412   int vtable_index = Method::invalid_vtable_index;
 413   Symbol* name = resolved_method-&gt;name();
 414   Symbol* signature = resolved_method-&gt;signature();
 415   InstanceKlass* ik = InstanceKlass::cast(klass);
 416 
 417   // First check in default method array
 418   if (!resolved_method-&gt;is_abstract() &amp;&amp; ik-&gt;default_methods() != NULL) {
 419     int index = InstanceKlass::find_method_index(ik-&gt;default_methods(),
 420                                                  name, signature, Klass::find_overpass,
 421                                                  Klass::find_static, Klass::find_private);
 422     if (index &gt;= 0 ) {
 423       vtable_index = ik-&gt;default_vtable_indices()-&gt;at(index);
 424     }
 425   }
 426   if (vtable_index == Method::invalid_vtable_index) {
 427     // get vtable_index for miranda methods
 428     klassVtable vt = ik-&gt;vtable();
 429     vtable_index = vt.index_of_miranda(name, signature);
 430   }
 431   return vtable_index;
 432 }
 433 
 434 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 435   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 436 
 437   // Specify &#39;true&#39; in order to skip default methods when searching the
 438   // interfaces.  Function lookup_method_in_klasses() already looked for
 439   // the method in the default methods table.
 440   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 441 }
 442 
<span class="line-modified"> 443 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified"> 444                                                 Handle *appendix_result_or_null,</span>
<span class="line-modified"> 445                                                 TRAPS) {</span>

 446   Klass* klass = link_info.resolved_klass();
 447   Symbol* name = link_info.name();
 448   Symbol* full_signature = link_info.signature();
 449 
 450   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
 451   if (TraceMethodHandles) {
 452     ResourceMark rm(THREAD);
 453     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,
 454                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),
 455                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());
 456   }
 457   if ((klass == SystemDictionary::MethodHandle_klass() ||
 458        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 459       iid != vmIntrinsics::_none) {
 460     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 461       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 462       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 463       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 464       TempNewSymbol basic_signature =
 465         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
 466       if (TraceMethodHandles) {
 467         ResourceMark rm(THREAD);
 468         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,
 469                       name-&gt;as_C_string(),
 470                       full_signature-&gt;as_C_string(),
 471                       basic_signature-&gt;as_C_string());
 472       }
<span class="line-modified"> 473       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,</span>
 474                                                               basic_signature,
 475                                                               CHECK_NULL);
<span class="line-modified"> 476       if (result != NULL) {</span>
 477         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 478         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 479         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
 480         if (TraceMethodHandles) {
 481           ttyLocker ttyl;
 482           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);
 483           result-&gt;print_on(tty);
 484         }
 485       }
 486       return result;
 487     } else if (iid == vmIntrinsics::_invokeGeneric
 488                &amp;&amp; THREAD-&gt;can_call_java()
 489                &amp;&amp; appendix_result_or_null != NULL) {
 490       // This is a method with type-checking semantics.
 491       // We will ask Java code to spin an adapter method for it.
 492       if (!MethodHandles::enabled()) {
 493         // Make sure the Java part of the runtime has been booted up.
 494         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 495         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 496           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 497                                             Handle(),
 498                                             Handle(),
 499                                             true,
 500                                             CHECK_NULL);
 501         }
 502       }
 503 
 504       Handle appendix;
 505       Handle method_type;
<span class="line-modified"> 506       Method* result = SystemDictionary::find_method_handle_invoker(</span>
 507                                                             klass,
 508                                                             name,
 509                                                             full_signature,
 510                                                             link_info.current_klass(),
 511                                                             &amp;appendix,
 512                                                             CHECK_NULL);
 513       if (TraceMethodHandles) {
 514         ttyLocker ttyl;
 515         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);
 516         result-&gt;print_on(tty);
 517         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);
 518         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);
 519         else                     appendix-&gt;print_on(tty);
 520       }
<span class="line-modified"> 521       if (result != NULL) {</span>
 522 #ifdef ASSERT
 523         ResourceMark rm(THREAD);
 524 
 525         TempNewSymbol basic_signature =
 526           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 527         int actual_size_of_params = result-&gt;size_of_parameters();
 528         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 529         // +1 for MethodHandle.this, +1 for trailing MethodType
 530         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 531         if (appendix.not_null())                                   expected_size_of_params += 1;
 532         if (actual_size_of_params != expected_size_of_params) {
 533           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 534           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 535           result-&gt;print();
 536         }
 537         assert(actual_size_of_params == expected_size_of_params,
 538                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 539 #endif //ASSERT
 540 
 541         assert(appendix_result_or_null != NULL, &quot;&quot;);
</pre>
<hr />
<pre>
 570     jint new_flags = flags.as_int();
 571     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 572     new_flags = new_flags | JVM_ACC_PUBLIC;
 573     flags.set_flags(new_flags);
 574   }
 575 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 576 
 577   bool can_access = Reflection::verify_member_access(ref_klass,
 578                                                      resolved_klass,
 579                                                      sel_klass,
 580                                                      flags,
 581                                                      true, false, CHECK);
 582   // Any existing exceptions that may have been thrown, for example LinkageErrors
 583   // from nest-host resolution, have been allowed to propagate.
 584   if (!can_access) {
 585     ResourceMark rm(THREAD);
 586     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 587     Exceptions::fthrow(
 588       THREAD_AND_LOCATION,
 589       vmSymbols::java_lang_IllegalAccessError(),
<span class="line-modified"> 590       &quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,</span>
 591       ref_klass-&gt;external_name(),
 592       sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,
 593       sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,
 594       sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,
<span class="line-modified"> 595       sel_method-&gt;external_name(),</span>


 596       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 597       (same_module) ? &quot;&quot; : &quot;; &quot;,
 598       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 599     );
 600     return;
 601   }
 602 }
 603 
<span class="line-modified"> 604 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified"> 605                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
 606   // This method is used only
 607   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 608   // and
 609   // (2) in Bytecode_invoke::static_target
 610   // It appears to fail when applied to an invokeinterface call site.
 611   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 612   // resolve klass
 613   if (code == Bytecodes::_invokedynamic) {
 614     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 615     Symbol* method_name = vmSymbols::invoke_name();
 616     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 617     Klass*  current_klass = pool-&gt;pool_holder();
 618     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 619     return resolve_method(link_info, code, THREAD);
 620   }
 621 
 622   LinkInfo link_info(pool, index, methodHandle(), CHECK_NULL);
 623   Klass* resolved_klass = link_info.resolved_klass();
 624 
 625   if (pool-&gt;has_preresolution()
 626       || (resolved_klass == SystemDictionary::MethodHandle_klass() &amp;&amp;
 627           MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
 628     Method* result = ConstantPool::method_at_if_loaded(pool, index);
 629     if (result != NULL) {
<span class="line-modified"> 630       return result;</span>
 631     }
 632   }
 633 
 634   if (code == Bytecodes::_invokeinterface) {
 635     return resolve_interface_method(link_info, code, THREAD);
 636   } else if (code == Bytecodes::_invokevirtual) {
 637     return resolve_method(link_info, code, THREAD);
 638   } else if (!resolved_klass-&gt;is_interface()) {
 639     return resolve_method(link_info, code, THREAD);
 640   } else {
 641     return resolve_interface_method(link_info, code, THREAD);
 642   }
 643 }
 644 
 645 // Check and print a loader constraint violation message for method or interface method
 646 void LinkResolver::check_method_loader_constraints(const LinkInfo&amp; link_info,
 647                                                    const methodHandle&amp; resolved_method,
 648                                                    const char* method_type, TRAPS) {
 649   Handle current_loader(THREAD, link_info.current_klass()-&gt;class_loader());
 650   Handle resolved_loader(THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 651 
 652   ResourceMark rm(THREAD);
 653   Symbol* failed_type_symbol =
 654     SystemDictionary::check_signature_loaders(link_info.signature(), current_loader,
 655                                               resolved_loader, true, CHECK);
 656   if (failed_type_symbol != NULL) {
 657     Klass* current_class = link_info.current_klass();
 658     ClassLoaderData* current_loader_data = current_class-&gt;class_loader_data();
 659     assert(current_loader_data != NULL, &quot;current class has no class loader data&quot;);
 660     Klass* resolved_method_class = resolved_method-&gt;method_holder();
 661     ClassLoaderData* target_loader_data = resolved_method_class-&gt;class_loader_data();
 662     assert(target_loader_data != NULL, &quot;resolved method&#39;s class has no class loader data&quot;);
 663 
 664     stringStream ss;
<span class="line-modified"> 665     ss.print(&quot;loader constraint violation: when resolving %s &#39;&quot;, method_type);</span>
<span class="line-modified"> 666     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="line-added"> 667     ss.print(&quot;&#39; the class loader %s of the current class, %s,&quot;</span>
 668              &quot; and the class loader %s for the method&#39;s defining class, %s, have&quot;
 669              &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,


 670              current_loader_data-&gt;loader_name_and_id(),
 671              current_class-&gt;name()-&gt;as_C_string(),
 672              target_loader_data-&gt;loader_name_and_id(),
 673              resolved_method_class-&gt;name()-&gt;as_C_string(),
 674              failed_type_symbol-&gt;as_C_string(),
 675              current_class-&gt;class_in_module_of_loader(false, true),
 676              resolved_method_class-&gt;class_in_module_of_loader(false, true));
 677     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 678   }
 679 }
 680 
 681 void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,
 682                                                   Klass* current_klass,
 683                                                   Klass* sel_klass, TRAPS) {
 684   Handle ref_loader(THREAD, current_klass-&gt;class_loader());
 685   Handle sel_loader(THREAD, sel_klass-&gt;class_loader());
 686 
 687   ResourceMark rm(THREAD);  // needed for check_signature_loaders
 688   Symbol* failed_type_symbol =
 689     SystemDictionary::check_signature_loaders(sig,
</pre>
<hr />
<pre>
 695     const char* failed_type_name = failed_type_symbol-&gt;as_klass_external_name();
 696 
 697     ss.print(&quot;loader constraint violation: when resolving field \&quot;%s\&quot; of type %s, &quot;
 698              &quot;the class loader %s of the current class, %s, &quot;
 699              &quot;and the class loader %s for the field&#39;s defining %s, %s, &quot;
 700              &quot;have different Class objects for type %s (%s; %s)&quot;,
 701              field-&gt;as_C_string(),
 702              failed_type_name,
 703              current_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 704              current_klass-&gt;external_name(),
 705              sel_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 706              sel_klass-&gt;external_kind(),
 707              sel_klass-&gt;external_name(),
 708              failed_type_name,
 709              current_klass-&gt;class_in_module_of_loader(false, true),
 710              sel_klass-&gt;class_in_module_of_loader(false, true));
 711     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 712   }
 713 }
 714 
<span class="line-modified"> 715 Method* LinkResolver::resolve_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified"> 716                                      Bytecodes::Code code, TRAPS) {</span>
 717 
 718   Handle nested_exception;
 719   Klass* resolved_klass = link_info.resolved_klass();
 720 
 721   // 1. For invokevirtual, cannot call an interface method
 722   if (code == Bytecodes::_invokevirtual &amp;&amp; resolved_klass-&gt;is_interface()) {
 723     ResourceMark rm(THREAD);
 724     char buf[200];
 725     jio_snprintf(buf, sizeof(buf), &quot;Found interface %s, but class was expected&quot;,
 726         resolved_klass-&gt;external_name());
 727     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 728   }
 729 
 730   // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
 731   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_method()) {
 732     ResourceMark rm(THREAD);
<span class="line-modified"> 733     stringStream ss;</span>
<span class="line-modified"> 734     ss.print(&quot;Method &#39;&quot;);</span>
<span class="line-modified"> 735     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="line-added"> 736     ss.print(&quot;&#39; must be Methodref constant&quot;);</span>
<span class="line-added"> 737     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
 738   }
 739 
 740   // 3. lookup method in resolved klass and its super klasses
 741   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
 742 
 743   // 4. lookup method in all the interfaces implemented by the resolved klass
 744   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) { // not found in the class hierarchy
 745     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 746 
 747     if (resolved_method.is_null()) {
 748       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
<span class="line-modified"> 749       Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);</span>
<span class="line-added"> 750       resolved_method = methodHandle(THREAD, method);</span>
 751       if (HAS_PENDING_EXCEPTION) {
 752         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
 753         CLEAR_PENDING_EXCEPTION;
 754       }
 755     }
 756   }
 757 
 758   // 5. method lookup failed
 759   if (resolved_method.is_null()) {
 760     ResourceMark rm(THREAD);
<span class="line-added"> 761     stringStream ss;</span>
<span class="line-added"> 762     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added"> 763     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());</span>
<span class="line-added"> 764     ss.print(&quot;&#39;&quot;);</span>
 765     THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
<span class="line-modified"> 766                      ss.as_string(), nested_exception, NULL);</span>



 767   }
 768 
 769   // 6. access checks, access checking may be turned off when calling from within the VM.
 770   Klass* current_klass = link_info.current_klass();
 771   if (link_info.check_access()) {
 772     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 773 
 774     // check if method can be accessed by the referring class
 775     check_method_accessability(current_klass,
 776                                resolved_klass,
 777                                resolved_method-&gt;method_holder(),
 778                                resolved_method,
 779                                CHECK_NULL);
 780 
 781     // check loader constraints
 782     check_method_loader_constraints(link_info, resolved_method, &quot;method&quot;, CHECK_NULL);
 783   }
 784 
<span class="line-modified"> 785   return resolved_method();</span>
 786 }
 787 
 788 static void trace_method_resolution(const char* prefix,
 789                                     Klass* klass,
 790                                     Klass* resolved_klass,
<span class="line-modified"> 791                                     Method* method,</span>
 792                                     bool logitables,
 793                                     int index = -1) {
 794 #ifndef PRODUCT
 795   ResourceMark rm;
 796   Log(itables) logi;
 797   LogStream lsi(logi.trace());
 798   Log(vtables) logv;
 799   LogStream lsv(logv.trace());
 800   outputStream* st;
 801   if (logitables) {
 802     st = &amp;lsi;
 803   } else {
 804     st = &amp;lsv;
 805   }
 806   st-&gt;print(&quot;%s%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: &quot;,
 807             prefix,
 808             (klass == NULL ? &quot;&lt;NULL&gt;&quot; : klass-&gt;internal_name()),
 809             (resolved_klass == NULL ? &quot;&lt;NULL&gt;&quot; : resolved_klass-&gt;internal_name()),
 810             Method::name_and_sig_as_C_string(resolved_klass,
 811                                              method-&gt;name(),
 812                                              method-&gt;signature()),
 813             method-&gt;method_holder()-&gt;internal_name());
 814   method-&gt;print_linkage_flags(st);
 815   if (index != -1) {
 816     st-&gt;print(&quot;vtable_index:%d&quot;, index);
 817   }
 818   st-&gt;cr();
 819 #endif // PRODUCT
 820 }
 821 
 822 // Do linktime resolution of a method in the interface within the context of the specied bytecode.
<span class="line-modified"> 823 Method* LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {</span>
 824 
 825   Klass* resolved_klass = link_info.resolved_klass();
 826 
 827   // check if klass is interface
 828   if (!resolved_klass-&gt;is_interface()) {
 829     ResourceMark rm(THREAD);
 830     char buf[200];
 831     jio_snprintf(buf, sizeof(buf), &quot;Found class %s, but interface was expected&quot;, resolved_klass-&gt;external_name());
 832     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 833   }
 834 
 835   // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
 836   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_interface_method()) {
 837     ResourceMark rm(THREAD);
<span class="line-modified"> 838     stringStream ss;</span>
<span class="line-modified"> 839     ss.print(&quot;Method &#39;&quot;);</span>
<span class="line-modified"> 840     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="line-added"> 841     ss.print(&quot;&#39; must be InterfaceMethodref constant&quot;);</span>
<span class="line-added"> 842     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
 843   }
 844 
 845   // lookup method in this interface or its super, java.lang.Object
 846   // JDK8: also look for static methods
 847   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
 848 
 849   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) {
 850     // lookup method in all the super-interfaces
 851     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 852   }
 853 
 854   if (resolved_method.is_null()) {
 855     // no method found
 856     ResourceMark rm(THREAD);
<span class="line-modified"> 857     stringStream ss;</span>
<span class="line-modified"> 858     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified"> 859     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());</span>
<span class="line-modified"> 860     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added"> 861     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());</span>
 862   }
 863 
 864   if (link_info.check_access()) {
 865     // JDK8 adds non-public interface methods, and accessability check requirement
 866     Klass* current_klass = link_info.current_klass();
 867 
 868     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 869 
 870     // check if method can be accessed by the referring class
 871     check_method_accessability(current_klass,
 872                                resolved_klass,
 873                                resolved_method-&gt;method_holder(),
 874                                resolved_method,
 875                                CHECK_NULL);
 876 
 877     check_method_loader_constraints(link_info, resolved_method, &quot;interface method&quot;, CHECK_NULL);
 878   }
 879 
 880   if (code != Bytecodes::_invokestatic &amp;&amp; resolved_method-&gt;is_static()) {
 881     ResourceMark rm(THREAD);
<span class="line-modified"> 882     stringStream ss;</span>
<span class="line-modified"> 883     ss.print(&quot;Expected instance not static method &#39;&quot;);</span>
<span class="line-modified"> 884     Method::print_external_name(&amp;ss, resolved_klass,</span>
<span class="line-modified"> 885                                 resolved_method-&gt;name(), resolved_method-&gt;signature());</span>
<span class="line-modified"> 886     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added"> 887     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
 888   }
 889 
 890   if (log_develop_is_enabled(Trace, itables)) {
 891     char buf[200];
 892     jio_snprintf(buf, sizeof(buf), &quot;%s resolved interface method: caller-class:&quot;,
 893                  Bytecodes::name(code));
<span class="line-modified"> 894     trace_method_resolution(buf, link_info.current_klass(), resolved_klass, resolved_method(), true);</span>

 895   }
 896 
<span class="line-modified"> 897   return resolved_method();</span>
 898 }
 899 
 900 //------------------------------------------------------------------------------------------------------------------------
 901 // Field resolution
 902 
 903 void LinkResolver::check_field_accessability(Klass* ref_klass,
 904                                              Klass* resolved_klass,
 905                                              Klass* sel_klass,
 906                                              const fieldDescriptor&amp; fd,
 907                                              TRAPS) {
 908   bool can_access = Reflection::verify_member_access(ref_klass,
 909                                                      resolved_klass,
 910                                                      sel_klass,
 911                                                      fd.access_flags(),
 912                                                      true, false, CHECK);
 913   // Any existing exceptions that may have been thrown, for example LinkageErrors
 914   // from nest-host resolution, have been allowed to propagate.
 915   if (!can_access) {
 916     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 917     ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 980       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 981       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 982     }
 983 
 984     // A final field can be modified only
 985     // (1) by methods declared in the class declaring the field and
 986     // (2) by the &lt;clinit&gt; method (in case of a static field)
 987     //     or by the &lt;init&gt; method (in case of an instance field).
 988     if (is_put &amp;&amp; fd.access_flags().is_final()) {
 989       ResourceMark rm(THREAD);
 990       stringStream ss;
 991 
 992       if (sel_klass != current_klass) {
 993         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
 994                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
 995                 current_klass-&gt;external_name());
 996         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
 997       }
 998 
 999       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
<span class="line-modified">1000         Method* m = link_info.current_method();</span>
<span class="line-modified">1001         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);</span>
1002         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1003                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1004                                                    !m-&gt;is_static_initializer());</span>
1005         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1006                                                      !fd.is_static() &amp;&amp;
1007                                                      !m-&gt;is_object_initializer());
1008 
1009         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1010           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1011                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1012                    m-&gt;name()-&gt;as_C_string(),</span>
1013                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1014           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1015         }
1016       }
1017     }
1018 
1019     // initialize resolved_klass if necessary
1020     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1021     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1022     //
1023     // note 2: we don&#39;t want to force initialization if we are just checking
1024     //         if the field access is legal; e.g., during compilation
1025     if (is_static &amp;&amp; initialize_class) {
1026       sel_klass-&gt;initialize(CHECK);
1027     }
1028   }
1029 
1030   if ((sel_klass != current_klass) &amp;&amp; (current_klass != NULL)) {
1031     check_field_loader_constraints(field, sig, current_klass, sel_klass, CHECK);
1032   }
1033 
1034   // return information. note that the klass is set to the actual klass containing the
1035   // field, otherwise access of static fields in superclasses will not work.
1036 }
1037 
1038 
1039 //------------------------------------------------------------------------------------------------------------------------
1040 // Invoke resolution
1041 //
1042 // Naming conventions:
1043 //
1044 // resolved_method    the specified method (i.e., static receiver specified via constant pool index)
1045 // sel_method         the selected method  (selected via run-time lookup; e.g., based on dynamic receiver class)
1046 // resolved_klass     the specified klass  (i.e., specified via constant pool index)
1047 // recv_klass         the receiver klass
1048 
1049 
1050 void LinkResolver::resolve_static_call(CallInfo&amp; result,
1051                                        const LinkInfo&amp; link_info,
1052                                        bool initialize_class, TRAPS) {
<span class="line-modified">1053   Method* resolved_method = linktime_resolve_static_method(link_info, CHECK);</span>
1054 
1055   // The resolved class can change as a result of this resolution.
1056   Klass* resolved_klass = resolved_method-&gt;method_holder();
1057 
1058   // Initialize klass (this should only happen if everything is ok)
1059   if (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) {
1060     resolved_klass-&gt;initialize(CHECK);
1061     // Use updated LinkInfo to reresolve with resolved method holder
1062     LinkInfo new_info(resolved_klass, link_info.name(), link_info.signature(),
1063                       link_info.current_klass(),
1064                       link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
1065     resolved_method = linktime_resolve_static_method(new_info, CHECK);
1066   }
1067 
1068   // setup result
<span class="line-modified">1069   result.set_static(resolved_klass, methodHandle(THREAD, resolved_method), CHECK);</span>
1070 }
1071 
1072 // throws linktime exceptions
<span class="line-modified">1073 Method* LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {</span>
1074 
1075   Klass* resolved_klass = link_info.resolved_klass();
<span class="line-modified">1076   Method* resolved_method;</span>
1077   if (!resolved_klass-&gt;is_interface()) {
1078     resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1079   } else {
1080     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1081   }
1082   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), &quot;should have been checked in verifier&quot;);
1083 
1084   // check if static
1085   if (!resolved_method-&gt;is_static()) {
1086     ResourceMark rm(THREAD);
<span class="line-modified">1087     stringStream ss;</span>
<span class="line-modified">1088     ss.print(&quot;Expected static method &#39;&quot;);</span>
<span class="line-modified">1089     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1090     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1091     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
1092   }
1093   return resolved_method;
1094 }
1095 
1096 
1097 void LinkResolver::resolve_special_call(CallInfo&amp; result,
1098                                         Handle recv,
1099                                         const LinkInfo&amp; link_info,
1100                                         TRAPS) {
<span class="line-modified">1101   Method* resolved_method = linktime_resolve_special_method(link_info, CHECK);</span>
<span class="line-modified">1102   runtime_resolve_special_method(result, link_info, methodHandle(THREAD, resolved_method), recv, CHECK);</span>
1103 }
1104 
1105 // throws linktime exceptions
<span class="line-modified">1106 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {</span>

1107 
1108   // Invokespecial is called for multiple special reasons:
1109   // &lt;init&gt;
1110   // local private method invocation, for classes and interfaces
1111   // superclass.method, which can also resolve to a default method
1112   // and the selected method is recalculated relative to the direct superclass
1113   // superinterface.method, which explicitly does not check shadowing
1114   Klass* resolved_klass = link_info.resolved_klass();
<span class="line-modified">1115   Method* resolved_method;</span>
1116 
1117   if (!resolved_klass-&gt;is_interface()) {
1118     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1119   } else {
1120     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1121   }
1122 
1123   // check if method name is &lt;init&gt;, that it is found in same klass as static type
1124   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1125       resolved_method-&gt;method_holder() != resolved_klass) {
1126     ResourceMark rm(THREAD);
<span class="line-added">1127     stringStream ss;</span>
<span class="line-added">1128     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());</span>
<span class="line-added">1129     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="line-added">1130     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">1131     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="line-added">1132     ss.print(&quot;)&#39; not found&quot;);</span>
1133     Exceptions::fthrow(
1134       THREAD_AND_LOCATION,
1135       vmSymbols::java_lang_NoSuchMethodError(),
<span class="line-modified">1136       &quot;%s&quot;, ss.as_string());</span>




1137     return NULL;
1138   }
1139 
1140   // ensure that invokespecial&#39;s interface method reference is in
1141   // a direct superinterface, not an indirect superinterface
1142   Klass* current_klass = link_info.current_klass();
1143   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
1144     InstanceKlass* ck = InstanceKlass::cast(current_klass);
1145     InstanceKlass *klass_to_check = !ck-&gt;is_unsafe_anonymous() ?
1146                                     ck :
1147                                     ck-&gt;unsafe_anonymous_host();
1148     // Disable verification for the dynamically-generated reflection bytecodes.
1149     bool is_reflect = klass_to_check-&gt;is_subclass_of(
1150                         SystemDictionary::reflect_MagicAccessorImpl_klass());
1151 
1152     if (!is_reflect &amp;&amp;
1153         !klass_to_check-&gt;is_same_or_direct_interface(resolved_klass)) {
1154       ResourceMark rm(THREAD);
<span class="line-modified">1155       stringStream ss;</span>
<span class="line-modified">1156       ss.print(&quot;Interface method reference: &#39;&quot;);</span>
<span class="line-modified">1157       resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1158       ss.print(&quot;&#39;, is in an indirect superinterface of %s&quot;,</span>
<span class="line-modified">1159                current_klass-&gt;external_name());</span>
<span class="line-modified">1160       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>


1161     }
1162   }
1163 
1164   // check if not static
1165   if (resolved_method-&gt;is_static()) {
1166     ResourceMark rm(THREAD);
<span class="line-modified">1167     stringStream ss;</span>
<span class="line-modified">1168     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="line-modified">1169     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1170     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1171     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>


1172   }
1173 
1174   if (log_develop_is_enabled(Trace, itables)) {
1175     trace_method_resolution(&quot;invokespecial resolved method: caller-class:&quot;,
1176                             current_klass, resolved_klass, resolved_method, true);
1177   }
1178 
1179   return resolved_method;
1180 }
1181 
1182 // throws runtime exceptions
1183 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1184                                                   const LinkInfo&amp; link_info,
1185                                                   const methodHandle&amp; resolved_method,
1186                                                   Handle recv, TRAPS) {
1187 
1188   Klass* resolved_klass = link_info.resolved_klass();
1189 
1190   // resolved method is selected method unless we have an old-style lookup
1191   // for a superclass method
1192   // Invokespecial for a superinterface, resolved method is selected method,
1193   // no checks for shadowing
1194   methodHandle sel_method(THREAD, resolved_method());
1195 
1196   if (link_info.check_access() &amp;&amp;
1197       // check if the method is not &lt;init&gt;
1198       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1199 
1200     Klass* current_klass = link_info.current_klass();
1201 
1202     // Check if the class of the resolved_klass is a superclass
1203     // (not supertype in order to exclude interface classes) of the current class.
1204     // This check is not performed for super.invoke for interface methods
1205     // in super interfaces.
1206     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1207         current_klass != resolved_klass) {
1208       // Lookup super method
1209       Klass* super_klass = current_klass-&gt;super();
<span class="line-modified">1210       Method* instance_method = lookup_instance_method_in_klasses(super_klass,</span>
1211                                                      resolved_method-&gt;name(),
1212                                                      resolved_method-&gt;signature(),
1213                                                      Klass::find_private, CHECK);
<span class="line-added">1214       sel_method = methodHandle(THREAD, instance_method);</span>
<span class="line-added">1215 </span>
1216       // check if found
1217       if (sel_method.is_null()) {
1218         ResourceMark rm(THREAD);
<span class="line-modified">1219         stringStream ss;</span>
<span class="line-modified">1220         ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1221         resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1222         ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">1223         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>
1224       // check loader constraints if found a different method
1225       } else if (sel_method() != resolved_method()) {
1226         check_method_loader_constraints(link_info, sel_method, &quot;method&quot;, CHECK);
1227       }
1228     }
1229 
1230     // Check that the class of objectref (the receiver) is the current class or interface,
1231     // or a subtype of the current class or interface (the sender), otherwise invokespecial
1232     // throws IllegalAccessError.
1233     // The verifier checks that the sender is a subtype of the class in the I/MR operand.
1234     // The verifier also checks that the receiver is a subtype of the sender, if the sender is
1235     // a class.  If the sender is an interface, the check has to be performed at runtime.
1236     InstanceKlass* sender = InstanceKlass::cast(current_klass);
1237     sender = sender-&gt;is_unsafe_anonymous() ? sender-&gt;unsafe_anonymous_host() : sender;
1238     if (sender-&gt;is_interface() &amp;&amp; recv.not_null()) {
1239       Klass* receiver_klass = recv-&gt;klass();
1240       if (!receiver_klass-&gt;is_subtype_of(sender)) {
1241         ResourceMark rm(THREAD);
1242         char buf[500];
1243         jio_snprintf(buf, sizeof(buf),
1244                      &quot;Receiver class %s must be the current class or a subtype of interface %s&quot;,
<span class="line-modified">1245                      receiver_klass-&gt;external_name(),</span>
<span class="line-modified">1246                      sender-&gt;external_name());</span>
1247         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
1248       }
1249     }
1250   }
1251 
1252   // check if not static
1253   if (sel_method-&gt;is_static()) {
1254     ResourceMark rm(THREAD);
<span class="line-modified">1255     stringStream ss;</span>
<span class="line-modified">1256     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="line-modified">1257     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1258     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1259     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
1260   }
1261 
1262   // check if abstract
1263   if (sel_method-&gt;is_abstract()) {
1264     ResourceMark rm(THREAD);
<span class="line-modified">1265     stringStream ss;</span>
<span class="line-modified">1266     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1267     Method::print_external_name(&amp;ss, resolved_klass, sel_method-&gt;name(), sel_method-&gt;signature());</span>
<span class="line-modified">1268     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">1269     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>
1270   }
1271 
1272   if (log_develop_is_enabled(Trace, itables)) {
1273     trace_method_resolution(&quot;invokespecial selected method: resolved-class:&quot;,
<span class="line-modified">1274                             resolved_klass, resolved_klass, sel_method(), true);</span>
1275   }
1276 
1277   // setup result
1278   result.set_static(resolved_klass, sel_method, CHECK);
1279 }
1280 
1281 void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, Klass* receiver_klass,
1282                                         const LinkInfo&amp; link_info,
1283                                         bool check_null_and_abstract, TRAPS) {
<span class="line-modified">1284   Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);</span>
<span class="line-modified">1285   runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),</span>
1286                                  link_info.resolved_klass(),
1287                                  recv, receiver_klass,
1288                                  check_null_and_abstract, CHECK);
1289 }
1290 
1291 // throws linktime exceptions
<span class="line-modified">1292 Method* LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,</span>
1293                                                            TRAPS) {
1294   // normal method resolution
<span class="line-modified">1295   Method* resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);</span>
1296 
1297   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1298   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1299 
1300   // check if private interface method
1301   Klass* resolved_klass = link_info.resolved_klass();
1302   Klass* current_klass = link_info.current_klass();
1303 
1304   // This is impossible, if resolve_klass is an interface, we&#39;ve thrown icce in resolve_method
1305   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1306     ResourceMark rm(THREAD);
<span class="line-modified">1307     stringStream ss;</span>
<span class="line-modified">1308     ss.print(&quot;private interface method requires invokespecial, not invokevirtual: method &#39;&quot;);</span>
<span class="line-modified">1309     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1310     ss.print(&quot;&#39;, caller-class: %s&quot;,</span>
<span class="line-modified">1311              (current_klass == NULL ? &quot;&lt;null&gt;&quot; : current_klass-&gt;internal_name()));</span>
<span class="line-modified">1312     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>

1313   }
1314 
1315   // check if not static
1316   if (resolved_method-&gt;is_static()) {
1317     ResourceMark rm(THREAD);
<span class="line-modified">1318     stringStream ss;</span>
<span class="line-modified">1319     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="line-modified">1320     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-modified">1321     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1322     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
1323   }
1324 
1325   if (log_develop_is_enabled(Trace, vtables)) {
1326     trace_method_resolution(&quot;invokevirtual resolved method: caller-class:&quot;,
1327                             current_klass, resolved_klass, resolved_method, false);
1328   }
1329 
1330   return resolved_method;
1331 }
1332 
1333 // throws runtime exceptions
1334 void LinkResolver::runtime_resolve_virtual_method(CallInfo&amp; result,
1335                                                   const methodHandle&amp; resolved_method,
1336                                                   Klass* resolved_klass,
1337                                                   Handle recv,
1338                                                   Klass* recv_klass,
1339                                                   bool check_null_and_abstract,
1340                                                   TRAPS) {
1341 
1342   // setup default return values
</pre>
<hr />
<pre>
1374       assert(resolved_method-&gt;can_be_statically_bound(), &quot;cannot override this method&quot;);
1375       selected_method = resolved_method;
1376     } else {
1377       selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1378     }
1379   }
1380 
1381   // check if method exists
1382   if (selected_method.is_null()) {
1383     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1384   }
1385 
1386   // check if abstract
1387   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1388     // Pass arguments for generating a verbose error message.
1389     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1390   }
1391 
1392   if (log_develop_is_enabled(Trace, vtables)) {
1393     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
<span class="line-modified">1394                             recv_klass, resolved_klass, selected_method(),</span>
1395                             false, vtable_index);
1396   }
1397   // setup result
1398   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
1399 }
1400 
1401 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1402                                           const LinkInfo&amp; link_info,
1403                                           bool check_null_and_abstract, TRAPS) {
1404   // throws linktime exceptions
<span class="line-modified">1405   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);</span>
<span class="line-modified">1406   methodHandle mh(THREAD, resolved_method);</span>
<span class="line-added">1407   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),</span>
1408                                    recv, recv_klass, check_null_and_abstract, CHECK);
1409 }
1410 
<span class="line-modified">1411 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,</span>
1412                                                              TRAPS) {
1413   // normal interface method resolution
<span class="line-modified">1414   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);</span>
1415   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1416   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1417 
1418   return resolved_method;
1419 }
1420 
1421 // throws runtime exceptions
1422 void LinkResolver::runtime_resolve_interface_method(CallInfo&amp; result,
1423                                                     const methodHandle&amp; resolved_method,
1424                                                     Klass* resolved_klass,
1425                                                     Handle recv,
1426                                                     Klass* recv_klass,
1427                                                     bool check_null_and_abstract, TRAPS) {
1428 
1429   // check if receiver exists
1430   if (check_null_and_abstract &amp;&amp; recv.is_null()) {
1431     THROW(vmSymbols::java_lang_NullPointerException());
1432   }
1433 
1434   // check if receiver klass implements the resolved interface
1435   if (!recv_klass-&gt;is_subtype_of(resolved_klass)) {
1436     ResourceMark rm(THREAD);
1437     char buf[200];
1438     jio_snprintf(buf, sizeof(buf), &quot;Class %s does not implement the requested interface %s&quot;,
1439                  recv_klass-&gt;external_name(),
1440                  resolved_klass-&gt;external_name());
1441     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1442   }
1443 
1444   methodHandle selected_method = resolved_method;
1445 
1446   // resolve the method in the receiver class, unless it is private
1447   if (!resolved_method()-&gt;is_private()) {
1448     // do lookup based on receiver klass
1449     // This search must match the linktime preparation search for itable initialization
1450     // to correctly enforce loader constraints for interface method inheritance.
1451     // Private methods are skipped as the resolved method was not private.
<span class="line-modified">1452     Method* method = lookup_instance_method_in_klasses(recv_klass,</span>
<span class="line-modified">1453                                                        resolved_method-&gt;name(),</span>
<span class="line-modified">1454                                                        resolved_method-&gt;signature(),</span>
<span class="line-modified">1455                                                        Klass::skip_private, CHECK);</span>
<span class="line-added">1456     selected_method = methodHandle(THREAD, method);</span>
1457 
1458     if (selected_method.is_null() &amp;&amp; !check_null_and_abstract) {
1459       // In theory this is a harmless placeholder value, but
1460       // in practice leaving in null affects the nsk default method tests.
1461       // This needs further study.
1462       selected_method = resolved_method;
1463     }
1464     // check if method exists
1465     if (selected_method.is_null()) {
1466       // Pass arguments for generating a verbose error message.
1467       throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1468     }
1469     // check access
1470     // Throw Illegal Access Error if selected_method is not public.
1471     if (!selected_method-&gt;is_public()) {
1472       ResourceMark rm(THREAD);
<span class="line-modified">1473       stringStream ss;</span>
<span class="line-modified">1474       ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1475       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());</span>
<span class="line-modified">1476       ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">1477       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());</span>
1478     }
1479     // check if abstract
1480     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1481       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1482     }
1483   }
1484 
1485   if (log_develop_is_enabled(Trace, itables)) {
1486     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
<span class="line-modified">1487                             recv_klass, resolved_klass, selected_method(), true);</span>
1488   }
1489   // setup result
1490   if (resolved_method-&gt;has_vtable_index()) {
1491     int vtable_index = resolved_method-&gt;vtable_index();
1492     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1493     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
1494     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
1495   } else if (resolved_method-&gt;has_itable_index()) {
1496     int itable_index = resolved_method()-&gt;itable_index();
1497     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
1498     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);
1499   } else {
1500     int index = resolved_method-&gt;vtable_index();
1501     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1502     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1503     assert(resolved_method()-&gt;is_private() ||
1504            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1505            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1506     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1507     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
1508     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);
1509   }
1510 }
1511 
1512 
<span class="line-modified">1513 Method* LinkResolver::linktime_resolve_interface_method_or_null(</span>
1514                                                  const LinkInfo&amp; link_info) {
1515   EXCEPTION_MARK;
<span class="line-modified">1516   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);</span>
1517   if (HAS_PENDING_EXCEPTION) {
1518     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1519     return NULL;</span>
1520   } else {
1521     return method_result;
1522   }
1523 }
1524 
<span class="line-modified">1525 Method* LinkResolver::linktime_resolve_virtual_method_or_null(</span>
1526                                                  const LinkInfo&amp; link_info) {
1527   EXCEPTION_MARK;
<span class="line-modified">1528   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);</span>
1529   if (HAS_PENDING_EXCEPTION) {
1530     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1531     return NULL;</span>
1532   } else {
1533     return method_result;
1534   }
1535 }
1536 
<span class="line-modified">1537 Method* LinkResolver::resolve_virtual_call_or_null(</span>
1538                                                  Klass* receiver_klass,
1539                                                  const LinkInfo&amp; link_info) {
1540   EXCEPTION_MARK;
1541   CallInfo info;
1542   resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1543   if (HAS_PENDING_EXCEPTION) {
1544     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1545     return NULL;</span>
1546   }
1547   return info.selected_method();
1548 }
1549 
<span class="line-modified">1550 Method* LinkResolver::resolve_interface_call_or_null(</span>
1551                                                  Klass* receiver_klass,
1552                                                  const LinkInfo&amp; link_info) {
1553   EXCEPTION_MARK;
1554   CallInfo info;
1555   resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1556   if (HAS_PENDING_EXCEPTION) {
1557     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1558     return NULL;</span>
1559   }
1560   return info.selected_method();
1561 }
1562 
1563 int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
1564                                                const LinkInfo&amp; link_info) {
1565   EXCEPTION_MARK;
1566   CallInfo info;
1567   resolve_virtual_call(info, Handle(), receiver_klass, link_info,
1568                        /*check_null_or_abstract*/false, THREAD);
1569   if (HAS_PENDING_EXCEPTION) {
1570     CLEAR_PENDING_EXCEPTION;
1571     return Method::invalid_vtable_index;
1572   }
1573   return info.vtable_index();
1574 }
1575 
<span class="line-modified">1576 Method* LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {</span>
1577   EXCEPTION_MARK;
1578   CallInfo info;
1579   resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
1580   if (HAS_PENDING_EXCEPTION) {
1581     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1582     return NULL;</span>
1583   }
1584   return info.selected_method();
1585 }
1586 
<span class="line-modified">1587 Method* LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {</span>
1588   EXCEPTION_MARK;
1589   CallInfo info;
1590   resolve_special_call(info, Handle(), link_info, THREAD);
1591   if (HAS_PENDING_EXCEPTION) {
1592     CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1593     return NULL;</span>
1594   }
1595   return info.selected_method();
1596 }
1597 
1598 
1599 
1600 //------------------------------------------------------------------------------------------------------------------------
1601 // ConstantPool entries
1602 
1603 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1604   switch (byte) {
1605     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1606     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1607     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1608     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1609     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1610     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1611     default                         :                                                            break;
1612   }
1613   return;
</pre>
<hr />
<pre>
1674 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1675   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1676   LinkInfo link_info(pool, index, CHECK);
1677   if (TraceMethodHandles) {
1678     ResourceMark rm(THREAD);
1679     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),
1680                   link_info.signature()-&gt;as_C_string());
1681   }
1682   resolve_handle_call(result, link_info, CHECK);
1683 }
1684 
1685 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1686                                        const LinkInfo&amp; link_info,
1687                                        TRAPS) {
1688   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1689   Klass* resolved_klass = link_info.resolved_klass();
1690   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1691          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1692   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1693   Handle       resolved_appendix;
<span class="line-modified">1694   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);</span>
<span class="line-modified">1695   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);</span>
1696 }
1697 
<span class="line-modified">1698 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {</span>
<span class="line-modified">1699   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);</span>







1700   int pool_index = cpce-&gt;constant_pool_index();
1701 
<span class="line-modified">1702   // Resolve the bootstrap specifier (BSM + optional arguments).</span>
<span class="line-modified">1703   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);</span>




1704 
<span class="line-modified">1705   // Check if CallSite has been bound already or failed already, and short circuit:</span>
<span class="line-modified">1706   {</span>
<span class="line-modified">1707     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);</span>
<span class="line-modified">1708     if (is_done) return;</span>















1709   }
1710 
<span class="line-added">1711   // The initial step in Call Site Specifier Resolution is to resolve the symbolic</span>
<span class="line-added">1712   // reference to a method handle which will be the bootstrap method for a dynamic</span>
<span class="line-added">1713   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap</span>
<span class="line-added">1714   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap</span>
<span class="line-added">1715   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to</span>
<span class="line-added">1716   // set the indy_rf flag since any subsequent invokedynamic instruction which shares</span>
<span class="line-added">1717   // this bootstrap method will encounter the resolution of MethodHandleInError.</span>
<span class="line-added">1718 </span>
<span class="line-added">1719   resolve_dynamic_call(result, bootstrap_specifier, CHECK);</span>
<span class="line-added">1720 </span>
1721   if (TraceMethodHandles) {
<span class="line-modified">1722     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);</span>






























1723   }
<span class="line-added">1724 </span>
<span class="line-added">1725   // The returned linkage result is provisional up to the moment</span>
<span class="line-added">1726   // the interpreter or runtime performs a serialized check of</span>
<span class="line-added">1727   // the relevant CPCE::f1 field.  This is done by the caller</span>
<span class="line-added">1728   // of this method, via CPCE::set_dynamic_call, which uses</span>
<span class="line-added">1729   // an ObjectLocker to do the final serialization of updates</span>
<span class="line-added">1730   // to CPCE state, including f1.</span>
1731 }
1732 
1733 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
<span class="line-modified">1734                                         BootstrapInfo&amp; bootstrap_specifier,</span>



1735                                         TRAPS) {
<span class="line-modified">1736   // JSR 292:  this must resolve to an implicitly generated method</span>
<span class="line-added">1737   // such as MH.linkToCallSite(*...) or some other call-site shape.</span>
1738   // The appendix argument is likely to be a freshly-created CallSite.
<span class="line-modified">1739   // It may also be a MethodHandle from an unwrapped ConstantCallSite,</span>
<span class="line-modified">1740   // or any other reference.  The resolved_method as well as the appendix</span>
<span class="line-modified">1741   // are both recorded together via CallInfo::set_handle.</span>
<span class="line-modified">1742   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);</span>
<span class="line-modified">1743   Exceptions::wrap_dynamic_exception(THREAD);</span>
<span class="line-modified">1744 </span>
<span class="line-modified">1745   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">1746     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {</span>
<span class="line-modified">1747       // Let any random low-level IE or SOE or OOME just bleed through.</span>
<span class="line-modified">1748       // Basically we pretend that the bootstrap method was never called,</span>
<span class="line-modified">1749       // if it fails this way:  We neither record a successful linkage,</span>
<span class="line-added">1750       // nor do we memorize a LE for posterity.</span>
<span class="line-added">1751       return;</span>
<span class="line-added">1752     }</span>
<span class="line-added">1753     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve</span>
<span class="line-added">1754     // a symbolic reference fails because an error is thrown that is an</span>
<span class="line-added">1755     // instance of LinkageError (or a subclass), then subsequent attempts to</span>
<span class="line-added">1756     // resolve the reference always fail with the same error that was thrown</span>
<span class="line-added">1757     // as a result of the initial resolution attempt.</span>
<span class="line-added">1758      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);</span>
<span class="line-added">1759      if (!recorded_res_status) {</span>
<span class="line-added">1760        // Another thread got here just before we did.  So, either use the method</span>
<span class="line-added">1761        // that it resolved or throw the LinkageError exception that it threw.</span>
<span class="line-added">1762        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);</span>
<span class="line-added">1763        if (is_done) return;</span>
<span class="line-added">1764      }</span>
<span class="line-added">1765      assert(bootstrap_specifier.invokedynamic_cp_cache_entry()-&gt;indy_resolution_failed(),</span>
<span class="line-added">1766             &quot;Resolution failure flag wasn&#39;t set&quot;);</span>
<span class="line-added">1767   }</span>
<span class="line-added">1768 </span>
<span class="line-added">1769   bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);</span>
<span class="line-added">1770   // Exceptions::wrap_dynamic_exception not used because</span>
<span class="line-added">1771   // set_handle doesn&#39;t throw linkage errors</span>
1772 }
1773 
1774 // Selected method is abstract.
1775 void LinkResolver::throw_abstract_method_error(const methodHandle&amp; resolved_method,
1776                                                const methodHandle&amp; selected_method,
1777                                                Klass *recv_klass, TRAPS) {
1778   Klass *resolved_klass = resolved_method-&gt;method_holder();
1779   ResourceMark rm(THREAD);
1780   stringStream ss;
1781 
1782   if (recv_klass != NULL) {
1783     ss.print(&quot;Receiver class %s does not define or inherit an &quot;
1784              &quot;implementation of the&quot;,
1785              recv_klass-&gt;external_name());
1786   } else {
1787     ss.print(&quot;Missing implementation of&quot;);
1788   }
1789 
1790   assert(resolved_method.not_null(), &quot;Sanity&quot;);
<span class="line-modified">1791   ss.print(&quot; resolved method &#39;%s%s&quot;,</span>
1792            resolved_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="line-modified">1793            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);</span>
<span class="line-modified">1794   resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="line-modified">1795   ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">1796   resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="line-added">1797   ss.print(&quot;)&#39; of %s %s.&quot;,</span>
1798            resolved_klass-&gt;external_kind(),
1799            resolved_klass-&gt;external_name());
1800 
1801   if (selected_method.not_null() &amp;&amp; !(resolved_method == selected_method)) {
<span class="line-modified">1802     ss.print(&quot; Selected method is &#39;%s%s&quot;,</span>
1803              selected_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="line-modified">1804              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);</span>
<span class="line-modified">1805     selected_method-&gt;print_external_name(&amp;ss);</span>
<span class="line-added">1806     ss.print(&quot;&#39;.&quot;);</span>
1807   }
1808 
1809   THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1810 }
</pre>
</td>
</tr>
</table>
<center><a href="invocationCounter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
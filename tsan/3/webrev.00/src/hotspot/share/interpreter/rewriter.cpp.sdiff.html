<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/rewriter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopMapCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/rewriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 63         if (_pool-&gt;symbol_at(i) == vmSymbols::java_lang_invoke_MethodHandle() ||
 64             _pool-&gt;symbol_at(i) == vmSymbols::java_lang_invoke_VarHandle()) {
 65           saw_mh_symbol = true;
 66         }
 67         break;
 68     }
 69   }
 70 
 71   // Record limits of resolved reference map for constant pool cache indices
 72   record_map_limits();
 73 
 74   guarantee((int) _cp_cache_map.length() - 1 &lt;= (int) ((u2)-1),
 75             &quot;all cp cache indexes fit in a u2&quot;);
 76 
 77   if (saw_mh_symbol) {
 78     _method_handle_invokers.at_grow(length, 0);
 79   }
 80 }
 81 
 82 // Unrewrite the bytecodes if an error occurs.
<span class="line-modified"> 83 void Rewriter::restore_bytecodes() {</span>
 84   int len = _methods-&gt;length();
 85   bool invokespecial_error = false;
 86 
 87   for (int i = len-1; i &gt;= 0; i--) {
 88     Method* method = _methods-&gt;at(i);
<span class="line-modified"> 89     scan_method(method, true, &amp;invokespecial_error);</span>
 90     assert(!invokespecial_error, &quot;reversing should not get an invokespecial error&quot;);
 91   }
 92 }
 93 
 94 // Creates a constant pool cache given a CPC map
 95 void Rewriter::make_constant_pool_cache(TRAPS) {
 96   ClassLoaderData* loader_data = _pool-&gt;pool_holder()-&gt;class_loader_data();
 97   ConstantPoolCache* cache =
 98       ConstantPoolCache::allocate(loader_data, _cp_cache_map,
 99                                   _invokedynamic_cp_cache_map,
100                                   _invokedynamic_references_map, CHECK);
101 
102   // initialize object cache in constant pool
103   _pool-&gt;set_cache(cache);
104   cache-&gt;set_constant_pool(_pool());
105 
106   // _resolved_references is stored in pool-&gt;cache(), so need to be done after
107   // the above lines.
108   _pool-&gt;initialize_resolved_references(loader_data, _resolved_references_map,
109                                         _resolved_reference_limit,
</pre>
<hr />
<pre>
313         _invokedynamic_references_map.at_put(resolved_index, cache_index + delta);
314     }
315   }
316 }
317 
318 
319 // Rewrite some ldc bytecodes to _fast_aldc
320 void Rewriter::maybe_rewrite_ldc(address bcp, int offset, bool is_wide,
321                                  bool reverse) {
322   if (!reverse) {
323     assert((*bcp) == (is_wide ? Bytecodes::_ldc_w : Bytecodes::_ldc), &quot;not ldc bytecode&quot;);
324     address p = bcp + offset;
325     int cp_index = is_wide ? Bytes::get_Java_u2(p) : (u1)(*p);
326     constantTag tag = _pool-&gt;tag_at(cp_index).value();
327 
328     if (tag.is_method_handle() ||
329         tag.is_method_type() ||
330         tag.is_string() ||
331         (tag.is_dynamic_constant() &amp;&amp;
332          // keep regular ldc interpreter logic for condy primitives
<span class="line-modified">333          is_reference_type(FieldType::basic_type(_pool-&gt;uncached_signature_ref_at(cp_index))))</span>
334         ) {
335       int ref_index = cp_entry_to_resolved_references(cp_index);
336       if (is_wide) {
337         (*bcp) = Bytecodes::_fast_aldc_w;
338         assert(ref_index == (u2)ref_index, &quot;index overflow&quot;);
339         Bytes::put_native_u2(p, ref_index);
340       } else {
341         (*bcp) = Bytecodes::_fast_aldc;
342         assert(ref_index == (u1)ref_index, &quot;index overflow&quot;);
343         (*p) = (u1)ref_index;
344       }
345     }
346   } else {
347     Bytecodes::Code rewritten_bc =
348               (is_wide ? Bytecodes::_fast_aldc_w : Bytecodes::_fast_aldc);
349     if ((*bcp) == rewritten_bc) {
350       address p = bcp + offset;
351       int ref_index = is_wide ? Bytes::get_native_u2(p) : (u1)(*p);
352       int pool_index = resolved_references_entry_to_pool_index(ref_index);
353       if (is_wide) {
354         (*bcp) = Bytecodes::_ldc_w;
355         assert(pool_index == (u2)pool_index, &quot;index overflow&quot;);
356         Bytes::put_Java_u2(p, pool_index);
357       } else {
358         (*bcp) = Bytecodes::_ldc;
359         assert(pool_index == (u1)pool_index, &quot;index overflow&quot;);
360         (*p) = (u1)pool_index;
361       }
362     }
363   }
364 }
365 
366 
367 // Rewrites a method given the index_map information
<span class="line-modified">368 void Rewriter::scan_method(Method* method, bool reverse, bool* invokespecial_error) {</span>
369 
370   int nof_jsrs = 0;
371   bool has_monitor_bytecodes = false;
372   Bytecodes::Code c;
373 
374   // Bytecodes and their length
375   const address code_base = method-&gt;code_base();
376   const int code_length = method-&gt;code_size();
377 
378   int bc_length;
379   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
380     address bcp = code_base + bci;
381     int prefix_length = 0;
382     c = (Bytecodes::Code)(*bcp);
383 
384     // Since we have the code, see if we can get the length
385     // directly. Some more complicated bytecodes will report
386     // a length of zero, meaning we need to make another method
387     // call to calculate the length.
388     bc_length = Bytecodes::length_for(c);
</pre>
<hr />
<pre>
422         break;
423       }
424 
425       case Bytecodes::_invokespecial  : {
426         rewrite_invokespecial(bcp, prefix_length+1, reverse, invokespecial_error);
427         break;
428       }
429 
430       case Bytecodes::_putstatic      :
431       case Bytecodes::_putfield       : {
432         if (!reverse) {
433           // Check if any final field of the class given as parameter is modified
434           // outside of initializer methods of the class. Fields that are modified
435           // are marked with a flag. For marked fields, the compilers do not perform
436           // constant folding (as the field can be changed after initialization).
437           //
438           // The check is performed after verification and only if verification has
439           // succeeded. Therefore, the class is guaranteed to be well-formed.
440           InstanceKlass* klass = method-&gt;method_holder();
441           u2 bc_index = Bytes::get_Java_u2(bcp + prefix_length + 1);
<span class="line-modified">442           constantPoolHandle cp(method-&gt;constants());</span>
443           Symbol* ref_class_name = cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(bc_index));
444 
445           if (klass-&gt;name() == ref_class_name) {
446             Symbol* field_name = cp-&gt;name_ref_at(bc_index);
447             Symbol* field_sig = cp-&gt;signature_ref_at(bc_index);
448 
449             fieldDescriptor fd;
450             if (klass-&gt;find_field(field_name, field_sig, &amp;fd) != NULL) {
451               if (fd.access_flags().is_final()) {
452                 if (fd.access_flags().is_static()) {
453                   if (!method-&gt;is_static_initializer()) {
454                     fd.set_has_initialized_final_update(true);
455                   }
456                 } else {
457                   if (!method-&gt;is_object_initializer()) {
458                     fd.set_has_initialized_final_update(true);
459                   }
460                 }
461               }
462             }
</pre>
<hr />
<pre>
531     while (i-- &gt; 0) {
532       Method* method = _methods-&gt;at(i);
533       if (method-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
534         // rewrite the return bytecodes of Object.&lt;init&gt; to register the
535         // object for finalization if needed.
536         methodHandle m(THREAD, method);
537         rewrite_Object_init(m, CHECK);
538         did_rewrite = true;
539         break;
540       }
541     }
542     assert(did_rewrite, &quot;must find Object::&lt;init&gt; to rewrite it&quot;);
543   }
544 
545   // rewrite methods, in two passes
546   int len = _methods-&gt;length();
547   bool invokespecial_error = false;
548 
549   for (int i = len-1; i &gt;= 0; i--) {
550     Method* method = _methods-&gt;at(i);
<span class="line-modified">551     scan_method(method, false, &amp;invokespecial_error);</span>
552     if (invokespecial_error) {
553       // If you get an error here, there is no reversing bytecodes
554       // This exception is stored for this class and no further attempt is
555       // made at verifying or rewriting.
556       THROW_MSG(vmSymbols::java_lang_InternalError(),
557                 &quot;This classfile overflows invokespecial for interfaces &quot;
558                 &quot;and cannot be loaded&quot;);
559       return;
560      }
561   }
562 
563   // May have to fix invokedynamic bytecodes if invokestatic/InterfaceMethodref
564   // entries had to be added.
565   patch_invokedynamic_bytecodes();
566 }
567 
568 void Rewriter::rewrite(InstanceKlass* klass, TRAPS) {
569   if (!DumpSharedSpaces) {
570     assert(!klass-&gt;is_shared(), &quot;archive methods must not be rewritten at run time&quot;);
571   }
572   ResourceMark rm(THREAD);
<span class="line-modified">573   Rewriter     rw(klass, klass-&gt;constants(), klass-&gt;methods(), CHECK);</span>

574   // (That&#39;s all, folks.)
575 }
576 
577 Rewriter::Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS)
578   : _klass(klass),
579     _pool(cpool),
580     _methods(methods),
581     _cp_map(cpool-&gt;length()),
582     _cp_cache_map(cpool-&gt;length() / 2),
583     _reference_map(cpool-&gt;length()),
584     _resolved_references_map(cpool-&gt;length() / 2),
585     _invokedynamic_references_map(cpool-&gt;length() / 2),
586     _method_handle_invokers(cpool-&gt;length()),
587     _invokedynamic_cp_cache_map(cpool-&gt;length() / 4)
588 {
589 
590   // Rewrite bytecodes - exception here exits.
591   rewrite_bytecodes(CHECK);
592 
593   // Stress restoring bytecodes
594   if (StressRewriter) {
<span class="line-modified">595     restore_bytecodes();</span>
596     rewrite_bytecodes(CHECK);
597   }
598 
599   // allocate constant pool cache, now that we&#39;ve seen all the bytecodes
600   make_constant_pool_cache(THREAD);
601 
602   // Restore bytecodes to their unrewritten state if there are exceptions
603   // rewriting bytecodes or allocating the cpCache
604   if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">605     restore_bytecodes();</span>
606     return;
607   }
608 
609   // Relocate after everything, but still do this under the is_rewritten flag,
610   // so methods with jsrs in custom class lists in aren&#39;t attempted to be
611   // rewritten in the RO section of the shared archive.
612   // Relocated bytecodes don&#39;t have to be restored, only the cp cache entries
613   int len = _methods-&gt;length();
614   for (int i = len-1; i &gt;= 0; i--) {
615     methodHandle m(THREAD, _methods-&gt;at(i));
616 
617     if (m-&gt;has_jsrs()) {
618       m = rewrite_jsrs(m, THREAD);
619       // Restore bytecodes to their unrewritten state if there are exceptions
620       // relocating bytecodes.  If some are relocated, that is ok because that
621       // doesn&#39;t affect constant pool to cpCache rewriting.
622       if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">623         restore_bytecodes();</span>
624         return;
625       }
626       // Method might have gotten rewritten.
627       methods-&gt;at_put(i, m());
628     }
629   }
630 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 63         if (_pool-&gt;symbol_at(i) == vmSymbols::java_lang_invoke_MethodHandle() ||
 64             _pool-&gt;symbol_at(i) == vmSymbols::java_lang_invoke_VarHandle()) {
 65           saw_mh_symbol = true;
 66         }
 67         break;
 68     }
 69   }
 70 
 71   // Record limits of resolved reference map for constant pool cache indices
 72   record_map_limits();
 73 
 74   guarantee((int) _cp_cache_map.length() - 1 &lt;= (int) ((u2)-1),
 75             &quot;all cp cache indexes fit in a u2&quot;);
 76 
 77   if (saw_mh_symbol) {
 78     _method_handle_invokers.at_grow(length, 0);
 79   }
 80 }
 81 
 82 // Unrewrite the bytecodes if an error occurs.
<span class="line-modified"> 83 void Rewriter::restore_bytecodes(Thread* thread) {</span>
 84   int len = _methods-&gt;length();
 85   bool invokespecial_error = false;
 86 
 87   for (int i = len-1; i &gt;= 0; i--) {
 88     Method* method = _methods-&gt;at(i);
<span class="line-modified"> 89     scan_method(thread, method, true, &amp;invokespecial_error);</span>
 90     assert(!invokespecial_error, &quot;reversing should not get an invokespecial error&quot;);
 91   }
 92 }
 93 
 94 // Creates a constant pool cache given a CPC map
 95 void Rewriter::make_constant_pool_cache(TRAPS) {
 96   ClassLoaderData* loader_data = _pool-&gt;pool_holder()-&gt;class_loader_data();
 97   ConstantPoolCache* cache =
 98       ConstantPoolCache::allocate(loader_data, _cp_cache_map,
 99                                   _invokedynamic_cp_cache_map,
100                                   _invokedynamic_references_map, CHECK);
101 
102   // initialize object cache in constant pool
103   _pool-&gt;set_cache(cache);
104   cache-&gt;set_constant_pool(_pool());
105 
106   // _resolved_references is stored in pool-&gt;cache(), so need to be done after
107   // the above lines.
108   _pool-&gt;initialize_resolved_references(loader_data, _resolved_references_map,
109                                         _resolved_reference_limit,
</pre>
<hr />
<pre>
313         _invokedynamic_references_map.at_put(resolved_index, cache_index + delta);
314     }
315   }
316 }
317 
318 
319 // Rewrite some ldc bytecodes to _fast_aldc
320 void Rewriter::maybe_rewrite_ldc(address bcp, int offset, bool is_wide,
321                                  bool reverse) {
322   if (!reverse) {
323     assert((*bcp) == (is_wide ? Bytecodes::_ldc_w : Bytecodes::_ldc), &quot;not ldc bytecode&quot;);
324     address p = bcp + offset;
325     int cp_index = is_wide ? Bytes::get_Java_u2(p) : (u1)(*p);
326     constantTag tag = _pool-&gt;tag_at(cp_index).value();
327 
328     if (tag.is_method_handle() ||
329         tag.is_method_type() ||
330         tag.is_string() ||
331         (tag.is_dynamic_constant() &amp;&amp;
332          // keep regular ldc interpreter logic for condy primitives
<span class="line-modified">333          is_reference_type(Signature::basic_type(_pool-&gt;uncached_signature_ref_at(cp_index))))</span>
334         ) {
335       int ref_index = cp_entry_to_resolved_references(cp_index);
336       if (is_wide) {
337         (*bcp) = Bytecodes::_fast_aldc_w;
338         assert(ref_index == (u2)ref_index, &quot;index overflow&quot;);
339         Bytes::put_native_u2(p, ref_index);
340       } else {
341         (*bcp) = Bytecodes::_fast_aldc;
342         assert(ref_index == (u1)ref_index, &quot;index overflow&quot;);
343         (*p) = (u1)ref_index;
344       }
345     }
346   } else {
347     Bytecodes::Code rewritten_bc =
348               (is_wide ? Bytecodes::_fast_aldc_w : Bytecodes::_fast_aldc);
349     if ((*bcp) == rewritten_bc) {
350       address p = bcp + offset;
351       int ref_index = is_wide ? Bytes::get_native_u2(p) : (u1)(*p);
352       int pool_index = resolved_references_entry_to_pool_index(ref_index);
353       if (is_wide) {
354         (*bcp) = Bytecodes::_ldc_w;
355         assert(pool_index == (u2)pool_index, &quot;index overflow&quot;);
356         Bytes::put_Java_u2(p, pool_index);
357       } else {
358         (*bcp) = Bytecodes::_ldc;
359         assert(pool_index == (u1)pool_index, &quot;index overflow&quot;);
360         (*p) = (u1)pool_index;
361       }
362     }
363   }
364 }
365 
366 
367 // Rewrites a method given the index_map information
<span class="line-modified">368 void Rewriter::scan_method(Thread* thread, Method* method, bool reverse, bool* invokespecial_error) {</span>
369 
370   int nof_jsrs = 0;
371   bool has_monitor_bytecodes = false;
372   Bytecodes::Code c;
373 
374   // Bytecodes and their length
375   const address code_base = method-&gt;code_base();
376   const int code_length = method-&gt;code_size();
377 
378   int bc_length;
379   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
380     address bcp = code_base + bci;
381     int prefix_length = 0;
382     c = (Bytecodes::Code)(*bcp);
383 
384     // Since we have the code, see if we can get the length
385     // directly. Some more complicated bytecodes will report
386     // a length of zero, meaning we need to make another method
387     // call to calculate the length.
388     bc_length = Bytecodes::length_for(c);
</pre>
<hr />
<pre>
422         break;
423       }
424 
425       case Bytecodes::_invokespecial  : {
426         rewrite_invokespecial(bcp, prefix_length+1, reverse, invokespecial_error);
427         break;
428       }
429 
430       case Bytecodes::_putstatic      :
431       case Bytecodes::_putfield       : {
432         if (!reverse) {
433           // Check if any final field of the class given as parameter is modified
434           // outside of initializer methods of the class. Fields that are modified
435           // are marked with a flag. For marked fields, the compilers do not perform
436           // constant folding (as the field can be changed after initialization).
437           //
438           // The check is performed after verification and only if verification has
439           // succeeded. Therefore, the class is guaranteed to be well-formed.
440           InstanceKlass* klass = method-&gt;method_holder();
441           u2 bc_index = Bytes::get_Java_u2(bcp + prefix_length + 1);
<span class="line-modified">442           constantPoolHandle cp(thread, method-&gt;constants());</span>
443           Symbol* ref_class_name = cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(bc_index));
444 
445           if (klass-&gt;name() == ref_class_name) {
446             Symbol* field_name = cp-&gt;name_ref_at(bc_index);
447             Symbol* field_sig = cp-&gt;signature_ref_at(bc_index);
448 
449             fieldDescriptor fd;
450             if (klass-&gt;find_field(field_name, field_sig, &amp;fd) != NULL) {
451               if (fd.access_flags().is_final()) {
452                 if (fd.access_flags().is_static()) {
453                   if (!method-&gt;is_static_initializer()) {
454                     fd.set_has_initialized_final_update(true);
455                   }
456                 } else {
457                   if (!method-&gt;is_object_initializer()) {
458                     fd.set_has_initialized_final_update(true);
459                   }
460                 }
461               }
462             }
</pre>
<hr />
<pre>
531     while (i-- &gt; 0) {
532       Method* method = _methods-&gt;at(i);
533       if (method-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
534         // rewrite the return bytecodes of Object.&lt;init&gt; to register the
535         // object for finalization if needed.
536         methodHandle m(THREAD, method);
537         rewrite_Object_init(m, CHECK);
538         did_rewrite = true;
539         break;
540       }
541     }
542     assert(did_rewrite, &quot;must find Object::&lt;init&gt; to rewrite it&quot;);
543   }
544 
545   // rewrite methods, in two passes
546   int len = _methods-&gt;length();
547   bool invokespecial_error = false;
548 
549   for (int i = len-1; i &gt;= 0; i--) {
550     Method* method = _methods-&gt;at(i);
<span class="line-modified">551     scan_method(THREAD, method, false, &amp;invokespecial_error);</span>
552     if (invokespecial_error) {
553       // If you get an error here, there is no reversing bytecodes
554       // This exception is stored for this class and no further attempt is
555       // made at verifying or rewriting.
556       THROW_MSG(vmSymbols::java_lang_InternalError(),
557                 &quot;This classfile overflows invokespecial for interfaces &quot;
558                 &quot;and cannot be loaded&quot;);
559       return;
560      }
561   }
562 
563   // May have to fix invokedynamic bytecodes if invokestatic/InterfaceMethodref
564   // entries had to be added.
565   patch_invokedynamic_bytecodes();
566 }
567 
568 void Rewriter::rewrite(InstanceKlass* klass, TRAPS) {
569   if (!DumpSharedSpaces) {
570     assert(!klass-&gt;is_shared(), &quot;archive methods must not be rewritten at run time&quot;);
571   }
572   ResourceMark rm(THREAD);
<span class="line-modified">573   constantPoolHandle cpool(THREAD, klass-&gt;constants());</span>
<span class="line-added">574   Rewriter     rw(klass, cpool, klass-&gt;methods(), CHECK);</span>
575   // (That&#39;s all, folks.)
576 }
577 
578 Rewriter::Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS)
579   : _klass(klass),
580     _pool(cpool),
581     _methods(methods),
582     _cp_map(cpool-&gt;length()),
583     _cp_cache_map(cpool-&gt;length() / 2),
584     _reference_map(cpool-&gt;length()),
585     _resolved_references_map(cpool-&gt;length() / 2),
586     _invokedynamic_references_map(cpool-&gt;length() / 2),
587     _method_handle_invokers(cpool-&gt;length()),
588     _invokedynamic_cp_cache_map(cpool-&gt;length() / 4)
589 {
590 
591   // Rewrite bytecodes - exception here exits.
592   rewrite_bytecodes(CHECK);
593 
594   // Stress restoring bytecodes
595   if (StressRewriter) {
<span class="line-modified">596     restore_bytecodes(THREAD);</span>
597     rewrite_bytecodes(CHECK);
598   }
599 
600   // allocate constant pool cache, now that we&#39;ve seen all the bytecodes
601   make_constant_pool_cache(THREAD);
602 
603   // Restore bytecodes to their unrewritten state if there are exceptions
604   // rewriting bytecodes or allocating the cpCache
605   if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">606     restore_bytecodes(THREAD);</span>
607     return;
608   }
609 
610   // Relocate after everything, but still do this under the is_rewritten flag,
611   // so methods with jsrs in custom class lists in aren&#39;t attempted to be
612   // rewritten in the RO section of the shared archive.
613   // Relocated bytecodes don&#39;t have to be restored, only the cp cache entries
614   int len = _methods-&gt;length();
615   for (int i = len-1; i &gt;= 0; i--) {
616     methodHandle m(THREAD, _methods-&gt;at(i));
617 
618     if (m-&gt;has_jsrs()) {
619       m = rewrite_jsrs(m, THREAD);
620       // Restore bytecodes to their unrewritten state if there are exceptions
621       // relocating bytecodes.  If some are relocated, that is ok because that
622       // doesn&#39;t affect constant pool to cpCache rewriting.
623       if (HAS_PENDING_EXCEPTION) {
<span class="line-modified">624         restore_bytecodes(THREAD);</span>
625         return;
626       }
627       // Method might have gotten rewritten.
628       methods-&gt;at_put(i, m());
629     }
630   }
631 }
</pre>
</td>
</tr>
</table>
<center><a href="oopMapCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
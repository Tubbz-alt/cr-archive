<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="invocationCounter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,29 +28,29 @@</span>
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/resolutionErrors.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
<span class="udiff-line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/reflection.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,12 +138,12 @@</span>
    if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
      resolved_klass = resolved_method_holder;
    }
    _resolved_klass  = resolved_klass;
    _selected_klass  = resolved_klass;
<span class="udiff-line-modified-removed">-   _resolved_method = resolved_method;</span>
<span class="udiff-line-modified-removed">-   _selected_method = resolved_method;</span>
<span class="udiff-line-modified-added">+   _resolved_method = methodHandle(THREAD, resolved_method);</span>
<span class="udiff-line-modified-added">+   _selected_method = methodHandle(THREAD, resolved_method);</span>
    // classify:
    CallKind kind = CallInfo::unknown_kind;
    int index = resolved_method-&gt;vtable_index();
    if (resolved_method-&gt;can_be_statically_bound()) {
      kind = CallInfo::direct_call;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151,11 +151,11 @@</span>
      // Could be an Object method inherited into an interface, but still a vtable call.
      kind = CallInfo::vtable_call;
    } else if (!resolved_klass-&gt;is_interface()) {
      // A default or miranda method.  Compute the vtable index.
      index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
<span class="udiff-line-modified-removed">-                            resolved_method);</span>
<span class="udiff-line-modified-added">+                            _resolved_method);</span>
      assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
  
      kind = CallInfo::vtable_call;
    } else if (resolved_method-&gt;has_vtable_index()) {
      // Can occur if an interface redeclares a method of Object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,13 +187,12 @@</span>
  
    DEBUG_ONLY(verify());
  }
  
  void CallInfo::set_resolved_method_name(TRAPS) {
<span class="udiff-line-modified-removed">-   Method* m = _resolved_method();</span>
<span class="udiff-line-modified-removed">-   assert(m != NULL, &quot;Should already have a Method*&quot;);</span>
<span class="udiff-line-removed">-   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);</span>
<span class="udiff-line-modified-added">+   assert(_resolved_method() != NULL, &quot;Should already have a Method*&quot;);</span>
<span class="udiff-line-modified-added">+   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(_resolved_method, CHECK);</span>
    _resolved_method_name = Handle(THREAD, rmethod_name);
  }
  
  #ifdef ASSERT
  void CallInfo::verify() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,14 +261,10 @@</span>
  
    // Coming from the constant pool always checks access
    _check_access  = true;
  }
  
<span class="udiff-line-removed">- char* LinkInfo::method_string() const {</span>
<span class="udiff-line-removed">-   return Method::name_and_sig_as_C_string(_resolved_klass, _name, _signature);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  #ifndef PRODUCT
  void LinkInfo::print() {
    ResourceMark rm;
    tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
                  _resolved_klass-&gt;name()-&gt;as_C_string(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -383,34 +378,34 @@</span>
    return result;
  }
  
  // returns first instance method
  // Looks up method in classes, then looks up local default methods
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::lookup_instance_method_in_klasses(Klass* klass,</span>
<span class="udiff-line-modified-removed">-                                                              Symbol* name,</span>
<span class="udiff-line-modified-removed">-                                                              Symbol* signature,</span>
<span class="udiff-line-modified-removed">-                                                              Klass::PrivateLookupMode private_mode, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::lookup_instance_method_in_klasses(Klass* klass,</span>
<span class="udiff-line-modified-added">+                                                         Symbol* name,</span>
<span class="udiff-line-modified-added">+                                                         Symbol* signature,</span>
<span class="udiff-line-modified-added">+                                                         Klass::PrivateLookupMode private_mode, TRAPS) {</span>
    Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
  
    while (result != NULL &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
      Klass* super_klass = result-&gt;method_holder()-&gt;super();
      result = super_klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
    }
  
    if (klass-&gt;is_array_klass()) {
      // Only consider klass and super klass for arrays
<span class="udiff-line-modified-removed">-     return methodHandle(THREAD, result);</span>
<span class="udiff-line-modified-added">+     return result;</span>
    }
  
    if (result == NULL) {
      Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass)-&gt;default_methods();
      if (default_methods != NULL) {
        result = InstanceKlass::find_method(default_methods, name, signature);
        assert(result == NULL || !result-&gt;is_static(), &quot;static defaults not allowed&quot;);
      }
    }
<span class="udiff-line-modified-removed">-   return methodHandle(THREAD, result);</span>
<span class="udiff-line-modified-added">+   return result;</span>
  }
  
  int LinkResolver::vtable_index_of_interface_method(Klass* klass,
                                                     const methodHandle&amp; resolved_method) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -443,14 +438,13 @@</span>
    // interfaces.  Function lookup_method_in_klasses() already looked for
    // the method in the default methods table.
    return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::lookup_polymorphic_method(</span>
<span class="udiff-line-modified-removed">-                                              const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-removed">-                                              Handle *appendix_result_or_null,</span>
<span class="udiff-line-removed">-                                              TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-added">+                                                 Handle *appendix_result_or_null,</span>
<span class="udiff-line-modified-added">+                                                 TRAPS) {</span>
    Klass* klass = link_info.resolved_klass();
    Symbol* name = link_info.name();
    Symbol* full_signature = link_info.signature();
  
    vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,14 +468,14 @@</span>
          tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,
                        name-&gt;as_C_string(),
                        full_signature-&gt;as_C_string(),
                        basic_signature-&gt;as_C_string());
        }
<span class="udiff-line-modified-removed">-       methodHandle result = SystemDictionary::find_method_handle_intrinsic(iid,</span>
<span class="udiff-line-modified-added">+       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,</span>
                                                                basic_signature,
                                                                CHECK_NULL);
<span class="udiff-line-modified-removed">-       if (result.not_null()) {</span>
<span class="udiff-line-modified-added">+       if (result != NULL) {</span>
          assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
          assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
          assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
          if (TraceMethodHandles) {
            ttyLocker ttyl;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -507,11 +501,11 @@</span>
          }
        }
  
        Handle appendix;
        Handle method_type;
<span class="udiff-line-modified-removed">-       methodHandle result = SystemDictionary::find_method_handle_invoker(</span>
<span class="udiff-line-modified-added">+       Method* result = SystemDictionary::find_method_handle_invoker(</span>
                                                              klass,
                                                              name,
                                                              full_signature,
                                                              link_info.current_klass(),
                                                              &amp;appendix,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,11 +516,11 @@</span>
          result-&gt;print_on(tty);
          tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);
          if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);
          else                     appendix-&gt;print_on(tty);
        }
<span class="udiff-line-modified-removed">-       if (result.not_null()) {</span>
<span class="udiff-line-modified-added">+       if (result != NULL) {</span>
  #ifdef ASSERT
          ResourceMark rm(THREAD);
  
          TempNewSymbol basic_signature =
            MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -591,28 +585,26 @@</span>
      ResourceMark rm(THREAD);
      bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_IllegalAccessError(),
<span class="udiff-line-modified-removed">-       &quot;class %s tried to access %s%s%smethod %s.%s%s (%s%s%s)&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,</span>
        ref_klass-&gt;external_name(),
        sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,
        sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,
        sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,
<span class="udiff-line-modified-removed">-       sel_klass-&gt;external_name(),</span>
<span class="udiff-line-removed">-       sel_method-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-       sel_method-&gt;signature()-&gt;as_C_string(),</span>
<span class="udiff-line-modified-added">+       sel_method-&gt;external_name(),</span>
        (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
        (same_module) ? &quot;&quot; : &quot;; &quot;,
        (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
      );
      return;
    }
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_method_statically(Bytecodes::Code code,</span>
<span class="udiff-line-modified-removed">-                                                      const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,</span>
<span class="udiff-line-modified-added">+                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
    // This method is used only
    // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
    // and
    // (2) in Bytecode_invoke::static_target
    // It appears to fail when applied to an invokeinterface call site.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -633,11 +625,11 @@</span>
    if (pool-&gt;has_preresolution()
        || (resolved_klass == SystemDictionary::MethodHandle_klass() &amp;&amp;
            MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
      Method* result = ConstantPool::method_at_if_loaded(pool, index);
      if (result != NULL) {
<span class="udiff-line-modified-removed">-       return methodHandle(THREAD, result);</span>
<span class="udiff-line-modified-added">+       return result;</span>
      }
    }
  
    if (code == Bytecodes::_invokeinterface) {
      return resolve_interface_method(link_info, code, THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -668,16 +660,15 @@</span>
      Klass* resolved_method_class = resolved_method-&gt;method_holder();
      ClassLoaderData* target_loader_data = resolved_method_class-&gt;class_loader_data();
      assert(target_loader_data != NULL, &quot;resolved method&#39;s class has no class loader data&quot;);
  
      stringStream ss;
<span class="udiff-line-modified-removed">-     ss.print(&quot;loader constraint violation: when resolving %s&quot;</span>
<span class="udiff-line-modified-removed">-              &quot; \&quot;%s\&quot; the class loader %s of the current class, %s,&quot;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;loader constraint violation: when resolving %s &#39;&quot;, method_type);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39; the class loader %s of the current class, %s,&quot;</span>
               &quot; and the class loader %s for the method&#39;s defining class, %s, have&quot;
               &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="udiff-line-removed">-              method_type,</span>
<span class="udiff-line-removed">-              link_info.method_string(),</span>
               current_loader_data-&gt;loader_name_and_id(),
               current_class-&gt;name()-&gt;as_C_string(),
               target_loader_data-&gt;loader_name_and_id(),
               resolved_method_class-&gt;name()-&gt;as_C_string(),
               failed_type_symbol-&gt;as_C_string(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -719,12 +710,12 @@</span>
               sel_klass-&gt;class_in_module_of_loader(false, true));
      THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
    }
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-removed">-                                           Bytecodes::Code code, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-added">+                                      Bytecodes::Code code, TRAPS) {</span>
  
    Handle nested_exception;
    Klass* resolved_klass = link_info.resolved_klass();
  
    // 1. For invokevirtual, cannot call an interface method
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -737,13 +728,15 @@</span>
    }
  
    // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
    if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_method()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Method %s must be Methodref constant&quot;, link_info.method_string());</span>
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39; must be Methodref constant&quot;);</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    // 3. lookup method in resolved klass and its super klasses
    methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -751,26 +744,28 @@</span>
    if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) { // not found in the class hierarchy
      resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
  
      if (resolved_method.is_null()) {
        // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
<span class="udiff-line-modified-removed">-       resolved_method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);</span>
<span class="udiff-line-modified-added">+       Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);</span>
<span class="udiff-line-added">+       resolved_method = methodHandle(THREAD, method);</span>
        if (HAS_PENDING_EXCEPTION) {
          nested_exception = Handle(THREAD, PENDING_EXCEPTION);
          CLEAR_PENDING_EXCEPTION;
        }
      }
    }
  
    // 5. method lookup failed
    if (resolved_method.is_null()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-added">+     stringStream ss;</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39;&quot;);</span>
      THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
<span class="udiff-line-modified-removed">-                     Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-removed">-                                                      link_info.name(),</span>
<span class="udiff-line-removed">-                                                      link_info.signature()),</span>
<span class="udiff-line-removed">-                     nested_exception, NULL);</span>
<span class="udiff-line-modified-added">+                      ss.as_string(), nested_exception, NULL);</span>
    }
  
    // 6. access checks, access checking may be turned off when calling from within the VM.
    Klass* current_klass = link_info.current_klass();
    if (link_info.check_access()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -785,17 +780,17 @@</span>
  
      // check loader constraints
      check_method_loader_constraints(link_info, resolved_method, &quot;method&quot;, CHECK_NULL);
    }
  
<span class="udiff-line-modified-removed">-   return resolved_method;</span>
<span class="udiff-line-modified-added">+   return resolved_method();</span>
  }
  
  static void trace_method_resolution(const char* prefix,
                                      Klass* klass,
                                      Klass* resolved_klass,
<span class="udiff-line-modified-removed">-                                     const methodHandle&amp; method,</span>
<span class="udiff-line-modified-added">+                                     Method* method,</span>
                                      bool logitables,
                                      int index = -1) {
  #ifndef PRODUCT
    ResourceMark rm;
    Log(itables) logi;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -823,11 +818,11 @@</span>
    st-&gt;cr();
  #endif // PRODUCT
  }
  
  // Do linktime resolution of a method in the interface within the context of the specied bytecode.
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {</span>
  
    Klass* resolved_klass = link_info.resolved_klass();
  
    // check if klass is interface
    if (!resolved_klass-&gt;is_interface()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,13 +833,15 @@</span>
    }
  
    // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
    if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_interface_method()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Method %s must be InterfaceMethodref constant&quot;, link_info.method_string());</span>
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39; must be InterfaceMethodref constant&quot;);</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    // lookup method in this interface or its super, java.lang.Object
    // JDK8: also look for static methods
    methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -855,14 +852,15 @@</span>
    }
  
    if (resolved_method.is_null()) {
      // no method found
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(),</span>
<span class="udiff-line-modified-removed">-                    Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                     link_info.name(),</span>
<span class="udiff-line-modified-removed">-                                                     link_info.signature()));</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());</span>
    }
  
    if (link_info.check_access()) {
      // JDK8 adds non-public interface methods, and accessability check requirement
      Klass* current_klass = link_info.current_klass();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -879,26 +877,26 @@</span>
      check_method_loader_constraints(link_info, resolved_method, &quot;interface method&quot;, CHECK_NULL);
    }
  
    if (code != Bytecodes::_invokestatic &amp;&amp; resolved_method-&gt;is_static()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Expected instance not static method %s&quot;,</span>
<span class="udiff-line-modified-removed">-                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                  resolved_method-&gt;name(), resolved_method-&gt;signature()));</span>
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Expected instance not static method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, resolved_klass,</span>
<span class="udiff-line-modified-added">+                                 resolved_method-&gt;name(), resolved_method-&gt;signature());</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    if (log_develop_is_enabled(Trace, itables)) {
      char buf[200];
      jio_snprintf(buf, sizeof(buf), &quot;%s resolved interface method: caller-class:&quot;,
                   Bytecodes::name(code));
<span class="udiff-line-modified-removed">-     trace_method_resolution(buf, link_info.current_klass(), resolved_klass,</span>
<span class="udiff-line-removed">-                             resolved_method, true);</span>
<span class="udiff-line-modified-added">+     trace_method_resolution(buf, link_info.current_klass(), resolved_klass, resolved_method(), true);</span>
    }
  
<span class="udiff-line-modified-removed">-   return resolved_method;</span>
<span class="udiff-line-modified-added">+   return resolved_method();</span>
  }
  
  //------------------------------------------------------------------------------------------------------------------------
  // Field resolution
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -997,23 +995,23 @@</span>
                  current_klass-&gt;external_name());
          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
        }
  
        if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
<span class="udiff-line-modified-removed">-         methodHandle m = link_info.current_method();</span>
<span class="udiff-line-modified-removed">-         assert(!m.is_null(), &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);</span>
<span class="udiff-line-modified-added">+         Method* m = link_info.current_method();</span>
<span class="udiff-line-modified-added">+         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);</span>
          bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
                                                     fd.is_static() &amp;&amp;
<span class="udiff-line-modified-removed">-                                                    !m()-&gt;is_static_initializer());</span>
<span class="udiff-line-modified-added">+                                                    !m-&gt;is_static_initializer());</span>
          bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
                                                       !fd.is_static() &amp;&amp;
                                                       !m-&gt;is_object_initializer());
  
          if (is_initialized_static_final_update || is_initialized_instance_final_update) {
            ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
                     is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="udiff-line-modified-removed">-                    m()-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-modified-added">+                    m-&gt;name()-&gt;as_C_string(),</span>
                     is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
            THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
          }
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1050,11 +1048,11 @@</span>
  
  
  void LinkResolver::resolve_static_call(CallInfo&amp; result,
                                         const LinkInfo&amp; link_info,
                                         bool initialize_class, TRAPS) {
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = linktime_resolve_static_method(link_info, CHECK);</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = linktime_resolve_static_method(link_info, CHECK);</span>
  
    // The resolved class can change as a result of this resolution.
    Klass* resolved_klass = resolved_method-&gt;method_holder();
  
    // Initialize klass (this should only happen if everything is ok)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1066,58 +1064,57 @@</span>
                        link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
      resolved_method = linktime_resolve_static_method(new_info, CHECK);
    }
  
    // setup result
<span class="udiff-line-modified-removed">-   result.set_static(resolved_klass, resolved_method, CHECK);</span>
<span class="udiff-line-modified-added">+   result.set_static(resolved_klass, methodHandle(THREAD, resolved_method), CHECK);</span>
  }
  
  // throws linktime exceptions
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {</span>
  
    Klass* resolved_klass = link_info.resolved_klass();
<span class="udiff-line-modified-removed">-   methodHandle resolved_method;</span>
<span class="udiff-line-modified-added">+   Method* resolved_method;</span>
    if (!resolved_klass-&gt;is_interface()) {
      resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
    } else {
      resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
    }
    assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), &quot;should have been checked in verifier&quot;);
  
    // check if static
    if (!resolved_method-&gt;is_static()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Expected static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                       resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                       resolved_method-&gt;signature()));</span>
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Expected static method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
    return resolved_method;
  }
  
  
  void LinkResolver::resolve_special_call(CallInfo&amp; result,
                                          Handle recv,
                                          const LinkInfo&amp; link_info,
                                          TRAPS) {
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = linktime_resolve_special_method(link_info, CHECK);</span>
<span class="udiff-line-modified-removed">-   runtime_resolve_special_method(result, link_info, resolved_method, recv, CHECK);</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = linktime_resolve_special_method(link_info, CHECK);</span>
<span class="udiff-line-modified-added">+   runtime_resolve_special_method(result, link_info, methodHandle(THREAD, resolved_method), recv, CHECK);</span>
  }
  
  // throws linktime exceptions
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-removed">-                                                            TRAPS) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {</span>
  
    // Invokespecial is called for multiple special reasons:
    // &lt;init&gt;
    // local private method invocation, for classes and interfaces
    // superclass.method, which can also resolve to a default method
    // and the selected method is recalculated relative to the direct superclass
    // superinterface.method, which explicitly does not check shadowing
    Klass* resolved_klass = link_info.resolved_klass();
<span class="udiff-line-modified-removed">-   methodHandle resolved_method;</span>
<span class="udiff-line-modified-added">+   Method* resolved_method;</span>
  
    if (!resolved_klass-&gt;is_interface()) {
      resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
    } else {
      resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1125,18 +1122,20 @@</span>
  
    // check if method name is &lt;init&gt;, that it is found in same klass as static type
    if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
        resolved_method-&gt;method_holder() != resolved_klass) {
      ResourceMark rm(THREAD);
<span class="udiff-line-added">+     stringStream ss;</span>
<span class="udiff-line-added">+     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());</span>
<span class="udiff-line-added">+     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="udiff-line-added">+     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-added">+     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="udiff-line-added">+     ss.print(&quot;)&#39; not found&quot;);</span>
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_NoSuchMethodError(),
<span class="udiff-line-modified-removed">-       &quot;%s: method %s%s not found&quot;,</span>
<span class="udiff-line-removed">-       resolved_klass-&gt;external_name(),</span>
<span class="udiff-line-removed">-       resolved_method-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-       resolved_method-&gt;signature()-&gt;as_C_string()</span>
<span class="udiff-line-removed">-     );</span>
<span class="udiff-line-modified-added">+       &quot;%s&quot;, ss.as_string());</span>
      return NULL;
    }
  
    // ensure that invokespecial&#39;s interface method reference is in
    // a direct superinterface, not an indirect superinterface
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1151,31 +1150,27 @@</span>
                          SystemDictionary::reflect_MagicAccessorImpl_klass());
  
      if (!is_reflect &amp;&amp;
          !klass_to_check-&gt;is_same_or_direct_interface(resolved_klass)) {
        ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-       char buf[200];</span>
<span class="udiff-line-modified-removed">-       jio_snprintf(buf, sizeof(buf),</span>
<span class="udiff-line-modified-removed">-                    &quot;Interface method reference: %s, is in an indirect superinterface of %s&quot;,</span>
<span class="udiff-line-modified-removed">-                    Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                                            resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                                            resolved_method-&gt;signature()),</span>
<span class="udiff-line-removed">-                    current_klass-&gt;external_name());</span>
<span class="udiff-line-removed">-       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+       stringStream ss;</span>
<span class="udiff-line-modified-added">+       ss.print(&quot;Interface method reference: &#39;&quot;);</span>
<span class="udiff-line-modified-added">+       resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+       ss.print(&quot;&#39;, is in an indirect superinterface of %s&quot;,</span>
<span class="udiff-line-modified-added">+                current_klass-&gt;external_name());</span>
<span class="udiff-line-modified-added">+       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
      }
    }
  
    // check if not static
    if (resolved_method-&gt;is_static()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf),</span>
<span class="udiff-line-modified-removed">-                  &quot;Expecting non-static method %s&quot;,</span>
<span class="udiff-line-modified-removed">-                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                   resolved_method-&gt;name(),</span>
<span class="udiff-line-removed">-                                                   resolved_method-&gt;signature()));</span>
<span class="udiff-line-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    if (log_develop_is_enabled(Trace, itables)) {
      trace_method_resolution(&quot;invokespecial resolved method: caller-class:&quot;,
                              current_klass, resolved_klass, resolved_method, true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1210,21 +1205,24 @@</span>
      // in super interfaces.
      if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
          current_klass != resolved_klass) {
        // Lookup super method
        Klass* super_klass = current_klass-&gt;super();
<span class="udiff-line-modified-removed">-       sel_method = lookup_instance_method_in_klasses(super_klass,</span>
<span class="udiff-line-modified-added">+       Method* instance_method = lookup_instance_method_in_klasses(super_klass,</span>
                                                       resolved_method-&gt;name(),
                                                       resolved_method-&gt;signature(),
                                                       Klass::find_private, CHECK);
<span class="udiff-line-added">+       sel_method = methodHandle(THREAD, instance_method);</span>
<span class="udiff-line-added">+ </span>
        // check if found
        if (sel_method.is_null()) {
          ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="udiff-line-modified-removed">-                   Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                             resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                             resolved_method-&gt;signature()));</span>
<span class="udiff-line-modified-added">+         stringStream ss;</span>
<span class="udiff-line-modified-added">+         ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+         resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+         ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>
        // check loader constraints if found a different method
        } else if (sel_method() != resolved_method()) {
          check_method_loader_constraints(link_info, sel_method, &quot;method&quot;, CHECK);
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1242,60 +1240,61 @@</span>
        if (!receiver_klass-&gt;is_subtype_of(sender)) {
          ResourceMark rm(THREAD);
          char buf[500];
          jio_snprintf(buf, sizeof(buf),
                       &quot;Receiver class %s must be the current class or a subtype of interface %s&quot;,
<span class="udiff-line-modified-removed">-                      receiver_klass-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-modified-removed">-                      sender-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-modified-added">+                      receiver_klass-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+                      sender-&gt;external_name());</span>
          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
        }
      }
    }
  
    // check if not static
    if (sel_method-&gt;is_static()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Expecting non-static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                                                       resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                                                       resolved_method-&gt;signature()));</span>
<span class="udiff-line-modified-removed">-     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    // check if abstract
    if (sel_method-&gt;is_abstract()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="udiff-line-modified-removed">-               Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                sel_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                sel_method-&gt;signature()));</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     Method::print_external_name(&amp;ss, resolved_klass, sel_method-&gt;name(), sel_method-&gt;signature());</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>
    }
  
    if (log_develop_is_enabled(Trace, itables)) {
      trace_method_resolution(&quot;invokespecial selected method: resolved-class:&quot;,
<span class="udiff-line-modified-removed">-                             resolved_klass, resolved_klass, sel_method, true);</span>
<span class="udiff-line-modified-added">+                             resolved_klass, resolved_klass, sel_method(), true);</span>
    }
  
    // setup result
    result.set_static(resolved_klass, sel_method, CHECK);
  }
  
  void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, Klass* receiver_klass,
                                          const LinkInfo&amp; link_info,
                                          bool check_null_and_abstract, TRAPS) {
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = linktime_resolve_virtual_method(link_info, CHECK);</span>
<span class="udiff-line-modified-removed">-   runtime_resolve_virtual_method(result, resolved_method,</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);</span>
<span class="udiff-line-modified-added">+   runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),</span>
                                   link_info.resolved_klass(),
                                   recv, receiver_klass,
                                   check_null_and_abstract, CHECK);
  }
  
  // throws linktime exceptions
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,</span>
                                                             TRAPS) {
    // normal method resolution
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);</span>
  
    assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
    assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
  
    // check if private interface method
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1303,27 +1302,26 @@</span>
    Klass* current_klass = link_info.current_klass();
  
    // This is impossible, if resolve_klass is an interface, we&#39;ve thrown icce in resolve_method
    if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;private interface method requires invokespecial, not invokevirtual: method %s, caller-class:%s&quot;,</span>
<span class="udiff-line-modified-removed">-                  Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                   resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                   resolved_method-&gt;signature()),</span>
<span class="udiff-line-modified-removed">-                    (current_klass == NULL ? &quot;&lt;NULL&gt;&quot; : current_klass-&gt;internal_name()));</span>
<span class="udiff-line-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;private interface method requires invokespecial, not invokevirtual: method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;, caller-class: %s&quot;,</span>
<span class="udiff-line-modified-added">+              (current_klass == NULL ? &quot;&lt;null&gt;&quot; : current_klass-&gt;internal_name()));</span>
<span class="udiff-line-modified-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    // check if not static
    if (resolved_method-&gt;is_static()) {
      ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-     char buf[200];</span>
<span class="udiff-line-modified-removed">-     jio_snprintf(buf, sizeof(buf), &quot;Expecting non-static method %s&quot;, Method::name_and_sig_as_C_string(resolved_klass,</span>
<span class="udiff-line-modified-removed">-                                                                                            resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                                                            resolved_method-&gt;signature()));</span>
<span class="udiff-line-modified-removed">-     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+     stringStream ss;</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Expecting non-static method &#39;&quot;);</span>
<span class="udiff-line-modified-added">+     resolved_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
    }
  
    if (log_develop_is_enabled(Trace, vtables)) {
      trace_method_resolution(&quot;invokevirtual resolved method: caller-class:&quot;,
                              current_klass, resolved_klass, resolved_method, false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1391,30 +1389,31 @@</span>
      throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
    }
  
    if (log_develop_is_enabled(Trace, vtables)) {
      trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
<span class="udiff-line-modified-removed">-                             recv_klass, resolved_klass, selected_method,</span>
<span class="udiff-line-modified-added">+                             recv_klass, resolved_klass, selected_method(),</span>
                              false, vtable_index);
    }
    // setup result
    result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
  }
  
  void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
                                            const LinkInfo&amp; link_info,
                                            bool check_null_and_abstract, TRAPS) {
    // throws linktime exceptions
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = linktime_resolve_interface_method(link_info, CHECK);</span>
<span class="udiff-line-modified-removed">-   runtime_resolve_interface_method(result, resolved_method,link_info.resolved_klass(),</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);</span>
<span class="udiff-line-modified-added">+   methodHandle mh(THREAD, resolved_method);</span>
<span class="udiff-line-added">+   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),</span>
                                     recv, recv_klass, check_null_and_abstract, CHECK);
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,</span>
                                                               TRAPS) {
    // normal interface method resolution
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);</span>
    assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
    assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
  
    return resolved_method;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1448,14 +1447,15 @@</span>
    if (!resolved_method()-&gt;is_private()) {
      // do lookup based on receiver klass
      // This search must match the linktime preparation search for itable initialization
      // to correctly enforce loader constraints for interface method inheritance.
      // Private methods are skipped as the resolved method was not private.
<span class="udiff-line-modified-removed">-     selected_method = lookup_instance_method_in_klasses(recv_klass,</span>
<span class="udiff-line-modified-removed">-                                                         resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                         resolved_method-&gt;signature(),</span>
<span class="udiff-line-modified-removed">-                                                         Klass::skip_private, CHECK);</span>
<span class="udiff-line-modified-added">+     Method* method = lookup_instance_method_in_klasses(recv_klass,</span>
<span class="udiff-line-modified-added">+                                                        resolved_method-&gt;name(),</span>
<span class="udiff-line-modified-added">+                                                        resolved_method-&gt;signature(),</span>
<span class="udiff-line-modified-added">+                                                        Klass::skip_private, CHECK);</span>
<span class="udiff-line-added">+     selected_method = methodHandle(THREAD, method);</span>
  
      if (selected_method.is_null() &amp;&amp; !check_null_and_abstract) {
        // In theory this is a harmless placeholder value, but
        // in practice leaving in null affects the nsk default method tests.
        // This needs further study.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1468,24 +1468,25 @@</span>
      }
      // check access
      // Throw Illegal Access Error if selected_method is not public.
      if (!selected_method-&gt;is_public()) {
        ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="udiff-line-modified-removed">-                 Method::name_and_sig_as_C_string(recv_klass,</span>
<span class="udiff-line-modified-removed">-                                                  selected_method-&gt;name(),</span>
<span class="udiff-line-modified-removed">-                                                  selected_method-&gt;signature()));</span>
<span class="udiff-line-modified-added">+       stringStream ss;</span>
<span class="udiff-line-modified-added">+       ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-modified-added">+       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());</span>
<span class="udiff-line-modified-added">+       ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());</span>
      }
      // check if abstract
      if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
        throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
      }
    }
  
    if (log_develop_is_enabled(Trace, itables)) {
      trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
<span class="udiff-line-modified-removed">-                             recv_klass, resolved_klass, selected_method, true);</span>
<span class="udiff-line-modified-added">+                             recv_klass, resolved_klass, selected_method(), true);</span>
    }
    // setup result
    if (resolved_method-&gt;has_vtable_index()) {
      int vtable_index = resolved_method-&gt;vtable_index();
      log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1507,56 +1508,56 @@</span>
      result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);
    }
  }
  
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_interface_method_or_null(</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_interface_method_or_null(</span>
                                                   const LinkInfo&amp; link_info) {
    EXCEPTION_MARK;
<span class="udiff-line-modified-removed">-   methodHandle method_result = linktime_resolve_interface_method(link_info, THREAD);</span>
<span class="udiff-line-modified-added">+   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);</span>
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    } else {
      return method_result;
    }
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::linktime_resolve_virtual_method_or_null(</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::linktime_resolve_virtual_method_or_null(</span>
                                                   const LinkInfo&amp; link_info) {
    EXCEPTION_MARK;
<span class="udiff-line-modified-removed">-   methodHandle method_result = linktime_resolve_virtual_method(link_info, THREAD);</span>
<span class="udiff-line-modified-added">+   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);</span>
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    } else {
      return method_result;
    }
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_virtual_call_or_null(</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_virtual_call_or_null(</span>
                                                   Klass* receiver_klass,
                                                   const LinkInfo&amp; link_info) {
    EXCEPTION_MARK;
    CallInfo info;
    resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    }
    return info.selected_method();
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_interface_call_or_null(</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_interface_call_or_null(</span>
                                                   Klass* receiver_klass,
                                                   const LinkInfo&amp; link_info) {
    EXCEPTION_MARK;
    CallInfo info;
    resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    }
    return info.selected_method();
  }
  
  int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1570,28 +1571,28 @@</span>
      return Method::invalid_vtable_index;
    }
    return info.vtable_index();
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {</span>
    EXCEPTION_MARK;
    CallInfo info;
    resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    }
    return info.selected_method();
  }
  
<span class="udiff-line-modified-removed">- methodHandle LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {</span>
<span class="udiff-line-modified-added">+ Method* LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {</span>
    EXCEPTION_MARK;
    CallInfo info;
    resolve_special_call(info, Handle(), link_info, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
<span class="udiff-line-modified-removed">-     return methodHandle();</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    }
    return info.selected_method();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1688,107 +1689,88 @@</span>
    Klass* resolved_klass = link_info.resolved_klass();
    assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
           resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
    assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
    Handle       resolved_appendix;
<span class="udiff-line-modified-removed">-   methodHandle resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);</span>
<span class="udiff-line-modified-removed">-   result.set_handle(resolved_klass, resolved_method, resolved_appendix, CHECK);</span>
<span class="udiff-line-modified-added">+   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);</span>
<span class="udiff-line-modified-added">+   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);</span>
  }
  
<span class="udiff-line-modified-removed">- void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Symbol* method_name       = pool-&gt;name_ref_at(index);</span>
<span class="udiff-line-removed">-   Symbol* method_signature  = pool-&gt;signature_ref_at(index);</span>
<span class="udiff-line-removed">-   Klass* current_klass = pool-&gt;pool_holder();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Resolve the bootstrap specifier (BSM + optional arguments).</span>
<span class="udiff-line-removed">-   Handle bootstrap_specifier;</span>
<span class="udiff-line-removed">-   // Check if CallSite has been bound already:</span>
<span class="udiff-line-removed">-   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
<span class="udiff-line-modified-added">+ void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {</span>
<span class="udiff-line-modified-added">+   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);</span>
    int pool_index = cpce-&gt;constant_pool_index();
  
<span class="udiff-line-modified-removed">-   if (cpce-&gt;is_f1_null()) {</span>
<span class="udiff-line-modified-removed">-     if (cpce-&gt;indy_resolution_failed()) {</span>
<span class="udiff-line-removed">-       ConstantPool::throw_resolution_error(pool,</span>
<span class="udiff-line-removed">-                                            ResolutionErrorTable::encode_cpcache_index(index),</span>
<span class="udiff-line-removed">-                                            CHECK);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   // Resolve the bootstrap specifier (BSM + optional arguments).</span>
<span class="udiff-line-modified-added">+   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);</span>
  
<span class="udiff-line-modified-removed">-     // The initial step in Call Site Specifier Resolution is to resolve the symbolic</span>
<span class="udiff-line-modified-removed">-     // reference to a method handle which will be the bootstrap method for a dynamic</span>
<span class="udiff-line-modified-removed">-     // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap</span>
<span class="udiff-line-modified-removed">-     // method fails, then a MethodHandleInError is stored at the corresponding bootstrap</span>
<span class="udiff-line-removed">-     // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to</span>
<span class="udiff-line-removed">-     // set the indy_rf flag since any subsequent invokedynamic instruction which shares</span>
<span class="udiff-line-removed">-     // this bootstrap method will encounter the resolution of MethodHandleInError.</span>
<span class="udiff-line-removed">-     oop bsm_info = pool-&gt;resolve_bootstrap_specifier_at(pool_index, THREAD);</span>
<span class="udiff-line-removed">-     Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="udiff-line-removed">-     assert(bsm_info != NULL, &quot;&quot;);</span>
<span class="udiff-line-removed">-     // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_InvokeDynamic.</span>
<span class="udiff-line-removed">-     bootstrap_specifier = Handle(THREAD, bsm_info);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (!cpce-&gt;is_f1_null()) {</span>
<span class="udiff-line-removed">-     methodHandle method(     THREAD, cpce-&gt;f1_as_method());</span>
<span class="udiff-line-removed">-     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(pool));</span>
<span class="udiff-line-removed">-     result.set_handle(method, appendix, THREAD);</span>
<span class="udiff-line-removed">-     Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-modified-added">+   // Check if CallSite has been bound already or failed already, and short circuit:</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);</span>
<span class="udiff-line-modified-added">+     if (is_done) return;</span>
    }
  
<span class="udiff-line-added">+   // The initial step in Call Site Specifier Resolution is to resolve the symbolic</span>
<span class="udiff-line-added">+   // reference to a method handle which will be the bootstrap method for a dynamic</span>
<span class="udiff-line-added">+   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap</span>
<span class="udiff-line-added">+   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap</span>
<span class="udiff-line-added">+   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to</span>
<span class="udiff-line-added">+   // set the indy_rf flag since any subsequent invokedynamic instruction which shares</span>
<span class="udiff-line-added">+   // this bootstrap method will encounter the resolution of MethodHandleInError.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   resolve_dynamic_call(result, bootstrap_specifier, CHECK);</span>
<span class="udiff-line-added">+ </span>
    if (TraceMethodHandles) {
<span class="udiff-line-modified-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;resolve_invokedynamic #%d %s %s in %s&quot;,</span>
<span class="udiff-line-removed">-                   ConstantPool::decode_invokedynamic_index(index),</span>
<span class="udiff-line-removed">-                   method_name-&gt;as_C_string(), method_signature-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-                   current_klass-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-removed">-     tty-&gt;print(&quot;  BSM info: &quot;); bootstrap_specifier-&gt;print();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   resolve_dynamic_call(result, pool_index, bootstrap_specifier, method_name,</span>
<span class="udiff-line-removed">-                        method_signature, current_klass, THREAD);</span>
<span class="udiff-line-removed">-   if (HAS_PENDING_EXCEPTION &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {</span>
<span class="udiff-line-removed">-     int encoded_index = ResolutionErrorTable::encode_cpcache_index(index);</span>
<span class="udiff-line-removed">-     bool recorded_res_status = cpce-&gt;save_and_throw_indy_exc(pool, pool_index,</span>
<span class="udiff-line-removed">-                                                              encoded_index,</span>
<span class="udiff-line-removed">-                                                              pool()-&gt;tag_at(pool_index),</span>
<span class="udiff-line-removed">-                                                              CHECK);</span>
<span class="udiff-line-removed">-     if (!recorded_res_status) {</span>
<span class="udiff-line-removed">-       // Another thread got here just before we did.  So, either use the method</span>
<span class="udiff-line-removed">-       // that it resolved or throw the LinkageError exception that it threw.</span>
<span class="udiff-line-removed">-       if (!cpce-&gt;is_f1_null()) {</span>
<span class="udiff-line-removed">-         methodHandle method(     THREAD, cpce-&gt;f1_as_method());</span>
<span class="udiff-line-removed">-         Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(pool));</span>
<span class="udiff-line-removed">-         result.set_handle(method, appendix, THREAD);</span>
<span class="udiff-line-removed">-         Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         assert(cpce-&gt;indy_resolution_failed(), &quot;Resolution failure flag not set&quot;);</span>
<span class="udiff-line-removed">-         ConstantPool::throw_resolution_error(pool, encoded_index, CHECK);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(cpce-&gt;indy_resolution_failed(), &quot;Resolution failure flag wasn&#39;t set&quot;);</span>
<span class="udiff-line-modified-added">+     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The returned linkage result is provisional up to the moment</span>
<span class="udiff-line-added">+   // the interpreter or runtime performs a serialized check of</span>
<span class="udiff-line-added">+   // the relevant CPCE::f1 field.  This is done by the caller</span>
<span class="udiff-line-added">+   // of this method, via CPCE::set_dynamic_call, which uses</span>
<span class="udiff-line-added">+   // an ObjectLocker to do the final serialization of updates</span>
<span class="udiff-line-added">+   // to CPCE state, including f1.</span>
  }
  
  void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
<span class="udiff-line-modified-removed">-                                         int pool_index,</span>
<span class="udiff-line-removed">-                                         Handle bootstrap_specifier,</span>
<span class="udiff-line-removed">-                                         Symbol* method_name, Symbol* method_signature,</span>
<span class="udiff-line-removed">-                                         Klass* current_klass,</span>
<span class="udiff-line-modified-added">+                                         BootstrapInfo&amp; bootstrap_specifier,</span>
                                          TRAPS) {
<span class="udiff-line-modified-removed">-   // JSR 292:  this must resolve to an implicitly generated method MH.linkToCallSite(*...)</span>
<span class="udiff-line-modified-added">+   // JSR 292:  this must resolve to an implicitly generated method</span>
<span class="udiff-line-added">+   // such as MH.linkToCallSite(*...) or some other call-site shape.</span>
    // The appendix argument is likely to be a freshly-created CallSite.
<span class="udiff-line-modified-removed">-   Handle       resolved_appendix;</span>
<span class="udiff-line-modified-removed">-   methodHandle resolved_method =</span>
<span class="udiff-line-modified-removed">-     SystemDictionary::find_dynamic_call_site_invoker(current_klass,</span>
<span class="udiff-line-modified-removed">-                                                      pool_index,</span>
<span class="udiff-line-modified-removed">-                                                      bootstrap_specifier,</span>
<span class="udiff-line-modified-removed">-                                                      method_name, method_signature,</span>
<span class="udiff-line-modified-removed">-                                                      &amp;resolved_appendix,</span>
<span class="udiff-line-modified-removed">-                                                      THREAD);</span>
<span class="udiff-line-modified-removed">-   Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="udiff-line-modified-removed">-   result.set_handle(resolved_method, resolved_appendix, THREAD);</span>
<span class="udiff-line-modified-removed">-   Exceptions::wrap_dynamic_exception(CHECK);</span>
<span class="udiff-line-modified-added">+   // It may also be a MethodHandle from an unwrapped ConstantCallSite,</span>
<span class="udiff-line-modified-added">+   // or any other reference.  The resolved_method as well as the appendix</span>
<span class="udiff-line-modified-added">+   // are both recorded together via CallInfo::set_handle.</span>
<span class="udiff-line-modified-added">+   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);</span>
<span class="udiff-line-modified-added">+   Exceptions::wrap_dynamic_exception(THREAD);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-modified-added">+     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {</span>
<span class="udiff-line-modified-added">+       // Let any random low-level IE or SOE or OOME just bleed through.</span>
<span class="udiff-line-modified-added">+       // Basically we pretend that the bootstrap method was never called,</span>
<span class="udiff-line-modified-added">+       // if it fails this way:  We neither record a successful linkage,</span>
<span class="udiff-line-added">+       // nor do we memorize a LE for posterity.</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve</span>
<span class="udiff-line-added">+     // a symbolic reference fails because an error is thrown that is an</span>
<span class="udiff-line-added">+     // instance of LinkageError (or a subclass), then subsequent attempts to</span>
<span class="udiff-line-added">+     // resolve the reference always fail with the same error that was thrown</span>
<span class="udiff-line-added">+     // as a result of the initial resolution attempt.</span>
<span class="udiff-line-added">+      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);</span>
<span class="udiff-line-added">+      if (!recorded_res_status) {</span>
<span class="udiff-line-added">+        // Another thread got here just before we did.  So, either use the method</span>
<span class="udiff-line-added">+        // that it resolved or throw the LinkageError exception that it threw.</span>
<span class="udiff-line-added">+        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);</span>
<span class="udiff-line-added">+        if (is_done) return;</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+      assert(bootstrap_specifier.invokedynamic_cp_cache_entry()-&gt;indy_resolution_failed(),</span>
<span class="udiff-line-added">+             &quot;Resolution failure flag wasn&#39;t set&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);</span>
<span class="udiff-line-added">+   // Exceptions::wrap_dynamic_exception not used because</span>
<span class="udiff-line-added">+   // set_handle doesn&#39;t throw linkage errors</span>
  }
  
  // Selected method is abstract.
  void LinkResolver::throw_abstract_method_error(const methodHandle&amp; resolved_method,
                                                 const methodHandle&amp; selected_method,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1804,22 +1786,25 @@</span>
    } else {
      ss.print(&quot;Missing implementation of&quot;);
    }
  
    assert(resolved_method.not_null(), &quot;Sanity&quot;);
<span class="udiff-line-modified-removed">-   ss.print(&quot; resolved method %s%s%s%s of %s %s.&quot;,</span>
<span class="udiff-line-modified-added">+   ss.print(&quot; resolved method &#39;%s%s&quot;,</span>
             resolved_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="udiff-line-modified-removed">-            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;,</span>
<span class="udiff-line-modified-removed">-            resolved_method-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-modified-removed">-            resolved_method-&gt;signature()-&gt;as_C_string(),</span>
<span class="udiff-line-modified-added">+            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="udiff-line-modified-added">+   ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-added">+   resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="udiff-line-added">+   ss.print(&quot;)&#39; of %s %s.&quot;,</span>
             resolved_klass-&gt;external_kind(),
             resolved_klass-&gt;external_name());
  
    if (selected_method.not_null() &amp;&amp; !(resolved_method == selected_method)) {
<span class="udiff-line-modified-removed">-     ss.print(&quot; Selected method is %s%s%s.&quot;,</span>
<span class="udiff-line-modified-added">+     ss.print(&quot; Selected method is &#39;%s%s&quot;,</span>
               selected_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
<span class="udiff-line-modified-removed">-              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;,</span>
<span class="udiff-line-modified-removed">-              selected_method-&gt;name_and_sig_as_C_string());</span>
<span class="udiff-line-modified-added">+              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);</span>
<span class="udiff-line-modified-added">+     selected_method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-added">+     ss.print(&quot;&#39;.&quot;);</span>
    }
  
    THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
  }
</pre>
<center><a href="invocationCounter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
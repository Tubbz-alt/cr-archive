<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMapCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_LINKRESOLVER_HPP
 26 #define SHARE_INTERPRETER_LINKRESOLVER_HPP
 27 

 28 #include &quot;oops/method.hpp&quot;
 29 
 30 // All the necessary definitions for run-time link resolution.
 31 
 32 // CallInfo provides all the information gathered for a particular
 33 // linked call site after resolving it. A link is any reference
 34 // made from within the bytecodes of a method to an object outside of
 35 // that method. If the info is invalid, the link has not been resolved
 36 // successfully.
 37 
 38 class CallInfo : public StackObj {
 39  public:
 40   // Ways that a method call might be selected (or not) based on receiver type.
 41   // Note that an invokevirtual instruction might be linked with no_dispatch,
 42   // and an invokeinterface instruction might be linked with any of the three options
 43   enum CallKind {
 44     direct_call,                        // jump into resolved_method (must be concrete)
 45     vtable_call,                        // select recv.klass.method_at_vtable(index)
 46     itable_call,                        // select recv.klass.method_at_itable(resolved_method.holder, index)
 47     unknown_kind = -1
</pre>
<hr />
<pre>
 60   void set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS);
 61   void set_interface(Klass* resolved_klass, Klass* selected_klass,
 62                      const methodHandle&amp; resolved_method,
 63                      const methodHandle&amp; selected_method,
 64                      int itable_index, TRAPS);
 65   void set_virtual(Klass* resolved_klass, Klass* selected_klass,
 66                    const methodHandle&amp; resolved_method,
 67                    const methodHandle&amp; selected_method,
 68                    int vtable_index, TRAPS);
 69   void set_handle(const methodHandle&amp; resolved_method,
 70                   Handle resolved_appendix, TRAPS);
 71   void set_handle(Klass* resolved_klass,
 72                   const methodHandle&amp; resolved_method,
 73                   Handle resolved_appendix, TRAPS);
 74   void set_common(Klass* resolved_klass, Klass* selected_klass,
 75                   const methodHandle&amp; resolved_method,
 76                   const methodHandle&amp; selected_method,
 77                   CallKind kind,
 78                   int index, TRAPS);
 79 

 80   friend class LinkResolver;
 81 
 82  public:
 83   CallInfo() {
 84 #ifndef PRODUCT
 85     _call_kind  = CallInfo::unknown_kind;
 86     _call_index = Method::garbage_vtable_index;
 87 #endif //PRODUCT
 88   }
 89 
 90   // utility to extract an effective CallInfo from a method and an optional receiver limit
 91   // does not queue the method for compilation.  This also creates a ResolvedMethodName
 92   // object for the resolved_method.
 93   CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
 94 
 95   Klass*  resolved_klass() const                 { return _resolved_klass; }
 96   Klass*  selected_klass() const                 { return _selected_klass; }
<span class="line-modified"> 97   methodHandle resolved_method() const           { return _resolved_method; }</span>
<span class="line-modified"> 98   methodHandle selected_method() const           { return _selected_method; }</span>
 99   Handle       resolved_appendix() const         { return _resolved_appendix; }
100   Handle       resolved_method_name() const      { return _resolved_method_name; }
101   // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
102   void     set_resolved_method_name(TRAPS);
103 
104   BasicType    result_type() const               { return selected_method()-&gt;result_type(); }
105   CallKind     call_kind() const                 { return _call_kind; }
106   int          call_index() const                { return _call_index; }
107   int          vtable_index() const {
108     // Even for interface calls the vtable index could be non-negative.
109     // See CallInfo::set_interface.
110     assert(has_vtable_index() || is_statically_bound(), &quot;&quot;);
111     assert(call_kind() == vtable_call || call_kind() == direct_call, &quot;&quot;);
112     // The returned value is &lt; 0 if the call is statically bound.
113     // But, the returned value may be &gt;= 0 even if the kind is direct_call.
114     // It is up to the caller to decide which way to go.
115     return _call_index;
116   }
117   int          itable_index() const {
118     assert(call_kind() == itable_call, &quot;&quot;);
</pre>
<hr />
<pre>
162     _check_access(check_access == needs_access_check), _tag(tag) {}
163 
164   LinkInfo(Klass* resolved_klass, Symbol* name, Symbol* signature, const methodHandle&amp; current_method,
165            AccessCheck check_access = needs_access_check,
166            constantTag tag = JVM_CONSTANT_Invalid) :
167     _name(name),
168     _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_method-&gt;method_holder()), _current_method(current_method),
169     _check_access(check_access == needs_access_check), _tag(tag) {}
170 
171   // Case where we just find the method and don&#39;t check access against the current class
172   LinkInfo(Klass* resolved_klass, Symbol*name, Symbol* signature) :
173     _name(name),
174     _signature(signature), _resolved_klass(resolved_klass), _current_klass(NULL), _current_method(methodHandle()),
175     _check_access(false), _tag(JVM_CONSTANT_Invalid) {}
176 
177   // accessors
178   Symbol* name() const               { return _name; }
179   Symbol* signature() const          { return _signature; }
180   Klass* resolved_klass() const      { return _resolved_klass; }
181   Klass* current_klass() const       { return _current_klass; }
<span class="line-modified">182   methodHandle current_method() const { return _current_method; }</span>
183   constantTag tag() const            { return _tag; }
184   bool check_access() const          { return _check_access; }
<span class="line-removed">185   char* method_string() const;</span>
186 
187   void         print()  PRODUCT_RETURN;
188 };
189 
190 // Link information for getfield/putfield &amp; getstatic/putstatic bytecodes
191 // is represented using a fieldDescriptor.
192 
193 // The LinkResolver is used to resolve constant-pool references at run-time.
194 // It does all necessary link-time checks &amp; throws exceptions if necessary.
195 
196 class LinkResolver: AllStatic {
197   friend class klassVtable;
198   friend class klassItable;
199 
200  private:
201 
202   static Method* lookup_method_in_klasses(const LinkInfo&amp; link_info,
203                                           bool checkpolymorphism,
204                                           bool in_imethod_resolve);
205   static Method* lookup_method_in_interfaces(const LinkInfo&amp; link_info);
206 
<span class="line-modified">207   static methodHandle lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified">208                                                 Handle *appendix_result_or_null, TRAPS);</span>
209  JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
210   // Not Linktime so doesn&#39;t take LinkInfo
<span class="line-modified">211   static methodHandle lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,</span>
<span class="line-modified">212                                                          Klass::PrivateLookupMode private_mode, TRAPS);</span>
213  JVMCI_ONLY(private:)
214 
215   // Similar loader constraint checking functions that throw
216   // LinkageError with descriptive message.
217   static void check_method_loader_constraints(const LinkInfo&amp; link_info,
218                                               const methodHandle&amp; resolved_method,
219                                               const char* method_type, TRAPS);
220   static void check_field_loader_constraints(Symbol* field, Symbol* sig,
221                                              Klass* current_klass,
222                                              Klass* sel_klass, TRAPS);
223 
<span class="line-modified">224   static methodHandle resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
<span class="line-modified">225   static methodHandle resolve_method          (const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
226 
<span class="line-modified">227   static methodHandle linktime_resolve_static_method    (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">228   static methodHandle linktime_resolve_special_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">229   static methodHandle linktime_resolve_virtual_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">230   static methodHandle linktime_resolve_interface_method (const LinkInfo&amp; link_info, TRAPS);</span>
231 
232   static void runtime_resolve_special_method    (CallInfo&amp; result,
233                                                  const LinkInfo&amp; link_info,
234                                                  const methodHandle&amp; resolved_method,
235                                                  Handle recv, TRAPS);
236 
237   static void runtime_resolve_virtual_method    (CallInfo&amp; result,
238                                                  const methodHandle&amp; resolved_method,
239                                                  Klass* resolved_klass,
240                                                  Handle recv,
241                                                  Klass* recv_klass,
242                                                  bool check_null_and_abstract, TRAPS);
243   static void runtime_resolve_interface_method  (CallInfo&amp; result,
244                                                  const methodHandle&amp; resolved_method,
245                                                  Klass* resolved_klass,
246                                                  Handle recv,
247                                                  Klass* recv_klass,
248                                                  bool check_null_and_abstract, TRAPS);
249 
250   static void check_field_accessability(Klass* ref_klass,
</pre>
<hr />
<pre>
267                                       const constantPoolHandle&amp; pool, int index, TRAPS);
268   static void resolve_invokedynamic  (CallInfo&amp; result,
269                                       const constantPoolHandle&amp; pool, int index, TRAPS);
270   static void resolve_invokehandle   (CallInfo&amp; result,
271                                       const constantPoolHandle&amp; pool, int index, TRAPS);
272  public:
273   // constant pool resolving
274   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass,
275                                         bool fold_type_to_class, TRAPS);
276   // The optional &#39;fold_type_to_class&#39; means that a derived type (array)
277   // is first converted to the class it is derived from (element type).
278   // If this element type is not a class, then the check passes quietly.
279   // This is usually what is needed, but a few existing uses might break
280   // if this flag were always turned on.  FIXME: See if it can be, always.
281   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass, TRAPS) {
282     return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
283   }
284 
285   // static resolving calls (will not run any Java code);
286   // used only from Bytecode_invoke::static_target
<span class="line-modified">287   static methodHandle resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified">288                                                 const constantPoolHandle&amp; pool,</span>
<span class="line-modified">289                                                 int index, TRAPS);</span>
290 
291   static void resolve_field_access(fieldDescriptor&amp; result,
292                                    const constantPoolHandle&amp; pool,
293                                    int index,
294                                    const methodHandle&amp; method,
295                                    Bytecodes::Code byte, TRAPS);
296   static void resolve_field(fieldDescriptor&amp; result, const LinkInfo&amp; link_info,
297                             Bytecodes::Code access_kind,
298                             bool initialize_class, TRAPS);
299 
300   static void resolve_static_call   (CallInfo&amp; result,
301                                      const LinkInfo&amp; link_info,
302                                      bool initialize_klass, TRAPS);
303   static void resolve_special_call  (CallInfo&amp; result,
304                                      Handle recv,
305                                      const LinkInfo&amp; link_info,
306                                      TRAPS);
307   static void resolve_virtual_call  (CallInfo&amp; result, Handle recv, Klass* recv_klass,
308                                      const LinkInfo&amp; link_info,
309                                      bool check_null_and_abstract, TRAPS);
310   static void resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
311                                      const LinkInfo&amp; link_info,
312                                      bool check_null_and_abstract, TRAPS);
313   static void resolve_handle_call   (CallInfo&amp; result,
314                                      const LinkInfo&amp; link_info, TRAPS);
<span class="line-modified">315   static void resolve_dynamic_call  (CallInfo&amp; result, int pool_index, Handle bootstrap_specifier,</span>
<span class="line-modified">316                                      Symbol* method_name, Symbol* method_signature,</span>
<span class="line-removed">317                                      Klass* current_klass, TRAPS);</span>
318 
319   // same as above for compile-time resolution; but returns null handle instead of throwing
320   // an exception on error also, does not initialize klass (i.e., no side effects)
<span class="line-modified">321   static methodHandle resolve_virtual_call_or_null  (Klass* receiver_klass,</span>
<span class="line-modified">322                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">323   static methodHandle resolve_interface_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">324                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">325   static methodHandle resolve_static_call_or_null   (const LinkInfo&amp; link_info);</span>
<span class="line-modified">326   static methodHandle resolve_special_call_or_null  (const LinkInfo&amp; link_info);</span>
327 
328   static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
329 
330   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
331   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
332                                             const LinkInfo&amp; link_info);
333 
334   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
<span class="line-modified">335   static methodHandle linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);</span>
<span class="line-modified">336   static methodHandle linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);</span>
337 
338   // runtime resolving from constant pool
339   static void resolve_invoke(CallInfo&amp; result, Handle recv,
340                              const constantPoolHandle&amp; pool, int index,
341                              Bytecodes::Code byte, TRAPS);
342 
343   // runtime resolving from attached method
344   static void resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
345                              const methodHandle&amp; attached_method,
346                              Bytecodes::Code byte, TRAPS);
347 
348  public:
349   // Only resolved method known.
350   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
<span class="line-modified">351     throw_abstract_method_error(resolved_method, NULL, NULL, CHECK);</span>
352   }
353   // Resolved method and receiver klass know.
354   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
<span class="line-modified">355     throw_abstract_method_error(resolved_method, NULL, recv_klass, CHECK);</span>
356   }
357   // Selected method is abstract.
358   static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
359                                           const methodHandle&amp; selected_method,
360                                           Klass *recv_klass, TRAPS);
361 };
362 #endif // SHARE_INTERPRETER_LINKRESOLVER_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_LINKRESOLVER_HPP
 26 #define SHARE_INTERPRETER_LINKRESOLVER_HPP
 27 
<span class="line-added"> 28 #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
 29 #include &quot;oops/method.hpp&quot;
 30 
 31 // All the necessary definitions for run-time link resolution.
 32 
 33 // CallInfo provides all the information gathered for a particular
 34 // linked call site after resolving it. A link is any reference
 35 // made from within the bytecodes of a method to an object outside of
 36 // that method. If the info is invalid, the link has not been resolved
 37 // successfully.
 38 
 39 class CallInfo : public StackObj {
 40  public:
 41   // Ways that a method call might be selected (or not) based on receiver type.
 42   // Note that an invokevirtual instruction might be linked with no_dispatch,
 43   // and an invokeinterface instruction might be linked with any of the three options
 44   enum CallKind {
 45     direct_call,                        // jump into resolved_method (must be concrete)
 46     vtable_call,                        // select recv.klass.method_at_vtable(index)
 47     itable_call,                        // select recv.klass.method_at_itable(resolved_method.holder, index)
 48     unknown_kind = -1
</pre>
<hr />
<pre>
 61   void set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS);
 62   void set_interface(Klass* resolved_klass, Klass* selected_klass,
 63                      const methodHandle&amp; resolved_method,
 64                      const methodHandle&amp; selected_method,
 65                      int itable_index, TRAPS);
 66   void set_virtual(Klass* resolved_klass, Klass* selected_klass,
 67                    const methodHandle&amp; resolved_method,
 68                    const methodHandle&amp; selected_method,
 69                    int vtable_index, TRAPS);
 70   void set_handle(const methodHandle&amp; resolved_method,
 71                   Handle resolved_appendix, TRAPS);
 72   void set_handle(Klass* resolved_klass,
 73                   const methodHandle&amp; resolved_method,
 74                   Handle resolved_appendix, TRAPS);
 75   void set_common(Klass* resolved_klass, Klass* selected_klass,
 76                   const methodHandle&amp; resolved_method,
 77                   const methodHandle&amp; selected_method,
 78                   CallKind kind,
 79                   int index, TRAPS);
 80 
<span class="line-added"> 81   friend class BootstrapInfo;</span>
 82   friend class LinkResolver;
 83 
 84  public:
 85   CallInfo() {
 86 #ifndef PRODUCT
 87     _call_kind  = CallInfo::unknown_kind;
 88     _call_index = Method::garbage_vtable_index;
 89 #endif //PRODUCT
 90   }
 91 
 92   // utility to extract an effective CallInfo from a method and an optional receiver limit
 93   // does not queue the method for compilation.  This also creates a ResolvedMethodName
 94   // object for the resolved_method.
 95   CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
 96 
 97   Klass*  resolved_klass() const                 { return _resolved_klass; }
 98   Klass*  selected_klass() const                 { return _selected_klass; }
<span class="line-modified"> 99   Method* resolved_method() const                { return _resolved_method(); }</span>
<span class="line-modified">100   Method* selected_method() const                { return _selected_method(); }</span>
101   Handle       resolved_appendix() const         { return _resolved_appendix; }
102   Handle       resolved_method_name() const      { return _resolved_method_name; }
103   // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
104   void     set_resolved_method_name(TRAPS);
105 
106   BasicType    result_type() const               { return selected_method()-&gt;result_type(); }
107   CallKind     call_kind() const                 { return _call_kind; }
108   int          call_index() const                { return _call_index; }
109   int          vtable_index() const {
110     // Even for interface calls the vtable index could be non-negative.
111     // See CallInfo::set_interface.
112     assert(has_vtable_index() || is_statically_bound(), &quot;&quot;);
113     assert(call_kind() == vtable_call || call_kind() == direct_call, &quot;&quot;);
114     // The returned value is &lt; 0 if the call is statically bound.
115     // But, the returned value may be &gt;= 0 even if the kind is direct_call.
116     // It is up to the caller to decide which way to go.
117     return _call_index;
118   }
119   int          itable_index() const {
120     assert(call_kind() == itable_call, &quot;&quot;);
</pre>
<hr />
<pre>
164     _check_access(check_access == needs_access_check), _tag(tag) {}
165 
166   LinkInfo(Klass* resolved_klass, Symbol* name, Symbol* signature, const methodHandle&amp; current_method,
167            AccessCheck check_access = needs_access_check,
168            constantTag tag = JVM_CONSTANT_Invalid) :
169     _name(name),
170     _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_method-&gt;method_holder()), _current_method(current_method),
171     _check_access(check_access == needs_access_check), _tag(tag) {}
172 
173   // Case where we just find the method and don&#39;t check access against the current class
174   LinkInfo(Klass* resolved_klass, Symbol*name, Symbol* signature) :
175     _name(name),
176     _signature(signature), _resolved_klass(resolved_klass), _current_klass(NULL), _current_method(methodHandle()),
177     _check_access(false), _tag(JVM_CONSTANT_Invalid) {}
178 
179   // accessors
180   Symbol* name() const               { return _name; }
181   Symbol* signature() const          { return _signature; }
182   Klass* resolved_klass() const      { return _resolved_klass; }
183   Klass* current_klass() const       { return _current_klass; }
<span class="line-modified">184   Method* current_method() const     { return _current_method(); }</span>
185   constantTag tag() const            { return _tag; }
186   bool check_access() const          { return _check_access; }

187 
188   void         print()  PRODUCT_RETURN;
189 };
190 
191 // Link information for getfield/putfield &amp; getstatic/putstatic bytecodes
192 // is represented using a fieldDescriptor.
193 
194 // The LinkResolver is used to resolve constant-pool references at run-time.
195 // It does all necessary link-time checks &amp; throws exceptions if necessary.
196 
197 class LinkResolver: AllStatic {
198   friend class klassVtable;
199   friend class klassItable;
200 
201  private:
202 
203   static Method* lookup_method_in_klasses(const LinkInfo&amp; link_info,
204                                           bool checkpolymorphism,
205                                           bool in_imethod_resolve);
206   static Method* lookup_method_in_interfaces(const LinkInfo&amp; link_info);
207 
<span class="line-modified">208   static Method* lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified">209                                            Handle *appendix_result_or_null, TRAPS);</span>
210  JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
211   // Not Linktime so doesn&#39;t take LinkInfo
<span class="line-modified">212   static Method* lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,</span>
<span class="line-modified">213                                                     Klass::PrivateLookupMode private_mode, TRAPS);</span>
214  JVMCI_ONLY(private:)
215 
216   // Similar loader constraint checking functions that throw
217   // LinkageError with descriptive message.
218   static void check_method_loader_constraints(const LinkInfo&amp; link_info,
219                                               const methodHandle&amp; resolved_method,
220                                               const char* method_type, TRAPS);
221   static void check_field_loader_constraints(Symbol* field, Symbol* sig,
222                                              Klass* current_klass,
223                                              Klass* sel_klass, TRAPS);
224 
<span class="line-modified">225   static Method* resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
<span class="line-modified">226   static Method* resolve_method          (const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
227 
<span class="line-modified">228   static Method* linktime_resolve_static_method    (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">229   static Method* linktime_resolve_special_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">230   static Method* linktime_resolve_virtual_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">231   static Method* linktime_resolve_interface_method (const LinkInfo&amp; link_info, TRAPS);</span>
232 
233   static void runtime_resolve_special_method    (CallInfo&amp; result,
234                                                  const LinkInfo&amp; link_info,
235                                                  const methodHandle&amp; resolved_method,
236                                                  Handle recv, TRAPS);
237 
238   static void runtime_resolve_virtual_method    (CallInfo&amp; result,
239                                                  const methodHandle&amp; resolved_method,
240                                                  Klass* resolved_klass,
241                                                  Handle recv,
242                                                  Klass* recv_klass,
243                                                  bool check_null_and_abstract, TRAPS);
244   static void runtime_resolve_interface_method  (CallInfo&amp; result,
245                                                  const methodHandle&amp; resolved_method,
246                                                  Klass* resolved_klass,
247                                                  Handle recv,
248                                                  Klass* recv_klass,
249                                                  bool check_null_and_abstract, TRAPS);
250 
251   static void check_field_accessability(Klass* ref_klass,
</pre>
<hr />
<pre>
268                                       const constantPoolHandle&amp; pool, int index, TRAPS);
269   static void resolve_invokedynamic  (CallInfo&amp; result,
270                                       const constantPoolHandle&amp; pool, int index, TRAPS);
271   static void resolve_invokehandle   (CallInfo&amp; result,
272                                       const constantPoolHandle&amp; pool, int index, TRAPS);
273  public:
274   // constant pool resolving
275   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass,
276                                         bool fold_type_to_class, TRAPS);
277   // The optional &#39;fold_type_to_class&#39; means that a derived type (array)
278   // is first converted to the class it is derived from (element type).
279   // If this element type is not a class, then the check passes quietly.
280   // This is usually what is needed, but a few existing uses might break
281   // if this flag were always turned on.  FIXME: See if it can be, always.
282   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass, TRAPS) {
283     return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
284   }
285 
286   // static resolving calls (will not run any Java code);
287   // used only from Bytecode_invoke::static_target
<span class="line-modified">288   static Method* resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified">289                                            const constantPoolHandle&amp; pool,</span>
<span class="line-modified">290                                            int index, TRAPS);</span>
291 
292   static void resolve_field_access(fieldDescriptor&amp; result,
293                                    const constantPoolHandle&amp; pool,
294                                    int index,
295                                    const methodHandle&amp; method,
296                                    Bytecodes::Code byte, TRAPS);
297   static void resolve_field(fieldDescriptor&amp; result, const LinkInfo&amp; link_info,
298                             Bytecodes::Code access_kind,
299                             bool initialize_class, TRAPS);
300 
301   static void resolve_static_call   (CallInfo&amp; result,
302                                      const LinkInfo&amp; link_info,
303                                      bool initialize_klass, TRAPS);
304   static void resolve_special_call  (CallInfo&amp; result,
305                                      Handle recv,
306                                      const LinkInfo&amp; link_info,
307                                      TRAPS);
308   static void resolve_virtual_call  (CallInfo&amp; result, Handle recv, Klass* recv_klass,
309                                      const LinkInfo&amp; link_info,
310                                      bool check_null_and_abstract, TRAPS);
311   static void resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
312                                      const LinkInfo&amp; link_info,
313                                      bool check_null_and_abstract, TRAPS);
314   static void resolve_handle_call   (CallInfo&amp; result,
315                                      const LinkInfo&amp; link_info, TRAPS);
<span class="line-modified">316   static void resolve_dynamic_call  (CallInfo&amp; result,</span>
<span class="line-modified">317                                      BootstrapInfo&amp; bootstrap_specifier, TRAPS);</span>

318 
319   // same as above for compile-time resolution; but returns null handle instead of throwing
320   // an exception on error also, does not initialize klass (i.e., no side effects)
<span class="line-modified">321   static Method* resolve_virtual_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">322                                               const LinkInfo&amp; link_info);</span>
<span class="line-modified">323   static Method* resolve_interface_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">324                                                 const LinkInfo&amp; link_info);</span>
<span class="line-modified">325   static Method* resolve_static_call_or_null(const LinkInfo&amp; link_info);</span>
<span class="line-modified">326   static Method* resolve_special_call_or_null(const LinkInfo&amp; link_info);</span>
327 
328   static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
329 
330   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
331   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
332                                             const LinkInfo&amp; link_info);
333 
334   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
<span class="line-modified">335   static Method* linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);</span>
<span class="line-modified">336   static Method* linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);</span>
337 
338   // runtime resolving from constant pool
339   static void resolve_invoke(CallInfo&amp; result, Handle recv,
340                              const constantPoolHandle&amp; pool, int index,
341                              Bytecodes::Code byte, TRAPS);
342 
343   // runtime resolving from attached method
344   static void resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
345                              const methodHandle&amp; attached_method,
346                              Bytecodes::Code byte, TRAPS);
347 
348  public:
349   // Only resolved method known.
350   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
<span class="line-modified">351     throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);</span>
352   }
353   // Resolved method and receiver klass know.
354   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
<span class="line-modified">355     throw_abstract_method_error(resolved_method, methodHandle(), recv_klass, CHECK);</span>
356   }
357   // Selected method is abstract.
358   static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
359                                           const methodHandle&amp; selected_method,
360                                           Klass *recv_klass, TRAPS);
361 };
362 #endif // SHARE_INTERPRETER_LINKRESOLVER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMapCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interpreter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,13 +22,15 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
<span class="udiff-line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,11 +51,10 @@</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -154,24 +155,24 @@</span>
  
  //------------------------------------------------------------------------------------------------------------------------
  // Constants
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))</span>
    // access constant pool
    LastFrameAccessor last_frame(thread);
    ConstantPool* pool = last_frame.method()-&gt;constants();
    int index = wide ? last_frame.get_index_u2(Bytecodes::_ldc_w) : last_frame.get_index_u1(Bytecodes::_ldc);
    constantTag tag = pool-&gt;tag_at(index);
  
    assert (tag.is_unresolved_klass() || tag.is_klass(), &quot;wrong ldc call&quot;);
    Klass* klass = pool-&gt;klass_at(index, CHECK);
      oop java_class = klass-&gt;java_mirror();
      thread-&gt;set_vm_result(java_class);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode)) {</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode)) {</span>
    assert(bytecode == Bytecodes::_ldc ||
           bytecode == Bytecodes::_ldc_w ||
           bytecode == Bytecodes::_ldc2_w ||
           bytecode == Bytecodes::_fast_aldc ||
           bytecode == Bytecodes::_fast_aldc_w, &quot;wrong bc&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,11 +204,11 @@</span>
      if (rindex &lt; 0)
        rindex = m-&gt;constants()-&gt;cp_to_object_index(ldc2.pool_index());
      if (rindex &gt;= 0) {
        oop coop = m-&gt;constants()-&gt;resolved_references()-&gt;obj_at(rindex);
        oop roop = (result == NULL ? Universe::the_null_sentinel() : result);
<span class="udiff-line-modified-removed">-       assert(oopDesc::equals(roop, coop), &quot;expected result for assembly code&quot;);</span>
<span class="udiff-line-modified-added">+       assert(roop == coop, &quot;expected result for assembly code&quot;);</span>
      }
    }
  #endif
    thread-&gt;set_vm_result(result);
    if (!is_fast_aldc) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,17 +218,17 @@</span>
      intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
                        | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
      thread-&gt;set_vm_result_2((Metadata*)flags);
    }
  }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  //------------------------------------------------------------------------------------------------------------------------
  // Allocation
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))</span>
    Klass* k = pool-&gt;klass_at(index, CHECK);
    InstanceKlass* klass = InstanceKlass::cast(k);
  
    // Make sure we are not instantiating an abstract klass
    klass-&gt;check_valid_for_instantiation(true, CHECK);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -249,27 +250,27 @@</span>
    //       Java).
    //       If we have a breakpoint, then we don&#39;t rewrite
    //       because the _breakpoint bytecode would be lost.
    oop obj = klass-&gt;allocate_instance(CHECK);
    thread-&gt;set_vm_result(obj);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))</span>
    oop obj = oopFactory::new_typeArray(type, size, CHECK);
    thread-&gt;set_vm_result(obj);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))</span>
    Klass*    klass = pool-&gt;klass_at(index, CHECK);
    objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);
    thread-&gt;set_vm_result(obj);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))</span>
    // We may want to pass in more arguments - could make this slightly faster
    LastFrameAccessor last_frame(thread);
    ConstantPool* constants = last_frame.method()-&gt;constants();
    int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);
    Klass* klass   = constants-&gt;klass_at(i, CHECK);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,33 +291,33 @@</span>
      int n = Interpreter::local_offset_in_bytes(index)/jintSize;
      dims[index] = first_size_address[n];
    }
    oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(nof_dims, dims, CHECK);
    thread-&gt;set_vm_result(obj);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))</span>
    assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
    assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
    InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  // Quicken instance-of and check-cast bytecodes
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))</span>
    // Force resolving; quicken the bytecode
    LastFrameAccessor last_frame(thread);
    int which = last_frame.get_index_u2(Bytecodes::_checkcast);
    ConstantPool* cpool = last_frame.method()-&gt;constants();
    // We&#39;d expect to assert that we&#39;re only here to quicken bytecodes, but in a multithreaded
    // program we might have seen an unquick&#39;d bytecode in the interpreter but have another
    // thread quicken the bytecode before we get here.
    // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), &quot;should only come here to quicken bytecodes&quot; );
    Klass* klass = cpool-&gt;klass_at(which, CHECK);
    thread-&gt;set_vm_result_2(klass);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  //------------------------------------------------------------------------------------------------------------------------
  // Exceptions
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,14 +353,14 @@</span>
    note_trap_inner(thread, reason, trap_method, trap_bci, THREAD);
  }
  
  #ifdef CC_INTERP
  // As legacy note_trap, but we have more arguments.
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::note_trap(JavaThread* thread, int reason, Method *method, int trap_bci))</span>
<span class="udiff-line-modified-removed">-   methodHandle trap_method(method);</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::note_trap(JavaThread* thread, int reason, Method *method, int trap_bci))</span>
<span class="udiff-line-modified-added">+   methodHandle trap_method(thread, method);</span>
    note_trap_inner(thread, reason, trap_method, trap_bci, THREAD);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  // Class Deoptimization is not visible in BytecodeInterpreter, so we need a wrapper
  // for each exception.
  void InterpreterRuntime::note_nullCheck_trap(JavaThread* thread, Method *method, int trap_bci)
    { if (ProfileTraps) note_trap(thread, Deoptimization::Reason_null_check, method, trap_bci); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -392,74 +393,74 @@</span>
  
  // Special handling for stack overflow: since we don&#39;t have any (java) stack
  // space left we use the pre-allocated &amp; pre-initialized StackOverflowError
  // klass to create an stack overflow error instance.  We do not call its
  // constructor for the same reason (it is empty, anyway).
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* thread))</span>
    Handle exception = get_preinitialized_exception(
                                   SystemDictionary::StackOverflowError_klass(),
                                   CHECK);
    // Increment counter for hs_err file reporting
    Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
    THROW_HANDLE(exception);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* thread))</span>
    Handle exception = get_preinitialized_exception(
                                   SystemDictionary::StackOverflowError_klass(),
                                   CHECK);
    java_lang_Throwable::set_message(exception(),
            Universe::delayed_stack_overflow_error_message());
    // Increment counter for hs_err file reporting
    Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
    THROW_HANDLE(exception);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* thread, char* name, char* message))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* thread, char* name, char* message))</span>
    // lookup exception klass
<span class="udiff-line-modified-removed">-   TempNewSymbol s = SymbolTable::new_symbol(name, CHECK);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol s = SymbolTable::new_symbol(name);</span>
    if (ProfileTraps) {
      if (s == vmSymbols::java_lang_ArithmeticException()) {
        note_trap(thread, Deoptimization::Reason_div0_check, CHECK);
      } else if (s == vmSymbols::java_lang_NullPointerException()) {
        note_trap(thread, Deoptimization::Reason_null_check, CHECK);
      }
    }
    // create exception
    Handle exception = Exceptions::new_exception(thread, s, message);
    thread-&gt;set_vm_result(exception());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* thread, char* name, oopDesc* obj))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* thread, char* name, oopDesc* obj))</span>
    // Produce the error message first because note_trap can safepoint
    ResourceMark rm(thread);
    const char* klass_name = obj-&gt;klass()-&gt;external_name();
    // lookup exception klass
<span class="udiff-line-modified-removed">-   TempNewSymbol s = SymbolTable::new_symbol(name, CHECK);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol s = SymbolTable::new_symbol(name);</span>
    if (ProfileTraps) {
      note_trap(thread, Deoptimization::Reason_class_check, CHECK);
    }
    // create exception, with klass name as detail message
    Handle exception = Exceptions::new_exception(thread, s, klass_name);
    thread-&gt;set_vm_result(exception());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index))</span>
    // Produce the error message first because note_trap can safepoint
    ResourceMark rm(thread);
    stringStream ss;
    ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
  
    if (ProfileTraps) {
      note_trap(thread, Deoptimization::Reason_range_check, CHECK);
    }
  
    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_ClassCastException(</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_ClassCastException(</span>
    JavaThread* thread, oopDesc* obj))
  
    // Produce the error message first because note_trap can safepoint
    ResourceMark rm(thread);
    char* message = SharedRuntime::generate_class_cast_message(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,21 +470,21 @@</span>
      note_trap(thread, Deoptimization::Reason_class_check, CHECK);
    }
  
    // create exception
    THROW_MSG(vmSymbols::java_lang_ClassCastException(), message);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  // exception_handler_for_exception(...) returns the continuation address,
  // the exception oop (via TLS) and sets the bci/bcp for the continuation.
  // The exception oop is returned to make sure it is preserved over GC (it
  // is only on the stack if the exception was thrown explicitly via athrow).
  // During this operation, the expression stack contains the values for the
  // bci where the exception happened. If the exception was propagated back
  // from a call, the expression stack contains the values for the bci at the
  // invoke w/o arguments (i.e., as if one were inside the call).
<span class="udiff-line-modified-removed">- IRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* thread, oopDesc* exception))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* thread, oopDesc* exception))</span>
  
    LastFrameAccessor last_frame(thread);
    Handle             h_exception(thread, exception);
    methodHandle       h_method   (thread, last_frame.method());
    constantPoolHandle h_constants(thread, h_method-&gt;constants());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -540,11 +541,11 @@</span>
        ResourceMark rm(thread);
        stringStream tempst;
        tempst.print(&quot;interpreter method &lt;%s&gt;\n&quot;
                     &quot; at bci %d for thread &quot; INTPTR_FORMAT &quot; (%s)&quot;,
                     h_method-&gt;print_value_string(), current_bci, p2i(thread), thread-&gt;name());
<span class="udiff-line-modified-removed">-       Exceptions::log_exception(h_exception, tempst);</span>
<span class="udiff-line-modified-added">+       Exceptions::log_exception(h_exception, tempst.as_string());</span>
      }
  // Don&#39;t go paging in something which won&#39;t be used.
  //     else if (extable-&gt;length() == 0) {
  //       // disabled for now - interpreter is not using shortcut yet
  //       // (shortcut is not to call runtime if we have no exception handlers)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -620,62 +621,62 @@</span>
      JvmtiExport::notice_unwind_due_to_exception(thread, h_method(), handler_pc, h_exception(), (handler_pc != NULL));
    }
  
    thread-&gt;set_vm_result(h_exception());
    return continuation;
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* thread))</span>
    assert(thread-&gt;has_pending_exception(), &quot;must only ne called if there&#39;s an exception pending&quot;);
    // nothing to do - eventually we should remove this code entirely (see comments @ call sites)
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* thread))</span>
    THROW(vmSymbols::java_lang_AbstractMethodError());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  // This method is called from the &quot;abstract_entry&quot; of the interpreter.
  // At that point, the arguments have already been removed from the stack
  // and therefore we don&#39;t have the receiver object at our fingertips. (Though,
  // on some platforms the receiver still resides in a register...). Thus,
  // we have no choice but print an error message not containing the receiver
  // type.
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,</span>
                                                                          Method* missingMethod))
    ResourceMark rm(thread);
    assert(missingMethod != NULL, &quot;sanity&quot;);
    methodHandle m(thread, missingMethod);
    LinkResolver::throw_abstract_method_error(m, THREAD);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,</span>
                                                                       Klass* recvKlass,
                                                                       Method* missingMethod))
    ResourceMark rm(thread);
    methodHandle mh = methodHandle(thread, missingMethod);
    LinkResolver::throw_abstract_method_error(mh, recvKlass, THREAD);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))</span>
    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,</span>
                                                                                Klass* recvKlass,
                                                                                Klass* interfaceKlass))
    ResourceMark rm(thread);
    char buf[1000];
    buf[0] = &#39;\0&#39;;
    jio_snprintf(buf, sizeof(buf),
                 &quot;Class %s does not implement the requested interface %s&quot;,
                 recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
                 interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  //------------------------------------------------------------------------------------------------------------------------
  // Fields
  //
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,61 +765,56 @@</span>
  // The interpreter&#39;s synchronization code is factored out so that it can
  // be shared by method invocation and synchronized blocks.
  //%note synchronization_3
  
  //%note monitor_1
<span class="udiff-line-modified-removed">- IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span>
  #ifdef ASSERT
    thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
  #endif
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(thread, elem-&gt;obj());
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span>
<span class="udiff-line-modified-added">+   assert(Universe::heap()-&gt;is_in_or_null(h_obj()),</span>
           &quot;must be NULL or an object&quot;);
<span class="udiff-line-modified-removed">-   if (UseBiasedLocking) {</span>
<span class="udiff-line-modified-removed">-     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span>
<span class="udiff-line-modified-added">+   ObjectSynchronizer::enter(h_obj, elem-&gt;lock(), CHECK);</span>
<span class="udiff-line-modified-added">+   assert(Universe::heap()-&gt;is_in_or_null(elem-&gt;obj()),</span>
           &quot;must be NULL or an object&quot;);
  #ifdef ASSERT
    thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
  #endif
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  //%note monitor_1
<span class="udiff-line-modified-removed">- IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span>
  #ifdef ASSERT
    thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
  #endif
    Handle h_obj(thread, elem-&gt;obj());
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span>
<span class="udiff-line-modified-added">+   assert(Universe::heap()-&gt;is_in_or_null(h_obj()),</span>
           &quot;must be NULL or an object&quot;);
    if (elem == NULL || h_obj()-&gt;is_unlocked()) {
      THROW(vmSymbols::java_lang_IllegalMonitorStateException());
    }
<span class="udiff-line-modified-removed">-   ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span>
<span class="udiff-line-modified-added">+   ObjectSynchronizer::exit(h_obj(), elem-&gt;lock(), thread);</span>
    // Free entry. This must be done here, since a pending exception might be installed on
    // exit. If it is not cleared, the exception handling code will try to unlock the monitor again.
    elem-&gt;set_obj(NULL);
  #ifdef ASSERT
    thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
  #endif
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* thread))</span>
    THROW(vmSymbols::java_lang_IllegalMonitorStateException());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* thread))</span>
    // Returns an illegal exception to install into the current thread. The
    // pending_exception flag is cleared so normal exception handling does not
    // trigger. Any current installed exception will be overwritten. This
    // method will be called during an exception unwind.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -830,27 +826,27 @@</span>
      exception = get_preinitialized_exception(
                         SystemDictionary::IllegalMonitorStateException_klass(),
                         CATCH);
    }
    thread-&gt;set_vm_result(exception());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  //------------------------------------------------------------------------------------------------------------------------
  // Invokes
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* thread, Method* method, address bcp))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* thread, Method* method, address bcp))</span>
    return method-&gt;orig_bytecode_at(method-&gt;bci_from(bcp));
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code))</span>
    method-&gt;set_orig_bytecode_at(method-&gt;bci_from(bcp), new_code);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* thread, Method* method, address bcp))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* thread, Method* method, address bcp))</span>
    JvmtiExport::post_raw_breakpoint(thread, method, bcp);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  void InterpreterRuntime::resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode) {
    Thread* THREAD = thread;
    LastFrameAccessor last_frame(thread);
    // extract receiver from the outgoing argument list if necessary
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -861,14 +857,14 @@</span>
      methodHandle m (thread, last_frame.method());
      Bytecode_invoke call(m, last_frame.bci());
      Symbol* signature = call.signature();
      receiver = Handle(thread, last_frame.callee_receiver(signature));
  
<span class="udiff-line-modified-removed">-     assert(Universe::heap()-&gt;is_in_reserved_or_null(receiver()),</span>
<span class="udiff-line-modified-added">+     assert(Universe::heap()-&gt;is_in_or_null(receiver()),</span>
             &quot;sanity check&quot;);
      assert(receiver.is_null() ||
<span class="udiff-line-modified-removed">-            !Universe::heap()-&gt;is_in_reserved(receiver-&gt;klass()),</span>
<span class="udiff-line-modified-added">+            !Universe::heap()-&gt;is_in(receiver-&gt;klass()),</span>
             &quot;sanity check&quot;);
    }
  
    // resolve method
    CallInfo info;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -905,11 +901,11 @@</span>
                                              SystemDictionary::Object_klass()) {
        // NOTE: THIS IS A FIX FOR A CORNER CASE in the JVM spec
        // (see also CallInfo::set_interface for details)
        assert(info.call_kind() == CallInfo::vtable_call ||
               info.call_kind() == CallInfo::direct_call, &quot;&quot;);
<span class="udiff-line-modified-removed">-       methodHandle rm = info.resolved_method();</span>
<span class="udiff-line-modified-added">+       Method* rm = info.resolved_method();</span>
        assert(rm-&gt;is_final() || info.has_vtable_index(),
               &quot;should have been set already&quot;);
      } else if (!info.resolved_method()-&gt;has_itable_index()) {
        // Resolved something like CharSequence.toString.  Use vtable not itable.
        assert(info.call_kind() != CallInfo::itable_call, &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -924,38 +920,35 @@</span>
    } else {
      assert(info.call_kind() == CallInfo::direct_call ||
             info.call_kind() == CallInfo::vtable_call, &quot;&quot;);
    }
  #endif
<span class="udiff-line-added">+   // Get sender or sender&#39;s unsafe_anonymous_host, and only set cpCache entry to resolved if</span>
<span class="udiff-line-added">+   // it is not an interface.  The receiver for invokespecial calls within interface</span>
<span class="udiff-line-added">+   // methods must be checked for every call.</span>
<span class="udiff-line-added">+   InstanceKlass* sender = pool-&gt;pool_holder();</span>
<span class="udiff-line-added">+   sender = sender-&gt;is_unsafe_anonymous() ? sender-&gt;unsafe_anonymous_host() : sender;</span>
<span class="udiff-line-added">+   methodHandle resolved_method(THREAD, info.resolved_method());</span>
  
    switch (info.call_kind()) {
<span class="udiff-line-modified-removed">-   case CallInfo::direct_call: {</span>
<span class="udiff-line-removed">-     // Get sender or sender&#39;s unsafe_anonymous_host, and only set cpCache entry to resolved if</span>
<span class="udiff-line-removed">-     // it is not an interface.  The receiver for invokespecial calls within interface</span>
<span class="udiff-line-removed">-     // methods must be checked for every call.</span>
<span class="udiff-line-removed">-     InstanceKlass* pool_holder = pool-&gt;pool_holder();</span>
<span class="udiff-line-removed">-     InstanceKlass* sender = pool_holder-&gt;is_unsafe_anonymous() ?</span>
<span class="udiff-line-removed">-                               pool_holder-&gt;unsafe_anonymous_host() : pool_holder;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   case CallInfo::direct_call:</span>
      cp_cache_entry-&gt;set_direct_call(
        bytecode,
<span class="udiff-line-modified-removed">-       info.resolved_method(),</span>
<span class="udiff-line-modified-removed">-       sender-&gt;is_interface(),</span>
<span class="udiff-line-removed">-       pool_holder);</span>
<span class="udiff-line-modified-added">+       resolved_method,</span>
<span class="udiff-line-modified-added">+       sender-&gt;is_interface());</span>
      break;
<span class="udiff-line-removed">-   }</span>
    case CallInfo::vtable_call:
      cp_cache_entry-&gt;set_vtable_call(
        bytecode,
<span class="udiff-line-modified-removed">-       info.resolved_method(),</span>
<span class="udiff-line-modified-added">+       resolved_method,</span>
        info.vtable_index());
      break;
    case CallInfo::itable_call:
      cp_cache_entry-&gt;set_itable_call(
        bytecode,
        info.resolved_klass(),
<span class="udiff-line-modified-removed">-       info.resolved_method(),</span>
<span class="udiff-line-modified-added">+       resolved_method,</span>
        info.itable_index());
      break;
    default:  ShouldNotReachHere();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1002,11 +995,11 @@</span>
  }
  
  // This function is the interface to the assembly code. It returns the resolved
  // cpCache entry.  This doesn&#39;t safepoint, but the helper routines safepoint.
  // This function will check for redefinition!
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {</span>
    switch (bytecode) {
    case Bytecodes::_getstatic:
    case Bytecodes::_putstatic:
    case Bytecodes::_getfield:
    case Bytecodes::_putfield:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,11 +1020,11 @@</span>
    default:
      fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(bytecode));
      break;
    }
  }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  //------------------------------------------------------------------------------------------------------------------------
  // Miscellaneous
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1073,11 +1066,11 @@</span>
    }
  #endif
    return nm;
  }
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(nmethod*,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(nmethod*,</span>
            InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp))
    // use UnlockFlagSaver to clear and restore the _do_not_unlock_if_synchronized
    // flag, in case this method triggers classloading which will call into Java.
    UnlockFlagSaver fs(thread);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1113,25 +1106,25 @@</span>
             kptr = last_frame.next_monitor(kptr) ) {
          if( kptr-&gt;obj() != NULL ) {
            objects_to_revoke-&gt;append(Handle(THREAD, kptr-&gt;obj()));
          }
        }
<span class="udiff-line-modified-removed">-       BiasedLocking::revoke(objects_to_revoke);</span>
<span class="udiff-line-modified-added">+       BiasedLocking::revoke(objects_to_revoke, thread);</span>
      }
    }
    return osr_nm;
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_LEAF(jint, InterpreterRuntime::bcp_to_di(Method* method, address cur_bcp))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(jint, InterpreterRuntime::bcp_to_di(Method* method, address cur_bcp))</span>
    assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
    int bci = method-&gt;bci_from(cur_bcp);
    MethodData* mdo = method-&gt;method_data();
    if (mdo == NULL)  return 0;
    return mdo-&gt;bci_to_di(bci);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::profile_method(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::profile_method(JavaThread* thread))</span>
    // use UnlockFlagSaver to clear and restore the _do_not_unlock_if_synchronized
    // flag, in case this method triggers classloading which will call into Java.
    UnlockFlagSaver fs(thread);
  
    assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1142,15 +1135,15 @@</span>
    if (HAS_PENDING_EXCEPTION) {
      assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
      CLEAR_PENDING_EXCEPTION;
      // and fall through...
    }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">- IRT_LEAF(void, InterpreterRuntime::verify_mdp(Method* method, address bcp, address mdp))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(void, InterpreterRuntime::verify_mdp(Method* method, address bcp, address mdp))</span>
    assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
  
    MethodData* mdo = method-&gt;method_data();
    assert(mdo != NULL, &quot;must not be null&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1173,14 +1166,14 @@</span>
      tty-&gt;print_cr(&quot;  actual bci is %d  expected bci %d&quot;, approx_bci, expected_approx_bci);
      mdo-&gt;print_on(tty);
      method-&gt;print_codes();
    }
    assert(mdp == mdp2, &quot;wrong mdp&quot;);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  #endif // ASSERT
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* thread, int return_bci))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* thread, int return_bci))</span>
    assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
    ResourceMark rm(thread);
    HandleMark hm(thread);
    LastFrameAccessor last_frame(thread);
    assert(last_frame.is_interpreted_frame(), &quot;must come from interpreter&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1195,40 +1188,40 @@</span>
    ProfileData* data = h_mdo-&gt;data_at(h_mdo-&gt;dp_to_di(last_frame.mdp()));
    guarantee(data != NULL, &quot;profile data must be valid&quot;);
    RetData* rdata = data-&gt;as_RetData();
    address new_mdp = rdata-&gt;fixup_ret(return_bci, h_mdo);
    last_frame.set_mdp(new_mdp);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* thread, Method* m))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* thread, Method* m))</span>
    MethodCounters* mcs = Method::build_method_counters(m, thread);
    if (HAS_PENDING_EXCEPTION) {
      assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
      CLEAR_PENDING_EXCEPTION;
    }
    return mcs;
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* thread))</span>
    // We used to need an explict preserve_arguments here for invoke bytecodes. However,
    // stack traversal automatically takes care of preserving arguments for invoke, so
    // this is no longer needed.
  
<span class="udiff-line-modified-removed">-   // IRT_END does an implicit safepoint check, hence we are guaranteed to block</span>
<span class="udiff-line-modified-added">+   // JRT_END does an implicit safepoint check, hence we are guaranteed to block</span>
    // if this is called during a safepoint
  
    if (JvmtiExport::should_post_single_step()) {
      // We are called during regular safepoints and when the VM is
      // single stepping. If any thread is marked for single stepping,
      // then we may have JVMTI work to do.
      LastFrameAccessor last_frame(thread);
      JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
    }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,</span>
  ConstantPoolCacheEntry *cp_entry))
  
    // check the access_flags for the field in the klass
  
    InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1245,13 +1238,13 @@</span>
    }
    InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
    jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static);
    LastFrameAccessor last_frame(thread);
    JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,</span>
    oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
  
    Klass* k = cp_entry-&gt;f1_as_klass();
  
    // check the access_flags for the field in the klass
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1261,19 +1254,19 @@</span>
    if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
  
    char sig_type = &#39;\0&#39;;
  
    switch(cp_entry-&gt;flag_state()) {
<span class="udiff-line-modified-removed">-     case btos: sig_type = &#39;B&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case ztos: sig_type = &#39;Z&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case ctos: sig_type = &#39;C&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case stos: sig_type = &#39;S&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case itos: sig_type = &#39;I&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case ftos: sig_type = &#39;F&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case atos: sig_type = &#39;L&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case ltos: sig_type = &#39;J&#39;; break;</span>
<span class="udiff-line-modified-removed">-     case dtos: sig_type = &#39;D&#39;; break;</span>
<span class="udiff-line-modified-added">+     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;</span>
<span class="udiff-line-modified-added">+     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;</span>
<span class="udiff-line-modified-added">+     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;</span>
<span class="udiff-line-modified-added">+     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;</span>
<span class="udiff-line-modified-added">+     case itos: sig_type = JVM_SIGNATURE_INT;     break;</span>
<span class="udiff-line-modified-added">+     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;</span>
<span class="udiff-line-modified-added">+     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;</span>
<span class="udiff-line-modified-added">+     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;</span>
<span class="udiff-line-modified-added">+     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;</span>
      default:  ShouldNotReachHere(); return;
    }
    bool is_static = (obj == NULL);
  
    HandleMark hm(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1302,28 +1295,28 @@</span>
    }
  
    LastFrameAccessor last_frame(thread);
    JvmtiExport::post_raw_field_modification(thread, last_frame.method(), last_frame.bcp(), ik, h_obj,
                                             fid, sig_type, &amp;fvalue);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread *thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread *thread))</span>
    LastFrameAccessor last_frame(thread);
    JvmtiExport::post_method_entry(thread, last_frame.method(), last_frame.get_frame());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))</span>
    LastFrameAccessor last_frame(thread);
    JvmtiExport::post_method_exit(thread, last_frame.method(), last_frame.get_frame());
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
<span class="udiff-line-modified-removed">- IRT_LEAF(int, InterpreterRuntime::interpreter_contains(address pc))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(int, InterpreterRuntime::interpreter_contains(address pc))</span>
  {
    return (Interpreter::contains(pc) ? 1 : 0);
  }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  
  // Implementation of SignatureHandlerLibrary
  
  #ifndef SHARING_FAST_NATIVE_FINGERPRINTS
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1380,11 +1373,11 @@</span>
  void SignatureHandlerLibrary::add(const methodHandle&amp; method) {
    if (method-&gt;signature_handler() == NULL) {
      // use slow signature handler if we can&#39;t do better
      int handler_index = -1;
      // check if we can use customized (fast) signature handler
<span class="udiff-line-modified-removed">-     if (UseFastSignatureHandlers &amp;&amp; method-&gt;size_of_parameters() &lt;= Fingerprinter::max_size_of_parameters) {</span>
<span class="udiff-line-modified-added">+     if (UseFastSignatureHandlers &amp;&amp; method-&gt;size_of_parameters() &lt;= Fingerprinter::fp_max_size_of_parameters) {</span>
        // use customized signature handler
        MutexLocker mu(SignatureHandlerLibrary_lock);
        // make sure data structure is initialized
        initialize();
        // lookup method signature&#39;s fingerprint
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1447,11 +1440,11 @@</span>
        } else {
          // set handler
          method-&gt;set_signature_handler(_handlers-&gt;at(handler_index));
        }
      } else {
<span class="udiff-line-modified-removed">-       CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
<span class="udiff-line-modified-added">+       DEBUG_ONLY(Thread::current()-&gt;check_possible_safepoint());</span>
        // use generic signature handler
        method-&gt;set_signature_handler(Interpreter::slow_signature_handler());
      }
    }
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1512,11 +1505,11 @@</span>
  GrowableArray&lt;uint64_t&gt;* SignatureHandlerLibrary::_fingerprints = NULL;
  GrowableArray&lt;address&gt;*  SignatureHandlerLibrary::_handlers     = NULL;
  address                  SignatureHandlerLibrary::_buffer       = NULL;
  
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* thread, Method* method))</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* thread, Method* method))</span>
    methodHandle m(thread, method);
    assert(m-&gt;is_native(), &quot;sanity check&quot;);
    // lookup native function entry point if it doesn&#39;t exist
    bool in_base_library;
    if (!m-&gt;has_native_function()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1526,14 +1519,14 @@</span>
    SignatureHandlerLibrary::add(m);
    // The interpreter entry point checks the signature handler first,
    // before trying to fetch the native entry point and klass mirror.
    // We must set the signature handler last, so that multiple processors
    // preparing the same method will be sure to see non-null entry &amp; mirror.
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  #if defined(IA32) || defined(AMD64) || defined(ARM)
<span class="udiff-line-modified-removed">- IRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address))</span>
    if (src_address == dest_address) {
      return;
    }
    ResetNoHandleMark rnm; // In a LEAF entry.
    HandleMark hm;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1545,21 +1538,21 @@</span>
    Bytecode_invoke invoke(mh, bci);
    ArgumentSizeComputer asc(invoke.signature());
    int size_of_arguments = (asc.size() + (invoke.has_receiver() ? 1 : 0)); // receiver
    Copy::conjoint_jbytes(src_address, dest_address,
                         size_of_arguments * Interpreter::stackElementSize);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  #endif
  
  #if INCLUDE_JVMTI
  // This is a support of the JVMTI PopFrame interface.
  // Make sure it is an invokestatic of a polymorphic intrinsic that has a member_name argument
  // and return it as a vm_result so that it can be reloaded in the list of invokestatic parameters.
  // The member_name argument is a saved reference (in local#0) to the member_name.
  // For backward compatibility with some JDK versions (7, 8) it can also be a direct method handle.
  // FIXME: remove DMH case after j.l.i.InvokerBytecodeGenerator code shape is updated.
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* thread, address member_name,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* thread, address member_name,</span>
                                                              Method* method, address bcp))
    Bytecodes::Code code = Bytecodes::code_at(method, bcp);
    if (code != Bytecodes::_invokestatic) {
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1576,21 +1569,21 @@</span>
      }
      thread-&gt;set_vm_result(member_name_oop);
    } else {
      thread-&gt;set_vm_result(NULL);
    }
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  #endif // INCLUDE_JVMTI
  
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">- // This must be a IRT_LEAF function because the interpreter must save registers on x86 to</span>
<span class="udiff-line-modified-added">+ // This must be a JRT_LEAF function because the interpreter must save registers on x86 to</span>
  // call this, which changes rsp and makes the interpreter&#39;s expression stack not walkable.
  // The generated code still uses call_VM because that will set up the frame pointer for
  // bcp and method.
<span class="udiff-line-modified-removed">- IRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))</span>
<span class="udiff-line-modified-added">+ JRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))</span>
    LastFrameAccessor last_frame(thread);
    assert(last_frame.is_interpreted_frame(), &quot;must be an interpreted frame&quot;);
    methodHandle mh(thread, last_frame.method());
    BytecodeTracer::trace(mh, last_frame.bcp(), tos, tos2);
    return preserve_this_value;
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  #endif // !PRODUCT
</pre>
<center><a href="interpreter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
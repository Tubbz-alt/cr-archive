diff a/src/hotspot/share/interpreter/oopMapCache.cpp b/src/hotspot/share/interpreter/oopMapCache.cpp
--- a/src/hotspot/share/interpreter/oopMapCache.cpp
+++ b/src/hotspot/share/interpreter/oopMapCache.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,10 +27,11 @@
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "oops/oop.inline.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/signature.hpp"
 
 class OopMapCacheEntry: private InterpreterOopMap {
   friend class InterpreterOopMap;
@@ -254,11 +255,11 @@
     int i = (size + BitsPerWord - 1) / BitsPerWord;
     while (i-- > 0) _mask[i] = 0;
   }
 
   void generate() {
-    NativeSignatureIterator::iterate();
+    iterate();
   }
 };
 
 bool OopMapCacheEntry::verify_mask(CellTypeState* vars, CellTypeState* stack, int max_locals, int stack_top) {
   // Check mask includes map
@@ -446,15 +447,15 @@
   // Deallocate array
   FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);
 }
 
 OopMapCacheEntry* OopMapCache::entry_at(int i) const {
-  return OrderAccess::load_acquire(&(_array[i % _size]));
+  return Atomic::load_acquire(&(_array[i % _size]));
 }
 
 bool OopMapCache::put_at(int i, OopMapCacheEntry* entry, OopMapCacheEntry* old) {
-  return Atomic::cmpxchg(entry, &_array[i % _size], old) == old;
+  return Atomic::cmpxchg(&_array[i % _size], old, entry) == old;
 }
 
 void OopMapCache::flush() {
   for (int i = 0; i < _size; i++) {
     OopMapCacheEntry* entry = _array[i];
@@ -562,11 +563,11 @@
   bool success = false;
   OopMapCacheEntry* head;
   do {
     head = _old_entries;
     entry->_next = head;
-    success = Atomic::cmpxchg(entry, &_old_entries, head) == head;
+    success = Atomic::cmpxchg(&_old_entries, head, entry) == head;
   } while (!success);
 
   if (log_is_enabled(Debug, interpreter, oopmap)) {
     ResourceMark rm;
     log_debug(interpreter, oopmap)("enqueue %s at bci %d for cleanup",
@@ -592,11 +593,11 @@
   }
 }
 
 void OopMapCache::compute_one_oop_map(const methodHandle& method, int bci, InterpreterOopMap* entry) {
   // Due to the invariants above it's tricky to allocate a temporary OopMapCacheEntry on the stack
-  OopMapCacheEntry* tmp = NEW_C_HEAP_ARRAY(OopMapCacheEntry, 1, mtClass);
+  OopMapCacheEntry* tmp = NEW_C_HEAP_OBJ(OopMapCacheEntry, mtClass);
   tmp->initialize();
   tmp->fill(method, bci);
   entry->resource_copy(tmp);
-  FREE_C_HEAP_ARRAY(OopMapCacheEntry, tmp);
+  FREE_C_HEAP_OBJ(tmp);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/abstractInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../include/jvm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/abstractInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 30 #include &quot;interpreter/bytecodeInterpreter.hpp&quot;

 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 33 #include &quot;interpreter/interp_masm.hpp&quot;
 34 #include &quot;interpreter/templateTable.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/arrayOop.hpp&quot;


 39 #include &quot;oops/methodData.hpp&quot;
 40 #include &quot;oops/method.hpp&quot;
 41 #include &quot;oops/oop.inline.hpp&quot;
 42 #include &quot;prims/forte.hpp&quot;
 43 #include &quot;prims/jvmtiExport.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/handles.inline.hpp&quot;
 46 #include &quot;runtime/sharedRuntime.hpp&quot;
 47 #include &quot;runtime/stubRoutines.hpp&quot;
 48 #include &quot;runtime/timer.hpp&quot;
 49 
 50 # define __ _masm-&gt;
 51 
 52 //------------------------------------------------------------------------------------------------------------------------
 53 // Implementation of platform independent aspects of Interpreter
 54 
 55 void AbstractInterpreter::initialize() {
 56   if (_code != NULL) return;
 57 
 58   // make sure &#39;imported&#39; classes are initialized
 59   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) BytecodeCounter::reset();
 60   if (PrintBytecodeHistogram)                                BytecodeHistogram::reset();
 61   if (PrintBytecodePairHistogram)                            BytecodePairHistogram::reset();
<span class="line-removed"> 62 </span>
<span class="line-removed"> 63   InvocationCounter::reinitialize();</span>
<span class="line-removed"> 64 </span>
 65 }
 66 
 67 void AbstractInterpreter::print() {
 68   tty-&gt;cr();
 69   tty-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
 70   tty-&gt;print_cr(&quot;Interpreter&quot;);
 71   tty-&gt;cr();
 72   tty-&gt;print_cr(&quot;code size        = %6dK bytes&quot;, (int)_code-&gt;used_space()/1024);
 73   tty-&gt;print_cr(&quot;total space      = %6dK bytes&quot;, (int)_code-&gt;total_space()/1024);
 74   tty-&gt;print_cr(&quot;wasted space     = %6dK bytes&quot;, (int)_code-&gt;available_space()/1024);
 75   tty-&gt;cr();
 76   tty-&gt;print_cr(&quot;# of codelets    = %6d&quot;      , _code-&gt;number_of_stubs());
 77   if (_code-&gt;number_of_stubs() != 0) {
 78     tty-&gt;print_cr(&quot;avg codelet size = %6d bytes&quot;, _code-&gt;used_space() / _code-&gt;number_of_stubs());
 79     tty-&gt;cr();
 80   }
 81   _code-&gt;print();
 82   tty-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
 83   tty-&gt;cr();
 84 }
</pre>
<hr />
<pre>
188     default                   : break;
189   }
190 
191   // Accessor method?
192   if (m-&gt;is_getter()) {
193     // TODO: We should have used ::is_accessor above, but fast accessors in Zero expect only getters.
194     // See CppInterpreter::accessor_entry in cppInterpreter_zero.cpp. This should be fixed in Zero,
195     // then the call above updated to ::is_accessor
196     assert(m-&gt;size_of_parameters() == 1, &quot;fast code for accessors assumes parameter size = 1&quot;);
197     return accessor;
198   }
199 
200   // Note: for now: zero locals for all non-empty methods
201   return zerolocals;
202 }
203 
204 #if INCLUDE_CDS
205 
206 address AbstractInterpreter::get_trampoline_code_buffer(AbstractInterpreter::MethodKind kind) {
207   const size_t trampoline_size = SharedRuntime::trampoline_size();
<span class="line-modified">208   address addr = MetaspaceShared::cds_i2i_entry_code_buffers((size_t)(AbstractInterpreter::number_of_method_entries) * trampoline_size);</span>
209   addr += (size_t)(kind) * trampoline_size;
210 
211   return addr;
212 }
213 
214 void AbstractInterpreter::update_cds_entry_table(AbstractInterpreter::MethodKind kind) {
215   if (DumpSharedSpaces || UseSharedSpaces) {
216     address trampoline = get_trampoline_code_buffer(kind);
217     _cds_entry_table[kind] = trampoline;
218 
219     CodeBuffer buffer(trampoline, (int)(SharedRuntime::trampoline_size()));
220     MacroAssembler _masm(&amp;buffer);
221     SharedRuntime::generate_trampoline(&amp;_masm, _entry_table[kind]);

222 
223     if (PrintInterpreter) {
224       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());
225     }
226   }
227 }
228 
229 #endif
230 
231 void AbstractInterpreter::set_entry_for_kind(AbstractInterpreter::MethodKind kind, address entry) {
232   assert(kind &gt;= method_handle_invoke_FIRST &amp;&amp;
233          kind &lt;= method_handle_invoke_LAST, &quot;late initialization only for MH entry points&quot;);
234   assert(_entry_table[kind] == _entry_table[abstract], &quot;previous value must be AME entry&quot;);
235   _entry_table[kind] = entry;
236 
237   update_cds_entry_table(kind);
238 }
239 
240 // Return true if the interpreter can prove that the given bytecode has
241 // not yet been executed (in Java semantics, not in actual operation).
242 bool AbstractInterpreter::is_not_reached(const methodHandle&amp; method, int bci) {
<span class="line-modified">243   Bytecodes::Code code = method()-&gt;code_at(bci);</span>
<span class="line-modified">244 </span>
<span class="line-modified">245   if (!Bytecodes::must_rewrite(code)) {</span>




























246     // might have been reached
247     return false;
248   }
249 
250   // the bytecode might not be rewritten if the method is an accessor, etc.
251   address ientry = method-&gt;interpreter_entry();
252   if (ientry != entry_for_kind(AbstractInterpreter::zerolocals) &amp;&amp;
253       ientry != entry_for_kind(AbstractInterpreter::zerolocals_synchronized))
254     return false;  // interpreter does not run this method!
255 
256   // otherwise, we can be sure this bytecode has never been executed
257   return true;
258 }
259 
260 
261 #ifndef PRODUCT
262 void AbstractInterpreter::print_method_kind(MethodKind kind) {
263   switch (kind) {
264     case zerolocals             : tty-&gt;print(&quot;zerolocals&quot;             ); break;
265     case zerolocals_synchronized: tty-&gt;print(&quot;zerolocals_synchronized&quot;); break;
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 30 #include &quot;interpreter/bytecodeInterpreter.hpp&quot;
<span class="line-added"> 31 #include &quot;interpreter/bytecodeStream.hpp&quot;</span>
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 34 #include &quot;interpreter/interp_masm.hpp&quot;
 35 #include &quot;interpreter/templateTable.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/metaspaceShared.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-added"> 40 #include &quot;oops/constantPool.hpp&quot;</span>
<span class="line-added"> 41 #include &quot;oops/cpCache.inline.hpp&quot;</span>
 42 #include &quot;oops/methodData.hpp&quot;
 43 #include &quot;oops/method.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;prims/forte.hpp&quot;
 46 #include &quot;prims/jvmtiExport.hpp&quot;
 47 #include &quot;prims/methodHandles.hpp&quot;
 48 #include &quot;runtime/handles.inline.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 
 53 # define __ _masm-&gt;
 54 
 55 //------------------------------------------------------------------------------------------------------------------------
 56 // Implementation of platform independent aspects of Interpreter
 57 
 58 void AbstractInterpreter::initialize() {
 59   if (_code != NULL) return;
 60 
 61   // make sure &#39;imported&#39; classes are initialized
 62   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) BytecodeCounter::reset();
 63   if (PrintBytecodeHistogram)                                BytecodeHistogram::reset();
 64   if (PrintBytecodePairHistogram)                            BytecodePairHistogram::reset();



 65 }
 66 
 67 void AbstractInterpreter::print() {
 68   tty-&gt;cr();
 69   tty-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
 70   tty-&gt;print_cr(&quot;Interpreter&quot;);
 71   tty-&gt;cr();
 72   tty-&gt;print_cr(&quot;code size        = %6dK bytes&quot;, (int)_code-&gt;used_space()/1024);
 73   tty-&gt;print_cr(&quot;total space      = %6dK bytes&quot;, (int)_code-&gt;total_space()/1024);
 74   tty-&gt;print_cr(&quot;wasted space     = %6dK bytes&quot;, (int)_code-&gt;available_space()/1024);
 75   tty-&gt;cr();
 76   tty-&gt;print_cr(&quot;# of codelets    = %6d&quot;      , _code-&gt;number_of_stubs());
 77   if (_code-&gt;number_of_stubs() != 0) {
 78     tty-&gt;print_cr(&quot;avg codelet size = %6d bytes&quot;, _code-&gt;used_space() / _code-&gt;number_of_stubs());
 79     tty-&gt;cr();
 80   }
 81   _code-&gt;print();
 82   tty-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
 83   tty-&gt;cr();
 84 }
</pre>
<hr />
<pre>
188     default                   : break;
189   }
190 
191   // Accessor method?
192   if (m-&gt;is_getter()) {
193     // TODO: We should have used ::is_accessor above, but fast accessors in Zero expect only getters.
194     // See CppInterpreter::accessor_entry in cppInterpreter_zero.cpp. This should be fixed in Zero,
195     // then the call above updated to ::is_accessor
196     assert(m-&gt;size_of_parameters() == 1, &quot;fast code for accessors assumes parameter size = 1&quot;);
197     return accessor;
198   }
199 
200   // Note: for now: zero locals for all non-empty methods
201   return zerolocals;
202 }
203 
204 #if INCLUDE_CDS
205 
206 address AbstractInterpreter::get_trampoline_code_buffer(AbstractInterpreter::MethodKind kind) {
207   const size_t trampoline_size = SharedRuntime::trampoline_size();
<span class="line-modified">208   address addr = MetaspaceShared::i2i_entry_code_buffers((size_t)(AbstractInterpreter::number_of_method_entries) * trampoline_size);</span>
209   addr += (size_t)(kind) * trampoline_size;
210 
211   return addr;
212 }
213 
214 void AbstractInterpreter::update_cds_entry_table(AbstractInterpreter::MethodKind kind) {
215   if (DumpSharedSpaces || UseSharedSpaces) {
216     address trampoline = get_trampoline_code_buffer(kind);
217     _cds_entry_table[kind] = trampoline;
218 
219     CodeBuffer buffer(trampoline, (int)(SharedRuntime::trampoline_size()));
220     MacroAssembler _masm(&amp;buffer);
221     SharedRuntime::generate_trampoline(&amp;_masm, _entry_table[kind]);
<span class="line-added">222     _masm.flush();</span>
223 
224     if (PrintInterpreter) {
225       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());
226     }
227   }
228 }
229 
230 #endif
231 
232 void AbstractInterpreter::set_entry_for_kind(AbstractInterpreter::MethodKind kind, address entry) {
233   assert(kind &gt;= method_handle_invoke_FIRST &amp;&amp;
234          kind &lt;= method_handle_invoke_LAST, &quot;late initialization only for MH entry points&quot;);
235   assert(_entry_table[kind] == _entry_table[abstract], &quot;previous value must be AME entry&quot;);
236   _entry_table[kind] = entry;
237 
238   update_cds_entry_table(kind);
239 }
240 
241 // Return true if the interpreter can prove that the given bytecode has
242 // not yet been executed (in Java semantics, not in actual operation).
243 bool AbstractInterpreter::is_not_reached(const methodHandle&amp; method, int bci) {
<span class="line-modified">244   BytecodeStream s(method, bci);</span>
<span class="line-modified">245   Bytecodes::Code code = s.next();</span>
<span class="line-modified">246 </span>
<span class="line-added">247   if (Bytecodes::is_invoke(code)) {</span>
<span class="line-added">248     assert(!Bytecodes::must_rewrite(code), &quot;invokes aren&#39;t rewritten&quot;);</span>
<span class="line-added">249     ConstantPool* cpool = method()-&gt;constants();</span>
<span class="line-added">250 </span>
<span class="line-added">251     Bytecode invoke_bc(s.bytecode());</span>
<span class="line-added">252 </span>
<span class="line-added">253     switch (code) {</span>
<span class="line-added">254       case Bytecodes::_invokedynamic: {</span>
<span class="line-added">255         assert(invoke_bc.has_index_u4(code), &quot;sanity&quot;);</span>
<span class="line-added">256         int method_index = invoke_bc.get_index_u4(code);</span>
<span class="line-added">257         return cpool-&gt;invokedynamic_cp_cache_entry_at(method_index)-&gt;is_f1_null();</span>
<span class="line-added">258       }</span>
<span class="line-added">259       case Bytecodes::_invokevirtual:   // fall-through</span>
<span class="line-added">260       case Bytecodes::_invokeinterface: // fall-through</span>
<span class="line-added">261       case Bytecodes::_invokespecial:   // fall-through</span>
<span class="line-added">262       case Bytecodes::_invokestatic: {</span>
<span class="line-added">263         if (cpool-&gt;has_preresolution()) {</span>
<span class="line-added">264           return false; // might have been reached</span>
<span class="line-added">265         }</span>
<span class="line-added">266         assert(!invoke_bc.has_index_u4(code), &quot;sanity&quot;);</span>
<span class="line-added">267         int method_index = invoke_bc.get_index_u2_cpcache(code);</span>
<span class="line-added">268         constantPoolHandle cp(Thread::current(), cpool);</span>
<span class="line-added">269         Method* resolved_method = ConstantPool::method_at_if_loaded(cp, method_index);</span>
<span class="line-added">270         return (resolved_method == NULL);</span>
<span class="line-added">271       }</span>
<span class="line-added">272       default: ShouldNotReachHere();</span>
<span class="line-added">273     }</span>
<span class="line-added">274   } else if (!Bytecodes::must_rewrite(code)) {</span>
275     // might have been reached
276     return false;
277   }
278 
279   // the bytecode might not be rewritten if the method is an accessor, etc.
280   address ientry = method-&gt;interpreter_entry();
281   if (ientry != entry_for_kind(AbstractInterpreter::zerolocals) &amp;&amp;
282       ientry != entry_for_kind(AbstractInterpreter::zerolocals_synchronized))
283     return false;  // interpreter does not run this method!
284 
285   // otherwise, we can be sure this bytecode has never been executed
286   return true;
287 }
288 
289 
290 #ifndef PRODUCT
291 void AbstractInterpreter::print_method_kind(MethodKind kind) {
292   switch (kind) {
293     case zerolocals             : tty-&gt;print(&quot;zerolocals&quot;             ); break;
294     case zerolocals_synchronized: tty-&gt;print(&quot;zerolocals_synchronized&quot;); break;
</pre>
</td>
</tr>
</table>
<center><a href="../include/jvm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
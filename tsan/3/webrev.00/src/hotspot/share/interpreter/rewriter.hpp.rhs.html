<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/rewriter.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_REWRITER_HPP
 26 #define SHARE_INTERPRETER_REWRITER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/growableArray.hpp&quot;
 30 
 31 // The Rewriter adds caches to the constant pool and rewrites bytecode indices
 32 // pointing into the constant pool for better interpreter performance.
 33 
 34 class Rewriter: public StackObj {
 35  private:
 36   InstanceKlass*      _klass;
 37   constantPoolHandle  _pool;
 38   Array&lt;Method*&gt;*     _methods;
 39   GrowableArray&lt;int&gt;  _cp_map;
 40   GrowableArray&lt;int&gt;  _cp_cache_map;  // for Methodref, Fieldref,
 41                                       // InterfaceMethodref and InvokeDynamic
 42   GrowableArray&lt;int&gt;  _reference_map; // maps from cp index to resolved_refs index (or -1)
 43   GrowableArray&lt;int&gt;  _resolved_references_map; // for strings, methodHandle, methodType
 44   GrowableArray&lt;int&gt;  _invokedynamic_references_map; // for invokedynamic resolved refs
 45   GrowableArray&lt;int&gt;  _method_handle_invokers;
 46   int                 _resolved_reference_limit;
 47 
 48   // For mapping invokedynamic bytecodes, which are discovered during method
 49   // scanning.  The invokedynamic entries are added at the end of the cpCache.
 50   // If there are any invokespecial/InterfaceMethodref special case bytecodes,
 51   // these entries are added before invokedynamic entries so that the
 52   // invokespecial bytecode 16 bit index doesn&#39;t overflow.
 53   GrowableArray&lt;int&gt;      _invokedynamic_cp_cache_map;
 54 
 55   // For patching.
 56   GrowableArray&lt;address&gt;* _patch_invokedynamic_bcps;
 57   GrowableArray&lt;int&gt;*     _patch_invokedynamic_refs;
 58 
 59   void init_maps(int length) {
 60     _cp_map.trunc_to(0);
 61     _cp_map.at_grow(length, -1);
 62 
 63     _cp_cache_map.trunc_to(0);
 64     // Also cache resolved objects, in another different cache.
 65     _reference_map.trunc_to(0);
 66     _reference_map.at_grow(length, -1);
 67 
 68     _method_handle_invokers.trunc_to(0);
 69     _resolved_references_map.trunc_to(0);
 70     _invokedynamic_references_map.trunc_to(0);
 71     _resolved_reference_limit = -1;
 72     _first_iteration_cp_cache_limit = -1;
 73 
 74     // invokedynamic specific fields
 75     _invokedynamic_cp_cache_map.trunc_to(0);
 76     _patch_invokedynamic_bcps = new GrowableArray&lt;address&gt;(length / 4);
 77     _patch_invokedynamic_refs = new GrowableArray&lt;int&gt;(length / 4);
 78   }
 79 
 80   int _first_iteration_cp_cache_limit;
 81   void record_map_limits() {
 82     // Record initial size of the two arrays generated for the CP cache
 83     // relative to walking the constant pool.
 84     _first_iteration_cp_cache_limit = _cp_cache_map.length();
 85     _resolved_reference_limit = _resolved_references_map.length();
 86   }
 87 
 88   int cp_cache_delta() {
 89     // How many cp cache entries were added since recording map limits after
 90     // cp cache initialization?
 91     assert(_first_iteration_cp_cache_limit != -1, &quot;only valid after first iteration&quot;);
 92     return _cp_cache_map.length() - _first_iteration_cp_cache_limit;
 93   }
 94 
 95   int  cp_entry_to_cp_cache(int i) { assert(has_cp_cache(i), &quot;oob&quot;); return _cp_map.at(i); }
 96   bool has_cp_cache(int i) { return (uint) i &lt; (uint) _cp_map.length() &amp;&amp; _cp_map.at(i) &gt;= 0; }
 97 
 98   int add_map_entry(int cp_index, GrowableArray&lt;int&gt;* cp_map, GrowableArray&lt;int&gt;* cp_cache_map) {
 99     assert(cp_map-&gt;at(cp_index) == -1, &quot;not twice on same cp_index&quot;);
100     int cache_index = cp_cache_map-&gt;append(cp_index);
101     cp_map-&gt;at_put(cp_index, cache_index);
102     return cache_index;
103   }
104 
105   int add_cp_cache_entry(int cp_index) {
106     assert(_pool-&gt;tag_at(cp_index).value() != JVM_CONSTANT_InvokeDynamic, &quot;use indy version&quot;);
107     assert(_first_iteration_cp_cache_limit == -1, &quot;do not add cache entries after first iteration&quot;);
108     int cache_index = add_map_entry(cp_index, &amp;_cp_map, &amp;_cp_cache_map);
109     assert(cp_entry_to_cp_cache(cp_index) == cache_index, &quot;&quot;);
110     assert(cp_cache_entry_pool_index(cache_index) == cp_index, &quot;&quot;);
111     return cache_index;
112   }
113 
114   int add_invokedynamic_cp_cache_entry(int cp_index) {
115     assert(_pool-&gt;tag_at(cp_index).value() == JVM_CONSTANT_InvokeDynamic, &quot;use non-indy version&quot;);
116     assert(_first_iteration_cp_cache_limit &gt;= 0, &quot;add indy cache entries after first iteration&quot;);
117     // add to the invokedynamic index map.
118     int cache_index = _invokedynamic_cp_cache_map.append(cp_index);
119     // do not update _cp_map, since the mapping is one-to-many
120     assert(invokedynamic_cp_cache_entry_pool_index(cache_index) == cp_index, &quot;&quot;);
121     // this index starts at one but in the bytecode it&#39;s appended to the end.
122     return cache_index + _first_iteration_cp_cache_limit;
123   }
124 
125   int invokedynamic_cp_cache_entry_pool_index(int cache_index) {
126     int cp_index = _invokedynamic_cp_cache_map.at(cache_index);
127     return cp_index;
128   }
129 
130   // add a new CP cache entry beyond the normal cache for the special case of
131   // invokespecial with InterfaceMethodref as cpool operand.
132   int add_invokespecial_cp_cache_entry(int cp_index) {
133     assert(_first_iteration_cp_cache_limit &gt;= 0, &quot;add these special cache entries after first iteration&quot;);
134     // Don&#39;t add InterfaceMethodref if it already exists at the end.
135     for (int i = _first_iteration_cp_cache_limit; i &lt; _cp_cache_map.length(); i++) {
136       if (cp_cache_entry_pool_index(i) == cp_index) {
137         return i;
138       }
139     }
140     int cache_index = _cp_cache_map.append(cp_index);
141     assert(cache_index &gt;= _first_iteration_cp_cache_limit, &quot;&quot;);
142     // do not update _cp_map, since the mapping is one-to-many
143     assert(cp_cache_entry_pool_index(cache_index) == cp_index, &quot;&quot;);
144     return cache_index;
145   }
146 
147   int  cp_entry_to_resolved_references(int cp_index) const {
148     assert(has_entry_in_resolved_references(cp_index), &quot;oob&quot;);
149     return _reference_map.at(cp_index);
150   }
151   bool has_entry_in_resolved_references(int cp_index) const {
152     return (uint) cp_index &lt; (uint) _reference_map.length() &amp;&amp; _reference_map.at(cp_index) &gt;= 0;
153   }
154 
155   // add a new entry to the resolved_references map
156   int add_resolved_references_entry(int cp_index) {
157     int ref_index = add_map_entry(cp_index, &amp;_reference_map, &amp;_resolved_references_map);
158     assert(cp_entry_to_resolved_references(cp_index) == ref_index, &quot;&quot;);
159     return ref_index;
160   }
161 
162   // add a new entry to the resolved_references map (for invokedynamic and invokehandle only)
163   int add_invokedynamic_resolved_references_entry(int cp_index, int cache_index) {
164     assert(_resolved_reference_limit &gt;= 0, &quot;must add indy refs after first iteration&quot;);
165     int ref_index = _resolved_references_map.append(cp_index);  // many-to-one
166     assert(ref_index &gt;= _resolved_reference_limit, &quot;&quot;);
167     _invokedynamic_references_map.at_put_grow(ref_index, cache_index, -1);
168     return ref_index;
169   }
170 
171   int resolved_references_entry_to_pool_index(int ref_index) {
172     int cp_index = _resolved_references_map.at(ref_index);
173     return cp_index;
174   }
175 
176   // Access the contents of _cp_cache_map to determine CP cache layout.
177   int cp_cache_entry_pool_index(int cache_index) {
178     int cp_index = _cp_cache_map.at(cache_index);
179     return cp_index;
180   }
181 
182   // All the work goes in here:
183   Rewriter(InstanceKlass* klass, const constantPoolHandle&amp; cpool, Array&lt;Method*&gt;* methods, TRAPS);
184 
185   void compute_index_maps();
186   void make_constant_pool_cache(TRAPS);
<a name="1" id="anc1"></a><span class="line-modified">187   void scan_method(Thread* thread, Method* m, bool reverse, bool* invokespecial_error);</span>
188   void rewrite_Object_init(const methodHandle&amp; m, TRAPS);
189   void rewrite_member_reference(address bcp, int offset, bool reverse);
190   void maybe_rewrite_invokehandle(address opc, int cp_index, int cache_index, bool reverse);
191   void rewrite_invokedynamic(address bcp, int offset, bool reverse);
192   void maybe_rewrite_ldc(address bcp, int offset, bool is_wide, bool reverse);
193   void rewrite_invokespecial(address bcp, int offset, bool reverse, bool* invokespecial_error);
194 
195   void patch_invokedynamic_bytecodes();
196 
197   // Do all the work.
198   void rewrite_bytecodes(TRAPS);
199 
200   // Revert bytecodes in case of an exception.
<a name="2" id="anc2"></a><span class="line-modified">201   void restore_bytecodes(Thread* thread);</span>
202 
203   static methodHandle rewrite_jsrs(const methodHandle&amp; m, TRAPS);
204  public:
205   // Driver routine:
206   static void rewrite(InstanceKlass* klass, TRAPS);
207 };
208 
209 #endif // SHARE_INTERPRETER_REWRITER_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
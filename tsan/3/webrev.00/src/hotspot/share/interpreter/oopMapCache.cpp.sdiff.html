<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/oopMapCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="linkResolver.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/oopMapCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/oopMapCache.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;logging/logStream.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;

 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/signature.hpp&quot;
 34 
 35 class OopMapCacheEntry: private InterpreterOopMap {
 36   friend class InterpreterOopMap;
 37   friend class OopMapForCacheEntry;
 38   friend class OopMapCache;
 39   friend class VerifyClosure;
 40 
 41  private:
 42   OopMapCacheEntry* _next;
 43 
 44  protected:
 45   // Initialization
 46   void fill(const methodHandle&amp; method, int bci);
 47   // fills the bit mask for native calls
 48   void fill_for_native(const methodHandle&amp; method);
 49   void set_mask(CellTypeState* vars, CellTypeState* stack, int stack_top);
 50 
 51   // Deallocate bit masks and initialize fields
</pre>
<hr />
<pre>
239     assert(0 &lt;= i &amp;&amp; i &lt; _size, &quot;offset out of bounds&quot;);
240     _mask[i / BitsPerWord] |= (((uintptr_t) 1 &lt;&lt; InterpreterOopMap::oop_bit_number) &lt;&lt; (i % BitsPerWord));
241   }
242 
243  public:
244   void pass_int()                                { /* ignore */ }
245   void pass_long()                               { /* ignore */ }
246   void pass_float()                              { /* ignore */ }
247   void pass_double()                             { /* ignore */ }
248   void pass_object()                             { set_one(offset()); }
249 
250   MaskFillerForNative(const methodHandle&amp; method, uintptr_t* mask, int size) : NativeSignatureIterator(method) {
251     _mask   = mask;
252     _size   = size;
253     // initialize with 0
254     int i = (size + BitsPerWord - 1) / BitsPerWord;
255     while (i-- &gt; 0) _mask[i] = 0;
256   }
257 
258   void generate() {
<span class="line-modified">259     NativeSignatureIterator::iterate();</span>
260   }
261 };
262 
263 bool OopMapCacheEntry::verify_mask(CellTypeState* vars, CellTypeState* stack, int max_locals, int stack_top) {
264   // Check mask includes map
265   VerifyClosure blk(this);
266   iterate_oop(&amp;blk);
267   if (blk.failed()) return false;
268 
269   // Check if map is generated correctly
270   // (Use ?: operator to make sure all &#39;true&#39; &amp; &#39;false&#39; are represented exactly the same so we can use == afterwards)
271   Log(interpreter, oopmap) logv;
272   LogStream st(logv.trace());
273 
274   st.print(&quot;Locals (%d): &quot;, max_locals);
275   for(int i = 0; i &lt; max_locals; i++) {
276     bool v1 = is_oop(i)               ? true : false;
277     bool v2 = vars[i].is_reference()  ? true : false;
278     assert(v1 == v2, &quot;locals oop mask generation error&quot;);
279     st.print(&quot;%d&quot;, v1 ? 1 : 0);
</pre>
<hr />
<pre>
431          ^ ((unsigned int) method-&gt;size_of_parameters() &lt;&lt; 6);
432 }
433 
434 OopMapCacheEntry* volatile OopMapCache::_old_entries = NULL;
435 
436 OopMapCache::OopMapCache() {
437   _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);
438   for(int i = 0; i &lt; _size; i++) _array[i] = NULL;
439 }
440 
441 
442 OopMapCache::~OopMapCache() {
443   assert(_array != NULL, &quot;sanity check&quot;);
444   // Deallocate oop maps that are allocated out-of-line
445   flush();
446   // Deallocate array
447   FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);
448 }
449 
450 OopMapCacheEntry* OopMapCache::entry_at(int i) const {
<span class="line-modified">451   return OrderAccess::load_acquire(&amp;(_array[i % _size]));</span>
452 }
453 
454 bool OopMapCache::put_at(int i, OopMapCacheEntry* entry, OopMapCacheEntry* old) {
<span class="line-modified">455   return Atomic::cmpxchg(entry, &amp;_array[i % _size], old) == old;</span>
456 }
457 
458 void OopMapCache::flush() {
459   for (int i = 0; i &lt; _size; i++) {
460     OopMapCacheEntry* entry = _array[i];
461     if (entry != NULL) {
462       _array[i] = NULL;  // no barrier, only called in OopMapCache destructor
463       entry-&gt;flush();
464       FREE_C_HEAP_OBJ(entry);
465     }
466   }
467 }
468 
469 void OopMapCache::flush_obsolete_entries() {
470   assert(SafepointSynchronize::is_at_safepoint(), &quot;called by RedefineClasses in a safepoint&quot;);
471   for (int i = 0; i &lt; _size; i++) {
472     OopMapCacheEntry* entry = _array[i];
473     if (entry != NULL &amp;&amp; !entry-&gt;is_empty() &amp;&amp; entry-&gt;method()-&gt;is_old()) {
474       // Cache entry is occupied by an old redefined method and we don&#39;t want
475       // to pin it down so flush the entry.
</pre>
<hr />
<pre>
547 
548   // No empty slot (uncommon case). Use (some approximation of a) LRU algorithm
549   // where the first entry in the collision array is replaced with the new one.
550   OopMapCacheEntry* old = entry_at(probe + 0);
551   if (put_at(probe + 0, tmp, old)) {
552     enqueue_for_cleanup(old);
553   } else {
554     enqueue_for_cleanup(tmp);
555   }
556 
557   assert(!entry_for-&gt;is_empty(), &quot;A non-empty oop map should be returned&quot;);
558   return;
559 }
560 
561 void OopMapCache::enqueue_for_cleanup(OopMapCacheEntry* entry) {
562   bool success = false;
563   OopMapCacheEntry* head;
564   do {
565     head = _old_entries;
566     entry-&gt;_next = head;
<span class="line-modified">567     success = Atomic::cmpxchg(entry, &amp;_old_entries, head) == head;</span>
568   } while (!success);
569 
570   if (log_is_enabled(Debug, interpreter, oopmap)) {
571     ResourceMark rm;
572     log_debug(interpreter, oopmap)(&quot;enqueue %s at bci %d for cleanup&quot;,
573                           entry-&gt;method()-&gt;name_and_sig_as_C_string(), entry-&gt;bci());
574   }
575 }
576 
577 // This is called after GC threads are done and nothing is accessing the old_entries
578 // list, so no synchronization needed.
579 void OopMapCache::cleanup_old_entries() {
580   OopMapCacheEntry* entry = _old_entries;
581   _old_entries = NULL;
582   while (entry != NULL) {
583     if (log_is_enabled(Debug, interpreter, oopmap)) {
584       ResourceMark rm;
585       log_debug(interpreter, oopmap)(&quot;cleanup entry %s at bci %d&quot;,
586                           entry-&gt;method()-&gt;name_and_sig_as_C_string(), entry-&gt;bci());
587     }
588     OopMapCacheEntry* next = entry-&gt;_next;
589     entry-&gt;flush();
590     FREE_C_HEAP_OBJ(entry);
591     entry = next;
592   }
593 }
594 
595 void OopMapCache::compute_one_oop_map(const methodHandle&amp; method, int bci, InterpreterOopMap* entry) {
596   // Due to the invariants above it&#39;s tricky to allocate a temporary OopMapCacheEntry on the stack
<span class="line-modified">597   OopMapCacheEntry* tmp = NEW_C_HEAP_ARRAY(OopMapCacheEntry, 1, mtClass);</span>
598   tmp-&gt;initialize();
599   tmp-&gt;fill(method, bci);
600   entry-&gt;resource_copy(tmp);
<span class="line-modified">601   FREE_C_HEAP_ARRAY(OopMapCacheEntry, tmp);</span>
602 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/oopMapCache.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;logging/logStream.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added"> 32 #include &quot;runtime/atomic.hpp&quot;</span>
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/signature.hpp&quot;
 35 
 36 class OopMapCacheEntry: private InterpreterOopMap {
 37   friend class InterpreterOopMap;
 38   friend class OopMapForCacheEntry;
 39   friend class OopMapCache;
 40   friend class VerifyClosure;
 41 
 42  private:
 43   OopMapCacheEntry* _next;
 44 
 45  protected:
 46   // Initialization
 47   void fill(const methodHandle&amp; method, int bci);
 48   // fills the bit mask for native calls
 49   void fill_for_native(const methodHandle&amp; method);
 50   void set_mask(CellTypeState* vars, CellTypeState* stack, int stack_top);
 51 
 52   // Deallocate bit masks and initialize fields
</pre>
<hr />
<pre>
240     assert(0 &lt;= i &amp;&amp; i &lt; _size, &quot;offset out of bounds&quot;);
241     _mask[i / BitsPerWord] |= (((uintptr_t) 1 &lt;&lt; InterpreterOopMap::oop_bit_number) &lt;&lt; (i % BitsPerWord));
242   }
243 
244  public:
245   void pass_int()                                { /* ignore */ }
246   void pass_long()                               { /* ignore */ }
247   void pass_float()                              { /* ignore */ }
248   void pass_double()                             { /* ignore */ }
249   void pass_object()                             { set_one(offset()); }
250 
251   MaskFillerForNative(const methodHandle&amp; method, uintptr_t* mask, int size) : NativeSignatureIterator(method) {
252     _mask   = mask;
253     _size   = size;
254     // initialize with 0
255     int i = (size + BitsPerWord - 1) / BitsPerWord;
256     while (i-- &gt; 0) _mask[i] = 0;
257   }
258 
259   void generate() {
<span class="line-modified">260     iterate();</span>
261   }
262 };
263 
264 bool OopMapCacheEntry::verify_mask(CellTypeState* vars, CellTypeState* stack, int max_locals, int stack_top) {
265   // Check mask includes map
266   VerifyClosure blk(this);
267   iterate_oop(&amp;blk);
268   if (blk.failed()) return false;
269 
270   // Check if map is generated correctly
271   // (Use ?: operator to make sure all &#39;true&#39; &amp; &#39;false&#39; are represented exactly the same so we can use == afterwards)
272   Log(interpreter, oopmap) logv;
273   LogStream st(logv.trace());
274 
275   st.print(&quot;Locals (%d): &quot;, max_locals);
276   for(int i = 0; i &lt; max_locals; i++) {
277     bool v1 = is_oop(i)               ? true : false;
278     bool v2 = vars[i].is_reference()  ? true : false;
279     assert(v1 == v2, &quot;locals oop mask generation error&quot;);
280     st.print(&quot;%d&quot;, v1 ? 1 : 0);
</pre>
<hr />
<pre>
432          ^ ((unsigned int) method-&gt;size_of_parameters() &lt;&lt; 6);
433 }
434 
435 OopMapCacheEntry* volatile OopMapCache::_old_entries = NULL;
436 
437 OopMapCache::OopMapCache() {
438   _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);
439   for(int i = 0; i &lt; _size; i++) _array[i] = NULL;
440 }
441 
442 
443 OopMapCache::~OopMapCache() {
444   assert(_array != NULL, &quot;sanity check&quot;);
445   // Deallocate oop maps that are allocated out-of-line
446   flush();
447   // Deallocate array
448   FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);
449 }
450 
451 OopMapCacheEntry* OopMapCache::entry_at(int i) const {
<span class="line-modified">452   return Atomic::load_acquire(&amp;(_array[i % _size]));</span>
453 }
454 
455 bool OopMapCache::put_at(int i, OopMapCacheEntry* entry, OopMapCacheEntry* old) {
<span class="line-modified">456   return Atomic::cmpxchg(&amp;_array[i % _size], old, entry) == old;</span>
457 }
458 
459 void OopMapCache::flush() {
460   for (int i = 0; i &lt; _size; i++) {
461     OopMapCacheEntry* entry = _array[i];
462     if (entry != NULL) {
463       _array[i] = NULL;  // no barrier, only called in OopMapCache destructor
464       entry-&gt;flush();
465       FREE_C_HEAP_OBJ(entry);
466     }
467   }
468 }
469 
470 void OopMapCache::flush_obsolete_entries() {
471   assert(SafepointSynchronize::is_at_safepoint(), &quot;called by RedefineClasses in a safepoint&quot;);
472   for (int i = 0; i &lt; _size; i++) {
473     OopMapCacheEntry* entry = _array[i];
474     if (entry != NULL &amp;&amp; !entry-&gt;is_empty() &amp;&amp; entry-&gt;method()-&gt;is_old()) {
475       // Cache entry is occupied by an old redefined method and we don&#39;t want
476       // to pin it down so flush the entry.
</pre>
<hr />
<pre>
548 
549   // No empty slot (uncommon case). Use (some approximation of a) LRU algorithm
550   // where the first entry in the collision array is replaced with the new one.
551   OopMapCacheEntry* old = entry_at(probe + 0);
552   if (put_at(probe + 0, tmp, old)) {
553     enqueue_for_cleanup(old);
554   } else {
555     enqueue_for_cleanup(tmp);
556   }
557 
558   assert(!entry_for-&gt;is_empty(), &quot;A non-empty oop map should be returned&quot;);
559   return;
560 }
561 
562 void OopMapCache::enqueue_for_cleanup(OopMapCacheEntry* entry) {
563   bool success = false;
564   OopMapCacheEntry* head;
565   do {
566     head = _old_entries;
567     entry-&gt;_next = head;
<span class="line-modified">568     success = Atomic::cmpxchg(&amp;_old_entries, head, entry) == head;</span>
569   } while (!success);
570 
571   if (log_is_enabled(Debug, interpreter, oopmap)) {
572     ResourceMark rm;
573     log_debug(interpreter, oopmap)(&quot;enqueue %s at bci %d for cleanup&quot;,
574                           entry-&gt;method()-&gt;name_and_sig_as_C_string(), entry-&gt;bci());
575   }
576 }
577 
578 // This is called after GC threads are done and nothing is accessing the old_entries
579 // list, so no synchronization needed.
580 void OopMapCache::cleanup_old_entries() {
581   OopMapCacheEntry* entry = _old_entries;
582   _old_entries = NULL;
583   while (entry != NULL) {
584     if (log_is_enabled(Debug, interpreter, oopmap)) {
585       ResourceMark rm;
586       log_debug(interpreter, oopmap)(&quot;cleanup entry %s at bci %d&quot;,
587                           entry-&gt;method()-&gt;name_and_sig_as_C_string(), entry-&gt;bci());
588     }
589     OopMapCacheEntry* next = entry-&gt;_next;
590     entry-&gt;flush();
591     FREE_C_HEAP_OBJ(entry);
592     entry = next;
593   }
594 }
595 
596 void OopMapCache::compute_one_oop_map(const methodHandle&amp; method, int bci, InterpreterOopMap* entry) {
597   // Due to the invariants above it&#39;s tricky to allocate a temporary OopMapCacheEntry on the stack
<span class="line-modified">598   OopMapCacheEntry* tmp = NEW_C_HEAP_OBJ(OopMapCacheEntry, mtClass);</span>
599   tmp-&gt;initialize();
600   tmp-&gt;fill(method, bci);
601   entry-&gt;resource_copy(tmp);
<span class="line-modified">602   FREE_C_HEAP_OBJ(tmp);</span>
603 }
</pre>
</td>
</tr>
</table>
<center><a href="linkResolver.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rewriter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
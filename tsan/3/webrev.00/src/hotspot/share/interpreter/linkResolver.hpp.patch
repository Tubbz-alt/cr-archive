diff a/src/hotspot/share/interpreter/linkResolver.hpp b/src/hotspot/share/interpreter/linkResolver.hpp
--- a/src/hotspot/share/interpreter/linkResolver.hpp
+++ b/src/hotspot/share/interpreter/linkResolver.hpp
@@ -23,10 +23,11 @@
  */
 
 #ifndef SHARE_INTERPRETER_LINKRESOLVER_HPP
 #define SHARE_INTERPRETER_LINKRESOLVER_HPP
 
+#include "interpreter/bootstrapInfo.hpp"
 #include "oops/method.hpp"
 
 // All the necessary definitions for run-time link resolution.
 
 // CallInfo provides all the information gathered for a particular
@@ -75,10 +76,11 @@
                   const methodHandle& resolved_method,
                   const methodHandle& selected_method,
                   CallKind kind,
                   int index, TRAPS);
 
+  friend class BootstrapInfo;
   friend class LinkResolver;
 
  public:
   CallInfo() {
 #ifndef PRODUCT
@@ -92,12 +94,12 @@
   // object for the resolved_method.
   CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
 
   Klass*  resolved_klass() const                 { return _resolved_klass; }
   Klass*  selected_klass() const                 { return _selected_klass; }
-  methodHandle resolved_method() const           { return _resolved_method; }
-  methodHandle selected_method() const           { return _selected_method; }
+  Method* resolved_method() const                { return _resolved_method(); }
+  Method* selected_method() const                { return _selected_method(); }
   Handle       resolved_appendix() const         { return _resolved_appendix; }
   Handle       resolved_method_name() const      { return _resolved_method_name; }
   // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
   void     set_resolved_method_name(TRAPS);
 
@@ -177,14 +179,13 @@
   // accessors
   Symbol* name() const               { return _name; }
   Symbol* signature() const          { return _signature; }
   Klass* resolved_klass() const      { return _resolved_klass; }
   Klass* current_klass() const       { return _current_klass; }
-  methodHandle current_method() const { return _current_method; }
+  Method* current_method() const     { return _current_method(); }
   constantTag tag() const            { return _tag; }
   bool check_access() const          { return _check_access; }
-  char* method_string() const;
 
   void         print()  PRODUCT_RETURN;
 };
 
 // Link information for getfield/putfield & getstatic/putstatic bytecodes
@@ -202,16 +203,16 @@
   static Method* lookup_method_in_klasses(const LinkInfo& link_info,
                                           bool checkpolymorphism,
                                           bool in_imethod_resolve);
   static Method* lookup_method_in_interfaces(const LinkInfo& link_info);
 
-  static methodHandle lookup_polymorphic_method(const LinkInfo& link_info,
-                                                Handle *appendix_result_or_null, TRAPS);
+  static Method* lookup_polymorphic_method(const LinkInfo& link_info,
+                                           Handle *appendix_result_or_null, TRAPS);
  JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
   // Not Linktime so doesn't take LinkInfo
-  static methodHandle lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,
-                                                         Klass::PrivateLookupMode private_mode, TRAPS);
+  static Method* lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,
+                                                    Klass::PrivateLookupMode private_mode, TRAPS);
  JVMCI_ONLY(private:)
 
   // Similar loader constraint checking functions that throw
   // LinkageError with descriptive message.
   static void check_method_loader_constraints(const LinkInfo& link_info,
@@ -219,17 +220,17 @@
                                               const char* method_type, TRAPS);
   static void check_field_loader_constraints(Symbol* field, Symbol* sig,
                                              Klass* current_klass,
                                              Klass* sel_klass, TRAPS);
 
-  static methodHandle resolve_interface_method(const LinkInfo& link_info, Bytecodes::Code code, TRAPS);
-  static methodHandle resolve_method          (const LinkInfo& link_info, Bytecodes::Code code, TRAPS);
+  static Method* resolve_interface_method(const LinkInfo& link_info, Bytecodes::Code code, TRAPS);
+  static Method* resolve_method          (const LinkInfo& link_info, Bytecodes::Code code, TRAPS);
 
-  static methodHandle linktime_resolve_static_method    (const LinkInfo& link_info, TRAPS);
-  static methodHandle linktime_resolve_special_method   (const LinkInfo& link_info, TRAPS);
-  static methodHandle linktime_resolve_virtual_method   (const LinkInfo& link_info, TRAPS);
-  static methodHandle linktime_resolve_interface_method (const LinkInfo& link_info, TRAPS);
+  static Method* linktime_resolve_static_method    (const LinkInfo& link_info, TRAPS);
+  static Method* linktime_resolve_special_method   (const LinkInfo& link_info, TRAPS);
+  static Method* linktime_resolve_virtual_method   (const LinkInfo& link_info, TRAPS);
+  static Method* linktime_resolve_interface_method (const LinkInfo& link_info, TRAPS);
 
   static void runtime_resolve_special_method    (CallInfo& result,
                                                  const LinkInfo& link_info,
                                                  const methodHandle& resolved_method,
                                                  Handle recv, TRAPS);
@@ -282,13 +283,13 @@
     return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
   }
 
   // static resolving calls (will not run any Java code);
   // used only from Bytecode_invoke::static_target
-  static methodHandle resolve_method_statically(Bytecodes::Code code,
-                                                const constantPoolHandle& pool,
-                                                int index, TRAPS);
+  static Method* resolve_method_statically(Bytecodes::Code code,
+                                           const constantPoolHandle& pool,
+                                           int index, TRAPS);
 
   static void resolve_field_access(fieldDescriptor& result,
                                    const constantPoolHandle& pool,
                                    int index,
                                    const methodHandle& method,
@@ -310,32 +311,31 @@
   static void resolve_interface_call(CallInfo& result, Handle recv, Klass* recv_klass,
                                      const LinkInfo& link_info,
                                      bool check_null_and_abstract, TRAPS);
   static void resolve_handle_call   (CallInfo& result,
                                      const LinkInfo& link_info, TRAPS);
-  static void resolve_dynamic_call  (CallInfo& result, int pool_index, Handle bootstrap_specifier,
-                                     Symbol* method_name, Symbol* method_signature,
-                                     Klass* current_klass, TRAPS);
+  static void resolve_dynamic_call  (CallInfo& result,
+                                     BootstrapInfo& bootstrap_specifier, TRAPS);
 
   // same as above for compile-time resolution; but returns null handle instead of throwing
   // an exception on error also, does not initialize klass (i.e., no side effects)
-  static methodHandle resolve_virtual_call_or_null  (Klass* receiver_klass,
-                                                     const LinkInfo& link_info);
-  static methodHandle resolve_interface_call_or_null(Klass* receiver_klass,
-                                                     const LinkInfo& link_info);
-  static methodHandle resolve_static_call_or_null   (const LinkInfo& link_info);
-  static methodHandle resolve_special_call_or_null  (const LinkInfo& link_info);
+  static Method* resolve_virtual_call_or_null(Klass* receiver_klass,
+                                              const LinkInfo& link_info);
+  static Method* resolve_interface_call_or_null(Klass* receiver_klass,
+                                                const LinkInfo& link_info);
+  static Method* resolve_static_call_or_null(const LinkInfo& link_info);
+  static Method* resolve_special_call_or_null(const LinkInfo& link_info);
 
   static int vtable_index_of_interface_method(Klass* klass, const methodHandle& resolved_method);
 
   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
                                             const LinkInfo& link_info);
 
   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
-  static methodHandle linktime_resolve_virtual_method_or_null  (const LinkInfo& link_info);
-  static methodHandle linktime_resolve_interface_method_or_null(const LinkInfo& link_info);
+  static Method* linktime_resolve_virtual_method_or_null  (const LinkInfo& link_info);
+  static Method* linktime_resolve_interface_method_or_null(const LinkInfo& link_info);
 
   // runtime resolving from constant pool
   static void resolve_invoke(CallInfo& result, Handle recv,
                              const constantPoolHandle& pool, int index,
                              Bytecodes::Code byte, TRAPS);
@@ -346,15 +346,15 @@
                              Bytecodes::Code byte, TRAPS);
 
  public:
   // Only resolved method known.
   static void throw_abstract_method_error(const methodHandle& resolved_method, TRAPS) {
-    throw_abstract_method_error(resolved_method, NULL, NULL, CHECK);
+    throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);
   }
   // Resolved method and receiver klass know.
   static void throw_abstract_method_error(const methodHandle& resolved_method, Klass *recv_klass, TRAPS) {
-    throw_abstract_method_error(resolved_method, NULL, recv_klass, CHECK);
+    throw_abstract_method_error(resolved_method, methodHandle(), recv_klass, CHECK);
   }
   // Selected method is abstract.
   static void throw_abstract_method_error(const methodHandle& resolved_method,
                                           const methodHandle& selected_method,
                                           Klass *recv_klass, TRAPS);

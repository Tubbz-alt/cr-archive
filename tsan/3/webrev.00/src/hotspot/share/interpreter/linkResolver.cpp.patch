diff a/src/hotspot/share/interpreter/linkResolver.cpp b/src/hotspot/share/interpreter/linkResolver.cpp
--- a/src/hotspot/share/interpreter/linkResolver.cpp
+++ b/src/hotspot/share/interpreter/linkResolver.cpp
@@ -28,29 +28,29 @@
 #include "classfile/javaClasses.hpp"
 #include "classfile/resolutionErrors.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "compiler/compilationPolicy.hpp"
 #include "compiler/compileBroker.hpp"
 #include "gc/shared/collectedHeap.inline.hpp"
+#include "interpreter/bootstrapInfo.hpp"
 #include "interpreter/bytecode.hpp"
 #include "interpreter/interpreterRuntime.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/resourceArea.hpp"
-#include "memory/universe.hpp"
 #include "oops/constantPool.hpp"
 #include "oops/cpCache.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/method.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.hpp"
 #include "oops/oop.inline.hpp"
 #include "prims/methodHandles.hpp"
 #include "prims/nativeLookup.hpp"
-#include "runtime/compilationPolicy.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/reflection.hpp"
 #include "runtime/safepointVerifiers.hpp"
@@ -138,12 +138,12 @@
   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
     resolved_klass = resolved_method_holder;
   }
   _resolved_klass  = resolved_klass;
   _selected_klass  = resolved_klass;
-  _resolved_method = resolved_method;
-  _selected_method = resolved_method;
+  _resolved_method = methodHandle(THREAD, resolved_method);
+  _selected_method = methodHandle(THREAD, resolved_method);
   // classify:
   CallKind kind = CallInfo::unknown_kind;
   int index = resolved_method->vtable_index();
   if (resolved_method->can_be_statically_bound()) {
     kind = CallInfo::direct_call;
@@ -151,11 +151,11 @@
     // Could be an Object method inherited into an interface, but still a vtable call.
     kind = CallInfo::vtable_call;
   } else if (!resolved_klass->is_interface()) {
     // A default or miranda method.  Compute the vtable index.
     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
-                           resolved_method);
+                           _resolved_method);
     assert(index >= 0 , "we should have valid vtable index at this point");
 
     kind = CallInfo::vtable_call;
   } else if (resolved_method->has_vtable_index()) {
     // Can occur if an interface redeclares a method of Object.
@@ -187,13 +187,12 @@
 
   DEBUG_ONLY(verify());
 }
 
 void CallInfo::set_resolved_method_name(TRAPS) {
-  Method* m = _resolved_method();
-  assert(m != NULL, "Should already have a Method*");
-  oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);
+  assert(_resolved_method() != NULL, "Should already have a Method*");
+  oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(_resolved_method, CHECK);
   _resolved_method_name = Handle(THREAD, rmethod_name);
 }
 
 #ifdef ASSERT
 void CallInfo::verify() {
@@ -262,14 +261,10 @@
 
   // Coming from the constant pool always checks access
   _check_access  = true;
 }
 
-char* LinkInfo::method_string() const {
-  return Method::name_and_sig_as_C_string(_resolved_klass, _name, _signature);
-}
-
 #ifndef PRODUCT
 void LinkInfo::print() {
   ResourceMark rm;
   tty->print_cr("Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s",
                 _resolved_klass->name()->as_C_string(),
@@ -383,34 +378,34 @@
   return result;
 }
 
 // returns first instance method
 // Looks up method in classes, then looks up local default methods
-methodHandle LinkResolver::lookup_instance_method_in_klasses(Klass* klass,
-                                                             Symbol* name,
-                                                             Symbol* signature,
-                                                             Klass::PrivateLookupMode private_mode, TRAPS) {
+Method* LinkResolver::lookup_instance_method_in_klasses(Klass* klass,
+                                                        Symbol* name,
+                                                        Symbol* signature,
+                                                        Klass::PrivateLookupMode private_mode, TRAPS) {
   Method* result = klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 
   while (result != NULL && result->is_static() && result->method_holder()->super() != NULL) {
     Klass* super_klass = result->method_holder()->super();
     result = super_klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
   }
 
   if (klass->is_array_klass()) {
     // Only consider klass and super klass for arrays
-    return methodHandle(THREAD, result);
+    return result;
   }
 
   if (result == NULL) {
     Array<Method*>* default_methods = InstanceKlass::cast(klass)->default_methods();
     if (default_methods != NULL) {
       result = InstanceKlass::find_method(default_methods, name, signature);
       assert(result == NULL || !result->is_static(), "static defaults not allowed");
     }
   }
-  return methodHandle(THREAD, result);
+  return result;
 }
 
 int LinkResolver::vtable_index_of_interface_method(Klass* klass,
                                                    const methodHandle& resolved_method) {
 
@@ -443,14 +438,13 @@
   // interfaces.  Function lookup_method_in_klasses() already looked for
   // the method in the default methods table.
   return ik->lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 }
 
-methodHandle LinkResolver::lookup_polymorphic_method(
-                                             const LinkInfo& link_info,
-                                             Handle *appendix_result_or_null,
-                                             TRAPS) {
+Method* LinkResolver::lookup_polymorphic_method(const LinkInfo& link_info,
+                                                Handle *appendix_result_or_null,
+                                                TRAPS) {
   Klass* klass = link_info.resolved_klass();
   Symbol* name = link_info.name();
   Symbol* full_signature = link_info.signature();
 
   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
@@ -474,14 +468,14 @@
         tty->print_cr("lookup_polymorphic_method %s %s => basic %s",
                       name->as_C_string(),
                       full_signature->as_C_string(),
                       basic_signature->as_C_string());
       }
-      methodHandle result = SystemDictionary::find_method_handle_intrinsic(iid,
+      Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
                                                               basic_signature,
                                                               CHECK_NULL);
-      if (result.not_null()) {
+      if (result != NULL) {
         assert(result->is_method_handle_intrinsic(), "MH.invokeBasic or MH.linkTo* intrinsic");
         assert(result->intrinsic_id() != vmIntrinsics::_invokeGeneric, "wrong place to find this");
         assert(basic_signature == result->signature(), "predict the result signature");
         if (TraceMethodHandles) {
           ttyLocker ttyl;
@@ -507,11 +501,11 @@
         }
       }
 
       Handle appendix;
       Handle method_type;
-      methodHandle result = SystemDictionary::find_method_handle_invoker(
+      Method* result = SystemDictionary::find_method_handle_invoker(
                                                             klass,
                                                             name,
                                                             full_signature,
                                                             link_info.current_klass(),
                                                             &appendix,
@@ -522,11 +516,11 @@
         result->print_on(tty);
         tty->print("  lookup_polymorphic_method => appendix = ");
         if (appendix.is_null())  tty->print_cr("(none)");
         else                     appendix->print_on(tty);
       }
-      if (result.not_null()) {
+      if (result != NULL) {
 #ifdef ASSERT
         ResourceMark rm(THREAD);
 
         TempNewSymbol basic_signature =
           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
@@ -591,28 +585,26 @@
     ResourceMark rm(THREAD);
     bool same_module = (sel_klass->module() == ref_klass->module());
     Exceptions::fthrow(
       THREAD_AND_LOCATION,
       vmSymbols::java_lang_IllegalAccessError(),
-      "class %s tried to access %s%s%smethod %s.%s%s (%s%s%s)",
+      "class %s tried to access %s%s%smethod '%s' (%s%s%s)",
       ref_klass->external_name(),
       sel_method->is_abstract()  ? "abstract "  : "",
       sel_method->is_protected() ? "protected " : "",
       sel_method->is_private()   ? "private "   : "",
-      sel_klass->external_name(),
-      sel_method->name()->as_C_string(),
-      sel_method->signature()->as_C_string(),
+      sel_method->external_name(),
       (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),
       (same_module) ? "" : "; ",
       (same_module) ? "" : sel_klass->class_in_module_of_loader()
     );
     return;
   }
 }
 
-methodHandle LinkResolver::resolve_method_statically(Bytecodes::Code code,
-                                                     const constantPoolHandle& pool, int index, TRAPS) {
+Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
+                                                const constantPoolHandle& pool, int index, TRAPS) {
   // This method is used only
   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
   // and
   // (2) in Bytecode_invoke::static_target
   // It appears to fail when applied to an invokeinterface call site.
@@ -633,11 +625,11 @@
   if (pool->has_preresolution()
       || (resolved_klass == SystemDictionary::MethodHandle_klass() &&
           MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
     Method* result = ConstantPool::method_at_if_loaded(pool, index);
     if (result != NULL) {
-      return methodHandle(THREAD, result);
+      return result;
     }
   }
 
   if (code == Bytecodes::_invokeinterface) {
     return resolve_interface_method(link_info, code, THREAD);
@@ -668,16 +660,15 @@
     Klass* resolved_method_class = resolved_method->method_holder();
     ClassLoaderData* target_loader_data = resolved_method_class->class_loader_data();
     assert(target_loader_data != NULL, "resolved method's class has no class loader data");
 
     stringStream ss;
-    ss.print("loader constraint violation: when resolving %s"
-             " \"%s\" the class loader %s of the current class, %s,"
+    ss.print("loader constraint violation: when resolving %s '", method_type);
+    Method::print_external_name(&ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
+    ss.print("' the class loader %s of the current class, %s,"
              " and the class loader %s for the method's defining class, %s, have"
              " different Class objects for the type %s used in the signature (%s; %s)",
-             method_type,
-             link_info.method_string(),
              current_loader_data->loader_name_and_id(),
              current_class->name()->as_C_string(),
              target_loader_data->loader_name_and_id(),
              resolved_method_class->name()->as_C_string(),
              failed_type_symbol->as_C_string(),
@@ -719,12 +710,12 @@
              sel_klass->class_in_module_of_loader(false, true));
     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
   }
 }
 
-methodHandle LinkResolver::resolve_method(const LinkInfo& link_info,
-                                          Bytecodes::Code code, TRAPS) {
+Method* LinkResolver::resolve_method(const LinkInfo& link_info,
+                                     Bytecodes::Code code, TRAPS) {
 
   Handle nested_exception;
   Klass* resolved_klass = link_info.resolved_klass();
 
   // 1. For invokevirtual, cannot call an interface method
@@ -737,13 +728,15 @@
   }
 
   // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
   if (!link_info.tag().is_invalid() && !link_info.tag().is_method()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Method %s must be Methodref constant", link_info.method_string());
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Method '");
+    Method::print_external_name(&ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
+    ss.print("' must be Methodref constant");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   // 3. lookup method in resolved klass and its super klasses
   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
 
@@ -751,26 +744,28 @@
   if (resolved_method.is_null() && !resolved_klass->is_array_klass()) { // not found in the class hierarchy
     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 
     if (resolved_method.is_null()) {
       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
-      resolved_method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);
+      Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);
+      resolved_method = methodHandle(THREAD, method);
       if (HAS_PENDING_EXCEPTION) {
         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
         CLEAR_PENDING_EXCEPTION;
       }
     }
   }
 
   // 5. method lookup failed
   if (resolved_method.is_null()) {
     ResourceMark rm(THREAD);
+    stringStream ss;
+    ss.print("'");
+    Method::print_external_name(&ss, resolved_klass, link_info.name(), link_info.signature());
+    ss.print("'");
     THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
-                    Method::name_and_sig_as_C_string(resolved_klass,
-                                                     link_info.name(),
-                                                     link_info.signature()),
-                    nested_exception, NULL);
+                     ss.as_string(), nested_exception, NULL);
   }
 
   // 6. access checks, access checking may be turned off when calling from within the VM.
   Klass* current_klass = link_info.current_klass();
   if (link_info.check_access()) {
@@ -785,17 +780,17 @@
 
     // check loader constraints
     check_method_loader_constraints(link_info, resolved_method, "method", CHECK_NULL);
   }
 
-  return resolved_method;
+  return resolved_method();
 }
 
 static void trace_method_resolution(const char* prefix,
                                     Klass* klass,
                                     Klass* resolved_klass,
-                                    const methodHandle& method,
+                                    Method* method,
                                     bool logitables,
                                     int index = -1) {
 #ifndef PRODUCT
   ResourceMark rm;
   Log(itables) logi;
@@ -823,11 +818,11 @@
   st->cr();
 #endif // PRODUCT
 }
 
 // Do linktime resolution of a method in the interface within the context of the specied bytecode.
-methodHandle LinkResolver::resolve_interface_method(const LinkInfo& link_info, Bytecodes::Code code, TRAPS) {
+Method* LinkResolver::resolve_interface_method(const LinkInfo& link_info, Bytecodes::Code code, TRAPS) {
 
   Klass* resolved_klass = link_info.resolved_klass();
 
   // check if klass is interface
   if (!resolved_klass->is_interface()) {
@@ -838,13 +833,15 @@
   }
 
   // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
   if (!link_info.tag().is_invalid() && !link_info.tag().is_interface_method()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Method %s must be InterfaceMethodref constant", link_info.method_string());
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Method '");
+    Method::print_external_name(&ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
+    ss.print("' must be InterfaceMethodref constant");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   // lookup method in this interface or its super, java.lang.Object
   // JDK8: also look for static methods
   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
@@ -855,14 +852,15 @@
   }
 
   if (resolved_method.is_null()) {
     // no method found
     ResourceMark rm(THREAD);
-    THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(),
-                   Method::name_and_sig_as_C_string(resolved_klass,
-                                                    link_info.name(),
-                                                    link_info.signature()));
+    stringStream ss;
+    ss.print("'");
+    Method::print_external_name(&ss, resolved_klass, link_info.name(), link_info.signature());
+    ss.print("'");
+    THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
   }
 
   if (link_info.check_access()) {
     // JDK8 adds non-public interface methods, and accessability check requirement
     Klass* current_klass = link_info.current_klass();
@@ -879,26 +877,26 @@
     check_method_loader_constraints(link_info, resolved_method, "interface method", CHECK_NULL);
   }
 
   if (code != Bytecodes::_invokestatic && resolved_method->is_static()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Expected instance not static method %s",
-                 Method::name_and_sig_as_C_string(resolved_klass,
-                 resolved_method->name(), resolved_method->signature()));
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Expected instance not static method '");
+    Method::print_external_name(&ss, resolved_klass,
+                                resolved_method->name(), resolved_method->signature());
+    ss.print("'");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   if (log_develop_is_enabled(Trace, itables)) {
     char buf[200];
     jio_snprintf(buf, sizeof(buf), "%s resolved interface method: caller-class:",
                  Bytecodes::name(code));
-    trace_method_resolution(buf, link_info.current_klass(), resolved_klass,
-                            resolved_method, true);
+    trace_method_resolution(buf, link_info.current_klass(), resolved_klass, resolved_method(), true);
   }
 
-  return resolved_method;
+  return resolved_method();
 }
 
 //------------------------------------------------------------------------------------------------------------------------
 // Field resolution
 
@@ -997,23 +995,23 @@
                 current_klass->external_name());
         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
       }
 
       if (fd.constants()->pool_holder()->major_version() >= 53) {
-        methodHandle m = link_info.current_method();
-        assert(!m.is_null(), "information about the current method must be available for 'put' bytecodes");
+        Method* m = link_info.current_method();
+        assert(m != NULL, "information about the current method must be available for 'put' bytecodes");
         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &&
                                                    fd.is_static() &&
-                                                   !m()->is_static_initializer());
+                                                   !m->is_static_initializer());
         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &&
                                                      !fd.is_static() &&
                                                      !m->is_object_initializer());
 
         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
           ss.print("Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s ",
                    is_static ? "static" : "non-static", resolved_klass->external_name(), fd.name()->as_C_string(),
-                   m()->name()->as_C_string(),
+                   m->name()->as_C_string(),
                    is_static ? "<clinit>" : "<init>");
           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
         }
       }
     }
@@ -1050,11 +1048,11 @@
 
 
 void LinkResolver::resolve_static_call(CallInfo& result,
                                        const LinkInfo& link_info,
                                        bool initialize_class, TRAPS) {
-  methodHandle resolved_method = linktime_resolve_static_method(link_info, CHECK);
+  Method* resolved_method = linktime_resolve_static_method(link_info, CHECK);
 
   // The resolved class can change as a result of this resolution.
   Klass* resolved_klass = resolved_method->method_holder();
 
   // Initialize klass (this should only happen if everything is ok)
@@ -1066,58 +1064,57 @@
                       link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
     resolved_method = linktime_resolve_static_method(new_info, CHECK);
   }
 
   // setup result
-  result.set_static(resolved_klass, resolved_method, CHECK);
+  result.set_static(resolved_klass, methodHandle(THREAD, resolved_method), CHECK);
 }
 
 // throws linktime exceptions
-methodHandle LinkResolver::linktime_resolve_static_method(const LinkInfo& link_info, TRAPS) {
+Method* LinkResolver::linktime_resolve_static_method(const LinkInfo& link_info, TRAPS) {
 
   Klass* resolved_klass = link_info.resolved_klass();
-  methodHandle resolved_method;
+  Method* resolved_method;
   if (!resolved_klass->is_interface()) {
     resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
   } else {
     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
   }
   assert(resolved_method->name() != vmSymbols::class_initializer_name(), "should have been checked in verifier");
 
   // check if static
   if (!resolved_method->is_static()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Expected static method %s", Method::name_and_sig_as_C_string(resolved_klass,
-                                                      resolved_method->name(),
-                                                      resolved_method->signature()));
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Expected static method '");
+    resolved_method->print_external_name(&ss);
+    ss.print("'");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
   return resolved_method;
 }
 
 
 void LinkResolver::resolve_special_call(CallInfo& result,
                                         Handle recv,
                                         const LinkInfo& link_info,
                                         TRAPS) {
-  methodHandle resolved_method = linktime_resolve_special_method(link_info, CHECK);
-  runtime_resolve_special_method(result, link_info, resolved_method, recv, CHECK);
+  Method* resolved_method = linktime_resolve_special_method(link_info, CHECK);
+  runtime_resolve_special_method(result, link_info, methodHandle(THREAD, resolved_method), recv, CHECK);
 }
 
 // throws linktime exceptions
-methodHandle LinkResolver::linktime_resolve_special_method(const LinkInfo& link_info,
-                                                           TRAPS) {
+Method* LinkResolver::linktime_resolve_special_method(const LinkInfo& link_info, TRAPS) {
 
   // Invokespecial is called for multiple special reasons:
   // <init>
   // local private method invocation, for classes and interfaces
   // superclass.method, which can also resolve to a default method
   // and the selected method is recalculated relative to the direct superclass
   // superinterface.method, which explicitly does not check shadowing
   Klass* resolved_klass = link_info.resolved_klass();
-  methodHandle resolved_method;
+  Method* resolved_method;
 
   if (!resolved_klass->is_interface()) {
     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
   } else {
     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
@@ -1125,18 +1122,20 @@
 
   // check if method name is <init>, that it is found in same klass as static type
   if (resolved_method->name() == vmSymbols::object_initializer_name() &&
       resolved_method->method_holder() != resolved_klass) {
     ResourceMark rm(THREAD);
+    stringStream ss;
+    ss.print("%s: method '", resolved_klass->external_name());
+    resolved_method->signature()->print_as_signature_external_return_type(&ss);
+    ss.print(" %s(", resolved_method->name()->as_C_string());
+    resolved_method->signature()->print_as_signature_external_parameters(&ss);
+    ss.print(")' not found");
     Exceptions::fthrow(
       THREAD_AND_LOCATION,
       vmSymbols::java_lang_NoSuchMethodError(),
-      "%s: method %s%s not found",
-      resolved_klass->external_name(),
-      resolved_method->name()->as_C_string(),
-      resolved_method->signature()->as_C_string()
-    );
+      "%s", ss.as_string());
     return NULL;
   }
 
   // ensure that invokespecial's interface method reference is in
   // a direct superinterface, not an indirect superinterface
@@ -1151,31 +1150,27 @@
                         SystemDictionary::reflect_MagicAccessorImpl_klass());
 
     if (!is_reflect &&
         !klass_to_check->is_same_or_direct_interface(resolved_klass)) {
       ResourceMark rm(THREAD);
-      char buf[200];
-      jio_snprintf(buf, sizeof(buf),
-                   "Interface method reference: %s, is in an indirect superinterface of %s",
-                   Method::name_and_sig_as_C_string(resolved_klass,
-                                                                           resolved_method->name(),
-                                                                           resolved_method->signature()),
-                   current_klass->external_name());
-      THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+      stringStream ss;
+      ss.print("Interface method reference: '");
+      resolved_method->print_external_name(&ss);
+      ss.print("', is in an indirect superinterface of %s",
+               current_klass->external_name());
+      THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
     }
   }
 
   // check if not static
   if (resolved_method->is_static()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf),
-                 "Expecting non-static method %s",
-                 Method::name_and_sig_as_C_string(resolved_klass,
-                                                  resolved_method->name(),
-                                                  resolved_method->signature()));
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Expecting non-static method '");
+    resolved_method->print_external_name(&ss);
+    ss.print("'");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   if (log_develop_is_enabled(Trace, itables)) {
     trace_method_resolution("invokespecial resolved method: caller-class:",
                             current_klass, resolved_klass, resolved_method, true);
@@ -1210,21 +1205,24 @@
     // in super interfaces.
     if (current_klass->is_subclass_of(resolved_klass) &&
         current_klass != resolved_klass) {
       // Lookup super method
       Klass* super_klass = current_klass->super();
-      sel_method = lookup_instance_method_in_klasses(super_klass,
+      Method* instance_method = lookup_instance_method_in_klasses(super_klass,
                                                      resolved_method->name(),
                                                      resolved_method->signature(),
                                                      Klass::find_private, CHECK);
+      sel_method = methodHandle(THREAD, instance_method);
+
       // check if found
       if (sel_method.is_null()) {
         ResourceMark rm(THREAD);
-        THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
-                  Method::name_and_sig_as_C_string(resolved_klass,
-                                            resolved_method->name(),
-                                            resolved_method->signature()));
+        stringStream ss;
+        ss.print("'");
+        resolved_method->print_external_name(&ss);
+        ss.print("'");
+        THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
       // check loader constraints if found a different method
       } else if (sel_method() != resolved_method()) {
         check_method_loader_constraints(link_info, sel_method, "method", CHECK);
       }
     }
@@ -1242,60 +1240,61 @@
       if (!receiver_klass->is_subtype_of(sender)) {
         ResourceMark rm(THREAD);
         char buf[500];
         jio_snprintf(buf, sizeof(buf),
                      "Receiver class %s must be the current class or a subtype of interface %s",
-                     receiver_klass->name()->as_C_string(),
-                     sender->name()->as_C_string());
+                     receiver_klass->external_name(),
+                     sender->external_name());
         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
       }
     }
   }
 
   // check if not static
   if (sel_method->is_static()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Expecting non-static method %s", Method::name_and_sig_as_C_string(resolved_klass,
-                                                                                      resolved_method->name(),
-                                                                                      resolved_method->signature()));
-    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Expecting non-static method '");
+    resolved_method->print_external_name(&ss);
+    ss.print("'");
+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   // check if abstract
   if (sel_method->is_abstract()) {
     ResourceMark rm(THREAD);
-    THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
-              Method::name_and_sig_as_C_string(resolved_klass,
-                                               sel_method->name(),
-                                               sel_method->signature()));
+    stringStream ss;
+    ss.print("'");
+    Method::print_external_name(&ss, resolved_klass, sel_method->name(), sel_method->signature());
+    ss.print("'");
+    THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
   }
 
   if (log_develop_is_enabled(Trace, itables)) {
     trace_method_resolution("invokespecial selected method: resolved-class:",
-                            resolved_klass, resolved_klass, sel_method, true);
+                            resolved_klass, resolved_klass, sel_method(), true);
   }
 
   // setup result
   result.set_static(resolved_klass, sel_method, CHECK);
 }
 
 void LinkResolver::resolve_virtual_call(CallInfo& result, Handle recv, Klass* receiver_klass,
                                         const LinkInfo& link_info,
                                         bool check_null_and_abstract, TRAPS) {
-  methodHandle resolved_method = linktime_resolve_virtual_method(link_info, CHECK);
-  runtime_resolve_virtual_method(result, resolved_method,
+  Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);
+  runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),
                                  link_info.resolved_klass(),
                                  recv, receiver_klass,
                                  check_null_and_abstract, CHECK);
 }
 
 // throws linktime exceptions
-methodHandle LinkResolver::linktime_resolve_virtual_method(const LinkInfo& link_info,
+Method* LinkResolver::linktime_resolve_virtual_method(const LinkInfo& link_info,
                                                            TRAPS) {
   // normal method resolution
-  methodHandle resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);
+  Method* resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);
 
   assert(resolved_method->name() != vmSymbols::object_initializer_name(), "should have been checked in verifier");
   assert(resolved_method->name() != vmSymbols::class_initializer_name (), "should have been checked in verifier");
 
   // check if private interface method
@@ -1303,27 +1302,26 @@
   Klass* current_klass = link_info.current_klass();
 
   // This is impossible, if resolve_klass is an interface, we've thrown icce in resolve_method
   if (resolved_klass->is_interface() && resolved_method->is_private()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "private interface method requires invokespecial, not invokevirtual: method %s, caller-class:%s",
-                 Method::name_and_sig_as_C_string(resolved_klass,
-                                                  resolved_method->name(),
-                                                  resolved_method->signature()),
-                   (current_klass == NULL ? "<NULL>" : current_klass->internal_name()));
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("private interface method requires invokespecial, not invokevirtual: method '");
+    resolved_method->print_external_name(&ss);
+    ss.print("', caller-class: %s",
+             (current_klass == NULL ? "<null>" : current_klass->internal_name()));
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   // check if not static
   if (resolved_method->is_static()) {
     ResourceMark rm(THREAD);
-    char buf[200];
-    jio_snprintf(buf, sizeof(buf), "Expecting non-static method %s", Method::name_and_sig_as_C_string(resolved_klass,
-                                                                                           resolved_method->name(),
-                                                                                           resolved_method->signature()));
-    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
+    stringStream ss;
+    ss.print("Expecting non-static method '");
+    resolved_method->print_external_name(&ss);
+    ss.print("'");
+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
   }
 
   if (log_develop_is_enabled(Trace, vtables)) {
     trace_method_resolution("invokevirtual resolved method: caller-class:",
                             current_klass, resolved_klass, resolved_method, false);
@@ -1391,30 +1389,31 @@
     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
   }
 
   if (log_develop_is_enabled(Trace, vtables)) {
     trace_method_resolution("invokevirtual selected method: receiver-class:",
-                            recv_klass, resolved_klass, selected_method,
+                            recv_klass, resolved_klass, selected_method(),
                             false, vtable_index);
   }
   // setup result
   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
 }
 
 void LinkResolver::resolve_interface_call(CallInfo& result, Handle recv, Klass* recv_klass,
                                           const LinkInfo& link_info,
                                           bool check_null_and_abstract, TRAPS) {
   // throws linktime exceptions
-  methodHandle resolved_method = linktime_resolve_interface_method(link_info, CHECK);
-  runtime_resolve_interface_method(result, resolved_method,link_info.resolved_klass(),
+  Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
+  methodHandle mh(THREAD, resolved_method);
+  runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
                                    recv, recv_klass, check_null_and_abstract, CHECK);
 }
 
-methodHandle LinkResolver::linktime_resolve_interface_method(const LinkInfo& link_info,
+Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo& link_info,
                                                              TRAPS) {
   // normal interface method resolution
-  methodHandle resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
+  Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
   assert(resolved_method->name() != vmSymbols::object_initializer_name(), "should have been checked in verifier");
   assert(resolved_method->name() != vmSymbols::class_initializer_name (), "should have been checked in verifier");
 
   return resolved_method;
 }
@@ -1448,14 +1447,15 @@
   if (!resolved_method()->is_private()) {
     // do lookup based on receiver klass
     // This search must match the linktime preparation search for itable initialization
     // to correctly enforce loader constraints for interface method inheritance.
     // Private methods are skipped as the resolved method was not private.
-    selected_method = lookup_instance_method_in_klasses(recv_klass,
-                                                        resolved_method->name(),
-                                                        resolved_method->signature(),
-                                                        Klass::skip_private, CHECK);
+    Method* method = lookup_instance_method_in_klasses(recv_klass,
+                                                       resolved_method->name(),
+                                                       resolved_method->signature(),
+                                                       Klass::skip_private, CHECK);
+    selected_method = methodHandle(THREAD, method);
 
     if (selected_method.is_null() && !check_null_and_abstract) {
       // In theory this is a harmless placeholder value, but
       // in practice leaving in null affects the nsk default method tests.
       // This needs further study.
@@ -1468,24 +1468,25 @@
     }
     // check access
     // Throw Illegal Access Error if selected_method is not public.
     if (!selected_method->is_public()) {
       ResourceMark rm(THREAD);
-      THROW_MSG(vmSymbols::java_lang_IllegalAccessError(),
-                Method::name_and_sig_as_C_string(recv_klass,
-                                                 selected_method->name(),
-                                                 selected_method->signature()));
+      stringStream ss;
+      ss.print("'");
+      Method::print_external_name(&ss, recv_klass, selected_method->name(), selected_method->signature());
+      ss.print("'");
+      THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
     }
     // check if abstract
     if (check_null_and_abstract && selected_method->is_abstract()) {
       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
     }
   }
 
   if (log_develop_is_enabled(Trace, itables)) {
     trace_method_resolution("invokeinterface selected method: receiver-class:",
-                            recv_klass, resolved_klass, selected_method, true);
+                            recv_klass, resolved_klass, selected_method(), true);
   }
   // setup result
   if (resolved_method->has_vtable_index()) {
     int vtable_index = resolved_method->vtable_index();
     log_develop_trace(itables)("  -- vtable index: %d", vtable_index);
@@ -1507,56 +1508,56 @@
     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);
   }
 }
 
 
-methodHandle LinkResolver::linktime_resolve_interface_method_or_null(
+Method* LinkResolver::linktime_resolve_interface_method_or_null(
                                                  const LinkInfo& link_info) {
   EXCEPTION_MARK;
-  methodHandle method_result = linktime_resolve_interface_method(link_info, THREAD);
+  Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   } else {
     return method_result;
   }
 }
 
-methodHandle LinkResolver::linktime_resolve_virtual_method_or_null(
+Method* LinkResolver::linktime_resolve_virtual_method_or_null(
                                                  const LinkInfo& link_info) {
   EXCEPTION_MARK;
-  methodHandle method_result = linktime_resolve_virtual_method(link_info, THREAD);
+  Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   } else {
     return method_result;
   }
 }
 
-methodHandle LinkResolver::resolve_virtual_call_or_null(
+Method* LinkResolver::resolve_virtual_call_or_null(
                                                  Klass* receiver_klass,
                                                  const LinkInfo& link_info) {
   EXCEPTION_MARK;
   CallInfo info;
   resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   }
   return info.selected_method();
 }
 
-methodHandle LinkResolver::resolve_interface_call_or_null(
+Method* LinkResolver::resolve_interface_call_or_null(
                                                  Klass* receiver_klass,
                                                  const LinkInfo& link_info) {
   EXCEPTION_MARK;
   CallInfo info;
   resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   }
   return info.selected_method();
 }
 
 int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
@@ -1570,28 +1571,28 @@
     return Method::invalid_vtable_index;
   }
   return info.vtable_index();
 }
 
-methodHandle LinkResolver::resolve_static_call_or_null(const LinkInfo& link_info) {
+Method* LinkResolver::resolve_static_call_or_null(const LinkInfo& link_info) {
   EXCEPTION_MARK;
   CallInfo info;
   resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   }
   return info.selected_method();
 }
 
-methodHandle LinkResolver::resolve_special_call_or_null(const LinkInfo& link_info) {
+Method* LinkResolver::resolve_special_call_or_null(const LinkInfo& link_info) {
   EXCEPTION_MARK;
   CallInfo info;
   resolve_special_call(info, Handle(), link_info, THREAD);
   if (HAS_PENDING_EXCEPTION) {
     CLEAR_PENDING_EXCEPTION;
-    return methodHandle();
+    return NULL;
   }
   return info.selected_method();
 }
 
 
@@ -1688,107 +1689,88 @@
   Klass* resolved_klass = link_info.resolved_klass();
   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
          resolved_klass == SystemDictionary::VarHandle_klass(), "");
   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), "");
   Handle       resolved_appendix;
-  methodHandle resolved_method = lookup_polymorphic_method(link_info, &resolved_appendix, CHECK);
-  result.set_handle(resolved_klass, resolved_method, resolved_appendix, CHECK);
+  Method* resolved_method = lookup_polymorphic_method(link_info, &resolved_appendix, CHECK);
+  result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
 }
 
-void LinkResolver::resolve_invokedynamic(CallInfo& result, const constantPoolHandle& pool, int index, TRAPS) {
-  Symbol* method_name       = pool->name_ref_at(index);
-  Symbol* method_signature  = pool->signature_ref_at(index);
-  Klass* current_klass = pool->pool_holder();
-
-  // Resolve the bootstrap specifier (BSM + optional arguments).
-  Handle bootstrap_specifier;
-  // Check if CallSite has been bound already:
-  ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(index);
+void LinkResolver::resolve_invokedynamic(CallInfo& result, const constantPoolHandle& pool, int indy_index, TRAPS) {
+  ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(indy_index);
   int pool_index = cpce->constant_pool_index();
 
-  if (cpce->is_f1_null()) {
-    if (cpce->indy_resolution_failed()) {
-      ConstantPool::throw_resolution_error(pool,
-                                           ResolutionErrorTable::encode_cpcache_index(index),
-                                           CHECK);
-    }
+  // Resolve the bootstrap specifier (BSM + optional arguments).
+  BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
 
-    // The initial step in Call Site Specifier Resolution is to resolve the symbolic
-    // reference to a method handle which will be the bootstrap method for a dynamic
-    // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
-    // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
-    // method's CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
-    // set the indy_rf flag since any subsequent invokedynamic instruction which shares
-    // this bootstrap method will encounter the resolution of MethodHandleInError.
-    oop bsm_info = pool->resolve_bootstrap_specifier_at(pool_index, THREAD);
-    Exceptions::wrap_dynamic_exception(CHECK);
-    assert(bsm_info != NULL, "");
-    // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_InvokeDynamic.
-    bootstrap_specifier = Handle(THREAD, bsm_info);
-  }
-  if (!cpce->is_f1_null()) {
-    methodHandle method(     THREAD, cpce->f1_as_method());
-    Handle       appendix(   THREAD, cpce->appendix_if_resolved(pool));
-    result.set_handle(method, appendix, THREAD);
-    Exceptions::wrap_dynamic_exception(CHECK);
-    return;
+  // Check if CallSite has been bound already or failed already, and short circuit:
+  {
+    bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
+    if (is_done) return;
   }
 
+  // The initial step in Call Site Specifier Resolution is to resolve the symbolic
+  // reference to a method handle which will be the bootstrap method for a dynamic
+  // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
+  // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
+  // method's CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
+  // set the indy_rf flag since any subsequent invokedynamic instruction which shares
+  // this bootstrap method will encounter the resolution of MethodHandleInError.
+
+  resolve_dynamic_call(result, bootstrap_specifier, CHECK);
+
   if (TraceMethodHandles) {
-    ResourceMark rm(THREAD);
-    tty->print_cr("resolve_invokedynamic #%d %s %s in %s",
-                  ConstantPool::decode_invokedynamic_index(index),
-                  method_name->as_C_string(), method_signature->as_C_string(),
-                  current_klass->name()->as_C_string());
-    tty->print("  BSM info: "); bootstrap_specifier->print();
-  }
-
-  resolve_dynamic_call(result, pool_index, bootstrap_specifier, method_name,
-                       method_signature, current_klass, THREAD);
-  if (HAS_PENDING_EXCEPTION && PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass())) {
-    int encoded_index = ResolutionErrorTable::encode_cpcache_index(index);
-    bool recorded_res_status = cpce->save_and_throw_indy_exc(pool, pool_index,
-                                                             encoded_index,
-                                                             pool()->tag_at(pool_index),
-                                                             CHECK);
-    if (!recorded_res_status) {
-      // Another thread got here just before we did.  So, either use the method
-      // that it resolved or throw the LinkageError exception that it threw.
-      if (!cpce->is_f1_null()) {
-        methodHandle method(     THREAD, cpce->f1_as_method());
-        Handle       appendix(   THREAD, cpce->appendix_if_resolved(pool));
-        result.set_handle(method, appendix, THREAD);
-        Exceptions::wrap_dynamic_exception(CHECK);
-      } else {
-        assert(cpce->indy_resolution_failed(), "Resolution failure flag not set");
-        ConstantPool::throw_resolution_error(pool, encoded_index, CHECK);
-      }
-      return;
-    }
-    assert(cpce->indy_resolution_failed(), "Resolution failure flag wasn't set");
+    bootstrap_specifier.print_msg_on(tty, "resolve_invokedynamic");
   }
+
+  // The returned linkage result is provisional up to the moment
+  // the interpreter or runtime performs a serialized check of
+  // the relevant CPCE::f1 field.  This is done by the caller
+  // of this method, via CPCE::set_dynamic_call, which uses
+  // an ObjectLocker to do the final serialization of updates
+  // to CPCE state, including f1.
 }
 
 void LinkResolver::resolve_dynamic_call(CallInfo& result,
-                                        int pool_index,
-                                        Handle bootstrap_specifier,
-                                        Symbol* method_name, Symbol* method_signature,
-                                        Klass* current_klass,
+                                        BootstrapInfo& bootstrap_specifier,
                                         TRAPS) {
-  // JSR 292:  this must resolve to an implicitly generated method MH.linkToCallSite(*...)
+  // JSR 292:  this must resolve to an implicitly generated method
+  // such as MH.linkToCallSite(*...) or some other call-site shape.
   // The appendix argument is likely to be a freshly-created CallSite.
-  Handle       resolved_appendix;
-  methodHandle resolved_method =
-    SystemDictionary::find_dynamic_call_site_invoker(current_klass,
-                                                     pool_index,
-                                                     bootstrap_specifier,
-                                                     method_name, method_signature,
-                                                     &resolved_appendix,
-                                                     THREAD);
-  Exceptions::wrap_dynamic_exception(CHECK);
-  result.set_handle(resolved_method, resolved_appendix, THREAD);
-  Exceptions::wrap_dynamic_exception(CHECK);
+  // It may also be a MethodHandle from an unwrapped ConstantCallSite,
+  // or any other reference.  The resolved_method as well as the appendix
+  // are both recorded together via CallInfo::set_handle.
+  SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
+  Exceptions::wrap_dynamic_exception(THREAD);
+
+  if (HAS_PENDING_EXCEPTION) {
+    if (!PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass())) {
+      // Let any random low-level IE or SOE or OOME just bleed through.
+      // Basically we pretend that the bootstrap method was never called,
+      // if it fails this way:  We neither record a successful linkage,
+      // nor do we memorize a LE for posterity.
+      return;
+    }
+    // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
+    // a symbolic reference fails because an error is thrown that is an
+    // instance of LinkageError (or a subclass), then subsequent attempts to
+    // resolve the reference always fail with the same error that was thrown
+    // as a result of the initial resolution attempt.
+     bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
+     if (!recorded_res_status) {
+       // Another thread got here just before we did.  So, either use the method
+       // that it resolved or throw the LinkageError exception that it threw.
+       bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
+       if (is_done) return;
+     }
+     assert(bootstrap_specifier.invokedynamic_cp_cache_entry()->indy_resolution_failed(),
+            "Resolution failure flag wasn't set");
+  }
+
+  bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);
+  // Exceptions::wrap_dynamic_exception not used because
+  // set_handle doesn't throw linkage errors
 }
 
 // Selected method is abstract.
 void LinkResolver::throw_abstract_method_error(const methodHandle& resolved_method,
                                                const methodHandle& selected_method,
@@ -1804,22 +1786,25 @@
   } else {
     ss.print("Missing implementation of");
   }
 
   assert(resolved_method.not_null(), "Sanity");
-  ss.print(" resolved method %s%s%s%s of %s %s.",
+  ss.print(" resolved method '%s%s",
            resolved_method->is_abstract() ? "abstract " : "",
-           resolved_method->is_private()  ? "private "  : "",
-           resolved_method->name()->as_C_string(),
-           resolved_method->signature()->as_C_string(),
+           resolved_method->is_private()  ? "private "  : "");
+  resolved_method->signature()->print_as_signature_external_return_type(&ss);
+  ss.print(" %s(", resolved_method->name()->as_C_string());
+  resolved_method->signature()->print_as_signature_external_parameters(&ss);
+  ss.print(")' of %s %s.",
            resolved_klass->external_kind(),
            resolved_klass->external_name());
 
   if (selected_method.not_null() && !(resolved_method == selected_method)) {
-    ss.print(" Selected method is %s%s%s.",
+    ss.print(" Selected method is '%s%s",
              selected_method->is_abstract() ? "abstract " : "",
-             selected_method->is_private()  ? "private "  : "",
-             selected_method->name_and_sig_as_C_string());
+             selected_method->is_private()  ? "private "  : "");
+    selected_method->print_external_name(&ss);
+    ss.print("'.");
   }
 
   THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
 }

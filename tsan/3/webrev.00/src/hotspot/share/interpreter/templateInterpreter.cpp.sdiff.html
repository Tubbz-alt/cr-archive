<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/templateInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rewriter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jfr/dcmd/jfrDcmds.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/templateInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/templateInterpreter.hpp&quot;
 30 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
 31 #include &quot;interpreter/templateTable.hpp&quot;

 32 #include &quot;memory/resourceArea.hpp&quot;

 33 #include &quot;runtime/timerTrace.hpp&quot;

 34 
 35 #ifndef CC_INTERP
 36 
 37 # define __ _masm-&gt;
 38 
 39 void TemplateInterpreter::initialize() {
 40   if (_code != NULL) return;
 41   // assertions
 42   assert((int)Bytecodes::number_of_codes &lt;= (int)DispatchTable::length,
 43          &quot;dispatch table too small&quot;);
 44 
 45   AbstractInterpreter::initialize();
 46 
 47   TemplateTable::initialize();
 48 
 49   // generate interpreter
 50   { ResourceMark rm;
 51     TraceTime timer(&quot;Interpreter generation&quot;, TRACETIME_LOG(Info, startuptime));
 52     int code_size = InterpreterCodeSize;
 53     NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space
</pre>
<hr />
<pre>
257 
258 
259 address TemplateInterpreter::deopt_entry(TosState state, int length) {
260   guarantee(0 &lt;= length &amp;&amp; length &lt; Interpreter::number_of_deopt_entries, &quot;illegal length&quot;);
261   address entry = _deopt_entry[length].entry(state);
262   vmassert(entry != NULL, &quot;unsupported deopt entry requested, length=%d state=%d&quot;, length, TosState_as_index(state));
263   return entry;
264 }
265 
266 //------------------------------------------------------------------------------------------------------------------------
267 // Suport for invokes
268 
269 int TemplateInterpreter::TosState_as_index(TosState state) {
270   assert( state &lt; number_of_states , &quot;Invalid state in TosState_as_index&quot;);
271   assert(0 &lt;= (int)state &amp;&amp; (int)state &lt; TemplateInterpreter::number_of_return_addrs, &quot;index out of bounds&quot;);
272   return (int)state;
273 }
274 
275 
276 //------------------------------------------------------------------------------------------------------------------------
<span class="line-modified">277 // Safepoint suppport</span>
278 
279 static inline void copy_table(address* from, address* to, int size) {
<span class="line-modified">280   // Copy non-overlapping tables. The copy has to occur word wise for MT safety.</span>
<span class="line-modified">281   while (size-- &gt; 0) *to++ = *from++;</span>






282 }
283 
284 void TemplateInterpreter::notice_safepoints() {
285   if (!_notice_safepoints) {

286     // switch to safepoint dispatch table
287     _notice_safepoints = true;
288     copy_table((address*)&amp;_safept_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));



289   }
290 }
291 
292 // switch from the dispatch table which notices safepoints back to the
293 // normal dispatch table.  So that we can notice single stepping points,
294 // keep the safepoint dispatch table if we are single stepping in JVMTI.
295 // Note that the should_post_single_step test is exactly as fast as the
296 // JvmtiExport::_enabled test and covers both cases.
297 void TemplateInterpreter::ignore_safepoints() {
298   if (_notice_safepoints) {
299     if (!JvmtiExport::should_post_single_step()) {

300       // switch to normal dispatch table
301       _notice_safepoints = false;
302       copy_table((address*)&amp;_normal_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));



303     }



304   }
305 }
306 
307 //------------------------------------------------------------------------------------------------------------------------
308 // Deoptimization support
309 
310 // If deoptimization happens, this function returns the point of next bytecode to continue execution
311 address TemplateInterpreter::deopt_continue_after_entry(Method* method, address bcp, int callee_parameters, bool is_top_frame) {
312   return AbstractInterpreter::deopt_continue_after_entry(method, bcp, callee_parameters, is_top_frame);
313 }
314 
315 // If deoptimization happens, this function returns the point where the interpreter reexecutes
316 // the bytecode.
317 // Note: Bytecodes::_athrow (C1 only) and Bytecodes::_return are the special cases
318 //       that do not return &quot;Interpreter::deopt_entry(vtos, 0)&quot;
319 address TemplateInterpreter::deopt_reexecute_entry(Method* method, address bcp) {
320   assert(method-&gt;contains(bcp), &quot;just checkin&#39;&quot;);
321   Bytecodes::Code code   = Bytecodes::code_at(method, bcp);
322   if (code == Bytecodes::_return_register_finalizer) {
323     // This is used for deopt during registration of finalizers
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/templateInterpreter.hpp&quot;
 30 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
 31 #include &quot;interpreter/templateTable.hpp&quot;
<span class="line-added"> 32 #include &quot;logging/log.hpp&quot;</span>
 33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 34 #include &quot;runtime/safepoint.hpp&quot;</span>
 35 #include &quot;runtime/timerTrace.hpp&quot;
<span class="line-added"> 36 #include &quot;utilities/copy.hpp&quot;</span>
 37 
 38 #ifndef CC_INTERP
 39 
 40 # define __ _masm-&gt;
 41 
 42 void TemplateInterpreter::initialize() {
 43   if (_code != NULL) return;
 44   // assertions
 45   assert((int)Bytecodes::number_of_codes &lt;= (int)DispatchTable::length,
 46          &quot;dispatch table too small&quot;);
 47 
 48   AbstractInterpreter::initialize();
 49 
 50   TemplateTable::initialize();
 51 
 52   // generate interpreter
 53   { ResourceMark rm;
 54     TraceTime timer(&quot;Interpreter generation&quot;, TRACETIME_LOG(Info, startuptime));
 55     int code_size = InterpreterCodeSize;
 56     NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space
</pre>
<hr />
<pre>
260 
261 
262 address TemplateInterpreter::deopt_entry(TosState state, int length) {
263   guarantee(0 &lt;= length &amp;&amp; length &lt; Interpreter::number_of_deopt_entries, &quot;illegal length&quot;);
264   address entry = _deopt_entry[length].entry(state);
265   vmassert(entry != NULL, &quot;unsupported deopt entry requested, length=%d state=%d&quot;, length, TosState_as_index(state));
266   return entry;
267 }
268 
269 //------------------------------------------------------------------------------------------------------------------------
270 // Suport for invokes
271 
272 int TemplateInterpreter::TosState_as_index(TosState state) {
273   assert( state &lt; number_of_states , &quot;Invalid state in TosState_as_index&quot;);
274   assert(0 &lt;= (int)state &amp;&amp; (int)state &lt; TemplateInterpreter::number_of_return_addrs, &quot;index out of bounds&quot;);
275   return (int)state;
276 }
277 
278 
279 //------------------------------------------------------------------------------------------------------------------------
<span class="line-modified">280 // Safepoint support</span>
281 
282 static inline void copy_table(address* from, address* to, int size) {
<span class="line-modified">283   // Copy non-overlapping tables.</span>
<span class="line-modified">284   if (SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-added">285     // Nothing is using the table at a safepoint so skip atomic word copy.</span>
<span class="line-added">286     Copy::disjoint_words((HeapWord*)from, (HeapWord*)to, (size_t)size);</span>
<span class="line-added">287   } else {</span>
<span class="line-added">288     // Use atomic word copy when not at a safepoint for safety.</span>
<span class="line-added">289     Copy::disjoint_words_atomic((HeapWord*)from, (HeapWord*)to, (size_t)size);</span>
<span class="line-added">290   }</span>
291 }
292 
293 void TemplateInterpreter::notice_safepoints() {
294   if (!_notice_safepoints) {
<span class="line-added">295     log_debug(interpreter, safepoint)(&quot;switching active_table to safept_table.&quot;);</span>
296     // switch to safepoint dispatch table
297     _notice_safepoints = true;
298     copy_table((address*)&amp;_safept_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));
<span class="line-added">299   } else {</span>
<span class="line-added">300     log_debug(interpreter, safepoint)(&quot;active_table is already safept_table; &quot;</span>
<span class="line-added">301                                       &quot;notice_safepoints() call is no-op.&quot;);</span>
302   }
303 }
304 
305 // switch from the dispatch table which notices safepoints back to the
306 // normal dispatch table.  So that we can notice single stepping points,
307 // keep the safepoint dispatch table if we are single stepping in JVMTI.
308 // Note that the should_post_single_step test is exactly as fast as the
309 // JvmtiExport::_enabled test and covers both cases.
310 void TemplateInterpreter::ignore_safepoints() {
311   if (_notice_safepoints) {
312     if (!JvmtiExport::should_post_single_step()) {
<span class="line-added">313       log_debug(interpreter, safepoint)(&quot;switching active_table to normal_table.&quot;);</span>
314       // switch to normal dispatch table
315       _notice_safepoints = false;
316       copy_table((address*)&amp;_normal_table, (address*)&amp;_active_table, sizeof(_active_table) / sizeof(address));
<span class="line-added">317     } else {</span>
<span class="line-added">318       log_debug(interpreter, safepoint)(&quot;single stepping is still active; &quot;</span>
<span class="line-added">319                                         &quot;ignoring ignore_safepoints() call.&quot;);</span>
320     }
<span class="line-added">321   } else {</span>
<span class="line-added">322     log_debug(interpreter, safepoint)(&quot;active_table is already normal_table; &quot;</span>
<span class="line-added">323                                       &quot;ignore_safepoints() call is no-op.&quot;);</span>
324   }
325 }
326 
327 //------------------------------------------------------------------------------------------------------------------------
328 // Deoptimization support
329 
330 // If deoptimization happens, this function returns the point of next bytecode to continue execution
331 address TemplateInterpreter::deopt_continue_after_entry(Method* method, address bcp, int callee_parameters, bool is_top_frame) {
332   return AbstractInterpreter::deopt_continue_after_entry(method, bcp, callee_parameters, is_top_frame);
333 }
334 
335 // If deoptimization happens, this function returns the point where the interpreter reexecutes
336 // the bytecode.
337 // Note: Bytecodes::_athrow (C1 only) and Bytecodes::_return are the special cases
338 //       that do not return &quot;Interpreter::deopt_entry(vtos, 0)&quot;
339 address TemplateInterpreter::deopt_reexecute_entry(Method* method, address bcp) {
340   assert(method-&gt;contains(bcp), &quot;just checkin&#39;&quot;);
341   Bytecodes::Code code   = Bytecodes::code_at(method, bcp);
342   if (code == Bytecodes::_return_register_finalizer) {
343     // This is used for deopt during registration of finalizers
</pre>
</td>
</tr>
</table>
<center><a href="rewriter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jfr/dcmd/jfrDcmds.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
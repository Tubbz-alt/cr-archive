<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/bytecodeStream.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecodeInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeTracer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bytecodeStream.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
153   // Get an unsigned 2-byte index, with no swapping of bytes.
154   int             get_index_u2() const       { assert(!is_wide(), &quot;&quot;); return get_index_u2_raw(bcp() + 1);  }
155 
156  private:
157   int get_index_u2_raw(address p) const {
158     assert_raw_index_size(2); assert_raw_stream(true);
159     return Bytes::get_Java_u2(p);
160   }
161 };
162 
163 // In BytecodeStream, non-java bytecodes will be translated into the
164 // corresponding java bytecodes.
165 
166 class BytecodeStream: public BaseBytecodeStream {
167   Bytecodes::Code _code;
168 
169  public:
170   // Construction
171   BytecodeStream(const methodHandle&amp; method) : BaseBytecodeStream(method) { }
172 




173   // Iteration
174   Bytecodes::Code next() {
175     Bytecodes::Code raw_code, code;
176     // set reading position
177     _bci = _next_bci;
178     if (is_last_bytecode()) {
179       // indicate end of bytecode stream
180       raw_code = code = Bytecodes::_illegal;
181     } else {
182       // get bytecode
183       address bcp = this-&gt;bcp();
184       raw_code = Bytecodes::code_at(_method(), bcp);
185       code = Bytecodes::java_code(raw_code);
186       // set next bytecode position
187       //
188       // note that we cannot advance before having the
189       // tty bytecode otherwise the stepping is wrong!
190       // (carefull: length_for(...) must be used first!)
191       int len = Bytecodes::length_for(code);
192       if (len == 0) len = Bytecodes::length_at(_method(), bcp);
</pre>
</td>
<td>
<hr />
<pre>
153   // Get an unsigned 2-byte index, with no swapping of bytes.
154   int             get_index_u2() const       { assert(!is_wide(), &quot;&quot;); return get_index_u2_raw(bcp() + 1);  }
155 
156  private:
157   int get_index_u2_raw(address p) const {
158     assert_raw_index_size(2); assert_raw_stream(true);
159     return Bytes::get_Java_u2(p);
160   }
161 };
162 
163 // In BytecodeStream, non-java bytecodes will be translated into the
164 // corresponding java bytecodes.
165 
166 class BytecodeStream: public BaseBytecodeStream {
167   Bytecodes::Code _code;
168 
169  public:
170   // Construction
171   BytecodeStream(const methodHandle&amp; method) : BaseBytecodeStream(method) { }
172 
<span class="line-added">173   BytecodeStream(const methodHandle&amp; method, int bci) : BaseBytecodeStream(method) {</span>
<span class="line-added">174     set_start(bci);</span>
<span class="line-added">175   }</span>
<span class="line-added">176 </span>
177   // Iteration
178   Bytecodes::Code next() {
179     Bytecodes::Code raw_code, code;
180     // set reading position
181     _bci = _next_bci;
182     if (is_last_bytecode()) {
183       // indicate end of bytecode stream
184       raw_code = code = Bytecodes::_illegal;
185     } else {
186       // get bytecode
187       address bcp = this-&gt;bcp();
188       raw_code = Bytecodes::code_at(_method(), bcp);
189       code = Bytecodes::java_code(raw_code);
190       // set next bytecode position
191       //
192       // note that we cannot advance before having the
193       // tty bytecode otherwise the stepping is wrong!
194       // (carefull: length_for(...) must be used first!)
195       int len = Bytecodes::length_for(code);
196       if (len == 0) len = Bytecodes::length_at(_method(), bcp);
</pre>
</td>
</tr>
</table>
<center><a href="bytecodeInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeTracer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
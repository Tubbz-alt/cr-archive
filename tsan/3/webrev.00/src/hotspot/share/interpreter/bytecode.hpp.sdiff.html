<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/bytecode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/bytecode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
192   int          pool_index() const;               // constant pool index
193   Symbol*      klass() const;                    // returns the klass of the method or field
194   Symbol*      name() const;                     // returns the name of the method or field
195   Symbol*      signature() const;                // returns the signature of the method or field
196 
197   BasicType    result_type() const;              // returns the result type of the getfield or invoke
198 };
199 
200 // Abstraction for invoke_{virtual, static, interface, special, dynamic, handle}
201 
202 class Bytecode_invoke: public Bytecode_member_ref {
203  protected:
204   // Constructor that skips verification
205   Bytecode_invoke(const methodHandle&amp; method, int bci, bool unused)  : Bytecode_member_ref(method, bci) {}
206 
207  public:
208   Bytecode_invoke(const methodHandle&amp; method, int bci)  : Bytecode_member_ref(method, bci) { verify(); }
209   void verify() const;
210 
211   // Attributes
<span class="line-modified">212   methodHandle static_target(TRAPS);             // &quot;specified&quot; method   (from constant pool)</span>
213   Handle       appendix(TRAPS);                  // if CPCE::has_appendix (from constant pool)
214 
215   // Testers
216   bool is_invokeinterface() const                { return invoke_code() == Bytecodes::_invokeinterface; }
217   bool is_invokevirtual() const                  { return invoke_code() == Bytecodes::_invokevirtual; }
218   bool is_invokestatic() const                   { return invoke_code() == Bytecodes::_invokestatic; }
219   bool is_invokespecial() const                  { return invoke_code() == Bytecodes::_invokespecial; }
220   bool is_invokedynamic() const                  { return invoke_code() == Bytecodes::_invokedynamic; }
221   bool is_invokehandle() const                   { return invoke_code() == Bytecodes::_invokehandle; }
222 
223   bool has_receiver() const                      { return !is_invokestatic() &amp;&amp; !is_invokedynamic(); }
224 
225   bool is_valid() const                          { return is_invokeinterface() ||
226                                                           is_invokevirtual()   ||
227                                                           is_invokestatic()    ||
228                                                           is_invokespecial()   ||
229                                                           is_invokedynamic()   ||
230                                                           is_invokehandle(); }
231 
232   bool has_appendix();
</pre>
</td>
<td>
<hr />
<pre>
192   int          pool_index() const;               // constant pool index
193   Symbol*      klass() const;                    // returns the klass of the method or field
194   Symbol*      name() const;                     // returns the name of the method or field
195   Symbol*      signature() const;                // returns the signature of the method or field
196 
197   BasicType    result_type() const;              // returns the result type of the getfield or invoke
198 };
199 
200 // Abstraction for invoke_{virtual, static, interface, special, dynamic, handle}
201 
202 class Bytecode_invoke: public Bytecode_member_ref {
203  protected:
204   // Constructor that skips verification
205   Bytecode_invoke(const methodHandle&amp; method, int bci, bool unused)  : Bytecode_member_ref(method, bci) {}
206 
207  public:
208   Bytecode_invoke(const methodHandle&amp; method, int bci)  : Bytecode_member_ref(method, bci) { verify(); }
209   void verify() const;
210 
211   // Attributes
<span class="line-modified">212   Method* static_target(TRAPS);                  // &quot;specified&quot; method   (from constant pool)</span>
213   Handle       appendix(TRAPS);                  // if CPCE::has_appendix (from constant pool)
214 
215   // Testers
216   bool is_invokeinterface() const                { return invoke_code() == Bytecodes::_invokeinterface; }
217   bool is_invokevirtual() const                  { return invoke_code() == Bytecodes::_invokevirtual; }
218   bool is_invokestatic() const                   { return invoke_code() == Bytecodes::_invokestatic; }
219   bool is_invokespecial() const                  { return invoke_code() == Bytecodes::_invokespecial; }
220   bool is_invokedynamic() const                  { return invoke_code() == Bytecodes::_invokedynamic; }
221   bool is_invokehandle() const                   { return invoke_code() == Bytecodes::_invokehandle; }
222 
223   bool has_receiver() const                      { return !is_invokestatic() &amp;&amp; !is_invokedynamic(); }
224 
225   bool is_valid() const                          { return is_invokeinterface() ||
226                                                           is_invokevirtual()   ||
227                                                           is_invokestatic()    ||
228                                                           is_invokespecial()   ||
229                                                           is_invokedynamic()   ||
230                                                           is_invokehandle(); }
231 
232   bool has_appendix();
</pre>
</td>
</tr>
</table>
<center><a href="bytecode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
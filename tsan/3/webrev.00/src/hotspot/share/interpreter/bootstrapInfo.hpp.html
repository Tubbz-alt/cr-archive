<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/interpreter/bootstrapInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_BOOTSTRAPINFO_HPP
 26 #define SHARE_INTERPRETER_BOOTSTRAPINFO_HPP
 27 
 28 #include &quot;oops/constantPool.hpp&quot;
 29 #include &quot;oops/instanceKlass.hpp&quot;
 30 
 31 // BootstrapInfo provides condensed information from the constant pool
 32 // necessary to invoke a bootstrap method.
 33 class BootstrapInfo : public StackObj {
 34   constantPoolHandle _pool;     // constant pool containing the bootstrap specifier
 35   const int   _bss_index;       // index of bootstrap specifier in CP (condy or indy)
 36   const int   _indy_index;      // internal index of indy call site, or -1 if a condy call
 37   const int   _argc;            // number of static arguments
 38   Symbol*     _name;            // extracted from JVM_CONSTANT_NameAndType
 39   Symbol*     _signature;
 40 
 41   // pre-bootstrap resolution state:
 42   Handle      _bsm;             // resolved bootstrap method
 43   Handle      _name_arg;        // resolved String
 44   Handle      _type_arg;        // resolved Class or MethodType
 45   Handle      _arg_values;      // array of static arguments; null implies either
 46                                 // uresolved or zero static arguments are specified
 47 
 48   // post-bootstrap resolution state:
 49   bool        _is_resolved;       // set true when any of the next fields are set
 50   Handle      _resolved_value;    // bind this as condy constant
 51   methodHandle _resolved_method;  // bind this as indy behavior
 52   Handle      _resolved_appendix; // extra opaque static argument for _resolved_method
 53 
 54  public:
 55   BootstrapInfo(const constantPoolHandle&amp; pool, int bss_index, int indy_index = -1);
 56 
 57   // accessors
 58   const constantPoolHandle&amp; pool() const{ return _pool; }
 59   int bss_index() const                 { return _bss_index; }
 60   int indy_index() const                { return _indy_index; }
 61   int argc() const                      { return _argc; }
 62   bool is_method_call() const           { return (_indy_index != -1); }
 63   Symbol* name() const                  { return _name; }
 64   Symbol* signature() const             { return _signature; }
 65 
 66   // accessors to lazy state
 67   Handle bsm() const                    { return _bsm; }
 68   Handle name_arg() const               { return _name_arg; }
 69   Handle type_arg() const               { return _type_arg; }
 70   Handle arg_values() const             { return _arg_values; }
 71   bool is_resolved() const              { return _is_resolved; }
 72   Handle resolved_value() const         { assert(!is_method_call(), &quot;&quot;); return _resolved_value; }
 73   methodHandle resolved_method() const  { assert(is_method_call(), &quot;&quot;);  return _resolved_method; }
 74   Handle resolved_appendix() const      { assert(is_method_call(), &quot;&quot;);  return _resolved_appendix; }
 75 
 76   // derived accessors
 77   InstanceKlass* caller() const         { return _pool-&gt;pool_holder(); }
 78   oop caller_mirror() const             { return caller()-&gt;java_mirror(); }
 79   int decode_indy_index() const         { return ConstantPool::decode_invokedynamic_index(_indy_index); }
 80   int bsms_attr_index() const           { return _pool-&gt;bootstrap_methods_attribute_index(_bss_index); }
 81   int bsm_index() const                 { return _pool-&gt;bootstrap_method_ref_index_at(_bss_index); }
 82   //int argc() is eagerly cached in _argc
 83   int arg_index(int i) const            { return _pool-&gt;bootstrap_argument_index_at(_bss_index, i); }
 84 
 85   // CP cache entry for call site (indy only)
 86   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry() const {
 87     assert(is_method_call(), &quot;&quot;);
 88     return _pool-&gt;invokedynamic_cp_cache_entry_at(_indy_index);
 89   }
 90 
 91   // If there is evidence this call site was already linked, set the
 92   // existing linkage data into result, or throw previous exception.
 93   // Return true if either action is taken, else false.
 94   bool resolve_previously_linked_invokedynamic(CallInfo&amp; result, TRAPS);
 95   bool save_and_throw_indy_exc(TRAPS);
 96   void resolve_newly_linked_invokedynamic(CallInfo&amp; result, TRAPS);
 97 
 98   // pre-bootstrap resolution actions:
 99   Handle resolve_bsm(TRAPS); // lazily compute _bsm and return it
100   void resolve_bss_name_and_type(TRAPS); // lazily compute _name/_type
101   void resolve_args(TRAPS);  // compute arguments
102 
103   // setters for post-bootstrap results:
104   void set_resolved_value(Handle value) {
105     assert(!is_resolved() &amp;&amp; !is_method_call(), &quot;&quot;);
106     _is_resolved = true;
107     _resolved_value = value;
108   }
109   void set_resolved_method(methodHandle method, Handle appendix) {
110     assert(!is_resolved() &amp;&amp; is_method_call(), &quot;&quot;);
111     _is_resolved = true;
112     _resolved_method = method;
113     _resolved_appendix = appendix;
114   }
115 
116   void print() { print_msg_on(tty); }
117   void print_msg_on(outputStream* st, const char* msg = NULL);
118 };
119 
120 #endif // SHARE_INTERPRETER_BOOTSTRAPINFO_HPP
    </pre>
  </body>
</html>
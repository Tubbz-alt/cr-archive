diff a/src/hotspot/share/interpreter/bytecodeInterpreter.cpp b/src/hotspot/share/interpreter/bytecodeInterpreter.cpp
--- a/src/hotspot/share/interpreter/bytecodeInterpreter.cpp
+++ b/src/hotspot/share/interpreter/bytecodeInterpreter.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -32,10 +32,11 @@
 #include "interpreter/bytecodeInterpreterProfiling.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/interpreterRuntime.hpp"
 #include "logging/log.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "oops/constantPool.inline.hpp"
 #include "oops/cpCache.inline.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/methodCounters.hpp"
 #include "oops/objArrayKlass.hpp"
@@ -663,43 +664,43 @@
         // The initial monitor is ours for the taking.
         // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
         BasicObjectLock* mon = &istate->monitor_base()[-1];
         mon->set_obj(rcvr);
         bool success = false;
-        uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;
-        markOop mark = rcvr->mark();
-        intptr_t hash = (intptr_t) markOopDesc::no_hash;
+        uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;
+        markWord mark = rcvr->mark();
+        intptr_t hash = (intptr_t) markWord::no_hash;
         // Implies UseBiasedLocking.
-        if (mark->has_bias_pattern()) {
+        if (mark.has_bias_pattern()) {
           uintptr_t thread_ident;
           uintptr_t anticipated_bias_locking_value;
           thread_ident = (uintptr_t)istate->thread();
           anticipated_bias_locking_value =
-            (((uintptr_t)rcvr->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
-            ~((uintptr_t) markOopDesc::age_mask_in_place);
+            ((rcvr->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &
+            ~(markWord::age_mask_in_place);
 
           if (anticipated_bias_locking_value == 0) {
             // Already biased towards this thread, nothing to do.
             if (PrintBiasedLockingStatistics) {
               (* BiasedLocking::biased_lock_entry_count_addr())++;
             }
             success = true;
-          } else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
+          } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {
             // Try to revoke bias.
-            markOop header = rcvr->klass()->prototype_header();
-            if (hash != markOopDesc::no_hash) {
-              header = header->copy_set_hash(hash);
+            markWord header = rcvr->klass()->prototype_header();
+            if (hash != markWord::no_hash) {
+              header = header.copy_set_hash(hash);
             }
             if (rcvr->cas_set_mark(header, mark) == mark) {
               if (PrintBiasedLockingStatistics)
                 (*BiasedLocking::revoked_lock_entry_count_addr())++;
             }
           } else if ((anticipated_bias_locking_value & epoch_mask_in_place) != 0) {
             // Try to rebias.
-            markOop new_header = (markOop) ( (intptr_t) rcvr->klass()->prototype_header() | thread_ident);
-            if (hash != markOopDesc::no_hash) {
-              new_header = new_header->copy_set_hash(hash);
+            markWord new_header( (intptr_t) rcvr->klass()->prototype_header().value() | thread_ident);
+            if (hash != markWord::no_hash) {
+              new_header = new_header.copy_set_hash(hash);
             }
             if (rcvr->cas_set_mark(new_header, mark) == mark) {
               if (PrintBiasedLockingStatistics) {
                 (* BiasedLocking::rebiased_lock_entry_count_addr())++;
               }
@@ -707,19 +708,19 @@
               CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
             }
             success = true;
           } else {
             // Try to bias towards thread in case object is anonymously biased.
-            markOop header = (markOop) ((uintptr_t) mark &
-                                        ((uintptr_t)markOopDesc::biased_lock_mask_in_place |
-                                         (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));
-            if (hash != markOopDesc::no_hash) {
-              header = header->copy_set_hash(hash);
+            markWord header(mark.value() &
+                            (markWord::biased_lock_mask_in_place |
+                             markWord::age_mask_in_place | epoch_mask_in_place));
+            if (hash != markWord::no_hash) {
+              header = header.copy_set_hash(hash);
             }
-            markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
+            markWord new_header(header.value() | thread_ident);
             // Debugging hint.
-            DEBUG_ONLY(mon->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
+            DEBUG_ONLY(mon->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)
             if (rcvr->cas_set_mark(new_header, header) == header) {
               if (PrintBiasedLockingStatistics) {
                 (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
               }
             } else {
@@ -729,17 +730,17 @@
           }
         }
 
         // Traditional lightweight locking.
         if (!success) {
-          markOop displaced = rcvr->mark()->set_unlocked();
+          markWord displaced = rcvr->mark().set_unlocked();
           mon->lock()->set_displaced_header(displaced);
           bool call_vm = UseHeavyMonitors;
-          if (call_vm || rcvr->cas_set_mark((markOop)mon, displaced) != displaced) {
+          if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {
             // Is it simple recursive case?
-            if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
-              mon->lock()->set_displaced_header(NULL);
+            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {
+              mon->lock()->set_displaced_header(markWord::from_pointer(NULL));
             } else {
               CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);
             }
           }
         }
@@ -848,45 +849,45 @@
       // find a free monitor
       BasicObjectLock* entry = (BasicObjectLock*) istate->stack_base();
       assert(entry->obj() == NULL, "Frame manager didn't allocate the monitor");
       entry->set_obj(lockee);
       bool success = false;
-      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;
+      uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;
 
-      markOop mark = lockee->mark();
-      intptr_t hash = (intptr_t) markOopDesc::no_hash;
+      markWord mark = lockee->mark();
+      intptr_t hash = (intptr_t) markWord::no_hash;
       // implies UseBiasedLocking
-      if (mark->has_bias_pattern()) {
+      if (mark.has_bias_pattern()) {
         uintptr_t thread_ident;
         uintptr_t anticipated_bias_locking_value;
         thread_ident = (uintptr_t)istate->thread();
         anticipated_bias_locking_value =
-          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
-          ~((uintptr_t) markOopDesc::age_mask_in_place);
+          ((lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &
+          ~(markWord::age_mask_in_place);
 
         if  (anticipated_bias_locking_value == 0) {
           // already biased towards this thread, nothing to do
           if (PrintBiasedLockingStatistics) {
             (* BiasedLocking::biased_lock_entry_count_addr())++;
           }
           success = true;
-        } else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
+        } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {
           // try revoke bias
-          markOop header = lockee->klass()->prototype_header();
-          if (hash != markOopDesc::no_hash) {
-            header = header->copy_set_hash(hash);
+          markWord header = lockee->klass()->prototype_header();
+          if (hash != markWord::no_hash) {
+            header = header.copy_set_hash(hash);
           }
           if (lockee->cas_set_mark(header, mark) == mark) {
             if (PrintBiasedLockingStatistics) {
               (*BiasedLocking::revoked_lock_entry_count_addr())++;
             }
           }
         } else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
           // try rebias
-          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);
-          if (hash != markOopDesc::no_hash) {
-                new_header = new_header->copy_set_hash(hash);
+          markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);
+          if (hash != markWord::no_hash) {
+            new_header = new_header.copy_set_hash(hash);
           }
           if (lockee->cas_set_mark(new_header, mark) == mark) {
             if (PrintBiasedLockingStatistics) {
               (* BiasedLocking::rebiased_lock_entry_count_addr())++;
             }
@@ -894,18 +895,18 @@
             CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
           }
           success = true;
         } else {
           // try to bias towards thread in case object is anonymously biased
-          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |
-                                                          (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));
-          if (hash != markOopDesc::no_hash) {
-            header = header->copy_set_hash(hash);
+          markWord header(mark.value() & (markWord::biased_lock_mask_in_place |
+                                          markWord::age_mask_in_place | epoch_mask_in_place));
+          if (hash != markWord::no_hash) {
+            header = header.copy_set_hash(hash);
           }
-          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
+          markWord new_header(header.value() | thread_ident);
           // debugging hint
-          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
+          DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)
           if (lockee->cas_set_mark(new_header, header) == header) {
             if (PrintBiasedLockingStatistics) {
               (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
             }
           } else {
@@ -915,17 +916,17 @@
         }
       }
 
       // traditional lightweight locking
       if (!success) {
-        markOop displaced = lockee->mark()->set_unlocked();
+        markWord displaced = lockee->mark().set_unlocked();
         entry->lock()->set_displaced_header(displaced);
         bool call_vm = UseHeavyMonitors;
-        if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {
+        if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {
           // Is it simple recursive case?
-          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
-            entry->lock()->set_displaced_header(NULL);
+          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {
+            entry->lock()->set_displaced_header(markWord::from_pointer(NULL));
           } else {
             CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
           }
         }
       }
@@ -1788,46 +1789,46 @@
           most_recent++;
         }
         if (entry != NULL) {
           entry->set_obj(lockee);
           int success = false;
-          uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;
+          uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;
 
-          markOop mark = lockee->mark();
-          intptr_t hash = (intptr_t) markOopDesc::no_hash;
+          markWord mark = lockee->mark();
+          intptr_t hash = (intptr_t) markWord::no_hash;
           // implies UseBiasedLocking
-          if (mark->has_bias_pattern()) {
+          if (mark.has_bias_pattern()) {
             uintptr_t thread_ident;
             uintptr_t anticipated_bias_locking_value;
             thread_ident = (uintptr_t)istate->thread();
             anticipated_bias_locking_value =
-              (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
-              ~((uintptr_t) markOopDesc::age_mask_in_place);
+              ((lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &
+              ~(markWord::age_mask_in_place);
 
             if  (anticipated_bias_locking_value == 0) {
               // already biased towards this thread, nothing to do
               if (PrintBiasedLockingStatistics) {
                 (* BiasedLocking::biased_lock_entry_count_addr())++;
               }
               success = true;
             }
-            else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
+            else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {
               // try revoke bias
-              markOop header = lockee->klass()->prototype_header();
-              if (hash != markOopDesc::no_hash) {
-                header = header->copy_set_hash(hash);
+              markWord header = lockee->klass()->prototype_header();
+              if (hash != markWord::no_hash) {
+                header = header.copy_set_hash(hash);
               }
               if (lockee->cas_set_mark(header, mark) == mark) {
                 if (PrintBiasedLockingStatistics)
                   (*BiasedLocking::revoked_lock_entry_count_addr())++;
               }
             }
             else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
               // try rebias
-              markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);
-              if (hash != markOopDesc::no_hash) {
-                new_header = new_header->copy_set_hash(hash);
+              markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);
+              if (hash != markWord::no_hash) {
+                new_header = new_header.copy_set_hash(hash);
               }
               if (lockee->cas_set_mark(new_header, mark) == mark) {
                 if (PrintBiasedLockingStatistics)
                   (* BiasedLocking::rebiased_lock_entry_count_addr())++;
               }
@@ -1836,19 +1837,19 @@
               }
               success = true;
             }
             else {
               // try to bias towards thread in case object is anonymously biased
-              markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |
-                                                              (uintptr_t)markOopDesc::age_mask_in_place |
-                                                              epoch_mask_in_place));
-              if (hash != markOopDesc::no_hash) {
-                header = header->copy_set_hash(hash);
+              markWord header(mark.value() & (markWord::biased_lock_mask_in_place |
+                                              markWord::age_mask_in_place |
+                                              epoch_mask_in_place));
+              if (hash != markWord::no_hash) {
+                header = header.copy_set_hash(hash);
               }
-              markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
+              markWord new_header(header.value() | thread_ident);
               // debugging hint
-              DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
+              DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)
               if (lockee->cas_set_mark(new_header, header) == header) {
                 if (PrintBiasedLockingStatistics)
                   (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
               }
               else {
@@ -1858,17 +1859,17 @@
             }
           }
 
           // traditional lightweight locking
           if (!success) {
-            markOop displaced = lockee->mark()->set_unlocked();
+            markWord displaced = lockee->mark().set_unlocked();
             entry->lock()->set_displaced_header(displaced);
             bool call_vm = UseHeavyMonitors;
-            if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {
+            if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {
               // Is it simple recursive case?
-              if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
-                entry->lock()->set_displaced_header(NULL);
+              if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {
+                entry->lock()->set_displaced_header(markWord::from_pointer(NULL));
               } else {
                 CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
               }
             }
           }
@@ -1887,17 +1888,17 @@
         BasicObjectLock* limit = istate->monitor_base();
         BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
         while (most_recent != limit ) {
           if ((most_recent)->obj() == lockee) {
             BasicLock* lock = most_recent->lock();
-            markOop header = lock->displaced_header();
+            markWord header = lock->displaced_header();
             most_recent->set_obj(NULL);
-            if (!lockee->mark()->has_bias_pattern()) {
+            if (!lockee->mark().has_bias_pattern()) {
               bool call_vm = UseHeavyMonitors;
               // If it isn't recursive we either must swap old header or call the runtime
-              if (header != NULL || call_vm) {
-                markOop old_header = markOopDesc::encode(lock);
+              if (header.to_pointer() != NULL || call_vm) {
+                markWord old_header = markWord::encode(lock);
                 if (call_vm || lockee->cas_set_mark(header, old_header) != old_header) {
                   // restore object for the slow case
                   most_recent->set_obj(lockee);
                   CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);
                 }
@@ -2160,30 +2161,30 @@
               // Try allocate in shared eden
             retry:
               HeapWord* compare_to = *Universe::heap()->top_addr();
               HeapWord* new_top = compare_to + obj_size;
               if (new_top <= *Universe::heap()->end_addr()) {
-                if (Atomic::cmpxchg(new_top, Universe::heap()->top_addr(), compare_to) != compare_to) {
+                if (Atomic::cmpxchg(Universe::heap()->top_addr(), compare_to, new_top) != compare_to) {
                   goto retry;
                 }
                 result = (oop) compare_to;
               }
             }
 #endif
             if (result != NULL) {
               // Initialize object (if nonzero size and need) and then the header
               if (need_zero ) {
-                HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;
+                HeapWord* to_zero = cast_from_oop<HeapWord*>(result) + sizeof(oopDesc) / oopSize;
                 obj_size -= sizeof(oopDesc) / oopSize;
                 if (obj_size > 0 ) {
                   memset(to_zero, 0, obj_size * HeapWordSize);
                 }
               }
               if (UseBiasedLocking) {
                 result->set_mark(ik->prototype_header());
               } else {
-                result->set_mark(markOopDesc::prototype());
+                result->set_mark(markWord::prototype());
               }
               result->set_klass_gap(0);
               result->set_klass(ik);
               // Must prevent reordering of stores for object initialization
               // with stores that publish the new object.
@@ -2433,11 +2434,11 @@
         if (result == NULL) {
           CALL_VM(InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode),
                   handle_exception);
           result = THREAD->vm_result();
         }
-        if (oopDesc::equals(result, Universe::the_null_sentinel()))
+        if (result == Universe::the_null_sentinel())
           result = NULL;
 
         VERIFY_OOP(result);
         SET_STACK_OBJECT(result, 0);
         UPDATE_PC_AND_TOS_AND_CONTINUE(incr, 1);
@@ -2459,12 +2460,12 @@
 
         Method* method = cache->f1_as_method();
         if (VerifyOops) method->verify();
 
         if (cache->has_appendix()) {
-          ConstantPool* constants = METHOD->constants();
-          SET_STACK_OBJECT(cache->appendix_if_resolved(constants), 0);
+          constantPoolHandle cp(THREAD, METHOD->constants());
+          SET_STACK_OBJECT(cache->appendix_if_resolved(cp), 0);
           MORE_STACK(1);
         }
 
         istate->set_msg(call_method);
         istate->set_callee(method);
@@ -2490,12 +2491,12 @@
 
         Method* method = cache->f1_as_method();
         if (VerifyOops) method->verify();
 
         if (cache->has_appendix()) {
-          ConstantPool* constants = METHOD->constants();
-          SET_STACK_OBJECT(cache->appendix_if_resolved(constants), 0);
+          constantPoolHandle cp(THREAD, METHOD->constants());
+          SET_STACK_OBJECT(cache->appendix_if_resolved(cp), 0);
           MORE_STACK(1);
         }
 
         istate->set_msg(call_method);
         istate->set_callee(method);
@@ -2868,11 +2869,11 @@
         tempst.print("interpreter method <%s>\n"
                      " at bci %d, continuing at %d for thread " INTPTR_FORMAT,
                      METHOD->print_value_string(),
                      (int)(istate->bcp() - METHOD->code_base()),
                      (int)continuation_bci, p2i(THREAD));
-        Exceptions::log_exception(except_oop, tempst);
+        Exceptions::log_exception(except_oop, tempst.as_string());
       }
       // for AbortVMOnException flag
       Exceptions::debug_check_abort(except_oop);
 
       // Update profiling data.
@@ -2885,11 +2886,11 @@
       tempst.print("interpreter method <%s>\n"
              " at bci %d, unwinding for thread " INTPTR_FORMAT,
              METHOD->print_value_string(),
              (int)(istate->bcp() - METHOD->code_base()),
              p2i(THREAD));
-      Exceptions::log_exception(except_oop, tempst);
+      Exceptions::log_exception(except_oop, tempst.as_string());
     }
     // for AbortVMOnException flag
     Exceptions::debug_check_abort(except_oop);
 
     // No handler in this activation, unwind and try again
@@ -3032,17 +3033,17 @@
       // Check all the monitors to see they are unlocked. Install exception if found to be locked.
       while (end < base) {
         oop lockee = end->obj();
         if (lockee != NULL) {
           BasicLock* lock = end->lock();
-          markOop header = lock->displaced_header();
+          markWord header = lock->displaced_header();
           end->set_obj(NULL);
 
-          if (!lockee->mark()->has_bias_pattern()) {
+          if (!lockee->mark().has_bias_pattern()) {
             // If it isn't recursive we either must swap old header or call the runtime
-            if (header != NULL) {
-              markOop old_header = markOopDesc::encode(lock);
+            if (header.to_pointer() != NULL) {
+              markWord old_header = markWord::encode(lock);
               if (lockee->cas_set_mark(header, old_header) != old_header) {
                 // restore object for the slow case
                 end->set_obj(lockee);
                 {
                   // Prevent any HandleMarkCleaner from freeing our live handles
@@ -3107,18 +3108,18 @@
               if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD->pending_exception());
               THREAD->clear_pending_exception();
             }
           } else {
             BasicLock* lock = base->lock();
-            markOop header = lock->displaced_header();
+            markWord header = lock->displaced_header();
             base->set_obj(NULL);
 
-            if (!rcvr->mark()->has_bias_pattern()) {
+            if (!rcvr->mark().has_bias_pattern()) {
               base->set_obj(NULL);
               // If it isn't recursive we either must swap old header or call the runtime
-              if (header != NULL) {
-                markOop old_header = markOopDesc::encode(lock);
+              if (header.to_pointer() != NULL) {
+                markWord old_header = markWord::encode(lock);
                 if (rcvr->cas_set_mark(header, old_header) != old_header) {
                   // restore object for the slow case
                   base->set_obj(rcvr);
                   {
                     // Prevent any HandleMarkCleaner from freeing our live handles

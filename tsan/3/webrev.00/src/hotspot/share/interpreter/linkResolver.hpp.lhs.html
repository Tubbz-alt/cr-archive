<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/linkResolver.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_LINKRESOLVER_HPP
 26 #define SHARE_INTERPRETER_LINKRESOLVER_HPP
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;oops/method.hpp&quot;
 29 
 30 // All the necessary definitions for run-time link resolution.
 31 
 32 // CallInfo provides all the information gathered for a particular
 33 // linked call site after resolving it. A link is any reference
 34 // made from within the bytecodes of a method to an object outside of
 35 // that method. If the info is invalid, the link has not been resolved
 36 // successfully.
 37 
 38 class CallInfo : public StackObj {
 39  public:
 40   // Ways that a method call might be selected (or not) based on receiver type.
 41   // Note that an invokevirtual instruction might be linked with no_dispatch,
 42   // and an invokeinterface instruction might be linked with any of the three options
 43   enum CallKind {
 44     direct_call,                        // jump into resolved_method (must be concrete)
 45     vtable_call,                        // select recv.klass.method_at_vtable(index)
 46     itable_call,                        // select recv.klass.method_at_itable(resolved_method.holder, index)
 47     unknown_kind = -1
 48   };
 49  private:
 50   Klass*       _resolved_klass;         // static receiver klass, resolved from a symbolic reference
 51   Klass*       _selected_klass;         // dynamic receiver class (same as static, or subklass)
 52   methodHandle _resolved_method;        // static target method
 53   methodHandle _selected_method;        // dynamic (actual) target method
 54   CallKind     _call_kind;              // kind of call (static(=bytecode static/special +
 55                                         //               others inferred), vtable, itable)
 56   int          _call_index;             // vtable or itable index of selected class method (if any)
 57   Handle       _resolved_appendix;      // extra argument in constant pool (if CPCE::has_appendix)
 58   Handle       _resolved_method_name;   // Object holding the ResolvedMethodName
 59 
 60   void set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS);
 61   void set_interface(Klass* resolved_klass, Klass* selected_klass,
 62                      const methodHandle&amp; resolved_method,
 63                      const methodHandle&amp; selected_method,
 64                      int itable_index, TRAPS);
 65   void set_virtual(Klass* resolved_klass, Klass* selected_klass,
 66                    const methodHandle&amp; resolved_method,
 67                    const methodHandle&amp; selected_method,
 68                    int vtable_index, TRAPS);
 69   void set_handle(const methodHandle&amp; resolved_method,
 70                   Handle resolved_appendix, TRAPS);
 71   void set_handle(Klass* resolved_klass,
 72                   const methodHandle&amp; resolved_method,
 73                   Handle resolved_appendix, TRAPS);
 74   void set_common(Klass* resolved_klass, Klass* selected_klass,
 75                   const methodHandle&amp; resolved_method,
 76                   const methodHandle&amp; selected_method,
 77                   CallKind kind,
 78                   int index, TRAPS);
 79 
<a name="2" id="anc2"></a>
 80   friend class LinkResolver;
 81 
 82  public:
 83   CallInfo() {
 84 #ifndef PRODUCT
 85     _call_kind  = CallInfo::unknown_kind;
 86     _call_index = Method::garbage_vtable_index;
 87 #endif //PRODUCT
 88   }
 89 
 90   // utility to extract an effective CallInfo from a method and an optional receiver limit
 91   // does not queue the method for compilation.  This also creates a ResolvedMethodName
 92   // object for the resolved_method.
 93   CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS);
 94 
 95   Klass*  resolved_klass() const                 { return _resolved_klass; }
 96   Klass*  selected_klass() const                 { return _selected_klass; }
<a name="3" id="anc3"></a><span class="line-modified"> 97   methodHandle resolved_method() const           { return _resolved_method; }</span>
<span class="line-modified"> 98   methodHandle selected_method() const           { return _selected_method; }</span>
 99   Handle       resolved_appendix() const         { return _resolved_appendix; }
100   Handle       resolved_method_name() const      { return _resolved_method_name; }
101   // Materialize a java.lang.invoke.ResolvedMethodName for this resolved_method
102   void     set_resolved_method_name(TRAPS);
103 
104   BasicType    result_type() const               { return selected_method()-&gt;result_type(); }
105   CallKind     call_kind() const                 { return _call_kind; }
106   int          call_index() const                { return _call_index; }
107   int          vtable_index() const {
108     // Even for interface calls the vtable index could be non-negative.
109     // See CallInfo::set_interface.
110     assert(has_vtable_index() || is_statically_bound(), &quot;&quot;);
111     assert(call_kind() == vtable_call || call_kind() == direct_call, &quot;&quot;);
112     // The returned value is &lt; 0 if the call is statically bound.
113     // But, the returned value may be &gt;= 0 even if the kind is direct_call.
114     // It is up to the caller to decide which way to go.
115     return _call_index;
116   }
117   int          itable_index() const {
118     assert(call_kind() == itable_call, &quot;&quot;);
119     // The returned value is always &gt;= 0, a valid itable index.
120     return _call_index;
121   }
122 
123   // debugging
124 #ifdef ASSERT
125   bool         has_vtable_index() const          { return _call_index &gt;= 0 &amp;&amp; _call_kind != CallInfo::itable_call; }
126   bool         is_statically_bound() const       { return _call_index == Method::nonvirtual_vtable_index; }
127 #endif //ASSERT
128   void         verify() PRODUCT_RETURN;
129   void         print()  PRODUCT_RETURN;
130 };
131 
132 
133 // Condensed information from constant pool to use to resolve the method or field.
134 //   resolved_klass = specified class (i.e., static receiver class)
135 //   current_klass  = sending method holder (i.e., class containing the method
136 //                    containing the call being resolved)
137 //   current_method = sending method (relevant for field resolution)
138 class LinkInfo : public StackObj {
139   Symbol*     _name;            // extracted from JVM_CONSTANT_NameAndType
140   Symbol*     _signature;
141   Klass*      _resolved_klass;  // class that the constant pool entry points to
142   Klass*      _current_klass;   // class that owns the constant pool
143   methodHandle _current_method;  // sending method
144   bool        _check_access;
145   constantTag _tag;
146 
147  public:
148   enum AccessCheck {
149     needs_access_check,
150     skip_access_check
151   };
152 
153   LinkInfo(const constantPoolHandle&amp; pool, int index, const methodHandle&amp; current_method, TRAPS);
154   LinkInfo(const constantPoolHandle&amp; pool, int index, TRAPS);
155 
156   // Condensed information from other call sites within the vm.
157   LinkInfo(Klass* resolved_klass, Symbol* name, Symbol* signature, Klass* current_klass,
158            AccessCheck check_access = needs_access_check,
159            constantTag tag = JVM_CONSTANT_Invalid) :
160     _name(name),
161     _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_klass), _current_method(methodHandle()),
162     _check_access(check_access == needs_access_check), _tag(tag) {}
163 
164   LinkInfo(Klass* resolved_klass, Symbol* name, Symbol* signature, const methodHandle&amp; current_method,
165            AccessCheck check_access = needs_access_check,
166            constantTag tag = JVM_CONSTANT_Invalid) :
167     _name(name),
168     _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_method-&gt;method_holder()), _current_method(current_method),
169     _check_access(check_access == needs_access_check), _tag(tag) {}
170 
171   // Case where we just find the method and don&#39;t check access against the current class
172   LinkInfo(Klass* resolved_klass, Symbol*name, Symbol* signature) :
173     _name(name),
174     _signature(signature), _resolved_klass(resolved_klass), _current_klass(NULL), _current_method(methodHandle()),
175     _check_access(false), _tag(JVM_CONSTANT_Invalid) {}
176 
177   // accessors
178   Symbol* name() const               { return _name; }
179   Symbol* signature() const          { return _signature; }
180   Klass* resolved_klass() const      { return _resolved_klass; }
181   Klass* current_klass() const       { return _current_klass; }
<a name="4" id="anc4"></a><span class="line-modified">182   methodHandle current_method() const { return _current_method; }</span>
183   constantTag tag() const            { return _tag; }
184   bool check_access() const          { return _check_access; }
<a name="5" id="anc5"></a><span class="line-removed">185   char* method_string() const;</span>
186 
187   void         print()  PRODUCT_RETURN;
188 };
189 
190 // Link information for getfield/putfield &amp; getstatic/putstatic bytecodes
191 // is represented using a fieldDescriptor.
192 
193 // The LinkResolver is used to resolve constant-pool references at run-time.
194 // It does all necessary link-time checks &amp; throws exceptions if necessary.
195 
196 class LinkResolver: AllStatic {
197   friend class klassVtable;
198   friend class klassItable;
199 
200  private:
201 
202   static Method* lookup_method_in_klasses(const LinkInfo&amp; link_info,
203                                           bool checkpolymorphism,
204                                           bool in_imethod_resolve);
205   static Method* lookup_method_in_interfaces(const LinkInfo&amp; link_info);
206 
<a name="6" id="anc6"></a><span class="line-modified">207   static methodHandle lookup_polymorphic_method(const LinkInfo&amp; link_info,</span>
<span class="line-modified">208                                                 Handle *appendix_result_or_null, TRAPS);</span>
209  JVMCI_ONLY(public:) // Needed for CompilerToVM.resolveMethod()
210   // Not Linktime so doesn&#39;t take LinkInfo
<a name="7" id="anc7"></a><span class="line-modified">211   static methodHandle lookup_instance_method_in_klasses (Klass* klass, Symbol* name, Symbol* signature,</span>
<span class="line-modified">212                                                          Klass::PrivateLookupMode private_mode, TRAPS);</span>
213  JVMCI_ONLY(private:)
214 
215   // Similar loader constraint checking functions that throw
216   // LinkageError with descriptive message.
217   static void check_method_loader_constraints(const LinkInfo&amp; link_info,
218                                               const methodHandle&amp; resolved_method,
219                                               const char* method_type, TRAPS);
220   static void check_field_loader_constraints(Symbol* field, Symbol* sig,
221                                              Klass* current_klass,
222                                              Klass* sel_klass, TRAPS);
223 
<a name="8" id="anc8"></a><span class="line-modified">224   static methodHandle resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
<span class="line-modified">225   static methodHandle resolve_method          (const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS);</span>
226 
<a name="9" id="anc9"></a><span class="line-modified">227   static methodHandle linktime_resolve_static_method    (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">228   static methodHandle linktime_resolve_special_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">229   static methodHandle linktime_resolve_virtual_method   (const LinkInfo&amp; link_info, TRAPS);</span>
<span class="line-modified">230   static methodHandle linktime_resolve_interface_method (const LinkInfo&amp; link_info, TRAPS);</span>
231 
232   static void runtime_resolve_special_method    (CallInfo&amp; result,
233                                                  const LinkInfo&amp; link_info,
234                                                  const methodHandle&amp; resolved_method,
235                                                  Handle recv, TRAPS);
236 
237   static void runtime_resolve_virtual_method    (CallInfo&amp; result,
238                                                  const methodHandle&amp; resolved_method,
239                                                  Klass* resolved_klass,
240                                                  Handle recv,
241                                                  Klass* recv_klass,
242                                                  bool check_null_and_abstract, TRAPS);
243   static void runtime_resolve_interface_method  (CallInfo&amp; result,
244                                                  const methodHandle&amp; resolved_method,
245                                                  Klass* resolved_klass,
246                                                  Handle recv,
247                                                  Klass* recv_klass,
248                                                  bool check_null_and_abstract, TRAPS);
249 
250   static void check_field_accessability(Klass* ref_klass,
251                                         Klass* resolved_klass,
252                                         Klass* sel_klass,
253                                         const fieldDescriptor&amp; fd, TRAPS);
254   static void check_method_accessability(Klass* ref_klass,
255                                          Klass* resolved_klass,
256                                          Klass* sel_klass,
257                                          const methodHandle&amp; sel_method, TRAPS);
258 
259   // runtime resolving from constant pool
260   static void resolve_invokestatic   (CallInfo&amp; result,
261                                       const constantPoolHandle&amp; pool, int index, TRAPS);
262   static void resolve_invokespecial  (CallInfo&amp; result, Handle recv,
263                                       const constantPoolHandle&amp; pool, int index, TRAPS);
264   static void resolve_invokevirtual  (CallInfo&amp; result, Handle recv,
265                                       const constantPoolHandle&amp; pool, int index, TRAPS);
266   static void resolve_invokeinterface(CallInfo&amp; result, Handle recv,
267                                       const constantPoolHandle&amp; pool, int index, TRAPS);
268   static void resolve_invokedynamic  (CallInfo&amp; result,
269                                       const constantPoolHandle&amp; pool, int index, TRAPS);
270   static void resolve_invokehandle   (CallInfo&amp; result,
271                                       const constantPoolHandle&amp; pool, int index, TRAPS);
272  public:
273   // constant pool resolving
274   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass,
275                                         bool fold_type_to_class, TRAPS);
276   // The optional &#39;fold_type_to_class&#39; means that a derived type (array)
277   // is first converted to the class it is derived from (element type).
278   // If this element type is not a class, then the check passes quietly.
279   // This is usually what is needed, but a few existing uses might break
280   // if this flag were always turned on.  FIXME: See if it can be, always.
281   static void check_klass_accessability(Klass* ref_klass, Klass* sel_klass, TRAPS) {
282     return check_klass_accessability(ref_klass, sel_klass, false, THREAD);
283   }
284 
285   // static resolving calls (will not run any Java code);
286   // used only from Bytecode_invoke::static_target
<a name="10" id="anc10"></a><span class="line-modified">287   static methodHandle resolve_method_statically(Bytecodes::Code code,</span>
<span class="line-modified">288                                                 const constantPoolHandle&amp; pool,</span>
<span class="line-modified">289                                                 int index, TRAPS);</span>
290 
291   static void resolve_field_access(fieldDescriptor&amp; result,
292                                    const constantPoolHandle&amp; pool,
293                                    int index,
294                                    const methodHandle&amp; method,
295                                    Bytecodes::Code byte, TRAPS);
296   static void resolve_field(fieldDescriptor&amp; result, const LinkInfo&amp; link_info,
297                             Bytecodes::Code access_kind,
298                             bool initialize_class, TRAPS);
299 
300   static void resolve_static_call   (CallInfo&amp; result,
301                                      const LinkInfo&amp; link_info,
302                                      bool initialize_klass, TRAPS);
303   static void resolve_special_call  (CallInfo&amp; result,
304                                      Handle recv,
305                                      const LinkInfo&amp; link_info,
306                                      TRAPS);
307   static void resolve_virtual_call  (CallInfo&amp; result, Handle recv, Klass* recv_klass,
308                                      const LinkInfo&amp; link_info,
309                                      bool check_null_and_abstract, TRAPS);
310   static void resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
311                                      const LinkInfo&amp; link_info,
312                                      bool check_null_and_abstract, TRAPS);
313   static void resolve_handle_call   (CallInfo&amp; result,
314                                      const LinkInfo&amp; link_info, TRAPS);
<a name="11" id="anc11"></a><span class="line-modified">315   static void resolve_dynamic_call  (CallInfo&amp; result, int pool_index, Handle bootstrap_specifier,</span>
<span class="line-modified">316                                      Symbol* method_name, Symbol* method_signature,</span>
<span class="line-removed">317                                      Klass* current_klass, TRAPS);</span>
318 
319   // same as above for compile-time resolution; but returns null handle instead of throwing
320   // an exception on error also, does not initialize klass (i.e., no side effects)
<a name="12" id="anc12"></a><span class="line-modified">321   static methodHandle resolve_virtual_call_or_null  (Klass* receiver_klass,</span>
<span class="line-modified">322                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">323   static methodHandle resolve_interface_call_or_null(Klass* receiver_klass,</span>
<span class="line-modified">324                                                      const LinkInfo&amp; link_info);</span>
<span class="line-modified">325   static methodHandle resolve_static_call_or_null   (const LinkInfo&amp; link_info);</span>
<span class="line-modified">326   static methodHandle resolve_special_call_or_null  (const LinkInfo&amp; link_info);</span>
327 
328   static int vtable_index_of_interface_method(Klass* klass, const methodHandle&amp; resolved_method);
329 
330   // same as above for compile-time resolution; returns vtable_index if current_klass if linked
331   static int resolve_virtual_vtable_index  (Klass* receiver_klass,
332                                             const LinkInfo&amp; link_info);
333 
334   // static resolving for compiler (does not throw exceptions, returns null handle if unsuccessful)
<a name="13" id="anc13"></a><span class="line-modified">335   static methodHandle linktime_resolve_virtual_method_or_null  (const LinkInfo&amp; link_info);</span>
<span class="line-modified">336   static methodHandle linktime_resolve_interface_method_or_null(const LinkInfo&amp; link_info);</span>
337 
338   // runtime resolving from constant pool
339   static void resolve_invoke(CallInfo&amp; result, Handle recv,
340                              const constantPoolHandle&amp; pool, int index,
341                              Bytecodes::Code byte, TRAPS);
342 
343   // runtime resolving from attached method
344   static void resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
345                              const methodHandle&amp; attached_method,
346                              Bytecodes::Code byte, TRAPS);
347 
348  public:
349   // Only resolved method known.
350   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, TRAPS) {
<a name="14" id="anc14"></a><span class="line-modified">351     throw_abstract_method_error(resolved_method, NULL, NULL, CHECK);</span>
352   }
353   // Resolved method and receiver klass know.
354   static void throw_abstract_method_error(const methodHandle&amp; resolved_method, Klass *recv_klass, TRAPS) {
<a name="15" id="anc15"></a><span class="line-modified">355     throw_abstract_method_error(resolved_method, NULL, recv_klass, CHECK);</span>
356   }
357   // Selected method is abstract.
358   static void throw_abstract_method_error(const methodHandle&amp; resolved_method,
359                                           const methodHandle&amp; selected_method,
360                                           Klass *recv_klass, TRAPS);
361 };
362 #endif // SHARE_INTERPRETER_LINKRESOLVER_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
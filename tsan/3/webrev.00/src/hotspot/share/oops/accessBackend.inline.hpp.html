<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/accessBackend.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 26 #define SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 27 
 28 #include &quot;oops/access.hpp&quot;
 29 #include &quot;oops/accessBackend.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 #include &quot;runtime/atomic.hpp&quot;
 33 #include &quot;runtime/orderAccess.hpp&quot;
 34 
 35 template &lt;DecoratorSet decorators&gt;
 36 template &lt;DecoratorSet idecorators, typename T&gt;
 37 inline typename EnableIf&lt;
 38   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 39 RawAccessBarrier&lt;decorators&gt;::decode_internal(typename HeapOopType&lt;idecorators&gt;::type value) {
 40   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 41     return CompressedOops::decode_not_null(value);
 42   } else {
 43     return CompressedOops::decode(value);
 44   }
 45 }
 46 
 47 template &lt;DecoratorSet decorators&gt;
 48 template &lt;DecoratorSet idecorators, typename T&gt;
 49 inline typename EnableIf&lt;
 50   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 51   typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 52 RawAccessBarrier&lt;decorators&gt;::encode_internal(T value) {
 53   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 54     return CompressedOops::encode_not_null(value);
 55   } else {
 56     return CompressedOops::encode(value);
 57   }
 58 }
 59 
 60 template &lt;DecoratorSet decorators&gt;
 61 template &lt;typename T&gt;
 62 inline void RawAccessBarrier&lt;decorators&gt;::oop_store(void* addr, T value) {
 63   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 64   Encoded encoded = encode(value);
 65   store(reinterpret_cast&lt;Encoded*&gt;(addr), encoded);
 66 }
 67 
 68 template &lt;DecoratorSet decorators&gt;
 69 template &lt;typename T&gt;
 70 inline void RawAccessBarrier&lt;decorators&gt;::oop_store_at(oop base, ptrdiff_t offset, T value) {
 71   oop_store(field_addr(base, offset), value);
 72 }
 73 
 74 template &lt;DecoratorSet decorators&gt;
 75 template &lt;typename T&gt;
 76 inline T RawAccessBarrier&lt;decorators&gt;::oop_load(void* addr) {
 77   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 78   Encoded encoded = load&lt;Encoded&gt;(reinterpret_cast&lt;Encoded*&gt;(addr));
 79   return decode&lt;T&gt;(encoded);
 80 }
 81 
 82 template &lt;DecoratorSet decorators&gt;
 83 template &lt;typename T&gt;
 84 inline T RawAccessBarrier&lt;decorators&gt;::oop_load_at(oop base, ptrdiff_t offset) {
 85   return oop_load&lt;T&gt;(field_addr(base, offset));
 86 }
 87 
 88 template &lt;DecoratorSet decorators&gt;
 89 template &lt;typename T&gt;
 90 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 91   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 92   Encoded encoded_new = encode(new_value);
 93   Encoded encoded_compare = encode(compare_value);
 94   Encoded encoded_result = atomic_cmpxchg(reinterpret_cast&lt;Encoded*&gt;(addr),
 95                                           encoded_compare,
 96                                           encoded_new);
 97   return decode&lt;T&gt;(encoded_result);
 98 }
 99 
100 template &lt;DecoratorSet decorators&gt;
101 template &lt;typename T&gt;
102 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
103   return oop_atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
104 }
105 
106 template &lt;DecoratorSet decorators&gt;
107 template &lt;typename T&gt;
108 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(void* addr, T new_value) {
109   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
110   Encoded encoded_new = encode(new_value);
111   Encoded encoded_result = atomic_xchg(reinterpret_cast&lt;Encoded*&gt;(addr), encoded_new);
112   return decode&lt;T&gt;(encoded_result);
113 }
114 
115 template &lt;DecoratorSet decorators&gt;
116 template &lt;typename T&gt;
117 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
118   return oop_atomic_xchg(field_addr(base, offset), new_value);
119 }
120 
121 template &lt;DecoratorSet decorators&gt;
122 template &lt;typename T&gt;
123 inline bool RawAccessBarrier&lt;decorators&gt;::oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
124                                                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
125                                                         size_t length) {
126   return arraycopy(src_obj, src_offset_in_bytes, src_raw,
127                    dst_obj, dst_offset_in_bytes, dst_raw,
128                    length);
129 }
130 
131 template &lt;DecoratorSet decorators&gt;
132 template &lt;DecoratorSet ds, typename T&gt;
133 inline typename EnableIf&lt;
134   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
135 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
136   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
137     OrderAccess::fence();
138   }
139   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));
140 }
141 
142 template &lt;DecoratorSet decorators&gt;
143 template &lt;DecoratorSet ds, typename T&gt;
144 inline typename EnableIf&lt;
145   HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
146 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
147   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));
148 }
149 
150 template &lt;DecoratorSet decorators&gt;
151 template &lt;DecoratorSet ds, typename T&gt;
152 inline typename EnableIf&lt;
153   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
154 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
155   return Atomic::load(reinterpret_cast&lt;const volatile T*&gt;(addr));
156 }
157 
158 template &lt;DecoratorSet decorators&gt;
159 template &lt;DecoratorSet ds, typename T&gt;
160 inline typename EnableIf&lt;
161   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
162 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
163   Atomic::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);
164 }
165 
166 template &lt;DecoratorSet decorators&gt;
167 template &lt;DecoratorSet ds, typename T&gt;
168 inline typename EnableIf&lt;
169   HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
170 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
171   Atomic::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);
172 }
173 
174 template &lt;DecoratorSet decorators&gt;
175 template &lt;DecoratorSet ds, typename T&gt;
176 inline typename EnableIf&lt;
177   HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
178 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
179   Atomic::store(reinterpret_cast&lt;volatile T*&gt;(addr), value);
180 }
181 
182 template &lt;DecoratorSet decorators&gt;
183 template &lt;DecoratorSet ds, typename T&gt;
184 inline typename EnableIf&lt;
185   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
186 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {
187   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),
188                          compare_value,
189                          new_value,
190                          memory_order_relaxed);
191 }
192 
193 template &lt;DecoratorSet decorators&gt;
194 template &lt;DecoratorSet ds, typename T&gt;
195 inline typename EnableIf&lt;
196   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
197 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {
198   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),
199                          compare_value,
200                          new_value,
201                          memory_order_conservative);
202 }
203 
204 template &lt;DecoratorSet decorators&gt;
205 template &lt;DecoratorSet ds, typename T&gt;
206 inline typename EnableIf&lt;
207   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
208 RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(void* addr, T new_value) {
209   return Atomic::xchg(reinterpret_cast&lt;volatile T*&gt;(addr),
210                       new_value);
211 }
212 
213 // For platforms that do not have native support for wide atomics,
214 // we can emulate the atomicity using a lock. So here we check
215 // whether that is necessary or not.
216 
217 template &lt;DecoratorSet ds&gt;
218 template &lt;DecoratorSet decorators, typename T&gt;
219 inline typename EnableIf&lt;
220   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
221 RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(void* addr, T new_value) {
222   if (!AccessInternal::wide_atomic_needs_locking()) {
223     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);
224   } else {
225     AccessInternal::AccessLocker access_lock;
226     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
227     T old_val = RawAccess&lt;&gt;::load(p);
228     RawAccess&lt;&gt;::store(p, new_value);
229     return old_val;
230   }
231 }
232 
233 template &lt;DecoratorSet ds&gt;
234 template &lt;DecoratorSet decorators, typename T&gt;
235 inline typename EnableIf&lt;
236   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
237 RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {
238   if (!AccessInternal::wide_atomic_needs_locking()) {
239     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);
240   } else {
241     AccessInternal::AccessLocker access_lock;
242     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
243     T old_val = RawAccess&lt;&gt;::load(p);
244     if (old_val == compare_value) {
245       RawAccess&lt;&gt;::store(p, new_value);
246     }
247     return old_val;
248   }
249 }
250 
251 class RawAccessBarrierArrayCopy: public AllStatic {
252   template&lt;typename T&gt; struct IsHeapWordSized: public IntegralConstant&lt;bool, sizeof(T) == HeapWordSize&gt; { };
253 public:
254   template &lt;DecoratorSet decorators, typename T&gt;
255   static inline typename EnableIf&lt;
256     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value&gt;::type
257   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
258             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
259             size_t length) {
260     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
261     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
262 
263     // We do not check for ARRAYCOPY_ATOMIC for oops, because they are unconditionally always atomic.
264     if (HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value) {
265       AccessInternal::arraycopy_arrayof_conjoint_oops(src_raw, dst_raw, length);
266     } else {
267       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
268       AccessInternal::arraycopy_conjoint_oops(reinterpret_cast&lt;OopType*&gt;(src_raw),
269                                               reinterpret_cast&lt;OopType*&gt;(dst_raw), length);
270     }
271   }
272 
273   template &lt;DecoratorSet decorators, typename T&gt;
274   static inline typename EnableIf&lt;
275     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
276     HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value&gt;::type
277   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
278             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
279             size_t length) {
280     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
281     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
282 
283     AccessInternal::arraycopy_arrayof_conjoint(src_raw, dst_raw, length);
284   }
285 
286   template &lt;DecoratorSet decorators, typename T&gt;
287   static inline typename EnableIf&lt;
288     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
289     HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value&gt;::type
290   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
291             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
292             size_t length) {
293     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
294     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
295 
296     // There is only a disjoint optimization for word granularity copying
297     if (HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value) {
298       AccessInternal::arraycopy_disjoint_words_atomic(src_raw, dst_raw, length);
299     } else {
300       AccessInternal::arraycopy_disjoint_words(src_raw, dst_raw, length);
301     }
302   }
303 
304   template &lt;DecoratorSet decorators, typename T&gt;
305   static inline typename EnableIf&lt;
306     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
307     !(HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value) &amp;&amp;
308     !HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value &amp;&amp;
309     !HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value&gt;::type
310   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
311             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
312             size_t length) {
313     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
314     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
315 
316     AccessInternal::arraycopy_conjoint(src_raw, dst_raw, length);
317   }
318 
319   template &lt;DecoratorSet decorators, typename T&gt;
320   static inline typename EnableIf&lt;
321     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
322     !(HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value) &amp;&amp;
323     !HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value &amp;&amp;
324     HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value&gt;::type
325   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
326             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
327             size_t length) {
328     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
329     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
330 
331     AccessInternal::arraycopy_conjoint_atomic(src_raw, dst_raw, length);
332   }
333 };
334 
335 template&lt;&gt; struct RawAccessBarrierArrayCopy::IsHeapWordSized&lt;void&gt;: public IntegralConstant&lt;bool, false&gt; { };
336 
337 template &lt;DecoratorSet decorators&gt;
338 template &lt;typename T&gt;
339 inline bool RawAccessBarrier&lt;decorators&gt;::arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
340                                                     arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
341                                                     size_t length) {
342   RawAccessBarrierArrayCopy::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
343                                                    dst_obj, dst_offset_in_bytes, dst_raw,
344                                                    length);
345   return true;
346 }
347 
348 template &lt;DecoratorSet decorators&gt;
349 inline void RawAccessBarrier&lt;decorators&gt;::clone(oop src, oop dst, size_t size) {
350   // 4839641 (4840070): We must do an oop-atomic copy, because if another thread
351   // is modifying a reference field in the clonee, a non-oop-atomic copy might
352   // be suspended in the middle of copying the pointer and end up with parts
353   // of two different pointers in the field.  Subsequent dereferences will crash.
354   // 4846409: an oop-copy of objects with long or double fields or arrays of same
355   // won&#39;t copy the longs/doubles atomically in 32-bit vm&#39;s, so we copy jlongs instead
356   // of oops.  We know objects are aligned on a minimum of an jlong boundary.
357   // The same is true of StubRoutines::object_copy and the various oop_copy
358   // variants, and of the code generated by the inline_native_clone intrinsic.
359 
360   assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;objects misaligned&quot;);
361   AccessInternal::arraycopy_conjoint_atomic(reinterpret_cast&lt;jlong*&gt;((oopDesc*)src),
362                                             reinterpret_cast&lt;jlong*&gt;((oopDesc*)dst),
363                                             align_object_size(size) / HeapWordsPerLong);
364   // Clear the header
365   dst-&gt;init_mark_raw();
366 }
367 
368 #endif // SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
    </pre>
  </body>
</html>
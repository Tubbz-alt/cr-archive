<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/symbol.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbol.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="typeArrayKlass.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,11 +26,10 @@</span>
  #define SHARE_OOPS_SYMBOL_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/exceptions.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-removed">- #include &quot;utilities/utf8.hpp&quot;</span>
  
  // A Symbol is a canonicalized string.
  // All Symbols reside in global SymbolTable and are reference counted.
  
  // Reference counting
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,12 +130,12 @@</span>
      assert(index &gt;=0 &amp;&amp; index &lt; length(), &quot;symbol index overflow&quot;);
      _body[index] = value;
    }
  
    Symbol(const u1* name, int length, int refcount);
<span class="udiff-line-modified-removed">-   void* operator new(size_t size, int len, TRAPS) throw();</span>
<span class="udiff-line-modified-removed">-   void* operator new(size_t size, int len, Arena* arena, TRAPS) throw();</span>
<span class="udiff-line-modified-added">+   void* operator new(size_t size, int len) throw();</span>
<span class="udiff-line-modified-added">+   void* operator new(size_t size, int len, Arena* arena) throw();</span>
  
    void  operator delete(void* p);
  
    static int extract_length(uint32_t value)   { return value &gt;&gt; 16; }
    static int extract_refcount(uint32_t value) { return value &amp; 0xffff; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,10 +167,11 @@</span>
    void increment_refcount();
    void decrement_refcount();
    bool is_permanent() {
      return (refcount() == PERM_REFCOUNT);
    }
<span class="udiff-line-added">+   void set_permanent();</span>
    void make_permanent();
  
    // Function char_at() returns the Symbol&#39;s selected u1 byte as a char type.
    //
    // Note that all multi-byte chars have the sign bit set on all their bytes.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,24 +187,38 @@</span>
  
    // Compares the symbol with a string.
    bool equals(const char* str, int len) const {
      int l = utf8_length();
      if (l != len) return false;
<span class="udiff-line-modified-removed">-     while (l-- &gt; 0) {</span>
<span class="udiff-line-removed">-       if (str[l] != char_at(l))</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(l == -1, &quot;we should be at the beginning&quot;);</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-modified-added">+     return contains_utf8_at(0, str, len);</span>
    }
    bool equals(const char* str) const { return equals(str, (int) strlen(str)); }
  
    // Tests if the symbol starts with the given prefix.
<span class="udiff-line-modified-removed">-   bool starts_with(const char* prefix, int len) const;</span>
<span class="udiff-line-modified-added">+   bool starts_with(const char* prefix, int len) const {</span>
<span class="udiff-line-added">+     return contains_utf8_at(0, prefix, len);</span>
<span class="udiff-line-added">+   }</span>
    bool starts_with(const char* prefix) const {
      return starts_with(prefix, (int) strlen(prefix));
    }
<span class="udiff-line-added">+   bool starts_with(int prefix_char) const {</span>
<span class="udiff-line-added">+     return contains_byte_at(0, prefix_char);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Tests if the symbol ends with the given suffix.</span>
<span class="udiff-line-added">+   bool ends_with(const char* suffix, int len) const {</span>
<span class="udiff-line-added">+     return contains_utf8_at(utf8_length() - len, suffix, len);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   bool ends_with(const char* suffix) const {</span>
<span class="udiff-line-added">+     return ends_with(suffix, (int) strlen(suffix));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   bool ends_with(int suffix_char) const {</span>
<span class="udiff-line-added">+     return contains_byte_at(utf8_length()-1, suffix_char);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Tests if the symbol contains the given utf8 substring</span>
<span class="udiff-line-added">+   // or byte at the given byte position.</span>
<span class="udiff-line-added">+   bool contains_utf8_at(int position, const char* substring, int len) const;</span>
<span class="udiff-line-added">+   bool contains_byte_at(int position, char code_byte) const;</span>
  
    // Tests if the symbol starts with the given prefix.
    int index_of_at(int i, const char* str, int len) const;
  
    // Three-way compare for sorting; returns -1/0/1 if receiver is &lt;/==/&gt; than arg
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228,22 +242,31 @@</span>
    // String is allocated in resource area if buffer is not provided.
    // See Klass::external_name()
    const char* as_klass_external_name() const;
    const char* as_klass_external_name(char* buf, int size) const;
  
<span class="udiff-line-added">+   // Treating the symbol as a signature, print the return</span>
<span class="udiff-line-added">+   // type to the outputStream. Prints external names as &#39;double&#39; or</span>
<span class="udiff-line-added">+   // &#39;java.lang.Object[][]&#39;.</span>
<span class="udiff-line-added">+   void print_as_signature_external_return_type(outputStream *os);</span>
<span class="udiff-line-added">+   // Treating the symbol as a signature, print the parameter types</span>
<span class="udiff-line-added">+   // seperated by &#39;, &#39; to the outputStream.  Prints external names as</span>
<span class="udiff-line-added">+   //  &#39;double&#39; or &#39;java.lang.Object[][]&#39;.</span>
<span class="udiff-line-added">+   void print_as_signature_external_parameters(outputStream *os);</span>
<span class="udiff-line-added">+ </span>
    void metaspace_pointers_do(MetaspaceClosure* it);
    MetaspaceObj::Type type() const { return SymbolType; }
  
    // Printing
    void print_symbol_on(outputStream* st = NULL) const;
    void print_utf8_on(outputStream* st) const;
    void print_on(outputStream* st) const;         // First level print
    void print_value_on(outputStream* st) const;   // Second level print.
  
    // printing on default output stream
<span class="udiff-line-modified-removed">-   void print()         { print_on(tty);       }</span>
<span class="udiff-line-modified-removed">-   void print_value()   { print_value_on(tty); }</span>
<span class="udiff-line-modified-added">+   void print() const;</span>
<span class="udiff-line-modified-added">+   void print_value() const;</span>
  
    static bool is_valid(Symbol* s);
  
  #ifndef PRODUCT
    // Empty constructor to create a dummy symbol object on stack
</pre>
<center><a href="symbol.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="typeArrayKlass.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
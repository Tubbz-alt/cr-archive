<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/instanceRefKlass.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
 26 #define SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;oops/access.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 32 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
 33 #include &quot;oops/instanceKlass.inline.hpp&quot;
 34 #include &quot;oops/instanceRefKlass.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/globalDefinitions.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 
 40 template &lt;typename T, class OopClosureType, class Contains&gt;
 41 void InstanceRefKlass::do_referent(oop obj, OopClosureType* closure, Contains&amp; contains) {
 42   T* referent_addr = (T*)java_lang_ref_Reference::referent_addr_raw(obj);
 43   if (contains(referent_addr)) {
 44     Devirtualizer::do_oop(closure, referent_addr);
 45   }
 46 }
 47 
 48 template &lt;typename T, class OopClosureType, class Contains&gt;
 49 void InstanceRefKlass::do_discovered(oop obj, OopClosureType* closure, Contains&amp; contains) {
 50   T* discovered_addr = (T*)java_lang_ref_Reference::discovered_addr_raw(obj);
 51   if (contains(discovered_addr)) {
 52     Devirtualizer::do_oop(closure, discovered_addr);
 53   }
 54 }
 55 
 56 static inline oop load_referent(oop obj, ReferenceType type) {
 57   if (type == REF_PHANTOM) {
 58     return HeapAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(java_lang_ref_Reference::referent_addr_raw(obj));
 59   } else {
 60     return HeapAccess&lt;ON_WEAK_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(java_lang_ref_Reference::referent_addr_raw(obj));
 61   }
 62 }
 63 
 64 template &lt;typename T, class OopClosureType&gt;
 65 bool InstanceRefKlass::try_discover(oop obj, ReferenceType type, OopClosureType* closure) {
 66   ReferenceDiscoverer* rd = closure-&gt;ref_discoverer();
 67   if (rd != NULL) {
 68     oop referent = load_referent(obj, type);
 69     if (referent != NULL) {
 70       if (!referent-&gt;is_gc_marked()) {
 71         // Only try to discover if not yet marked.
 72         return rd-&gt;discover_reference(obj, type);
 73       }
 74     }
 75   }
 76   return false;
 77 }
 78 
 79 template &lt;typename T, class OopClosureType, class Contains&gt;
 80 void InstanceRefKlass::oop_oop_iterate_discovery(oop obj, ReferenceType type, OopClosureType* closure, Contains&amp; contains) {
 81   // Try to discover reference and return if it succeeds.
 82   if (try_discover&lt;T&gt;(obj, type, closure)) {
 83     return;
 84   }
 85 
 86   // Treat referent and discovered as normal oops.
 87   do_referent&lt;T&gt;(obj, closure, contains);
 88   do_discovered&lt;T&gt;(obj, closure, contains);
 89 }
 90 
 91 template &lt;typename T, class OopClosureType, class Contains&gt;
 92 void InstanceRefKlass::oop_oop_iterate_discovered_and_discovery(oop obj, ReferenceType type, OopClosureType* closure, Contains&amp; contains) {
 93   // Explicitly apply closure to the discovered field.
 94   do_discovered&lt;T&gt;(obj, closure, contains);
 95   // Then do normal reference processing with discovery.
 96   oop_oop_iterate_discovery&lt;T&gt;(obj, type, closure, contains);
 97 }
 98 
 99 template &lt;typename T, class OopClosureType, class Contains&gt;
100 void InstanceRefKlass::oop_oop_iterate_fields(oop obj, OopClosureType* closure, Contains&amp; contains) {
101   assert(closure-&gt;ref_discoverer() == NULL, &quot;ReferenceDiscoverer should not be set&quot;);
102   do_referent&lt;T&gt;(obj, closure, contains);
103   do_discovered&lt;T&gt;(obj, closure, contains);
104 }
105 
106 template &lt;typename T, class OopClosureType, class Contains&gt;
107 void InstanceRefKlass::oop_oop_iterate_fields_except_referent(oop obj, OopClosureType* closure, Contains&amp; contains) {
108   assert(closure-&gt;ref_discoverer() == NULL, &quot;ReferenceDiscoverer should not be set&quot;);
109   do_discovered&lt;T&gt;(obj, closure, contains);
110 }
111 
112 template &lt;typename T, class OopClosureType, class Contains&gt;
113 void InstanceRefKlass::oop_oop_iterate_ref_processing(oop obj, OopClosureType* closure, Contains&amp; contains) {
114   switch (closure-&gt;reference_iteration_mode()) {
115     case OopIterateClosure::DO_DISCOVERY:
116       trace_reference_gc&lt;T&gt;(&quot;do_discovery&quot;, obj);
117       oop_oop_iterate_discovery&lt;T&gt;(obj, reference_type(), closure, contains);
118       break;
119     case OopIterateClosure::DO_DISCOVERED_AND_DISCOVERY:
120       trace_reference_gc&lt;T&gt;(&quot;do_discovered_and_discovery&quot;, obj);
121       oop_oop_iterate_discovered_and_discovery&lt;T&gt;(obj, reference_type(), closure, contains);
122       break;
123     case OopIterateClosure::DO_FIELDS:
124       trace_reference_gc&lt;T&gt;(&quot;do_fields&quot;, obj);
125       oop_oop_iterate_fields&lt;T&gt;(obj, closure, contains);
126       break;
127     case OopIterateClosure::DO_FIELDS_EXCEPT_REFERENT:
128       trace_reference_gc&lt;T&gt;(&quot;do_fields_except_referent&quot;, obj);
129       oop_oop_iterate_fields_except_referent&lt;T&gt;(obj, closure, contains);
130       break;
131     default:
132       ShouldNotReachHere();
133   }
134 }
135 
136 class AlwaysContains {
137  public:
138   template &lt;typename T&gt; bool operator()(T* p) const { return true; }
139 };
140 
141 template &lt;typename T, class OopClosureType&gt;
142 void InstanceRefKlass::oop_oop_iterate_ref_processing(oop obj, OopClosureType* closure) {
143   AlwaysContains always_contains;
144   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure, always_contains);
145 }
146 
147 class MrContains {
148   const MemRegion _mr;
149  public:
150   MrContains(MemRegion mr) : _mr(mr) {}
151   template &lt;typename T&gt; bool operator()(T* p) const { return _mr.contains(p); }
152 };
153 
154 template &lt;typename T, class OopClosureType&gt;
155 void InstanceRefKlass::oop_oop_iterate_ref_processing_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
156   const MrContains contains(mr);
157   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure, contains);
158 }
159 
160 template &lt;typename T, class OopClosureType&gt;
161 void InstanceRefKlass::oop_oop_iterate(oop obj, OopClosureType* closure) {
162   InstanceKlass::oop_oop_iterate&lt;T&gt;(obj, closure);
163 
164   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure);
165 }
166 
167 template &lt;typename T, class OopClosureType&gt;
168 void InstanceRefKlass::oop_oop_iterate_reverse(oop obj, OopClosureType* closure) {
169   InstanceKlass::oop_oop_iterate_reverse&lt;T&gt;(obj, closure);
170 
171   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure);
172 }
173 
174 template &lt;typename T, class OopClosureType&gt;
175 void InstanceRefKlass::oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
176   InstanceKlass::oop_oop_iterate_bounded&lt;T&gt;(obj, closure, mr);
177 
178   oop_oop_iterate_ref_processing_bounded&lt;T&gt;(obj, closure, mr);
179 }
180 
181 #ifdef ASSERT
182 template &lt;typename T&gt;
183 void InstanceRefKlass::trace_reference_gc(const char *s, oop obj) {
184   T* referent_addr   = (T*) java_lang_ref_Reference::referent_addr_raw(obj);
185   T* discovered_addr = (T*) java_lang_ref_Reference::discovered_addr_raw(obj);
186 
187   log_develop_trace(gc, ref)(&quot;InstanceRefKlass %s for obj &quot; PTR_FORMAT, s, p2i(obj));
188   if (java_lang_ref_Reference::is_phantom(obj)) {
189     log_develop_trace(gc, ref)(&quot;     referent_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
190                                p2i(referent_addr), p2i((oop)HeapAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(referent_addr)));
191   } else {
192     log_develop_trace(gc, ref)(&quot;     referent_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
193                                p2i(referent_addr), p2i((oop)HeapAccess&lt;ON_WEAK_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(referent_addr)));
194   }
195   log_develop_trace(gc, ref)(&quot;     discovered_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
196       p2i(discovered_addr), p2i((oop)HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(discovered_addr)));
197 }
198 #endif
199 
200 #endif // SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
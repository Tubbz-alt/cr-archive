<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_HPP
 26 #define SHARE_OOPS_OOP_HPP
 27 
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;

 31 #include &quot;oops/metadata.hpp&quot;
 32 #include &quot;runtime/atomic.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
 36 // the format of Java objects so the fields can be accessed from C++.
 37 // oopDesc is abstract.
 38 // (see oopHierarchy for complete oop class hierarchy)
 39 //
 40 // no virtual functions allowed
 41 
<span class="line-removed"> 42 extern bool always_do_update_barrier;</span>
<span class="line-removed"> 43 </span>
 44 // Forward declarations.
 45 class OopClosure;
 46 class ScanClosure;
 47 class FastScanClosure;
 48 class FilteringClosure;
<span class="line-removed"> 49 class CMSIsAliveClosure;</span>
 50 
 51 class PSPromotionManager;
 52 class ParCompactionManager;
 53 
 54 class oopDesc {
 55   friend class VMStructs;
 56   friend class JVMCIVMStructs;
 57  private:
<span class="line-modified"> 58   volatile markOop _mark;</span>
 59   union _metadata {
 60     Klass*      _klass;
 61     narrowKlass _compressed_klass;
 62   } _metadata;
 63 
 64  public:
<span class="line-modified"> 65   inline markOop  mark()          const;</span>
<span class="line-modified"> 66   inline markOop  mark_raw()      const;</span>
<span class="line-modified"> 67   inline markOop* mark_addr_raw() const;</span>
 68 
<span class="line-modified"> 69   inline void set_mark(volatile markOop m);</span>
<span class="line-modified"> 70   inline void set_mark_raw(volatile markOop m);</span>
<span class="line-modified"> 71   static inline void set_mark_raw(HeapWord* mem, markOop m);</span>
 72 
<span class="line-modified"> 73   inline void release_set_mark(markOop m);</span>
<span class="line-modified"> 74   inline markOop cas_set_mark(markOop new_mark, markOop old_mark);</span>
<span class="line-modified"> 75   inline markOop cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative);</span>
 76 
 77   // Used only to re-initialize the mark word (e.g., of promoted
 78   // objects during a GC) -- requires a valid klass pointer
 79   inline void init_mark();
 80   inline void init_mark_raw();
 81 
 82   inline Klass* klass() const;
 83   inline Klass* klass_or_null() const volatile;
 84   inline Klass* klass_or_null_acquire() const volatile;
 85   static inline Klass** klass_addr(HeapWord* mem);
 86   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
 87   inline Klass** klass_addr();
 88   inline narrowKlass* compressed_klass_addr();
 89 
 90   inline void set_klass(Klass* k);
 91   static inline void release_set_klass(HeapWord* mem, Klass* klass);
 92 
 93   // For klass field compression
 94   inline int klass_gap() const;
 95   inline void set_klass_gap(int z);
 96   static inline void set_klass_gap(HeapWord* mem, int z);
<span class="line-removed"> 97   // For when the klass pointer is being used as a linked list &quot;next&quot; field.</span>
<span class="line-removed"> 98   inline void set_klass_to_list_ptr(oop k);</span>
<span class="line-removed"> 99   inline oop list_ptr_from_klass();</span>
100 
101   // size of object header, aligned to platform wordSize
102   static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
103 
104   // Returns whether this is an instance of k or an instance of a subclass of k
105   inline bool is_a(Klass* k) const;
106 
107   // Returns the actual oop size of the object
108   inline int size();
109 
110   // Sometimes (for complicated concurrency-related reasons), it is useful
111   // to be able to figure out the size of an object knowing its klass.
112   inline int size_given_klass(Klass* klass);
113 
114   // type test operations (inlined in oop.inline.hpp)
115   inline bool is_instance()            const;
116   inline bool is_array()               const;
117   inline bool is_objArray()            const;
118   inline bool is_typeArray()           const;
119 
</pre>
<hr />
<pre>
134   // Need this as public for garbage collection.
135   template &lt;class T&gt; inline T* obj_field_addr_raw(int offset) const;
136 
137   template &lt;typename T&gt; inline size_t field_offset(T* p) const;
138 
139   // Standard compare function returns negative value if o1 &lt; o2
140   //                                   0              if o1 == o2
141   //                                   positive value if o1 &gt; o2
142   inline static int  compare(oop o1, oop o2) {
143     void* o1_addr = (void*)o1;
144     void* o2_addr = (void*)o2;
145     if (o1_addr &lt; o2_addr) {
146       return -1;
147     } else if (o1_addr &gt; o2_addr) {
148       return 1;
149     } else {
150       return 0;
151     }
152   }
153 
<span class="line-removed">154   inline static bool equals(oop o1, oop o2) { return Access&lt;&gt;::equals(o1, o2); }</span>
<span class="line-removed">155 </span>
<span class="line-removed">156   inline static bool equals_raw(oop o1, oop o2) { return RawAccess&lt;&gt;::equals(o1, o2); }</span>
<span class="line-removed">157 </span>
158   // Access to fields in a instanceOop through these methods.
159   template &lt;DecoratorSet decorator&gt;
160   oop obj_field_access(int offset) const;
161   oop obj_field(int offset) const;
162   void obj_field_put(int offset, oop value);
163   void obj_field_put_raw(int offset, oop value);
164   void obj_field_put_volatile(int offset, oop value);
165 
166   Metadata* metadata_field(int offset) const;
167   Metadata* metadata_field_raw(int offset) const;
168   void metadata_field_put(int offset, Metadata* value);
169 
170   Metadata* metadata_field_acquire(int offset) const;
171   void release_metadata_field_put(int offset, Metadata* value);
172 
173   jbyte byte_field(int offset) const;
174   void byte_field_put(int offset, jbyte contents);
175 
176   jchar char_field(int offset) const;
177   void char_field_put(int offset, jchar contents);
178 
179   jboolean bool_field(int offset) const;
180   void bool_field_put(int offset, jboolean contents);


181 
182   jint int_field(int offset) const;
183   jint int_field_raw(int offset) const;
184   void int_field_put(int offset, jint contents);
185 
186   jshort short_field(int offset) const;
187   void short_field_put(int offset, jshort contents);
188 
189   jlong long_field(int offset) const;
190   void long_field_put(int offset, jlong contents);
191 
192   jfloat float_field(int offset) const;
193   void float_field_put(int offset, jfloat contents);
194 
195   jdouble double_field(int offset) const;
196   void double_field_put(int offset, jdouble contents);
197 
198   address address_field(int offset) const;
199   void address_field_put(int offset, address contents);
200 
</pre>
<hr />
<pre>
238   void print_value();
239   void print_address();
240 
241   // return the print strings
242   char* print_string();
243   char* print_value_string();
244 
245   // verification operations
246   static void verify_on(outputStream* st, oopDesc* oop_desc);
247   static void verify(oopDesc* oopDesc);
248 
249   // locking operations
250   inline bool is_locked()   const;
251   inline bool is_unlocked() const;
252   inline bool has_bias_pattern() const;
253   inline bool has_bias_pattern_raw() const;
254 
255   // asserts and guarantees
256   static bool is_oop(oop obj, bool ignore_mark_word = false);
257   static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);
<span class="line-removed">258 #ifndef PRODUCT</span>
<span class="line-removed">259   inline bool is_unlocked_oop() const;</span>
<span class="line-removed">260   static bool is_archived_object(oop p) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
<span class="line-removed">261 #endif</span>
262 
263   // garbage collection
264   inline bool is_gc_marked() const;
265 
266   // Forward pointer operations for scavenge
267   inline bool is_forwarded() const;
268 


269   inline void forward_to(oop p);
<span class="line-modified">270   inline bool cas_forward_to(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);</span>
271 
272   // Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.
273   // Exactly one thread succeeds in inserting the forwarding pointer, and
274   // this call returns &quot;NULL&quot; for that thread; any other thread has the
275   // value of the forwarding pointer returned and does not modify &quot;this&quot;.
<span class="line-modified">276   inline oop forward_to_atomic(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);</span>
277 
278   inline oop forwardee() const;
279   inline oop forwardee_acquire() const;
280 
281   // Age of object during scavenge
282   inline uint age() const;
283   inline void incr_age();
284 
285   // mark-sweep support
286   void follow_body(int begin, int end);
287 
288   template &lt;typename OopClosureType&gt;
289   inline void oop_iterate(OopClosureType* cl);
290 
291   template &lt;typename OopClosureType&gt;
292   inline void oop_iterate(OopClosureType* cl, MemRegion mr);
293 
294   template &lt;typename OopClosureType&gt;
295   inline int oop_iterate_size(OopClosureType* cl);
296 
297   template &lt;typename OopClosureType&gt;
298   inline int oop_iterate_size(OopClosureType* cl, MemRegion mr);
299 
300   template &lt;typename OopClosureType&gt;
301   inline void oop_iterate_backwards(OopClosureType* cl);
302 
303   inline static bool is_instanceof_or_null(oop obj, Klass* klass);
304 
305   // identity hash; returns the identity hash key (computes it if necessary)
306   // NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a
307   // safepoint if called on a biased object. Calling code must be aware of that.
308   inline intptr_t identity_hash();
309   intptr_t slow_identity_hash();
310 
311   // marks are forwarded to stack when object is locked
<span class="line-modified">312   inline bool    has_displaced_mark_raw() const;</span>
<span class="line-modified">313   inline markOop displaced_mark_raw() const;</span>
<span class="line-modified">314   inline void    set_displaced_mark_raw(markOop m);</span>





315 
316   static bool has_klass_gap();
317 
318   // for code generation
319   static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }
320   static int klass_offset_in_bytes()     { return offset_of(oopDesc, _metadata._klass); }
321   static int klass_gap_offset_in_bytes() {
322     assert(has_klass_gap(), &quot;only applicable to compressed klass pointers&quot;);
323     return klass_offset_in_bytes() + sizeof(narrowKlass);
324   }
325 
326   // for error reporting
<span class="line-removed">327   static oop   decode_oop_raw(narrowOop narrow_oop);</span>
328   static void* load_klass_raw(oop obj);
329   static void* load_oop_raw(oop obj, int offset);
<span class="line-removed">330   static bool  is_valid(oop obj);</span>
<span class="line-removed">331   static oop   oop_or_null(address addr);</span>
332 };
333 
334 #endif // SHARE_OOPS_OOP_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_HPP
 26 #define SHARE_OOPS_OOP_HPP
 27 
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
<span class="line-added"> 31 #include &quot;oops/markWord.hpp&quot;</span>
 32 #include &quot;oops/metadata.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
 37 // the format of Java objects so the fields can be accessed from C++.
 38 // oopDesc is abstract.
 39 // (see oopHierarchy for complete oop class hierarchy)
 40 //
 41 // no virtual functions allowed
 42 


 43 // Forward declarations.
 44 class OopClosure;
 45 class ScanClosure;
 46 class FastScanClosure;
 47 class FilteringClosure;

 48 
 49 class PSPromotionManager;
 50 class ParCompactionManager;
 51 
 52 class oopDesc {
 53   friend class VMStructs;
 54   friend class JVMCIVMStructs;
 55  private:
<span class="line-modified"> 56   volatile markWord _mark;</span>
 57   union _metadata {
 58     Klass*      _klass;
 59     narrowKlass _compressed_klass;
 60   } _metadata;
 61 
 62  public:
<span class="line-modified"> 63   inline markWord  mark()          const;</span>
<span class="line-modified"> 64   inline markWord  mark_raw()      const;</span>
<span class="line-modified"> 65   inline markWord* mark_addr_raw() const;</span>
 66 
<span class="line-modified"> 67   inline void set_mark(volatile markWord m);</span>
<span class="line-modified"> 68   inline void set_mark_raw(volatile markWord m);</span>
<span class="line-modified"> 69   static inline void set_mark_raw(HeapWord* mem, markWord m);</span>
 70 
<span class="line-modified"> 71   inline void release_set_mark(markWord m);</span>
<span class="line-modified"> 72   inline markWord cas_set_mark(markWord new_mark, markWord old_mark);</span>
<span class="line-modified"> 73   inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);</span>
 74 
 75   // Used only to re-initialize the mark word (e.g., of promoted
 76   // objects during a GC) -- requires a valid klass pointer
 77   inline void init_mark();
 78   inline void init_mark_raw();
 79 
 80   inline Klass* klass() const;
 81   inline Klass* klass_or_null() const volatile;
 82   inline Klass* klass_or_null_acquire() const volatile;
 83   static inline Klass** klass_addr(HeapWord* mem);
 84   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
 85   inline Klass** klass_addr();
 86   inline narrowKlass* compressed_klass_addr();
 87 
 88   inline void set_klass(Klass* k);
 89   static inline void release_set_klass(HeapWord* mem, Klass* klass);
 90 
 91   // For klass field compression
 92   inline int klass_gap() const;
 93   inline void set_klass_gap(int z);
 94   static inline void set_klass_gap(HeapWord* mem, int z);



 95 
 96   // size of object header, aligned to platform wordSize
 97   static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
 98 
 99   // Returns whether this is an instance of k or an instance of a subclass of k
100   inline bool is_a(Klass* k) const;
101 
102   // Returns the actual oop size of the object
103   inline int size();
104 
105   // Sometimes (for complicated concurrency-related reasons), it is useful
106   // to be able to figure out the size of an object knowing its klass.
107   inline int size_given_klass(Klass* klass);
108 
109   // type test operations (inlined in oop.inline.hpp)
110   inline bool is_instance()            const;
111   inline bool is_array()               const;
112   inline bool is_objArray()            const;
113   inline bool is_typeArray()           const;
114 
</pre>
<hr />
<pre>
129   // Need this as public for garbage collection.
130   template &lt;class T&gt; inline T* obj_field_addr_raw(int offset) const;
131 
132   template &lt;typename T&gt; inline size_t field_offset(T* p) const;
133 
134   // Standard compare function returns negative value if o1 &lt; o2
135   //                                   0              if o1 == o2
136   //                                   positive value if o1 &gt; o2
137   inline static int  compare(oop o1, oop o2) {
138     void* o1_addr = (void*)o1;
139     void* o2_addr = (void*)o2;
140     if (o1_addr &lt; o2_addr) {
141       return -1;
142     } else if (o1_addr &gt; o2_addr) {
143       return 1;
144     } else {
145       return 0;
146     }
147   }
148 




149   // Access to fields in a instanceOop through these methods.
150   template &lt;DecoratorSet decorator&gt;
151   oop obj_field_access(int offset) const;
152   oop obj_field(int offset) const;
153   void obj_field_put(int offset, oop value);
154   void obj_field_put_raw(int offset, oop value);
155   void obj_field_put_volatile(int offset, oop value);
156 
157   Metadata* metadata_field(int offset) const;
158   Metadata* metadata_field_raw(int offset) const;
159   void metadata_field_put(int offset, Metadata* value);
160 
161   Metadata* metadata_field_acquire(int offset) const;
162   void release_metadata_field_put(int offset, Metadata* value);
163 
164   jbyte byte_field(int offset) const;
165   void byte_field_put(int offset, jbyte contents);
166 
167   jchar char_field(int offset) const;
168   void char_field_put(int offset, jchar contents);
169 
170   jboolean bool_field(int offset) const;
171   void bool_field_put(int offset, jboolean contents);
<span class="line-added">172   jboolean bool_field_volatile(int offset) const;</span>
<span class="line-added">173   void bool_field_put_volatile(int offset, jboolean contents);</span>
174 
175   jint int_field(int offset) const;
176   jint int_field_raw(int offset) const;
177   void int_field_put(int offset, jint contents);
178 
179   jshort short_field(int offset) const;
180   void short_field_put(int offset, jshort contents);
181 
182   jlong long_field(int offset) const;
183   void long_field_put(int offset, jlong contents);
184 
185   jfloat float_field(int offset) const;
186   void float_field_put(int offset, jfloat contents);
187 
188   jdouble double_field(int offset) const;
189   void double_field_put(int offset, jdouble contents);
190 
191   address address_field(int offset) const;
192   void address_field_put(int offset, address contents);
193 
</pre>
<hr />
<pre>
231   void print_value();
232   void print_address();
233 
234   // return the print strings
235   char* print_string();
236   char* print_value_string();
237 
238   // verification operations
239   static void verify_on(outputStream* st, oopDesc* oop_desc);
240   static void verify(oopDesc* oopDesc);
241 
242   // locking operations
243   inline bool is_locked()   const;
244   inline bool is_unlocked() const;
245   inline bool has_bias_pattern() const;
246   inline bool has_bias_pattern_raw() const;
247 
248   // asserts and guarantees
249   static bool is_oop(oop obj, bool ignore_mark_word = false);
250   static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);




251 
252   // garbage collection
253   inline bool is_gc_marked() const;
254 
255   // Forward pointer operations for scavenge
256   inline bool is_forwarded() const;
257 
<span class="line-added">258   void verify_forwardee(oop forwardee) NOT_DEBUG_RETURN;</span>
<span class="line-added">259 </span>
260   inline void forward_to(oop p);
<span class="line-modified">261   inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);</span>
262 
263   // Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.
264   // Exactly one thread succeeds in inserting the forwarding pointer, and
265   // this call returns &quot;NULL&quot; for that thread; any other thread has the
266   // value of the forwarding pointer returned and does not modify &quot;this&quot;.
<span class="line-modified">267   inline oop forward_to_atomic(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);</span>
268 
269   inline oop forwardee() const;
270   inline oop forwardee_acquire() const;
271 
272   // Age of object during scavenge
273   inline uint age() const;
274   inline void incr_age();
275 
276   // mark-sweep support
277   void follow_body(int begin, int end);
278 
279   template &lt;typename OopClosureType&gt;
280   inline void oop_iterate(OopClosureType* cl);
281 
282   template &lt;typename OopClosureType&gt;
283   inline void oop_iterate(OopClosureType* cl, MemRegion mr);
284 
285   template &lt;typename OopClosureType&gt;
286   inline int oop_iterate_size(OopClosureType* cl);
287 
288   template &lt;typename OopClosureType&gt;
289   inline int oop_iterate_size(OopClosureType* cl, MemRegion mr);
290 
291   template &lt;typename OopClosureType&gt;
292   inline void oop_iterate_backwards(OopClosureType* cl);
293 
294   inline static bool is_instanceof_or_null(oop obj, Klass* klass);
295 
296   // identity hash; returns the identity hash key (computes it if necessary)
297   // NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a
298   // safepoint if called on a biased object. Calling code must be aware of that.
299   inline intptr_t identity_hash();
300   intptr_t slow_identity_hash();
301 
302   // marks are forwarded to stack when object is locked
<span class="line-modified">303   inline bool     has_displaced_mark_raw() const;</span>
<span class="line-modified">304   inline markWord displaced_mark_raw() const;</span>
<span class="line-modified">305   inline void     set_displaced_mark_raw(markWord m);</span>
<span class="line-added">306 </span>
<span class="line-added">307   // Checks if the mark word needs to be preserved</span>
<span class="line-added">308   inline bool mark_must_be_preserved() const;</span>
<span class="line-added">309   inline bool mark_must_be_preserved(markWord m) const;</span>
<span class="line-added">310   inline bool mark_must_be_preserved_for_promotion_failure(markWord m) const;</span>
311 
312   static bool has_klass_gap();
313 
314   // for code generation
315   static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }
316   static int klass_offset_in_bytes()     { return offset_of(oopDesc, _metadata._klass); }
317   static int klass_gap_offset_in_bytes() {
318     assert(has_klass_gap(), &quot;only applicable to compressed klass pointers&quot;);
319     return klass_offset_in_bytes() + sizeof(narrowKlass);
320   }
321 
322   // for error reporting

323   static void* load_klass_raw(oop obj);
324   static void* load_oop_raw(oop obj, int offset);


325 };
326 
327 #endif // SHARE_OOPS_OOP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="oop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
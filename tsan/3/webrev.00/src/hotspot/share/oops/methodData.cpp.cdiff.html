<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/methodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,21 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-removed">- #include &quot;memory/heapInspection.hpp&quot;</span>
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/methodData.inline.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-new-header">--- 22,21 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/methodData.inline.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,12 ***</span>
  
  int TypeStackSlotEntries::compute_cell_count(Symbol* signature, bool include_receiver, int max) {
    // Parameter profiling include the receiver
    int args_count = include_receiver ? 1 : 0;
    ResourceMark rm;
<span class="line-modified">!   SignatureStream ss(signature);</span>
<span class="line-modified">!   args_count += ss.reference_parameter_count();</span>
    args_count = MIN2(args_count, max);
    return args_count * per_arg_cell_count;
  }
  
  int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
<span class="line-new-header">--- 197,12 ---</span>
  
  int TypeStackSlotEntries::compute_cell_count(Symbol* signature, bool include_receiver, int max) {
    // Parameter profiling include the receiver
    int args_count = include_receiver ? 1 : 0;
    ResourceMark rm;
<span class="line-modified">!   ReferenceArgumentCount rac(signature);</span>
<span class="line-modified">!   args_count += rac.count();</span>
    args_count = MIN2(args_count, max);
    return args_count * per_arg_cell_count;
  }
  
  int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,47 ***</span>
    int args_cell = 0;
    if (MethodData::profile_arguments_for_invoke(m, bci)) {
      args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
    }
    int ret_cell = 0;
<span class="line-modified">!   if (MethodData::profile_return_for_invoke(m, bci) &amp;&amp; (inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY)) {</span>
      ret_cell = ReturnTypeEntry::static_cell_count();
    }
    int header_cell = 0;
    if (args_cell + ret_cell &gt; 0) {
      header_cell = header_cell_count();
    }
  
    return header_cell + args_cell + ret_cell;
  }
  
<span class="line-modified">! class ArgumentOffsetComputer : public SignatureInfo {</span>
  private:
    int _max;
    GrowableArray&lt;int&gt; _offsets;
  
<span class="line-modified">!   void set(int size, BasicType type) { _size += size; }</span>
<span class="line-modified">!   void do_object(int begin, int end) {</span>
<span class="line-modified">!     if (_offsets.length() &lt; _max) {</span>
<span class="line-modified">!       _offsets.push(_size);</span>
      }
<span class="line-modified">!     SignatureInfo::do_object(begin, end);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   void do_array (int begin, int end) {</span>
<span class="line-removed">-     if (_offsets.length() &lt; _max) {</span>
<span class="line-removed">-       _offsets.push(_size);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     SignatureInfo::do_array(begin, end);</span>
    }
  
<span class="line-modified">! public:</span>
    ArgumentOffsetComputer(Symbol* signature, int max)
<span class="line-modified">!     : SignatureInfo(signature), _max(max), _offsets(Thread::current(), max) {</span>
    }
  
<span class="line-removed">-   int total() { lazy_iterate_parameters(); return _size; }</span>
<span class="line-removed">- </span>
    int off_at(int i) const { return _offsets.at(i); }
  };
  
  void TypeStackSlotEntries::post_initialize(Symbol* signature, bool has_receiver, bool include_receiver) {
    ResourceMark rm;
<span class="line-new-header">--- 214,43 ---</span>
    int args_cell = 0;
    if (MethodData::profile_arguments_for_invoke(m, bci)) {
      args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
    }
    int ret_cell = 0;
<span class="line-modified">!   if (MethodData::profile_return_for_invoke(m, bci) &amp;&amp; is_reference_type(inv.result_type())) {</span>
      ret_cell = ReturnTypeEntry::static_cell_count();
    }
    int header_cell = 0;
    if (args_cell + ret_cell &gt; 0) {
      header_cell = header_cell_count();
    }
  
    return header_cell + args_cell + ret_cell;
  }
  
<span class="line-modified">! class ArgumentOffsetComputer : public SignatureIterator {</span>
  private:
    int _max;
<span class="line-added">+   int _offset;</span>
    GrowableArray&lt;int&gt; _offsets;
  
<span class="line-modified">!   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">!   void do_type(BasicType type) {</span>
<span class="line-modified">!     if (is_reference_type(type) &amp;&amp; _offsets.length() &lt; _max) {</span>
<span class="line-modified">!       _offsets.push(_offset);</span>
      }
<span class="line-modified">!     _offset += parameter_type_word_count(type);</span>
    }
  
<span class="line-modified">!  public:</span>
    ArgumentOffsetComputer(Symbol* signature, int max)
<span class="line-modified">!     : SignatureIterator(signature),</span>
<span class="line-added">+       _max(max), _offset(0),</span>
<span class="line-added">+       _offsets(Thread::current(), max) {</span>
<span class="line-added">+     do_parameters_on(this);  // non-virtual template execution</span>
    }
  
    int off_at(int i) const { return _offsets.at(i); }
  };
  
  void TypeStackSlotEntries::post_initialize(Symbol* signature, bool has_receiver, bool include_receiver) {
    ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,34 ***</span>
      set_stack_slot(0, 0);
      set_type(0, type_none());
      start += 1;
    }
    ArgumentOffsetComputer aos(signature, _number_of_entries-start);
<span class="line-removed">-   aos.total();</span>
    for (int i = start; i &lt; _number_of_entries; i++) {
      set_stack_slot(i, aos.off_at(i-start) + (has_receiver ? 1 : 0));
      set_type(i, type_none());
    }
  }
  
  void CallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
    assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
    Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
  
<span class="line-removed">-   SignatureStream ss(inv.signature());</span>
    if (has_arguments()) {
  #ifdef ASSERT
      ResourceMark rm;
<span class="line-modified">!     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>
      assert(count &gt; 0, &quot;room for args type but none found?&quot;);
      check_number_of_arguments(count);
  #endif
      _args.post_initialize(inv.signature(), inv.has_receiver(), false);
    }
  
    if (has_return()) {
<span class="line-modified">!     assert(inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY, &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
      _ret.post_initialize();
    }
  }
  
  void VirtualCallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
<span class="line-new-header">--- 260,33 ---</span>
      set_stack_slot(0, 0);
      set_type(0, type_none());
      start += 1;
    }
    ArgumentOffsetComputer aos(signature, _number_of_entries-start);
    for (int i = start; i &lt; _number_of_entries; i++) {
      set_stack_slot(i, aos.off_at(i-start) + (has_receiver ? 1 : 0));
      set_type(i, type_none());
    }
  }
  
  void CallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
    assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
    Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
  
    if (has_arguments()) {
  #ifdef ASSERT
      ResourceMark rm;
<span class="line-modified">!     ReferenceArgumentCount rac(inv.signature());</span>
<span class="line-added">+     int count = MIN2(rac.count(), (int)TypeProfileArgsLimit);</span>
      assert(count &gt; 0, &quot;room for args type but none found?&quot;);
      check_number_of_arguments(count);
  #endif
      _args.post_initialize(inv.signature(), inv.has_receiver(), false);
    }
  
    if (has_return()) {
<span class="line-modified">!     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
      _ret.post_initialize();
    }
  }
  
  void VirtualCallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,20 ***</span>
    Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
  
    if (has_arguments()) {
  #ifdef ASSERT
      ResourceMark rm;
<span class="line-modified">!     SignatureStream ss(inv.signature());</span>
<span class="line-modified">!     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>
      assert(count &gt; 0, &quot;room for args type but none found?&quot;);
      check_number_of_arguments(count);
  #endif
      _args.post_initialize(inv.signature(), inv.has_receiver(), false);
    }
  
    if (has_return()) {
<span class="line-modified">!     assert(inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY, &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
      _ret.post_initialize();
    }
  }
  
  void TypeStackSlotEntries::clean_weak_klass_links(bool always_clean) {
<span class="line-new-header">--- 294,20 ---</span>
    Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
  
    if (has_arguments()) {
  #ifdef ASSERT
      ResourceMark rm;
<span class="line-modified">!     ReferenceArgumentCount rac(inv.signature());</span>
<span class="line-modified">!     int count = MIN2(rac.count(), (int)TypeProfileArgsLimit);</span>
      assert(count &gt; 0, &quot;room for args type but none found?&quot;);
      check_number_of_arguments(count);
  #endif
      _args.post_initialize(inv.signature(), inv.has_receiver(), false);
    }
  
    if (has_return()) {
<span class="line-modified">!     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
      _ret.post_initialize();
    }
  }
  
  void TypeStackSlotEntries::clean_weak_klass_links(bool always_clean) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,11 ***</span>
    }
    st-&gt;cr();
  }
  
  int ParametersTypeData::compute_cell_count(Method* m) {
<span class="line-modified">!   if (!MethodData::profile_parameters_for_method(m)) {</span>
      return 0;
    }
    int max = TypeProfileParmsLimit == -1 ? INT_MAX : TypeProfileParmsLimit;
    int obj_args = TypeStackSlotEntries::compute_cell_count(m-&gt;signature(), !m-&gt;is_static(), max);
    if (obj_args &gt; 0) {
<span class="line-new-header">--- 661,11 ---</span>
    }
    st-&gt;cr();
  }
  
  int ParametersTypeData::compute_cell_count(Method* m) {
<span class="line-modified">!   if (!MethodData::profile_parameters_for_method(methodHandle(Thread::current(), m))) {</span>
      return 0;
    }
    int max = TypeProfileParmsLimit == -1 ? INT_MAX : TypeProfileParmsLimit;
    int obj_args = TypeStackSlotEntries::compute_cell_count(m-&gt;signature(), !m-&gt;is_static(), max);
    if (obj_args &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,11 ***</span>
  
  MethodData* MethodData::allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS) {
    int size = MethodData::compute_allocation_size_in_words(method);
  
    return new (loader_data, size, MetaspaceObj::MethodDataType, THREAD)
<span class="line-modified">!     MethodData(method(), size, THREAD);</span>
  }
  
  int MethodData::bytecode_cell_count(Bytecodes::Code code) {
    if (is_client_compilation_mode_vm()) {
      return no_profile_data;
<span class="line-new-header">--- 702,11 ---</span>
  
  MethodData* MethodData::allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS) {
    int size = MethodData::compute_allocation_size_in_words(method);
  
    return new (loader_data, size, MetaspaceObj::MethodDataType, THREAD)
<span class="line-modified">!     MethodData(method, size, THREAD);</span>
  }
  
  int MethodData::bytecode_cell_count(Bytecodes::Code code) {
    if (is_client_compilation_mode_vm()) {
      return no_profile_data;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,10 ***</span>
<span class="line-new-header">--- 839,90 ---</span>
      return false;
    }
    return false;
  }
  
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ </span>
<span class="line-added">+ void* FailedSpeculation::operator new(size_t size, size_t fs_size) throw() {</span>
<span class="line-added">+   return CHeapObj&lt;mtCompiler&gt;::operator new(fs_size, std::nothrow);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(NULL) {</span>
<span class="line-added">+   memcpy(data(), speculation, speculation_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // A heuristic check to detect nmethods that outlive a failed speculations list.</span>
<span class="line-added">+ static void guarantee_failed_speculations_alive(nmethod* nm, FailedSpeculation** failed_speculations_address) {</span>
<span class="line-added">+   jlong head = (jlong)(address) *failed_speculations_address;</span>
<span class="line-added">+   if ((head &amp; 0x1) == 0x1) {</span>
<span class="line-added">+     stringStream st;</span>
<span class="line-added">+     if (nm != NULL) {</span>
<span class="line-added">+       st.print(&quot;%d&quot;, nm-&gt;compile_id());</span>
<span class="line-added">+       Method* method = nm-&gt;method();</span>
<span class="line-added">+       st.print_raw(&quot;{&quot;);</span>
<span class="line-added">+       if (method != NULL) {</span>
<span class="line-added">+         method-&gt;print_name(&amp;st);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         const char* jvmci_name = nm-&gt;jvmci_name();</span>
<span class="line-added">+         if (jvmci_name != NULL) {</span>
<span class="line-added">+           st.print_raw(jvmci_name);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       st.print_raw(&quot;}&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       st.print(&quot;&lt;unknown&gt;&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fatal(&quot;Adding to failed speculations list that appears to have been freed. Source: %s&quot;, st.as_string());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool FailedSpeculation::add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len) {</span>
<span class="line-added">+   assert(failed_speculations_address != NULL, &quot;must be&quot;);</span>
<span class="line-added">+   size_t fs_size = sizeof(FailedSpeculation) + speculation_len;</span>
<span class="line-added">+   FailedSpeculation* fs = new (fs_size) FailedSpeculation(speculation, speculation_len);</span>
<span class="line-added">+   if (fs == NULL) {</span>
<span class="line-added">+     // no memory -&gt; ignore failed speculation</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   guarantee(is_aligned(fs, sizeof(FailedSpeculation*)), &quot;FailedSpeculation objects must be pointer aligned&quot;);</span>
<span class="line-added">+   guarantee_failed_speculations_alive(nm, failed_speculations_address);</span>
<span class="line-added">+ </span>
<span class="line-added">+   FailedSpeculation** cursor = failed_speculations_address;</span>
<span class="line-added">+   do {</span>
<span class="line-added">+     if (*cursor == NULL) {</span>
<span class="line-added">+       FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) NULL, fs);</span>
<span class="line-added">+       if (old_fs == NULL) {</span>
<span class="line-added">+         // Successfully appended fs to end of the list</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       cursor = old_fs-&gt;next_adr();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       cursor = (*cursor)-&gt;next_adr();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } while (true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void FailedSpeculation::free_failed_speculations(FailedSpeculation** failed_speculations_address) {</span>
<span class="line-added">+   assert(failed_speculations_address != NULL, &quot;must be&quot;);</span>
<span class="line-added">+   FailedSpeculation* fs = *failed_speculations_address;</span>
<span class="line-added">+   while (fs != NULL) {</span>
<span class="line-added">+     FailedSpeculation* next = fs-&gt;next();</span>
<span class="line-added">+     delete fs;</span>
<span class="line-added">+     fs = next;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Write an unaligned value to failed_speculations_address to denote</span>
<span class="line-added">+   // that it is no longer a valid pointer. This is allows for the check</span>
<span class="line-added">+   // in add_failed_speculation against adding to a freed failed</span>
<span class="line-added">+   // speculations list.</span>
<span class="line-added">+   long* head = (long*) failed_speculations_address;</span>
<span class="line-added">+   (*head) = (*head) | 0x1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI</span>
<span class="line-added">+ </span>
  int MethodData::compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps) {
  #if INCLUDE_JVMCI
    if (ProfileTraps) {
      // Assume that up to 30% of the possibly trapping BCIs with no MDP will need to allocate one.
      int extra_data_count = MIN2(empty_bc_count, MAX2(4, (empty_bc_count * 30) / 100));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,30 ***</span>
    }
  }
  
  // Initialize the MethodData* corresponding to a given method.
  MethodData::MethodData(const methodHandle&amp; method, int size, TRAPS)
<span class="line-modified">!   : _extra_data_lock(Monitor::leaf, &quot;MDO extra data lock&quot;),</span>
      _parameters_type_data_di(parameters_uninitialized) {
    // Set the method back-pointer.
    _method = method();
    initialize();
  }
  
  void MethodData::initialize() {
    NoSafepointVerifier no_safepoint;  // init function atomic wrt GC
<span class="line-modified">!   ResourceMark rm;</span>
  
    init();
    set_creation_mileage(mileage_of(method()));
  
    // Go through the bytecodes and allocate and initialize the
    // corresponding data cells.
    int data_size = 0;
    int empty_bc_count = 0;  // number of bytecodes lacking data
    _data[0] = 0;  // apparently not set below.
<span class="line-modified">!   BytecodeStream stream(method());</span>
    Bytecodes::Code c;
    bool needs_speculative_traps = false;
    while ((c = stream.next()) &gt;= 0) {
      int size_in_bytes = initialize_data(&amp;stream, data_size);
      data_size += size_in_bytes;
<span class="line-new-header">--- 1205,31 ---</span>
    }
  }
  
  // Initialize the MethodData* corresponding to a given method.
  MethodData::MethodData(const methodHandle&amp; method, int size, TRAPS)
<span class="line-modified">!   : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;),</span>
      _parameters_type_data_di(parameters_uninitialized) {
    // Set the method back-pointer.
    _method = method();
    initialize();
  }
  
  void MethodData::initialize() {
<span class="line-added">+   Thread* thread = Thread::current();</span>
    NoSafepointVerifier no_safepoint;  // init function atomic wrt GC
<span class="line-modified">!   ResourceMark rm(thread);</span>
  
    init();
    set_creation_mileage(mileage_of(method()));
  
    // Go through the bytecodes and allocate and initialize the
    // corresponding data cells.
    int data_size = 0;
    int empty_bc_count = 0;  // number of bytecodes lacking data
    _data[0] = 0;  // apparently not set below.
<span class="line-modified">!   BytecodeStream stream(methodHandle(thread, method()));</span>
    Bytecodes::Code c;
    bool needs_speculative_traps = false;
    while ((c = stream.next()) &gt;= 0) {
      int size_in_bytes = initialize_data(&amp;stream, data_size);
      data_size += size_in_bytes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1202,11 ***</span>
    // least well-defined.
    _hint_di = first_di();
  
    post_initialize(&amp;stream);
  
<span class="line-modified">!   assert(object_size == compute_allocation_size_in_bytes(methodHandle(_method)), &quot;MethodData: computed size != initialized size&quot;);</span>
    set_size(object_size);
  }
  
  void MethodData::init() {
    _invocation_counter.init();
<span class="line-new-header">--- 1278,11 ---</span>
    // least well-defined.
    _hint_di = first_di();
  
    post_initialize(&amp;stream);
  
<span class="line-modified">!   assert(object_size == compute_allocation_size_in_bytes(methodHandle(thread, _method)), &quot;MethodData: computed size != initialized size&quot;);</span>
    set_size(object_size);
  }
  
  void MethodData::init() {
    _invocation_counter.init();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1214,28 ***</span>
    _invocation_counter_start = 0;
    _backedge_counter_start = 0;
  
    // Set per-method invoke- and backedge mask.
    double scale = 1.0;
<span class="line-modified">!   CompilerOracle::has_option_value(_method, &quot;CompileThresholdScaling&quot;, scale);</span>
    _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
    _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
  
    _tenure_traps = 0;
    _num_loops = 0;
    _num_blocks = 0;
    _would_profile = unknown;
  
  #if INCLUDE_JVMCI
    _jvmci_ir_size = 0;
  #endif
  
  #if INCLUDE_RTM_OPT
    _rtm_state = NoRTM; // No RTM lock eliding by default
    if (UseRTMLocking &amp;&amp;
<span class="line-modified">!       !CompilerOracle::has_option_string(_method, &quot;NoRTMLockEliding&quot;)) {</span>
<span class="line-modified">!     if (CompilerOracle::has_option_string(_method, &quot;UseRTMLockEliding&quot;) || !UseRTMDeopt) {</span>
        // Generate RTM lock eliding code without abort ratio calculation code.
        _rtm_state = UseRTM;
      } else if (UseRTMDeopt) {
        // Generate RTM lock eliding code and include abort ratio calculation
        // code if UseRTMDeopt is on.
<span class="line-new-header">--- 1290,30 ---</span>
    _invocation_counter_start = 0;
    _backedge_counter_start = 0;
  
    // Set per-method invoke- and backedge mask.
    double scale = 1.0;
<span class="line-modified">!   methodHandle mh(Thread::current(), _method);</span>
<span class="line-added">+   CompilerOracle::has_option_value(mh, &quot;CompileThresholdScaling&quot;, scale);</span>
    _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
    _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
  
    _tenure_traps = 0;
    _num_loops = 0;
    _num_blocks = 0;
    _would_profile = unknown;
  
  #if INCLUDE_JVMCI
    _jvmci_ir_size = 0;
<span class="line-added">+   _failed_speculations = NULL;</span>
  #endif
  
  #if INCLUDE_RTM_OPT
    _rtm_state = NoRTM; // No RTM lock eliding by default
    if (UseRTMLocking &amp;&amp;
<span class="line-modified">!       !CompilerOracle::has_option_string(mh, &quot;NoRTMLockEliding&quot;)) {</span>
<span class="line-modified">!     if (CompilerOracle::has_option_string(mh, &quot;UseRTMLockEliding&quot;) || !UseRTMDeopt) {</span>
        // Generate RTM lock eliding code without abort ratio calculation code.
        _rtm_state = UseRTM;
      } else if (UseRTMDeopt) {
        // Generate RTM lock eliding code and include abort ratio calculation
        // code if UseRTMDeopt is on.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,11 ***</span>
  ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent) {
    DataLayout* end = args_data_limit();
  
    for (;; dp = next_extra(dp)) {
      assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">!     // No need for &quot;OrderAccess::load_acquire&quot; ops,</span>
      // since the data structure is monotonic.
      switch(dp-&gt;tag()) {
      case DataLayout::no_tag:
        return NULL;
      case DataLayout::arg_info_data_tag:
<span class="line-new-header">--- 1408,11 ---</span>
  ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent) {
    DataLayout* end = args_data_limit();
  
    for (;; dp = next_extra(dp)) {
      assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">!     // No need for &quot;Atomic::load_acquire&quot; ops,</span>
      // since the data structure is monotonic.
      switch(dp-&gt;tag()) {
      case DataLayout::no_tag:
        return NULL;
      case DataLayout::arg_info_data_tag:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1465,11 ***</span>
    st-&gt;print_cr(&quot;--- Extra data:&quot;);
    DataLayout* dp    = extra_data_base();
    DataLayout* end   = args_data_limit();
    for (;; dp = next_extra(dp)) {
      assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">!     // No need for &quot;OrderAccess::load_acquire&quot; ops,</span>
      // since the data structure is monotonic.
      switch(dp-&gt;tag()) {
      case DataLayout::no_tag:
        continue;
      case DataLayout::bit_data_tag:
<span class="line-new-header">--- 1543,11 ---</span>
    st-&gt;print_cr(&quot;--- Extra data:&quot;);
    DataLayout* dp    = extra_data_base();
    DataLayout* end   = args_data_limit();
    for (;; dp = next_extra(dp)) {
      assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">!     // No need for &quot;Atomic::load_acquire&quot; ops,</span>
      // since the data structure is monotonic.
      switch(dp-&gt;tag()) {
      case DataLayout::no_tag:
        continue;
      case DataLayout::bit_data_tag:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,20 ***</span>
      data-&gt;print_data_on(st);
      if (dp &gt;= end) return;
    }
  }
  
<span class="line-removed">- #if INCLUDE_SERVICES</span>
<span class="line-removed">- // Size Statistics</span>
<span class="line-removed">- void MethodData::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">-   int n = sz-&gt;count(this);</span>
<span class="line-removed">-   sz-&gt;_method_data_bytes += n;</span>
<span class="line-removed">-   sz-&gt;_method_all_bytes += n;</span>
<span class="line-removed">-   sz-&gt;_rw_bytes += n;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // INCLUDE_SERVICES</span>
<span class="line-removed">- </span>
  // Verification
  
  void MethodData::verify_on(outputStream* st) {
    guarantee(is_methodData(), &quot;object must be method data&quot;);
    // guarantee(m-&gt;is_perm(), &quot;should be in permspace&quot;);
<span class="line-new-header">--- 1568,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1524,15 ***</span>
    return inv.is_invokedynamic() || inv.is_invokehandle();
  }
  
  bool MethodData::profile_unsafe(const methodHandle&amp; m, int bci) {
    Bytecode_invoke inv(m , bci);
<span class="line-modified">!   if (inv.is_invokevirtual() &amp;&amp; inv.klass() == vmSymbols::jdk_internal_misc_Unsafe()) {</span>
<span class="line-modified">!     ResourceMark rm;</span>
<span class="line-modified">!     char* name = inv.name()-&gt;as_C_string();</span>
<span class="line-modified">!     if (!strncmp(name, &quot;get&quot;, 3) || !strncmp(name, &quot;put&quot;, 3)) {</span>
<span class="line-modified">!       return true;</span>
      }
    }
    return false;
  }
  
<span class="line-new-header">--- 1592,18 ---</span>
    return inv.is_invokedynamic() || inv.is_invokehandle();
  }
  
  bool MethodData::profile_unsafe(const methodHandle&amp; m, int bci) {
    Bytecode_invoke inv(m , bci);
<span class="line-modified">!   if (inv.is_invokevirtual()) {</span>
<span class="line-modified">!     if (inv.klass() == vmSymbols::jdk_internal_misc_Unsafe() ||</span>
<span class="line-modified">!         inv.klass() == vmSymbols::sun_misc_Unsafe()) {</span>
<span class="line-modified">!       ResourceMark rm;</span>
<span class="line-modified">!       char* name = inv.name()-&gt;as_C_string();</span>
<span class="line-added">+       if (!strncmp(name, &quot;get&quot;, 3) || !strncmp(name, &quot;put&quot;, 3)) {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+       }</span>
      }
    }
    return false;
  }
  
</pre>
<center><a href="method.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
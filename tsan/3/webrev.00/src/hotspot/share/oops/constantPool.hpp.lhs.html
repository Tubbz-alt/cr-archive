<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_CONSTANTPOOL_HPP
  26 #define SHARE_OOPS_CONSTANTPOOL_HPP
  27 
  28 #include &quot;memory/allocation.hpp&quot;
  29 #include &quot;oops/arrayOop.hpp&quot;
  30 #include &quot;oops/cpCache.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oopHandle.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;oops/typeArrayOop.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/bytes.hpp&quot;
  38 #include &quot;utilities/constantTag.hpp&quot;
  39 
  40 // A ConstantPool is an array containing class constants as described in the
  41 // class file.
  42 //
  43 // Most of the constant pool entries are written during class parsing, which
  44 // is safe.  For klass types, the constant pool entry is
  45 // modified when the entry is resolved.  If a klass constant pool
  46 // entry is read without a lock, only the resolved state guarantees that
  47 // the entry in the constant pool is a klass object and not a Symbol*.
  48 
  49 class SymbolHashMap;
  50 
  51 class CPSlot {
  52  friend class ConstantPool;
  53   intptr_t _ptr;
  54   enum TagBits  {_pseudo_bit = 1};
  55  public:
  56 
  57   CPSlot(intptr_t ptr): _ptr(ptr) {}
  58   CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}
  59 
  60   intptr_t value()   { return _ptr; }
  61   bool is_pseudo_string() { return (_ptr &amp; _pseudo_bit) != 0; }
  62 
  63   Symbol* get_symbol() {
  64     return (Symbol*)(_ptr &amp; ~_pseudo_bit);
  65   }
  66 };
  67 
  68 // This represents a JVM_CONSTANT_Class, JVM_CONSTANT_UnresolvedClass, or
  69 // JVM_CONSTANT_UnresolvedClassInError slot in the constant pool.
  70 class CPKlassSlot {
  71   // cp-&gt;symbol_at(_name_index) gives the name of the class.
  72   int _name_index;
  73 
  74   // cp-&gt;_resolved_klasses-&gt;at(_resolved_klass_index) gives the Klass* for the class.
  75   int _resolved_klass_index;
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
<a name="2" id="anc2"></a><span class="line-removed">  96 class KlassSizeStats;</span>
<span class="line-removed">  97 </span>
  98 class ConstantPool : public Metadata {
  99   friend class VMStructs;
 100   friend class JVMCIVMStructs;
 101   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 102   friend class Universe;             // For null constructor
 103  private:
 104   // If you add a new field that points to any metaspace object, you
 105   // must add this field to ConstantPool::metaspace_pointers_do().
 106   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 107   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 108   InstanceKlass*       _pool_holder; // the corresponding class
 109   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 110 
 111   // Consider using an array of compressed klass pointers to
 112   // save space on 64-bit platforms.
 113   Array&lt;Klass*&gt;*       _resolved_klasses;
 114 
 115   enum {
 116     _has_preresolution    = 1,       // Flags
 117     _on_stack             = 2,
 118     _is_shared            = 4,
 119     _has_dynamic_constant = 8
 120   };
 121 
 122   int                  _flags;  // old fashioned bit twiddling
 123   int                  _length; // number of elements in the array
 124 
 125   union {
 126     // set for CDS to restore resolved references
 127     int                _resolved_reference_length;
 128     // keeps version number for redefined classes (used in backtrace)
 129     int                _version;
 130   } _saved;
 131 
 132   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 133   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 134   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 135 
 136   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 137 
 138   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 139 
 140   int flags() const                            { return _flags; }
 141   void set_flags(int f)                        { _flags = f; }
 142 
 143  private:
 144   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 145 
 146   CPSlot slot_at(int which) const;
 147 
 148   void slot_at_put(int which, CPSlot s) const {
 149     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 150     assert(s.value() != 0, &quot;Caught something&quot;);
 151     *(intptr_t*)&amp;base()[which] = s.value();
 152   }
 153   intptr_t* obj_at_addr(int which) const {
 154     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 155     return (intptr_t*) &amp;base()[which];
 156   }
 157 
 158   jint* int_at_addr(int which) const {
 159     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 160     return (jint*) &amp;base()[which];
 161   }
 162 
 163   jlong* long_at_addr(int which) const {
 164     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 165     return (jlong*) &amp;base()[which];
 166   }
 167 
 168   jfloat* float_at_addr(int which) const {
 169     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 170     return (jfloat*) &amp;base()[which];
 171   }
 172 
 173   jdouble* double_at_addr(int which) const {
 174     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 175     return (jdouble*) &amp;base()[which];
 176   }
 177 
 178   ConstantPool(Array&lt;u1&gt;* tags);
 179   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 180  public:
 181   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 182 
 183   bool is_constantPool() const volatile     { return true; }
 184 
 185   Array&lt;u1&gt;* tags() const                   { return _tags; }
 186   Array&lt;u2&gt;* operands() const               { return _operands; }
 187 
 188   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 189   void set_has_preresolution() {
 190     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 191     _flags |= _has_preresolution;
 192   }
 193 
 194   // Redefine classes support.  If a method refering to this constant pool
 195   // is on the executing stack, or as a handle in vm code, this constant pool
 196   // can&#39;t be removed from the set of previous versions saved in the instance
 197   // class.
 198   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 199   void set_on_stack(const bool value);
 200 
 201   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 202   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 203 
 204   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 205   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 206 
 207   // Klass holding pool
 208   InstanceKlass* pool_holder() const      { return _pool_holder; }
 209   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 210   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 211 
 212   // Interpreter runtime support
 213   ConstantPoolCache* cache() const        { return _cache; }
 214   void set_cache(ConstantPoolCache* cache){ _cache = cache; }
 215 
 216   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 217   virtual MetaspaceObj::Type type() const { return ConstantPoolType; }
 218 
 219   // Create object cache in the constant pool
 220   void initialize_resolved_references(ClassLoaderData* loader_data,
 221                                       const intStack&amp; reference_map,
 222                                       int constant_pool_map_length,
 223                                       TRAPS);
 224 
 225   // resolved strings, methodHandles and callsite objects from the constant pool
 226   objArrayOop resolved_references()  const;
 227   objArrayOop resolved_references_or_null()  const;
 228   // mapping resolved object array indexes to cp indexes and back.
 229   int object_to_cp_index(int index)         { return reference_map()-&gt;at(index); }
 230   int cp_to_object_index(int index);
 231 
 232   void set_resolved_klasses(Array&lt;Klass*&gt;* rk)  { _resolved_klasses = rk; }
 233   Array&lt;Klass*&gt;* resolved_klasses() const       { return _resolved_klasses; }
 234   void allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS);
 235   void initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS);
 236 
 237   // Invokedynamic indexes.
 238   // They must look completely different from normal indexes.
 239   // The main reason is that byte swapping is sometimes done on normal indexes.
 240   // Finally, it is helpful for debugging to tell the two apart.
 241   static bool is_invokedynamic_index(int i) { return (i &lt; 0); }
 242   static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  &quot;&quot;); return ~i; }
 243   static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), &quot;&quot;); return ~i; }
 244 
 245 
 246   // The invokedynamic points at a CP cache entry.  This entry points back
 247   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
 248   // in the resolved_references array (which provides the appendix argument).
 249   int invokedynamic_cp_cache_index(int indy_index) const {
 250     assert(is_invokedynamic_index(indy_index), &quot;should be a invokedynamic index&quot;);
 251     int cache_index = decode_invokedynamic_index(indy_index);
 252     return cache_index;
 253   }
 254   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {
 255     // decode index that invokedynamic points to.
 256     int cp_cache_index = invokedynamic_cp_cache_index(indy_index);
 257     return cache()-&gt;entry_at(cp_cache_index);
 258   }
 259   // Given the per-instruction index of an indy instruction, report the
 260   // main constant pool entry for its bootstrap specifier.
 261   // From there, uncached_name/signature_ref_at will get the name/type.
 262   int invokedynamic_bootstrap_ref_index_at(int indy_index) const {
 263     return invokedynamic_cp_cache_entry_at(indy_index)-&gt;constant_pool_index();
 264   }
 265 
 266   // Assembly code support
 267   static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }
 268   static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }
 269   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
 270   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 271 
 272   // Storing constants
 273 
 274   // For temporary use while constructing constant pool
 275   void klass_index_at_put(int which, int name_index) {
 276     tag_at_put(which, JVM_CONSTANT_ClassIndex);
 277     *int_at_addr(which) = name_index;
 278   }
 279 
 280   // Unsafe anonymous class support:
 281   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
 282   void klass_at_put(int class_index, Klass* k);
 283 
 284   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
 285     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 286 
 287     assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 288     assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 289     *int_at_addr(which) =
 290       build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 291   }
 292 
 293   void method_handle_index_at_put(int which, int ref_kind, int ref_index) {
 294     tag_at_put(which, JVM_CONSTANT_MethodHandle);
 295     *int_at_addr(which) = ((jint) ref_index&lt;&lt;16) | ref_kind;
 296   }
 297 
 298   void method_type_index_at_put(int which, int ref_index) {
 299     tag_at_put(which, JVM_CONSTANT_MethodType);
 300     *int_at_addr(which) = ref_index;
 301   }
 302 
 303   void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 304     tag_at_put(which, JVM_CONSTANT_Dynamic);
 305     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 306   }
 307 
 308   void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 309     tag_at_put(which, JVM_CONSTANT_InvokeDynamic);
 310     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 311   }
 312 
 313   void unresolved_string_at_put(int which, Symbol* s) {
 314     release_tag_at_put(which, JVM_CONSTANT_String);
 315     slot_at_put(which, CPSlot(s));
 316   }
 317 
 318   void int_at_put(int which, jint i) {
 319     tag_at_put(which, JVM_CONSTANT_Integer);
 320     *int_at_addr(which) = i;
 321   }
 322 
 323   void long_at_put(int which, jlong l) {
 324     tag_at_put(which, JVM_CONSTANT_Long);
 325     // *long_at_addr(which) = l;
 326     Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &amp;l));
 327   }
 328 
 329   void float_at_put(int which, jfloat f) {
 330     tag_at_put(which, JVM_CONSTANT_Float);
 331     *float_at_addr(which) = f;
 332   }
 333 
 334   void double_at_put(int which, jdouble d) {
 335     tag_at_put(which, JVM_CONSTANT_Double);
 336     // *double_at_addr(which) = d;
 337     // u8 temp = *(u8*) &amp;d;
 338     Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &amp;d));
 339   }
 340 
 341   Symbol** symbol_at_addr(int which) const {
 342     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 343     return (Symbol**) &amp;base()[which];
 344   }
 345 
 346   void symbol_at_put(int which, Symbol* s) {
 347     assert(s-&gt;refcount() != 0, &quot;should have nonzero refcount&quot;);
 348     tag_at_put(which, JVM_CONSTANT_Utf8);
 349     *symbol_at_addr(which) = s;
 350   }
 351 
 352   void string_at_put(int which, int obj_index, oop str);
 353 
 354   // For temporary use while constructing constant pool
 355   void string_index_at_put(int which, int string_index) {
 356     tag_at_put(which, JVM_CONSTANT_StringIndex);
 357     *int_at_addr(which) = string_index;
 358   }
 359 
 360   void field_at_put(int which, int class_index, int name_and_type_index) {
 361     tag_at_put(which, JVM_CONSTANT_Fieldref);
 362     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 363   }
 364 
 365   void method_at_put(int which, int class_index, int name_and_type_index) {
 366     tag_at_put(which, JVM_CONSTANT_Methodref);
 367     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 368   }
 369 
 370   void interface_method_at_put(int which, int class_index, int name_and_type_index) {
 371     tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);
 372     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;  // Not so nice
 373   }
 374 
 375   void name_and_type_at_put(int which, int name_index, int signature_index) {
 376     tag_at_put(which, JVM_CONSTANT_NameAndType);
 377     *int_at_addr(which) = ((jint) signature_index&lt;&lt;16) | name_index;  // Not so nice
 378   }
 379 
 380   // Tag query
 381 
 382   constantTag tag_at(int which) const { return (constantTag)tags()-&gt;at_acquire(which); }
 383 
 384   // Fetching constants
 385 
 386   Klass* klass_at(int which, TRAPS) {
 387     constantPoolHandle h_this(THREAD, this);
 388     return klass_at_impl(h_this, which, true, THREAD);
 389   }
 390 
 391   // Version of klass_at that doesn&#39;t save the resolution error, called during deopt
 392   Klass* klass_at_ignore_error(int which, TRAPS) {
 393     constantPoolHandle h_this(THREAD, this);
 394     return klass_at_impl(h_this, which, false, THREAD);
 395   }
 396 
 397   CPKlassSlot klass_slot_at(int which) const {
 398     assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),
 399            &quot;Corrupted constant pool&quot;);
 400     int value = *int_at_addr(which);
 401     int name_index = extract_high_short_from_int(value);
 402     int resolved_klass_index = extract_low_short_from_int(value);
 403     return CPKlassSlot(name_index, resolved_klass_index);
 404   }
 405 
 406   Symbol* klass_name_at(int which) const;  // Returns the name, w/o resolving.
 407   int klass_name_index_at(int which) const {
 408     return klass_slot_at(which).name_index();
 409   }
 410 
 411   Klass* resolved_klass_at(int which) const;  // Used by Compiler
 412 
 413   // RedefineClasses() API support:
 414   Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }
 415   void temp_unresolved_klass_at_put(int which, int name_index) {
 416     // Used only during constant pool merging for class redefinition. The resolved klass index
 417     // will be initialized later by a call to initialize_unresolved_klasses().
 418     unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);
 419   }
 420 
 421   jint int_at(int which) {
 422     assert(tag_at(which).is_int(), &quot;Corrupted constant pool&quot;);
 423     return *int_at_addr(which);
 424   }
 425 
 426   jlong long_at(int which) {
 427     assert(tag_at(which).is_long(), &quot;Corrupted constant pool&quot;);
 428     // return *long_at_addr(which);
 429     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 430     return *((jlong*)&amp;tmp);
 431   }
 432 
 433   jfloat float_at(int which) {
 434     assert(tag_at(which).is_float(), &quot;Corrupted constant pool&quot;);
 435     return *float_at_addr(which);
 436   }
 437 
 438   jdouble double_at(int which) {
 439     assert(tag_at(which).is_double(), &quot;Corrupted constant pool&quot;);
 440     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 441     return *((jdouble*)&amp;tmp);
 442   }
 443 
 444   Symbol* symbol_at(int which) const {
 445     assert(tag_at(which).is_utf8(), &quot;Corrupted constant pool&quot;);
 446     return *symbol_at_addr(which);
 447   }
 448 
 449   oop string_at(int which, int obj_index, TRAPS) {
 450     constantPoolHandle h_this(THREAD, this);
 451     return string_at_impl(h_this, which, obj_index, THREAD);
 452   }
 453   oop string_at(int which, TRAPS) {
 454     int obj_index = cp_to_object_index(which);
 455     return string_at(which, obj_index, THREAD);
 456   }
 457 
 458   // Version that can be used before string oop array is created.
 459   oop uncached_string_at(int which, TRAPS);
 460 
 461   // A &quot;pseudo-string&quot; is an non-string oop that has found its way into
 462   // a String entry.
 463   // This can happen if the user patches a live
 464   // object into a CONSTANT_String entry of an unsafe anonymous class.
 465   // Method oops internally created for method handles may also
 466   // use pseudo-strings to link themselves to related metaobjects.
 467 
 468   bool is_pseudo_string_at(int which);
 469 
 470   oop pseudo_string_at(int which, int obj_index);
 471 
 472   oop pseudo_string_at(int which);
 473 
 474   void pseudo_string_at_put(int which, int obj_index, oop x) {
 475     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 476     Symbol* sym = unresolved_string_at(which);
 477     slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));
 478     string_at_put(which, obj_index, x);    // this works just fine
 479   }
 480 
 481   // only called when we are sure a string entry is already resolved (via an
 482   // earlier string_at call.
 483   oop resolved_string_at(int which) {
 484     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 485     // Must do an acquire here in case another thread resolved the klass
 486     // behind our back, lest we later load stale values thru the oop.
 487     // we might want a volatile_obj_at in ObjArrayKlass.
 488     int obj_index = cp_to_object_index(which);
 489     return resolved_references()-&gt;obj_at(obj_index);
 490   }
 491 
 492   Symbol* unresolved_string_at(int which) {
 493     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 494     Symbol* sym = slot_at(which).get_symbol();
 495     return sym;
 496   }
 497 
 498   // Returns an UTF8 for a CONSTANT_String entry at a given index.
 499   // UTF8 char* representation was chosen to avoid conversion of
 500   // java_lang_Strings at resolved entries into Symbol*s
 501   // or vice versa.
 502   char* string_at_noresolve(int which);
 503 
 504   jint name_and_type_at(int which) {
 505     assert(tag_at(which).is_name_and_type(), &quot;Corrupted constant pool&quot;);
 506     return *int_at_addr(which);
 507   }
 508 
 509   int method_handle_ref_kind_at(int which) {
 510     assert(tag_at(which).is_method_handle() ||
 511            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 512     return extract_low_short_from_int(*int_at_addr(which));  // mask out unwanted ref_index bits
 513   }
 514   int method_handle_index_at(int which) {
 515     assert(tag_at(which).is_method_handle() ||
 516            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 517     return extract_high_short_from_int(*int_at_addr(which));  // shift out unwanted ref_kind bits
 518   }
 519   int method_type_index_at(int which) {
 520     assert(tag_at(which).is_method_type() ||
 521            tag_at(which).is_method_type_in_error(), &quot;Corrupted constant pool&quot;);
 522     return *int_at_addr(which);
 523   }
 524 
 525   // Derived queries:
 526   Symbol* method_handle_name_ref_at(int which) {
 527     int member = method_handle_index_at(which);
 528     return impl_name_ref_at(member, true);
 529   }
 530   Symbol* method_handle_signature_ref_at(int which) {
 531     int member = method_handle_index_at(which);
 532     return impl_signature_ref_at(member, true);
 533   }
 534   int method_handle_klass_index_at(int which) {
 535     int member = method_handle_index_at(which);
 536     return impl_klass_ref_index_at(member, true);
 537   }
 538   Symbol* method_type_signature_at(int which) {
 539     int sym = method_type_index_at(which);
 540     return symbol_at(sym);
 541   }
 542 
 543   int bootstrap_name_and_type_ref_index_at(int which) {
 544     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 545     return extract_high_short_from_int(*int_at_addr(which));
 546   }
 547   int bootstrap_methods_attribute_index(int which) {
 548     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 549     return extract_low_short_from_int(*int_at_addr(which));
 550   }
 551   int bootstrap_operand_base(int which) {
 552     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 553     return operand_offset_at(operands(), bsms_attribute_index);
 554   }
 555   // The first part of the operands array consists of an index into the second part.
 556   // Extract a 32-bit index value from the first part.
 557   static int operand_offset_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 558     int n = (bsms_attribute_index * 2);
 559     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 560     // The first 32-bit index points to the beginning of the second part
 561     // of the operands array.  Make sure this index is in the first part.
 562     DEBUG_ONLY(int second_part = build_int_from_shorts(operands-&gt;at(0),
 563                                                        operands-&gt;at(1)));
 564     assert(second_part == 0 || n+2 &lt;= second_part, &quot;oob (2)&quot;);
 565     int offset = build_int_from_shorts(operands-&gt;at(n+0),
 566                                        operands-&gt;at(n+1));
 567     // The offset itself must point into the second part of the array.
 568     assert(offset == 0 || offset &gt;= second_part &amp;&amp; offset &lt;= operands-&gt;length(), &quot;oob (3)&quot;);
 569     return offset;
 570   }
 571   static void operand_offset_at_put(Array&lt;u2&gt;* operands, int bsms_attribute_index, int offset) {
 572     int n = bsms_attribute_index * 2;
 573     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 574     operands-&gt;at_put(n+0, extract_low_short_from_int(offset));
 575     operands-&gt;at_put(n+1, extract_high_short_from_int(offset));
 576   }
 577   static int operand_array_length(Array&lt;u2&gt;* operands) {
 578     if (operands == NULL || operands-&gt;length() == 0)  return 0;
 579     int second_part = operand_offset_at(operands, 0);
 580     return (second_part / 2);
 581   }
 582 
 583 #ifdef ASSERT
 584   // operand tuples fit together exactly, end to end
 585   static int operand_limit_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 586     int nextidx = bsms_attribute_index + 1;
 587     if (nextidx == operand_array_length(operands))
 588       return operands-&gt;length();
 589     else
 590       return operand_offset_at(operands, nextidx);
 591   }
 592   int bootstrap_operand_limit(int which) {
 593     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 594     return operand_limit_at(operands(), bsms_attribute_index);
 595   }
 596 #endif //ASSERT
 597 
 598   // Layout of InvokeDynamic and Dynamic bootstrap method specifier
 599   // data in second part of operands array.  This encodes one record in
 600   // the BootstrapMethods attribute.  The whole specifier also includes
 601   // the name and type information from the main constant pool entry.
 602   enum {
 603          _indy_bsm_offset  = 0,  // CONSTANT_MethodHandle bsm
 604          _indy_argc_offset = 1,  // u2 argc
 605          _indy_argv_offset = 2   // u2 argv[argc]
 606   };
 607 
 608   // These functions are used in RedefineClasses for CP merge
 609 
 610   int operand_offset_at(int bsms_attribute_index) {
 611     assert(0 &lt;= bsms_attribute_index &amp;&amp;
 612            bsms_attribute_index &lt; operand_array_length(operands()),
 613            &quot;Corrupted CP operands&quot;);
 614     return operand_offset_at(operands(), bsms_attribute_index);
 615   }
 616   int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {
 617     int offset = operand_offset_at(bsms_attribute_index);
 618     return operands()-&gt;at(offset + _indy_bsm_offset);
 619   }
 620   int operand_argument_count_at(int bsms_attribute_index) {
 621     int offset = operand_offset_at(bsms_attribute_index);
 622     int argc = operands()-&gt;at(offset + _indy_argc_offset);
 623     return argc;
 624   }
 625   int operand_argument_index_at(int bsms_attribute_index, int j) {
 626     int offset = operand_offset_at(bsms_attribute_index);
 627     return operands()-&gt;at(offset + _indy_argv_offset + j);
 628   }
 629   int operand_next_offset_at(int bsms_attribute_index) {
 630     int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset
 631                    + operand_argument_count_at(bsms_attribute_index);
 632     return offset;
 633   }
 634   // Compare a bootstrap specifier data in the operands arrays
 635   bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle&amp; cp2,
 636                           int bsms_attribute_index2, TRAPS);
 637   // Find a bootstrap specifier data in the operands array
 638   int find_matching_operand(int bsms_attribute_index, const constantPoolHandle&amp; search_cp,
 639                             int operands_cur_len, TRAPS);
 640   // Resize the operands array with delta_len and delta_size
 641   void resize_operands(int delta_len, int delta_size, TRAPS);
 642   // Extend the operands array with the length and size of the ext_cp operands
 643   void extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS);
 644   // Shrink the operands array to a smaller array with new_len length
 645   void shrink_operands(int new_len, TRAPS);
 646 
 647   int bootstrap_method_ref_index_at(int which) {
 648     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 649     int op_base = bootstrap_operand_base(which);
 650     return operands()-&gt;at(op_base + _indy_bsm_offset);
 651   }
 652   int bootstrap_argument_count_at(int which) {
 653     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 654     int op_base = bootstrap_operand_base(which);
 655     int argc = operands()-&gt;at(op_base + _indy_argc_offset);
 656     DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;
 657                int next_offset = bootstrap_operand_limit(which));
 658     assert(end_offset == next_offset, &quot;matched ending&quot;);
 659     return argc;
 660   }
 661   int bootstrap_argument_index_at(int which, int j) {
 662     int op_base = bootstrap_operand_base(which);
 663     DEBUG_ONLY(int argc = operands()-&gt;at(op_base + _indy_argc_offset));
 664     assert((uint)j &lt; (uint)argc, &quot;oob&quot;);
 665     return operands()-&gt;at(op_base + _indy_argv_offset + j);
 666   }
 667 
 668   // The following methods (name/signature/klass_ref_at, klass_ref_at_noresolve,
 669   // name_and_type_ref_index_at) all expect to be passed indices obtained
 670   // directly from the bytecode.
 671   // If the indices are meant to refer to fields or methods, they are
 672   // actually rewritten constant pool cache indices.
 673   // The routine remap_instruction_operand_from_cache manages the adjustment
 674   // of these values back to constant pool indices.
 675 
 676   // There are also &quot;uncached&quot; versions which do not adjust the operand index; see below.
 677 
 678   // FIXME: Consider renaming these with a prefix &quot;cached_&quot; to make the distinction clear.
 679   // In a few cases (the verifier) there are uses before a cpcache has been built,
 680   // which are handled by a dynamic check in remap_instruction_operand_from_cache.
 681   // FIXME: Remove the dynamic check, and adjust all callers to specify the correct mode.
 682 
 683   // Lookup for entries consisting of (klass_index, name_and_type index)
 684   Klass* klass_ref_at(int which, TRAPS);
 685   Symbol* klass_ref_at_noresolve(int which);
 686   Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }
 687   Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }
 688 
 689   int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }
 690   int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }
 691 
 692   int remap_instruction_operand_from_cache(int operand);  // operand must be biased by CPCACHE_INDEX_TAG
 693 
 694   constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }
 695 
 696   // Lookup for entries consisting of (name_index, signature_index)
 697   int name_ref_index_at(int which_nt);            // ==  low-order jshort of name_and_type_at(which_nt)
 698   int signature_ref_index_at(int which_nt);       // == high-order jshort of name_and_type_at(which_nt)
 699 
 700   BasicType basic_type_for_signature_at(int which) const;
 701 
 702   // Resolve string constants (to prevent allocation during compilation)
 703   void resolve_string_constants(TRAPS) {
 704     constantPoolHandle h_this(THREAD, this);
 705     resolve_string_constants_impl(h_this, CHECK);
 706   }
 707 
 708   // CDS support
 709   void archive_resolved_references(Thread *THREAD) NOT_CDS_JAVA_HEAP_RETURN;
 710   void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 711   void remove_unshareable_info();
 712   void restore_unshareable_info(TRAPS);
 713   // The ConstantPool vtable is restored by this call when the ConstantPool is
 714   // in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for
 715   // all the gory details.  SA, dtrace and pstack helpers distinguish metadata
 716   // by their vtable.
 717   void restore_vtable() { guarantee(is_constantPool(), &quot;vtable restored by this call&quot;); }
 718 
 719  private:
 720   enum { _no_index_sentinel = -1, _possible_index_sentinel = -2 };
 721  public:
 722 
 723   // Get the tag for a constant, which may involve a constant dynamic
 724   constantTag constant_tag_at(int which);
 725   // Get the basic type for a constant, which may involve a constant dynamic
 726   BasicType basic_type_for_constant_at(int which);
 727 
 728   // Resolve late bound constants.
 729   oop resolve_constant_at(int index, TRAPS) {
 730     constantPoolHandle h_this(THREAD, this);
 731     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 732   }
 733 
 734   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 735     constantPoolHandle h_this(THREAD, this);
 736     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 737   }
 738 
 739   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 740     constantPoolHandle h_this(THREAD, this);
 741     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 742   }
 743 
 744   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 745     constantPoolHandle h_this(THREAD, this);
 746     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 747   }
 748 
<a name="3" id="anc3"></a><span class="line-removed"> 749   oop resolve_bootstrap_specifier_at(int index, TRAPS) {</span>
<span class="line-removed"> 750     constantPoolHandle h_this(THREAD, this);</span>
<span class="line-removed"> 751     return resolve_bootstrap_specifier_at_impl(h_this, index, THREAD);</span>
<span class="line-removed"> 752   }</span>
<span class="line-removed"> 753 </span>
 754   void copy_bootstrap_arguments_at(int index,
 755                                    int start_arg, int end_arg,
 756                                    objArrayHandle info, int pos,
 757                                    bool must_resolve, Handle if_not_available, TRAPS) {
 758     constantPoolHandle h_this(THREAD, this);
 759     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 760                                      info, pos, must_resolve, if_not_available, THREAD);
 761   }
 762 
 763   // Klass name matches name at offset
 764   bool klass_name_at_matches(const InstanceKlass* k, int which);
 765 
 766   // Sizing
 767   int length() const                   { return _length; }
 768   void set_length(int length)          { _length = length; }
 769 
 770   // Tells whether index is within bounds.
 771   bool is_within_bounds(int index) const {
 772     return 0 &lt;= index &amp;&amp; index &lt; length();
 773   }
 774 
 775   // Sizing (in words)
 776   static int header_size()             {
 777     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 778   }
 779   static int size(int length)          { return align_metadata_size(header_size() + length); }
 780   int size() const                     { return size(length()); }
<a name="4" id="anc4"></a><span class="line-removed"> 781 #if INCLUDE_SERVICES</span>
<span class="line-removed"> 782   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed"> 783 #endif</span>
 784 
 785   // ConstantPools should be stored in the read-only region of CDS archive.
 786   static bool is_read_only_by_default() { return true; }
 787 
 788   friend class ClassFileParser;
 789   friend class SystemDictionary;
 790 
 791   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 792   template &lt;class T&gt; friend class CppVtableTesterA;
 793   template &lt;class T&gt; friend class CppVtableTesterB;
 794   template &lt;class T&gt; friend class CppVtableCloner;
 795 
 796   // Used by compiler to prevent classloading.
 797   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 798   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 799   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 800   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 801   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 802 
 803   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
 804   // future by other Java code. These take constant pool indices rather than
 805   // constant pool cache indices as do the peer methods above.
 806   Symbol* uncached_klass_ref_at_noresolve(int which);
 807   Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }
 808   Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }
 809   int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }
 810   int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }
 811 
 812   // Sharing
 813   int pre_resolve_shared_klasses(TRAPS);
 814 
 815   // Debugging
 816   const char* printable_name_at(int which) PRODUCT_RETURN0;
 817 
 818 #ifdef ASSERT
 819   enum { CPCACHE_INDEX_TAG = 0x10000 };  // helps keep CP cache indices distinct from CP indices
 820 #else
 821   enum { CPCACHE_INDEX_TAG = 0 };        // in product mode, this zero value is a no-op
 822 #endif //ASSERT
 823 
 824   static int decode_cpcache_index(int raw_index, bool invokedynamic_ok = false) {
 825     if (invokedynamic_ok &amp;&amp; is_invokedynamic_index(raw_index))
 826       return decode_invokedynamic_index(raw_index);
 827     else
 828       return raw_index - CPCACHE_INDEX_TAG;
 829   }
 830 
 831  private:
 832 
 833   void set_resolved_references(OopHandle s) { _cache-&gt;set_resolved_references(s); }
 834   Array&lt;u2&gt;* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache-&gt;reference_map(); }
 835   void set_reference_map(Array&lt;u2&gt;* o)    { _cache-&gt;set_reference_map(o); }
 836 
 837   // patch JSR 292 resolved references after the class is linked.
 838   void patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches);
 839 
 840   Symbol* impl_name_ref_at(int which, bool uncached);
 841   Symbol* impl_signature_ref_at(int which, bool uncached);
 842 
 843   int       impl_klass_ref_index_at(int which, bool uncached);
 844   int       impl_name_and_type_ref_index_at(int which, bool uncached);
 845   constantTag impl_tag_ref_at(int which, bool uncached);
 846 
 847   // Used while constructing constant pool (only by ClassFileParser)
 848   jint klass_index_at(int which) {
 849     assert(tag_at(which).is_klass_index(), &quot;Corrupted constant pool&quot;);
 850     return *int_at_addr(which);
 851   }
 852 
 853   jint string_index_at(int which) {
 854     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 855     return *int_at_addr(which);
 856   }
 857 
 858   // Performs the LinkResolver checks
 859   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 860 
 861   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 862   // handle GC while executing the method
 863   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 864                               bool save_resolution_error, TRAPS);
 865   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 866 
 867   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 868 
 869   // Resolve string constants (to prevent allocation during compilation)
 870   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 871 
 872   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 873                                       bool* status_return, TRAPS);
<a name="5" id="anc5"></a><span class="line-removed"> 874   static oop resolve_bootstrap_specifier_at_impl(const constantPoolHandle&amp; this_cp, int index, TRAPS);</span>
 875   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 876                                                int start_arg, int end_arg,
 877                                                objArrayHandle info, int pos,
 878                                                bool must_resolve, Handle if_not_available, TRAPS);
 879 
 880   // Exception handling
 881   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 882   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 883 
 884  public:
 885   // Exception handling
 886   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 887 
 888   // Merging ConstantPool* support:
 889   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 890   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 891     constantPoolHandle h_this(THREAD, this);
 892     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 893   }
 894   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 895   static void copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 896   static void copy_operands(const constantPoolHandle&amp; from_cp, const constantPoolHandle&amp; to_cp, TRAPS);
 897   int  find_matching_entry(int pattern_i, const constantPoolHandle&amp; search_cp, TRAPS);
 898   int  version() const                    { return _saved._version; }
 899   void set_version(int version)           { _saved._version = version; }
 900   void increment_and_save_version(int version) {
 901     _saved._version = version &gt;= 0 ? (version + 1) : version;  // keep overflow
 902   }
 903 
 904   void set_resolved_reference_length(int length) { _saved._resolved_reference_length = length; }
 905   int  resolved_reference_length() const  { return _saved._resolved_reference_length; }
 906 
 907   // Decrease ref counts of symbols that are in the constant pool
 908   // when the holder class is unloaded
 909   void unreference_symbols();
 910 
 911   // Deallocate constant pool for RedefineClasses
 912   void deallocate_contents(ClassLoaderData* loader_data);
 913   void release_C_heap_structures();
 914 
 915   // JVMTI accesss - GetConstantPool, RetransformClasses, ...
 916   friend class JvmtiConstantPoolReconstituter;
 917 
 918  private:
 919   jint cpool_entry_size(jint idx);
 920   jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);
 921 
 922   // Copy cpool bytes into byte array.
 923   // Returns:
 924   //  int &gt; 0, count of the raw cpool bytes that have been copied
 925   //        0, OutOfMemory error
 926   //       -1, Internal error
 927   int  copy_cpool_bytes(int cpool_size,
 928                         SymbolHashMap* tbl,
 929                         unsigned char *bytes);
 930 
 931  public:
 932   // Verify
 933   void verify_on(outputStream* st);
 934 
 935   // Printing
 936   void print_on(outputStream* st) const;
 937   void print_value_on(outputStream* st) const;
 938   void print_entry_on(int index, outputStream* st);
 939 
 940   const char* internal_name() const { return &quot;{constant pool}&quot;; }
 941 };
 942 
 943 class SymbolHashMapEntry : public CHeapObj&lt;mtSymbol&gt; {
 944  private:
 945   unsigned int        _hash;   // 32-bit hash for item
 946   SymbolHashMapEntry* _next;   // Next element in the linked list for this bucket
 947   Symbol*             _symbol; // 1-st part of the mapping: symbol =&gt; value
 948   u2                  _value;  // 2-nd part of the mapping: symbol =&gt; value
 949 
 950  public:
 951   unsigned   int hash() const             { return _hash;   }
 952   void       set_hash(unsigned int hash)  { _hash = hash;   }
 953 
 954   SymbolHashMapEntry* next() const        { return _next;   }
 955   void set_next(SymbolHashMapEntry* next) { _next = next;   }
 956 
 957   Symbol*    symbol() const               { return _symbol; }
 958   void       set_symbol(Symbol* sym)      { _symbol = sym;  }
 959 
 960   u2         value() const                {  return _value; }
 961   void       set_value(u2 value)          { _value = value; }
 962 
 963   SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)
 964     : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}
 965 
 966 }; // End SymbolHashMapEntry class
 967 
 968 
 969 class SymbolHashMapBucket : public CHeapObj&lt;mtSymbol&gt; {
 970 
 971 private:
 972   SymbolHashMapEntry*    _entry;
 973 
 974 public:
 975   SymbolHashMapEntry* entry() const         {  return _entry; }
 976   void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }
 977   void clear()                              { _entry = NULL;  }
 978 
 979 }; // End SymbolHashMapBucket class
 980 
 981 
 982 class SymbolHashMap: public CHeapObj&lt;mtSymbol&gt; {
 983 
 984  private:
 985   // Default number of entries in the table
 986   enum SymbolHashMap_Constants {
 987     _Def_HashMap_Size = 256
 988   };
 989 
 990   int                   _table_size;
 991   SymbolHashMapBucket*  _buckets;
 992 
 993   void initialize_table(int table_size);
 994 
 995  public:
 996 
 997   int table_size() const        { return _table_size; }
 998 
 999   SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }
1000   SymbolHashMap(int table_size) { initialize_table(table_size); }
1001 
1002   // hash P(31) from Kernighan &amp; Ritchie
1003   static unsigned int compute_hash(const char* str, int len) {
1004     unsigned int hash = 0;
1005     while (len-- &gt; 0) {
1006       hash = 31*hash + (unsigned) *str;
1007       str++;
1008     }
1009     return hash;
1010   }
1011 
1012   SymbolHashMapEntry* bucket(int i) {
1013     return _buckets[i].entry();
1014   }
1015 
1016   void add_entry(Symbol* sym, u2 value);
1017   SymbolHashMapEntry* find_entry(Symbol* sym);
1018 
1019   u2 symbol_to_value(Symbol* sym) {
1020     SymbolHashMapEntry *entry = find_entry(sym);
1021     return (entry == NULL) ? 0 : entry-&gt;value();
1022   }
1023 
1024   ~SymbolHashMap();
1025 }; // End SymbolHashMap class
1026 
1027 #endif // SHARE_OOPS_CONSTANTPOOL_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessBackend.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="accessBackend.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 26 #define SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 27 
 28 #include &quot;oops/access.hpp&quot;
 29 #include &quot;oops/accessBackend.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;


 32 
 33 template &lt;DecoratorSet decorators&gt;
 34 template &lt;DecoratorSet idecorators, typename T&gt;
 35 inline typename EnableIf&lt;
 36   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 37 RawAccessBarrier&lt;decorators&gt;::decode_internal(typename HeapOopType&lt;idecorators&gt;::type value) {
 38   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 39     return CompressedOops::decode_not_null(value);
 40   } else {
 41     return CompressedOops::decode(value);
 42   }
 43 }
 44 
 45 template &lt;DecoratorSet decorators&gt;
 46 template &lt;DecoratorSet idecorators, typename T&gt;
 47 inline typename EnableIf&lt;
 48   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 49   typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 50 RawAccessBarrier&lt;decorators&gt;::encode_internal(T value) {
 51   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
</pre>
<hr />
<pre>
 68 inline void RawAccessBarrier&lt;decorators&gt;::oop_store_at(oop base, ptrdiff_t offset, T value) {
 69   oop_store(field_addr(base, offset), value);
 70 }
 71 
 72 template &lt;DecoratorSet decorators&gt;
 73 template &lt;typename T&gt;
 74 inline T RawAccessBarrier&lt;decorators&gt;::oop_load(void* addr) {
 75   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 76   Encoded encoded = load&lt;Encoded&gt;(reinterpret_cast&lt;Encoded*&gt;(addr));
 77   return decode&lt;T&gt;(encoded);
 78 }
 79 
 80 template &lt;DecoratorSet decorators&gt;
 81 template &lt;typename T&gt;
 82 inline T RawAccessBarrier&lt;decorators&gt;::oop_load_at(oop base, ptrdiff_t offset) {
 83   return oop_load&lt;T&gt;(field_addr(base, offset));
 84 }
 85 
 86 template &lt;DecoratorSet decorators&gt;
 87 template &lt;typename T&gt;
<span class="line-modified"> 88 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 89   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 90   Encoded encoded_new = encode(new_value);
 91   Encoded encoded_compare = encode(compare_value);
<span class="line-modified"> 92   Encoded encoded_result = atomic_cmpxchg(encoded_new,</span>
<span class="line-modified"> 93                                           reinterpret_cast&lt;Encoded*&gt;(addr),</span>
<span class="line-modified"> 94                                           encoded_compare);</span>
 95   return decode&lt;T&gt;(encoded_result);
 96 }
 97 
 98 template &lt;DecoratorSet decorators&gt;
 99 template &lt;typename T&gt;
<span class="line-modified">100 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">101   return oop_atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);</span>
102 }
103 
104 template &lt;DecoratorSet decorators&gt;
105 template &lt;typename T&gt;
<span class="line-modified">106 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(T new_value, void* addr) {</span>
107   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
108   Encoded encoded_new = encode(new_value);
<span class="line-modified">109   Encoded encoded_result = atomic_xchg(encoded_new, reinterpret_cast&lt;Encoded*&gt;(addr));</span>
110   return decode&lt;T&gt;(encoded_result);
111 }
112 
113 template &lt;DecoratorSet decorators&gt;
114 template &lt;typename T&gt;
<span class="line-modified">115 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">116   return oop_atomic_xchg(new_value, field_addr(base, offset));</span>
117 }
118 
119 template &lt;DecoratorSet decorators&gt;
120 template &lt;typename T&gt;
121 inline bool RawAccessBarrier&lt;decorators&gt;::oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
122                                                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
123                                                         size_t length) {
124   return arraycopy(src_obj, src_offset_in_bytes, src_raw,
125                    dst_obj, dst_offset_in_bytes, dst_raw,
126                    length);
127 }
128 
129 template &lt;DecoratorSet decorators&gt;
130 template &lt;DecoratorSet ds, typename T&gt;
131 inline typename EnableIf&lt;
132   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
133 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
134   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
135     OrderAccess::fence();
136   }
<span class="line-modified">137   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
138 }
139 
140 template &lt;DecoratorSet decorators&gt;
141 template &lt;DecoratorSet ds, typename T&gt;
142 inline typename EnableIf&lt;
143   HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
144 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
<span class="line-modified">145   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
146 }
147 
148 template &lt;DecoratorSet decorators&gt;
149 template &lt;DecoratorSet ds, typename T&gt;
150 inline typename EnableIf&lt;
151   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
152 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
153   return Atomic::load(reinterpret_cast&lt;const volatile T*&gt;(addr));
154 }
155 
156 template &lt;DecoratorSet decorators&gt;
157 template &lt;DecoratorSet ds, typename T&gt;
158 inline typename EnableIf&lt;
159   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
160 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">161   OrderAccess::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
162 }
163 
164 template &lt;DecoratorSet decorators&gt;
165 template &lt;DecoratorSet ds, typename T&gt;
166 inline typename EnableIf&lt;
167   HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
168 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">169   OrderAccess::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
170 }
171 
172 template &lt;DecoratorSet decorators&gt;
173 template &lt;DecoratorSet ds, typename T&gt;
174 inline typename EnableIf&lt;
175   HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
176 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">177   Atomic::store(value, reinterpret_cast&lt;volatile T*&gt;(addr));</span>
178 }
179 
180 template &lt;DecoratorSet decorators&gt;
181 template &lt;DecoratorSet ds, typename T&gt;
182 inline typename EnableIf&lt;
183   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified">184 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">185   return Atomic::cmpxchg(new_value,</span>
<span class="line-removed">186                          reinterpret_cast&lt;volatile T*&gt;(addr),</span>
187                          compare_value,

188                          memory_order_relaxed);
189 }
190 
191 template &lt;DecoratorSet decorators&gt;
192 template &lt;DecoratorSet ds, typename T&gt;
193 inline typename EnableIf&lt;
194   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">195 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">196   return Atomic::cmpxchg(new_value,</span>
<span class="line-removed">197                          reinterpret_cast&lt;volatile T*&gt;(addr),</span>
198                          compare_value,

199                          memory_order_conservative);
200 }
201 
202 template &lt;DecoratorSet decorators&gt;
203 template &lt;DecoratorSet ds, typename T&gt;
204 inline typename EnableIf&lt;
205   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">206 RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(T new_value, void* addr) {</span>
<span class="line-modified">207   return Atomic::xchg(new_value,</span>
<span class="line-modified">208                       reinterpret_cast&lt;volatile T*&gt;(addr));</span>
209 }
210 
211 // For platforms that do not have native support for wide atomics,
212 // we can emulate the atomicity using a lock. So here we check
213 // whether that is necessary or not.
214 
215 template &lt;DecoratorSet ds&gt;
216 template &lt;DecoratorSet decorators, typename T&gt;
217 inline typename EnableIf&lt;
218   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">219 RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(T new_value, void* addr) {</span>
220   if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="line-modified">221     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);</span>
222   } else {
223     AccessInternal::AccessLocker access_lock;
224     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
225     T old_val = RawAccess&lt;&gt;::load(p);
226     RawAccess&lt;&gt;::store(p, new_value);
227     return old_val;
228   }
229 }
230 
231 template &lt;DecoratorSet ds&gt;
232 template &lt;DecoratorSet decorators, typename T&gt;
233 inline typename EnableIf&lt;
234   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">235 RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {</span>
236   if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="line-modified">237     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);</span>
238   } else {
239     AccessInternal::AccessLocker access_lock;
240     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
241     T old_val = RawAccess&lt;&gt;::load(p);
242     if (old_val == compare_value) {
243       RawAccess&lt;&gt;::store(p, new_value);
244     }
245     return old_val;
246   }
247 }
248 
249 class RawAccessBarrierArrayCopy: public AllStatic {
250   template&lt;typename T&gt; struct IsHeapWordSized: public IntegralConstant&lt;bool, sizeof(T) == HeapWordSize&gt; { };
251 public:
252   template &lt;DecoratorSet decorators, typename T&gt;
253   static inline typename EnableIf&lt;
254     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value&gt;::type
255   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
256             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
257             size_t length) {
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 26 #define SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 27 
 28 #include &quot;oops/access.hpp&quot;
 29 #include &quot;oops/accessBackend.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-added"> 32 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;runtime/orderAccess.hpp&quot;</span>
 34 
 35 template &lt;DecoratorSet decorators&gt;
 36 template &lt;DecoratorSet idecorators, typename T&gt;
 37 inline typename EnableIf&lt;
 38   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 39 RawAccessBarrier&lt;decorators&gt;::decode_internal(typename HeapOopType&lt;idecorators&gt;::type value) {
 40   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 41     return CompressedOops::decode_not_null(value);
 42   } else {
 43     return CompressedOops::decode(value);
 44   }
 45 }
 46 
 47 template &lt;DecoratorSet decorators&gt;
 48 template &lt;DecoratorSet idecorators, typename T&gt;
 49 inline typename EnableIf&lt;
 50   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 51   typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 52 RawAccessBarrier&lt;decorators&gt;::encode_internal(T value) {
 53   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
</pre>
<hr />
<pre>
 70 inline void RawAccessBarrier&lt;decorators&gt;::oop_store_at(oop base, ptrdiff_t offset, T value) {
 71   oop_store(field_addr(base, offset), value);
 72 }
 73 
 74 template &lt;DecoratorSet decorators&gt;
 75 template &lt;typename T&gt;
 76 inline T RawAccessBarrier&lt;decorators&gt;::oop_load(void* addr) {
 77   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 78   Encoded encoded = load&lt;Encoded&gt;(reinterpret_cast&lt;Encoded*&gt;(addr));
 79   return decode&lt;T&gt;(encoded);
 80 }
 81 
 82 template &lt;DecoratorSet decorators&gt;
 83 template &lt;typename T&gt;
 84 inline T RawAccessBarrier&lt;decorators&gt;::oop_load_at(oop base, ptrdiff_t offset) {
 85   return oop_load&lt;T&gt;(field_addr(base, offset));
 86 }
 87 
 88 template &lt;DecoratorSet decorators&gt;
 89 template &lt;typename T&gt;
<span class="line-modified"> 90 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 91   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 92   Encoded encoded_new = encode(new_value);
 93   Encoded encoded_compare = encode(compare_value);
<span class="line-modified"> 94   Encoded encoded_result = atomic_cmpxchg(reinterpret_cast&lt;Encoded*&gt;(addr),</span>
<span class="line-modified"> 95                                           encoded_compare,</span>
<span class="line-modified"> 96                                           encoded_new);</span>
 97   return decode&lt;T&gt;(encoded_result);
 98 }
 99 
100 template &lt;DecoratorSet decorators&gt;
101 template &lt;typename T&gt;
<span class="line-modified">102 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">103   return oop_atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);</span>
104 }
105 
106 template &lt;DecoratorSet decorators&gt;
107 template &lt;typename T&gt;
<span class="line-modified">108 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(void* addr, T new_value) {</span>
109   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
110   Encoded encoded_new = encode(new_value);
<span class="line-modified">111   Encoded encoded_result = atomic_xchg(reinterpret_cast&lt;Encoded*&gt;(addr), encoded_new);</span>
112   return decode&lt;T&gt;(encoded_result);
113 }
114 
115 template &lt;DecoratorSet decorators&gt;
116 template &lt;typename T&gt;
<span class="line-modified">117 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">118   return oop_atomic_xchg(field_addr(base, offset), new_value);</span>
119 }
120 
121 template &lt;DecoratorSet decorators&gt;
122 template &lt;typename T&gt;
123 inline bool RawAccessBarrier&lt;decorators&gt;::oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
124                                                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
125                                                         size_t length) {
126   return arraycopy(src_obj, src_offset_in_bytes, src_raw,
127                    dst_obj, dst_offset_in_bytes, dst_raw,
128                    length);
129 }
130 
131 template &lt;DecoratorSet decorators&gt;
132 template &lt;DecoratorSet ds, typename T&gt;
133 inline typename EnableIf&lt;
134   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
135 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
136   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
137     OrderAccess::fence();
138   }
<span class="line-modified">139   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
140 }
141 
142 template &lt;DecoratorSet decorators&gt;
143 template &lt;DecoratorSet ds, typename T&gt;
144 inline typename EnableIf&lt;
145   HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
146 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
<span class="line-modified">147   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
148 }
149 
150 template &lt;DecoratorSet decorators&gt;
151 template &lt;DecoratorSet ds, typename T&gt;
152 inline typename EnableIf&lt;
153   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
154 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
155   return Atomic::load(reinterpret_cast&lt;const volatile T*&gt;(addr));
156 }
157 
158 template &lt;DecoratorSet decorators&gt;
159 template &lt;DecoratorSet ds, typename T&gt;
160 inline typename EnableIf&lt;
161   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
162 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">163   Atomic::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
164 }
165 
166 template &lt;DecoratorSet decorators&gt;
167 template &lt;DecoratorSet ds, typename T&gt;
168 inline typename EnableIf&lt;
169   HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
170 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">171   Atomic::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
172 }
173 
174 template &lt;DecoratorSet decorators&gt;
175 template &lt;DecoratorSet ds, typename T&gt;
176 inline typename EnableIf&lt;
177   HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
178 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="line-modified">179   Atomic::store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
180 }
181 
182 template &lt;DecoratorSet decorators&gt;
183 template &lt;DecoratorSet ds, typename T&gt;
184 inline typename EnableIf&lt;
185   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified">186 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">187   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>

188                          compare_value,
<span class="line-added">189                          new_value,</span>
190                          memory_order_relaxed);
191 }
192 
193 template &lt;DecoratorSet decorators&gt;
194 template &lt;DecoratorSet ds, typename T&gt;
195 inline typename EnableIf&lt;
196   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">197 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">198   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>

199                          compare_value,
<span class="line-added">200                          new_value,</span>
201                          memory_order_conservative);
202 }
203 
204 template &lt;DecoratorSet decorators&gt;
205 template &lt;DecoratorSet ds, typename T&gt;
206 inline typename EnableIf&lt;
207   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">208 RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(void* addr, T new_value) {</span>
<span class="line-modified">209   return Atomic::xchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>
<span class="line-modified">210                       new_value);</span>
211 }
212 
213 // For platforms that do not have native support for wide atomics,
214 // we can emulate the atomicity using a lock. So here we check
215 // whether that is necessary or not.
216 
217 template &lt;DecoratorSet ds&gt;
218 template &lt;DecoratorSet decorators, typename T&gt;
219 inline typename EnableIf&lt;
220   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">221 RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(void* addr, T new_value) {</span>
222   if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="line-modified">223     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);</span>
224   } else {
225     AccessInternal::AccessLocker access_lock;
226     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
227     T old_val = RawAccess&lt;&gt;::load(p);
228     RawAccess&lt;&gt;::store(p, new_value);
229     return old_val;
230   }
231 }
232 
233 template &lt;DecoratorSet ds&gt;
234 template &lt;DecoratorSet decorators, typename T&gt;
235 inline typename EnableIf&lt;
236   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">237 RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {</span>
238   if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="line-modified">239     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);</span>
240   } else {
241     AccessInternal::AccessLocker access_lock;
242     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
243     T old_val = RawAccess&lt;&gt;::load(p);
244     if (old_val == compare_value) {
245       RawAccess&lt;&gt;::store(p, new_value);
246     }
247     return old_val;
248   }
249 }
250 
251 class RawAccessBarrierArrayCopy: public AllStatic {
252   template&lt;typename T&gt; struct IsHeapWordSized: public IntegralConstant&lt;bool, sizeof(T) == HeapWordSize&gt; { };
253 public:
254   template &lt;DecoratorSet decorators, typename T&gt;
255   static inline typename EnableIf&lt;
256     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value&gt;::type
257   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
258             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
259             size_t length) {
</pre>
</td>
</tr>
</table>
<center><a href="accessBackend.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
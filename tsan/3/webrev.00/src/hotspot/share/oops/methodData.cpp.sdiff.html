<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/methodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;

  27 #include &quot;compiler/compilerOracle.hpp&quot;
  28 #include &quot;interpreter/bytecode.hpp&quot;
  29 #include &quot;interpreter/bytecodeStream.hpp&quot;
  30 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-removed">  31 #include &quot;memory/heapInspection.hpp&quot;</span>
  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/methodData.inline.hpp&quot;
  35 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  36 #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">  37 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  38 #include &quot;runtime/deoptimization.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/orderAccess.hpp&quot;
  41 #include &quot;runtime/safepointVerifiers.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 
  45 // ==================================================================
  46 // DataLayout
  47 //
  48 // Overlay for generic profiling data.
  49 
  50 // Some types of data layouts need a length field.
  51 bool DataLayout::needs_array_len(u1 tag) {
  52   return (tag == multi_branch_data_tag) || (tag == arg_info_data_tag) || (tag == parameters_type_data_tag);
  53 }
  54 
  55 // Perform generic initialization of the data.  More specific
  56 // initialization occurs in overrides of ProfileData::post_initialize.
  57 void DataLayout::initialize(u1 tag, u2 bci, int cell_count) {
</pre>
<hr />
<pre>
 182   if (c == Bytecodes::_goto_w || c == Bytecodes::_jsr_w) {
 183     target = stream-&gt;dest_w();
 184   } else {
 185     target = stream-&gt;dest();
 186   }
 187   int my_di = mdo-&gt;dp_to_di(dp());
 188   int target_di = mdo-&gt;bci_to_di(target);
 189   int offset = target_di - my_di;
 190   set_displacement(offset);
 191 }
 192 
 193 void JumpData::print_data_on(outputStream* st, const char* extra) const {
 194   print_shared(st, &quot;JumpData&quot;, extra);
 195   st-&gt;print_cr(&quot;taken(%u) displacement(%d)&quot;, taken(), displacement());
 196 }
 197 
 198 int TypeStackSlotEntries::compute_cell_count(Symbol* signature, bool include_receiver, int max) {
 199   // Parameter profiling include the receiver
 200   int args_count = include_receiver ? 1 : 0;
 201   ResourceMark rm;
<span class="line-modified"> 202   SignatureStream ss(signature);</span>
<span class="line-modified"> 203   args_count += ss.reference_parameter_count();</span>
 204   args_count = MIN2(args_count, max);
 205   return args_count * per_arg_cell_count;
 206 }
 207 
 208 int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
 209   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 210   assert(TypeStackSlotEntries::per_arg_count() &gt; ReturnTypeEntry::static_cell_count(), &quot;code to test for arguments/results broken&quot;);
 211   const methodHandle m = stream-&gt;method();
 212   int bci = stream-&gt;bci();
 213   Bytecode_invoke inv(m, bci);
 214   int args_cell = 0;
 215   if (MethodData::profile_arguments_for_invoke(m, bci)) {
 216     args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
 217   }
 218   int ret_cell = 0;
<span class="line-modified"> 219   if (MethodData::profile_return_for_invoke(m, bci) &amp;&amp; (inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY)) {</span>
 220     ret_cell = ReturnTypeEntry::static_cell_count();
 221   }
 222   int header_cell = 0;
 223   if (args_cell + ret_cell &gt; 0) {
 224     header_cell = header_cell_count();
 225   }
 226 
 227   return header_cell + args_cell + ret_cell;
 228 }
 229 
<span class="line-modified"> 230 class ArgumentOffsetComputer : public SignatureInfo {</span>
 231 private:
 232   int _max;

 233   GrowableArray&lt;int&gt; _offsets;
 234 
<span class="line-modified"> 235   void set(int size, BasicType type) { _size += size; }</span>
<span class="line-modified"> 236   void do_object(int begin, int end) {</span>
<span class="line-modified"> 237     if (_offsets.length() &lt; _max) {</span>
<span class="line-modified"> 238       _offsets.push(_size);</span>
 239     }
<span class="line-modified"> 240     SignatureInfo::do_object(begin, end);</span>
<span class="line-removed"> 241   }</span>
<span class="line-removed"> 242   void do_array (int begin, int end) {</span>
<span class="line-removed"> 243     if (_offsets.length() &lt; _max) {</span>
<span class="line-removed"> 244       _offsets.push(_size);</span>
<span class="line-removed"> 245     }</span>
<span class="line-removed"> 246     SignatureInfo::do_array(begin, end);</span>
 247   }
 248 
<span class="line-modified"> 249 public:</span>
 250   ArgumentOffsetComputer(Symbol* signature, int max)
<span class="line-modified"> 251     : SignatureInfo(signature), _max(max), _offsets(Thread::current(), max) {</span>



 252   }
 253 
<span class="line-removed"> 254   int total() { lazy_iterate_parameters(); return _size; }</span>
<span class="line-removed"> 255 </span>
 256   int off_at(int i) const { return _offsets.at(i); }
 257 };
 258 
 259 void TypeStackSlotEntries::post_initialize(Symbol* signature, bool has_receiver, bool include_receiver) {
 260   ResourceMark rm;
 261   int start = 0;
 262   // Parameter profiling include the receiver
 263   if (include_receiver &amp;&amp; has_receiver) {
 264     set_stack_slot(0, 0);
 265     set_type(0, type_none());
 266     start += 1;
 267   }
 268   ArgumentOffsetComputer aos(signature, _number_of_entries-start);
<span class="line-removed"> 269   aos.total();</span>
 270   for (int i = start; i &lt; _number_of_entries; i++) {
 271     set_stack_slot(i, aos.off_at(i-start) + (has_receiver ? 1 : 0));
 272     set_type(i, type_none());
 273   }
 274 }
 275 
 276 void CallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 277   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 278   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 279 
<span class="line-removed"> 280   SignatureStream ss(inv.signature());</span>
 281   if (has_arguments()) {
 282 #ifdef ASSERT
 283     ResourceMark rm;
<span class="line-modified"> 284     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>

 285     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 286     check_number_of_arguments(count);
 287 #endif
 288     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 289   }
 290 
 291   if (has_return()) {
<span class="line-modified"> 292     assert(inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY, &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
 293     _ret.post_initialize();
 294   }
 295 }
 296 
 297 void VirtualCallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 298   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 299   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 300 
 301   if (has_arguments()) {
 302 #ifdef ASSERT
 303     ResourceMark rm;
<span class="line-modified"> 304     SignatureStream ss(inv.signature());</span>
<span class="line-modified"> 305     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>
 306     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 307     check_number_of_arguments(count);
 308 #endif
 309     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 310   }
 311 
 312   if (has_return()) {
<span class="line-modified"> 313     assert(inv.result_type() == T_OBJECT || inv.result_type() == T_ARRAY, &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
 314     _ret.post_initialize();
 315   }
 316 }
 317 
 318 void TypeStackSlotEntries::clean_weak_klass_links(bool always_clean) {
 319   for (int i = 0; i &lt; _number_of_entries; i++) {
 320     intptr_t p = type(i);
 321     Klass* k = (Klass*)klass_part(p);
 322     if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 323       set_type(i, with_status((Klass*)NULL, p));
 324     }
 325   }
 326 }
 327 
 328 void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {
 329   intptr_t p = type();
 330   Klass* k = (Klass*)klass_part(p);
 331   if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 332     set_type(with_status((Klass*)NULL, p));
 333   }
</pre>
<hr />
<pre>
 651   st-&gt;print_cr(&quot;default_count(%u) displacement(%d)&quot;,
 652                default_count(), default_displacement());
 653   int cases = number_of_cases();
 654   for (int i = 0; i &lt; cases; i++) {
 655     tab(st);
 656     st-&gt;print_cr(&quot;count(%u) displacement(%d)&quot;,
 657                  count_at(i), displacement_at(i));
 658   }
 659 }
 660 
 661 void ArgInfoData::print_data_on(outputStream* st, const char* extra) const {
 662   print_shared(st, &quot;ArgInfoData&quot;, extra);
 663   int nargs = number_of_args();
 664   for (int i = 0; i &lt; nargs; i++) {
 665     st-&gt;print(&quot;  0x%x&quot;, arg_modified(i));
 666   }
 667   st-&gt;cr();
 668 }
 669 
 670 int ParametersTypeData::compute_cell_count(Method* m) {
<span class="line-modified"> 671   if (!MethodData::profile_parameters_for_method(m)) {</span>
 672     return 0;
 673   }
 674   int max = TypeProfileParmsLimit == -1 ? INT_MAX : TypeProfileParmsLimit;
 675   int obj_args = TypeStackSlotEntries::compute_cell_count(m-&gt;signature(), !m-&gt;is_static(), max);
 676   if (obj_args &gt; 0) {
 677     return obj_args + 1; // 1 cell for array len
 678   }
 679   return 0;
 680 }
 681 
 682 void ParametersTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 683   _parameters.post_initialize(mdo-&gt;method()-&gt;signature(), !mdo-&gt;method()-&gt;is_static(), true);
 684 }
 685 
 686 bool ParametersTypeData::profiling_enabled() {
 687   return MethodData::profile_parameters();
 688 }
 689 
 690 void ParametersTypeData::print_data_on(outputStream* st, const char* extra) const {
 691   st-&gt;print(&quot;parameter types&quot;); // FIXME extra ignored?
 692   _parameters.print_data_on(st);
 693 }
 694 
 695 void SpeculativeTrapData::print_data_on(outputStream* st, const char* extra) const {
 696   print_shared(st, &quot;SpeculativeTrapData&quot;, extra);
 697   tab(st);
 698   method()-&gt;print_short_name(st);
 699   st-&gt;cr();
 700 }
 701 
 702 // ==================================================================
 703 // MethodData*
 704 //
 705 // A MethodData* holds information which has been collected about
 706 // a method.
 707 
 708 MethodData* MethodData::allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS) {
 709   int size = MethodData::compute_allocation_size_in_words(method);
 710 
 711   return new (loader_data, size, MetaspaceObj::MethodDataType, THREAD)
<span class="line-modified"> 712     MethodData(method(), size, THREAD);</span>
 713 }
 714 
 715 int MethodData::bytecode_cell_count(Bytecodes::Code code) {
 716   if (is_client_compilation_mode_vm()) {
 717     return no_profile_data;
 718   }
 719   switch (code) {
 720   case Bytecodes::_checkcast:
 721   case Bytecodes::_instanceof:
 722   case Bytecodes::_aastore:
 723     if (TypeProfileCasts) {
 724       return ReceiverTypeData::static_cell_count();
 725     } else {
 726       return BitData::static_cell_count();
 727     }
 728   case Bytecodes::_invokespecial:
 729   case Bytecodes::_invokestatic:
 730     if (MethodData::profile_arguments() || MethodData::profile_return()) {
 731       return variable_cell_count;
 732     } else {
</pre>
<hr />
<pre>
 829   case Bytecodes::_instanceof:
 830   case Bytecodes::_aastore:
 831   case Bytecodes::_invokevirtual:
 832   case Bytecodes::_invokeinterface:
 833   case Bytecodes::_if_acmpeq:
 834   case Bytecodes::_if_acmpne:
 835   case Bytecodes::_ifnull:
 836   case Bytecodes::_ifnonnull:
 837   case Bytecodes::_invokestatic:
 838 #ifdef COMPILER2
 839     if (is_server_compilation_mode_vm()) {
 840       return UseTypeSpeculation;
 841     }
 842 #endif
 843   default:
 844     return false;
 845   }
 846   return false;
 847 }
 848 
















































































 849 int MethodData::compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps) {
 850 #if INCLUDE_JVMCI
 851   if (ProfileTraps) {
 852     // Assume that up to 30% of the possibly trapping BCIs with no MDP will need to allocate one.
 853     int extra_data_count = MIN2(empty_bc_count, MAX2(4, (empty_bc_count * 30) / 100));
 854 
 855     // Make sure we have a minimum number of extra data slots to
 856     // allocate SpeculativeTrapData entries. We would want to have one
 857     // entry per compilation that inlines this method and for which
 858     // some type speculation assumption fails. So the room we need for
 859     // the SpeculativeTrapData entries doesn&#39;t directly depend on the
 860     // size of the method. Because it&#39;s hard to estimate, we reserve
 861     // space for an arbitrary number of entries.
 862     int spec_data_count = (needs_speculative_traps ? SpecTrapLimitExtraEntries : 0) *
 863       (SpeculativeTrapData::static_cell_count() + DataLayout::header_size_in_cells());
 864 
 865     return MAX2(extra_data_count, spec_data_count);
 866   } else {
 867     return 0;
 868   }
</pre>
<hr />
<pre>
1115   return next;
1116 }
1117 
1118 // Give each of the data entries a chance to perform specific
1119 // data initialization.
1120 void MethodData::post_initialize(BytecodeStream* stream) {
1121   ResourceMark rm;
1122   ProfileData* data;
1123   for (data = first_data(); is_valid(data); data = next_data(data)) {
1124     stream-&gt;set_start(data-&gt;bci());
1125     stream-&gt;next();
1126     data-&gt;post_initialize(stream, this);
1127   }
1128   if (_parameters_type_data_di != no_parameters) {
1129     parameters_type_data()-&gt;post_initialize(NULL, this);
1130   }
1131 }
1132 
1133 // Initialize the MethodData* corresponding to a given method.
1134 MethodData::MethodData(const methodHandle&amp; method, int size, TRAPS)
<span class="line-modified">1135   : _extra_data_lock(Monitor::leaf, &quot;MDO extra data lock&quot;),</span>
1136     _parameters_type_data_di(parameters_uninitialized) {
1137   // Set the method back-pointer.
1138   _method = method();
1139   initialize();
1140 }
1141 
1142 void MethodData::initialize() {

1143   NoSafepointVerifier no_safepoint;  // init function atomic wrt GC
<span class="line-modified">1144   ResourceMark rm;</span>
1145 
1146   init();
1147   set_creation_mileage(mileage_of(method()));
1148 
1149   // Go through the bytecodes and allocate and initialize the
1150   // corresponding data cells.
1151   int data_size = 0;
1152   int empty_bc_count = 0;  // number of bytecodes lacking data
1153   _data[0] = 0;  // apparently not set below.
<span class="line-modified">1154   BytecodeStream stream(method());</span>
1155   Bytecodes::Code c;
1156   bool needs_speculative_traps = false;
1157   while ((c = stream.next()) &gt;= 0) {
1158     int size_in_bytes = initialize_data(&amp;stream, data_size);
1159     data_size += size_in_bytes;
1160     if (size_in_bytes == 0 JVMCI_ONLY(&amp;&amp; Bytecodes::can_trap(c)))  empty_bc_count += 1;
1161     needs_speculative_traps = needs_speculative_traps || is_speculative_trap_bytecode(c);
1162   }
1163   _data_size = data_size;
1164   int object_size = in_bytes(data_offset()) + data_size;
1165 
1166   // Add some extra DataLayout cells (at least one) to track stray traps.
1167   int extra_data_count = compute_extra_data_count(data_size, empty_bc_count, needs_speculative_traps);
1168   int extra_size = extra_data_count * DataLayout::compute_size_in_bytes(0);
1169 
1170   // Let&#39;s zero the space for the extra data
1171   Copy::zero_to_bytes(((address)_data) + data_size, extra_size);
1172 
1173   // Add a cell to record information about modified arguments.
1174   // Set up _args_modified array after traps cells so that
</pre>
<hr />
<pre>
1187   // for method entry so they don&#39;t fit with the framework for the
1188   // profiling of bytecodes). We store the offset within the MDO of
1189   // this area (or -1 if no parameter is profiled)
1190   if (parms_cell &gt; 0) {
1191     object_size += DataLayout::compute_size_in_bytes(parms_cell);
1192     _parameters_type_data_di = data_size + extra_size + arg_data_size;
1193     DataLayout *dp = data_layout_at(data_size + extra_size + arg_data_size);
1194     dp-&gt;initialize(DataLayout::parameters_type_data_tag, 0, parms_cell);
1195   } else {
1196     _parameters_type_data_di = no_parameters;
1197   }
1198 
1199   // Set an initial hint. Don&#39;t use set_hint_di() because
1200   // first_di() may be out of bounds if data_size is 0.
1201   // In that situation, _hint_di is never used, but at
1202   // least well-defined.
1203   _hint_di = first_di();
1204 
1205   post_initialize(&amp;stream);
1206 
<span class="line-modified">1207   assert(object_size == compute_allocation_size_in_bytes(methodHandle(_method)), &quot;MethodData: computed size != initialized size&quot;);</span>
1208   set_size(object_size);
1209 }
1210 
1211 void MethodData::init() {
1212   _invocation_counter.init();
1213   _backedge_counter.init();
1214   _invocation_counter_start = 0;
1215   _backedge_counter_start = 0;
1216 
1217   // Set per-method invoke- and backedge mask.
1218   double scale = 1.0;
<span class="line-modified">1219   CompilerOracle::has_option_value(_method, &quot;CompileThresholdScaling&quot;, scale);</span>

1220   _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1221   _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1222 
1223   _tenure_traps = 0;
1224   _num_loops = 0;
1225   _num_blocks = 0;
1226   _would_profile = unknown;
1227 
1228 #if INCLUDE_JVMCI
1229   _jvmci_ir_size = 0;

1230 #endif
1231 
1232 #if INCLUDE_RTM_OPT
1233   _rtm_state = NoRTM; // No RTM lock eliding by default
1234   if (UseRTMLocking &amp;&amp;
<span class="line-modified">1235       !CompilerOracle::has_option_string(_method, &quot;NoRTMLockEliding&quot;)) {</span>
<span class="line-modified">1236     if (CompilerOracle::has_option_string(_method, &quot;UseRTMLockEliding&quot;) || !UseRTMDeopt) {</span>
1237       // Generate RTM lock eliding code without abort ratio calculation code.
1238       _rtm_state = UseRTM;
1239     } else if (UseRTMDeopt) {
1240       // Generate RTM lock eliding code and include abort ratio calculation
1241       // code if UseRTMDeopt is on.
1242       _rtm_state = ProfileRTM;
1243     }
1244   }
1245 #endif
1246 
1247   // Initialize flags and trap history.
1248   _nof_decompiles = 0;
1249   _nof_overflow_recompiles = 0;
1250   _nof_overflow_traps = 0;
1251   clear_escape_info();
1252   assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, &quot;align&quot;);
1253   Copy::zero_to_words((HeapWord*) &amp;_trap_hist,
1254                       sizeof(_trap_hist) / sizeof(HeapWord));
1255 }
1256 
</pre>
<hr />
<pre>
1315   int nb_cells = 0;
1316   switch(dp-&gt;tag()) {
1317   case DataLayout::bit_data_tag:
1318   case DataLayout::no_tag:
1319     nb_cells = BitData::static_cell_count();
1320     break;
1321   case DataLayout::speculative_trap_data_tag:
1322     nb_cells = SpeculativeTrapData::static_cell_count();
1323     break;
1324   default:
1325     fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1326   }
1327   return (DataLayout*)((address)dp + DataLayout::compute_size_in_bytes(nb_cells));
1328 }
1329 
1330 ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent) {
1331   DataLayout* end = args_data_limit();
1332 
1333   for (;; dp = next_extra(dp)) {
1334     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">1335     // No need for &quot;OrderAccess::load_acquire&quot; ops,</span>
1336     // since the data structure is monotonic.
1337     switch(dp-&gt;tag()) {
1338     case DataLayout::no_tag:
1339       return NULL;
1340     case DataLayout::arg_info_data_tag:
1341       dp = end;
1342       return NULL; // ArgInfoData is at the end of extra data section.
1343     case DataLayout::bit_data_tag:
1344       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
1345         return new BitData(dp);
1346       }
1347       break;
1348     case DataLayout::speculative_trap_data_tag:
1349       if (m != NULL) {
1350         SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1351         // data-&gt;method() may be null in case of a concurrent
1352         // allocation. Maybe it&#39;s for the same method. Try to use that
1353         // entry in that case.
1354         if (dp-&gt;bci() == bci) {
1355           if (data-&gt;method() == NULL) {
</pre>
<hr />
<pre>
1450   st-&gt;print(&quot;method data for &quot;);
1451   method()-&gt;print_value_on(st);
1452 }
1453 
1454 void MethodData::print_data_on(outputStream* st) const {
1455   ResourceMark rm;
1456   ProfileData* data = first_data();
1457   if (_parameters_type_data_di != no_parameters) {
1458     parameters_type_data()-&gt;print_data_on(st);
1459   }
1460   for ( ; is_valid(data); data = next_data(data)) {
1461     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1462     st-&gt;fill_to(6);
1463     data-&gt;print_data_on(st, this);
1464   }
1465   st-&gt;print_cr(&quot;--- Extra data:&quot;);
1466   DataLayout* dp    = extra_data_base();
1467   DataLayout* end   = args_data_limit();
1468   for (;; dp = next_extra(dp)) {
1469     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">1470     // No need for &quot;OrderAccess::load_acquire&quot; ops,</span>
1471     // since the data structure is monotonic.
1472     switch(dp-&gt;tag()) {
1473     case DataLayout::no_tag:
1474       continue;
1475     case DataLayout::bit_data_tag:
1476       data = new BitData(dp);
1477       break;
1478     case DataLayout::speculative_trap_data_tag:
1479       data = new SpeculativeTrapData(dp);
1480       break;
1481     case DataLayout::arg_info_data_tag:
1482       data = new ArgInfoData(dp);
1483       dp = end; // ArgInfoData is at the end of extra data section.
1484       break;
1485     default:
1486       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1487     }
1488     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1489     st-&gt;fill_to(6);
1490     data-&gt;print_data_on(st);
1491     if (dp &gt;= end) return;
1492   }
1493 }
1494 
<span class="line-removed">1495 #if INCLUDE_SERVICES</span>
<span class="line-removed">1496 // Size Statistics</span>
<span class="line-removed">1497 void MethodData::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">1498   int n = sz-&gt;count(this);</span>
<span class="line-removed">1499   sz-&gt;_method_data_bytes += n;</span>
<span class="line-removed">1500   sz-&gt;_method_all_bytes += n;</span>
<span class="line-removed">1501   sz-&gt;_rw_bytes += n;</span>
<span class="line-removed">1502 }</span>
<span class="line-removed">1503 #endif // INCLUDE_SERVICES</span>
<span class="line-removed">1504 </span>
1505 // Verification
1506 
1507 void MethodData::verify_on(outputStream* st) {
1508   guarantee(is_methodData(), &quot;object must be method data&quot;);
1509   // guarantee(m-&gt;is_perm(), &quot;should be in permspace&quot;);
1510   this-&gt;verify_data_on(st);
1511 }
1512 
1513 void MethodData::verify_data_on(outputStream* st) {
1514   NEEDS_CLEANUP;
1515   // not yet implemented.
1516 }
1517 
1518 bool MethodData::profile_jsr292(const methodHandle&amp; m, int bci) {
1519   if (m-&gt;is_compiled_lambda_form()) {
1520     return true;
1521   }
1522 
1523   Bytecode_invoke inv(m , bci);
1524   return inv.is_invokedynamic() || inv.is_invokehandle();
1525 }
1526 
1527 bool MethodData::profile_unsafe(const methodHandle&amp; m, int bci) {
1528   Bytecode_invoke inv(m , bci);
<span class="line-modified">1529   if (inv.is_invokevirtual() &amp;&amp; inv.klass() == vmSymbols::jdk_internal_misc_Unsafe()) {</span>
<span class="line-modified">1530     ResourceMark rm;</span>
<span class="line-modified">1531     char* name = inv.name()-&gt;as_C_string();</span>
<span class="line-modified">1532     if (!strncmp(name, &quot;get&quot;, 3) || !strncmp(name, &quot;put&quot;, 3)) {</span>
<span class="line-modified">1533       return true;</span>



1534     }
1535   }
1536   return false;
1537 }
1538 
1539 int MethodData::profile_arguments_flag() {
1540   return TypeProfileLevel % 10;
1541 }
1542 
1543 bool MethodData::profile_arguments() {
1544   return profile_arguments_flag() &gt; no_type_profile &amp;&amp; profile_arguments_flag() &lt;= type_profile_all;
1545 }
1546 
1547 bool MethodData::profile_arguments_jsr292_only() {
1548   return profile_arguments_flag() == type_profile_jsr292;
1549 }
1550 
1551 bool MethodData::profile_all_arguments() {
1552   return profile_arguments_flag() == type_profile_all;
1553 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">  27 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  28 #include &quot;compiler/compilerOracle.hpp&quot;
  29 #include &quot;interpreter/bytecode.hpp&quot;
  30 #include &quot;interpreter/bytecodeStream.hpp&quot;
  31 #include &quot;interpreter/linkResolver.hpp&quot;

  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/methodData.inline.hpp&quot;
  35 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  36 #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">  37 #include &quot;runtime/atomic.hpp&quot;</span>
  38 #include &quot;runtime/deoptimization.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/orderAccess.hpp&quot;
  41 #include &quot;runtime/safepointVerifiers.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 
  45 // ==================================================================
  46 // DataLayout
  47 //
  48 // Overlay for generic profiling data.
  49 
  50 // Some types of data layouts need a length field.
  51 bool DataLayout::needs_array_len(u1 tag) {
  52   return (tag == multi_branch_data_tag) || (tag == arg_info_data_tag) || (tag == parameters_type_data_tag);
  53 }
  54 
  55 // Perform generic initialization of the data.  More specific
  56 // initialization occurs in overrides of ProfileData::post_initialize.
  57 void DataLayout::initialize(u1 tag, u2 bci, int cell_count) {
</pre>
<hr />
<pre>
 182   if (c == Bytecodes::_goto_w || c == Bytecodes::_jsr_w) {
 183     target = stream-&gt;dest_w();
 184   } else {
 185     target = stream-&gt;dest();
 186   }
 187   int my_di = mdo-&gt;dp_to_di(dp());
 188   int target_di = mdo-&gt;bci_to_di(target);
 189   int offset = target_di - my_di;
 190   set_displacement(offset);
 191 }
 192 
 193 void JumpData::print_data_on(outputStream* st, const char* extra) const {
 194   print_shared(st, &quot;JumpData&quot;, extra);
 195   st-&gt;print_cr(&quot;taken(%u) displacement(%d)&quot;, taken(), displacement());
 196 }
 197 
 198 int TypeStackSlotEntries::compute_cell_count(Symbol* signature, bool include_receiver, int max) {
 199   // Parameter profiling include the receiver
 200   int args_count = include_receiver ? 1 : 0;
 201   ResourceMark rm;
<span class="line-modified"> 202   ReferenceArgumentCount rac(signature);</span>
<span class="line-modified"> 203   args_count += rac.count();</span>
 204   args_count = MIN2(args_count, max);
 205   return args_count * per_arg_cell_count;
 206 }
 207 
 208 int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
 209   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 210   assert(TypeStackSlotEntries::per_arg_count() &gt; ReturnTypeEntry::static_cell_count(), &quot;code to test for arguments/results broken&quot;);
 211   const methodHandle m = stream-&gt;method();
 212   int bci = stream-&gt;bci();
 213   Bytecode_invoke inv(m, bci);
 214   int args_cell = 0;
 215   if (MethodData::profile_arguments_for_invoke(m, bci)) {
 216     args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
 217   }
 218   int ret_cell = 0;
<span class="line-modified"> 219   if (MethodData::profile_return_for_invoke(m, bci) &amp;&amp; is_reference_type(inv.result_type())) {</span>
 220     ret_cell = ReturnTypeEntry::static_cell_count();
 221   }
 222   int header_cell = 0;
 223   if (args_cell + ret_cell &gt; 0) {
 224     header_cell = header_cell_count();
 225   }
 226 
 227   return header_cell + args_cell + ret_cell;
 228 }
 229 
<span class="line-modified"> 230 class ArgumentOffsetComputer : public SignatureIterator {</span>
 231 private:
 232   int _max;
<span class="line-added"> 233   int _offset;</span>
 234   GrowableArray&lt;int&gt; _offsets;
 235 
<span class="line-modified"> 236   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 237   void do_type(BasicType type) {</span>
<span class="line-modified"> 238     if (is_reference_type(type) &amp;&amp; _offsets.length() &lt; _max) {</span>
<span class="line-modified"> 239       _offsets.push(_offset);</span>
 240     }
<span class="line-modified"> 241     _offset += parameter_type_word_count(type);</span>






 242   }
 243 
<span class="line-modified"> 244  public:</span>
 245   ArgumentOffsetComputer(Symbol* signature, int max)
<span class="line-modified"> 246     : SignatureIterator(signature),</span>
<span class="line-added"> 247       _max(max), _offset(0),</span>
<span class="line-added"> 248       _offsets(Thread::current(), max) {</span>
<span class="line-added"> 249     do_parameters_on(this);  // non-virtual template execution</span>
 250   }
 251 


 252   int off_at(int i) const { return _offsets.at(i); }
 253 };
 254 
 255 void TypeStackSlotEntries::post_initialize(Symbol* signature, bool has_receiver, bool include_receiver) {
 256   ResourceMark rm;
 257   int start = 0;
 258   // Parameter profiling include the receiver
 259   if (include_receiver &amp;&amp; has_receiver) {
 260     set_stack_slot(0, 0);
 261     set_type(0, type_none());
 262     start += 1;
 263   }
 264   ArgumentOffsetComputer aos(signature, _number_of_entries-start);

 265   for (int i = start; i &lt; _number_of_entries; i++) {
 266     set_stack_slot(i, aos.off_at(i-start) + (has_receiver ? 1 : 0));
 267     set_type(i, type_none());
 268   }
 269 }
 270 
 271 void CallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 272   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 273   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 274 

 275   if (has_arguments()) {
 276 #ifdef ASSERT
 277     ResourceMark rm;
<span class="line-modified"> 278     ReferenceArgumentCount rac(inv.signature());</span>
<span class="line-added"> 279     int count = MIN2(rac.count(), (int)TypeProfileArgsLimit);</span>
 280     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 281     check_number_of_arguments(count);
 282 #endif
 283     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 284   }
 285 
 286   if (has_return()) {
<span class="line-modified"> 287     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
 288     _ret.post_initialize();
 289   }
 290 }
 291 
 292 void VirtualCallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 293   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 294   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 295 
 296   if (has_arguments()) {
 297 #ifdef ASSERT
 298     ResourceMark rm;
<span class="line-modified"> 299     ReferenceArgumentCount rac(inv.signature());</span>
<span class="line-modified"> 300     int count = MIN2(rac.count(), (int)TypeProfileArgsLimit);</span>
 301     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 302     check_number_of_arguments(count);
 303 #endif
 304     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 305   }
 306 
 307   if (has_return()) {
<span class="line-modified"> 308     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);</span>
 309     _ret.post_initialize();
 310   }
 311 }
 312 
 313 void TypeStackSlotEntries::clean_weak_klass_links(bool always_clean) {
 314   for (int i = 0; i &lt; _number_of_entries; i++) {
 315     intptr_t p = type(i);
 316     Klass* k = (Klass*)klass_part(p);
 317     if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 318       set_type(i, with_status((Klass*)NULL, p));
 319     }
 320   }
 321 }
 322 
 323 void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {
 324   intptr_t p = type();
 325   Klass* k = (Klass*)klass_part(p);
 326   if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 327     set_type(with_status((Klass*)NULL, p));
 328   }
</pre>
<hr />
<pre>
 646   st-&gt;print_cr(&quot;default_count(%u) displacement(%d)&quot;,
 647                default_count(), default_displacement());
 648   int cases = number_of_cases();
 649   for (int i = 0; i &lt; cases; i++) {
 650     tab(st);
 651     st-&gt;print_cr(&quot;count(%u) displacement(%d)&quot;,
 652                  count_at(i), displacement_at(i));
 653   }
 654 }
 655 
 656 void ArgInfoData::print_data_on(outputStream* st, const char* extra) const {
 657   print_shared(st, &quot;ArgInfoData&quot;, extra);
 658   int nargs = number_of_args();
 659   for (int i = 0; i &lt; nargs; i++) {
 660     st-&gt;print(&quot;  0x%x&quot;, arg_modified(i));
 661   }
 662   st-&gt;cr();
 663 }
 664 
 665 int ParametersTypeData::compute_cell_count(Method* m) {
<span class="line-modified"> 666   if (!MethodData::profile_parameters_for_method(methodHandle(Thread::current(), m))) {</span>
 667     return 0;
 668   }
 669   int max = TypeProfileParmsLimit == -1 ? INT_MAX : TypeProfileParmsLimit;
 670   int obj_args = TypeStackSlotEntries::compute_cell_count(m-&gt;signature(), !m-&gt;is_static(), max);
 671   if (obj_args &gt; 0) {
 672     return obj_args + 1; // 1 cell for array len
 673   }
 674   return 0;
 675 }
 676 
 677 void ParametersTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 678   _parameters.post_initialize(mdo-&gt;method()-&gt;signature(), !mdo-&gt;method()-&gt;is_static(), true);
 679 }
 680 
 681 bool ParametersTypeData::profiling_enabled() {
 682   return MethodData::profile_parameters();
 683 }
 684 
 685 void ParametersTypeData::print_data_on(outputStream* st, const char* extra) const {
 686   st-&gt;print(&quot;parameter types&quot;); // FIXME extra ignored?
 687   _parameters.print_data_on(st);
 688 }
 689 
 690 void SpeculativeTrapData::print_data_on(outputStream* st, const char* extra) const {
 691   print_shared(st, &quot;SpeculativeTrapData&quot;, extra);
 692   tab(st);
 693   method()-&gt;print_short_name(st);
 694   st-&gt;cr();
 695 }
 696 
 697 // ==================================================================
 698 // MethodData*
 699 //
 700 // A MethodData* holds information which has been collected about
 701 // a method.
 702 
 703 MethodData* MethodData::allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS) {
 704   int size = MethodData::compute_allocation_size_in_words(method);
 705 
 706   return new (loader_data, size, MetaspaceObj::MethodDataType, THREAD)
<span class="line-modified"> 707     MethodData(method, size, THREAD);</span>
 708 }
 709 
 710 int MethodData::bytecode_cell_count(Bytecodes::Code code) {
 711   if (is_client_compilation_mode_vm()) {
 712     return no_profile_data;
 713   }
 714   switch (code) {
 715   case Bytecodes::_checkcast:
 716   case Bytecodes::_instanceof:
 717   case Bytecodes::_aastore:
 718     if (TypeProfileCasts) {
 719       return ReceiverTypeData::static_cell_count();
 720     } else {
 721       return BitData::static_cell_count();
 722     }
 723   case Bytecodes::_invokespecial:
 724   case Bytecodes::_invokestatic:
 725     if (MethodData::profile_arguments() || MethodData::profile_return()) {
 726       return variable_cell_count;
 727     } else {
</pre>
<hr />
<pre>
 824   case Bytecodes::_instanceof:
 825   case Bytecodes::_aastore:
 826   case Bytecodes::_invokevirtual:
 827   case Bytecodes::_invokeinterface:
 828   case Bytecodes::_if_acmpeq:
 829   case Bytecodes::_if_acmpne:
 830   case Bytecodes::_ifnull:
 831   case Bytecodes::_ifnonnull:
 832   case Bytecodes::_invokestatic:
 833 #ifdef COMPILER2
 834     if (is_server_compilation_mode_vm()) {
 835       return UseTypeSpeculation;
 836     }
 837 #endif
 838   default:
 839     return false;
 840   }
 841   return false;
 842 }
 843 
<span class="line-added"> 844 #if INCLUDE_JVMCI</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846 void* FailedSpeculation::operator new(size_t size, size_t fs_size) throw() {</span>
<span class="line-added"> 847   return CHeapObj&lt;mtCompiler&gt;::operator new(fs_size, std::nothrow);</span>
<span class="line-added"> 848 }</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850 FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(NULL) {</span>
<span class="line-added"> 851   memcpy(data(), speculation, speculation_len);</span>
<span class="line-added"> 852 }</span>
<span class="line-added"> 853 </span>
<span class="line-added"> 854 // A heuristic check to detect nmethods that outlive a failed speculations list.</span>
<span class="line-added"> 855 static void guarantee_failed_speculations_alive(nmethod* nm, FailedSpeculation** failed_speculations_address) {</span>
<span class="line-added"> 856   jlong head = (jlong)(address) *failed_speculations_address;</span>
<span class="line-added"> 857   if ((head &amp; 0x1) == 0x1) {</span>
<span class="line-added"> 858     stringStream st;</span>
<span class="line-added"> 859     if (nm != NULL) {</span>
<span class="line-added"> 860       st.print(&quot;%d&quot;, nm-&gt;compile_id());</span>
<span class="line-added"> 861       Method* method = nm-&gt;method();</span>
<span class="line-added"> 862       st.print_raw(&quot;{&quot;);</span>
<span class="line-added"> 863       if (method != NULL) {</span>
<span class="line-added"> 864         method-&gt;print_name(&amp;st);</span>
<span class="line-added"> 865       } else {</span>
<span class="line-added"> 866         const char* jvmci_name = nm-&gt;jvmci_name();</span>
<span class="line-added"> 867         if (jvmci_name != NULL) {</span>
<span class="line-added"> 868           st.print_raw(jvmci_name);</span>
<span class="line-added"> 869         }</span>
<span class="line-added"> 870       }</span>
<span class="line-added"> 871       st.print_raw(&quot;}&quot;);</span>
<span class="line-added"> 872     } else {</span>
<span class="line-added"> 873       st.print(&quot;&lt;unknown&gt;&quot;);</span>
<span class="line-added"> 874     }</span>
<span class="line-added"> 875     fatal(&quot;Adding to failed speculations list that appears to have been freed. Source: %s&quot;, st.as_string());</span>
<span class="line-added"> 876   }</span>
<span class="line-added"> 877 }</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879 bool FailedSpeculation::add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len) {</span>
<span class="line-added"> 880   assert(failed_speculations_address != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 881   size_t fs_size = sizeof(FailedSpeculation) + speculation_len;</span>
<span class="line-added"> 882   FailedSpeculation* fs = new (fs_size) FailedSpeculation(speculation, speculation_len);</span>
<span class="line-added"> 883   if (fs == NULL) {</span>
<span class="line-added"> 884     // no memory -&gt; ignore failed speculation</span>
<span class="line-added"> 885     return false;</span>
<span class="line-added"> 886   }</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888   guarantee(is_aligned(fs, sizeof(FailedSpeculation*)), &quot;FailedSpeculation objects must be pointer aligned&quot;);</span>
<span class="line-added"> 889   guarantee_failed_speculations_alive(nm, failed_speculations_address);</span>
<span class="line-added"> 890 </span>
<span class="line-added"> 891   FailedSpeculation** cursor = failed_speculations_address;</span>
<span class="line-added"> 892   do {</span>
<span class="line-added"> 893     if (*cursor == NULL) {</span>
<span class="line-added"> 894       FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) NULL, fs);</span>
<span class="line-added"> 895       if (old_fs == NULL) {</span>
<span class="line-added"> 896         // Successfully appended fs to end of the list</span>
<span class="line-added"> 897         return true;</span>
<span class="line-added"> 898       }</span>
<span class="line-added"> 899       cursor = old_fs-&gt;next_adr();</span>
<span class="line-added"> 900     } else {</span>
<span class="line-added"> 901       cursor = (*cursor)-&gt;next_adr();</span>
<span class="line-added"> 902     }</span>
<span class="line-added"> 903   } while (true);</span>
<span class="line-added"> 904 }</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906 void FailedSpeculation::free_failed_speculations(FailedSpeculation** failed_speculations_address) {</span>
<span class="line-added"> 907   assert(failed_speculations_address != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 908   FailedSpeculation* fs = *failed_speculations_address;</span>
<span class="line-added"> 909   while (fs != NULL) {</span>
<span class="line-added"> 910     FailedSpeculation* next = fs-&gt;next();</span>
<span class="line-added"> 911     delete fs;</span>
<span class="line-added"> 912     fs = next;</span>
<span class="line-added"> 913   }</span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915   // Write an unaligned value to failed_speculations_address to denote</span>
<span class="line-added"> 916   // that it is no longer a valid pointer. This is allows for the check</span>
<span class="line-added"> 917   // in add_failed_speculation against adding to a freed failed</span>
<span class="line-added"> 918   // speculations list.</span>
<span class="line-added"> 919   long* head = (long*) failed_speculations_address;</span>
<span class="line-added"> 920   (*head) = (*head) | 0x1;</span>
<span class="line-added"> 921 }</span>
<span class="line-added"> 922 #endif // INCLUDE_JVMCI</span>
<span class="line-added"> 923 </span>
 924 int MethodData::compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps) {
 925 #if INCLUDE_JVMCI
 926   if (ProfileTraps) {
 927     // Assume that up to 30% of the possibly trapping BCIs with no MDP will need to allocate one.
 928     int extra_data_count = MIN2(empty_bc_count, MAX2(4, (empty_bc_count * 30) / 100));
 929 
 930     // Make sure we have a minimum number of extra data slots to
 931     // allocate SpeculativeTrapData entries. We would want to have one
 932     // entry per compilation that inlines this method and for which
 933     // some type speculation assumption fails. So the room we need for
 934     // the SpeculativeTrapData entries doesn&#39;t directly depend on the
 935     // size of the method. Because it&#39;s hard to estimate, we reserve
 936     // space for an arbitrary number of entries.
 937     int spec_data_count = (needs_speculative_traps ? SpecTrapLimitExtraEntries : 0) *
 938       (SpeculativeTrapData::static_cell_count() + DataLayout::header_size_in_cells());
 939 
 940     return MAX2(extra_data_count, spec_data_count);
 941   } else {
 942     return 0;
 943   }
</pre>
<hr />
<pre>
1190   return next;
1191 }
1192 
1193 // Give each of the data entries a chance to perform specific
1194 // data initialization.
1195 void MethodData::post_initialize(BytecodeStream* stream) {
1196   ResourceMark rm;
1197   ProfileData* data;
1198   for (data = first_data(); is_valid(data); data = next_data(data)) {
1199     stream-&gt;set_start(data-&gt;bci());
1200     stream-&gt;next();
1201     data-&gt;post_initialize(stream, this);
1202   }
1203   if (_parameters_type_data_di != no_parameters) {
1204     parameters_type_data()-&gt;post_initialize(NULL, this);
1205   }
1206 }
1207 
1208 // Initialize the MethodData* corresponding to a given method.
1209 MethodData::MethodData(const methodHandle&amp; method, int size, TRAPS)
<span class="line-modified">1210   : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;),</span>
1211     _parameters_type_data_di(parameters_uninitialized) {
1212   // Set the method back-pointer.
1213   _method = method();
1214   initialize();
1215 }
1216 
1217 void MethodData::initialize() {
<span class="line-added">1218   Thread* thread = Thread::current();</span>
1219   NoSafepointVerifier no_safepoint;  // init function atomic wrt GC
<span class="line-modified">1220   ResourceMark rm(thread);</span>
1221 
1222   init();
1223   set_creation_mileage(mileage_of(method()));
1224 
1225   // Go through the bytecodes and allocate and initialize the
1226   // corresponding data cells.
1227   int data_size = 0;
1228   int empty_bc_count = 0;  // number of bytecodes lacking data
1229   _data[0] = 0;  // apparently not set below.
<span class="line-modified">1230   BytecodeStream stream(methodHandle(thread, method()));</span>
1231   Bytecodes::Code c;
1232   bool needs_speculative_traps = false;
1233   while ((c = stream.next()) &gt;= 0) {
1234     int size_in_bytes = initialize_data(&amp;stream, data_size);
1235     data_size += size_in_bytes;
1236     if (size_in_bytes == 0 JVMCI_ONLY(&amp;&amp; Bytecodes::can_trap(c)))  empty_bc_count += 1;
1237     needs_speculative_traps = needs_speculative_traps || is_speculative_trap_bytecode(c);
1238   }
1239   _data_size = data_size;
1240   int object_size = in_bytes(data_offset()) + data_size;
1241 
1242   // Add some extra DataLayout cells (at least one) to track stray traps.
1243   int extra_data_count = compute_extra_data_count(data_size, empty_bc_count, needs_speculative_traps);
1244   int extra_size = extra_data_count * DataLayout::compute_size_in_bytes(0);
1245 
1246   // Let&#39;s zero the space for the extra data
1247   Copy::zero_to_bytes(((address)_data) + data_size, extra_size);
1248 
1249   // Add a cell to record information about modified arguments.
1250   // Set up _args_modified array after traps cells so that
</pre>
<hr />
<pre>
1263   // for method entry so they don&#39;t fit with the framework for the
1264   // profiling of bytecodes). We store the offset within the MDO of
1265   // this area (or -1 if no parameter is profiled)
1266   if (parms_cell &gt; 0) {
1267     object_size += DataLayout::compute_size_in_bytes(parms_cell);
1268     _parameters_type_data_di = data_size + extra_size + arg_data_size;
1269     DataLayout *dp = data_layout_at(data_size + extra_size + arg_data_size);
1270     dp-&gt;initialize(DataLayout::parameters_type_data_tag, 0, parms_cell);
1271   } else {
1272     _parameters_type_data_di = no_parameters;
1273   }
1274 
1275   // Set an initial hint. Don&#39;t use set_hint_di() because
1276   // first_di() may be out of bounds if data_size is 0.
1277   // In that situation, _hint_di is never used, but at
1278   // least well-defined.
1279   _hint_di = first_di();
1280 
1281   post_initialize(&amp;stream);
1282 
<span class="line-modified">1283   assert(object_size == compute_allocation_size_in_bytes(methodHandle(thread, _method)), &quot;MethodData: computed size != initialized size&quot;);</span>
1284   set_size(object_size);
1285 }
1286 
1287 void MethodData::init() {
1288   _invocation_counter.init();
1289   _backedge_counter.init();
1290   _invocation_counter_start = 0;
1291   _backedge_counter_start = 0;
1292 
1293   // Set per-method invoke- and backedge mask.
1294   double scale = 1.0;
<span class="line-modified">1295   methodHandle mh(Thread::current(), _method);</span>
<span class="line-added">1296   CompilerOracle::has_option_value(mh, &quot;CompileThresholdScaling&quot;, scale);</span>
1297   _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1298   _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1299 
1300   _tenure_traps = 0;
1301   _num_loops = 0;
1302   _num_blocks = 0;
1303   _would_profile = unknown;
1304 
1305 #if INCLUDE_JVMCI
1306   _jvmci_ir_size = 0;
<span class="line-added">1307   _failed_speculations = NULL;</span>
1308 #endif
1309 
1310 #if INCLUDE_RTM_OPT
1311   _rtm_state = NoRTM; // No RTM lock eliding by default
1312   if (UseRTMLocking &amp;&amp;
<span class="line-modified">1313       !CompilerOracle::has_option_string(mh, &quot;NoRTMLockEliding&quot;)) {</span>
<span class="line-modified">1314     if (CompilerOracle::has_option_string(mh, &quot;UseRTMLockEliding&quot;) || !UseRTMDeopt) {</span>
1315       // Generate RTM lock eliding code without abort ratio calculation code.
1316       _rtm_state = UseRTM;
1317     } else if (UseRTMDeopt) {
1318       // Generate RTM lock eliding code and include abort ratio calculation
1319       // code if UseRTMDeopt is on.
1320       _rtm_state = ProfileRTM;
1321     }
1322   }
1323 #endif
1324 
1325   // Initialize flags and trap history.
1326   _nof_decompiles = 0;
1327   _nof_overflow_recompiles = 0;
1328   _nof_overflow_traps = 0;
1329   clear_escape_info();
1330   assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, &quot;align&quot;);
1331   Copy::zero_to_words((HeapWord*) &amp;_trap_hist,
1332                       sizeof(_trap_hist) / sizeof(HeapWord));
1333 }
1334 
</pre>
<hr />
<pre>
1393   int nb_cells = 0;
1394   switch(dp-&gt;tag()) {
1395   case DataLayout::bit_data_tag:
1396   case DataLayout::no_tag:
1397     nb_cells = BitData::static_cell_count();
1398     break;
1399   case DataLayout::speculative_trap_data_tag:
1400     nb_cells = SpeculativeTrapData::static_cell_count();
1401     break;
1402   default:
1403     fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1404   }
1405   return (DataLayout*)((address)dp + DataLayout::compute_size_in_bytes(nb_cells));
1406 }
1407 
1408 ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent) {
1409   DataLayout* end = args_data_limit();
1410 
1411   for (;; dp = next_extra(dp)) {
1412     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">1413     // No need for &quot;Atomic::load_acquire&quot; ops,</span>
1414     // since the data structure is monotonic.
1415     switch(dp-&gt;tag()) {
1416     case DataLayout::no_tag:
1417       return NULL;
1418     case DataLayout::arg_info_data_tag:
1419       dp = end;
1420       return NULL; // ArgInfoData is at the end of extra data section.
1421     case DataLayout::bit_data_tag:
1422       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
1423         return new BitData(dp);
1424       }
1425       break;
1426     case DataLayout::speculative_trap_data_tag:
1427       if (m != NULL) {
1428         SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1429         // data-&gt;method() may be null in case of a concurrent
1430         // allocation. Maybe it&#39;s for the same method. Try to use that
1431         // entry in that case.
1432         if (dp-&gt;bci() == bci) {
1433           if (data-&gt;method() == NULL) {
</pre>
<hr />
<pre>
1528   st-&gt;print(&quot;method data for &quot;);
1529   method()-&gt;print_value_on(st);
1530 }
1531 
1532 void MethodData::print_data_on(outputStream* st) const {
1533   ResourceMark rm;
1534   ProfileData* data = first_data();
1535   if (_parameters_type_data_di != no_parameters) {
1536     parameters_type_data()-&gt;print_data_on(st);
1537   }
1538   for ( ; is_valid(data); data = next_data(data)) {
1539     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1540     st-&gt;fill_to(6);
1541     data-&gt;print_data_on(st, this);
1542   }
1543   st-&gt;print_cr(&quot;--- Extra data:&quot;);
1544   DataLayout* dp    = extra_data_base();
1545   DataLayout* end   = args_data_limit();
1546   for (;; dp = next_extra(dp)) {
1547     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
<span class="line-modified">1548     // No need for &quot;Atomic::load_acquire&quot; ops,</span>
1549     // since the data structure is monotonic.
1550     switch(dp-&gt;tag()) {
1551     case DataLayout::no_tag:
1552       continue;
1553     case DataLayout::bit_data_tag:
1554       data = new BitData(dp);
1555       break;
1556     case DataLayout::speculative_trap_data_tag:
1557       data = new SpeculativeTrapData(dp);
1558       break;
1559     case DataLayout::arg_info_data_tag:
1560       data = new ArgInfoData(dp);
1561       dp = end; // ArgInfoData is at the end of extra data section.
1562       break;
1563     default:
1564       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1565     }
1566     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1567     st-&gt;fill_to(6);
1568     data-&gt;print_data_on(st);
1569     if (dp &gt;= end) return;
1570   }
1571 }
1572 










1573 // Verification
1574 
1575 void MethodData::verify_on(outputStream* st) {
1576   guarantee(is_methodData(), &quot;object must be method data&quot;);
1577   // guarantee(m-&gt;is_perm(), &quot;should be in permspace&quot;);
1578   this-&gt;verify_data_on(st);
1579 }
1580 
1581 void MethodData::verify_data_on(outputStream* st) {
1582   NEEDS_CLEANUP;
1583   // not yet implemented.
1584 }
1585 
1586 bool MethodData::profile_jsr292(const methodHandle&amp; m, int bci) {
1587   if (m-&gt;is_compiled_lambda_form()) {
1588     return true;
1589   }
1590 
1591   Bytecode_invoke inv(m , bci);
1592   return inv.is_invokedynamic() || inv.is_invokehandle();
1593 }
1594 
1595 bool MethodData::profile_unsafe(const methodHandle&amp; m, int bci) {
1596   Bytecode_invoke inv(m , bci);
<span class="line-modified">1597   if (inv.is_invokevirtual()) {</span>
<span class="line-modified">1598     if (inv.klass() == vmSymbols::jdk_internal_misc_Unsafe() ||</span>
<span class="line-modified">1599         inv.klass() == vmSymbols::sun_misc_Unsafe()) {</span>
<span class="line-modified">1600       ResourceMark rm;</span>
<span class="line-modified">1601       char* name = inv.name()-&gt;as_C_string();</span>
<span class="line-added">1602       if (!strncmp(name, &quot;get&quot;, 3) || !strncmp(name, &quot;put&quot;, 3)) {</span>
<span class="line-added">1603         return true;</span>
<span class="line-added">1604       }</span>
1605     }
1606   }
1607   return false;
1608 }
1609 
1610 int MethodData::profile_arguments_flag() {
1611   return TypeProfileLevel % 10;
1612 }
1613 
1614 bool MethodData::profile_arguments() {
1615   return profile_arguments_flag() &gt; no_type_profile &amp;&amp; profile_arguments_flag() &lt;= type_profile_all;
1616 }
1617 
1618 bool MethodData::profile_arguments_jsr292_only() {
1619   return profile_arguments_flag() == type_profile_jsr292;
1620 }
1621 
1622 bool MethodData::profile_all_arguments() {
1623   return profile_arguments_flag() == type_profile_all;
1624 }
</pre>
</td>
</tr>
</table>
<center><a href="method.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
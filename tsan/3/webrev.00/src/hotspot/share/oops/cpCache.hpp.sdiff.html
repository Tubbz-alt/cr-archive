<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CPCACHE_HPP
 26 #define SHARE_OOPS_CPCACHE_HPP
 27 
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;

 32 #include &quot;utilities/align.hpp&quot;
 33 #include &quot;utilities/constantTag.hpp&quot;

 34 
 35 class PSPromotionManager;
 36 
 37 // The ConstantPoolCache is not a cache! It is the resolution table that the
 38 // interpreter uses to avoid going into the runtime and a way to access resolved
 39 // values.
 40 
 41 // A ConstantPoolCacheEntry describes an individual entry of the constant
 42 // pool cache. There&#39;s 2 principal kinds of entries: field entries for in-
 43 // stance &amp; static field access, and method entries for invokes. Some of
 44 // the entry layout is shared and looks as follows:
 45 //
 46 // bit number |31                0|
 47 // bit length |-8--|-8--|---16----|
 48 // --------------------------------
 49 // _indices   [ b2 | b1 |  index  ]  index = constant_pool_index
 50 // _f1        [  entry specific   ]  metadata ptr (method or klass)
 51 // _f2        [  entry specific   ]  vtable or res_ref index, or vfinal method ptr
 52 // _flags     [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries)
 53 // bit length [ 4 |1| 1 |1|1|1|1|1|1 |1     |-3-|----16-----]
</pre>
<hr />
<pre>
215   }
216 
217   void set_field(                                // sets entry to resolved field state
218     Bytecodes::Code get_code,                    // the bytecode used for reading the field
219     Bytecodes::Code put_code,                    // the bytecode used for writing the field
220     Klass*          field_holder,                // the object/klass holding the field
221     int             orig_field_index,            // the original field index in the field holder
222     int             field_offset,                // the field offset in words in the field holder
223     TosState        field_type,                  // the (machine) field type
224     bool            is_final,                    // the field is final
225     bool            is_volatile,                 // the field is volatile
226     bool            is_tsan_ignore,              // the field should be ignored by TSAN
227     Klass*          root_klass                   // needed by the GC to dirty the klass
228   );
229 
230  private:
231   void set_direct_or_vtable_call(
232     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
233     const methodHandle&amp; method,                  // the method/prototype if any (NULL, otherwise)
234     int             vtable_index,                // the vtable index if any, else negative
<span class="line-modified">235     bool            sender_is_interface,         // &#39;logical&#39; sender (may be host of VMAC)</span>
<span class="line-removed">236     InstanceKlass*  pool_holder                  // class from which the call is made</span>
237   );
238 
239  public:
240   void set_direct_call(                          // sets entry to exact concrete method entry
241     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
242     const methodHandle&amp; method,                  // the method to call
<span class="line-modified">243     bool            sender_is_interface,         // &#39;logical&#39; sender (may be host of VMAC)</span>
<span class="line-removed">244     InstanceKlass*  pool_holder                  // class from which the call is made</span>
245   );
246 
247   void set_vtable_call(                          // sets entry to vtable index
248     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
249     const methodHandle&amp; method,                  // resolved method which declares the vtable index
250     int             vtable_index                 // the vtable index
251   );
252 
253   void set_itable_call(
254     Bytecodes::Code invoke_code,                 // the bytecode used; must be invokeinterface
255     Klass* referenced_klass,                     // the referenced klass in the InterfaceMethodref
256     const methodHandle&amp; method,                  // the resolved interface method
257     int itable_index                             // index into itable for the method
258   );
259 
260   void set_method_handle(
261     const constantPoolHandle&amp; cpool,             // holding constant pool (required for locking)
262     const CallInfo &amp;call_info                    // Call link information
263   );
264 
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CPCACHE_HPP
 26 #define SHARE_OOPS_CPCACHE_HPP
 27 
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;
<span class="line-added"> 32 #include &quot;runtime/handles.hpp&quot;</span>
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/constantTag.hpp&quot;
<span class="line-added"> 35 #include &quot;utilities/growableArray.hpp&quot;</span>
 36 
 37 class PSPromotionManager;
 38 
 39 // The ConstantPoolCache is not a cache! It is the resolution table that the
 40 // interpreter uses to avoid going into the runtime and a way to access resolved
 41 // values.
 42 
 43 // A ConstantPoolCacheEntry describes an individual entry of the constant
 44 // pool cache. There&#39;s 2 principal kinds of entries: field entries for in-
 45 // stance &amp; static field access, and method entries for invokes. Some of
 46 // the entry layout is shared and looks as follows:
 47 //
 48 // bit number |31                0|
 49 // bit length |-8--|-8--|---16----|
 50 // --------------------------------
 51 // _indices   [ b2 | b1 |  index  ]  index = constant_pool_index
 52 // _f1        [  entry specific   ]  metadata ptr (method or klass)
 53 // _f2        [  entry specific   ]  vtable or res_ref index, or vfinal method ptr
 54 // _flags     [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries)
 55 // bit length [ 4 |1| 1 |1|1|1|1|1|1 |1     |-3-|----16-----]
</pre>
<hr />
<pre>
217   }
218 
219   void set_field(                                // sets entry to resolved field state
220     Bytecodes::Code get_code,                    // the bytecode used for reading the field
221     Bytecodes::Code put_code,                    // the bytecode used for writing the field
222     Klass*          field_holder,                // the object/klass holding the field
223     int             orig_field_index,            // the original field index in the field holder
224     int             field_offset,                // the field offset in words in the field holder
225     TosState        field_type,                  // the (machine) field type
226     bool            is_final,                    // the field is final
227     bool            is_volatile,                 // the field is volatile
228     bool            is_tsan_ignore,              // the field should be ignored by TSAN
229     Klass*          root_klass                   // needed by the GC to dirty the klass
230   );
231 
232  private:
233   void set_direct_or_vtable_call(
234     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
235     const methodHandle&amp; method,                  // the method/prototype if any (NULL, otherwise)
236     int             vtable_index,                // the vtable index if any, else negative
<span class="line-modified">237     bool            sender_is_interface</span>

238   );
239 
240  public:
241   void set_direct_call(                          // sets entry to exact concrete method entry
242     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
243     const methodHandle&amp; method,                  // the method to call
<span class="line-modified">244     bool            sender_is_interface</span>

245   );
246 
247   void set_vtable_call(                          // sets entry to vtable index
248     Bytecodes::Code invoke_code,                 // the bytecode used for invoking the method
249     const methodHandle&amp; method,                  // resolved method which declares the vtable index
250     int             vtable_index                 // the vtable index
251   );
252 
253   void set_itable_call(
254     Bytecodes::Code invoke_code,                 // the bytecode used; must be invokeinterface
255     Klass* referenced_klass,                     // the referenced klass in the InterfaceMethodref
256     const methodHandle&amp; method,                  // the resolved interface method
257     int itable_index                             // index into itable for the method
258   );
259 
260   void set_method_handle(
261     const constantPoolHandle&amp; cpool,             // holding constant pool (required for locking)
262     const CallInfo &amp;call_info                    // Call link information
263   );
264 
</pre>
</td>
</tr>
</table>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
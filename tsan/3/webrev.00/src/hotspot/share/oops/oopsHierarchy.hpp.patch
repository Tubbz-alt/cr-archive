diff a/src/hotspot/share/oops/oopsHierarchy.hpp b/src/hotspot/share/oops/oopsHierarchy.hpp
--- a/src/hotspot/share/oops/oopsHierarchy.hpp
+++ b/src/hotspot/share/oops/oopsHierarchy.hpp
@@ -25,11 +25,10 @@
 #ifndef SHARE_OOPS_OOPSHIERARCHY_HPP
 #define SHARE_OOPS_OOPSHIERARCHY_HPP
 
 #include "metaprogramming/integralConstant.hpp"
 #include "metaprogramming/primitiveConversions.hpp"
-#include "runtime/globals.hpp"
 #include "utilities/globalDefinitions.hpp"
 
 // OBJECT hierarchy
 // This hierarchy is a representation hierarchy, i.e. if A is a superclass
 // of B, A's representation is a prefix of B's representation.
@@ -38,19 +37,18 @@
 
 // If compressed klass pointers then use narrowKlass.
 typedef juint  narrowKlass;
 
 typedef void* OopOrNarrowOopStar;
-typedef class   markOopDesc*                markOop;
 
 #ifndef CHECK_UNHANDLED_OOPS
 
-typedef class oopDesc*                            oop;
+typedef class oopDesc*                    oop;
 typedef class   instanceOopDesc*            instanceOop;
-typedef class   arrayOopDesc*                    arrayOop;
+typedef class   arrayOopDesc*               arrayOop;
 typedef class     objArrayOopDesc*            objArrayOop;
-typedef class     typeArrayOopDesc*            typeArrayOop;
+typedef class     typeArrayOopDesc*           typeArrayOop;
 
 #else
 
 // When CHECK_UNHANDLED_OOPS is defined, an "oop" is a class with a
 // carefully chosen set of constructors and conversion operators to go
@@ -70,20 +68,20 @@
 // Converting NULL to oop to Handle implicit is no longer accepted by the
 // compiler because there are too many steps in the conversion.  Use Handle()
 // instead, which generates less code anyway.
 
 class Thread;
-class PromotedObject;
 class oopDesc;
 
+extern "C" bool CheckUnhandledOops;
+
 class oop {
   oopDesc* _o;
 
   void register_oop();
   void unregister_oop();
 
-  // friend class markOop;
 public:
   void set_obj(const void* p)         {
     raw_set_obj(p);
     if (CheckUnhandledOops) register_oop();
   }
@@ -99,38 +97,22 @@
 
   oopDesc* obj()  const volatile      { return _o; }
 
   // General access
   oopDesc*  operator->() const        { return obj(); }
-  bool operator==(const oop o) const;
+  bool operator==(const oop o) const  { return obj() == o.obj(); }
   bool operator==(void *p) const      { return obj() == p; }
-  bool operator!=(const volatile oop o) const;
+  bool operator!=(const volatile oop o) const { return obj() != o.obj(); }
   bool operator!=(void *p) const      { return obj() != p; }
 
   // Assignment
   oop& operator=(const oop& o)                            { _o = o.obj(); return *this; }
   volatile oop& operator=(const oop& o) volatile          { _o = o.obj(); return *this; }
   volatile oop& operator=(const volatile oop& o) volatile { _o = o.obj(); return *this; }
 
   // Explict user conversions
-  operator void* () const             { return (void *)obj(); }
-#ifndef SOLARIS
-  operator void* () const volatile    { return (void *)obj(); }
-#endif
-  operator HeapWord* () const         { return (HeapWord*)obj(); }
   operator oopDesc* () const volatile { return obj(); }
-  operator intptr_t* () const         { return (intptr_t*)obj(); }
-  operator PromotedObject* () const   { return (PromotedObject*)obj(); }
-  operator markOop () const volatile  { return markOop(obj()); }
-  operator address   () const         { return (address)obj(); }
-
-  // from javaCalls.cpp
-  operator jobject () const           { return (jobject)obj(); }
-
-  // from parNewGeneration and other things that want to get to the end of
-  // an oop for stuff (like ObjArrayKlass.cpp)
-  operator oop* () const              { return (oop *)obj(); }
 };
 
 template<>
 struct PrimitiveConversions::Translate<oop> : public TrueType {
   typedef oop Value;
@@ -187,15 +169,11 @@
 // and pointer type. Define inline methods to provide the numerical conversions.
 template <class T> inline oop cast_to_oop(T value) {
   return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
 }
 template <class T> inline T cast_from_oop(oop o) {
-  return (T)(CHECK_UNHANDLED_OOPS_ONLY((void*))o);
-}
-
-inline bool check_obj_alignment(oop obj) {
-  return (cast_from_oop<intptr_t>(obj) & MinObjAlignmentInBytesMask) == 0;
+  return (T)(CHECK_UNHANDLED_OOPS_ONLY((oopDesc*))o);
 }
 
 // The metadata hierarchy is separate from the oop hierarchy
 
 //      class MetaspaceObj

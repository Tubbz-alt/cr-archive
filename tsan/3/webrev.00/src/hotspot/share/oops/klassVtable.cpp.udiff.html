<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/klassVtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -126,15 +126,10 @@</span>
    assert(vtable_length &gt;= Universe::base_vtable_size(), &quot;vtable too small&quot;);
  
    *vtable_length_ret = vtable_length;
  }
  
<span class="udiff-line-removed">- int klassVtable::index_of(Method* m, int len) const {</span>
<span class="udiff-line-removed">-   assert(m-&gt;has_vtable_index(), &quot;do not ask this of non-vtable methods&quot;);</span>
<span class="udiff-line-removed">-   return m-&gt;vtable_index();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Copy super class&#39;s vtable to the first part (prefix) of this class&#39;s vtable,
  // and return the number of entries copied.  Expects that &#39;super&#39; is the Java
  // super class (arrays can have &quot;array&quot; super classes that must be skipped).
  int klassVtable::initialize_from_super(Klass* super) {
    if (super == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167,11 +162,10 @@</span>
  // Revised lookup semantics   introduced 1.3 (Kestrel beta)
  void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {
  
    // Note:  Arrays can have intermediate array supers.  Use java_super to skip them.
    InstanceKlass* super = _klass-&gt;java_super();
<span class="udiff-line-removed">-   int nofNewEntries = 0;</span>
  
    bool is_shared = _klass-&gt;is_shared();
  
    if (!_klass-&gt;is_array_klass()) {
      ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,27 +289,30 @@</span>
  // Package private methods may also override other vtable entries
  InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method,
                              int vtable_index, Handle target_loader, Symbol* target_classname, Thread * THREAD) {
    InstanceKlass* superk = initialsuper;
    while (superk != NULL &amp;&amp; superk-&gt;super() != NULL) {
<span class="udiff-line-modified-removed">-     InstanceKlass* supersuperklass = InstanceKlass::cast(superk-&gt;super());</span>
<span class="udiff-line-removed">-     klassVtable ssVtable = supersuperklass-&gt;vtable();</span>
<span class="udiff-line-modified-added">+     klassVtable ssVtable = (superk-&gt;super())-&gt;vtable();</span>
      if (vtable_index &lt; ssVtable.length()) {
        Method* super_method = ssVtable.method_at(vtable_index);
<span class="udiff-line-added">+       // get the class holding the matching method</span>
<span class="udiff-line-added">+       // make sure you use that class for is_override</span>
<span class="udiff-line-added">+       InstanceKlass* supermethodholder = super_method-&gt;method_holder();</span>
  #ifndef PRODUCT
        Symbol* name= target_method()-&gt;name();
        Symbol* signature = target_method()-&gt;signature();
        assert(super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature, &quot;vtable entry name/sig mismatch&quot;);
  #endif
<span class="udiff-line-modified-removed">-       if (supersuperklass-&gt;is_override(super_method, target_loader, target_classname, THREAD)) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+       if (supermethodholder-&gt;is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD)) {</span>
          if (log_develop_is_enabled(Trace, vtables)) {
            ResourceMark rm(THREAD);
            LogTarget(Trace, vtables) lt;
            LogStream ls(lt);
            char* sig = target_method()-&gt;name_and_sig_as_C_string();
            ls.print(&quot;transitive overriding superclass %s with %s index %d, original flags: &quot;,
<span class="udiff-line-modified-removed">-                        supersuperklass-&gt;internal_name(),</span>
<span class="udiff-line-modified-added">+                        supermethodholder-&gt;internal_name(),</span>
                         sig, vtable_index);
            super_method-&gt;print_linkage_flags(&amp;ls);
            ls.print(&quot;overriders flags: &quot;);
            target_method-&gt;print_linkage_flags(&amp;ls);
            ls.cr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -465,11 +462,11 @@</span>
        bool overrides = false;
  
        // private methods are also never overridden
        if (!super_method-&gt;is_private() &amp;&amp;
            (is_default
<span class="udiff-line-modified-removed">-           || ((super_klass-&gt;is_override(super_method, target_loader, target_classname, THREAD))</span>
<span class="udiff-line-modified-added">+           || ((super_klass-&gt;is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD))</span>
            || ((klass-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION)
            &amp;&amp; ((super_klass = find_transitive_override(super_klass,
                               target_method, i, target_loader,
                               target_classname, THREAD))
                               != (InstanceKlass*)NULL)))))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -489,24 +486,24 @@</span>
            // have already made any needed loader constraints.
            // Since loader constraints are transitive, it is enough
            // to link to the first super, and we get all the others.
            Handle super_loader(THREAD, super_klass-&gt;class_loader());
  
<span class="udiff-line-modified-removed">-           if (!oopDesc::equals(target_loader(), super_loader())) {</span>
<span class="udiff-line-modified-added">+           if (target_loader() != super_loader()) {</span>
              ResourceMark rm(THREAD);
              Symbol* failed_type_symbol =
                SystemDictionary::check_signature_loaders(signature, target_loader,
                                                          super_loader, true,
                                                          CHECK_(false));
              if (failed_type_symbol != NULL) {
                stringStream ss;
                ss.print(&quot;loader constraint violation for class %s: when selecting &quot;
<span class="udiff-line-modified-removed">-                        &quot;overriding method %s the class loader %s of the &quot;</span>
<span class="udiff-line-modified-added">+                        &quot;overriding method &#39;&quot;, klass-&gt;external_name());</span>
<span class="udiff-line-added">+               target_method()-&gt;print_external_name(&amp;ss),</span>
<span class="udiff-line-added">+               ss.print(&quot;&#39; the class loader %s of the &quot;</span>
                         &quot;selected method&#39;s type %s, and the class loader %s for its super &quot;
                         &quot;type %s have different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="udiff-line-removed">-                        klass-&gt;external_name(),</span>
<span class="udiff-line-removed">-                        target_method()-&gt;name_and_sig_as_C_string(),</span>
                         target_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
                         target_klass-&gt;external_name(),
                         super_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
                         super_klass-&gt;external_name(),
                         failed_type_symbol-&gt;as_klass_external_name(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -629,17 +626,18 @@</span>
      return true;
    }
  
    // search through the super class hierarchy to see if we need
    // a new entry
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
    Symbol* name = target_method()-&gt;name();
    Symbol* signature = target_method()-&gt;signature();
    const Klass* k = super;
    Method* super_method = NULL;
    InstanceKlass *holder = NULL;
    Method* recheck_method =  NULL;
<span class="udiff-line-added">+   bool found_pkg_prvt_method = false;</span>
    while (k != NULL) {
      // lookup through the hierarchy for a method with matching name and sign.
      super_method = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
      if (super_method == NULL) {
        break; // we still have to search for a matching miranda method
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -653,32 +651,51 @@</span>
      // ignore private, c.m pub does override a.m pub
      // For classes that were not javac&#39;d together, we also do transitive overriding around
      // methods that have less accessibility
      if ((!super_method-&gt;is_static()) &amp;&amp;
         (!super_method-&gt;is_private())) {
<span class="udiff-line-modified-removed">-       if (superk-&gt;is_override(super_method, classloader, classname, THREAD)) {</span>
<span class="udiff-line-modified-added">+       if (superk-&gt;is_override(methodHandle(THREAD, super_method), classloader, classname, THREAD)) {</span>
          return false;
        // else keep looking for transitive overrides
        }
<span class="udiff-line-added">+       // If we get here then one of the super classes has a package private method</span>
<span class="udiff-line-added">+       // that will not get overridden because it is in a different package.  But,</span>
<span class="udiff-line-added">+       // that package private method does &quot;override&quot; any matching methods in super</span>
<span class="udiff-line-added">+       // interfaces, so there will be no miranda vtable entry created.  So, set flag</span>
<span class="udiff-line-added">+       // to TRUE for use below, in case there are no methods in super classes that</span>
<span class="udiff-line-added">+       // this target method overrides.</span>
<span class="udiff-line-added">+       assert(super_method-&gt;is_package_private(), &quot;super_method must be package private&quot;);</span>
<span class="udiff-line-added">+       assert(!superk-&gt;is_same_class_package(classloader(), classname),</span>
<span class="udiff-line-added">+              &quot;Must be different packages&quot;);</span>
<span class="udiff-line-added">+       found_pkg_prvt_method = true;</span>
      }
  
      // Start with lookup result and continue to search up, for versions supporting transitive override
      if (major_version &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION) {
        k = superk-&gt;super(); // haven&#39;t found an override match yet; continue to look
      } else {
        break;
      }
    }
  
<span class="udiff-line-added">+   // If found_pkg_prvt_method is set, then the ONLY matching method in the</span>
<span class="udiff-line-added">+   // superclasses is package private in another package. That matching method will</span>
<span class="udiff-line-added">+   // prevent a miranda vtable entry from being created. Because the target method can not</span>
<span class="udiff-line-added">+   // override the package private method in another package, then it needs to be the root</span>
<span class="udiff-line-added">+   // for its own vtable entry.</span>
<span class="udiff-line-added">+   if (found_pkg_prvt_method) {</span>
<span class="udiff-line-added">+      return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // if the target method is public or protected it may have a matching
    // miranda method in the super, whose entry it should re-use.
    // Actually, to handle cases that javac would not generate, we need
    // this check for all access permissions.
    const InstanceKlass *sk = InstanceKlass::cast(super);
    if (sk-&gt;has_miranda_methods()) {
      if (sk-&gt;lookup_method_in_all_interfaces(name, signature, Klass::find_defaults) != NULL) {
<span class="udiff-line-modified-removed">-       return false;  // found a matching miranda; we do not need a new entry</span>
<span class="udiff-line-modified-added">+       return false; // found a matching miranda; we do not need a new entry</span>
      }
    }
    return true; // found no match; we need a new entry
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1007,19 +1024,10 @@</span>
      }
    }
  }
  #endif // INCLUDE_JVMTI
  
<span class="udiff-line-removed">- // CDS/RedefineClasses support - clear vtables so they can be reinitialized</span>
<span class="udiff-line-removed">- void klassVtable::clear_vtable() {</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; _length; i++) table()[i].clear();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool klassVtable::is_initialized() {</span>
<span class="udiff-line-removed">-   return _length == 0 || table()[0].method() != NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //-----------------------------------------------------------------------------------------
  // Itable code
  
  // Initialize a itableMethodEntry
  void itableMethodEntry::initialize(Method* m) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1190,11 +1198,11 @@</span>
    Handle interface_loader (THREAD, interf-&gt;class_loader());
  
    int ime_count = method_count_for_interface(interf);
    for (int i = 0; i &lt; nof_methods; i++) {
      Method* m = methods-&gt;at(i);
<span class="udiff-line-modified-removed">-     methodHandle target;</span>
<span class="udiff-line-modified-added">+     Method* target = NULL;</span>
      if (m-&gt;has_itable_index()) {
        // This search must match the runtime resolution, i.e. selection search for invokeinterface
        // to correctly enforce loader constraints for interface method inheritance.
        // Private methods are skipped as a private class method can never be the implementation
        // of an interface method.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1215,53 +1223,55 @@</span>
      } else {
        // Entry did resolve, check loader constraints before initializing
        // if checkconstraints requested
        if (checkconstraints) {
          Handle method_holder_loader (THREAD, target-&gt;method_holder()-&gt;class_loader());
<span class="udiff-line-modified-removed">-         if (!oopDesc::equals(method_holder_loader(), interface_loader())) {</span>
<span class="udiff-line-modified-added">+         InstanceKlass* method_holder = target-&gt;method_holder();</span>
<span class="udiff-line-added">+         if (method_holder_loader() != interface_loader()) {</span>
            ResourceMark rm(THREAD);
            Symbol* failed_type_symbol =
              SystemDictionary::check_signature_loaders(m-&gt;signature(),
                                                        method_holder_loader,
                                                        interface_loader,
                                                        true, CHECK);
            if (failed_type_symbol != NULL) {
              stringStream ss;
              ss.print(&quot;loader constraint violation in interface itable&quot;
<span class="udiff-line-modified-removed">-                      &quot; initialization for class %s: when selecting method %s the&quot;</span>
<span class="udiff-line-modified-removed">-                      &quot; class loader %s for super interface %s, and the class&quot;</span>
<span class="udiff-line-modified-removed">-                      &quot; loader %s of the selected method&#39;s type, %s have&quot;</span>
<span class="udiff-line-modified-added">+                      &quot; initialization for class %s: when selecting method &#39;&quot;,</span>
<span class="udiff-line-modified-added">+                      _klass-&gt;external_name());</span>
<span class="udiff-line-modified-added">+             m-&gt;print_external_name(&amp;ss),</span>
<span class="udiff-line-added">+             ss.print(&quot;&#39; the class loader %s for super interface %s, and the class&quot;</span>
<span class="udiff-line-added">+                      &quot; loader %s of the selected method&#39;s %s, %s have&quot;</span>
                       &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="udiff-line-removed">-                      _klass-&gt;external_name(),</span>
<span class="udiff-line-removed">-                      m-&gt;name_and_sig_as_C_string(),</span>
                       interf-&gt;class_loader_data()-&gt;loader_name_and_id(),
                       interf-&gt;external_name(),
<span class="udiff-line-modified-removed">-                      target()-&gt;method_holder()-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="udiff-line-modified-removed">-                      target()-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+                      method_holder-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="udiff-line-modified-added">+                      method_holder-&gt;external_kind(),</span>
<span class="udiff-line-added">+                      method_holder-&gt;external_name(),</span>
                       failed_type_symbol-&gt;as_klass_external_name(),
                       interf-&gt;class_in_module_of_loader(false, true),
<span class="udiff-line-modified-removed">-                      target()-&gt;method_holder()-&gt;class_in_module_of_loader(false, true));</span>
<span class="udiff-line-modified-added">+                      method_holder-&gt;class_in_module_of_loader(false, true));</span>
              THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
            }
          }
        }
  
        // ime may have moved during GC so recalculate address
        int ime_num = m-&gt;itable_index();
        assert(ime_num &lt; ime_count, &quot;oob&quot;);
<span class="udiff-line-modified-removed">-       itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target());</span>
<span class="udiff-line-modified-added">+       itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target);</span>
        if (log_develop_is_enabled(Trace, itables)) {
          ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-         if (target() != NULL) {</span>
<span class="udiff-line-modified-added">+         if (target != NULL) {</span>
            LogTarget(Trace, itables) lt;
            LogStream ls(lt);
<span class="udiff-line-modified-removed">-           char* sig = target()-&gt;name_and_sig_as_C_string();</span>
<span class="udiff-line-modified-added">+           char* sig = target-&gt;name_and_sig_as_C_string();</span>
            ls.print(&quot;interface: %s, ime_num: %d, target: %s, method_holder: %s &quot;,
                         interf-&gt;internal_name(), ime_num, sig,
<span class="udiff-line-modified-removed">-                        target()-&gt;method_holder()-&gt;internal_name());</span>
<span class="udiff-line-modified-added">+                        target-&gt;method_holder()-&gt;internal_name());</span>
            ls.print(&quot;target_method flags: &quot;);
<span class="udiff-line-modified-removed">-           target()-&gt;print_linkage_flags(&amp;ls);</span>
<span class="udiff-line-modified-added">+           target-&gt;print_linkage_flags(&amp;ls);</span>
            ls.cr();
          }
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1445,35 +1455,10 @@</span>
    oop* v = (oop*) klass-&gt;end_of_itable();
    assert( (oop*)(ime) == v, &quot;wrong offset calculation (2)&quot;);
  #endif
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // inverse to itable_index</span>
<span class="udiff-line-removed">- Method* klassItable::method_for_itable_index(InstanceKlass* intf, int itable_index) {</span>
<span class="udiff-line-removed">-   assert(intf-&gt;is_interface(), &quot;sanity check&quot;);</span>
<span class="udiff-line-removed">-   assert(intf-&gt;verify_itable_index(itable_index), &quot;&quot;);</span>
<span class="udiff-line-removed">-   Array&lt;Method*&gt;* methods = InstanceKlass::cast(intf)-&gt;methods();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (itable_index &lt; 0 || itable_index &gt;= method_count_for_interface(intf))</span>
<span class="udiff-line-removed">-     return NULL;                // help caller defend against bad indices</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int index = itable_index;</span>
<span class="udiff-line-removed">-   Method* m = methods-&gt;at(index);</span>
<span class="udiff-line-removed">-   int index2 = -1;</span>
<span class="udiff-line-removed">-   while (!m-&gt;has_itable_index() ||</span>
<span class="udiff-line-removed">-          (index2 = m-&gt;itable_index()) != itable_index) {</span>
<span class="udiff-line-removed">-     assert(index2 &lt; itable_index, &quot;monotonic&quot;);</span>
<span class="udiff-line-removed">-     if (++index == methods-&gt;length())</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-removed">-     m = methods-&gt;at(index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(m-&gt;itable_index() == itable_index, &quot;correct inverse&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return m;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void klassVtable::verify(outputStream* st, bool forced) {
    // make sure table is initialized
    if (!Universe::is_fully_initialized()) return;
  #ifndef PRODUCT
    // avoid redundant verifies
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1518,11 +1503,10 @@</span>
    }
  }
  #endif
  
  void vtableEntry::verify(klassVtable* vt, outputStream* st) {
<span class="udiff-line-removed">-   NOT_PRODUCT(FlagSetting fs(IgnoreLockingAssertions, true));</span>
    Klass* vtklass = vt-&gt;klass();
    if (vtklass-&gt;is_instance_klass() &amp;&amp;
       (InstanceKlass::cast(vtklass)-&gt;major_version() &gt;= klassVtable::VTABLE_TRANSITIVE_OVERRIDE_VERSION)) {
      assert(method() != NULL, &quot;must have set method&quot;);
    }
</pre>
<center><a href="klass.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
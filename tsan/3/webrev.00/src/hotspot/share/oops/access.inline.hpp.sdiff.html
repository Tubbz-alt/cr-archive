<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/access.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/access.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 73   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 74   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD, decorators&gt;: public AllStatic {
 75     template &lt;typename T&gt;
 76     static T access_barrier(void* addr) {
 77       return GCBarrierType::load_in_heap(reinterpret_cast&lt;T*&gt;(addr));
 78     }
 79 
 80     static oop oop_access_barrier(void* addr) {
 81       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 82       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 83         return GCBarrierType::oop_load_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 84       } else {
 85         return GCBarrierType::oop_load_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 86       }
 87     }
 88   };
 89 
 90   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 91   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG, decorators&gt;: public AllStatic {
 92     template &lt;typename T&gt;
<span class="line-modified"> 93     static T access_barrier(T new_value, void* addr) {</span>
<span class="line-modified"> 94       return GCBarrierType::atomic_xchg_in_heap(new_value, reinterpret_cast&lt;T*&gt;(addr));</span>
 95     }
 96 
<span class="line-modified"> 97     static oop oop_access_barrier(oop new_value, void* addr) {</span>
 98       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 99       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
<span class="line-modified">100         return GCBarrierType::oop_atomic_xchg_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr));</span>
101       } else {
<span class="line-modified">102         return GCBarrierType::oop_atomic_xchg_not_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr));</span>
103       }
104     }
105   };
106 
107   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
108   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG, decorators&gt;: public AllStatic {
109     template &lt;typename T&gt;
<span class="line-modified">110     static T access_barrier(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">111       return GCBarrierType::atomic_cmpxchg_in_heap(new_value, reinterpret_cast&lt;T*&gt;(addr), compare_value);</span>
112     }
113 
<span class="line-modified">114     static oop oop_access_barrier(oop new_value, void* addr, oop compare_value) {</span>
115       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
116       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
<span class="line-modified">117         return GCBarrierType::oop_atomic_cmpxchg_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr), compare_value);</span>
118       } else {
<span class="line-modified">119         return GCBarrierType::oop_atomic_cmpxchg_not_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr), compare_value);</span>
120       }
121     }
122   };
123 
124   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
125   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ARRAYCOPY, decorators&gt;: public AllStatic {
126     template &lt;typename T&gt;
127     static bool access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
128                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
129                                size_t length) {
130       GCBarrierType::arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw,
131                                        dst_obj, dst_offset_in_bytes, dst_raw,
132                                        length);
133       return true;
134     }
135 
136     template &lt;typename T&gt;
137     static bool oop_access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
138                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
139                                    size_t length) {
</pre>
<hr />
<pre>
154     static void oop_access_barrier(oop base, ptrdiff_t offset, oop value) {
155       GCBarrierType::oop_store_in_heap_at(base, offset, value);
156     }
157   };
158 
159   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
160   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD_AT, decorators&gt;: public AllStatic {
161     template &lt;typename T&gt;
162     static T access_barrier(oop base, ptrdiff_t offset) {
163       return GCBarrierType::template load_in_heap_at&lt;T&gt;(base, offset);
164     }
165 
166     static oop oop_access_barrier(oop base, ptrdiff_t offset) {
167       return GCBarrierType::oop_load_in_heap_at(base, offset);
168     }
169   };
170 
171   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
172   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG_AT, decorators&gt;: public AllStatic {
173     template &lt;typename T&gt;
<span class="line-modified">174     static T access_barrier(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">175       return GCBarrierType::atomic_xchg_in_heap_at(new_value, base, offset);</span>
176     }
177 
<span class="line-modified">178     static oop oop_access_barrier(oop new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">179       return GCBarrierType::oop_atomic_xchg_in_heap_at(new_value, base, offset);</span>
180     }
181   };
182 
183   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
184   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG_AT, decorators&gt;: public AllStatic {
185     template &lt;typename T&gt;
<span class="line-modified">186     static T access_barrier(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">187       return GCBarrierType::atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);</span>
188     }
189 
<span class="line-modified">190     static oop oop_access_barrier(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
<span class="line-modified">191       return GCBarrierType::oop_atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);</span>
192     }
193   };
194 
195   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
196   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_CLONE, decorators&gt;: public AllStatic {
197     static void access_barrier(oop src, oop dst, size_t size) {
198       GCBarrierType::clone_in_heap(src, dst, size);
199     }
200   };
201 
202   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
203   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_RESOLVE, decorators&gt;: public AllStatic {
204     static oop access_barrier(oop obj) {
205       return GCBarrierType::resolve(obj);
206     }
207   };
208 
<span class="line-removed">209   template &lt;class GCBarrierType, DecoratorSet decorators&gt;</span>
<span class="line-removed">210   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_EQUALS, decorators&gt;: public AllStatic {</span>
<span class="line-removed">211     static bool access_barrier(oop o1, oop o2) {</span>
<span class="line-removed">212       return GCBarrierType::equals(o1, o2);</span>
<span class="line-removed">213     }</span>
<span class="line-removed">214   };</span>
<span class="line-removed">215 </span>
216   // Resolving accessors with barriers from the barrier set happens in two steps.
217   // 1. Expand paths with runtime-decorators, e.g. is UseCompressedOops on or off.
218   // 2. Expand paths for each BarrierSet available in the system.
219   template &lt;DecoratorSet decorators, typename FunctionPointerT, BarrierType barrier_type&gt;
220   struct BarrierResolver: public AllStatic {
221     template &lt;DecoratorSet ds&gt;
222     static typename EnableIf&lt;
223       HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
224       FunctionPointerT&gt;::type
225     resolve_barrier_gc() {
226       BarrierSet* bs = BarrierSet::barrier_set();
227       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
228       switch (bs-&gt;kind()) {
229 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
230         case BarrierSet::bs_name: {                                     \
231           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
232             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::oop_access_barrier; \
233         }                                                               \
234         break;
235         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
</pre>
<hr />
<pre>
299     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE_AT&gt;::resolve_barrier();
300     _store_at_func = function;
301     function(base, offset, value);
302   }
303 
304   template &lt;DecoratorSet decorators, typename T&gt;
305   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load_init(void* addr) {
306     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD&gt;::resolve_barrier();
307     _load_func = function;
308     return function(addr);
309   }
310 
311   template &lt;DecoratorSet decorators, typename T&gt;
312   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at_init(oop base, ptrdiff_t offset) {
313     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD_AT&gt;::resolve_barrier();
314     _load_at_func = function;
315     return function(base, offset);
316   }
317 
318   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">319   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg_init(T new_value, void* addr, T compare_value) {</span>
320     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG&gt;::resolve_barrier();
321     _atomic_cmpxchg_func = function;
<span class="line-modified">322     return function(new_value, addr, compare_value);</span>
323   }
324 
325   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">326   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
327     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG_AT&gt;::resolve_barrier();
328     _atomic_cmpxchg_at_func = function;
<span class="line-modified">329     return function(new_value, base, offset, compare_value);</span>
330   }
331 
332   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">333   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg_init(T new_value, void* addr) {</span>
334     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG&gt;::resolve_barrier();
335     _atomic_xchg_func = function;
<span class="line-modified">336     return function(new_value, addr);</span>
337   }
338 
339   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">340   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset) {</span>
341     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG_AT&gt;::resolve_barrier();
342     _atomic_xchg_at_func = function;
<span class="line-modified">343     return function(new_value, base, offset);</span>
344   }
345 
346   template &lt;DecoratorSet decorators, typename T&gt;
347   bool RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
348                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
349                                                                          size_t length) {
350     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ARRAYCOPY&gt;::resolve_barrier();
351     _arraycopy_func = function;
352     return function(src_obj, src_offset_in_bytes, src_raw,
353                     dst_obj, dst_offset_in_bytes, dst_raw,
354                     length);
355   }
356 
357   template &lt;DecoratorSet decorators, typename T&gt;
358   void RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::clone_init(oop src, oop dst, size_t size) {
359     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_CLONE&gt;::resolve_barrier();
360     _clone_func = function;
361     function(src, dst, size);
362   }
363 
364   template &lt;DecoratorSet decorators, typename T&gt;
365   oop RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::resolve_init(oop obj) {
366     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_RESOLVE&gt;::resolve_barrier();
367     _resolve_func = function;
368     return function(obj);
369   }
<span class="line-removed">370 </span>
<span class="line-removed">371   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed">372   bool RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;::equals_init(oop o1, oop o2) {</span>
<span class="line-removed">373     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_EQUALS&gt;::resolve_barrier();</span>
<span class="line-removed">374     _equals_func = function;</span>
<span class="line-removed">375     return function(o1, o2);</span>
<span class="line-removed">376   }</span>
377 }
378 
379 #endif // SHARE_OOPS_ACCESS_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 73   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 74   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD, decorators&gt;: public AllStatic {
 75     template &lt;typename T&gt;
 76     static T access_barrier(void* addr) {
 77       return GCBarrierType::load_in_heap(reinterpret_cast&lt;T*&gt;(addr));
 78     }
 79 
 80     static oop oop_access_barrier(void* addr) {
 81       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 82       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 83         return GCBarrierType::oop_load_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 84       } else {
 85         return GCBarrierType::oop_load_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 86       }
 87     }
 88   };
 89 
 90   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 91   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG, decorators&gt;: public AllStatic {
 92     template &lt;typename T&gt;
<span class="line-modified"> 93     static T access_barrier(void* addr, T new_value) {</span>
<span class="line-modified"> 94       return GCBarrierType::atomic_xchg_in_heap(reinterpret_cast&lt;T*&gt;(addr), new_value);</span>
 95     }
 96 
<span class="line-modified"> 97     static oop oop_access_barrier(void* addr, oop new_value) {</span>
 98       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 99       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
<span class="line-modified">100         return GCBarrierType::oop_atomic_xchg_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), new_value);</span>
101       } else {
<span class="line-modified">102         return GCBarrierType::oop_atomic_xchg_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), new_value);</span>
103       }
104     }
105   };
106 
107   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
108   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG, decorators&gt;: public AllStatic {
109     template &lt;typename T&gt;
<span class="line-modified">110     static T access_barrier(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">111       return GCBarrierType::atomic_cmpxchg_in_heap(reinterpret_cast&lt;T*&gt;(addr), compare_value, new_value);</span>
112     }
113 
<span class="line-modified">114     static oop oop_access_barrier(void* addr, oop compare_value, oop new_value) {</span>
115       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
116       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
<span class="line-modified">117         return GCBarrierType::oop_atomic_cmpxchg_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), compare_value, new_value);</span>
118       } else {
<span class="line-modified">119         return GCBarrierType::oop_atomic_cmpxchg_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), compare_value, new_value);</span>
120       }
121     }
122   };
123 
124   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
125   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ARRAYCOPY, decorators&gt;: public AllStatic {
126     template &lt;typename T&gt;
127     static bool access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
128                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
129                                size_t length) {
130       GCBarrierType::arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw,
131                                        dst_obj, dst_offset_in_bytes, dst_raw,
132                                        length);
133       return true;
134     }
135 
136     template &lt;typename T&gt;
137     static bool oop_access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
138                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
139                                    size_t length) {
</pre>
<hr />
<pre>
154     static void oop_access_barrier(oop base, ptrdiff_t offset, oop value) {
155       GCBarrierType::oop_store_in_heap_at(base, offset, value);
156     }
157   };
158 
159   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
160   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD_AT, decorators&gt;: public AllStatic {
161     template &lt;typename T&gt;
162     static T access_barrier(oop base, ptrdiff_t offset) {
163       return GCBarrierType::template load_in_heap_at&lt;T&gt;(base, offset);
164     }
165 
166     static oop oop_access_barrier(oop base, ptrdiff_t offset) {
167       return GCBarrierType::oop_load_in_heap_at(base, offset);
168     }
169   };
170 
171   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
172   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG_AT, decorators&gt;: public AllStatic {
173     template &lt;typename T&gt;
<span class="line-modified">174     static T access_barrier(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">175       return GCBarrierType::atomic_xchg_in_heap_at(base, offset, new_value);</span>
176     }
177 
<span class="line-modified">178     static oop oop_access_barrier(oop base, ptrdiff_t offset, oop new_value) {</span>
<span class="line-modified">179       return GCBarrierType::oop_atomic_xchg_in_heap_at(base, offset, new_value);</span>
180     }
181   };
182 
183   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
184   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG_AT, decorators&gt;: public AllStatic {
185     template &lt;typename T&gt;
<span class="line-modified">186     static T access_barrier(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">187       return GCBarrierType::atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);</span>
188     }
189 
<span class="line-modified">190     static oop oop_access_barrier(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
<span class="line-modified">191       return GCBarrierType::oop_atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);</span>
192     }
193   };
194 
195   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
196   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_CLONE, decorators&gt;: public AllStatic {
197     static void access_barrier(oop src, oop dst, size_t size) {
198       GCBarrierType::clone_in_heap(src, dst, size);
199     }
200   };
201 
202   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
203   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_RESOLVE, decorators&gt;: public AllStatic {
204     static oop access_barrier(oop obj) {
205       return GCBarrierType::resolve(obj);
206     }
207   };
208 







209   // Resolving accessors with barriers from the barrier set happens in two steps.
210   // 1. Expand paths with runtime-decorators, e.g. is UseCompressedOops on or off.
211   // 2. Expand paths for each BarrierSet available in the system.
212   template &lt;DecoratorSet decorators, typename FunctionPointerT, BarrierType barrier_type&gt;
213   struct BarrierResolver: public AllStatic {
214     template &lt;DecoratorSet ds&gt;
215     static typename EnableIf&lt;
216       HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
217       FunctionPointerT&gt;::type
218     resolve_barrier_gc() {
219       BarrierSet* bs = BarrierSet::barrier_set();
220       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
221       switch (bs-&gt;kind()) {
222 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
223         case BarrierSet::bs_name: {                                     \
224           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
225             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::oop_access_barrier; \
226         }                                                               \
227         break;
228         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
</pre>
<hr />
<pre>
292     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE_AT&gt;::resolve_barrier();
293     _store_at_func = function;
294     function(base, offset, value);
295   }
296 
297   template &lt;DecoratorSet decorators, typename T&gt;
298   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load_init(void* addr) {
299     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD&gt;::resolve_barrier();
300     _load_func = function;
301     return function(addr);
302   }
303 
304   template &lt;DecoratorSet decorators, typename T&gt;
305   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at_init(oop base, ptrdiff_t offset) {
306     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD_AT&gt;::resolve_barrier();
307     _load_at_func = function;
308     return function(base, offset);
309   }
310 
311   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">312   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg_init(void* addr, T compare_value, T new_value) {</span>
313     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG&gt;::resolve_barrier();
314     _atomic_cmpxchg_func = function;
<span class="line-modified">315     return function(addr, compare_value, new_value);</span>
316   }
317 
318   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">319   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
320     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG_AT&gt;::resolve_barrier();
321     _atomic_cmpxchg_at_func = function;
<span class="line-modified">322     return function(base, offset, compare_value, new_value);</span>
323   }
324 
325   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">326   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg_init(void* addr, T new_value) {</span>
327     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG&gt;::resolve_barrier();
328     _atomic_xchg_func = function;
<span class="line-modified">329     return function(addr, new_value);</span>
330   }
331 
332   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">333   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value) {</span>
334     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG_AT&gt;::resolve_barrier();
335     _atomic_xchg_at_func = function;
<span class="line-modified">336     return function(base, offset, new_value);</span>
337   }
338 
339   template &lt;DecoratorSet decorators, typename T&gt;
340   bool RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
341                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
342                                                                          size_t length) {
343     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ARRAYCOPY&gt;::resolve_barrier();
344     _arraycopy_func = function;
345     return function(src_obj, src_offset_in_bytes, src_raw,
346                     dst_obj, dst_offset_in_bytes, dst_raw,
347                     length);
348   }
349 
350   template &lt;DecoratorSet decorators, typename T&gt;
351   void RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::clone_init(oop src, oop dst, size_t size) {
352     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_CLONE&gt;::resolve_barrier();
353     _clone_func = function;
354     function(src, dst, size);
355   }
356 
357   template &lt;DecoratorSet decorators, typename T&gt;
358   oop RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::resolve_init(oop obj) {
359     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_RESOLVE&gt;::resolve_barrier();
360     _resolve_func = function;
361     return function(obj);
362   }







363 }
364 
365 #endif // SHARE_OOPS_ACCESS_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
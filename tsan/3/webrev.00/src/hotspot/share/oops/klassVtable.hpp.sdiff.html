<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klassVtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klassVtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metadata.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 
 32 // A klassVtable abstracts the variable-length vtable that is embedded in InstanceKlass
 33 // and ArrayKlass.  klassVtable objects are used just as convenient transient accessors to the vtable,
 34 // not to actually hold the vtable data.
 35 // Note: the klassVtable should not be accessed before the class has been verified
 36 // (until that point, the vtable is uninitialized).
 37 
 38 // Currently a klassVtable contains a direct reference to the vtable data, and is therefore
 39 // not preserved across GCs.
 40 
 41 class vtableEntry;
 42 
 43 class klassVtable {
 44   Klass*       _klass;            // my klass
 45   int          _tableOffset;      // offset of start of vtable data within klass
 46   int          _length;           // length of vtable (number of entries)
 47 #ifndef PRODUCT
 48   int          _verify_count;     // to make verify faster
 49 #endif
 50 
<span class="line-removed"> 51   // Ordering important, so greater_than (&gt;) can be used as an merge operator.</span>
<span class="line-removed"> 52   enum AccessType {</span>
<span class="line-removed"> 53     acc_private         = 0,</span>
<span class="line-removed"> 54     acc_package_private = 1,</span>
<span class="line-removed"> 55     acc_publicprotected = 2</span>
<span class="line-removed"> 56   };</span>
<span class="line-removed"> 57 </span>
 58  public:
 59   klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
 60     _tableOffset = (address)base - (address)klass; _length = length;
 61   }
 62 
 63   // accessors
 64   vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
 65   Klass* klass() const            { return _klass;  }
 66   int length() const              { return _length; }
 67   inline Method* method_at(int i) const;
 68   inline Method* unchecked_method_at(int i) const;
<span class="line-removed"> 69   inline Method** adr_method_at(int i) const;</span>
 70 
 71   // searching; all methods return -1 if not found
<span class="line-removed"> 72   int index_of(Method* m) const                         { return index_of(m, _length); }</span>
 73   int index_of_miranda(Symbol* name, Symbol* signature);
 74 
 75   void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
 76 
<span class="line-removed"> 77   // CDS/RedefineClasses support - clear vtables so they can be reinitialized</span>
<span class="line-removed"> 78   // at dump time.  Clearing gives us an easy way to tell if the vtable has</span>
<span class="line-removed"> 79   // already been reinitialized at dump time (see dump.cpp).  Vtables can</span>
<span class="line-removed"> 80   // be initialized at run time by RedefineClasses so dumping the right order</span>
<span class="line-removed"> 81   // is necessary.</span>
<span class="line-removed"> 82   void clear_vtable();</span>
<span class="line-removed"> 83   bool is_initialized();</span>
<span class="line-removed"> 84 </span>
 85   // computes vtable length (in words) and the number of miranda methods
 86   static void compute_vtable_size_and_num_mirandas(int* vtable_length,
 87                                                    int* num_new_mirandas,
 88                                                    GrowableArray&lt;Method*&gt;* all_mirandas,
 89                                                    const Klass* super,
 90                                                    Array&lt;Method*&gt;* methods,
 91                                                    AccessFlags class_flags,
 92                                                    u2 major_version,
 93                                                    Handle classloader,
 94                                                    Symbol* classname,
 95                                                    Array&lt;InstanceKlass*&gt;* local_interfaces,
 96                                                    TRAPS);
 97 
 98 #if INCLUDE_JVMTI
 99   // RedefineClasses() API support:
100   // If any entry of this vtable points to any of old_methods,
101   // replace it with the corresponding new_method.
102   // trace_name_printed is set to true if the current call has
103   // printed the klass name so that other routines in the adjust_*
104   // group don&#39;t print the klass name.
</pre>
<hr />
<pre>
108   void dump_vtable();
109 #endif // INCLUDE_JVMTI
110 
111   // Debugging code
112   void print()                                              PRODUCT_RETURN;
113   void verify(outputStream* st, bool force = false);
114   static void print_statistics()                            PRODUCT_RETURN;
115 
116  protected:
117   friend class vtableEntry;
118 
119  public:
120   // Transitive overridng rules for class files &lt; JDK1_7 use the older JVMS rules.
121   // Overriding is determined as we create the vtable, so we use the class file version
122   // of the class whose vtable we are calculating.
123   enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
124 
125  private:
126   void copy_vtable_to(vtableEntry* start);
127   int  initialize_from_super(Klass* super);
<span class="line-removed">128   int  index_of(Method* m, int len) const; // same as index_of, but search only up to len</span>
129   void put_method_at(Method* m, int index);
130   static bool needs_new_vtable_entry(const methodHandle&amp; m,
131                                      const Klass* super,
132                                      Handle classloader,
133                                      Symbol* classname,
134                                      AccessFlags access_flags,
135                                      u2 major_version,
136                                      TRAPS);
137 
138   bool update_inherited_vtable(InstanceKlass* klass, const methodHandle&amp; target_method, int super_vtable_len, int default_index, bool checkconstraints, TRAPS);
139  InstanceKlass* find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method, int vtable_index,
140                                          Handle target_loader, Symbol* target_classname, Thread* THREAD);
141 
142   // support for miranda methods
143   bool is_miranda_entry_at(int i);
144   int fill_in_mirandas(int initialized, TRAPS);
145   static bool is_miranda(Method* m, Array&lt;Method*&gt;* class_methods,
146                          Array&lt;Method*&gt;* default_methods, const Klass* super,
147                          bool is_interface);
148   static void add_new_mirandas_to_lists(
</pre>
<hr />
<pre>
206   void clear()                { _method = NULL; }
207   void print()                                        PRODUCT_RETURN;
208   void verify(klassVtable* vt, outputStream* st);
209 
210   friend class klassVtable;
211 };
212 
213 
214 inline Method* klassVtable::method_at(int i) const {
215   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
216   assert(table()[i].method() != NULL, &quot;should not be null&quot;);
217   assert(((Metadata*)table()[i].method())-&gt;is_method(), &quot;should be method&quot;);
218   return table()[i].method();
219 }
220 
221 inline Method* klassVtable::unchecked_method_at(int i) const {
222   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
223   return table()[i].method();
224 }
225 
<span class="line-removed">226 inline Method** klassVtable::adr_method_at(int i) const {</span>
<span class="line-removed">227   // Allow one past the last entry to be referenced; useful for loop bounds.</span>
<span class="line-removed">228   assert(i &gt;= 0 &amp;&amp; i &lt;= _length, &quot;index out of bounds&quot;);</span>
<span class="line-removed">229   return (Method**)(address(table() + i) + vtableEntry::method_offset_in_bytes());</span>
<span class="line-removed">230 }</span>
<span class="line-removed">231 </span>
232 // --------------------------------------------------------------------------------
233 class klassItable;
234 class itableMethodEntry;
235 
236 class itableOffsetEntry {
237  private:
238   InstanceKlass* _interface;
239   int      _offset;
240  public:
241   InstanceKlass* interface_klass() const { return _interface; }
242   InstanceKlass**interface_klass_addr()  { return &amp;_interface; }
243   int      offset() const          { return _offset; }
244 
245   static itableMethodEntry* method_entry(Klass* k, int offset) { return (itableMethodEntry*)(((address)k) + offset); }
246   itableMethodEntry* first_method_entry(Klass* k)              { return method_entry(k, _offset); }
247 
248   void initialize(InstanceKlass* interf, int offset) { _interface = interf; _offset = offset; }
249 
250   // Static size and offset accessors
251   static int size()                       { return sizeof(itableOffsetEntry) / wordSize; }    // size in words
</pre>
<hr />
<pre>
316   void initialize_itable(bool checkconstraints, TRAPS);
317 
318 #if INCLUDE_JVMTI
319   // RedefineClasses() API support:
320   // if any entry of this itable points to any of old_methods,
321   // replace it with the corresponding new_method.
322   // trace_name_printed is set to true if the current call has
323   // printed the klass name so that other routines in the adjust_*
324   // group don&#39;t print the klass name.
325   void adjust_method_entries(bool* trace_name_printed);
326   bool check_no_old_or_obsolete_entries();
327   void dump_itable();
328 #endif // INCLUDE_JVMTI
329 
330   // Setup of itable
331   static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
332   static int method_count_for_interface(InstanceKlass* klass);
333   static int compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces);
334   static void setup_itable_offset_table(InstanceKlass* klass);
335 
<span class="line-removed">336   // Resolving of method to index</span>
<span class="line-removed">337   static Method* method_for_itable_index(InstanceKlass* klass, int itable_index);</span>
<span class="line-removed">338 </span>
339   // Debugging/Statistics
340   static void print_statistics() PRODUCT_RETURN;
341  private:
342   intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
343   intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }
344 
345   // Helper methods
346   static int  calc_itable_size(int num_interfaces, int num_methods) { return (num_interfaces * itableOffsetEntry::size()) + (num_methods * itableMethodEntry::size()); }
347 
348   // Statistics
349   NOT_PRODUCT(static int  _total_classes;)   // Total no. of classes with itables
350   NOT_PRODUCT(static long _total_size;)      // Total no. of bytes used for itables
351 
352   static void update_stats(int size) PRODUCT_RETURN NOT_PRODUCT({ _total_classes++; _total_size += size; })
353 };
354 
355 #endif // SHARE_OOPS_KLASSVTABLE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 31 
 32 // A klassVtable abstracts the variable-length vtable that is embedded in InstanceKlass
 33 // and ArrayKlass.  klassVtable objects are used just as convenient transient accessors to the vtable,
 34 // not to actually hold the vtable data.
 35 // Note: the klassVtable should not be accessed before the class has been verified
 36 // (until that point, the vtable is uninitialized).
 37 
 38 // Currently a klassVtable contains a direct reference to the vtable data, and is therefore
 39 // not preserved across GCs.
 40 
 41 class vtableEntry;
 42 
 43 class klassVtable {
 44   Klass*       _klass;            // my klass
 45   int          _tableOffset;      // offset of start of vtable data within klass
 46   int          _length;           // length of vtable (number of entries)
 47 #ifndef PRODUCT
 48   int          _verify_count;     // to make verify faster
 49 #endif
 50 







 51  public:
 52   klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
 53     _tableOffset = (address)base - (address)klass; _length = length;
 54   }
 55 
 56   // accessors
 57   vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
 58   Klass* klass() const            { return _klass;  }
 59   int length() const              { return _length; }
 60   inline Method* method_at(int i) const;
 61   inline Method* unchecked_method_at(int i) const;

 62 
 63   // searching; all methods return -1 if not found

 64   int index_of_miranda(Symbol* name, Symbol* signature);
 65 
 66   void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
 67 








 68   // computes vtable length (in words) and the number of miranda methods
 69   static void compute_vtable_size_and_num_mirandas(int* vtable_length,
 70                                                    int* num_new_mirandas,
 71                                                    GrowableArray&lt;Method*&gt;* all_mirandas,
 72                                                    const Klass* super,
 73                                                    Array&lt;Method*&gt;* methods,
 74                                                    AccessFlags class_flags,
 75                                                    u2 major_version,
 76                                                    Handle classloader,
 77                                                    Symbol* classname,
 78                                                    Array&lt;InstanceKlass*&gt;* local_interfaces,
 79                                                    TRAPS);
 80 
 81 #if INCLUDE_JVMTI
 82   // RedefineClasses() API support:
 83   // If any entry of this vtable points to any of old_methods,
 84   // replace it with the corresponding new_method.
 85   // trace_name_printed is set to true if the current call has
 86   // printed the klass name so that other routines in the adjust_*
 87   // group don&#39;t print the klass name.
</pre>
<hr />
<pre>
 91   void dump_vtable();
 92 #endif // INCLUDE_JVMTI
 93 
 94   // Debugging code
 95   void print()                                              PRODUCT_RETURN;
 96   void verify(outputStream* st, bool force = false);
 97   static void print_statistics()                            PRODUCT_RETURN;
 98 
 99  protected:
100   friend class vtableEntry;
101 
102  public:
103   // Transitive overridng rules for class files &lt; JDK1_7 use the older JVMS rules.
104   // Overriding is determined as we create the vtable, so we use the class file version
105   // of the class whose vtable we are calculating.
106   enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
107 
108  private:
109   void copy_vtable_to(vtableEntry* start);
110   int  initialize_from_super(Klass* super);

111   void put_method_at(Method* m, int index);
112   static bool needs_new_vtable_entry(const methodHandle&amp; m,
113                                      const Klass* super,
114                                      Handle classloader,
115                                      Symbol* classname,
116                                      AccessFlags access_flags,
117                                      u2 major_version,
118                                      TRAPS);
119 
120   bool update_inherited_vtable(InstanceKlass* klass, const methodHandle&amp; target_method, int super_vtable_len, int default_index, bool checkconstraints, TRAPS);
121  InstanceKlass* find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method, int vtable_index,
122                                          Handle target_loader, Symbol* target_classname, Thread* THREAD);
123 
124   // support for miranda methods
125   bool is_miranda_entry_at(int i);
126   int fill_in_mirandas(int initialized, TRAPS);
127   static bool is_miranda(Method* m, Array&lt;Method*&gt;* class_methods,
128                          Array&lt;Method*&gt;* default_methods, const Klass* super,
129                          bool is_interface);
130   static void add_new_mirandas_to_lists(
</pre>
<hr />
<pre>
188   void clear()                { _method = NULL; }
189   void print()                                        PRODUCT_RETURN;
190   void verify(klassVtable* vt, outputStream* st);
191 
192   friend class klassVtable;
193 };
194 
195 
196 inline Method* klassVtable::method_at(int i) const {
197   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
198   assert(table()[i].method() != NULL, &quot;should not be null&quot;);
199   assert(((Metadata*)table()[i].method())-&gt;is_method(), &quot;should be method&quot;);
200   return table()[i].method();
201 }
202 
203 inline Method* klassVtable::unchecked_method_at(int i) const {
204   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
205   return table()[i].method();
206 }
207 






208 // --------------------------------------------------------------------------------
209 class klassItable;
210 class itableMethodEntry;
211 
212 class itableOffsetEntry {
213  private:
214   InstanceKlass* _interface;
215   int      _offset;
216  public:
217   InstanceKlass* interface_klass() const { return _interface; }
218   InstanceKlass**interface_klass_addr()  { return &amp;_interface; }
219   int      offset() const          { return _offset; }
220 
221   static itableMethodEntry* method_entry(Klass* k, int offset) { return (itableMethodEntry*)(((address)k) + offset); }
222   itableMethodEntry* first_method_entry(Klass* k)              { return method_entry(k, _offset); }
223 
224   void initialize(InstanceKlass* interf, int offset) { _interface = interf; _offset = offset; }
225 
226   // Static size and offset accessors
227   static int size()                       { return sizeof(itableOffsetEntry) / wordSize; }    // size in words
</pre>
<hr />
<pre>
292   void initialize_itable(bool checkconstraints, TRAPS);
293 
294 #if INCLUDE_JVMTI
295   // RedefineClasses() API support:
296   // if any entry of this itable points to any of old_methods,
297   // replace it with the corresponding new_method.
298   // trace_name_printed is set to true if the current call has
299   // printed the klass name so that other routines in the adjust_*
300   // group don&#39;t print the klass name.
301   void adjust_method_entries(bool* trace_name_printed);
302   bool check_no_old_or_obsolete_entries();
303   void dump_itable();
304 #endif // INCLUDE_JVMTI
305 
306   // Setup of itable
307   static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
308   static int method_count_for_interface(InstanceKlass* klass);
309   static int compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces);
310   static void setup_itable_offset_table(InstanceKlass* klass);
311 



312   // Debugging/Statistics
313   static void print_statistics() PRODUCT_RETURN;
314  private:
315   intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
316   intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }
317 
318   // Helper methods
319   static int  calc_itable_size(int num_interfaces, int num_methods) { return (num_interfaces * itableOffsetEntry::size()) + (num_methods * itableMethodEntry::size()); }
320 
321   // Statistics
322   NOT_PRODUCT(static int  _total_classes;)   // Total no. of classes with itables
323   NOT_PRODUCT(static long _total_size;)      // Total no. of bytes used for itables
324 
325   static void update_stats(int size) PRODUCT_RETURN NOT_PRODUCT({ _total_classes++; _total_size += size; })
326 };
327 
328 #endif // SHARE_OOPS_KLASSVTABLE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="klassVtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metadata.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
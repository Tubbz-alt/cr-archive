<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/klassVtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_KLASSVTABLE_HPP
 26 #define SHARE_OOPS_KLASSVTABLE_HPP
 27 
 28 #include &quot;oops/oopsHierarchy.hpp&quot;
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
 32 // A klassVtable abstracts the variable-length vtable that is embedded in InstanceKlass
 33 // and ArrayKlass.  klassVtable objects are used just as convenient transient accessors to the vtable,
 34 // not to actually hold the vtable data.
 35 // Note: the klassVtable should not be accessed before the class has been verified
 36 // (until that point, the vtable is uninitialized).
 37 
 38 // Currently a klassVtable contains a direct reference to the vtable data, and is therefore
 39 // not preserved across GCs.
 40 
 41 class vtableEntry;
 42 
 43 class klassVtable {
 44   Klass*       _klass;            // my klass
 45   int          _tableOffset;      // offset of start of vtable data within klass
 46   int          _length;           // length of vtable (number of entries)
 47 #ifndef PRODUCT
 48   int          _verify_count;     // to make verify faster
 49 #endif
 50 
 51  public:
 52   klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
 53     _tableOffset = (address)base - (address)klass; _length = length;
 54   }
 55 
 56   // accessors
 57   vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
 58   Klass* klass() const            { return _klass;  }
 59   int length() const              { return _length; }
 60   inline Method* method_at(int i) const;
 61   inline Method* unchecked_method_at(int i) const;
 62 
 63   // searching; all methods return -1 if not found
 64   int index_of_miranda(Symbol* name, Symbol* signature);
 65 
 66   void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
 67 
 68   // computes vtable length (in words) and the number of miranda methods
 69   static void compute_vtable_size_and_num_mirandas(int* vtable_length,
 70                                                    int* num_new_mirandas,
 71                                                    GrowableArray&lt;Method*&gt;* all_mirandas,
 72                                                    const Klass* super,
 73                                                    Array&lt;Method*&gt;* methods,
 74                                                    AccessFlags class_flags,
 75                                                    u2 major_version,
 76                                                    Handle classloader,
 77                                                    Symbol* classname,
 78                                                    Array&lt;InstanceKlass*&gt;* local_interfaces,
 79                                                    TRAPS);
 80 
 81 #if INCLUDE_JVMTI
 82   // RedefineClasses() API support:
 83   // If any entry of this vtable points to any of old_methods,
 84   // replace it with the corresponding new_method.
 85   // trace_name_printed is set to true if the current call has
 86   // printed the klass name so that other routines in the adjust_*
 87   // group don&#39;t print the klass name.
 88   bool adjust_default_method(int vtable_index, Method* old_method, Method* new_method);
 89   void adjust_method_entries(bool* trace_name_printed);
 90   bool check_no_old_or_obsolete_entries();
 91   void dump_vtable();
 92 #endif // INCLUDE_JVMTI
 93 
 94   // Debugging code
 95   void print()                                              PRODUCT_RETURN;
 96   void verify(outputStream* st, bool force = false);
 97   static void print_statistics()                            PRODUCT_RETURN;
 98 
 99  protected:
100   friend class vtableEntry;
101 
102  public:
103   // Transitive overridng rules for class files &lt; JDK1_7 use the older JVMS rules.
104   // Overriding is determined as we create the vtable, so we use the class file version
105   // of the class whose vtable we are calculating.
106   enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
107 
108  private:
109   void copy_vtable_to(vtableEntry* start);
110   int  initialize_from_super(Klass* super);
111   void put_method_at(Method* m, int index);
112   static bool needs_new_vtable_entry(const methodHandle&amp; m,
113                                      const Klass* super,
114                                      Handle classloader,
115                                      Symbol* classname,
116                                      AccessFlags access_flags,
117                                      u2 major_version,
118                                      TRAPS);
119 
120   bool update_inherited_vtable(InstanceKlass* klass, const methodHandle&amp; target_method, int super_vtable_len, int default_index, bool checkconstraints, TRAPS);
121  InstanceKlass* find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method, int vtable_index,
122                                          Handle target_loader, Symbol* target_classname, Thread* THREAD);
123 
124   // support for miranda methods
125   bool is_miranda_entry_at(int i);
126   int fill_in_mirandas(int initialized, TRAPS);
127   static bool is_miranda(Method* m, Array&lt;Method*&gt;* class_methods,
128                          Array&lt;Method*&gt;* default_methods, const Klass* super,
129                          bool is_interface);
130   static void add_new_mirandas_to_lists(
131       GrowableArray&lt;Method*&gt;* new_mirandas,
132       GrowableArray&lt;Method*&gt;* all_mirandas,
133       Array&lt;Method*&gt;* current_interface_methods,
134       Array&lt;Method*&gt;* class_methods,
135       Array&lt;Method*&gt;* default_methods,
136       const Klass* super,
137       bool is_interface);
138   static void get_mirandas(
139       GrowableArray&lt;Method*&gt;* new_mirandas,
140       GrowableArray&lt;Method*&gt;* all_mirandas,
141       const Klass* super,
142       Array&lt;Method*&gt;* class_methods,
143       Array&lt;Method*&gt;* default_methods,
144       Array&lt;InstanceKlass*&gt;* local_interfaces,
145       bool is_interface);
146   void verify_against(outputStream* st, klassVtable* vt, int index);
147   inline InstanceKlass* ik() const;
148   // When loading a class from CDS archive at run time, and no class redefintion
149   // has happened, it is expected that the class&#39;s itable/vtables are
150   // laid out exactly the same way as they had been during dump time.
151   // Therefore, in klassVtable::initialize_[iv]table, we do not layout the
152   // tables again. Instead, we only rerun the process to create/check
153   // the class loader constraints. In non-product builds, we add asserts to
154   // guarantee that the table&#39;s layout would be the same as at dump time.
155   //
156   // If JVMTI redefines any class, the read-only shared memory are remapped
157   // as read-write. A shared class&#39; vtable/itable are re-initialized and
158   // might have different layout due to class redefinition of the shared class
159   // or its super types.
160   bool is_preinitialized_vtable();
161 };
162 
163 
164 // private helper class for klassVtable
165 // description of entry points:
166 //    destination is interpreted:
167 //      from_compiled_code_entry_point -&gt; c2iadapter
168 //      from_interpreter_entry_point   -&gt; interpreter entry point
169 //    destination is compiled:
170 //      from_compiled_code_entry_point -&gt; nmethod entry point
171 //      from_interpreter_entry_point   -&gt; i2cadapter
172 class vtableEntry {
173   friend class VMStructs;
174   friend class JVMCIVMStructs;
175 
176  public:
177   // size in words
178   static int size()          { return sizeof(vtableEntry) / wordSize; }
179   static int size_in_bytes() { return sizeof(vtableEntry); }
180 
181   static int method_offset_in_bytes() { return offset_of(vtableEntry, _method); }
182   Method* method() const    { return _method; }
183   Method** method_addr()    { return &amp;_method; }
184 
185  private:
186   Method* _method;
187   void set(Method* method)  { assert(method != NULL, &quot;use clear&quot;); _method = method; }
188   void clear()                { _method = NULL; }
189   void print()                                        PRODUCT_RETURN;
190   void verify(klassVtable* vt, outputStream* st);
191 
192   friend class klassVtable;
193 };
194 
195 
196 inline Method* klassVtable::method_at(int i) const {
197   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
198   assert(table()[i].method() != NULL, &quot;should not be null&quot;);
199   assert(((Metadata*)table()[i].method())-&gt;is_method(), &quot;should be method&quot;);
200   return table()[i].method();
201 }
202 
203 inline Method* klassVtable::unchecked_method_at(int i) const {
204   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
205   return table()[i].method();
206 }
207 
208 // --------------------------------------------------------------------------------
209 class klassItable;
210 class itableMethodEntry;
211 
212 class itableOffsetEntry {
213  private:
214   InstanceKlass* _interface;
215   int      _offset;
216  public:
217   InstanceKlass* interface_klass() const { return _interface; }
218   InstanceKlass**interface_klass_addr()  { return &amp;_interface; }
219   int      offset() const          { return _offset; }
220 
221   static itableMethodEntry* method_entry(Klass* k, int offset) { return (itableMethodEntry*)(((address)k) + offset); }
222   itableMethodEntry* first_method_entry(Klass* k)              { return method_entry(k, _offset); }
223 
224   void initialize(InstanceKlass* interf, int offset) { _interface = interf; _offset = offset; }
225 
226   // Static size and offset accessors
227   static int size()                       { return sizeof(itableOffsetEntry) / wordSize; }    // size in words
228   static int interface_offset_in_bytes()  { return offset_of(itableOffsetEntry, _interface); }
229   static int offset_offset_in_bytes()     { return offset_of(itableOffsetEntry, _offset); }
230 
231   friend class klassItable;
232 };
233 
234 
235 class itableMethodEntry {
236  private:
237   Method* _method;
238 
239  public:
240   Method* method() const { return _method; }
241   Method**method_addr() { return &amp;_method; }
242 
243   void clear()             { _method = NULL; }
244 
245   void initialize(Method* method);
246 
247   // Static size and offset accessors
248   static int size()                         { return sizeof(itableMethodEntry) / wordSize; }  // size in words
249   static int method_offset_in_bytes()       { return offset_of(itableMethodEntry, _method); }
250 
251   friend class klassItable;
252 };
253 
254 //
255 // Format of an itable
256 //
257 //    ---- offset table ---
258 //    Klass* of interface 1             \
259 //    offset to vtable from start of oop  / offset table entry
260 //    ...
261 //    Klass* of interface n             \
262 //    offset to vtable from start of oop  / offset table entry
263 //    --- vtable for interface 1 ---
264 //    Method*                             \
265 //    compiler entry point                / method table entry
266 //    ...
267 //    Method*                             \
268 //    compiler entry point                / method table entry
269 //    -- vtable for interface 2 ---
270 //    ...
271 //
272 class klassItable {
273  private:
274   InstanceKlass*       _klass;             // my klass
275   int                  _table_offset;      // offset of start of itable data within klass (in words)
276   int                  _size_offset_table; // size of offset table (in itableOffset entries)
277   int                  _size_method_table; // size of methodtable (in itableMethodEntry entries)
278 
279   void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h, bool checkconstraints, TRAPS);
280  public:
281   klassItable(InstanceKlass* klass);
282 
283   itableOffsetEntry* offset_entry(int i) { assert(0 &lt;= i &amp;&amp; i &lt;= _size_offset_table, &quot;index out of bounds&quot;);
284                                            return &amp;((itableOffsetEntry*)vtable_start())[i]; }
285 
286   itableMethodEntry* method_entry(int i) { assert(0 &lt;= i &amp;&amp; i &lt;= _size_method_table, &quot;index out of bounds&quot;);
287                                            return &amp;((itableMethodEntry*)method_start())[i]; }
288 
289   int size_offset_table()                { return _size_offset_table; }
290 
291   // Initialization
292   void initialize_itable(bool checkconstraints, TRAPS);
293 
294 #if INCLUDE_JVMTI
295   // RedefineClasses() API support:
296   // if any entry of this itable points to any of old_methods,
297   // replace it with the corresponding new_method.
298   // trace_name_printed is set to true if the current call has
299   // printed the klass name so that other routines in the adjust_*
300   // group don&#39;t print the klass name.
301   void adjust_method_entries(bool* trace_name_printed);
302   bool check_no_old_or_obsolete_entries();
303   void dump_itable();
304 #endif // INCLUDE_JVMTI
305 
306   // Setup of itable
307   static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
308   static int method_count_for_interface(InstanceKlass* klass);
309   static int compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces);
310   static void setup_itable_offset_table(InstanceKlass* klass);
311 
312   // Debugging/Statistics
313   static void print_statistics() PRODUCT_RETURN;
314  private:
315   intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
316   intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }
317 
318   // Helper methods
319   static int  calc_itable_size(int num_interfaces, int num_methods) { return (num_interfaces * itableOffsetEntry::size()) + (num_methods * itableMethodEntry::size()); }
320 
321   // Statistics
322   NOT_PRODUCT(static int  _total_classes;)   // Total no. of classes with itables
323   NOT_PRODUCT(static long _total_size;)      // Total no. of bytes used for itables
324 
325   static void update_stats(int size) PRODUCT_RETURN NOT_PRODUCT({ _total_classes++; _total_size += size; })
326 };
327 
328 #endif // SHARE_OOPS_KLASSVTABLE_HPP
    </pre>
  </body>
</html>
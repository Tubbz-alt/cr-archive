<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
<span class="line-removed">  96 class KlassSizeStats;</span>
<span class="line-removed">  97 </span>
  98 class ConstantPool : public Metadata {
  99   friend class VMStructs;
 100   friend class JVMCIVMStructs;
 101   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 102   friend class Universe;             // For null constructor
 103  private:
 104   // If you add a new field that points to any metaspace object, you
 105   // must add this field to ConstantPool::metaspace_pointers_do().
 106   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 107   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 108   InstanceKlass*       _pool_holder; // the corresponding class
 109   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 110 
 111   // Consider using an array of compressed klass pointers to
 112   // save space on 64-bit platforms.
 113   Array&lt;Klass*&gt;*       _resolved_klasses;
 114 
 115   enum {
 116     _has_preresolution    = 1,       // Flags
 117     _on_stack             = 2,
</pre>
<hr />
<pre>
 729   oop resolve_constant_at(int index, TRAPS) {
 730     constantPoolHandle h_this(THREAD, this);
 731     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 732   }
 733 
 734   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 735     constantPoolHandle h_this(THREAD, this);
 736     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 737   }
 738 
 739   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 740     constantPoolHandle h_this(THREAD, this);
 741     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 742   }
 743 
 744   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 745     constantPoolHandle h_this(THREAD, this);
 746     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 747   }
 748 
<span class="line-removed"> 749   oop resolve_bootstrap_specifier_at(int index, TRAPS) {</span>
<span class="line-removed"> 750     constantPoolHandle h_this(THREAD, this);</span>
<span class="line-removed"> 751     return resolve_bootstrap_specifier_at_impl(h_this, index, THREAD);</span>
<span class="line-removed"> 752   }</span>
<span class="line-removed"> 753 </span>
 754   void copy_bootstrap_arguments_at(int index,
 755                                    int start_arg, int end_arg,
 756                                    objArrayHandle info, int pos,
 757                                    bool must_resolve, Handle if_not_available, TRAPS) {
 758     constantPoolHandle h_this(THREAD, this);
 759     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 760                                      info, pos, must_resolve, if_not_available, THREAD);
 761   }
 762 
 763   // Klass name matches name at offset
 764   bool klass_name_at_matches(const InstanceKlass* k, int which);
 765 
 766   // Sizing
 767   int length() const                   { return _length; }
 768   void set_length(int length)          { _length = length; }
 769 
 770   // Tells whether index is within bounds.
 771   bool is_within_bounds(int index) const {
 772     return 0 &lt;= index &amp;&amp; index &lt; length();
 773   }
 774 
 775   // Sizing (in words)
 776   static int header_size()             {
 777     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 778   }
 779   static int size(int length)          { return align_metadata_size(header_size() + length); }
 780   int size() const                     { return size(length()); }
<span class="line-removed"> 781 #if INCLUDE_SERVICES</span>
<span class="line-removed"> 782   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed"> 783 #endif</span>
 784 
 785   // ConstantPools should be stored in the read-only region of CDS archive.
 786   static bool is_read_only_by_default() { return true; }
 787 
 788   friend class ClassFileParser;
 789   friend class SystemDictionary;
 790 
 791   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 792   template &lt;class T&gt; friend class CppVtableTesterA;
 793   template &lt;class T&gt; friend class CppVtableTesterB;
 794   template &lt;class T&gt; friend class CppVtableCloner;
 795 
 796   // Used by compiler to prevent classloading.
 797   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 798   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 799   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 800   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 801   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 802 
 803   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
</pre>
<hr />
<pre>
 854     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 855     return *int_at_addr(which);
 856   }
 857 
 858   // Performs the LinkResolver checks
 859   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 860 
 861   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 862   // handle GC while executing the method
 863   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 864                               bool save_resolution_error, TRAPS);
 865   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 866 
 867   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 868 
 869   // Resolve string constants (to prevent allocation during compilation)
 870   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 871 
 872   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 873                                       bool* status_return, TRAPS);
<span class="line-removed"> 874   static oop resolve_bootstrap_specifier_at_impl(const constantPoolHandle&amp; this_cp, int index, TRAPS);</span>
 875   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 876                                                int start_arg, int end_arg,
 877                                                objArrayHandle info, int pos,
 878                                                bool must_resolve, Handle if_not_available, TRAPS);
 879 
 880   // Exception handling
 881   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 882   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 883 
 884  public:
 885   // Exception handling
 886   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 887 
 888   // Merging ConstantPool* support:
 889   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 890   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 891     constantPoolHandle h_this(THREAD, this);
 892     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 893   }
 894   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 


  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
 113   enum {
 114     _has_preresolution    = 1,       // Flags
 115     _on_stack             = 2,
</pre>
<hr />
<pre>
 727   oop resolve_constant_at(int index, TRAPS) {
 728     constantPoolHandle h_this(THREAD, this);
 729     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 730   }
 731 
 732   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 733     constantPoolHandle h_this(THREAD, this);
 734     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 735   }
 736 
 737   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 738     constantPoolHandle h_this(THREAD, this);
 739     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 740   }
 741 
 742   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 743     constantPoolHandle h_this(THREAD, this);
 744     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 745   }
 746 





 747   void copy_bootstrap_arguments_at(int index,
 748                                    int start_arg, int end_arg,
 749                                    objArrayHandle info, int pos,
 750                                    bool must_resolve, Handle if_not_available, TRAPS) {
 751     constantPoolHandle h_this(THREAD, this);
 752     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 753                                      info, pos, must_resolve, if_not_available, THREAD);
 754   }
 755 
 756   // Klass name matches name at offset
 757   bool klass_name_at_matches(const InstanceKlass* k, int which);
 758 
 759   // Sizing
 760   int length() const                   { return _length; }
 761   void set_length(int length)          { _length = length; }
 762 
 763   // Tells whether index is within bounds.
 764   bool is_within_bounds(int index) const {
 765     return 0 &lt;= index &amp;&amp; index &lt; length();
 766   }
 767 
 768   // Sizing (in words)
 769   static int header_size()             {
 770     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 771   }
 772   static int size(int length)          { return align_metadata_size(header_size() + length); }
 773   int size() const                     { return size(length()); }



 774 
 775   // ConstantPools should be stored in the read-only region of CDS archive.
 776   static bool is_read_only_by_default() { return true; }
 777 
 778   friend class ClassFileParser;
 779   friend class SystemDictionary;
 780 
 781   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 782   template &lt;class T&gt; friend class CppVtableTesterA;
 783   template &lt;class T&gt; friend class CppVtableTesterB;
 784   template &lt;class T&gt; friend class CppVtableCloner;
 785 
 786   // Used by compiler to prevent classloading.
 787   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 788   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 789   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 790   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 791   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 792 
 793   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
</pre>
<hr />
<pre>
 844     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 845     return *int_at_addr(which);
 846   }
 847 
 848   // Performs the LinkResolver checks
 849   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 850 
 851   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 852   // handle GC while executing the method
 853   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 854                               bool save_resolution_error, TRAPS);
 855   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 856 
 857   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 858 
 859   // Resolve string constants (to prevent allocation during compilation)
 860   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 861 
 862   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 863                                       bool* status_return, TRAPS);

 864   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 865                                                int start_arg, int end_arg,
 866                                                objArrayHandle info, int pos,
 867                                                bool must_resolve, Handle if_not_available, TRAPS);
 868 
 869   // Exception handling
 870   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 871   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 872 
 873  public:
 874   // Exception handling
 875   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 876 
 877   // Merging ConstantPool* support:
 878   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 879   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 880     constantPoolHandle h_this(THREAD, this);
 881     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 882   }
 883   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
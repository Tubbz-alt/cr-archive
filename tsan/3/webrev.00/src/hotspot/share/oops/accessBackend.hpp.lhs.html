<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
<a name="1" id="anc1"></a>
  41 #include &quot;utilities/debug.hpp&quot;
  42 #include &quot;utilities/globalDefinitions.hpp&quot;
  43 
  44 
  45 // This metafunction returns either oop or narrowOop depending on whether
  46 // an access needs to use compressed oops or not.
  47 template &lt;DecoratorSet decorators&gt;
  48 struct HeapOopType: AllStatic {
  49   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  50                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  51   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  52 };
  53 
  54 namespace AccessInternal {
  55   enum BarrierType {
  56     BARRIER_STORE,
  57     BARRIER_STORE_AT,
  58     BARRIER_LOAD,
  59     BARRIER_LOAD_AT,
  60     BARRIER_ATOMIC_CMPXCHG,
  61     BARRIER_ATOMIC_CMPXCHG_AT,
  62     BARRIER_ATOMIC_XCHG,
  63     BARRIER_ATOMIC_XCHG_AT,
  64     BARRIER_ARRAYCOPY,
  65     BARRIER_CLONE,
<a name="2" id="anc2"></a><span class="line-modified">  66     BARRIER_RESOLVE,</span>
<span class="line-removed">  67     BARRIER_EQUALS</span>
  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
  87   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  88     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  89              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  90   }
  91 
  92   // This metafunction returns whether it is possible for a type T to require
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<a name="3" id="anc3"></a><span class="line-modified"> 105     typedef T (*atomic_cmpxchg_at_func_t)(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
<span class="line-modified"> 106     typedef T (*atomic_xchg_at_func_t)(T new_value, oop base, ptrdiff_t offset);</span>
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
<a name="4" id="anc4"></a><span class="line-modified"> 110     typedef T (*atomic_cmpxchg_func_t)(T new_value, void* addr, T compare_value);</span>
<span class="line-modified"> 111     typedef T (*atomic_xchg_func_t)(T new_value, void* addr);</span>
 112 
 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
 117     typedef oop (*resolve_func_t)(oop obj);
<a name="5" id="anc5"></a><span class="line-removed"> 118     typedef bool (*equals_func_t)(oop o1, oop o2);</span>
 119   };
 120 
 121   template &lt;DecoratorSet decorators&gt;
 122   struct AccessFunctionTypes&lt;decorators, void&gt; {
 123     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
 124                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 125                                      size_t length);
 126   };
 127 
 128   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 129 
 130 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 131   template &lt;DecoratorSet decorators, typename T&gt;                    \
 132   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 133     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 134   }
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
 145   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
<a name="6" id="anc6"></a><span class="line-removed"> 146   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_EQUALS, equals_func_t);</span>
 147 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 148 
 149   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 150   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 151 
 152   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 153   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 154 
 155   class AccessLocker {
 156   public:
 157     AccessLocker();
 158     ~AccessLocker();
 159   };
 160   bool wide_atomic_needs_locking();
 161 
 162   void* field_addr(oop base, ptrdiff_t offset);
 163 
 164   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 165   // faster build times, given how frequently included access is.
 166   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
 167   void arraycopy_conjoint_oops(oop* src, oop* dst, size_t length);
 168   void arraycopy_conjoint_oops(narrowOop* src, narrowOop* dst, size_t length);
 169 
 170   void arraycopy_disjoint_words(void* src, void* dst, size_t length);
 171   void arraycopy_disjoint_words_atomic(void* src, void* dst, size_t length);
 172 
 173   template&lt;typename T&gt;
 174   void arraycopy_conjoint(T* src, T* dst, size_t length);
 175   template&lt;typename T&gt;
 176   void arraycopy_arrayof_conjoint(T* src, T* dst, size_t length);
 177   template&lt;typename T&gt;
 178   void arraycopy_conjoint_atomic(T* src, T* dst, size_t length);
 179 }
 180 
 181 // This mask specifies what decorators are relevant for raw accesses. When passing
 182 // accesses to the raw layer, irrelevant decorators are removed.
 183 const DecoratorSet RAW_DECORATOR_MASK = INTERNAL_DECORATOR_MASK | MO_DECORATOR_MASK |
 184                                         ARRAYCOPY_DECORATOR_MASK | IS_NOT_NULL;
 185 
 186 // The RawAccessBarrier performs raw accesses with additional knowledge of
 187 // memory ordering, so that OrderAccess/Atomic is called when necessary.
 188 // It additionally handles compressed oops, and hence is not completely &quot;raw&quot;
 189 // strictly speaking.
 190 template &lt;DecoratorSet decorators&gt;
 191 class RawAccessBarrier: public AllStatic {
 192 protected:
 193   static inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 194     return AccessInternal::field_addr(base, byte_offset);
 195   }
 196 
 197 protected:
 198   // Only encode if INTERNAL_VALUE_IS_OOP
 199   template &lt;DecoratorSet idecorators, typename T&gt;
 200   static inline typename EnableIf&lt;
 201     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 202     typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 203   encode_internal(T value);
 204 
 205   template &lt;DecoratorSet idecorators, typename T&gt;
 206   static inline typename EnableIf&lt;
 207     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 208   encode_internal(T value) {
 209     return value;
 210   }
 211 
 212   template &lt;typename T&gt;
 213   static inline typename AccessInternal::EncodedType&lt;decorators, T&gt;::type
 214   encode(T value) {
 215     return encode_internal&lt;decorators, T&gt;(value);
 216   }
 217 
 218   // Only decode if INTERNAL_VALUE_IS_OOP
 219   template &lt;DecoratorSet idecorators, typename T&gt;
 220   static inline typename EnableIf&lt;
 221     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 222   decode_internal(typename HeapOopType&lt;idecorators&gt;::type value);
 223 
 224   template &lt;DecoratorSet idecorators, typename T&gt;
 225   static inline typename EnableIf&lt;
 226     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 227   decode_internal(T value) {
 228     return value;
 229   }
 230 
 231   template &lt;typename T&gt;
 232   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 233     return decode_internal&lt;decorators, T&gt;(value);
 234   }
 235 
 236 protected:
 237   template &lt;DecoratorSet ds, typename T&gt;
 238   static typename EnableIf&lt;
 239     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 240   load_internal(void* addr);
 241 
 242   template &lt;DecoratorSet ds, typename T&gt;
 243   static typename EnableIf&lt;
 244     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 245   load_internal(void* addr);
 246 
 247   template &lt;DecoratorSet ds, typename T&gt;
 248   static typename EnableIf&lt;
 249     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 250   load_internal(void* addr);
 251 
 252   template &lt;DecoratorSet ds, typename T&gt;
 253   static inline typename EnableIf&lt;
 254     HasDecorator&lt;ds, MO_VOLATILE&gt;::value, T&gt;::type
 255   load_internal(void* addr) {
 256     return *reinterpret_cast&lt;const volatile T*&gt;(addr);
 257   }
 258 
 259   template &lt;DecoratorSet ds, typename T&gt;
 260   static inline typename EnableIf&lt;
 261     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 262   load_internal(void* addr) {
 263     return *reinterpret_cast&lt;T*&gt;(addr);
 264   }
 265 
 266   template &lt;DecoratorSet ds, typename T&gt;
 267   static typename EnableIf&lt;
 268     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 269   store_internal(void* addr, T value);
 270 
 271   template &lt;DecoratorSet ds, typename T&gt;
 272   static typename EnableIf&lt;
 273     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 274   store_internal(void* addr, T value);
 275 
 276   template &lt;DecoratorSet ds, typename T&gt;
 277   static typename EnableIf&lt;
 278     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 279   store_internal(void* addr, T value);
 280 
 281   template &lt;DecoratorSet ds, typename T&gt;
 282   static inline typename EnableIf&lt;
 283     HasDecorator&lt;ds, MO_VOLATILE&gt;::value&gt;::type
 284   store_internal(void* addr, T value) {
 285     (void)const_cast&lt;T&amp;&gt;(*reinterpret_cast&lt;volatile T*&gt;(addr) = value);
 286   }
 287 
 288   template &lt;DecoratorSet ds, typename T&gt;
 289   static inline typename EnableIf&lt;
 290     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 291   store_internal(void* addr, T value) {
 292     *reinterpret_cast&lt;T*&gt;(addr) = value;
 293   }
 294 
 295   template &lt;DecoratorSet ds, typename T&gt;
 296   static typename EnableIf&lt;
 297     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<a name="7" id="anc7"></a><span class="line-modified"> 298   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
 299 
 300   template &lt;DecoratorSet ds, typename T&gt;
 301   static typename EnableIf&lt;
 302     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<a name="8" id="anc8"></a><span class="line-modified"> 303   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
 304 
 305   template &lt;DecoratorSet ds, typename T&gt;
 306   static typename EnableIf&lt;
 307     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<a name="9" id="anc9"></a><span class="line-modified"> 308   atomic_xchg_internal(T new_value, void* addr);</span>
 309 
 310   // The following *_locked mechanisms serve the purpose of handling atomic operations
 311   // that are larger than a machine can handle, and then possibly opt for using
 312   // a slower path using a mutex to perform the operation.
 313 
 314   template &lt;DecoratorSet ds, typename T&gt;
 315   static inline typename EnableIf&lt;
 316     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="10" id="anc10"></a><span class="line-modified"> 317   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 318     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);</span>
 319   }
 320 
 321   template &lt;DecoratorSet ds, typename T&gt;
 322   static typename EnableIf&lt;
 323     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="11" id="anc11"></a><span class="line-modified"> 324   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value);</span>
 325 
 326   template &lt;DecoratorSet ds, typename T&gt;
 327   static inline typename EnableIf&lt;
 328     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="12" id="anc12"></a><span class="line-modified"> 329   atomic_xchg_maybe_locked(T new_value, void* addr) {</span>
<span class="line-modified"> 330     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);</span>
 331   }
 332 
 333   template &lt;DecoratorSet ds, typename T&gt;
 334   static typename EnableIf&lt;
 335     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="13" id="anc13"></a><span class="line-modified"> 336   atomic_xchg_maybe_locked(T new_value, void* addr);</span>
 337 
 338 public:
 339   template &lt;typename T&gt;
 340   static inline void store(void* addr, T value) {
 341     store_internal&lt;decorators&gt;(addr, value);
 342   }
 343 
 344   template &lt;typename T&gt;
 345   static inline T load(void* addr) {
 346     return load_internal&lt;decorators, T&gt;(addr);
 347   }
 348 
 349   template &lt;typename T&gt;
<a name="14" id="anc14"></a><span class="line-modified"> 350   static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 351     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(new_value, addr, compare_value);</span>
 352   }
 353 
 354   template &lt;typename T&gt;
<a name="15" id="anc15"></a><span class="line-modified"> 355   static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified"> 356     return atomic_xchg_maybe_locked&lt;decorators&gt;(new_value, addr);</span>
 357   }
 358 
 359   template &lt;typename T&gt;
 360   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 361                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 362                         size_t length);
 363 
 364   template &lt;typename T&gt;
 365   static void oop_store(void* addr, T value);
 366   template &lt;typename T&gt;
 367   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 368 
 369   template &lt;typename T&gt;
 370   static T oop_load(void* addr);
 371   template &lt;typename T&gt;
 372   static T oop_load_at(oop base, ptrdiff_t offset);
 373 
 374   template &lt;typename T&gt;
<a name="16" id="anc16"></a><span class="line-modified"> 375   static T oop_atomic_cmpxchg(T new_value, void* addr, T compare_value);</span>
 376   template &lt;typename T&gt;
<a name="17" id="anc17"></a><span class="line-modified"> 377   static T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
 378 
 379   template &lt;typename T&gt;
<a name="18" id="anc18"></a><span class="line-modified"> 380   static T oop_atomic_xchg(T new_value, void* addr);</span>
 381   template &lt;typename T&gt;
<a name="19" id="anc19"></a><span class="line-modified"> 382   static T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset);</span>
 383 
 384   template &lt;typename T&gt;
 385   static void store_at(oop base, ptrdiff_t offset, T value) {
 386     store(field_addr(base, offset), value);
 387   }
 388 
 389   template &lt;typename T&gt;
 390   static T load_at(oop base, ptrdiff_t offset) {
 391     return load&lt;T&gt;(field_addr(base, offset));
 392   }
 393 
 394   template &lt;typename T&gt;
<a name="20" id="anc20"></a><span class="line-modified"> 395   static T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 396     return atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);</span>
 397   }
 398 
 399   template &lt;typename T&gt;
<a name="21" id="anc21"></a><span class="line-modified"> 400   static T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 401     return atomic_xchg(new_value, field_addr(base, offset));</span>
 402   }
 403 
 404   template &lt;typename T&gt;
 405   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 406                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 407                             size_t length);
 408 
 409   static void clone(oop src, oop dst, size_t size);
 410 
 411   static oop resolve(oop obj) { return obj; }
<a name="22" id="anc22"></a><span class="line-removed"> 412 </span>
<span class="line-removed"> 413   static bool equals(oop o1, oop o2) { return (void*)o1 == (void*)o2; }</span>
 414 };
 415 
 416 // Below is the implementation of the first 4 steps of the template pipeline:
 417 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 418 //           and sets default decorators to sensible values.
 419 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 420 //           multiple types. The P type of the address and T type of the value must
 421 //           match.
 422 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 423 //           avoided, and in that case avoids it (calling raw accesses or
 424 //           primitive accesses in a build that does not require primitive GC barriers)
 425 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 426 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 427 //           to the access.
 428 
 429 namespace AccessInternal {
 430   template &lt;typename T&gt;
 431   struct OopOrNarrowOopInternal: AllStatic {
 432     typedef oop type;
 433   };
 434 
 435   template &lt;&gt;
 436   struct OopOrNarrowOopInternal&lt;narrowOop&gt;: AllStatic {
 437     typedef narrowOop type;
 438   };
 439 
 440   // This metafunction returns a canonicalized oop/narrowOop type for a passed
 441   // in oop-like types passed in from oop_* overloads where the user has sworn
 442   // that the passed in values should be oop-like (e.g. oop, oopDesc*, arrayOop,
 443   // narrowOoop, instanceOopDesc*, and random other things).
 444   // In the oop_* overloads, it must hold that if the passed in type T is not
 445   // narrowOop, then it by contract has to be one of many oop-like types implicitly
 446   // convertible to oop, and hence returns oop as the canonical oop type.
 447   // If it turns out it was not, then the implicit conversion to oop will fail
 448   // to compile, as desired.
 449   template &lt;typename T&gt;
 450   struct OopOrNarrowOop: AllStatic {
 451     typedef typename OopOrNarrowOopInternal&lt;typename Decay&lt;T&gt;::type&gt;::type type;
 452   };
 453 
 454   inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 455     return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
 456   }
 457   // Step 4: Runtime dispatch
 458   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
 459   // accessor. This is required when the access either depends on whether compressed oops
 460   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
 461   // barriers). The way it works is that a function pointer initially pointing to an
 462   // accessor resolution function gets called for each access. Upon first invocation,
 463   // it resolves which accessor to be used in future invocations and patches the
 464   // function pointer to this new accessor.
 465 
 466   template &lt;DecoratorSet decorators, typename T, BarrierType type&gt;
 467   struct RuntimeDispatch: AllStatic {};
 468 
 469   template &lt;DecoratorSet decorators, typename T&gt;
 470   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;: AllStatic {
 471     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type func_t;
 472     static func_t _store_func;
 473 
 474     static void store_init(void* addr, T value);
 475 
 476     static inline void store(void* addr, T value) {
 477       _store_func(addr, value);
 478     }
 479   };
 480 
 481   template &lt;DecoratorSet decorators, typename T&gt;
 482   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;: AllStatic {
 483     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type func_t;
 484     static func_t _store_at_func;
 485 
 486     static void store_at_init(oop base, ptrdiff_t offset, T value);
 487 
 488     static inline void store_at(oop base, ptrdiff_t offset, T value) {
 489       _store_at_func(base, offset, value);
 490     }
 491   };
 492 
 493   template &lt;DecoratorSet decorators, typename T&gt;
 494   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;: AllStatic {
 495     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type func_t;
 496     static func_t _load_func;
 497 
 498     static T load_init(void* addr);
 499 
 500     static inline T load(void* addr) {
 501       return _load_func(addr);
 502     }
 503   };
 504 
 505   template &lt;DecoratorSet decorators, typename T&gt;
 506   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 507     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 508     static func_t _load_at_func;
 509 
 510     static T load_at_init(oop base, ptrdiff_t offset);
 511 
 512     static inline T load_at(oop base, ptrdiff_t offset) {
 513       return _load_at_func(base, offset);
 514     }
 515   };
 516 
 517   template &lt;DecoratorSet decorators, typename T&gt;
 518   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 519     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 520     static func_t _atomic_cmpxchg_func;
 521 
<a name="23" id="anc23"></a><span class="line-modified"> 522     static T atomic_cmpxchg_init(T new_value, void* addr, T compare_value);</span>
 523 
<a name="24" id="anc24"></a><span class="line-modified"> 524     static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 525       return _atomic_cmpxchg_func(new_value, addr, compare_value);</span>
 526     }
 527   };
 528 
 529   template &lt;DecoratorSet decorators, typename T&gt;
 530   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 531     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 532     static func_t _atomic_cmpxchg_at_func;
 533 
<a name="25" id="anc25"></a><span class="line-modified"> 534     static T atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
 535 
<a name="26" id="anc26"></a><span class="line-modified"> 536     static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 537       return _atomic_cmpxchg_at_func(new_value, base, offset, compare_value);</span>
 538     }
 539   };
 540 
 541   template &lt;DecoratorSet decorators, typename T&gt;
 542   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 543     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 544     static func_t _atomic_xchg_func;
 545 
<a name="27" id="anc27"></a><span class="line-modified"> 546     static T atomic_xchg_init(T new_value, void* addr);</span>
 547 
<a name="28" id="anc28"></a><span class="line-modified"> 548     static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified"> 549       return _atomic_xchg_func(new_value, addr);</span>
 550     }
 551   };
 552 
 553   template &lt;DecoratorSet decorators, typename T&gt;
 554   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 555     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 556     static func_t _atomic_xchg_at_func;
 557 
<a name="29" id="anc29"></a><span class="line-modified"> 558     static T atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset);</span>
 559 
<a name="30" id="anc30"></a><span class="line-modified"> 560     static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 561       return _atomic_xchg_at_func(new_value, base, offset);</span>
 562     }
 563   };
 564 
 565   template &lt;DecoratorSet decorators, typename T&gt;
 566   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 567     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 568     static func_t _arraycopy_func;
 569 
 570     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 571                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 572                                size_t length);
 573 
 574     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 575                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 576                                  size_t length) {
 577       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 578                              dst_obj, dst_offset_in_bytes, dst_raw,
 579                              length);
 580     }
 581   };
 582 
 583   template &lt;DecoratorSet decorators, typename T&gt;
 584   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 585     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 586     static func_t _clone_func;
 587 
 588     static void clone_init(oop src, oop dst, size_t size);
 589 
 590     static inline void clone(oop src, oop dst, size_t size) {
 591       _clone_func(src, dst, size);
 592     }
 593   };
 594 
 595   template &lt;DecoratorSet decorators, typename T&gt;
 596   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 597     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 598     static func_t _resolve_func;
 599 
 600     static oop resolve_init(oop obj);
 601 
 602     static inline oop resolve(oop obj) {
 603       return _resolve_func(obj);
 604     }
 605   };
 606 
<a name="31" id="anc31"></a><span class="line-removed"> 607   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed"> 608   struct RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;: AllStatic {</span>
<span class="line-removed"> 609     typedef typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type func_t;</span>
<span class="line-removed"> 610     static func_t _equals_func;</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612     static bool equals_init(oop o1, oop o2);</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614     static inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed"> 615       return _equals_func(o1, o2);</span>
<span class="line-removed"> 616     }</span>
<span class="line-removed"> 617   };</span>
<span class="line-removed"> 618 </span>
 619   // Initialize the function pointers to point to the resolving function.
 620   template &lt;DecoratorSet decorators, typename T&gt;
 621   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 622   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 623 
 624   template &lt;DecoratorSet decorators, typename T&gt;
 625   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 626   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 627 
 628   template &lt;DecoratorSet decorators, typename T&gt;
 629   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 630   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 631 
 632   template &lt;DecoratorSet decorators, typename T&gt;
 633   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 634   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 635 
 636   template &lt;DecoratorSet decorators, typename T&gt;
 637   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 638   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
 639 
 640   template &lt;DecoratorSet decorators, typename T&gt;
 641   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 642   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 643 
 644   template &lt;DecoratorSet decorators, typename T&gt;
 645   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 646   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 647 
 648   template &lt;DecoratorSet decorators, typename T&gt;
 649   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 650   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 651 
 652   template &lt;DecoratorSet decorators, typename T&gt;
 653   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 654   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 655 
 656   template &lt;DecoratorSet decorators, typename T&gt;
 657   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 658   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 659 
 660   template &lt;DecoratorSet decorators, typename T&gt;
 661   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 662   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 663 
<a name="32" id="anc32"></a><span class="line-removed"> 664   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed"> 665   typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type</span>
<span class="line-removed"> 666   RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;::_equals_func = &amp;equals_init;</span>
<span class="line-removed"> 667 </span>
 668   // Step 3: Pre-runtime dispatching.
 669   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 670   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 671   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 672   // not possible.
 673   struct PreRuntimeDispatch: AllStatic {
 674     template&lt;DecoratorSet decorators&gt;
 675     struct CanHardwireRaw: public IntegralConstant&lt;
 676       bool,
 677       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 678       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 679       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 680     {};
 681 
 682     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 683 
 684     template&lt;DecoratorSet decorators&gt;
 685     static bool is_hardwired_primitive() {
 686       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 687              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
 688     }
 689 
 690     template &lt;DecoratorSet decorators, typename T&gt;
 691     inline static typename EnableIf&lt;
 692       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 693     store(void* addr, T value) {
 694       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 695       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 696         Raw::oop_store(addr, value);
 697       } else {
 698         Raw::store(addr, value);
 699       }
 700     }
 701 
 702     template &lt;DecoratorSet decorators, typename T&gt;
 703     inline static typename EnableIf&lt;
 704       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 705     store(void* addr, T value) {
 706       if (UseCompressedOops) {
 707         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 708         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 709       } else {
 710         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 711         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 712       }
 713     }
 714 
 715     template &lt;DecoratorSet decorators, typename T&gt;
 716     inline static typename EnableIf&lt;
 717       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 718     store(void* addr, T value) {
 719       if (is_hardwired_primitive&lt;decorators&gt;()) {
 720         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 721         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 722       } else {
 723         RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store(addr, value);
 724       }
 725     }
 726 
 727     template &lt;DecoratorSet decorators, typename T&gt;
 728     inline static typename EnableIf&lt;
 729       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 730     store_at(oop base, ptrdiff_t offset, T value) {
 731       store&lt;decorators&gt;(field_addr(base, offset), value);
 732     }
 733 
 734     template &lt;DecoratorSet decorators, typename T&gt;
 735     inline static typename EnableIf&lt;
 736       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 737     store_at(oop base, ptrdiff_t offset, T value) {
 738       if (is_hardwired_primitive&lt;decorators&gt;()) {
 739         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 740         PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, value);
 741       } else {
 742         RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at(base, offset, value);
 743       }
 744     }
 745 
 746     template &lt;DecoratorSet decorators, typename T&gt;
 747     inline static typename EnableIf&lt;
 748       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 749     load(void* addr) {
 750       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 751       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 752         return Raw::template oop_load&lt;T&gt;(addr);
 753       } else {
 754         return Raw::template load&lt;T&gt;(addr);
 755       }
 756     }
 757 
 758     template &lt;DecoratorSet decorators, typename T&gt;
 759     inline static typename EnableIf&lt;
 760       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 761     load(void* addr) {
 762       if (UseCompressedOops) {
 763         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 764         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 765       } else {
 766         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 767         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 768       }
 769     }
 770 
 771     template &lt;DecoratorSet decorators, typename T&gt;
 772     inline static typename EnableIf&lt;
 773       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 774     load(void* addr) {
 775       if (is_hardwired_primitive&lt;decorators&gt;()) {
 776         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 777         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 778       } else {
 779         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load(addr);
 780       }
 781     }
 782 
 783     template &lt;DecoratorSet decorators, typename T&gt;
 784     inline static typename EnableIf&lt;
 785       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 786     load_at(oop base, ptrdiff_t offset) {
 787       return load&lt;decorators, T&gt;(field_addr(base, offset));
 788     }
 789 
 790     template &lt;DecoratorSet decorators, typename T&gt;
 791     inline static typename EnableIf&lt;
 792       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 793     load_at(oop base, ptrdiff_t offset) {
 794       if (is_hardwired_primitive&lt;decorators&gt;()) {
 795         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 796         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 797       } else {
 798         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 799       }
 800     }
 801 
 802     template &lt;DecoratorSet decorators, typename T&gt;
 803     inline static typename EnableIf&lt;
 804       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="33" id="anc33"></a><span class="line-modified"> 805     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 806       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 807       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<a name="34" id="anc34"></a><span class="line-modified"> 808         return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
 809       } else {
<a name="35" id="anc35"></a><span class="line-modified"> 810         return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
 811       }
 812     }
 813 
 814     template &lt;DecoratorSet decorators, typename T&gt;
 815     inline static typename EnableIf&lt;
 816       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="36" id="anc36"></a><span class="line-modified"> 817     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 818       if (UseCompressedOops) {
 819         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<a name="37" id="anc37"></a><span class="line-modified"> 820         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 821       } else {
 822         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<a name="38" id="anc38"></a><span class="line-modified"> 823         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 824       }
 825     }
 826 
 827     template &lt;DecoratorSet decorators, typename T&gt;
 828     inline static typename EnableIf&lt;
 829       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="39" id="anc39"></a><span class="line-modified"> 830     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 831       if (is_hardwired_primitive&lt;decorators&gt;()) {
 832         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="40" id="anc40"></a><span class="line-modified"> 833         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 834       } else {
<a name="41" id="anc41"></a><span class="line-modified"> 835         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(new_value, addr, compare_value);</span>
 836       }
 837     }
 838 
 839     template &lt;DecoratorSet decorators, typename T&gt;
 840     inline static typename EnableIf&lt;
 841       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="42" id="anc42"></a><span class="line-modified"> 842     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 843       return atomic_cmpxchg&lt;decorators&gt;(new_value, field_addr(base, offset), compare_value);</span>
 844     }
 845 
 846     template &lt;DecoratorSet decorators, typename T&gt;
 847     inline static typename EnableIf&lt;
 848       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="43" id="anc43"></a><span class="line-modified"> 849     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
 850       if (is_hardwired_primitive&lt;decorators&gt;()) {
 851         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="44" id="anc44"></a><span class="line-modified"> 852         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(new_value, base, offset, compare_value);</span>
 853       } else {
<a name="45" id="anc45"></a><span class="line-modified"> 854         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
 855       }
 856     }
 857 
 858     template &lt;DecoratorSet decorators, typename T&gt;
 859     inline static typename EnableIf&lt;
 860       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="46" id="anc46"></a><span class="line-modified"> 861     atomic_xchg(T new_value, void* addr) {</span>
 862       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 863       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<a name="47" id="anc47"></a><span class="line-modified"> 864         return Raw::oop_atomic_xchg(new_value, addr);</span>
 865       } else {
<a name="48" id="anc48"></a><span class="line-modified"> 866         return Raw::atomic_xchg(new_value, addr);</span>
 867       }
 868     }
 869 
 870     template &lt;DecoratorSet decorators, typename T&gt;
 871     inline static typename EnableIf&lt;
 872       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="49" id="anc49"></a><span class="line-modified"> 873     atomic_xchg(T new_value, void* addr) {</span>
 874       if (UseCompressedOops) {
 875         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<a name="50" id="anc50"></a><span class="line-modified"> 876         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 877       } else {
 878         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<a name="51" id="anc51"></a><span class="line-modified"> 879         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 880       }
 881     }
 882 
 883     template &lt;DecoratorSet decorators, typename T&gt;
 884     inline static typename EnableIf&lt;
 885       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="52" id="anc52"></a><span class="line-modified"> 886     atomic_xchg(T new_value, void* addr) {</span>
 887       if (is_hardwired_primitive&lt;decorators&gt;()) {
 888         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="53" id="anc53"></a><span class="line-modified"> 889         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 890       } else {
<a name="54" id="anc54"></a><span class="line-modified"> 891         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(new_value, addr);</span>
 892       }
 893     }
 894 
 895     template &lt;DecoratorSet decorators, typename T&gt;
 896     inline static typename EnableIf&lt;
 897       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="55" id="anc55"></a><span class="line-modified"> 898     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 899       return atomic_xchg&lt;decorators&gt;(new_value, field_addr(base, offset));</span>
 900     }
 901 
 902     template &lt;DecoratorSet decorators, typename T&gt;
 903     inline static typename EnableIf&lt;
 904       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="56" id="anc56"></a><span class="line-modified"> 905     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
 906       if (is_hardwired_primitive&lt;decorators&gt;()) {
 907         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="57" id="anc57"></a><span class="line-modified"> 908         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, base, offset);</span>
 909       } else {
<a name="58" id="anc58"></a><span class="line-modified"> 910         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(new_value, base, offset);</span>
 911       }
 912     }
 913 
 914     template &lt;DecoratorSet decorators, typename T&gt;
 915     inline static typename EnableIf&lt;
 916       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 917     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 918               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 919               size_t length) {
 920       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 921       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 922         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,
 923                                   dst_obj, dst_offset_in_bytes, dst_raw,
 924                                   length);
 925       } else {
 926         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 927                               dst_obj, dst_offset_in_bytes, dst_raw,
 928                               length);
 929       }
 930     }
 931 
 932     template &lt;DecoratorSet decorators, typename T&gt;
 933     inline static typename EnableIf&lt;
 934       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 935     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 936               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 937               size_t length) {
 938       if (UseCompressedOops) {
 939         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 940         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 941                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 942                                                                   length);
 943       } else {
 944         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 945         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 946                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 947                                                                   length);
 948       }
 949     }
 950 
 951     template &lt;DecoratorSet decorators, typename T&gt;
 952     inline static typename EnableIf&lt;
 953       !HasDecorator&lt;decorators, AS_RAW&gt;::value, bool&gt;::type
 954     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 955               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 956               size_t length) {
 957       if (is_hardwired_primitive&lt;decorators&gt;()) {
 958         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 959         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 960                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 961                                                                   length);
 962       } else {
 963         return RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 964                                                                             dst_obj, dst_offset_in_bytes, dst_raw,
 965                                                                             length);
 966       }
 967     }
 968 
 969     template &lt;DecoratorSet decorators&gt;
 970     inline static typename EnableIf&lt;
 971       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 972     clone(oop src, oop dst, size_t size) {
 973       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 974       Raw::clone(src, dst, size);
 975     }
 976 
 977     template &lt;DecoratorSet decorators&gt;
 978     inline static typename EnableIf&lt;
 979       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 980     clone(oop src, oop dst, size_t size) {
 981       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 982     }
 983 
 984     template &lt;DecoratorSet decorators&gt;
 985     inline static typename EnableIf&lt;
 986       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 987     resolve(oop obj) {
 988       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 989       return Raw::resolve(obj);
 990     }
 991 
 992     template &lt;DecoratorSet decorators&gt;
 993     inline static typename EnableIf&lt;
 994       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 995     resolve(oop obj) {
 996       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 997     }
<a name="59" id="anc59"></a><span class="line-removed"> 998 </span>
<span class="line-removed"> 999     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1000     inline static typename EnableIf&lt;</span>
<span class="line-removed">1001       HasDecorator&lt;decorators, AS_RAW&gt;::value || HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">1002     equals(oop o1, oop o2) {</span>
<span class="line-removed">1003       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;</span>
<span class="line-removed">1004       return Raw::equals(o1, o2);</span>
<span class="line-removed">1005     }</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1008     inline static typename EnableIf&lt;</span>
<span class="line-removed">1009       !HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">1010     equals(oop o1, oop o2) {</span>
<span class="line-removed">1011       return RuntimeDispatch&lt;decorators, oop, BARRIER_EQUALS&gt;::equals(o1, o2);</span>
<span class="line-removed">1012     }</span>
1013   };
1014 
1015   // Step 2: Reduce types.
1016   // Enforce that for non-oop types, T and P have to be strictly the same.
1017   // P is the type of the address and T is the type of the values.
1018   // As for oop types, it is allow to send T in {narrowOop, oop} and
1019   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
1020   // the subsequent table. (columns are P, rows are T)
1021   // |           | HeapWord  |   oop   | narrowOop |
1022   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
1023   // | narrowOop |     x     |    x    |  hw-none  |
1024   //
1025   // x means not allowed
1026   // rt-comp means it must be checked at runtime whether the oop is compressed.
1027   // hw-none means it is statically known the oop will not be compressed.
1028   // hw-comp means it is statically known the oop will be compressed.
1029 
1030   template &lt;DecoratorSet decorators, typename T&gt;
1031   inline void store_reduce_types(T* addr, T value) {
1032     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
1033   }
1034 
1035   template &lt;DecoratorSet decorators&gt;
1036   inline void store_reduce_types(narrowOop* addr, oop value) {
1037     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1038                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1039     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1040   }
1041 
1042   template &lt;DecoratorSet decorators&gt;
1043   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
1044     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1045                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1046     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1047   }
1048 
1049   template &lt;DecoratorSet decorators&gt;
1050   inline void store_reduce_types(HeapWord* addr, oop value) {
1051     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1052     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1053   }
1054 
1055   template &lt;DecoratorSet decorators, typename T&gt;
<a name="60" id="anc60"></a><span class="line-modified">1056   inline T atomic_cmpxchg_reduce_types(T new_value, T* addr, T compare_value) {</span>
<span class="line-modified">1057     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(new_value, addr, compare_value);</span>
1058   }
1059 
1060   template &lt;DecoratorSet decorators&gt;
<a name="61" id="anc61"></a><span class="line-modified">1061   inline oop atomic_cmpxchg_reduce_types(oop new_value, narrowOop* addr, oop compare_value) {</span>
1062     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1063                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="62" id="anc62"></a><span class="line-modified">1064     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1065   }
1066 
1067   template &lt;DecoratorSet decorators&gt;
<a name="63" id="anc63"></a><span class="line-modified">1068   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop new_value, narrowOop* addr, narrowOop compare_value) {</span>
1069     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1070                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="64" id="anc64"></a><span class="line-modified">1071     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1072   }
1073 
1074   template &lt;DecoratorSet decorators&gt;
<a name="65" id="anc65"></a><span class="line-modified">1075   inline oop atomic_cmpxchg_reduce_types(oop new_value,</span>
<span class="line-modified">1076                                          HeapWord* addr,</span>
<span class="line-modified">1077                                          oop compare_value) {</span>
1078     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<a name="66" id="anc66"></a><span class="line-modified">1079     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1080   }
1081 
1082   template &lt;DecoratorSet decorators, typename T&gt;
<a name="67" id="anc67"></a><span class="line-modified">1083   inline T atomic_xchg_reduce_types(T new_value, T* addr) {</span>
1084     const DecoratorSet expanded_decorators = decorators;
<a name="68" id="anc68"></a><span class="line-modified">1085     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1086   }
1087 
1088   template &lt;DecoratorSet decorators&gt;
<a name="69" id="anc69"></a><span class="line-modified">1089   inline oop atomic_xchg_reduce_types(oop new_value, narrowOop* addr) {</span>
1090     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1091                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="70" id="anc70"></a><span class="line-modified">1092     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1093   }
1094 
1095   template &lt;DecoratorSet decorators&gt;
<a name="71" id="anc71"></a><span class="line-modified">1096   inline narrowOop atomic_xchg_reduce_types(narrowOop new_value, narrowOop* addr) {</span>
1097     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1098                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="72" id="anc72"></a><span class="line-modified">1099     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1100   }
1101 
1102   template &lt;DecoratorSet decorators&gt;
<a name="73" id="anc73"></a><span class="line-modified">1103   inline oop atomic_xchg_reduce_types(oop new_value, HeapWord* addr) {</span>
1104     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<a name="74" id="anc74"></a><span class="line-modified">1105     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1106   }
1107 
1108   template &lt;DecoratorSet decorators, typename T&gt;
1109   inline T load_reduce_types(T* addr) {
1110     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1111   }
1112 
1113   template &lt;DecoratorSet decorators, typename T&gt;
1114   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1115     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1116                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1117     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1118   }
1119 
1120   template &lt;DecoratorSet decorators, typename T&gt;
1121   inline oop load_reduce_types(HeapWord* addr) {
1122     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1123     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1124   }
1125 
1126   template &lt;DecoratorSet decorators, typename T&gt;
1127   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
1128                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1129                                      size_t length) {
1130     return PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1131                                                      dst_obj, dst_offset_in_bytes, dst_raw,
1132                                                      length);
1133   }
1134 
1135   template &lt;DecoratorSet decorators&gt;
1136   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,
1137                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1138                                      size_t length) {
1139     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1140     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1141                                                               dst_obj, dst_offset_in_bytes, dst_raw,
1142                                                               length);
1143   }
1144 
1145   template &lt;DecoratorSet decorators&gt;
1146   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,
1147                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1148                                      size_t length) {
1149     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1150                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1151     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1152                                                               dst_obj, dst_offset_in_bytes, dst_raw,
1153                                                               length);
1154   }
1155 
1156   // Step 1: Set default decorators. This step remembers if a type was volatile
1157   // and then sets the MO_VOLATILE decorator by default. Otherwise, a default
1158   // memory ordering is set for the access, and the implied decorator rules
1159   // are applied to select sensible defaults for decorators that have not been
1160   // explicitly set. For example, default object referent strength is set to strong.
1161   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1162   // and references from the types). This step also perform some type verification
1163   // that the passed in types make sense.
1164 
1165   template &lt;DecoratorSet decorators, typename T&gt;
1166   static void verify_types(){
1167     // If this fails to compile, then you have sent in something that is
1168     // not recognized as a valid primitive type to a primitive Access function.
1169     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1170                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1171                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1172   }
1173 
1174   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1175   inline void store(P* addr, T value) {
1176     verify_types&lt;decorators, T&gt;();
1177     typedef typename Decay&lt;P&gt;::type DecayedP;
1178     typedef typename Decay&lt;T&gt;::type DecayedT;
1179     DecayedT decayed_value = value;
1180     // If a volatile address is passed in but no memory ordering decorator,
1181     // set the memory ordering to MO_VOLATILE by default.
1182     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1183       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1184       (MO_VOLATILE | decorators) : decorators&gt;::value;
1185     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1186   }
1187 
1188   template &lt;DecoratorSet decorators, typename T&gt;
1189   inline void store_at(oop base, ptrdiff_t offset, T value) {
1190     verify_types&lt;decorators, T&gt;();
1191     typedef typename Decay&lt;T&gt;::type DecayedT;
1192     DecayedT decayed_value = value;
1193     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1194                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1195                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1196     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1197   }
1198 
1199   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1200   inline T load(P* addr) {
1201     verify_types&lt;decorators, T&gt;();
1202     typedef typename Decay&lt;P&gt;::type DecayedP;
1203     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1204                                  typename OopOrNarrowOop&lt;T&gt;::type,
1205                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1206     // If a volatile address is passed in but no memory ordering decorator,
1207     // set the memory ordering to MO_VOLATILE by default.
1208     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1209       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1210       (MO_VOLATILE | decorators) : decorators&gt;::value;
1211     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1212   }
1213 
1214   template &lt;DecoratorSet decorators, typename T&gt;
1215   inline T load_at(oop base, ptrdiff_t offset) {
1216     verify_types&lt;decorators, T&gt;();
1217     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1218                                  typename OopOrNarrowOop&lt;T&gt;::type,
1219                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1220     // Expand the decorators (figure out sensible defaults)
1221     // Potentially remember if we need compressed oop awareness
1222     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1223                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1224                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1225     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1226   }
1227 
1228   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<a name="75" id="anc75"></a><span class="line-modified">1229   inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
1230     verify_types&lt;decorators, T&gt;();
1231     typedef typename Decay&lt;P&gt;::type DecayedP;
1232     typedef typename Decay&lt;T&gt;::type DecayedT;
1233     DecayedT new_decayed_value = new_value;
1234     DecayedT compare_decayed_value = compare_value;
1235     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1236       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1237       (MO_SEQ_CST | decorators) : decorators&gt;::value;
<a name="76" id="anc76"></a><span class="line-modified">1238     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">1239                                                             const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1240                                                             compare_decayed_value);</span>
1241   }
1242 
1243   template &lt;DecoratorSet decorators, typename T&gt;
<a name="77" id="anc77"></a><span class="line-modified">1244   inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
1245     verify_types&lt;decorators, T&gt;();
1246     typedef typename Decay&lt;T&gt;::type DecayedT;
1247     DecayedT new_decayed_value = new_value;
1248     DecayedT compare_decayed_value = compare_value;
1249     // Determine default memory ordering
1250     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1251       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1252       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1253     // Potentially remember that we need compressed oop awareness
1254     const DecoratorSet final_decorators = expanded_decorators |
1255                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1256                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<a name="78" id="anc78"></a><span class="line-modified">1257     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(new_decayed_value, base,</span>
<span class="line-modified">1258                                                                    offset, compare_decayed_value);</span>
1259   }
1260 
1261   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<a name="79" id="anc79"></a><span class="line-modified">1262   inline T atomic_xchg(T new_value, P* addr) {</span>
1263     verify_types&lt;decorators, T&gt;();
1264     typedef typename Decay&lt;P&gt;::type DecayedP;
1265     typedef typename Decay&lt;T&gt;::type DecayedT;
1266     DecayedT new_decayed_value = new_value;
1267     // atomic_xchg is only available in SEQ_CST flavour.
1268     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<a name="80" id="anc80"></a><span class="line-modified">1269     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">1270                                                          const_cast&lt;DecayedP*&gt;(addr));</span>
1271   }
1272 
1273   template &lt;DecoratorSet decorators, typename T&gt;
<a name="81" id="anc81"></a><span class="line-modified">1274   inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
1275     verify_types&lt;decorators, T&gt;();
1276     typedef typename Decay&lt;T&gt;::type DecayedT;
1277     DecayedT new_decayed_value = new_value;
1278     // atomic_xchg is only available in SEQ_CST flavour.
1279     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1280                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1281                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<a name="82" id="anc82"></a><span class="line-modified">1282     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(new_decayed_value, base, offset);</span>
1283   }
1284 
1285   template &lt;DecoratorSet decorators, typename T&gt;
1286   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
1287                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1288                         size_t length) {
1289     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1290                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1291                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1292     typedef typename Decay&lt;T&gt;::type DecayedT;
1293     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
1294     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),
1295                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),
1296                                                        length);
1297   }
1298 
1299   template &lt;DecoratorSet decorators&gt;
1300   inline void clone(oop src, oop dst, size_t size) {
1301     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1302     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1303   }
1304 
1305   template &lt;DecoratorSet decorators&gt;
1306   inline oop resolve(oop obj) {
1307     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1308     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1309   }
1310 
<a name="83" id="anc83"></a><span class="line-removed">1311   template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1312   inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed">1313     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;</span>
<span class="line-removed">1314     return PreRuntimeDispatch::equals&lt;expanded_decorators&gt;(o1, o2);</span>
<span class="line-removed">1315   }</span>
<span class="line-removed">1316 </span>
1317   // Infer the type that should be returned from an Access::oop_load.
1318   template &lt;typename P, DecoratorSet decorators&gt;
1319   class OopLoadProxy: public StackObj {
1320   private:
1321     P *const _addr;
1322   public:
1323     OopLoadProxy(P* addr) : _addr(addr) {}
1324 
1325     inline operator oop() {
1326       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1327     }
1328 
1329     inline operator narrowOop() {
1330       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1331     }
1332 
1333     template &lt;typename T&gt;
1334     inline bool operator ==(const T&amp; other) const {
1335       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1336     }
1337 
1338     template &lt;typename T&gt;
1339     inline bool operator !=(const T&amp; other) const {
1340       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) != other;
1341     }
1342   };
1343 
1344   // Infer the type that should be returned from an Access::load_at.
1345   template &lt;DecoratorSet decorators&gt;
1346   class LoadAtProxy: public StackObj {
1347   private:
1348     const oop _base;
1349     const ptrdiff_t _offset;
1350   public:
1351     LoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1352 
1353     template &lt;typename T&gt;
1354     inline operator T() const {
1355       return load_at&lt;decorators, T&gt;(_base, _offset);
1356     }
1357 
1358     template &lt;typename T&gt;
1359     inline bool operator ==(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) == other; }
1360 
1361     template &lt;typename T&gt;
1362     inline bool operator !=(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) != other; }
1363   };
1364 
1365   // Infer the type that should be returned from an Access::oop_load_at.
1366   template &lt;DecoratorSet decorators&gt;
1367   class OopLoadAtProxy: public StackObj {
1368   private:
1369     const oop _base;
1370     const ptrdiff_t _offset;
1371   public:
1372     OopLoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1373 
1374     inline operator oop() const {
1375       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, oop&gt;(_base, _offset);
1376     }
1377 
1378     inline operator narrowOop() const {
1379       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, narrowOop&gt;(_base, _offset);
1380     }
1381 
1382     template &lt;typename T&gt;
1383     inline bool operator ==(const T&amp; other) const {
1384       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) == other;
1385     }
1386 
1387     template &lt;typename T&gt;
1388     inline bool operator !=(const T&amp; other) const {
1389       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) != other;
1390     }
1391   };
1392 }
1393 
1394 #endif // SHARE_OOPS_ACCESSBACKEND_HPP
<a name="84" id="anc84"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="84" type="hidden" />
</body>
</html>
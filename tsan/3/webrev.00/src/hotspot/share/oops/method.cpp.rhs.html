<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/metadataOnStackMark.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  28 #include &quot;classfile/symbolTable.hpp&quot;</span>
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;code/debugInfoRec.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  32 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  33 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  34 #include &quot;interpreter/bytecodeStream.hpp&quot;
  35 #include &quot;interpreter/bytecodeTracer.hpp&quot;
  36 #include &quot;interpreter/bytecodes.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  39 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  40 #include &quot;logging/logTag.hpp&quot;</span>
  41 #include &quot;memory/allocation.inline.hpp&quot;
<a name="5" id="anc5"></a>
  42 #include &quot;memory/metadataFactory.hpp&quot;
  43 #include &quot;memory/metaspaceClosure.hpp&quot;
  44 #include &quot;memory/metaspaceShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/resourceArea.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added">  47 #include &quot;memory/universe.hpp&quot;</span>
  48 #include &quot;oops/constMethod.hpp&quot;
  49 #include &quot;oops/constantPool.hpp&quot;
  50 #include &quot;oops/method.inline.hpp&quot;
  51 #include &quot;oops/methodData.hpp&quot;
<a name="7" id="anc7"></a><span class="line-added">  52 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  53 #include &quot;oops/objArrayOop.inline.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;oops/symbol.hpp&quot;
  56 #include &quot;prims/jvmtiExport.hpp&quot;
  57 #include &quot;prims/methodHandles.hpp&quot;
  58 #include &quot;prims/nativeLookup.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
<a name="8" id="anc8"></a><span class="line-modified">  60 #include &quot;runtime/atomic.hpp&quot;</span>
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/init.hpp&quot;
  64 #include &quot;runtime/orderAccess.hpp&quot;
  65 #include &quot;runtime/relocator.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/sharedRuntime.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;utilities/align.hpp&quot;
  70 #include &quot;utilities/quickSort.hpp&quot;
  71 #include &quot;utilities/vmError.hpp&quot;
  72 #include &quot;utilities/xmlstream.hpp&quot;
  73 
  74 // Implementation of Method
  75 
  76 Method* Method::allocate(ClassLoaderData* loader_data,
  77                          int byte_code_size,
  78                          AccessFlags access_flags,
  79                          InlineTableSizes* sizes,
  80                          ConstMethod::MethodType method_type,
  81                          TRAPS) {
  82   assert(!access_flags.is_native() || byte_code_size == 0,
  83          &quot;native methods should not contain byte codes&quot;);
  84   ConstMethod* cm = ConstMethod::allocate(loader_data,
  85                                           byte_code_size,
  86                                           sizes,
  87                                           method_type,
  88                                           CHECK_NULL);
  89   int size = Method::size(access_flags.is_native());
  90   return new (loader_data, size, MetaspaceObj::MethodType, THREAD) Method(cm, access_flags);
  91 }
  92 
  93 Method::Method(ConstMethod* xconst, AccessFlags access_flags) {
  94   NoSafepointVerifier no_safepoint;
  95   set_constMethod(xconst);
  96   set_access_flags(access_flags);
  97   set_intrinsic_id(vmIntrinsics::_none);
  98   set_force_inline(false);
  99   set_hidden(false);
 100   set_dont_inline(false);
 101   set_has_injected_profile(false);
 102   set_method_data(NULL);
 103   clear_method_counters();
 104   set_vtable_index(Method::garbage_vtable_index);
 105 
 106   // Fix and bury in Method*
 107   set_interpreter_entry(NULL); // sets i2i entry and from_int
 108   set_adapter_entry(NULL);
<a name="9" id="anc9"></a><span class="line-modified"> 109   Method::clear_code(); // from_c/from_i get set to c2i/i2i</span>
 110 
 111   if (access_flags.is_native()) {
 112     clear_native_function();
 113     set_signature_handler(NULL);
 114   }
 115 
 116   NOT_PRODUCT(set_compiled_invocation_count(0);)
 117 }
 118 
 119 // Release Method*.  The nmethod will be gone when we get here because
 120 // we&#39;ve walked the code cache.
 121 void Method::deallocate_contents(ClassLoaderData* loader_data) {
 122   MetadataFactory::free_metadata(loader_data, constMethod());
 123   set_constMethod(NULL);
 124   MetadataFactory::free_metadata(loader_data, method_data());
 125   set_method_data(NULL);
 126   MetadataFactory::free_metadata(loader_data, method_counters());
 127   clear_method_counters();
 128   // The nmethod will be gone when we get here.
 129   if (code() != NULL) _code = NULL;
 130 }
 131 
<a name="10" id="anc10"></a><span class="line-added"> 132 void Method::release_C_heap_structures() {</span>
<span class="line-added"> 133   if (method_data()) {</span>
<span class="line-added"> 134 #if INCLUDE_JVMCI</span>
<span class="line-added"> 135     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());</span>
<span class="line-added"> 136 #endif</span>
<span class="line-added"> 137     // Destroy MethodData</span>
<span class="line-added"> 138     method_data()-&gt;~MethodData();</span>
<span class="line-added"> 139   }</span>
<span class="line-added"> 140 }</span>
<span class="line-added"> 141 </span>
 142 address Method::get_i2c_entry() {
 143   assert(adapter() != NULL, &quot;must have&quot;);
 144   return adapter()-&gt;get_i2c_entry();
 145 }
 146 
 147 address Method::get_c2i_entry() {
 148   assert(adapter() != NULL, &quot;must have&quot;);
 149   return adapter()-&gt;get_c2i_entry();
 150 }
 151 
 152 address Method::get_c2i_unverified_entry() {
 153   assert(adapter() != NULL, &quot;must have&quot;);
 154   return adapter()-&gt;get_c2i_unverified_entry();
 155 }
 156 
<a name="11" id="anc11"></a><span class="line-added"> 157 address Method::get_c2i_no_clinit_check_entry() {</span>
<span class="line-added"> 158   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);</span>
<span class="line-added"> 159   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added"> 160   return adapter()-&gt;get_c2i_no_clinit_check_entry();</span>
<span class="line-added"> 161 }</span>
<span class="line-added"> 162 </span>
 163 char* Method::name_and_sig_as_C_string() const {
 164   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
 165 }
 166 
 167 char* Method::name_and_sig_as_C_string(char* buf, int size) const {
 168   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature(), buf, size);
 169 }
 170 
 171 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature) {
 172   const char* klass_name = klass-&gt;external_name();
 173   int klass_name_len  = (int)strlen(klass_name);
 174   int method_name_len = method_name-&gt;utf8_length();
 175   int len             = klass_name_len + 1 + method_name_len + signature-&gt;utf8_length();
 176   char* dest          = NEW_RESOURCE_ARRAY(char, len + 1);
 177   strcpy(dest, klass_name);
 178   dest[klass_name_len] = &#39;.&#39;;
 179   strcpy(&amp;dest[klass_name_len + 1], method_name-&gt;as_C_string());
 180   strcpy(&amp;dest[klass_name_len + 1 + method_name_len], signature-&gt;as_C_string());
 181   dest[len] = 0;
 182   return dest;
 183 }
 184 
 185 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature, char* buf, int size) {
 186   Symbol* klass_name = klass-&gt;name();
 187   klass_name-&gt;as_klass_external_name(buf, size);
 188   int len = (int)strlen(buf);
 189 
 190   if (len &lt; size - 1) {
 191     buf[len++] = &#39;.&#39;;
 192 
 193     method_name-&gt;as_C_string(&amp;(buf[len]), size - len);
 194     len = (int)strlen(buf);
 195 
 196     signature-&gt;as_C_string(&amp;(buf[len]), size - len);
 197   }
 198 
 199   return buf;
 200 }
 201 
<a name="12" id="anc12"></a><span class="line-added"> 202 const char* Method::external_name() const {</span>
<span class="line-added"> 203   return external_name(constants()-&gt;pool_holder(), name(), signature());</span>
<span class="line-added"> 204 }</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206 void Method::print_external_name(outputStream *os) const {</span>
<span class="line-added"> 207   print_external_name(os, constants()-&gt;pool_holder(), name(), signature());</span>
<span class="line-added"> 208 }</span>
<span class="line-added"> 209 </span>
<span class="line-added"> 210 const char* Method::external_name(Klass* klass, Symbol* method_name, Symbol* signature) {</span>
<span class="line-added"> 211   stringStream ss;</span>
<span class="line-added"> 212   print_external_name(&amp;ss, klass, method_name, signature);</span>
<span class="line-added"> 213   return ss.as_string();</span>
<span class="line-added"> 214 }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216 void Method::print_external_name(outputStream *os, Klass* klass, Symbol* method_name, Symbol* signature) {</span>
<span class="line-added"> 217   signature-&gt;print_as_signature_external_return_type(os);</span>
<span class="line-added"> 218   os-&gt;print(&quot; %s.%s(&quot;, klass-&gt;external_name(), method_name-&gt;as_C_string());</span>
<span class="line-added"> 219   signature-&gt;print_as_signature_external_parameters(os);</span>
<span class="line-added"> 220   os-&gt;print(&quot;)&quot;);</span>
<span class="line-added"> 221 }</span>
<span class="line-added"> 222 </span>
 223 int Method::fast_exception_handler_bci_for(const methodHandle&amp; mh, Klass* ex_klass, int throw_bci, TRAPS) {
 224   // exception table holds quadruple entries of the form (beg_bci, end_bci, handler_bci, klass_index)
 225   // access exception table
 226   ExceptionTable table(mh());
 227   int length = table.length();
 228   // iterate through all entries sequentially
 229   constantPoolHandle pool(THREAD, mh-&gt;constants());
 230   for (int i = 0; i &lt; length; i ++) {
 231     //reacquire the table in case a GC happened
 232     ExceptionTable table(mh());
 233     int beg_bci = table.start_pc(i);
 234     int end_bci = table.end_pc(i);
 235     assert(beg_bci &lt;= end_bci, &quot;inconsistent exception table&quot;);
 236     if (beg_bci &lt;= throw_bci &amp;&amp; throw_bci &lt; end_bci) {
 237       // exception handler bci range covers throw_bci =&gt; investigate further
 238       int handler_bci = table.handler_pc(i);
 239       int klass_index = table.catch_type_index(i);
 240       if (klass_index == 0) {
 241         return handler_bci;
 242       } else if (ex_klass == NULL) {
 243         return handler_bci;
 244       } else {
 245         // we know the exception class =&gt; get the constraint class
 246         // this may require loading of the constraint class; if verification
 247         // fails or some other exception occurs, return handler_bci
 248         Klass* k = pool-&gt;klass_at(klass_index, CHECK_(handler_bci));
 249         assert(k != NULL, &quot;klass not loaded&quot;);
 250         if (ex_klass-&gt;is_subtype_of(k)) {
 251           return handler_bci;
 252         }
 253       }
 254     }
 255   }
 256 
 257   return -1;
 258 }
 259 
 260 void Method::mask_for(int bci, InterpreterOopMap* mask) {
 261   methodHandle h_this(Thread::current(), this);
 262   // Only GC uses the OopMapCache during thread stack root scanning
 263   // any other uses generate an oopmap but do not save it in the cache.
 264   if (Universe::heap()-&gt;is_gc_active()) {
 265     method_holder()-&gt;mask_for(h_this, bci, mask);
 266   } else {
 267     OopMapCache::compute_one_oop_map(h_this, bci, mask);
 268   }
 269   return;
 270 }
 271 
 272 
 273 int Method::bci_from(address bcp) const {
 274   if (is_native() &amp;&amp; bcp == 0) {
 275     return 0;
 276   }
 277 #ifdef ASSERT
 278   {
 279     ResourceMark rm;
 280     assert(is_native() &amp;&amp; bcp == code_base() || contains(bcp) || VMError::is_error_reported(),
 281            &quot;bcp doesn&#39;t belong to this method: bcp: &quot; INTPTR_FORMAT &quot;, method: %s&quot;,
 282            p2i(bcp), name_and_sig_as_C_string());
 283   }
 284 #endif
 285   return bcp - code_base();
 286 }
 287 
 288 
 289 int Method::validate_bci(int bci) const {
 290   return (bci == 0 || bci &lt; code_size()) ? bci : -1;
 291 }
 292 
 293 // Return bci if it appears to be a valid bcp
 294 // Return -1 otherwise.
 295 // Used by profiling code, when invalid data is a possibility.
 296 // The caller is responsible for validating the Method* itself.
 297 int Method::validate_bci_from_bcp(address bcp) const {
 298   // keep bci as -1 if not a valid bci
 299   int bci = -1;
 300   if (bcp == 0 || bcp == code_base()) {
 301     // code_size() may return 0 and we allow 0 here
 302     // the method may be native
 303     bci = 0;
 304   } else if (contains(bcp)) {
 305     bci = bcp - code_base();
 306   }
 307   // Assert that if we have dodged any asserts, bci is negative.
 308   assert(bci == -1 || bci == bci_from(bcp_from(bci)), &quot;sane bci if &gt;=0&quot;);
 309   return bci;
 310 }
 311 
 312 address Method::bcp_from(int bci) const {
 313   assert((is_native() &amp;&amp; bci == 0) || (!is_native() &amp;&amp; 0 &lt;= bci &amp;&amp; bci &lt; code_size()),
 314          &quot;illegal bci: %d for %s method&quot;, bci, is_native() ? &quot;native&quot; : &quot;non-native&quot;);
 315   address bcp = code_base() + bci;
 316   assert(is_native() &amp;&amp; bcp == code_base() || contains(bcp), &quot;bcp doesn&#39;t belong to this method&quot;);
 317   return bcp;
 318 }
 319 
 320 address Method::bcp_from(address bcp) const {
 321   if (is_native() &amp;&amp; bcp == NULL) {
 322     return code_base();
 323   } else {
 324     return bcp;
 325   }
 326 }
 327 
 328 int Method::size(bool is_native) {
 329   // If native, then include pointers for native_function and signature_handler
 330   int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
 331   int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
 332   return align_metadata_size(header_size() + extra_words);
 333 }
 334 
<a name="13" id="anc13"></a>
 335 Symbol* Method::klass_name() const {
 336   return method_holder()-&gt;name();
 337 }
 338 
<a name="14" id="anc14"></a>
 339 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 340   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 341 
 342   it-&gt;push(&amp;_constMethod);
 343   it-&gt;push(&amp;_method_data);
 344   it-&gt;push(&amp;_method_counters);
<a name="15" id="anc15"></a><span class="line-added"> 345 </span>
<span class="line-added"> 346   Method* this_ptr = this;</span>
<span class="line-added"> 347   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);</span>
<span class="line-added"> 348   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);</span>
<span class="line-added"> 349   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);</span>
 350 }
 351 
 352 // Attempt to return method oop to original state.  Clear any pointers
 353 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 354 // where they should point in a new JVM.  Further initialize some
 355 // entries now in order allow them to be write protected later.
 356 
 357 void Method::remove_unshareable_info() {
 358   unlink_method();
 359 }
 360 
 361 void Method::set_vtable_index(int index) {
 362   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 363     // At runtime initialize_vtable is rerun as part of link_class_impl()
 364     // for a shared class loaded by the non-boot loader to obtain the loader
 365     // constraints based on the runtime classloaders&#39; context.
 366     return; // don&#39;t write into the shared class
 367   } else {
 368     _vtable_index = index;
 369   }
 370 }
 371 
 372 void Method::set_itable_index(int index) {
 373   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 374     // At runtime initialize_itable is rerun as part of link_class_impl()
 375     // for a shared class loaded by the non-boot loader to obtain the loader
 376     // constraints based on the runtime classloaders&#39; context. The dumptime
 377     // itable index should be the same as the runtime index.
 378     assert(_vtable_index == itable_index_max - index,
 379            &quot;archived itable index is different from runtime index&quot;);
 380     return; // don’t write into the shared class
 381   } else {
 382     _vtable_index = itable_index_max - index;
 383   }
 384   assert(valid_itable_index(), &quot;&quot;);
 385 }
 386 
<a name="16" id="anc16"></a><span class="line-added"> 387 // The RegisterNatives call being attempted tried to register with a method that</span>
<span class="line-added"> 388 // is not native.  Ask JVM TI what prefixes have been specified.  Then check</span>
<span class="line-added"> 389 // to see if the native method is now wrapped with the prefixes.  See the</span>
<span class="line-added"> 390 // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.</span>
<span class="line-added"> 391 static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {</span>
<span class="line-added"> 392 #if INCLUDE_JVMTI</span>
<span class="line-added"> 393   ResourceMark rm(THREAD);</span>
<span class="line-added"> 394   Method* method;</span>
<span class="line-added"> 395   int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 396   char* name_str = name-&gt;as_utf8();</span>
<span class="line-added"> 397   int prefix_count;</span>
<span class="line-added"> 398   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);</span>
<span class="line-added"> 399   for (int i = 0; i &lt; prefix_count; i++) {</span>
<span class="line-added"> 400     char* prefix = prefixes[i];</span>
<span class="line-added"> 401     int prefix_len = (int)strlen(prefix);</span>
<span class="line-added"> 402 </span>
<span class="line-added"> 403     // try adding this prefix to the method name and see if it matches another method name</span>
<span class="line-added"> 404     int trial_len = name_len + prefix_len;</span>
<span class="line-added"> 405     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);</span>
<span class="line-added"> 406     strcpy(trial_name_str, prefix);</span>
<span class="line-added"> 407     strcat(trial_name_str, name_str);</span>
<span class="line-added"> 408     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);</span>
<span class="line-added"> 409     if (trial_name == NULL) {</span>
<span class="line-added"> 410       continue; // no such symbol, so this prefix wasn&#39;t used, try the next prefix</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412     method = k-&gt;lookup_method(trial_name, signature);</span>
<span class="line-added"> 413     if (method == NULL) {</span>
<span class="line-added"> 414       continue; // signature doesn&#39;t match, try the next prefix</span>
<span class="line-added"> 415     }</span>
<span class="line-added"> 416     if (method-&gt;is_native()) {</span>
<span class="line-added"> 417       method-&gt;set_is_prefixed_native();</span>
<span class="line-added"> 418       return method; // wahoo, we found a prefixed version of the method, return it</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420     // found as non-native, so prefix is good, add it, probably just need more prefixes</span>
<span class="line-added"> 421     name_len = trial_len;</span>
<span class="line-added"> 422     name_str = trial_name_str;</span>
<span class="line-added"> 423   }</span>
<span class="line-added"> 424 #endif // INCLUDE_JVMTI</span>
<span class="line-added"> 425   return NULL; // not found</span>
<span class="line-added"> 426 }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428 bool Method::register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {</span>
<span class="line-added"> 429   Method* method = k-&gt;lookup_method(name, signature);</span>
<span class="line-added"> 430   if (method == NULL) {</span>
<span class="line-added"> 431     ResourceMark rm(THREAD);</span>
<span class="line-added"> 432     stringStream st;</span>
<span class="line-added"> 433     st.print(&quot;Method &#39;&quot;);</span>
<span class="line-added"> 434     print_external_name(&amp;st, k, name, signature);</span>
<span class="line-added"> 435     st.print(&quot;&#39; name or signature does not match&quot;);</span>
<span class="line-added"> 436     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-added"> 437   }</span>
<span class="line-added"> 438   if (!method-&gt;is_native()) {</span>
<span class="line-added"> 439     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)</span>
<span class="line-added"> 440     method = find_prefixed_native(k, name, signature, THREAD);</span>
<span class="line-added"> 441     if (method == NULL) {</span>
<span class="line-added"> 442       ResourceMark rm(THREAD);</span>
<span class="line-added"> 443       stringStream st;</span>
<span class="line-added"> 444       st.print(&quot;Method &#39;&quot;);</span>
<span class="line-added"> 445       print_external_name(&amp;st, k, name, signature);</span>
<span class="line-added"> 446       st.print(&quot;&#39; is not declared as native&quot;);</span>
<span class="line-added"> 447       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-added"> 448     }</span>
<span class="line-added"> 449   }</span>
 450 
<a name="17" id="anc17"></a><span class="line-added"> 451   if (entry != NULL) {</span>
<span class="line-added"> 452     method-&gt;set_native_function(entry, native_bind_event_is_interesting);</span>
<span class="line-added"> 453   } else {</span>
<span class="line-added"> 454     method-&gt;clear_native_function();</span>
<span class="line-added"> 455   }</span>
<span class="line-added"> 456   if (log_is_enabled(Debug, jni, resolve)) {</span>
<span class="line-added"> 457     ResourceMark rm(THREAD);</span>
<span class="line-added"> 458     log_debug(jni, resolve)(&quot;[Registering JNI native method %s.%s]&quot;,</span>
<span class="line-added"> 459                             method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added"> 460                             method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462   return true;</span>
<span class="line-added"> 463 }</span>
 464 
 465 bool Method::was_executed_more_than(int n) {
 466   // Invocation counter is reset when the Method* is compiled.
 467   // If the method has compiled code we therefore assume it has
 468   // be excuted more than n times.
 469   if (is_accessor() || is_empty_method() || (code() != NULL)) {
 470     // interpreter doesn&#39;t bump invocation counter of trivial methods
 471     // compiler does not bump invocation counter of compiled methods
 472     return true;
 473   }
 474   else if ((method_counters() != NULL &amp;&amp;
 475             method_counters()-&gt;invocation_counter()-&gt;carry()) ||
 476            (method_data() != NULL &amp;&amp;
 477             method_data()-&gt;invocation_counter()-&gt;carry())) {
 478     // The carry bit is set when the counter overflows and causes
 479     // a compilation to occur.  We don&#39;t know how many times
 480     // the counter has been reset, so we simply assume it has
 481     // been executed more than n times.
 482     return true;
 483   } else {
 484     return invocation_count() &gt; n;
 485   }
 486 }
 487 
 488 void Method::print_invocation_count() {
 489   if (is_static()) tty-&gt;print(&quot;static &quot;);
 490   if (is_final()) tty-&gt;print(&quot;final &quot;);
 491   if (is_synchronized()) tty-&gt;print(&quot;synchronized &quot;);
 492   if (is_native()) tty-&gt;print(&quot;native &quot;);
 493   tty-&gt;print(&quot;%s::&quot;, method_holder()-&gt;external_name());
 494   name()-&gt;print_symbol_on(tty);
 495   signature()-&gt;print_symbol_on(tty);
 496 
 497   if (WizardMode) {
 498     // dump the size of the byte codes
 499     tty-&gt;print(&quot; {%d}&quot;, code_size());
 500   }
 501   tty-&gt;cr();
 502 
 503   tty-&gt;print_cr (&quot;  interpreter_invocation_count: %8d &quot;, interpreter_invocation_count());
 504   tty-&gt;print_cr (&quot;  invocation_counter:           %8d &quot;, invocation_count());
 505   tty-&gt;print_cr (&quot;  backedge_counter:             %8d &quot;, backedge_count());
 506 #ifndef PRODUCT
 507   if (CountCompiledCalls) {
 508     tty-&gt;print_cr (&quot;  compiled_invocation_count: %8d &quot;, compiled_invocation_count());
 509   }
 510 #endif
 511 }
 512 
 513 // Build a MethodData* object to hold information about this method
 514 // collected in the interpreter.
 515 void Method::build_interpreter_method_data(const methodHandle&amp; method, TRAPS) {
 516   // Do not profile the method if metaspace has hit an OOM previously
 517   // allocating profiling data. Callers clear pending exception so don&#39;t
 518   // add one here.
 519   if (ClassLoaderDataGraph::has_metaspace_oom()) {
 520     return;
 521   }
 522 
 523   // Grab a lock here to prevent multiple
 524   // MethodData*s from being created.
<a name="18" id="anc18"></a><span class="line-modified"> 525   MutexLocker ml(THREAD, MethodData_lock);</span>
 526   if (method-&gt;method_data() == NULL) {
 527     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 528     MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);
 529     if (HAS_PENDING_EXCEPTION) {
 530       CompileBroker::log_metaspace_failure();
 531       ClassLoaderDataGraph::set_metaspace_oom(true);
 532       return;   // return the exception (which is cleared)
 533     }
 534 
 535     method-&gt;set_method_data(method_data);
 536     if (PrintMethodData &amp;&amp; (Verbose || WizardMode)) {
 537       ResourceMark rm(THREAD);
 538       tty-&gt;print(&quot;build_interpreter_method_data for &quot;);
 539       method-&gt;print_name(tty);
 540       tty-&gt;cr();
 541       // At the end of the run, the MDO, full of data, will be dumped.
 542     }
 543   }
 544 }
 545 
 546 MethodCounters* Method::build_method_counters(Method* m, TRAPS) {
 547   // Do not profile the method if metaspace has hit an OOM previously
 548   if (ClassLoaderDataGraph::has_metaspace_oom()) {
 549     return NULL;
 550   }
 551 
<a name="19" id="anc19"></a><span class="line-modified"> 552   methodHandle mh(THREAD, m);</span>
 553   MethodCounters* counters = MethodCounters::allocate(mh, THREAD);
 554   if (HAS_PENDING_EXCEPTION) {
 555     CompileBroker::log_metaspace_failure();
 556     ClassLoaderDataGraph::set_metaspace_oom(true);
 557     return NULL;   // return the exception (which is cleared)
 558   }
 559   if (!mh-&gt;init_method_counters(counters)) {
 560     MetadataFactory::free_metadata(mh-&gt;method_holder()-&gt;class_loader_data(), counters);
 561   }
 562 
 563   if (LogTouchedMethods) {
 564     mh-&gt;log_touched(CHECK_NULL);
 565   }
 566 
 567   return mh-&gt;method_counters();
 568 }
 569 
 570 bool Method::init_method_counters(MethodCounters* counters) {
 571   // Try to install a pointer to MethodCounters, return true on success.
<a name="20" id="anc20"></a><span class="line-modified"> 572   return Atomic::replace_if_null(&amp;_method_counters, counters);</span>
 573 }
 574 
 575 int Method::extra_stack_words() {
 576   // not an inline function, to avoid a header dependency on Interpreter
 577   return extra_stack_entries() * Interpreter::stackElementSize;
 578 }
 579 
<a name="21" id="anc21"></a><span class="line-modified"> 580 // Derive size of parameters, return type, and fingerprint,</span>
<span class="line-modified"> 581 // all in one pass, which is run at load time.</span>
<span class="line-modified"> 582 // We need the first two, and might as well grab the third.</span>
<span class="line-modified"> 583 void Method::compute_from_signature(Symbol* sig) {</span>
<span class="line-added"> 584   // At this point, since we are scanning the signature,</span>
<span class="line-added"> 585   // we might as well compute the whole fingerprint.</span>
<span class="line-added"> 586   Fingerprinter fp(sig, is_static());</span>
<span class="line-added"> 587   set_size_of_parameters(fp.size_of_parameters());</span>
<span class="line-added"> 588   constMethod()-&gt;set_result_type(fp.return_type());</span>
<span class="line-added"> 589   constMethod()-&gt;set_fingerprint(fp.fingerprint());</span>
 590 }
 591 
<a name="22" id="anc22"></a>





 592 bool Method::is_empty_method() const {
 593   return  code_size() == 1
 594       &amp;&amp; *code_base() == Bytecodes::_return;
 595 }
 596 
<a name="23" id="anc23"></a>
 597 bool Method::is_vanilla_constructor() const {
 598   // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
 599   // which only calls the superclass vanilla constructor and possibly does stores of
 600   // zero constants to local fields:
 601   //
 602   //   aload_0
 603   //   invokespecial
 604   //   indexbyte1
 605   //   indexbyte2
 606   //
 607   // followed by an (optional) sequence of:
 608   //
 609   //   aload_0
 610   //   aconst_null / iconst_0 / fconst_0 / dconst_0
 611   //   putfield
 612   //   indexbyte1
 613   //   indexbyte2
 614   //
 615   // followed by:
 616   //
 617   //   return
 618 
 619   assert(name() == vmSymbols::object_initializer_name(),    &quot;Should only be called for default constructors&quot;);
 620   assert(signature() == vmSymbols::void_method_signature(), &quot;Should only be called for default constructors&quot;);
 621   int size = code_size();
 622   // Check if size match
 623   if (size == 0 || size % 5 != 0) return false;
 624   address cb = code_base();
 625   int last = size - 1;
 626   if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {
 627     // Does not call superclass default constructor
 628     return false;
 629   }
 630   // Check optional sequence
 631   for (int i = 4; i &lt; last; i += 5) {
 632     if (cb[i] != Bytecodes::_aload_0) return false;
 633     if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;
 634     if (cb[i+2] != Bytecodes::_putfield) return false;
 635   }
 636   return true;
 637 }
 638 
 639 
 640 bool Method::compute_has_loops_flag() {
<a name="24" id="anc24"></a><span class="line-modified"> 641   BytecodeStream bcs(methodHandle(Thread::current(), this));</span>
 642   Bytecodes::Code bc;
 643 
 644   while ((bc = bcs.next()) &gt;= 0) {
 645     switch( bc ) {
 646       case Bytecodes::_ifeq:
 647       case Bytecodes::_ifnull:
 648       case Bytecodes::_iflt:
 649       case Bytecodes::_ifle:
 650       case Bytecodes::_ifne:
 651       case Bytecodes::_ifnonnull:
 652       case Bytecodes::_ifgt:
 653       case Bytecodes::_ifge:
 654       case Bytecodes::_if_icmpeq:
 655       case Bytecodes::_if_icmpne:
 656       case Bytecodes::_if_icmplt:
 657       case Bytecodes::_if_icmpgt:
 658       case Bytecodes::_if_icmple:
 659       case Bytecodes::_if_icmpge:
 660       case Bytecodes::_if_acmpeq:
 661       case Bytecodes::_if_acmpne:
 662       case Bytecodes::_goto:
 663       case Bytecodes::_jsr:
 664         if( bcs.dest() &lt; bcs.next_bci() ) _access_flags.set_has_loops();
 665         break;
 666 
 667       case Bytecodes::_goto_w:
 668       case Bytecodes::_jsr_w:
 669         if( bcs.dest_w() &lt; bcs.next_bci() ) _access_flags.set_has_loops();
 670         break;
 671 
 672       default:
 673         break;
 674     }
 675   }
 676   _access_flags.set_loops_flag_init();
 677   return _access_flags.has_loops();
 678 }
 679 
 680 bool Method::is_final_method(AccessFlags class_access_flags) const {
 681   // or &quot;does_not_require_vtable_entry&quot;
 682   // default method or overpass can occur, is not final (reuses vtable entry)
 683   // private methods in classes get vtable entries for backward class compatibility.
 684   if (is_overpass() || is_default_method())  return false;
 685   return is_final() || class_access_flags.is_final();
 686 }
 687 
 688 bool Method::is_final_method() const {
 689   return is_final_method(method_holder()-&gt;access_flags());
 690 }
 691 
 692 bool Method::is_default_method() const {
 693   if (method_holder() != NULL &amp;&amp;
 694       method_holder()-&gt;is_interface() &amp;&amp;
 695       !is_abstract() &amp;&amp; !is_private()) {
 696     return true;
 697   } else {
 698     return false;
 699   }
 700 }
 701 
 702 bool Method::can_be_statically_bound(AccessFlags class_access_flags) const {
 703   if (is_final_method(class_access_flags))  return true;
 704 #ifdef ASSERT
 705   ResourceMark rm;
 706   bool is_nonv = (vtable_index() == nonvirtual_vtable_index);
 707   if (class_access_flags.is_interface()) {
 708       assert(is_nonv == is_static() || is_nonv == is_private(),
 709              &quot;nonvirtual unexpected for non-static, non-private: %s&quot;,
 710              name_and_sig_as_C_string());
 711   }
 712 #endif
 713   assert(valid_vtable_index() || valid_itable_index(), &quot;method must be linked before we ask this question&quot;);
 714   return vtable_index() == nonvirtual_vtable_index;
 715 }
 716 
 717 bool Method::can_be_statically_bound() const {
 718   return can_be_statically_bound(method_holder()-&gt;access_flags());
 719 }
 720 
<a name="25" id="anc25"></a><span class="line-added"> 721 bool Method::can_be_statically_bound(InstanceKlass* context) const {</span>
<span class="line-added"> 722   return (method_holder() == context) &amp;&amp; can_be_statically_bound();</span>
<span class="line-added"> 723 }</span>
<span class="line-added"> 724 </span>
 725 bool Method::is_accessor() const {
 726   return is_getter() || is_setter();
 727 }
 728 
 729 bool Method::is_getter() const {
 730   if (code_size() != 5) return false;
 731   if (size_of_parameters() != 1) return false;
 732   if (java_code_at(0) != Bytecodes::_aload_0)  return false;
 733   if (java_code_at(1) != Bytecodes::_getfield) return false;
 734   switch (java_code_at(4)) {
 735     case Bytecodes::_ireturn:
 736     case Bytecodes::_lreturn:
 737     case Bytecodes::_freturn:
 738     case Bytecodes::_dreturn:
 739     case Bytecodes::_areturn:
 740       break;
 741     default:
 742       return false;
 743   }
 744   return true;
 745 }
 746 
 747 bool Method::is_setter() const {
 748   if (code_size() != 6) return false;
 749   if (java_code_at(0) != Bytecodes::_aload_0) return false;
 750   switch (java_code_at(1)) {
 751     case Bytecodes::_iload_1:
 752     case Bytecodes::_aload_1:
 753     case Bytecodes::_fload_1:
 754       if (size_of_parameters() != 2) return false;
 755       break;
 756     case Bytecodes::_dload_1:
 757     case Bytecodes::_lload_1:
 758       if (size_of_parameters() != 3) return false;
 759       break;
 760     default:
 761       return false;
 762   }
 763   if (java_code_at(2) != Bytecodes::_putfield) return false;
 764   if (java_code_at(5) != Bytecodes::_return)   return false;
 765   return true;
 766 }
 767 
 768 bool Method::is_constant_getter() const {
 769   int last_index = code_size() - 1;
 770   // Check if the first 1-3 bytecodes are a constant push
 771   // and the last bytecode is a return.
 772   return (2 &lt;= code_size() &amp;&amp; code_size() &lt;= 4 &amp;&amp;
 773           Bytecodes::is_const(java_code_at(0)) &amp;&amp;
 774           Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
 775           Bytecodes::is_return(java_code_at(last_index)));
 776 }
 777 
 778 bool Method::is_initializer() const {
 779   return is_object_initializer() || is_static_initializer();
 780 }
 781 
 782 bool Method::has_valid_initializer_flags() const {
 783   return (is_static() ||
 784           method_holder()-&gt;major_version() &lt; 51);
 785 }
 786 
 787 bool Method::is_static_initializer() const {
 788   // For classfiles version 51 or greater, ensure that the clinit method is
 789   // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
 790   // initializers. (older classfiles exempted for backward compatibility)
 791   return name() == vmSymbols::class_initializer_name() &amp;&amp;
 792          has_valid_initializer_flags();
 793 }
 794 
 795 bool Method::is_object_initializer() const {
 796    return name() == vmSymbols::object_initializer_name();
 797 }
 798 
<a name="26" id="anc26"></a><span class="line-added"> 799 bool Method::needs_clinit_barrier() const {</span>
<span class="line-added"> 800   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();</span>
<span class="line-added"> 801 }</span>
<span class="line-added"> 802 </span>
 803 objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
 804   int length = method-&gt;checked_exceptions_length();
 805   if (length == 0) {  // common case
 806     return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
 807   } else {
 808     methodHandle h_this(THREAD, method);
 809     objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
 810     objArrayHandle mirrors (THREAD, m_oop);
 811     for (int i = 0; i &lt; length; i++) {
 812       CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
 813       Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
<a name="27" id="anc27"></a><span class="line-modified"> 814       if (log_is_enabled(Warning, exceptions) &amp;&amp;</span>
<span class="line-added"> 815           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {</span>
<span class="line-added"> 816         ResourceMark rm(THREAD);</span>
<span class="line-added"> 817         log_warning(exceptions)(</span>
<span class="line-added"> 818           &quot;Class %s in throws clause of method %s is not a subtype of class java.lang.Throwable&quot;,</span>
<span class="line-added"> 819           k-&gt;external_name(), method-&gt;external_name());</span>
<span class="line-added"> 820       }</span>
 821       mirrors-&gt;obj_at_put(i, k-&gt;java_mirror());
 822     }
 823     return mirrors;
 824   }
 825 };
 826 
 827 
 828 int Method::line_number_from_bci(int bci) const {
 829   int best_bci  =  0;
 830   int best_line = -1;
 831   if (bci == SynchronizationEntryBCI) bci = 0;
 832   if (0 &lt;= bci &amp;&amp; bci &lt; code_size() &amp;&amp; has_linenumber_table()) {
 833     // The line numbers are a short array of 2-tuples [start_pc, line_number].
 834     // Not necessarily sorted and not necessarily one-to-one.
 835     CompressedLineNumberReadStream stream(compressed_linenumber_table());
 836     while (stream.read_pair()) {
 837       if (stream.bci() == bci) {
 838         // perfect match
 839         return stream.line();
 840       } else {
 841         // update best_bci/line
 842         if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= best_bci) {
 843           best_bci  = stream.bci();
 844           best_line = stream.line();
 845         }
 846       }
 847     }
 848   }
 849   return best_line;
 850 }
 851 
 852 
 853 bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
 854   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass() ) {
 855     Thread *thread = Thread::current();
 856     Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
 857     Handle loader(thread, method_holder()-&gt;class_loader());
 858     Handle prot  (thread, method_holder()-&gt;protection_domain());
 859     return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
 860   } else {
 861     return true;
 862   }
 863 }
 864 
 865 
 866 bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
 867   int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
 868   if (must_be_resolved) {
 869     // Make sure klass is resolved in constantpool.
 870     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) return false;
 871   }
 872   return is_klass_loaded_by_klass_index(klass_index);
 873 }
 874 
 875 
 876 void Method::set_native_function(address function, bool post_event_flag) {
 877   assert(function != NULL, &quot;use clear_native_function to unregister natives&quot;);
 878   assert(!is_method_handle_intrinsic() || function == SharedRuntime::native_method_throw_unsatisfied_link_error_entry(), &quot;&quot;);
 879   address* native_function = native_function_addr();
 880 
 881   // We can see racers trying to place the same native function into place. Once
 882   // is plenty.
 883   address current = *native_function;
 884   if (current == function) return;
 885   if (post_event_flag &amp;&amp; JvmtiExport::should_post_native_method_bind() &amp;&amp;
 886       function != NULL) {
 887     // native_method_throw_unsatisfied_link_error_entry() should only
 888     // be passed when post_event_flag is false.
 889     assert(function !=
 890       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
 891       &quot;post_event_flag mis-match&quot;);
 892 
 893     // post the bind event, and possible change the bind function
 894     JvmtiExport::post_native_method_bind(this, &amp;function);
 895   }
 896   *native_function = function;
 897   // This function can be called more than once. We must make sure that we always
 898   // use the latest registered method -&gt; check if a stub already has been generated.
 899   // If so, we have to make it not_entrant.
 900   CompiledMethod* nm = code(); // Put it into local variable to guard against concurrent updates
 901   if (nm != NULL) {
 902     nm-&gt;make_not_entrant();
 903   }
 904 }
 905 
 906 
 907 bool Method::has_native_function() const {
 908   if (is_method_handle_intrinsic())
 909     return false;  // special-cased in SharedRuntime::generate_native_wrapper
 910   address func = native_function();
 911   return (func != NULL &amp;&amp; func != SharedRuntime::native_method_throw_unsatisfied_link_error_entry());
 912 }
 913 
 914 
 915 void Method::clear_native_function() {
 916   // Note: is_method_handle_intrinsic() is allowed here.
 917   set_native_function(
 918     SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
 919     !native_bind_event_is_interesting);
<a name="28" id="anc28"></a><span class="line-modified"> 920   this-&gt;unlink_code();</span>





 921 }
 922 
 923 
 924 void Method::set_signature_handler(address handler) {
 925   address* signature_handler =  signature_handler_addr();
 926   *signature_handler = handler;
 927 }
 928 
 929 
 930 void Method::print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason) {
<a name="29" id="anc29"></a><span class="line-added"> 931   assert(reason != NULL, &quot;must provide a reason&quot;);</span>
 932   if (PrintCompilation &amp;&amp; report) {
 933     ttyLocker ttyl;
 934     tty-&gt;print(&quot;made not %scompilable on &quot;, is_osr ? &quot;OSR &quot; : &quot;&quot;);
 935     if (comp_level == CompLevel_all) {
 936       tty-&gt;print(&quot;all levels &quot;);
 937     } else {
<a name="30" id="anc30"></a><span class="line-modified"> 938       tty-&gt;print(&quot;level %d &quot;, comp_level);</span>



 939     }
 940     this-&gt;print_short_name(tty);
 941     int size = this-&gt;code_size();
 942     if (size &gt; 0) {
 943       tty-&gt;print(&quot; (%d bytes)&quot;, size);
 944     }
 945     if (reason != NULL) {
 946       tty-&gt;print(&quot;   %s&quot;, reason);
 947     }
 948     tty-&gt;cr();
 949   }
 950   if ((TraceDeoptimization || LogCompilation) &amp;&amp; (xtty != NULL)) {
 951     ttyLocker ttyl;
 952     xtty-&gt;begin_elem(&quot;make_not_compilable thread=&#39;&quot; UINTX_FORMAT &quot;&#39; osr=&#39;%d&#39; level=&#39;%d&#39;&quot;,
 953                      os::current_thread_id(), is_osr, comp_level);
 954     if (reason != NULL) {
 955       xtty-&gt;print(&quot; reason=\&#39;%s\&#39;&quot;, reason);
 956     }
 957     xtty-&gt;method(this);
 958     xtty-&gt;stamp();
 959     xtty-&gt;end_elem();
 960   }
 961 }
 962 
 963 bool Method::is_always_compilable() const {
 964   // Generated adapters must be compiled
 965   if (is_method_handle_intrinsic() &amp;&amp; is_synthetic()) {
 966     assert(!is_not_c1_compilable(), &quot;sanity check&quot;);
 967     assert(!is_not_c2_compilable(), &quot;sanity check&quot;);
 968     return true;
 969   }
 970 
 971   return false;
 972 }
 973 
 974 bool Method::is_not_compilable(int comp_level) const {
 975   if (number_of_breakpoints() &gt; 0)
 976     return true;
 977   if (is_always_compilable())
 978     return false;
 979   if (comp_level == CompLevel_any)
 980     return is_not_c1_compilable() || is_not_c2_compilable();
 981   if (is_c1_compile(comp_level))
 982     return is_not_c1_compilable();
 983   if (is_c2_compile(comp_level))
 984     return is_not_c2_compilable();
 985   return false;
 986 }
 987 
 988 // call this when compiler finds that this method is not compilable
<a name="31" id="anc31"></a><span class="line-modified"> 989 void Method::set_not_compilable(const char* reason, int comp_level, bool report) {</span>
 990   if (is_always_compilable()) {
 991     // Don&#39;t mark a method which should be always compilable
 992     return;
 993   }
 994   print_made_not_compilable(comp_level, /*is_osr*/ false, report, reason);
 995   if (comp_level == CompLevel_all) {
 996     set_not_c1_compilable();
 997     set_not_c2_compilable();
 998   } else {
 999     if (is_c1_compile(comp_level))
1000       set_not_c1_compilable();
1001     if (is_c2_compile(comp_level))
1002       set_not_c2_compilable();
1003   }
<a name="32" id="anc32"></a><span class="line-modified">1004   assert(!CompilationPolicy::can_be_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);</span>

1005 }
1006 
1007 bool Method::is_not_osr_compilable(int comp_level) const {
1008   if (is_not_compilable(comp_level))
1009     return true;
1010   if (comp_level == CompLevel_any)
1011     return is_not_c1_osr_compilable() || is_not_c2_osr_compilable();
1012   if (is_c1_compile(comp_level))
1013     return is_not_c1_osr_compilable();
1014   if (is_c2_compile(comp_level))
1015     return is_not_c2_osr_compilable();
1016   return false;
1017 }
1018 
<a name="33" id="anc33"></a><span class="line-modified">1019 void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {</span>
1020   print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
1021   if (comp_level == CompLevel_all) {
1022     set_not_c1_osr_compilable();
1023     set_not_c2_osr_compilable();
1024   } else {
1025     if (is_c1_compile(comp_level))
1026       set_not_c1_osr_compilable();
1027     if (is_c2_compile(comp_level))
1028       set_not_c2_osr_compilable();
1029   }
<a name="34" id="anc34"></a><span class="line-modified">1030   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);</span>

1031 }
1032 
1033 // Revert to using the interpreter and clear out the nmethod
<a name="35" id="anc35"></a><span class="line-modified">1034 void Method::clear_code() {</span>

1035   // this may be NULL if c2i adapters have not been made yet
1036   // Only should happen at allocate time.
1037   if (adapter() == NULL) {
1038     _from_compiled_entry    = NULL;
1039   } else {
1040     _from_compiled_entry    = adapter()-&gt;get_c2i_entry();
1041   }
1042   OrderAccess::storestore();
1043   _from_interpreted_entry = _i2i_entry;
1044   OrderAccess::storestore();
1045   _code = NULL;
1046 }
1047 
<a name="36" id="anc36"></a><span class="line-added">1048 void Method::unlink_code(CompiledMethod *compare) {</span>
<span class="line-added">1049   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">1050   // We need to check if either the _code or _from_compiled_code_entry_point</span>
<span class="line-added">1051   // refer to this nmethod because there is a race in setting these two fields</span>
<span class="line-added">1052   // in Method* as seen in bugid 4947125.</span>
<span class="line-added">1053   // If the vep() points to the zombie nmethod, the memory for the nmethod</span>
<span class="line-added">1054   // could be flushed and the compiler and vtable stubs could still call</span>
<span class="line-added">1055   // through it.</span>
<span class="line-added">1056   if (code() == compare ||</span>
<span class="line-added">1057       from_compiled_entry() == compare-&gt;verified_entry_point()) {</span>
<span class="line-added">1058     clear_code();</span>
<span class="line-added">1059   }</span>
<span class="line-added">1060 }</span>
<span class="line-added">1061 </span>
<span class="line-added">1062 void Method::unlink_code() {</span>
<span class="line-added">1063   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">1064   clear_code();</span>
<span class="line-added">1065 }</span>
<span class="line-added">1066 </span>
1067 #if INCLUDE_CDS
1068 // Called by class data sharing to remove any entry points (which are not shared)
1069 void Method::unlink_method() {
1070   _code = NULL;
1071 
<a name="37" id="anc37"></a><span class="line-modified">1072   Arguments::assert_is_dumping_archive();</span>
1073   // Set the values to what they should be at run time. Note that
1074   // this Method can no longer be executed during dump time.
<a name="38" id="anc38"></a><span class="line-modified">1075   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));</span>
1076   _from_interpreted_entry = _i2i_entry;
1077 
<a name="39" id="anc39"></a><span class="line-added">1078   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">1079     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);</span>
<span class="line-added">1080   } else {</span>
<span class="line-added">1081     // TODO: Simplify the adapter trampoline allocation for static archiving.</span>
<span class="line-added">1082     //       Remove the use of CDSAdapterHandlerEntry.</span>
<span class="line-added">1083     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();</span>
<span class="line-added">1084     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());</span>
<span class="line-added">1085     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();</span>
<span class="line-added">1086     assert(*((int*)_from_compiled_entry) == 0,</span>
<span class="line-added">1087            &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">1088   }</span>
<span class="line-added">1089 </span>
1090   if (is_native()) {
1091     *native_function_addr() = NULL;
1092     set_signature_handler(NULL);
1093   }
1094   NOT_PRODUCT(set_compiled_invocation_count(0);)
1095 
<a name="40" id="anc40"></a>




1096   set_method_data(NULL);
1097   clear_method_counters();
1098 }
1099 #endif
1100 
1101 /****************************************************************************
1102 // The following illustrates how the entries work for CDS shared Methods:
1103 //
1104 // Our goal is to delay writing into a shared Method until it&#39;s compiled.
1105 // Hence, we want to determine the initial values for _i2i_entry,
1106 // _from_interpreted_entry and _from_compiled_entry during CDS dump time.
1107 //
1108 // In this example, both Methods A and B have the _i2i_entry of &quot;zero_locals&quot;.
1109 // They also have similar signatures so that they will share the same
1110 // AdapterHandlerEntry.
1111 //
1112 // _adapter_trampoline points to a fixed location in the RW section of
1113 // the CDS archive. This location initially contains a NULL pointer. When the
1114 // first of method A or B is linked, an AdapterHandlerEntry is allocated
1115 // dynamically, and its c2i/i2c entries are generated.
1116 //
1117 // _i2i_entry and _from_interpreted_entry initially points to the same
1118 // (fixed) location in the CODE section of the CDS archive. This contains
1119 // an unconditional branch to the actual entry for &quot;zero_locals&quot;, which is
1120 // generated at run time and may be on an arbitrary address. Thus, the
1121 // unconditional branch is also generated at run time to jump to the correct
1122 // address.
1123 //
1124 // Similarly, _from_compiled_entry points to a fixed address in the CODE
1125 // section. This address has enough space for an unconditional branch
1126 // instruction, and is initially zero-filled. After the AdapterHandlerEntry is
1127 // initialized, and the address for the actual c2i_entry is known, we emit a
1128 // branch instruction here to branch to the actual c2i_entry.
1129 //
1130 // The effect of the extra branch on the i2i and c2i entries is negligible.
1131 //
1132 // The reason for putting _adapter_trampoline in RO is many shared Methods
1133 // share the same AdapterHandlerEntry, so we can save space in the RW section
1134 // by having the extra indirection.
1135 
1136 
1137 [Method A: RW]
1138   _constMethod ----&gt; [ConstMethod: RO]
1139                        _adapter_trampoline -----------+
1140                                                       |
1141   _i2i_entry              (same value as method B)    |
1142   _from_interpreted_entry (same value as method B)    |
1143   _from_compiled_entry    (same value as method B)    |
1144                                                       |
1145                                                       |
1146 [Method B: RW]                               +--------+
1147   _constMethod ----&gt; [ConstMethod: RO]       |
1148                        _adapter_trampoline --+---&gt;(AdapterHandlerEntry* ptr: RW)-+
1149                                                                                  |
1150                                                  +-------------------------------+
1151                                                  |
1152                                                  +----&gt; [AdapterHandlerEntry] (allocated at run time)
1153                                                               _fingerprint
1154                                                               _c2i_entry ---------------------------------+-&gt;[c2i entry..]
1155  _i2i_entry  -------------+                                   _i2c_entry ---------------+-&gt; [i2c entry..] |
1156  _from_interpreted_entry  |                                   _c2i_unverified_entry     |                 |
<a name="41" id="anc41"></a><span class="line-modified">1157          |                |                                   _c2i_no_clinit_check_entry|                 |</span>
1158          |                |  (_cds_entry_table: CODE)                                   |                 |
1159          |                +-&gt;[0]: jmp _entry_table[0] --&gt; (i2i_entry_for &quot;zero_locals&quot;) |                 |
1160          |                |                               (allocated at run time)       |                 |
1161          |                |  ...                           [asm code ...]               |                 |
1162          +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |
1163          |                                                                              |                 |
1164          |                                                                              |                 |
1165          +-[compiled]-------------------------------------------------------------------+                 |
1166                                                                                                           |
1167  _from_compiled_entry------------&gt;  (_c2i_entry_trampoline: CODE)                                         |
1168                                     [jmp c2i_entry] ------------------------------------------------------+
1169 
1170 ***/
1171 
1172 // Called when the method_holder is getting linked. Setup entrypoints so the method
1173 // is ready to be called from interpreter, compiler, and vtables.
1174 void Method::link_method(const methodHandle&amp; h_method, TRAPS) {
1175   // If the code cache is full, we may reenter this function for the
1176   // leftover methods that weren&#39;t linked.
1177   if (is_shared()) {
1178     address entry = Interpreter::entry_for_cds_method(h_method);
1179     assert(entry != NULL &amp;&amp; entry == _i2i_entry,
1180            &quot;should be correctly set during dump time&quot;);
1181     if (adapter() != NULL) {
1182       return;
1183     }
1184     assert(entry == _from_interpreted_entry,
1185            &quot;should be correctly set during dump time&quot;);
1186   } else if (_i2i_entry != NULL) {
1187     return;
1188   }
1189   assert( _code == NULL, &quot;nothing compiled yet&quot; );
1190 
1191   // Setup interpreter entrypoint
1192   assert(this == h_method(), &quot;wrong h_method()&quot; );
1193 
1194   if (!is_shared()) {
1195     assert(adapter() == NULL, &quot;init&#39;d to NULL&quot;);
1196     address entry = Interpreter::entry_for_method(h_method);
1197     assert(entry != NULL, &quot;interpreter entry must be non-null&quot;);
1198     // Sets both _i2i_entry and _from_interpreted_entry
1199     set_interpreter_entry(entry);
1200   }
1201 
1202   // Don&#39;t overwrite already registered native entries.
1203   if (is_native() &amp;&amp; !has_native_function()) {
1204     set_native_function(
1205       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
1206       !native_bind_event_is_interesting);
1207   }
1208 
1209   // Setup compiler entrypoint.  This is made eagerly, so we do not need
1210   // special handling of vtables.  An alternative is to make adapters more
1211   // lazily by calling make_adapter() from from_compiled_entry() for the
1212   // normal calls.  For vtable calls life gets more complicated.  When a
1213   // call-site goes mega-morphic we need adapters in all methods which can be
1214   // called from the vtable.  We need adapters on such methods that get loaded
1215   // later.  Ditto for mega-morphic itable calls.  If this proves to be a
1216   // problem we&#39;ll make these lazily later.
1217   (void) make_adapters(h_method, CHECK);
1218 
1219   // ONLY USE the h_method now as make_adapter may have blocked
1220 
1221 }
1222 
1223 address Method::make_adapters(const methodHandle&amp; mh, TRAPS) {
1224   // Adapters for compiled code are made eagerly here.  They are fairly
1225   // small (generally &lt; 100 bytes) and quick to make (and cached and shared)
1226   // so making them eagerly shouldn&#39;t be too expensive.
1227   AdapterHandlerEntry* adapter = AdapterHandlerLibrary::get_adapter(mh);
1228   if (adapter == NULL ) {
1229     if (!is_init_completed()) {
1230       // Don&#39;t throw exceptions during VM initialization because java.lang.* classes
1231       // might not have been initialized, causing problems when constructing the
1232       // Java exception object.
1233       vm_exit_during_initialization(&quot;Out of space in CodeCache for adapters&quot;);
1234     } else {
1235       THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), &quot;Out of space in CodeCache for adapters&quot;);
1236     }
1237   }
1238 
1239   if (mh-&gt;is_shared()) {
1240     assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
1241     assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);
1242   } else {
1243     mh-&gt;set_adapter_entry(adapter);
1244     mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();
1245   }
1246   return adapter-&gt;get_c2i_entry();
1247 }
1248 
1249 void Method::restore_unshareable_info(TRAPS) {
1250   assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
1251 
1252   // Since restore_unshareable_info can be called more than once for a method, don&#39;t
1253   // redo any work.
1254   if (adapter() == NULL) {
1255     methodHandle mh(THREAD, this);
1256     link_method(mh, CHECK);
1257   }
1258 }
1259 
1260 address Method::from_compiled_entry_no_trampoline() const {
<a name="42" id="anc42"></a><span class="line-modified">1261   CompiledMethod *code = Atomic::load_acquire(&amp;_code);</span>
1262   if (code) {
1263     return code-&gt;verified_entry_point();
1264   } else {
1265     return adapter()-&gt;get_c2i_entry();
1266   }
1267 }
1268 
1269 // The verified_code_entry() must be called when a invoke is resolved
1270 // on this method.
1271 
1272 // It returns the compiled code entry point, after asserting not null.
1273 // This function is called after potential safepoints so that nmethod
1274 // or adapter that it points to is still live and valid.
1275 // This function must not hit a safepoint!
1276 address Method::verified_code_entry() {
1277   debug_only(NoSafepointVerifier nsv;)
1278   assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
1279   return _from_compiled_entry;
1280 }
1281 
1282 // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
1283 // (could be racing a deopt).
1284 // Not inline to avoid circular ref.
1285 bool Method::check_code() const {
1286   // cached in a register or local.  There&#39;s a race on the value of the field.
<a name="43" id="anc43"></a><span class="line-modified">1287   CompiledMethod *code = Atomic::load_acquire(&amp;_code);</span>
1288   return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
1289 }
1290 
1291 // Install compiled code.  Instantly it can execute.
1292 void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
<a name="44" id="anc44"></a><span class="line-modified">1293   assert_lock_strong(CompiledMethod_lock);</span>
1294   assert( code, &quot;use clear_code to remove code&quot; );
1295   assert( mh-&gt;check_code(), &quot;&quot; );
1296 
1297   guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
1298 
1299   // These writes must happen in this order, because the interpreter will
1300   // directly jump to from_interpreted_entry which jumps to an i2c adapter
1301   // which jumps to _from_compiled_entry.
1302   mh-&gt;_code = code;             // Assign before allowing compiled code to exec
1303 
1304   int comp_level = code-&gt;comp_level();
1305   // In theory there could be a race here. In practice it is unlikely
1306   // and not worth worrying about.
1307   if (comp_level &gt; mh-&gt;highest_comp_level()) {
1308     mh-&gt;set_highest_comp_level(comp_level);
1309   }
1310 
1311   OrderAccess::storestore();
1312   mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();
1313   OrderAccess::storestore();
1314   // Instantly compiled code can execute.
1315   if (!mh-&gt;is_method_handle_intrinsic())
1316     mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
1317 }
1318 
1319 
1320 bool Method::is_overridden_in(Klass* k) const {
1321   InstanceKlass* ik = InstanceKlass::cast(k);
1322 
1323   if (ik-&gt;is_interface()) return false;
1324 
1325   // If method is an interface, we skip it - except if it
1326   // is a miranda method
1327   if (method_holder()-&gt;is_interface()) {
1328     // Check that method is not a miranda method
1329     if (ik-&gt;lookup_method(name(), signature()) == NULL) {
1330       // No implementation exist - so miranda method
1331       return false;
1332     }
1333     return true;
1334   }
1335 
1336   assert(ik-&gt;is_subclass_of(method_holder()), &quot;should be subklass&quot;);
1337   if (!has_vtable_index()) {
1338     return false;
1339   } else {
1340     Method* vt_m = ik-&gt;method_at_vtable(vtable_index());
1341     return vt_m != this;
1342   }
1343 }
1344 
1345 
1346 // give advice about whether this Method* should be cached or not
1347 bool Method::should_not_be_cached() const {
1348   if (is_old()) {
1349     // This method has been redefined. It is either EMCP or obsolete
1350     // and we don&#39;t want to cache it because that would pin the method
1351     // down and prevent it from being collectible if and when it
1352     // finishes executing.
1353     return true;
1354   }
1355 
1356   // caching this method should be just fine
1357   return false;
1358 }
1359 
1360 
1361 /**
1362  *  Returns true if this is one of the specially treated methods for
1363  *  security related stack walks (like Reflection.getCallerClass).
1364  */
1365 bool Method::is_ignored_by_security_stack_walk() const {
1366   if (intrinsic_id() == vmIntrinsics::_invoke) {
1367     // This is Method.invoke() -- ignore it
1368     return true;
1369   }
1370   if (method_holder()-&gt;is_subclass_of(SystemDictionary::reflect_MethodAccessorImpl_klass())) {
1371     // This is an auxilary frame -- ignore it
1372     return true;
1373   }
1374   if (is_method_handle_intrinsic() || is_compiled_lambda_form()) {
1375     // This is an internal adapter frame for method handles -- ignore it
1376     return true;
1377   }
1378   return false;
1379 }
1380 
1381 
1382 // Constant pool structure for invoke methods:
1383 enum {
1384   _imcp_invoke_name = 1,        // utf8: &#39;invokeExact&#39;, etc.
1385   _imcp_invoke_signature,       // utf8: (variable Symbol*)
1386   _imcp_limit
1387 };
1388 
1389 // Test if this method is an MH adapter frame generated by Java code.
1390 // Cf. java/lang/invoke/InvokerBytecodeGenerator
1391 bool Method::is_compiled_lambda_form() const {
1392   return intrinsic_id() == vmIntrinsics::_compiledLambdaForm;
1393 }
1394 
1395 // Test if this method is an internal MH primitive method.
1396 bool Method::is_method_handle_intrinsic() const {
1397   vmIntrinsics::ID iid = intrinsic_id();
1398   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
1399           MethodHandles::is_signature_polymorphic_intrinsic(iid));
1400 }
1401 
1402 bool Method::has_member_arg() const {
1403   vmIntrinsics::ID iid = intrinsic_id();
1404   return (MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
1405           MethodHandles::has_member_arg(iid));
1406 }
1407 
1408 // Make an instance of a signature-polymorphic internal MH primitive.
1409 methodHandle Method::make_method_handle_intrinsic(vmIntrinsics::ID iid,
1410                                                          Symbol* signature,
1411                                                          TRAPS) {
<a name="45" id="anc45"></a><span class="line-modified">1412   ResourceMark rm(THREAD);</span>
1413   methodHandle empty;
1414 
1415   InstanceKlass* holder = SystemDictionary::MethodHandle_klass();
1416   Symbol* name = MethodHandles::signature_polymorphic_intrinsic_name(iid);
1417   assert(iid == MethodHandles::signature_polymorphic_name_id(name), &quot;&quot;);
1418   if (TraceMethodHandles) {
1419     tty-&gt;print_cr(&quot;make_method_handle_intrinsic MH.%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
1420   }
1421 
1422   // invariant:   cp-&gt;symbol_at_put is preceded by a refcount increment (more usually a lookup)
1423   name-&gt;increment_refcount();
1424   signature-&gt;increment_refcount();
1425 
1426   int cp_length = _imcp_limit;
1427   ClassLoaderData* loader_data = holder-&gt;class_loader_data();
1428   constantPoolHandle cp;
1429   {
1430     ConstantPool* cp_oop = ConstantPool::allocate(loader_data, cp_length, CHECK_(empty));
1431     cp = constantPoolHandle(THREAD, cp_oop);
1432   }
1433   cp-&gt;set_pool_holder(holder);
1434   cp-&gt;symbol_at_put(_imcp_invoke_name,       name);
1435   cp-&gt;symbol_at_put(_imcp_invoke_signature,  signature);
1436   cp-&gt;set_has_preresolution();
1437 
1438   // decide on access bits:  public or not?
1439   int flags_bits = (JVM_ACC_NATIVE | JVM_ACC_SYNTHETIC | JVM_ACC_FINAL);
1440   bool must_be_static = MethodHandles::is_signature_polymorphic_static(iid);
1441   if (must_be_static)  flags_bits |= JVM_ACC_STATIC;
1442   assert((flags_bits &amp; JVM_ACC_PUBLIC) == 0, &quot;do not expose these methods&quot;);
1443 
1444   methodHandle m;
1445   {
1446     InlineTableSizes sizes;
1447     Method* m_oop = Method::allocate(loader_data, 0,
1448                                      accessFlags_from(flags_bits), &amp;sizes,
1449                                      ConstMethod::NORMAL, CHECK_(empty));
1450     m = methodHandle(THREAD, m_oop);
1451   }
1452   m-&gt;set_constants(cp());
1453   m-&gt;set_name_index(_imcp_invoke_name);
1454   m-&gt;set_signature_index(_imcp_invoke_signature);
1455   assert(MethodHandles::is_signature_polymorphic_name(m-&gt;name()), &quot;&quot;);
1456   assert(m-&gt;signature() == signature, &quot;&quot;);
<a name="46" id="anc46"></a><span class="line-modified">1457   m-&gt;compute_from_signature(signature);</span>


1458   m-&gt;init_intrinsic_id();
1459   assert(m-&gt;is_method_handle_intrinsic(), &quot;&quot;);
1460 #ifdef ASSERT
1461   if (!MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()))  m-&gt;print();
1462   assert(MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()), &quot;must be an invoker&quot;);
1463   assert(m-&gt;intrinsic_id() == iid, &quot;correctly predicted iid&quot;);
1464 #endif //ASSERT
1465 
1466   // Finally, set up its entry points.
1467   assert(m-&gt;can_be_statically_bound(), &quot;&quot;);
1468   m-&gt;set_vtable_index(Method::nonvirtual_vtable_index);
1469   m-&gt;link_method(m, CHECK_(empty));
1470 
1471   if (TraceMethodHandles &amp;&amp; (Verbose || WizardMode)) {
1472     ttyLocker ttyl;
1473     m-&gt;print_on(tty);
1474   }
1475 
1476   return m;
1477 }
1478 
1479 Klass* Method::check_non_bcp_klass(Klass* klass) {
1480   if (klass != NULL &amp;&amp; klass-&gt;class_loader() != NULL) {
1481     if (klass-&gt;is_objArray_klass())
1482       klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass();
1483     return klass;
1484   }
1485   return NULL;
1486 }
1487 
1488 
1489 methodHandle Method::clone_with_new_data(const methodHandle&amp; m, u_char* new_code, int new_code_length,
1490                                                 u_char* new_compressed_linenumber_table, int new_compressed_linenumber_size, TRAPS) {
1491   // Code below does not work for native methods - they should never get rewritten anyway
1492   assert(!m-&gt;is_native(), &quot;cannot rewrite native methods&quot;);
1493   // Allocate new Method*
1494   AccessFlags flags = m-&gt;access_flags();
1495 
1496   ConstMethod* cm = m-&gt;constMethod();
1497   int checked_exceptions_len = cm-&gt;checked_exceptions_length();
1498   int localvariable_len = cm-&gt;localvariable_table_length();
1499   int exception_table_len = cm-&gt;exception_table_length();
1500   int method_parameters_len = cm-&gt;method_parameters_length();
1501   int method_annotations_len = cm-&gt;method_annotations_length();
1502   int parameter_annotations_len = cm-&gt;parameter_annotations_length();
1503   int type_annotations_len = cm-&gt;type_annotations_length();
1504   int default_annotations_len = cm-&gt;default_annotations_length();
1505 
1506   InlineTableSizes sizes(
1507       localvariable_len,
1508       new_compressed_linenumber_size,
1509       exception_table_len,
1510       checked_exceptions_len,
1511       method_parameters_len,
1512       cm-&gt;generic_signature_index(),
1513       method_annotations_len,
1514       parameter_annotations_len,
1515       type_annotations_len,
1516       default_annotations_len,
1517       0);
1518 
1519   ClassLoaderData* loader_data = m-&gt;method_holder()-&gt;class_loader_data();
1520   Method* newm_oop = Method::allocate(loader_data,
1521                                       new_code_length,
1522                                       flags,
1523                                       &amp;sizes,
1524                                       m-&gt;method_type(),
1525                                       CHECK_(methodHandle()));
1526   methodHandle newm (THREAD, newm_oop);
1527 
1528   // Create a shallow copy of Method part, but be careful to preserve the new ConstMethod*
1529   ConstMethod* newcm = newm-&gt;constMethod();
1530   int new_const_method_size = newm-&gt;constMethod()-&gt;size();
1531 
1532   // This works because the source and target are both Methods. Some compilers
1533   // (e.g., clang) complain that the target vtable pointer will be stomped,
1534   // so cast away newm()&#39;s and m()&#39;s Methodness.
1535   memcpy((void*)newm(), (void*)m(), sizeof(Method));
1536 
1537   // Create shallow copy of ConstMethod.
1538   memcpy(newcm, m-&gt;constMethod(), sizeof(ConstMethod));
1539 
1540   // Reset correct method/const method, method size, and parameter info
1541   newm-&gt;set_constMethod(newcm);
1542   newm-&gt;constMethod()-&gt;set_code_size(new_code_length);
1543   newm-&gt;constMethod()-&gt;set_constMethod_size(new_const_method_size);
1544   assert(newm-&gt;code_size() == new_code_length, &quot;check&quot;);
1545   assert(newm-&gt;method_parameters_length() == method_parameters_len, &quot;check&quot;);
1546   assert(newm-&gt;checked_exceptions_length() == checked_exceptions_len, &quot;check&quot;);
1547   assert(newm-&gt;exception_table_length() == exception_table_len, &quot;check&quot;);
1548   assert(newm-&gt;localvariable_table_length() == localvariable_len, &quot;check&quot;);
1549   // Copy new byte codes
1550   memcpy(newm-&gt;code_base(), new_code, new_code_length);
1551   // Copy line number table
1552   if (new_compressed_linenumber_size &gt; 0) {
1553     memcpy(newm-&gt;compressed_linenumber_table(),
1554            new_compressed_linenumber_table,
1555            new_compressed_linenumber_size);
1556   }
1557   // Copy method_parameters
1558   if (method_parameters_len &gt; 0) {
1559     memcpy(newm-&gt;method_parameters_start(),
1560            m-&gt;method_parameters_start(),
1561            method_parameters_len * sizeof(MethodParametersElement));
1562   }
1563   // Copy checked_exceptions
1564   if (checked_exceptions_len &gt; 0) {
1565     memcpy(newm-&gt;checked_exceptions_start(),
1566            m-&gt;checked_exceptions_start(),
1567            checked_exceptions_len * sizeof(CheckedExceptionElement));
1568   }
1569   // Copy exception table
1570   if (exception_table_len &gt; 0) {
1571     memcpy(newm-&gt;exception_table_start(),
1572            m-&gt;exception_table_start(),
1573            exception_table_len * sizeof(ExceptionTableElement));
1574   }
1575   // Copy local variable number table
1576   if (localvariable_len &gt; 0) {
1577     memcpy(newm-&gt;localvariable_table_start(),
1578            m-&gt;localvariable_table_start(),
1579            localvariable_len * sizeof(LocalVariableTableElement));
1580   }
1581   // Copy stackmap table
1582   if (m-&gt;has_stackmap_table()) {
1583     int code_attribute_length = m-&gt;stackmap_data()-&gt;length();
1584     Array&lt;u1&gt;* stackmap_data =
<a name="47" id="anc47"></a><span class="line-modified">1585       MetadataFactory::new_array&lt;u1&gt;(loader_data, code_attribute_length, 0, CHECK_(methodHandle()));</span>
1586     memcpy((void*)stackmap_data-&gt;adr_at(0),
1587            (void*)m-&gt;stackmap_data()-&gt;adr_at(0), code_attribute_length);
1588     newm-&gt;set_stackmap_data(stackmap_data);
1589   }
1590 
1591   // copy annotations over to new method
<a name="48" id="anc48"></a><span class="line-modified">1592   newcm-&gt;copy_annotations_from(loader_data, cm, CHECK_(methodHandle()));</span>
1593   return newm;
1594 }
1595 
1596 vmSymbols::SID Method::klass_id_for_intrinsics(const Klass* holder) {
1597   // if loader is not the default loader (i.e., != NULL), we can&#39;t know the intrinsics
1598   // because we are not loading from core libraries
1599   // exception: the AES intrinsics come from lib/ext/sunjce_provider.jar
1600   // which does not use the class default class loader so we check for its loader here
1601   const InstanceKlass* ik = InstanceKlass::cast(holder);
1602   if ((ik-&gt;class_loader() != NULL) &amp;&amp; !SystemDictionary::is_platform_class_loader(ik-&gt;class_loader())) {
1603     return vmSymbols::NO_SID;   // regardless of name, no intrinsics here
1604   }
1605 
1606   // see if the klass name is well-known:
1607   Symbol* klass_name = ik-&gt;name();
1608   return vmSymbols::find_sid(klass_name);
1609 }
1610 
1611 void Method::init_intrinsic_id() {
1612   assert(_intrinsic_id == vmIntrinsics::_none, &quot;do this just once&quot;);
1613   const uintptr_t max_id_uint = right_n_bits((int)(sizeof(_intrinsic_id) * BitsPerByte));
1614   assert((uintptr_t)vmIntrinsics::ID_LIMIT &lt;= max_id_uint, &quot;else fix size&quot;);
1615   assert(intrinsic_id_size_in_bytes() == sizeof(_intrinsic_id), &quot;&quot;);
1616 
1617   // the klass name is well-known:
1618   vmSymbols::SID klass_id = klass_id_for_intrinsics(method_holder());
1619   assert(klass_id != vmSymbols::NO_SID, &quot;caller responsibility&quot;);
1620 
1621   // ditto for method and signature:
1622   vmSymbols::SID  name_id = vmSymbols::find_sid(name());
1623   if (klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)
1624       &amp;&amp; klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)
1625       &amp;&amp; name_id == vmSymbols::NO_SID) {
1626     return;
1627   }
1628   vmSymbols::SID   sig_id = vmSymbols::find_sid(signature());
1629   if (klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle)
1630       &amp;&amp; klass_id != vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle)
1631       &amp;&amp; sig_id == vmSymbols::NO_SID) {
1632     return;
1633   }
1634   jshort flags = access_flags().as_short();
1635 
1636   vmIntrinsics::ID id = vmIntrinsics::find_id(klass_id, name_id, sig_id, flags);
1637   if (id != vmIntrinsics::_none) {
1638     set_intrinsic_id(id);
1639     if (id == vmIntrinsics::_Class_cast) {
1640       // Even if the intrinsic is rejected, we want to inline this simple method.
1641       set_force_inline(true);
1642     }
1643     return;
1644   }
1645 
1646   // A few slightly irregular cases:
1647   switch (klass_id) {
1648   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_StrictMath):
1649     // Second chance: check in regular Math.
1650     switch (name_id) {
1651     case vmSymbols::VM_SYMBOL_ENUM_NAME(min_name):
1652     case vmSymbols::VM_SYMBOL_ENUM_NAME(max_name):
1653     case vmSymbols::VM_SYMBOL_ENUM_NAME(sqrt_name):
1654       // pretend it is the corresponding method in the non-strict class:
1655       klass_id = vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_Math);
1656       id = vmIntrinsics::find_id(klass_id, name_id, sig_id, flags);
1657       break;
1658     default:
1659       break;
1660     }
1661     break;
1662 
1663   // Signature-polymorphic methods: MethodHandle.invoke*, InvokeDynamic.*., VarHandle
1664   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle):
1665   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle):
1666     if (!is_native())  break;
1667     id = MethodHandles::signature_polymorphic_name_id(method_holder(), name());
1668     if (is_static() != MethodHandles::is_signature_polymorphic_static(id))
1669       id = vmIntrinsics::_none;
1670     break;
1671 
1672   default:
1673     break;
1674   }
1675 
1676   if (id != vmIntrinsics::_none) {
1677     // Set up its iid.  It is an alias method.
1678     set_intrinsic_id(id);
1679     return;
1680   }
1681 }
1682 
1683 // These two methods are static since a GC may move the Method
1684 bool Method::load_signature_classes(const methodHandle&amp; m, TRAPS) {
1685   if (!THREAD-&gt;can_call_java()) {
1686     // There is nothing useful this routine can do from within the Compile thread.
1687     // Hopefully, the signature contains only well-known classes.
1688     // We could scan for this and return true/false, but the caller won&#39;t care.
1689     return false;
1690   }
1691   bool sig_is_loaded = true;
1692   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());
1693   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
1694   ResourceMark rm(THREAD);
1695   Symbol*  signature = m-&gt;signature();
1696   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
<a name="49" id="anc49"></a><span class="line-modified">1697     if (ss.is_reference()) {</span>
<span class="line-modified">1698       Symbol* sym = ss.as_symbol();</span>
1699       Symbol*  name  = sym;
1700       Klass* klass = SystemDictionary::resolve_or_null(name, class_loader,
1701                                              protection_domain, THREAD);
1702       // We are loading classes eagerly. If a ClassNotFoundException or
1703       // a LinkageError was generated, be sure to ignore it.
1704       if (HAS_PENDING_EXCEPTION) {
1705         if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass()) ||
1706             PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1707           CLEAR_PENDING_EXCEPTION;
1708         } else {
1709           return false;
1710         }
1711       }
1712       if( klass == NULL) { sig_is_loaded = false; }
1713     }
1714   }
1715   return sig_is_loaded;
1716 }
1717 
1718 bool Method::has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS) {
1719   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());
1720   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
1721   ResourceMark rm(THREAD);
1722   Symbol*  signature = m-&gt;signature();
1723   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
1724     if (ss.type() == T_OBJECT) {
<a name="50" id="anc50"></a><span class="line-modified">1725       Symbol* name = ss.as_symbol();</span>

1726       Klass* klass = SystemDictionary::find(name, class_loader, protection_domain, THREAD);
1727       if (klass == NULL) return true;
1728     }
1729   }
1730   return false;
1731 }
1732 
1733 // Exposed so field engineers can debug VM
1734 void Method::print_short_name(outputStream* st) {
1735   ResourceMark rm;
1736 #ifdef PRODUCT
1737   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;external_name());
1738 #else
1739   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;internal_name());
1740 #endif
1741   name()-&gt;print_symbol_on(st);
1742   if (WizardMode) signature()-&gt;print_symbol_on(st);
1743   else if (MethodHandles::is_signature_polymorphic(intrinsic_id()))
<a name="51" id="anc51"></a><span class="line-modified">1744     MethodHandles::print_as_basic_type_signature_on(st, signature());</span>
1745 }
1746 
1747 // Comparer for sorting an object array containing
1748 // Method*s.
1749 static int method_comparator(Method* a, Method* b) {
1750   return a-&gt;name()-&gt;fast_compare(b-&gt;name());
1751 }
1752 
1753 // This is only done during class loading, so it is OK to assume method_idnum matches the methods() array
1754 // default_methods also uses this without the ordering for fast find_method
<a name="52" id="anc52"></a><span class="line-modified">1755 void Method::sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums, method_comparator_func func) {</span>
1756   int length = methods-&gt;length();
1757   if (length &gt; 1) {
<a name="53" id="anc53"></a><span class="line-added">1758     if (func == NULL) {</span>
<span class="line-added">1759       func = method_comparator;</span>
<span class="line-added">1760     }</span>
1761     {
1762       NoSafepointVerifier nsv;
<a name="54" id="anc54"></a><span class="line-modified">1763       QuickSort::sort(methods-&gt;data(), length, func, /*idempotent=*/false);</span>
1764     }
1765     // Reset method ordering
1766     if (set_idnums) {
1767       for (int i = 0; i &lt; length; i++) {
1768         Method* m = methods-&gt;at(i);
1769         m-&gt;set_method_idnum(i);
1770         m-&gt;set_orig_method_idnum(i);
1771       }
1772     }
1773   }
1774 }
1775 
1776 //-----------------------------------------------------------------------------------
1777 // Non-product code unless JVM/TI needs it
1778 
1779 #if !defined(PRODUCT) || INCLUDE_JVMTI
1780 class SignatureTypePrinter : public SignatureTypeNames {
1781  private:
1782   outputStream* _st;
1783   bool _use_separator;
1784 
1785   void type_name(const char* name) {
1786     if (_use_separator) _st-&gt;print(&quot;, &quot;);
1787     _st-&gt;print(&quot;%s&quot;, name);
1788     _use_separator = true;
1789   }
1790 
1791  public:
1792   SignatureTypePrinter(Symbol* signature, outputStream* st) : SignatureTypeNames(signature) {
1793     _st = st;
1794     _use_separator = false;
1795   }
1796 
<a name="55" id="anc55"></a><span class="line-modified">1797   void print_parameters()              { _use_separator = false; do_parameters_on(this); }</span>
<span class="line-modified">1798   void print_returntype()              { _use_separator = false; do_type(return_type()); }</span>
1799 };
1800 
1801 
1802 void Method::print_name(outputStream* st) {
1803   Thread *thread = Thread::current();
1804   ResourceMark rm(thread);
1805   st-&gt;print(&quot;%s &quot;, is_static() ? &quot;static&quot; : &quot;virtual&quot;);
1806   if (WizardMode) {
1807     st-&gt;print(&quot;%s.&quot;, method_holder()-&gt;internal_name());
1808     name()-&gt;print_symbol_on(st);
1809     signature()-&gt;print_symbol_on(st);
1810   } else {
1811     SignatureTypePrinter sig(signature(), st);
1812     sig.print_returntype();
1813     st-&gt;print(&quot; %s.&quot;, method_holder()-&gt;internal_name());
1814     name()-&gt;print_symbol_on(st);
1815     st-&gt;print(&quot;(&quot;);
1816     sig.print_parameters();
1817     st-&gt;print(&quot;)&quot;);
1818   }
1819 }
1820 #endif // !PRODUCT || INCLUDE_JVMTI
1821 
1822 
1823 void Method::print_codes_on(outputStream* st) const {
1824   print_codes_on(0, code_size(), st);
1825 }
1826 
1827 void Method::print_codes_on(int from, int to, outputStream* st) const {
1828   Thread *thread = Thread::current();
1829   ResourceMark rm(thread);
1830   methodHandle mh (thread, (Method*)this);
1831   BytecodeStream s(mh);
1832   s.set_interval(from, to);
1833   BytecodeTracer::set_closure(BytecodeTracer::std_closure());
1834   while (s.next() &gt;= 0) BytecodeTracer::trace(mh, s.bcp(), st);
1835 }
1836 
1837 CompressedLineNumberReadStream::CompressedLineNumberReadStream(u_char* buffer) : CompressedReadStream(buffer) {
1838   _bci = 0;
1839   _line = 0;
1840 };
1841 
1842 bool CompressedLineNumberReadStream::read_pair() {
1843   jubyte next = read_byte();
1844   // Check for terminator
1845   if (next == 0) return false;
1846   if (next == 0xFF) {
1847     // Escape character, regular compression used
1848     _bci  += read_signed_int();
1849     _line += read_signed_int();
1850   } else {
1851     // Single byte compression used
1852     _bci  += next &gt;&gt; 3;
1853     _line += next &amp; 0x7;
1854   }
1855   return true;
1856 }
1857 
1858 #if INCLUDE_JVMTI
1859 
1860 Bytecodes::Code Method::orig_bytecode_at(int bci) const {
1861   BreakpointInfo* bp = method_holder()-&gt;breakpoints();
1862   for (; bp != NULL; bp = bp-&gt;next()) {
1863     if (bp-&gt;match(this, bci)) {
1864       return bp-&gt;orig_bytecode();
1865     }
1866   }
1867   {
1868     ResourceMark rm;
1869     fatal(&quot;no original bytecode found in %s at bci %d&quot;, name_and_sig_as_C_string(), bci);
1870   }
1871   return Bytecodes::_shouldnotreachhere;
1872 }
1873 
1874 void Method::set_orig_bytecode_at(int bci, Bytecodes::Code code) {
1875   assert(code != Bytecodes::_breakpoint, &quot;cannot patch breakpoints this way&quot;);
1876   BreakpointInfo* bp = method_holder()-&gt;breakpoints();
1877   for (; bp != NULL; bp = bp-&gt;next()) {
1878     if (bp-&gt;match(this, bci)) {
1879       bp-&gt;set_orig_bytecode(code);
1880       // and continue, in case there is more than one
1881     }
1882   }
1883 }
1884 
1885 void Method::set_breakpoint(int bci) {
1886   InstanceKlass* ik = method_holder();
1887   BreakpointInfo *bp = new BreakpointInfo(this, bci);
1888   bp-&gt;set_next(ik-&gt;breakpoints());
1889   ik-&gt;set_breakpoints(bp);
1890   // do this last:
1891   bp-&gt;set(this);
1892 }
1893 
1894 static void clear_matches(Method* m, int bci) {
1895   InstanceKlass* ik = m-&gt;method_holder();
1896   BreakpointInfo* prev_bp = NULL;
1897   BreakpointInfo* next_bp;
1898   for (BreakpointInfo* bp = ik-&gt;breakpoints(); bp != NULL; bp = next_bp) {
1899     next_bp = bp-&gt;next();
1900     // bci value of -1 is used to delete all breakpoints in method m (ex: clear_all_breakpoint).
1901     if (bci &gt;= 0 ? bp-&gt;match(m, bci) : bp-&gt;match(m)) {
1902       // do this first:
1903       bp-&gt;clear(m);
1904       // unhook it
1905       if (prev_bp != NULL)
1906         prev_bp-&gt;set_next(next_bp);
1907       else
1908         ik-&gt;set_breakpoints(next_bp);
1909       delete bp;
1910       // When class is redefined JVMTI sets breakpoint in all versions of EMCP methods
1911       // at same location. So we have multiple matching (method_index and bci)
1912       // BreakpointInfo nodes in BreakpointInfo list. We should just delete one
1913       // breakpoint for clear_breakpoint request and keep all other method versions
1914       // BreakpointInfo for future clear_breakpoint request.
1915       // bcivalue of -1 is used to clear all breakpoints (see clear_all_breakpoints)
1916       // which is being called when class is unloaded. We delete all the Breakpoint
1917       // information for all versions of method. We may not correctly restore the original
1918       // bytecode in all method versions, but that is ok. Because the class is being unloaded
1919       // so these methods won&#39;t be used anymore.
1920       if (bci &gt;= 0) {
1921         break;
1922       }
1923     } else {
1924       // This one is a keeper.
1925       prev_bp = bp;
1926     }
1927   }
1928 }
1929 
1930 void Method::clear_breakpoint(int bci) {
1931   assert(bci &gt;= 0, &quot;&quot;);
1932   clear_matches(this, bci);
1933 }
1934 
1935 void Method::clear_all_breakpoints() {
1936   clear_matches(this, -1);
1937 }
1938 
1939 #endif // INCLUDE_JVMTI
1940 
1941 int Method::invocation_count() {
1942   MethodCounters *mcs = method_counters();
1943   if (TieredCompilation) {
1944     MethodData* const mdo = method_data();
1945     if (((mcs != NULL) ? mcs-&gt;invocation_counter()-&gt;carry() : false) ||
1946         ((mdo != NULL) ? mdo-&gt;invocation_counter()-&gt;carry() : false)) {
1947       return InvocationCounter::count_limit;
1948     } else {
1949       return ((mcs != NULL) ? mcs-&gt;invocation_counter()-&gt;count() : 0) +
1950              ((mdo != NULL) ? mdo-&gt;invocation_counter()-&gt;count() : 0);
1951     }
1952   } else {
1953     return (mcs == NULL) ? 0 : mcs-&gt;invocation_counter()-&gt;count();
1954   }
1955 }
1956 
1957 int Method::backedge_count() {
1958   MethodCounters *mcs = method_counters();
1959   if (TieredCompilation) {
1960     MethodData* const mdo = method_data();
1961     if (((mcs != NULL) ? mcs-&gt;backedge_counter()-&gt;carry() : false) ||
1962         ((mdo != NULL) ? mdo-&gt;backedge_counter()-&gt;carry() : false)) {
1963       return InvocationCounter::count_limit;
1964     } else {
1965       return ((mcs != NULL) ? mcs-&gt;backedge_counter()-&gt;count() : 0) +
1966              ((mdo != NULL) ? mdo-&gt;backedge_counter()-&gt;count() : 0);
1967     }
1968   } else {
1969     return (mcs == NULL) ? 0 : mcs-&gt;backedge_counter()-&gt;count();
1970   }
1971 }
1972 
1973 int Method::highest_comp_level() const {
1974   const MethodCounters* mcs = method_counters();
1975   if (mcs != NULL) {
1976     return mcs-&gt;highest_comp_level();
1977   } else {
1978     return CompLevel_none;
1979   }
1980 }
1981 
1982 int Method::highest_osr_comp_level() const {
1983   const MethodCounters* mcs = method_counters();
1984   if (mcs != NULL) {
1985     return mcs-&gt;highest_osr_comp_level();
1986   } else {
1987     return CompLevel_none;
1988   }
1989 }
1990 
1991 void Method::set_highest_comp_level(int level) {
1992   MethodCounters* mcs = method_counters();
1993   if (mcs != NULL) {
1994     mcs-&gt;set_highest_comp_level(level);
1995   }
1996 }
1997 
1998 void Method::set_highest_osr_comp_level(int level) {
1999   MethodCounters* mcs = method_counters();
2000   if (mcs != NULL) {
2001     mcs-&gt;set_highest_osr_comp_level(level);
2002   }
2003 }
2004 
2005 #if INCLUDE_JVMTI
2006 
2007 BreakpointInfo::BreakpointInfo(Method* m, int bci) {
2008   _bci = bci;
2009   _name_index = m-&gt;name_index();
2010   _signature_index = m-&gt;signature_index();
2011   _orig_bytecode = (Bytecodes::Code) *m-&gt;bcp_from(_bci);
2012   if (_orig_bytecode == Bytecodes::_breakpoint)
2013     _orig_bytecode = m-&gt;orig_bytecode_at(_bci);
2014   _next = NULL;
2015 }
2016 
2017 void BreakpointInfo::set(Method* method) {
2018 #ifdef ASSERT
2019   {
2020     Bytecodes::Code code = (Bytecodes::Code) *method-&gt;bcp_from(_bci);
2021     if (code == Bytecodes::_breakpoint)
2022       code = method-&gt;orig_bytecode_at(_bci);
2023     assert(orig_bytecode() == code, &quot;original bytecode must be the same&quot;);
2024   }
2025 #endif
2026   Thread *thread = Thread::current();
2027   *method-&gt;bcp_from(_bci) = Bytecodes::_breakpoint;
2028   method-&gt;incr_number_of_breakpoints(thread);
<a name="56" id="anc56"></a>
2029   {
2030     // Deoptimize all dependents on this method
2031     HandleMark hm(thread);
2032     methodHandle mh(thread, method);
2033     CodeCache::flush_dependents_on_method(mh);
2034   }
2035 }
2036 
2037 void BreakpointInfo::clear(Method* method) {
2038   *method-&gt;bcp_from(_bci) = orig_bytecode();
2039   assert(method-&gt;number_of_breakpoints() &gt; 0, &quot;must not go negative&quot;);
2040   method-&gt;decr_number_of_breakpoints(Thread::current());
2041 }
2042 
2043 #endif // INCLUDE_JVMTI
2044 
2045 // jmethodID handling
2046 
2047 // This is a block allocating object, sort of like JNIHandleBlock, only a
2048 // lot simpler.
2049 // It&#39;s allocated on the CHeap because once we allocate a jmethodID, we can
2050 // never get rid of it.
2051 
2052 static const int min_block_size = 8;
2053 
2054 class JNIMethodBlockNode : public CHeapObj&lt;mtClass&gt; {
2055   friend class JNIMethodBlock;
2056   Method**        _methods;
2057   int             _number_of_methods;
2058   int             _top;
2059   JNIMethodBlockNode* _next;
2060 
2061  public:
2062 
2063   JNIMethodBlockNode(int num_methods = min_block_size);
2064 
2065   ~JNIMethodBlockNode() { FREE_C_HEAP_ARRAY(Method*, _methods); }
2066 
2067   void ensure_methods(int num_addl_methods) {
2068     if (_top &lt; _number_of_methods) {
2069       num_addl_methods -= _number_of_methods - _top;
2070       if (num_addl_methods &lt;= 0) {
2071         return;
2072       }
2073     }
2074     if (_next == NULL) {
2075       _next = new JNIMethodBlockNode(MAX2(num_addl_methods, min_block_size));
2076     } else {
2077       _next-&gt;ensure_methods(num_addl_methods);
2078     }
2079   }
2080 };
2081 
2082 class JNIMethodBlock : public CHeapObj&lt;mtClass&gt; {
2083   JNIMethodBlockNode _head;
2084   JNIMethodBlockNode *_last_free;
2085  public:
2086   static Method* const _free_method;
2087 
2088   JNIMethodBlock(int initial_capacity = min_block_size)
2089       : _head(initial_capacity), _last_free(&amp;_head) {}
2090 
2091   void ensure_methods(int num_addl_methods) {
2092     _last_free-&gt;ensure_methods(num_addl_methods);
2093   }
2094 
2095   Method** add_method(Method* m) {
2096     for (JNIMethodBlockNode* b = _last_free; b != NULL; b = b-&gt;_next) {
2097       if (b-&gt;_top &lt; b-&gt;_number_of_methods) {
2098         // top points to the next free entry.
2099         int i = b-&gt;_top;
2100         b-&gt;_methods[i] = m;
2101         b-&gt;_top++;
2102         _last_free = b;
2103         return &amp;(b-&gt;_methods[i]);
2104       } else if (b-&gt;_top == b-&gt;_number_of_methods) {
2105         // if the next free entry ran off the block see if there&#39;s a free entry
2106         for (int i = 0; i &lt; b-&gt;_number_of_methods; i++) {
2107           if (b-&gt;_methods[i] == _free_method) {
2108             b-&gt;_methods[i] = m;
2109             _last_free = b;
2110             return &amp;(b-&gt;_methods[i]);
2111           }
2112         }
2113         // Only check each block once for frees.  They&#39;re very unlikely.
2114         // Increment top past the end of the block.
2115         b-&gt;_top++;
2116       }
2117       // need to allocate a next block.
2118       if (b-&gt;_next == NULL) {
2119         b-&gt;_next = _last_free = new JNIMethodBlockNode();
2120       }
2121     }
2122     guarantee(false, &quot;Should always allocate a free block&quot;);
2123     return NULL;
2124   }
2125 
2126   bool contains(Method** m) {
2127     if (m == NULL) return false;
2128     for (JNIMethodBlockNode* b = &amp;_head; b != NULL; b = b-&gt;_next) {
2129       if (b-&gt;_methods &lt;= m &amp;&amp; m &lt; b-&gt;_methods + b-&gt;_number_of_methods) {
2130         // This is a bit of extra checking, for two reasons.  One is
2131         // that contains() deals with pointers that are passed in by
2132         // JNI code, so making sure that the pointer is aligned
2133         // correctly is valuable.  The other is that &lt;= and &gt; are
2134         // technically not defined on pointers, so the if guard can
2135         // pass spuriously; no modern compiler is likely to make that
2136         // a problem, though (and if one did, the guard could also
2137         // fail spuriously, which would be bad).
2138         ptrdiff_t idx = m - b-&gt;_methods;
2139         if (b-&gt;_methods + idx == m) {
2140           return true;
2141         }
2142       }
2143     }
2144     return false;  // not found
2145   }
2146 
2147   // Doesn&#39;t really destroy it, just marks it as free so it can be reused.
2148   void destroy_method(Method** m) {
2149 #ifdef ASSERT
2150     assert(contains(m), &quot;should be a methodID&quot;);
2151 #endif // ASSERT
2152     *m = _free_method;
2153   }
2154 
2155   // During class unloading the methods are cleared, which is different
2156   // than freed.
2157   void clear_all_methods() {
2158     for (JNIMethodBlockNode* b = &amp;_head; b != NULL; b = b-&gt;_next) {
2159       for (int i = 0; i&lt; b-&gt;_number_of_methods; i++) {
2160         b-&gt;_methods[i] = NULL;
2161       }
2162     }
2163   }
2164 #ifndef PRODUCT
2165   int count_methods() {
2166     // count all allocated methods
2167     int count = 0;
2168     for (JNIMethodBlockNode* b = &amp;_head; b != NULL; b = b-&gt;_next) {
2169       for (int i = 0; i&lt; b-&gt;_number_of_methods; i++) {
2170         if (b-&gt;_methods[i] != _free_method) count++;
2171       }
2172     }
2173     return count;
2174   }
2175 #endif // PRODUCT
2176 };
2177 
<a name="57" id="anc57"></a><span class="line-modified">2178 // Something that can&#39;t be mistaken for an address or a markWord</span>
2179 Method* const JNIMethodBlock::_free_method = (Method*)55;
2180 
2181 JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(NULL) {
2182   _number_of_methods = MAX2(num_methods, min_block_size);
2183   _methods = NEW_C_HEAP_ARRAY(Method*, _number_of_methods, mtInternal);
2184   for (int i = 0; i &lt; _number_of_methods; i++) {
2185     _methods[i] = JNIMethodBlock::_free_method;
2186   }
2187 }
2188 
2189 void Method::ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity) {
2190   ClassLoaderData* cld = loader_data;
2191   if (!SafepointSynchronize::is_at_safepoint()) {
2192     // Have to add jmethod_ids() to class loader data thread-safely.
2193     // Also have to add the method to the list safely, which the cld lock
2194     // protects as well.
<a name="58" id="anc58"></a><span class="line-modified">2195     MutexLocker ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
2196     if (cld-&gt;jmethod_ids() == NULL) {
2197       cld-&gt;set_jmethod_ids(new JNIMethodBlock(capacity));
2198     } else {
2199       cld-&gt;jmethod_ids()-&gt;ensure_methods(capacity);
2200     }
2201   } else {
2202     // At safepoint, we are single threaded and can set this.
2203     if (cld-&gt;jmethod_ids() == NULL) {
2204       cld-&gt;set_jmethod_ids(new JNIMethodBlock(capacity));
2205     } else {
2206       cld-&gt;jmethod_ids()-&gt;ensure_methods(capacity);
2207     }
2208   }
2209 }
2210 
2211 // Add a method id to the jmethod_ids
2212 jmethodID Method::make_jmethod_id(ClassLoaderData* loader_data, Method* m) {
2213   ClassLoaderData* cld = loader_data;
2214 
2215   if (!SafepointSynchronize::is_at_safepoint()) {
2216     // Have to add jmethod_ids() to class loader data thread-safely.
2217     // Also have to add the method to the list safely, which the cld lock
2218     // protects as well.
<a name="59" id="anc59"></a><span class="line-modified">2219     MutexLocker ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
2220     if (cld-&gt;jmethod_ids() == NULL) {
2221       cld-&gt;set_jmethod_ids(new JNIMethodBlock());
2222     }
2223     // jmethodID is a pointer to Method*
2224     return (jmethodID)cld-&gt;jmethod_ids()-&gt;add_method(m);
2225   } else {
2226     // At safepoint, we are single threaded and can set this.
2227     if (cld-&gt;jmethod_ids() == NULL) {
2228       cld-&gt;set_jmethod_ids(new JNIMethodBlock());
2229     }
2230     // jmethodID is a pointer to Method*
2231     return (jmethodID)cld-&gt;jmethod_ids()-&gt;add_method(m);
2232   }
2233 }
2234 
<a name="60" id="anc60"></a><span class="line-added">2235 jmethodID Method::jmethod_id() {</span>
<span class="line-added">2236   methodHandle mh(Thread::current(), this);</span>
<span class="line-added">2237   return method_holder()-&gt;get_jmethod_id(mh);</span>
<span class="line-added">2238 }</span>
<span class="line-added">2239 </span>
2240 // Mark a jmethodID as free.  This is called when there is a data race in
2241 // InstanceKlass while creating the jmethodID cache.
2242 void Method::destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID m) {
2243   ClassLoaderData* cld = loader_data;
2244   Method** ptr = (Method**)m;
2245   assert(cld-&gt;jmethod_ids() != NULL, &quot;should have method handles&quot;);
2246   cld-&gt;jmethod_ids()-&gt;destroy_method(ptr);
2247 }
2248 
2249 void Method::change_method_associated_with_jmethod_id(jmethodID jmid, Method* new_method) {
2250   // Can&#39;t assert the method_holder is the same because the new method has the
2251   // scratch method holder.
2252   assert(resolve_jmethod_id(jmid)-&gt;method_holder()-&gt;class_loader()
2253            == new_method-&gt;method_holder()-&gt;class_loader() ||
2254            new_method-&gt;method_holder()-&gt;class_loader() == NULL, // allow Unsafe substitution
2255          &quot;changing to a different class loader&quot;);
2256   // Just change the method in place, jmethodID pointer doesn&#39;t change.
2257   *((Method**)jmid) = new_method;
2258 }
2259 
2260 bool Method::is_method_id(jmethodID mid) {
2261   Method* m = resolve_jmethod_id(mid);
2262   assert(m != NULL, &quot;should be called with non-null method&quot;);
2263   InstanceKlass* ik = m-&gt;method_holder();
2264   ClassLoaderData* cld = ik-&gt;class_loader_data();
2265   if (cld-&gt;jmethod_ids() == NULL) return false;
2266   return (cld-&gt;jmethod_ids()-&gt;contains((Method**)mid));
2267 }
2268 
2269 Method* Method::checked_resolve_jmethod_id(jmethodID mid) {
2270   if (mid == NULL) return NULL;
2271   Method* o = resolve_jmethod_id(mid);
2272   if (o == NULL || o == JNIMethodBlock::_free_method || !((Metadata*)o)-&gt;is_method()) {
2273     return NULL;
2274   }
2275   return o;
2276 };
2277 
2278 void Method::set_on_stack(const bool value) {
2279   // Set both the method itself and its constant pool.  The constant pool
2280   // on stack means some method referring to it is also on the stack.
2281   constants()-&gt;set_on_stack(value);
2282 
2283   bool already_set = on_stack();
2284   _access_flags.set_on_stack(value);
2285   if (value &amp;&amp; !already_set) {
2286     MetadataOnStackMark::record(this);
2287   }
2288   assert(!value || !is_old() || is_obsolete() || is_running_emcp(),
2289          &quot;emcp methods cannot run after emcp bit is cleared&quot;);
2290 }
2291 
2292 // Called when the class loader is unloaded to make all methods weak.
2293 void Method::clear_jmethod_ids(ClassLoaderData* loader_data) {
2294   loader_data-&gt;jmethod_ids()-&gt;clear_all_methods();
2295 }
2296 
2297 bool Method::has_method_vptr(const void* ptr) {
2298   Method m;
2299   // This assumes that the vtbl pointer is the first word of a C++ object.
2300   return dereference_vptr(&amp;m) == dereference_vptr(ptr);
2301 }
2302 
2303 // Check that this pointer is valid by checking that the vtbl pointer matches
2304 bool Method::is_valid_method(const Method* m) {
2305   if (m == NULL) {
2306     return false;
2307   } else if ((intptr_t(m) &amp; (wordSize-1)) != 0) {
2308     // Quick sanity check on pointer.
2309     return false;
2310   } else if (m-&gt;is_shared()) {
2311     return MetaspaceShared::is_valid_shared_method(m);
2312   } else if (Metaspace::contains_non_shared(m)) {
2313     return has_method_vptr((const void*)m);
2314   } else {
2315     return false;
2316   }
2317 }
2318 
2319 #ifndef PRODUCT
2320 void Method::print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) {
2321   out-&gt;print(&quot; jni_method_id count = %d&quot;, loader_data-&gt;jmethod_ids()-&gt;count_methods());
2322 }
2323 #endif // PRODUCT
2324 
2325 
2326 // Printing
2327 
2328 #ifndef PRODUCT
2329 
2330 void Method::print_on(outputStream* st) const {
2331   ResourceMark rm;
2332   assert(is_method(), &quot;must be method&quot;);
2333   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2334   st-&gt;print_cr(&quot; - this oop:          &quot; INTPTR_FORMAT, p2i(this));
2335   st-&gt;print   (&quot; - method holder:     &quot;); method_holder()-&gt;print_value_on(st); st-&gt;cr();
2336   st-&gt;print   (&quot; - constants:         &quot; INTPTR_FORMAT &quot; &quot;, p2i(constants()));
2337   constants()-&gt;print_value_on(st); st-&gt;cr();
2338   st-&gt;print   (&quot; - access:            0x%x  &quot;, access_flags().as_int()); access_flags().print_on(st); st-&gt;cr();
2339   st-&gt;print   (&quot; - name:              &quot;);    name()-&gt;print_value_on(st); st-&gt;cr();
2340   st-&gt;print   (&quot; - signature:         &quot;);    signature()-&gt;print_value_on(st); st-&gt;cr();
2341   st-&gt;print_cr(&quot; - max stack:         %d&quot;,   max_stack());
2342   st-&gt;print_cr(&quot; - max locals:        %d&quot;,   max_locals());
2343   st-&gt;print_cr(&quot; - size of params:    %d&quot;,   size_of_parameters());
2344   st-&gt;print_cr(&quot; - method size:       %d&quot;,   method_size());
2345   if (intrinsic_id() != vmIntrinsics::_none)
2346     st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
2347   if (highest_comp_level() != CompLevel_none)
2348     st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
2349   st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);
2350   st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
2351   st-&gt;print(   &quot; - adapters:          &quot;);
2352   AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
2353   if (a == NULL)
2354     st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
2355   else
2356     a-&gt;print_adapter_on(st);
2357   st-&gt;print_cr(&quot; - compiled entry     &quot; INTPTR_FORMAT, p2i(from_compiled_entry()));
2358   st-&gt;print_cr(&quot; - code size:         %d&quot;,   code_size());
2359   if (code_size() != 0) {
2360     st-&gt;print_cr(&quot; - code start:        &quot; INTPTR_FORMAT, p2i(code_base()));
2361     st-&gt;print_cr(&quot; - code end (excl):   &quot; INTPTR_FORMAT, p2i(code_base() + code_size()));
2362   }
2363   if (method_data() != NULL) {
2364     st-&gt;print_cr(&quot; - method data:       &quot; INTPTR_FORMAT, p2i(method_data()));
2365   }
2366   st-&gt;print_cr(&quot; - checked ex length: %d&quot;,   checked_exceptions_length());
2367   if (checked_exceptions_length() &gt; 0) {
2368     CheckedExceptionElement* table = checked_exceptions_start();
2369     st-&gt;print_cr(&quot; - checked ex start:  &quot; INTPTR_FORMAT, p2i(table));
2370     if (Verbose) {
2371       for (int i = 0; i &lt; checked_exceptions_length(); i++) {
2372         st-&gt;print_cr(&quot;   - throws %s&quot;, constants()-&gt;printable_name_at(table[i].class_cp_index));
2373       }
2374     }
2375   }
2376   if (has_linenumber_table()) {
2377     u_char* table = compressed_linenumber_table();
2378     st-&gt;print_cr(&quot; - linenumber start:  &quot; INTPTR_FORMAT, p2i(table));
2379     if (Verbose) {
2380       CompressedLineNumberReadStream stream(table);
2381       while (stream.read_pair()) {
2382         st-&gt;print_cr(&quot;   - line %d: %d&quot;, stream.line(), stream.bci());
2383       }
2384     }
2385   }
2386   st-&gt;print_cr(&quot; - localvar length:   %d&quot;,   localvariable_table_length());
2387   if (localvariable_table_length() &gt; 0) {
2388     LocalVariableTableElement* table = localvariable_table_start();
2389     st-&gt;print_cr(&quot; - localvar start:    &quot; INTPTR_FORMAT, p2i(table));
2390     if (Verbose) {
2391       for (int i = 0; i &lt; localvariable_table_length(); i++) {
2392         int bci = table[i].start_bci;
2393         int len = table[i].length;
2394         const char* name = constants()-&gt;printable_name_at(table[i].name_cp_index);
2395         const char* desc = constants()-&gt;printable_name_at(table[i].descriptor_cp_index);
2396         int slot = table[i].slot;
2397         st-&gt;print_cr(&quot;   - %s %s bci=%d len=%d slot=%d&quot;, desc, name, bci, len, slot);
2398       }
2399     }
2400   }
2401   if (code() != NULL) {
2402     st-&gt;print   (&quot; - compiled code: &quot;);
2403     code()-&gt;print_value_on(st);
2404   }
2405   if (is_native()) {
2406     st-&gt;print_cr(&quot; - native function:   &quot; INTPTR_FORMAT, p2i(native_function()));
2407     st-&gt;print_cr(&quot; - signature handler: &quot; INTPTR_FORMAT, p2i(signature_handler()));
2408   }
2409 }
2410 
2411 void Method::print_linkage_flags(outputStream* st) {
2412   access_flags().print_on(st);
2413   if (is_default_method()) {
2414     st-&gt;print(&quot;default &quot;);
2415   }
2416   if (is_overpass()) {
2417     st-&gt;print(&quot;overpass &quot;);
2418   }
2419 }
2420 #endif //PRODUCT
2421 
2422 void Method::print_value_on(outputStream* st) const {
2423   assert(is_method(), &quot;must be method&quot;);
2424   st-&gt;print(&quot;%s&quot;, internal_name());
2425   print_address_on(st);
2426   st-&gt;print(&quot; &quot;);
2427   name()-&gt;print_value_on(st);
2428   st-&gt;print(&quot; &quot;);
2429   signature()-&gt;print_value_on(st);
2430   st-&gt;print(&quot; in &quot;);
2431   method_holder()-&gt;print_value_on(st);
2432   if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
2433   if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
2434   if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
2435 }
2436 
<a name="61" id="anc61"></a>
















2437 // LogTouchedMethods and PrintTouchedMethods
2438 
2439 // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
2440 // the Method may be garbage collected. Let&#39;s roll our own hash table.
2441 class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
2442 public:
2443   // It&#39;s OK to store Symbols here because they will NOT be GC&#39;ed if
2444   // LogTouchedMethods is enabled.
2445   TouchedMethodRecord* _next;
2446   Symbol* _class_name;
2447   Symbol* _method_name;
2448   Symbol* _method_signature;
2449 };
2450 
2451 static const int TOUCHED_METHOD_TABLE_SIZE = 20011;
2452 static TouchedMethodRecord** _touched_method_table = NULL;
2453 
2454 void Method::log_touched(TRAPS) {
2455 
2456   const int table_size = TOUCHED_METHOD_TABLE_SIZE;
2457   Symbol* my_class = klass_name();
2458   Symbol* my_name  = name();
2459   Symbol* my_sig   = signature();
2460 
2461   unsigned int hash = my_class-&gt;identity_hash() +
2462                       my_name-&gt;identity_hash() +
2463                       my_sig-&gt;identity_hash();
2464   juint index = juint(hash) % table_size;
2465 
<a name="62" id="anc62"></a><span class="line-modified">2466   MutexLocker ml(THREAD, TouchedMethodLog_lock);</span>
2467   if (_touched_method_table == NULL) {
2468     _touched_method_table = NEW_C_HEAP_ARRAY2(TouchedMethodRecord*, table_size,
2469                                               mtTracing, CURRENT_PC);
2470     memset(_touched_method_table, 0, sizeof(TouchedMethodRecord*)*table_size);
2471   }
2472 
2473   TouchedMethodRecord* ptr = _touched_method_table[index];
2474   while (ptr) {
2475     if (ptr-&gt;_class_name       == my_class &amp;&amp;
2476         ptr-&gt;_method_name      == my_name &amp;&amp;
2477         ptr-&gt;_method_signature == my_sig) {
2478       return;
2479     }
2480     if (ptr-&gt;_next == NULL) break;
2481     ptr = ptr-&gt;_next;
2482   }
2483   TouchedMethodRecord* nptr = NEW_C_HEAP_OBJ(TouchedMethodRecord, mtTracing);
2484   my_class-&gt;increment_refcount();
2485   my_name-&gt;increment_refcount();
2486   my_sig-&gt;increment_refcount();
2487   nptr-&gt;_class_name         = my_class;
2488   nptr-&gt;_method_name        = my_name;
2489   nptr-&gt;_method_signature   = my_sig;
2490   nptr-&gt;_next               = NULL;
2491 
2492   if (ptr == NULL) {
2493     // first
2494     _touched_method_table[index] = nptr;
2495   } else {
2496     ptr-&gt;_next = nptr;
2497   }
2498 }
2499 
2500 void Method::print_touched_methods(outputStream* out) {
<a name="63" id="anc63"></a><span class="line-modified">2501   MutexLocker ml(Thread::current()-&gt;is_VM_thread() ? NULL : TouchedMethodLog_lock);</span>
2502   out-&gt;print_cr(&quot;# Method::print_touched_methods version 1&quot;);
2503   if (_touched_method_table) {
2504     for (int i = 0; i &lt; TOUCHED_METHOD_TABLE_SIZE; i++) {
2505       TouchedMethodRecord* ptr = _touched_method_table[i];
2506       while(ptr) {
2507         ptr-&gt;_class_name-&gt;print_symbol_on(out);       out-&gt;print(&quot;.&quot;);
2508         ptr-&gt;_method_name-&gt;print_symbol_on(out);      out-&gt;print(&quot;:&quot;);
2509         ptr-&gt;_method_signature-&gt;print_symbol_on(out); out-&gt;cr();
2510         ptr = ptr-&gt;_next;
2511       }
2512     }
2513   }
2514 }
2515 
2516 // Verification
2517 
2518 void Method::verify_on(outputStream* st) {
2519   guarantee(is_method(), &quot;object must be method&quot;);
2520   guarantee(constants()-&gt;is_constantPool(), &quot;should be constant pool&quot;);
2521   MethodData* md = method_data();
2522   guarantee(md == NULL ||
2523       md-&gt;is_methodData(), &quot;should be method data&quot;);
2524 }
<a name="64" id="anc64"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="64" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metadata.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,38 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/metadataOnStackMark.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/bytecodeTracer.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed">- #include &quot;memory/heapInspection.hpp&quot;</span>
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/constMethod.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/relocator.hpp&quot;
<span class="line-new-header">--- 23,43 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/metadataOnStackMark.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/bytecodeTracer.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
<span class="line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">+ #include &quot;logging/logTag.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constMethod.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
<span class="line-added">+ #include &quot;oops/objArrayKlass.hpp&quot;</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/relocator.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
    set_vtable_index(Method::garbage_vtable_index);
  
    // Fix and bury in Method*
    set_interpreter_entry(NULL); // sets i2i entry and from_int
    set_adapter_entry(NULL);
<span class="line-modified">!   clear_code(false /* don&#39;t need a lock */); // from_c/from_i get set to c2i/i2i</span>
  
    if (access_flags.is_native()) {
      clear_native_function();
      set_signature_handler(NULL);
    }
<span class="line-new-header">--- 104,11 ---</span>
    set_vtable_index(Method::garbage_vtable_index);
  
    // Fix and bury in Method*
    set_interpreter_entry(NULL); // sets i2i entry and from_int
    set_adapter_entry(NULL);
<span class="line-modified">!   Method::clear_code(); // from_c/from_i get set to c2i/i2i</span>
  
    if (access_flags.is_native()) {
      clear_native_function();
      set_signature_handler(NULL);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,10 ***</span>
<span class="line-new-header">--- 127,20 ---</span>
    clear_method_counters();
    // The nmethod will be gone when we get here.
    if (code() != NULL) _code = NULL;
  }
  
<span class="line-added">+ void Method::release_C_heap_structures() {</span>
<span class="line-added">+   if (method_data()) {</span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     // Destroy MethodData</span>
<span class="line-added">+     method_data()-&gt;~MethodData();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  address Method::get_i2c_entry() {
    assert(adapter() != NULL, &quot;must have&quot;);
    return adapter()-&gt;get_i2c_entry();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,10 ***</span>
<span class="line-new-header">--- 152,16 ---</span>
  address Method::get_c2i_unverified_entry() {
    assert(adapter() != NULL, &quot;must have&quot;);
    return adapter()-&gt;get_c2i_unverified_entry();
  }
  
<span class="line-added">+ address Method::get_c2i_no_clinit_check_entry() {</span>
<span class="line-added">+   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);</span>
<span class="line-added">+   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added">+   return adapter()-&gt;get_c2i_no_clinit_check_entry();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  char* Method::name_and_sig_as_C_string() const {
    return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
  }
  
  char* Method::name_and_sig_as_C_string(char* buf, int size) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,10 ***</span>
<span class="line-new-header">--- 197,31 ---</span>
    }
  
    return buf;
  }
  
<span class="line-added">+ const char* Method::external_name() const {</span>
<span class="line-added">+   return external_name(constants()-&gt;pool_holder(), name(), signature());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Method::print_external_name(outputStream *os) const {</span>
<span class="line-added">+   print_external_name(os, constants()-&gt;pool_holder(), name(), signature());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* Method::external_name(Klass* klass, Symbol* method_name, Symbol* signature) {</span>
<span class="line-added">+   stringStream ss;</span>
<span class="line-added">+   print_external_name(&amp;ss, klass, method_name, signature);</span>
<span class="line-added">+   return ss.as_string();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Method::print_external_name(outputStream *os, Klass* klass, Symbol* method_name, Symbol* signature) {</span>
<span class="line-added">+   signature-&gt;print_as_signature_external_return_type(os);</span>
<span class="line-added">+   os-&gt;print(&quot; %s.%s(&quot;, klass-&gt;external_name(), method_name-&gt;as_C_string());</span>
<span class="line-added">+   signature-&gt;print_as_signature_external_parameters(os);</span>
<span class="line-added">+   os-&gt;print(&quot;)&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int Method::fast_exception_handler_bci_for(const methodHandle&amp; mh, Klass* ex_klass, int throw_bci, TRAPS) {
    // exception table holds quadruple entries of the form (beg_bci, end_bci, handler_bci, klass_index)
    // access exception table
    ExceptionTable table(mh());
    int length = table.length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,22 ***</span>
    int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
    int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
    return align_metadata_size(header_size() + extra_words);
  }
  
<span class="line-removed">- </span>
  Symbol* Method::klass_name() const {
    return method_holder()-&gt;name();
  }
  
<span class="line-removed">- </span>
  void Method::metaspace_pointers_do(MetaspaceClosure* it) {
    log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
  
    it-&gt;push(&amp;_constMethod);
    it-&gt;push(&amp;_method_data);
    it-&gt;push(&amp;_method_counters);
  }
  
  // Attempt to return method oop to original state.  Clear any pointers
  // (to objects outside the shared spaces).  We won&#39;t be able to predict
  // where they should point in a new JVM.  Further initialize some
<span class="line-new-header">--- 330,25 ---</span>
    int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
    int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
    return align_metadata_size(header_size() + extra_words);
  }
  
  Symbol* Method::klass_name() const {
    return method_holder()-&gt;name();
  }
  
  void Method::metaspace_pointers_do(MetaspaceClosure* it) {
    log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
  
    it-&gt;push(&amp;_constMethod);
    it-&gt;push(&amp;_method_data);
    it-&gt;push(&amp;_method_counters);
<span class="line-added">+ </span>
<span class="line-added">+   Method* this_ptr = this;</span>
<span class="line-added">+   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);</span>
<span class="line-added">+   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);</span>
<span class="line-added">+   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);</span>
  }
  
  // Attempt to return method oop to original state.  Clear any pointers
  // (to objects outside the shared spaces).  We won&#39;t be able to predict
  // where they should point in a new JVM.  Further initialize some
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,11 ***</span>
<span class="line-new-header">--- 382,87 ---</span>
      _vtable_index = itable_index_max - index;
    }
    assert(valid_itable_index(), &quot;&quot;);
  }
  
<span class="line-added">+ // The RegisterNatives call being attempted tried to register with a method that</span>
<span class="line-added">+ // is not native.  Ask JVM TI what prefixes have been specified.  Then check</span>
<span class="line-added">+ // to see if the native method is now wrapped with the prefixes.  See the</span>
<span class="line-added">+ // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.</span>
<span class="line-added">+ static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {</span>
<span class="line-added">+ #if INCLUDE_JVMTI</span>
<span class="line-added">+   ResourceMark rm(THREAD);</span>
<span class="line-added">+   Method* method;</span>
<span class="line-added">+   int name_len = name-&gt;utf8_length();</span>
<span class="line-added">+   char* name_str = name-&gt;as_utf8();</span>
<span class="line-added">+   int prefix_count;</span>
<span class="line-added">+   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);</span>
<span class="line-added">+   for (int i = 0; i &lt; prefix_count; i++) {</span>
<span class="line-added">+     char* prefix = prefixes[i];</span>
<span class="line-added">+     int prefix_len = (int)strlen(prefix);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // try adding this prefix to the method name and see if it matches another method name</span>
<span class="line-added">+     int trial_len = name_len + prefix_len;</span>
<span class="line-added">+     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);</span>
<span class="line-added">+     strcpy(trial_name_str, prefix);</span>
<span class="line-added">+     strcat(trial_name_str, name_str);</span>
<span class="line-added">+     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);</span>
<span class="line-added">+     if (trial_name == NULL) {</span>
<span class="line-added">+       continue; // no such symbol, so this prefix wasn&#39;t used, try the next prefix</span>
<span class="line-added">+     }</span>
<span class="line-added">+     method = k-&gt;lookup_method(trial_name, signature);</span>
<span class="line-added">+     if (method == NULL) {</span>
<span class="line-added">+       continue; // signature doesn&#39;t match, try the next prefix</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (method-&gt;is_native()) {</span>
<span class="line-added">+       method-&gt;set_is_prefixed_native();</span>
<span class="line-added">+       return method; // wahoo, we found a prefixed version of the method, return it</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // found as non-native, so prefix is good, add it, probably just need more prefixes</span>
<span class="line-added">+     name_len = trial_len;</span>
<span class="line-added">+     name_str = trial_name_str;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif // INCLUDE_JVMTI</span>
<span class="line-added">+   return NULL; // not found</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Method::register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {</span>
<span class="line-added">+   Method* method = k-&gt;lookup_method(name, signature);</span>
<span class="line-added">+   if (method == NULL) {</span>
<span class="line-added">+     ResourceMark rm(THREAD);</span>
<span class="line-added">+     stringStream st;</span>
<span class="line-added">+     st.print(&quot;Method &#39;&quot;);</span>
<span class="line-added">+     print_external_name(&amp;st, k, name, signature);</span>
<span class="line-added">+     st.print(&quot;&#39; name or signature does not match&quot;);</span>
<span class="line-added">+     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!method-&gt;is_native()) {</span>
<span class="line-added">+     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)</span>
<span class="line-added">+     method = find_prefixed_native(k, name, signature, THREAD);</span>
<span class="line-added">+     if (method == NULL) {</span>
<span class="line-added">+       ResourceMark rm(THREAD);</span>
<span class="line-added">+       stringStream st;</span>
<span class="line-added">+       st.print(&quot;Method &#39;&quot;);</span>
<span class="line-added">+       print_external_name(&amp;st, k, name, signature);</span>
<span class="line-added">+       st.print(&quot;&#39; is not declared as native&quot;);</span>
<span class="line-added">+       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
<span class="line-added">+   if (entry != NULL) {</span>
<span class="line-added">+     method-&gt;set_native_function(entry, native_bind_event_is_interesting);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     method-&gt;clear_native_function();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (log_is_enabled(Debug, jni, resolve)) {</span>
<span class="line-added">+     ResourceMark rm(THREAD);</span>
<span class="line-added">+     log_debug(jni, resolve)(&quot;[Registering JNI native method %s.%s]&quot;,</span>
<span class="line-added">+                             method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added">+                             method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
  
  bool Method::was_executed_more_than(int n) {
    // Invocation counter is reset when the Method* is compiled.
    // If the method has compiled code we therefore assume it has
    // be excuted more than n times.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,11 ***</span>
      return;
    }
  
    // Grab a lock here to prevent multiple
    // MethodData*s from being created.
<span class="line-modified">!   MutexLocker ml(MethodData_lock, THREAD);</span>
    if (method-&gt;method_data() == NULL) {
      ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
      MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);
      if (HAS_PENDING_EXCEPTION) {
        CompileBroker::log_metaspace_failure();
<span class="line-new-header">--- 520,11 ---</span>
      return;
    }
  
    // Grab a lock here to prevent multiple
    // MethodData*s from being created.
<span class="line-modified">!   MutexLocker ml(THREAD, MethodData_lock);</span>
    if (method-&gt;method_data() == NULL) {
      ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
      MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);
      if (HAS_PENDING_EXCEPTION) {
        CompileBroker::log_metaspace_failure();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,11 ***</span>
    // Do not profile the method if metaspace has hit an OOM previously
    if (ClassLoaderDataGraph::has_metaspace_oom()) {
      return NULL;
    }
  
<span class="line-modified">!   methodHandle mh(m);</span>
    MethodCounters* counters = MethodCounters::allocate(mh, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CompileBroker::log_metaspace_failure();
      ClassLoaderDataGraph::set_metaspace_oom(true);
      return NULL;   // return the exception (which is cleared)
<span class="line-new-header">--- 547,11 ---</span>
    // Do not profile the method if metaspace has hit an OOM previously
    if (ClassLoaderDataGraph::has_metaspace_oom()) {
      return NULL;
    }
  
<span class="line-modified">!   methodHandle mh(THREAD, m);</span>
    MethodCounters* counters = MethodCounters::allocate(mh, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CompileBroker::log_metaspace_failure();
      ClassLoaderDataGraph::set_metaspace_oom(true);
      return NULL;   // return the exception (which is cleared)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,36 ***</span>
    return mh-&gt;method_counters();
  }
  
  bool Method::init_method_counters(MethodCounters* counters) {
    // Try to install a pointer to MethodCounters, return true on success.
<span class="line-modified">!   return Atomic::replace_if_null(counters, &amp;_method_counters);</span>
  }
  
  int Method::extra_stack_words() {
    // not an inline function, to avoid a header dependency on Interpreter
    return extra_stack_entries() * Interpreter::stackElementSize;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! void Method::compute_size_of_parameters(Thread *thread) {</span>
<span class="line-modified">!   ArgumentSizeComputer asc(signature());</span>
<span class="line-modified">!   set_size_of_parameters(asc.size() + (is_static() ? 0 : 1));</span>
  }
  
<span class="line-removed">- BasicType Method::result_type() const {</span>
<span class="line-removed">-   ResultTypeFinder rtf(signature());</span>
<span class="line-removed">-   return rtf.type();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  bool Method::is_empty_method() const {
    return  code_size() == 1
        &amp;&amp; *code_base() == Bytecodes::_return;
  }
  
<span class="line-removed">- </span>
  bool Method::is_vanilla_constructor() const {
    // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
    // which only calls the superclass vanilla constructor and possibly does stores of
    // zero constants to local fields:
    //
<span class="line-new-header">--- 567,35 ---</span>
    return mh-&gt;method_counters();
  }
  
  bool Method::init_method_counters(MethodCounters* counters) {
    // Try to install a pointer to MethodCounters, return true on success.
<span class="line-modified">!   return Atomic::replace_if_null(&amp;_method_counters, counters);</span>
  }
  
  int Method::extra_stack_words() {
    // not an inline function, to avoid a header dependency on Interpreter
    return extra_stack_entries() * Interpreter::stackElementSize;
  }
  
<span class="line-modified">! // Derive size of parameters, return type, and fingerprint,</span>
<span class="line-modified">! // all in one pass, which is run at load time.</span>
<span class="line-modified">! // We need the first two, and might as well grab the third.</span>
<span class="line-modified">! void Method::compute_from_signature(Symbol* sig) {</span>
<span class="line-added">+   // At this point, since we are scanning the signature,</span>
<span class="line-added">+   // we might as well compute the whole fingerprint.</span>
<span class="line-added">+   Fingerprinter fp(sig, is_static());</span>
<span class="line-added">+   set_size_of_parameters(fp.size_of_parameters());</span>
<span class="line-added">+   constMethod()-&gt;set_result_type(fp.return_type());</span>
<span class="line-added">+   constMethod()-&gt;set_fingerprint(fp.fingerprint());</span>
  }
  
  bool Method::is_empty_method() const {
    return  code_size() == 1
        &amp;&amp; *code_base() == Bytecodes::_return;
  }
  
  bool Method::is_vanilla_constructor() const {
    // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
    // which only calls the superclass vanilla constructor and possibly does stores of
    // zero constants to local fields:
    //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 516,11 ***</span>
    return true;
  }
  
  
  bool Method::compute_has_loops_flag() {
<span class="line-modified">!   BytecodeStream bcs(this);</span>
    Bytecodes::Code bc;
  
    while ((bc = bcs.next()) &gt;= 0) {
      switch( bc ) {
        case Bytecodes::_ifeq:
<span class="line-new-header">--- 636,11 ---</span>
    return true;
  }
  
  
  bool Method::compute_has_loops_flag() {
<span class="line-modified">!   BytecodeStream bcs(methodHandle(Thread::current(), this));</span>
    Bytecodes::Code bc;
  
    while ((bc = bcs.next()) &gt;= 0) {
      switch( bc ) {
        case Bytecodes::_ifeq:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,10 ***</span>
<span class="line-new-header">--- 716,14 ---</span>
  
  bool Method::can_be_statically_bound() const {
    return can_be_statically_bound(method_holder()-&gt;access_flags());
  }
  
<span class="line-added">+ bool Method::can_be_statically_bound(InstanceKlass* context) const {</span>
<span class="line-added">+   return (method_holder() == context) &amp;&amp; can_be_statically_bound();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool Method::is_accessor() const {
    return is_getter() || is_setter();
  }
  
  bool Method::is_getter() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,10 ***</span>
<span class="line-new-header">--- 794,14 ---</span>
  
  bool Method::is_object_initializer() const {
     return name() == vmSymbols::object_initializer_name();
  }
  
<span class="line-added">+ bool Method::needs_clinit_barrier() const {</span>
<span class="line-added">+   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
    int length = method-&gt;checked_exceptions_length();
    if (length == 0) {  // common case
      return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 681,11 ***</span>
      objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
      objArrayHandle mirrors (THREAD, m_oop);
      for (int i = 0; i &lt; length; i++) {
        CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
        Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
<span class="line-modified">!       assert(k-&gt;is_subclass_of(SystemDictionary::Throwable_klass()), &quot;invalid exception class&quot;);</span>
        mirrors-&gt;obj_at_put(i, k-&gt;java_mirror());
      }
      return mirrors;
    }
  };
<span class="line-new-header">--- 809,17 ---</span>
      objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
      objArrayHandle mirrors (THREAD, m_oop);
      for (int i = 0; i &lt; length; i++) {
        CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
        Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
<span class="line-modified">!       if (log_is_enabled(Warning, exceptions) &amp;&amp;</span>
<span class="line-added">+           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {</span>
<span class="line-added">+         ResourceMark rm(THREAD);</span>
<span class="line-added">+         log_warning(exceptions)(</span>
<span class="line-added">+           &quot;Class %s in throws clause of method %s is not a subtype of class java.lang.Throwable&quot;,</span>
<span class="line-added">+           k-&gt;external_name(), method-&gt;external_name());</span>
<span class="line-added">+       }</span>
        mirrors-&gt;obj_at_put(i, k-&gt;java_mirror());
      }
      return mirrors;
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 781,36 ***</span>
  void Method::clear_native_function() {
    // Note: is_method_handle_intrinsic() is allowed here.
    set_native_function(
      SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
      !native_bind_event_is_interesting);
<span class="line-modified">!   clear_code();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- address Method::critical_native_function() {</span>
<span class="line-removed">-   methodHandle mh(this);</span>
<span class="line-removed">-   return NativeLookup::lookup_critical_entry(mh);</span>
  }
  
  
  void Method::set_signature_handler(address handler) {
    address* signature_handler =  signature_handler_addr();
    *signature_handler = handler;
  }
  
  
  void Method::print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason) {
    if (PrintCompilation &amp;&amp; report) {
      ttyLocker ttyl;
      tty-&gt;print(&quot;made not %scompilable on &quot;, is_osr ? &quot;OSR &quot; : &quot;&quot;);
      if (comp_level == CompLevel_all) {
        tty-&gt;print(&quot;all levels &quot;);
      } else {
<span class="line-modified">!       tty-&gt;print(&quot;levels &quot;);</span>
<span class="line-removed">-       for (int i = (int)CompLevel_none; i &lt;= comp_level; i++) {</span>
<span class="line-removed">-         tty-&gt;print(&quot;%d &quot;, i);</span>
<span class="line-removed">-       }</span>
      }
      this-&gt;print_short_name(tty);
      int size = this-&gt;code_size();
      if (size &gt; 0) {
        tty-&gt;print(&quot; (%d bytes)&quot;, size);
<span class="line-new-header">--- 915,29 ---</span>
  void Method::clear_native_function() {
    // Note: is_method_handle_intrinsic() is allowed here.
    set_native_function(
      SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
      !native_bind_event_is_interesting);
<span class="line-modified">!   this-&gt;unlink_code();</span>
  }
  
  
  void Method::set_signature_handler(address handler) {
    address* signature_handler =  signature_handler_addr();
    *signature_handler = handler;
  }
  
  
  void Method::print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason) {
<span class="line-added">+   assert(reason != NULL, &quot;must provide a reason&quot;);</span>
    if (PrintCompilation &amp;&amp; report) {
      ttyLocker ttyl;
      tty-&gt;print(&quot;made not %scompilable on &quot;, is_osr ? &quot;OSR &quot; : &quot;&quot;);
      if (comp_level == CompLevel_all) {
        tty-&gt;print(&quot;all levels &quot;);
      } else {
<span class="line-modified">!       tty-&gt;print(&quot;level %d &quot;, comp_level);</span>
      }
      this-&gt;print_short_name(tty);
      int size = this-&gt;code_size();
      if (size &gt; 0) {
        tty-&gt;print(&quot; (%d bytes)&quot;, size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,11 ***</span>
      return is_not_c2_compilable();
    return false;
  }
  
  // call this when compiler finds that this method is not compilable
<span class="line-modified">! void Method::set_not_compilable(int comp_level, bool report, const char* reason) {</span>
    if (is_always_compilable()) {
      // Don&#39;t mark a method which should be always compilable
      return;
    }
    print_made_not_compilable(comp_level, /*is_osr*/ false, report, reason);
<span class="line-new-header">--- 984,11 ---</span>
      return is_not_c2_compilable();
    return false;
  }
  
  // call this when compiler finds that this method is not compilable
<span class="line-modified">! void Method::set_not_compilable(const char* reason, int comp_level, bool report) {</span>
    if (is_always_compilable()) {
      // Don&#39;t mark a method which should be always compilable
      return;
    }
    print_made_not_compilable(comp_level, /*is_osr*/ false, report, reason);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 872,12 ***</span>
      if (is_c1_compile(comp_level))
        set_not_c1_compilable();
      if (is_c2_compile(comp_level))
        set_not_c2_compilable();
    }
<span class="line-modified">!   CompilationPolicy::policy()-&gt;disable_compilation(this);</span>
<span class="line-removed">-   assert(!CompilationPolicy::can_be_compiled(this, comp_level), &quot;sanity check&quot;);</span>
  }
  
  bool Method::is_not_osr_compilable(int comp_level) const {
    if (is_not_compilable(comp_level))
      return true;
<span class="line-new-header">--- 999,11 ---</span>
      if (is_c1_compile(comp_level))
        set_not_c1_compilable();
      if (is_c2_compile(comp_level))
        set_not_c2_compilable();
    }
<span class="line-modified">!   assert(!CompilationPolicy::can_be_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);</span>
  }
  
  bool Method::is_not_osr_compilable(int comp_level) const {
    if (is_not_compilable(comp_level))
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 888,28 ***</span>
    if (is_c2_compile(comp_level))
      return is_not_c2_osr_compilable();
    return false;
  }
  
<span class="line-modified">! void Method::set_not_osr_compilable(int comp_level, bool report, const char* reason) {</span>
    print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
    if (comp_level == CompLevel_all) {
      set_not_c1_osr_compilable();
      set_not_c2_osr_compilable();
    } else {
      if (is_c1_compile(comp_level))
        set_not_c1_osr_compilable();
      if (is_c2_compile(comp_level))
        set_not_c2_osr_compilable();
    }
<span class="line-modified">!   CompilationPolicy::policy()-&gt;disable_compilation(this);</span>
<span class="line-removed">-   assert(!CompilationPolicy::can_be_osr_compiled(this, comp_level), &quot;sanity check&quot;);</span>
  }
  
  // Revert to using the interpreter and clear out the nmethod
<span class="line-modified">! void Method::clear_code(bool acquire_lock /* = true */) {</span>
<span class="line-removed">-   MutexLockerEx pl(acquire_lock ? Patching_lock : NULL, Mutex::_no_safepoint_check_flag);</span>
    // this may be NULL if c2i adapters have not been made yet
    // Only should happen at allocate time.
    if (adapter() == NULL) {
      _from_compiled_entry    = NULL;
    } else {
<span class="line-new-header">--- 1014,26 ---</span>
    if (is_c2_compile(comp_level))
      return is_not_c2_osr_compilable();
    return false;
  }
  
<span class="line-modified">! void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {</span>
    print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
    if (comp_level == CompLevel_all) {
      set_not_c1_osr_compilable();
      set_not_c2_osr_compilable();
    } else {
      if (is_c1_compile(comp_level))
        set_not_c1_osr_compilable();
      if (is_c2_compile(comp_level))
        set_not_c2_osr_compilable();
    }
<span class="line-modified">!   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);</span>
  }
  
  // Revert to using the interpreter and clear out the nmethod
<span class="line-modified">! void Method::clear_code() {</span>
    // this may be NULL if c2i adapters have not been made yet
    // Only should happen at allocate time.
    if (adapter() == NULL) {
      _from_compiled_entry    = NULL;
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 919,32 ***</span>
    _from_interpreted_entry = _i2i_entry;
    OrderAccess::storestore();
    _code = NULL;
  }
  
  #if INCLUDE_CDS
  // Called by class data sharing to remove any entry points (which are not shared)
  void Method::unlink_method() {
    _code = NULL;
  
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
    // Set the values to what they should be at run time. Note that
    // this Method can no longer be executed during dump time.
<span class="line-modified">!   _i2i_entry = Interpreter::entry_for_cds_method(this);</span>
    _from_interpreted_entry = _i2i_entry;
  
    if (is_native()) {
      *native_function_addr() = NULL;
      set_signature_handler(NULL);
    }
    NOT_PRODUCT(set_compiled_invocation_count(0);)
  
<span class="line-removed">-   CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();</span>
<span class="line-removed">-   constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());</span>
<span class="line-removed">-   _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();</span>
<span class="line-removed">-   assert(*((int*)_from_compiled_entry) == 0, &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>
<span class="line-removed">- </span>
    set_method_data(NULL);
    clear_method_counters();
  }
  #endif
  
<span class="line-new-header">--- 1043,58 ---</span>
    _from_interpreted_entry = _i2i_entry;
    OrderAccess::storestore();
    _code = NULL;
  }
  
<span class="line-added">+ void Method::unlink_code(CompiledMethod *compare) {</span>
<span class="line-added">+   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   // We need to check if either the _code or _from_compiled_code_entry_point</span>
<span class="line-added">+   // refer to this nmethod because there is a race in setting these two fields</span>
<span class="line-added">+   // in Method* as seen in bugid 4947125.</span>
<span class="line-added">+   // If the vep() points to the zombie nmethod, the memory for the nmethod</span>
<span class="line-added">+   // could be flushed and the compiler and vtable stubs could still call</span>
<span class="line-added">+   // through it.</span>
<span class="line-added">+   if (code() == compare ||</span>
<span class="line-added">+       from_compiled_entry() == compare-&gt;verified_entry_point()) {</span>
<span class="line-added">+     clear_code();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Method::unlink_code() {</span>
<span class="line-added">+   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   clear_code();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if INCLUDE_CDS
  // Called by class data sharing to remove any entry points (which are not shared)
  void Method::unlink_method() {
    _code = NULL;
  
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
    // Set the values to what they should be at run time. Note that
    // this Method can no longer be executed during dump time.
<span class="line-modified">!   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));</span>
    _from_interpreted_entry = _i2i_entry;
  
<span class="line-added">+   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // TODO: Simplify the adapter trampoline allocation for static archiving.</span>
<span class="line-added">+     //       Remove the use of CDSAdapterHandlerEntry.</span>
<span class="line-added">+     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();</span>
<span class="line-added">+     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());</span>
<span class="line-added">+     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();</span>
<span class="line-added">+     assert(*((int*)_from_compiled_entry) == 0,</span>
<span class="line-added">+            &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (is_native()) {
      *native_function_addr() = NULL;
      set_signature_handler(NULL);
    }
    NOT_PRODUCT(set_compiled_invocation_count(0);)
  
    set_method_data(NULL);
    clear_method_counters();
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1002,11 ***</span>
                                                   +----&gt; [AdapterHandlerEntry] (allocated at run time)
                                                                _fingerprint
                                                                _c2i_entry ---------------------------------+-&gt;[c2i entry..]
   _i2i_entry  -------------+                                   _i2c_entry ---------------+-&gt; [i2c entry..] |
   _from_interpreted_entry  |                                   _c2i_unverified_entry     |                 |
<span class="line-modified">!          |                |                                                             |                 |</span>
           |                |  (_cds_entry_table: CODE)                                   |                 |
           |                +-&gt;[0]: jmp _entry_table[0] --&gt; (i2i_entry_for &quot;zero_locals&quot;) |                 |
           |                |                               (allocated at run time)       |                 |
           |                |  ...                           [asm code ...]               |                 |
           +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |
<span class="line-new-header">--- 1152,11 ---</span>
                                                   +----&gt; [AdapterHandlerEntry] (allocated at run time)
                                                                _fingerprint
                                                                _c2i_entry ---------------------------------+-&gt;[c2i entry..]
   _i2i_entry  -------------+                                   _i2c_entry ---------------+-&gt; [i2c entry..] |
   _from_interpreted_entry  |                                   _c2i_unverified_entry     |                 |
<span class="line-modified">!          |                |                                   _c2i_no_clinit_check_entry|                 |</span>
           |                |  (_cds_entry_table: CODE)                                   |                 |
           |                +-&gt;[0]: jmp _entry_table[0] --&gt; (i2i_entry_for &quot;zero_locals&quot;) |                 |
           |                |                               (allocated at run time)       |                 |
           |                |  ...                           [asm code ...]               |                 |
           +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1106,11 ***</span>
      link_method(mh, CHECK);
    }
  }
  
  address Method::from_compiled_entry_no_trampoline() const {
<span class="line-modified">!   CompiledMethod *code = OrderAccess::load_acquire(&amp;_code);</span>
    if (code) {
      return code-&gt;verified_entry_point();
    } else {
      return adapter()-&gt;get_c2i_entry();
    }
<span class="line-new-header">--- 1256,11 ---</span>
      link_method(mh, CHECK);
    }
  }
  
  address Method::from_compiled_entry_no_trampoline() const {
<span class="line-modified">!   CompiledMethod *code = Atomic::load_acquire(&amp;_code);</span>
    if (code) {
      return code-&gt;verified_entry_point();
    } else {
      return adapter()-&gt;get_c2i_entry();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1132,17 ***</span>
  // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
  // (could be racing a deopt).
  // Not inline to avoid circular ref.
  bool Method::check_code() const {
    // cached in a register or local.  There&#39;s a race on the value of the field.
<span class="line-modified">!   CompiledMethod *code = OrderAccess::load_acquire(&amp;_code);</span>
    return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
  }
  
  // Install compiled code.  Instantly it can execute.
  void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
<span class="line-modified">!   MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
    assert( code, &quot;use clear_code to remove code&quot; );
    assert( mh-&gt;check_code(), &quot;&quot; );
  
    guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
  
<span class="line-new-header">--- 1282,17 ---</span>
  // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
  // (could be racing a deopt).
  // Not inline to avoid circular ref.
  bool Method::check_code() const {
    // cached in a register or local.  There&#39;s a race on the value of the field.
<span class="line-modified">!   CompiledMethod *code = Atomic::load_acquire(&amp;_code);</span>
    return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
  }
  
  // Install compiled code.  Instantly it can execute.
  void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
<span class="line-modified">!   assert_lock_strong(CompiledMethod_lock);</span>
    assert( code, &quot;use clear_code to remove code&quot; );
    assert( mh-&gt;check_code(), &quot;&quot; );
  
    guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1257,11 ***</span>
  
  // Make an instance of a signature-polymorphic internal MH primitive.
  methodHandle Method::make_method_handle_intrinsic(vmIntrinsics::ID iid,
                                                           Symbol* signature,
                                                           TRAPS) {
<span class="line-modified">!   ResourceMark rm;</span>
    methodHandle empty;
  
    InstanceKlass* holder = SystemDictionary::MethodHandle_klass();
    Symbol* name = MethodHandles::signature_polymorphic_intrinsic_name(iid);
    assert(iid == MethodHandles::signature_polymorphic_name_id(name), &quot;&quot;);
<span class="line-new-header">--- 1407,11 ---</span>
  
  // Make an instance of a signature-polymorphic internal MH primitive.
  methodHandle Method::make_method_handle_intrinsic(vmIntrinsics::ID iid,
                                                           Symbol* signature,
                                                           TRAPS) {
<span class="line-modified">!   ResourceMark rm(THREAD);</span>
    methodHandle empty;
  
    InstanceKlass* holder = SystemDictionary::MethodHandle_klass();
    Symbol* name = MethodHandles::signature_polymorphic_intrinsic_name(iid);
    assert(iid == MethodHandles::signature_polymorphic_name_id(name), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1302,13 ***</span>
    m-&gt;set_constants(cp());
    m-&gt;set_name_index(_imcp_invoke_name);
    m-&gt;set_signature_index(_imcp_invoke_signature);
    assert(MethodHandles::is_signature_polymorphic_name(m-&gt;name()), &quot;&quot;);
    assert(m-&gt;signature() == signature, &quot;&quot;);
<span class="line-modified">!   ResultTypeFinder rtf(signature);</span>
<span class="line-removed">-   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
<span class="line-removed">-   m-&gt;compute_size_of_parameters(THREAD);</span>
    m-&gt;init_intrinsic_id();
    assert(m-&gt;is_method_handle_intrinsic(), &quot;&quot;);
  #ifdef ASSERT
    if (!MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()))  m-&gt;print();
    assert(MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()), &quot;must be an invoker&quot;);
<span class="line-new-header">--- 1452,11 ---</span>
    m-&gt;set_constants(cp());
    m-&gt;set_name_index(_imcp_invoke_name);
    m-&gt;set_signature_index(_imcp_invoke_signature);
    assert(MethodHandles::is_signature_polymorphic_name(m-&gt;name()), &quot;&quot;);
    assert(m-&gt;signature() == signature, &quot;&quot;);
<span class="line-modified">!   m-&gt;compute_from_signature(signature);</span>
    m-&gt;init_intrinsic_id();
    assert(m-&gt;is_method_handle_intrinsic(), &quot;&quot;);
  #ifdef ASSERT
    if (!MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()))  m-&gt;print();
    assert(MethodHandles::is_signature_polymorphic(m-&gt;intrinsic_id()), &quot;must be an invoker&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1432,18 ***</span>
    }
    // Copy stackmap table
    if (m-&gt;has_stackmap_table()) {
      int code_attribute_length = m-&gt;stackmap_data()-&gt;length();
      Array&lt;u1&gt;* stackmap_data =
<span class="line-modified">!       MetadataFactory::new_array&lt;u1&gt;(loader_data, code_attribute_length, 0, CHECK_NULL);</span>
      memcpy((void*)stackmap_data-&gt;adr_at(0),
             (void*)m-&gt;stackmap_data()-&gt;adr_at(0), code_attribute_length);
      newm-&gt;set_stackmap_data(stackmap_data);
    }
  
    // copy annotations over to new method
<span class="line-modified">!   newcm-&gt;copy_annotations_from(loader_data, cm, CHECK_NULL);</span>
    return newm;
  }
  
  vmSymbols::SID Method::klass_id_for_intrinsics(const Klass* holder) {
    // if loader is not the default loader (i.e., != NULL), we can&#39;t know the intrinsics
<span class="line-new-header">--- 1580,18 ---</span>
    }
    // Copy stackmap table
    if (m-&gt;has_stackmap_table()) {
      int code_attribute_length = m-&gt;stackmap_data()-&gt;length();
      Array&lt;u1&gt;* stackmap_data =
<span class="line-modified">!       MetadataFactory::new_array&lt;u1&gt;(loader_data, code_attribute_length, 0, CHECK_(methodHandle()));</span>
      memcpy((void*)stackmap_data-&gt;adr_at(0),
             (void*)m-&gt;stackmap_data()-&gt;adr_at(0), code_attribute_length);
      newm-&gt;set_stackmap_data(stackmap_data);
    }
  
    // copy annotations over to new method
<span class="line-modified">!   newcm-&gt;copy_annotations_from(loader_data, cm, CHECK_(methodHandle()));</span>
    return newm;
  }
  
  vmSymbols::SID Method::klass_id_for_intrinsics(const Klass* holder) {
    // if loader is not the default loader (i.e., != NULL), we can&#39;t know the intrinsics
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1544,12 ***</span>
    Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());
    Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
    ResourceMark rm(THREAD);
    Symbol*  signature = m-&gt;signature();
    for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
<span class="line-modified">!     if (ss.is_object()) {</span>
<span class="line-modified">!       Symbol* sym = ss.as_symbol(CHECK_(false));</span>
        Symbol*  name  = sym;
        Klass* klass = SystemDictionary::resolve_or_null(name, class_loader,
                                               protection_domain, THREAD);
        // We are loading classes eagerly. If a ClassNotFoundException or
        // a LinkageError was generated, be sure to ignore it.
<span class="line-new-header">--- 1692,12 ---</span>
    Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());
    Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
    ResourceMark rm(THREAD);
    Symbol*  signature = m-&gt;signature();
    for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
<span class="line-modified">!     if (ss.is_reference()) {</span>
<span class="line-modified">!       Symbol* sym = ss.as_symbol();</span>
        Symbol*  name  = sym;
        Klass* klass = SystemDictionary::resolve_or_null(name, class_loader,
                                               protection_domain, THREAD);
        // We are loading classes eagerly. If a ClassNotFoundException or
        // a LinkageError was generated, be sure to ignore it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1572,12 ***</span>
    Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
    ResourceMark rm(THREAD);
    Symbol*  signature = m-&gt;signature();
    for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
      if (ss.type() == T_OBJECT) {
<span class="line-modified">!       Symbol* name = ss.as_symbol_or_null();</span>
<span class="line-removed">-       if (name == NULL) return true;</span>
        Klass* klass = SystemDictionary::find(name, class_loader, protection_domain, THREAD);
        if (klass == NULL) return true;
      }
    }
    return false;
<span class="line-new-header">--- 1720,11 ---</span>
    Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());
    ResourceMark rm(THREAD);
    Symbol*  signature = m-&gt;signature();
    for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {
      if (ss.type() == T_OBJECT) {
<span class="line-modified">!       Symbol* name = ss.as_symbol();</span>
        Klass* klass = SystemDictionary::find(name, class_loader, protection_domain, THREAD);
        if (klass == NULL) return true;
      }
    }
    return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1592,27 ***</span>
    st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;internal_name());
  #endif
    name()-&gt;print_symbol_on(st);
    if (WizardMode) signature()-&gt;print_symbol_on(st);
    else if (MethodHandles::is_signature_polymorphic(intrinsic_id()))
<span class="line-modified">!     MethodHandles::print_as_basic_type_signature_on(st, signature(), true);</span>
  }
  
  // Comparer for sorting an object array containing
  // Method*s.
  static int method_comparator(Method* a, Method* b) {
    return a-&gt;name()-&gt;fast_compare(b-&gt;name());
  }
  
  // This is only done during class loading, so it is OK to assume method_idnum matches the methods() array
  // default_methods also uses this without the ordering for fast find_method
<span class="line-modified">! void Method::sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums) {</span>
    int length = methods-&gt;length();
    if (length &gt; 1) {
      {
        NoSafepointVerifier nsv;
<span class="line-modified">!       QuickSort::sort(methods-&gt;data(), length, method_comparator, /*idempotent=*/false);</span>
      }
      // Reset method ordering
      if (set_idnums) {
        for (int i = 0; i &lt; length; i++) {
          Method* m = methods-&gt;at(i);
<span class="line-new-header">--- 1739,30 ---</span>
    st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;internal_name());
  #endif
    name()-&gt;print_symbol_on(st);
    if (WizardMode) signature()-&gt;print_symbol_on(st);
    else if (MethodHandles::is_signature_polymorphic(intrinsic_id()))
<span class="line-modified">!     MethodHandles::print_as_basic_type_signature_on(st, signature());</span>
  }
  
  // Comparer for sorting an object array containing
  // Method*s.
  static int method_comparator(Method* a, Method* b) {
    return a-&gt;name()-&gt;fast_compare(b-&gt;name());
  }
  
  // This is only done during class loading, so it is OK to assume method_idnum matches the methods() array
  // default_methods also uses this without the ordering for fast find_method
<span class="line-modified">! void Method::sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums, method_comparator_func func) {</span>
    int length = methods-&gt;length();
    if (length &gt; 1) {
<span class="line-added">+     if (func == NULL) {</span>
<span class="line-added">+       func = method_comparator;</span>
<span class="line-added">+     }</span>
      {
        NoSafepointVerifier nsv;
<span class="line-modified">!       QuickSort::sort(methods-&gt;data(), length, func, /*idempotent=*/false);</span>
      }
      // Reset method ordering
      if (set_idnums) {
        for (int i = 0; i &lt; length; i++) {
          Method* m = methods-&gt;at(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1642,12 ***</span>
    SignatureTypePrinter(Symbol* signature, outputStream* st) : SignatureTypeNames(signature) {
      _st = st;
      _use_separator = false;
    }
  
<span class="line-modified">!   void print_parameters()              { _use_separator = false; iterate_parameters(); }</span>
<span class="line-modified">!   void print_returntype()              { _use_separator = false; iterate_returntype(); }</span>
  };
  
  
  void Method::print_name(outputStream* st) {
    Thread *thread = Thread::current();
<span class="line-new-header">--- 1792,12 ---</span>
    SignatureTypePrinter(Symbol* signature, outputStream* st) : SignatureTypeNames(signature) {
      _st = st;
      _use_separator = false;
    }
  
<span class="line-modified">!   void print_parameters()              { _use_separator = false; do_parameters_on(this); }</span>
<span class="line-modified">!   void print_returntype()              { _use_separator = false; do_type(return_type()); }</span>
  };
  
  
  void Method::print_name(outputStream* st) {
    Thread *thread = Thread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1874,11 ***</span>
    }
  #endif
    Thread *thread = Thread::current();
    *method-&gt;bcp_from(_bci) = Bytecodes::_breakpoint;
    method-&gt;incr_number_of_breakpoints(thread);
<span class="line-removed">-   SystemDictionary::notice_modification();</span>
    {
      // Deoptimize all dependents on this method
      HandleMark hm(thread);
      methodHandle mh(thread, method);
      CodeCache::flush_dependents_on_method(mh);
<span class="line-new-header">--- 2024,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2024,11 ***</span>
      return count;
    }
  #endif // PRODUCT
  };
  
<span class="line-modified">! // Something that can&#39;t be mistaken for an address or a markOop</span>
  Method* const JNIMethodBlock::_free_method = (Method*)55;
  
  JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(NULL) {
    _number_of_methods = MAX2(num_methods, min_block_size);
    _methods = NEW_C_HEAP_ARRAY(Method*, _number_of_methods, mtInternal);
<span class="line-new-header">--- 2173,11 ---</span>
      return count;
    }
  #endif // PRODUCT
  };
  
<span class="line-modified">! // Something that can&#39;t be mistaken for an address or a markWord</span>
  Method* const JNIMethodBlock::_free_method = (Method*)55;
  
  JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(NULL) {
    _number_of_methods = MAX2(num_methods, min_block_size);
    _methods = NEW_C_HEAP_ARRAY(Method*, _number_of_methods, mtInternal);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2041,11 ***</span>
    ClassLoaderData* cld = loader_data;
    if (!SafepointSynchronize::is_at_safepoint()) {
      // Have to add jmethod_ids() to class loader data thread-safely.
      // Also have to add the method to the list safely, which the cld lock
      // protects as well.
<span class="line-modified">!     MutexLockerEx ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
      if (cld-&gt;jmethod_ids() == NULL) {
        cld-&gt;set_jmethod_ids(new JNIMethodBlock(capacity));
      } else {
        cld-&gt;jmethod_ids()-&gt;ensure_methods(capacity);
      }
<span class="line-new-header">--- 2190,11 ---</span>
    ClassLoaderData* cld = loader_data;
    if (!SafepointSynchronize::is_at_safepoint()) {
      // Have to add jmethod_ids() to class loader data thread-safely.
      // Also have to add the method to the list safely, which the cld lock
      // protects as well.
<span class="line-modified">!     MutexLocker ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
      if (cld-&gt;jmethod_ids() == NULL) {
        cld-&gt;set_jmethod_ids(new JNIMethodBlock(capacity));
      } else {
        cld-&gt;jmethod_ids()-&gt;ensure_methods(capacity);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2065,11 ***</span>
  
    if (!SafepointSynchronize::is_at_safepoint()) {
      // Have to add jmethod_ids() to class loader data thread-safely.
      // Also have to add the method to the list safely, which the cld lock
      // protects as well.
<span class="line-modified">!     MutexLockerEx ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
      if (cld-&gt;jmethod_ids() == NULL) {
        cld-&gt;set_jmethod_ids(new JNIMethodBlock());
      }
      // jmethodID is a pointer to Method*
      return (jmethodID)cld-&gt;jmethod_ids()-&gt;add_method(m);
<span class="line-new-header">--- 2214,11 ---</span>
  
    if (!SafepointSynchronize::is_at_safepoint()) {
      // Have to add jmethod_ids() to class loader data thread-safely.
      // Also have to add the method to the list safely, which the cld lock
      // protects as well.
<span class="line-modified">!     MutexLocker ml(cld-&gt;metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
      if (cld-&gt;jmethod_ids() == NULL) {
        cld-&gt;set_jmethod_ids(new JNIMethodBlock());
      }
      // jmethodID is a pointer to Method*
      return (jmethodID)cld-&gt;jmethod_ids()-&gt;add_method(m);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2081,10 ***</span>
<span class="line-new-header">--- 2230,15 ---</span>
      // jmethodID is a pointer to Method*
      return (jmethodID)cld-&gt;jmethod_ids()-&gt;add_method(m);
    }
  }
  
<span class="line-added">+ jmethodID Method::jmethod_id() {</span>
<span class="line-added">+   methodHandle mh(Thread::current(), this);</span>
<span class="line-added">+   return method_holder()-&gt;get_jmethod_id(mh);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Mark a jmethodID as free.  This is called when there is a data race in
  // InstanceKlass while creating the jmethodID cache.
  void Method::destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID m) {
    ClassLoaderData* cld = loader_data;
    Method** ptr = (Method**)m;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2278,27 ***</span>
    if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
    if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
    if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
  }
  
<span class="line-removed">- #if INCLUDE_SERVICES</span>
<span class="line-removed">- // Size Statistics</span>
<span class="line-removed">- void Method::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">-   int mysize = sz-&gt;count(this);</span>
<span class="line-removed">-   sz-&gt;_method_bytes += mysize;</span>
<span class="line-removed">-   sz-&gt;_method_all_bytes += mysize;</span>
<span class="line-removed">-   sz-&gt;_rw_bytes += mysize;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (constMethod()) {</span>
<span class="line-removed">-     constMethod()-&gt;collect_statistics(sz);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (method_data()) {</span>
<span class="line-removed">-     method_data()-&gt;collect_statistics(sz);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // INCLUDE_SERVICES</span>
<span class="line-removed">- </span>
  // LogTouchedMethods and PrintTouchedMethods
  
  // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
  // the Method may be garbage collected. Let&#39;s roll our own hash table.
  class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
<span class="line-new-header">--- 2432,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2324,11 ***</span>
    unsigned int hash = my_class-&gt;identity_hash() +
                        my_name-&gt;identity_hash() +
                        my_sig-&gt;identity_hash();
    juint index = juint(hash) % table_size;
  
<span class="line-modified">!   MutexLocker ml(TouchedMethodLog_lock, THREAD);</span>
    if (_touched_method_table == NULL) {
      _touched_method_table = NEW_C_HEAP_ARRAY2(TouchedMethodRecord*, table_size,
                                                mtTracing, CURRENT_PC);
      memset(_touched_method_table, 0, sizeof(TouchedMethodRecord*)*table_size);
    }
<span class="line-new-header">--- 2461,11 ---</span>
    unsigned int hash = my_class-&gt;identity_hash() +
                        my_name-&gt;identity_hash() +
                        my_sig-&gt;identity_hash();
    juint index = juint(hash) % table_size;
  
<span class="line-modified">!   MutexLocker ml(THREAD, TouchedMethodLog_lock);</span>
    if (_touched_method_table == NULL) {
      _touched_method_table = NEW_C_HEAP_ARRAY2(TouchedMethodRecord*, table_size,
                                                mtTracing, CURRENT_PC);
      memset(_touched_method_table, 0, sizeof(TouchedMethodRecord*)*table_size);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2359,11 ***</span>
      ptr-&gt;_next = nptr;
    }
  }
  
  void Method::print_touched_methods(outputStream* out) {
<span class="line-modified">!   MutexLockerEx ml(Thread::current()-&gt;is_VM_thread() ? NULL : TouchedMethodLog_lock);</span>
    out-&gt;print_cr(&quot;# Method::print_touched_methods version 1&quot;);
    if (_touched_method_table) {
      for (int i = 0; i &lt; TOUCHED_METHOD_TABLE_SIZE; i++) {
        TouchedMethodRecord* ptr = _touched_method_table[i];
        while(ptr) {
<span class="line-new-header">--- 2496,11 ---</span>
      ptr-&gt;_next = nptr;
    }
  }
  
  void Method::print_touched_methods(outputStream* out) {
<span class="line-modified">!   MutexLocker ml(Thread::current()-&gt;is_VM_thread() ? NULL : TouchedMethodLog_lock);</span>
    out-&gt;print_cr(&quot;# Method::print_touched_methods version 1&quot;);
    if (_touched_method_table) {
      for (int i = 0; i &lt; TOUCHED_METHOD_TABLE_SIZE; i++) {
        TouchedMethodRecord* ptr = _touched_method_table[i];
        while(ptr) {
</pre>
<center><a href="metadata.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
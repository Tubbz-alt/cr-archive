<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,14 ***</span>
   */
  
  #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  #define SHARE_OOPS_INSTANCEKLASS_HPP
  
<span class="line-removed">- #include &quot;classfile/classLoader.hpp&quot;</span>
  #include &quot;classfile/classLoaderData.hpp&quot;
<span class="line-removed">- #include &quot;classfile/moduleEntry.hpp&quot;</span>
<span class="line-removed">- #include &quot;classfile/packageEntry.hpp&quot;</span>
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;oops/annotations.hpp&quot;
  #include &quot;oops/constMethod.hpp&quot;
  #include &quot;oops/fieldInfo.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
<span class="line-new-header">--- 23,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  #include &quot;utilities/macros.hpp&quot;
  #if INCLUDE_JFR
  #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  #endif
  
<span class="line-added">+ class RecordComponent;</span>
  
  // An InstanceKlass is the VM level representation of a Java class.
  // It contains all information needed for at class at execution runtime.
  
  //  InstanceKlass embedded field layout (after declared fields):
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,20 ***</span>
  // forward declaration for class -- see below for definition
  #if INCLUDE_JVMTI
  class BreakpointInfo;
  #endif
  class ClassFileParser;
  class KlassDepChange;
  class DependencyContext;
  class fieldDescriptor;
  class jniIdMapBase;
  class JNIid;
  class JvmtiCachedClassFieldMap;
  class nmethodBucket;
<span class="line-removed">- class SuperTypeClosure;</span>
  class OopMapCache;
  class InterpreterOopMap;
  
  // This is used in iterators below.
  class FieldClosure: public StackObj {
  public:
    virtual void do_field(fieldDescriptor* fd) = 0;
<span class="line-new-header">--- 59,22 ---</span>
  // forward declaration for class -- see below for definition
  #if INCLUDE_JVMTI
  class BreakpointInfo;
  #endif
  class ClassFileParser;
<span class="line-added">+ class ClassFileStream;</span>
  class KlassDepChange;
  class DependencyContext;
  class fieldDescriptor;
  class jniIdMapBase;
  class JNIid;
  class JvmtiCachedClassFieldMap;
  class nmethodBucket;
  class OopMapCache;
  class InterpreterOopMap;
<span class="line-added">+ class PackageEntry;</span>
<span class="line-added">+ class ModuleEntry;</span>
  
  // This is used in iterators below.
  class FieldClosure: public StackObj {
  public:
    virtual void do_field(fieldDescriptor* fd) = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,16 ***</span>
<span class="line-new-header">--- 101,32 ---</span>
  
    // Number of oops in this block.
    uint count() const         { return _count; }
    void set_count(uint count) { _count = count; }
  
<span class="line-added">+   void increment_count(int diff) { _count += diff; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int offset_span() const { return _count * heapOopSize; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int end_offset() const {</span>
<span class="line-added">+     return offset() + offset_span();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_contiguous(int another_offset) const {</span>
<span class="line-added">+     return another_offset == end_offset();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // sizeof(OopMapBlock) in words.
    static const int size_in_words() {
      return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
        LogBytesPerWord;
    }
  
<span class="line-added">+   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {</span>
<span class="line-added">+     return a-&gt;offset() - b-&gt;offset();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
   private:
    int  _offset;
    uint _count;
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,10 ***</span>
<span class="line-new-header">--- 197,13 ---</span>
  
    // Resolved nest-host klass: either true nest-host or self if we are not nested.
    // By always being set it makes nest-member access checks simpler.
    InstanceKlass* _nest_host;
  
<span class="line-added">+   // The contents of the Record attribute.</span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* _record_components;</span>
<span class="line-added">+ </span>
    // the source debug extension for this klass, NULL if not specified.
    // Specified as UTF-8 string without terminating zero byte in the classfile,
    // it is stored in the instanceklass as a NULL-terminated UTF-8 string
    const char*     _source_debug_extension;
    // Array name derived from this class which needs unreferencing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,11 ***</span>
  
    int             _itable_len;           // length of Java itable (in words)
    // _is_marked_dependent can be set concurrently, thus cannot be part of the
    // _misc_flags.
    bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
<span class="line-removed">-   bool            _is_being_redefined;   // used for locking redefinition</span>
  
    // The low two bits of _misc_flags contains the kind field.
    // This can be used to quickly discriminate among the four kinds of
    // InstanceKlass.
  
<span class="line-new-header">--- 226,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,19 ***</span>
                                                           // code source was found to be matching the value recorded by AOT.
      _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class
      _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader
      _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader
      _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader
<span class="line-modified">!     _misc_has_resolved_methods                = 1 &lt;&lt; 15  // resolved methods table entries added for this class</span>
    };
    u2 loader_type_bits() {
      return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
    }
<span class="line-modified">!   u2              _misc_flags;</span>
    u2              _minor_version;        // minor version number of class file
    u2              _major_version;        // major version number of class file
<span class="line-modified">!   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)</span>
    OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
    JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
    jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
    nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
    uint64_t        volatile _dep_context_last_cleaned;
<span class="line-new-header">--- 256,21 ---</span>
                                                           // code source was found to be matching the value recorded by AOT.
      _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class
      _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader
      _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader
      _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader
<span class="line-modified">!     _misc_has_resolved_methods                = 1 &lt;&lt; 15, // resolved methods table entries added for this class</span>
<span class="line-added">+     _misc_is_being_redefined                  = 1 &lt;&lt; 16, // used for locking redefinition</span>
<span class="line-added">+     _misc_has_contended_annotations           = 1 &lt;&lt; 17  // has @Contended annotation</span>
    };
    u2 loader_type_bits() {
      return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
    }
<span class="line-modified">!   u4              _misc_flags;</span>
    u2              _minor_version;        // minor version number of class file
    u2              _major_version;        // major version number of class file
<span class="line-modified">!   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)</span>
    OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
    JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
    jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
    nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
    uint64_t        volatile _dep_context_last_cleaned;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,10 ***</span>
<span class="line-new-header">--- 348,12 ---</span>
    //   have this embedded field.
    //
  
    friend class SystemDictionary;
  
<span class="line-added">+   static bool _disable_method_binary_search;</span>
<span class="line-added">+ </span>
   public:
    u2 loader_type() {
      return _misc_flags &amp; loader_type_bits();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,26 ***</span>
  
    void clear_class_loader_type() {
      _misc_flags &amp;= ~loader_type_bits();
    }
  
<span class="line-modified">!   void set_class_loader_type(s2 loader_type) {</span>
<span class="line-removed">-     switch (loader_type) {</span>
<span class="line-removed">-     case ClassLoader::BOOT_LOADER:</span>
<span class="line-removed">-       _misc_flags |= _misc_is_shared_boot_class;</span>
<span class="line-removed">-        break;</span>
<span class="line-removed">-     case ClassLoader::PLATFORM_LOADER:</span>
<span class="line-removed">-       _misc_flags |= _misc_is_shared_platform_class;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case ClassLoader::APP_LOADER:</span>
<span class="line-removed">-       _misc_flags |= _misc_is_shared_app_class;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       ShouldNotReachHere();</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  
    bool has_nonstatic_fields() const        {
      return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
    }
    void set_has_nonstatic_fields(bool b)    {
<span class="line-new-header">--- 369,11 ---</span>
  
    void clear_class_loader_type() {
      _misc_flags &amp;= ~loader_type_bits();
    }
  
<span class="line-modified">!   void set_class_loader_type(s2 loader_type);</span>
  
    bool has_nonstatic_fields() const        {
      return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
    }
    void set_has_nonstatic_fields(bool b)    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,13 ***</span>
<span class="line-new-header">--- 467,21 ---</span>
  
    // nest-host index
    jushort nest_host_index() const { return _nest_host_index; }
    void set_nest_host_index(u2 i)  { _nest_host_index = i; }
  
<span class="line-added">+   // record components</span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }</span>
<span class="line-added">+   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {</span>
<span class="line-added">+     _record_components = record_components;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   bool is_record() const { return _record_components != NULL; }</span>
<span class="line-added">+ </span>
  private:
    // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
    bool has_nest_member(InstanceKlass* k, TRAPS) const;
<span class="line-added">+ </span>
  public:
    // Returns nest-host class, resolving and validating it if needed
    // Returns NULL if an exception occurs during loading, or validation fails
    InstanceKlass* nest_host(Symbol* validationException, TRAPS);
    // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,17 ***</span>
    Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
    // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
    Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
  
    // find a non-static or static field given its offset within the class.
<span class="line-modified">!   bool contains_field_offset(int offset) {</span>
<span class="line-removed">-     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());</span>
<span class="line-removed">-   }</span>
  
    bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
    bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
  
    // find a local method (returns NULL if not found)
    Method* find_method(const Symbol* name, const Symbol* signature) const;
    static Method* find_method(const Array&lt;Method*&gt;* methods,
                               const Symbol* name,
                               const Symbol* signature);
<span class="line-new-header">--- 586,23 ---</span>
    Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
    // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
    Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
  
    // find a non-static or static field given its offset within the class.
<span class="line-modified">!   bool contains_field_offset(int offset);</span>
  
    bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
    bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
  
<span class="line-added">+  private:</span>
<span class="line-added">+   inline static int quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name);</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   static void disable_method_binary_search() {</span>
<span class="line-added">+     _disable_method_binary_search = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // find a local method (returns NULL if not found)
    Method* find_method(const Symbol* name, const Symbol* signature) const;
    static Method* find_method(const Array&lt;Method*&gt;* methods,
                               const Symbol* name,
                               const Symbol* signature);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 727,14 ***</span>
    int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
    void set_nonstatic_oop_map_size(int words) {
      _nonstatic_oop_map_size = words;
    }
  
  #if INCLUDE_JVMTI
    // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-modified">!   bool is_being_redefined() const          { return _is_being_redefined; }</span>
<span class="line-modified">!   void set_is_being_redefined(bool value)  { _is_being_redefined = value; }</span>
  
    // RedefineClasses() support for previous versions:
    void add_previous_version(InstanceKlass* ik, int emcp_method_count);
    void purge_previous_version_list();
  
<span class="line-new-header">--- 748,33 ---</span>
    int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
    void set_nonstatic_oop_map_size(int words) {
      _nonstatic_oop_map_size = words;
    }
  
<span class="line-added">+   bool has_contended_annotations() const {</span>
<span class="line-added">+     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void set_has_contended_annotations(bool value)  {</span>
<span class="line-added">+     if (value) {</span>
<span class="line-added">+       _misc_flags |= _misc_has_contended_annotations;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       _misc_flags &amp;= ~_misc_has_contended_annotations;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  #if INCLUDE_JVMTI
    // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-modified">!   bool is_being_redefined() const          {</span>
<span class="line-modified">!     return ((_misc_flags &amp; _misc_is_being_redefined) != 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void set_is_being_redefined(bool value)  {</span>
<span class="line-added">+     if (value) {</span>
<span class="line-added">+       _misc_flags |= _misc_is_being_redefined;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       _misc_flags &amp;= ~_misc_is_being_redefined;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
    // RedefineClasses() support for previous versions:
    void add_previous_version(InstanceKlass* ik, int emcp_method_count);
    void purge_previous_version_list();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,11 ***</span>
  
    // link this class into the implementors list of every interface it implements
    void process_interfaces(Thread *thread);
  
    // virtual operations from Klass
<span class="line-removed">-   bool is_leaf_class() const               { return _subklass == NULL; }</span>
    GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
                                                    Array&lt;InstanceKlass*&gt;* transitive_interfaces);
    bool can_be_primary_super_slow() const;
    int oop_size(oop obj)  const             { return size_helper(); }
    // slow because it&#39;s a virtual call and used for verifying the layout_helper.
<span class="line-new-header">--- 1046,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,11 ***</span>
    void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
  
    void methods_do(void f(Method* method));
    void array_klasses_do(void f(Klass* k));
    void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
<span class="line-removed">-   bool super_types_do(SuperTypeClosure* blk);</span>
  
    static InstanceKlass* cast(Klass* k) {
      return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
    }
  
<span class="line-new-header">--- 1062,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,13 ***</span>
                                                 nonstatic_oop_map_size(),
                                                 is_interface(),
                                                 is_unsafe_anonymous(),
                                                 has_stored_fingerprint());
    }
<span class="line-removed">- #if INCLUDE_SERVICES</span>
<span class="line-removed">-   virtual void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">- #endif</span>
  
    intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
    intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
  
    int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
<span class="line-new-header">--- 1098,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1158,10 ***</span>
<span class="line-new-header">--- 1193,12 ---</span>
                                   Array&lt;Method*&gt;* methods);
    void static deallocate_interfaces(ClassLoaderData* loader_data,
                                      const Klass* super_klass,
                                      Array&lt;InstanceKlass*&gt;* local_interfaces,
                                      Array&lt;InstanceKlass*&gt;* transitive_interfaces);
<span class="line-added">+   void static deallocate_record_components(ClassLoaderData* loader_data,</span>
<span class="line-added">+                                            Array&lt;RecordComponent*&gt;* record_component);</span>
  
    // The constant pool is on stack if any of the methods are executing or
    // referenced by handles.
    bool on_stack() const { return _constants-&gt;on_stack(); }
  
</pre>
<center><a href="instanceKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/oops/accessBackend.hpp b/src/hotspot/share/oops/accessBackend.hpp
--- a/src/hotspot/share/oops/accessBackend.hpp
+++ b/src/hotspot/share/oops/accessBackend.hpp
@@ -36,10 +36,11 @@
 #include "metaprogramming/isPointer.hpp"
 #include "metaprogramming/isSame.hpp"
 #include "metaprogramming/isVolatile.hpp"
 #include "oops/accessDecorators.hpp"
 #include "oops/oopsHierarchy.hpp"
+#include "runtime/globals.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 
 
 // This metafunction returns either oop or narrowOop depending on whether
@@ -61,12 +62,11 @@
     BARRIER_ATOMIC_CMPXCHG_AT,
     BARRIER_ATOMIC_XCHG,
     BARRIER_ATOMIC_XCHG_AT,
     BARRIER_ARRAYCOPY,
     BARRIER_CLONE,
-    BARRIER_RESOLVE,
-    BARRIER_EQUALS
+    BARRIER_RESOLVE
   };
 
   template <DecoratorSet decorators, typename T>
   struct MustConvertCompressedOop: public IntegralConstant<bool,
     HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value &&
@@ -100,24 +100,23 @@
 
   template <DecoratorSet decorators, typename T>
   struct AccessFunctionTypes {
     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
-    typedef T (*atomic_cmpxchg_at_func_t)(T new_value, oop base, ptrdiff_t offset, T compare_value);
-    typedef T (*atomic_xchg_at_func_t)(T new_value, oop base, ptrdiff_t offset);
+    typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);
+    typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);
 
     typedef T (*load_func_t)(void* addr);
     typedef void (*store_func_t)(void* addr, T value);
-    typedef T (*atomic_cmpxchg_func_t)(T new_value, void* addr, T compare_value);
-    typedef T (*atomic_xchg_func_t)(T new_value, void* addr);
+    typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
+    typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
 
     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                      size_t length);
     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
     typedef oop (*resolve_func_t)(oop obj);
-    typedef bool (*equals_func_t)(oop o1, oop o2);
   };
 
   template <DecoratorSet decorators>
   struct AccessFunctionTypes<decorators, void> {
     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
@@ -141,11 +140,10 @@
   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
-  ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_EQUALS, equals_func_t);
 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 
   template <DecoratorSet decorators, typename T, BarrierType barrier_type>
   typename AccessFunction<decorators, T, barrier_type>::type resolve_barrier();
 
@@ -293,49 +291,49 @@
   }
 
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     HasDecorator<ds, MO_SEQ_CST>::value, T>::type
-  atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);
+  atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     HasDecorator<ds, MO_RELAXED>::value, T>::type
-  atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);
+  atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     HasDecorator<ds, MO_SEQ_CST>::value, T>::type
-  atomic_xchg_internal(T new_value, void* addr);
+  atomic_xchg_internal(void* addr, T new_value);
 
   // The following *_locked mechanisms serve the purpose of handling atomic operations
   // that are larger than a machine can handle, and then possibly opt for using
   // a slower path using a mutex to perform the operation.
 
   template <DecoratorSet ds, typename T>
   static inline typename EnableIf<
     !AccessInternal::PossiblyLockedAccess<T>::value, T>::type
-  atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {
-    return atomic_cmpxchg_internal<ds>(new_value, addr, compare_value);
+  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {
+    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);
   }
 
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     AccessInternal::PossiblyLockedAccess<T>::value, T>::type
-  atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value);
+  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);
 
   template <DecoratorSet ds, typename T>
   static inline typename EnableIf<
     !AccessInternal::PossiblyLockedAccess<T>::value, T>::type
-  atomic_xchg_maybe_locked(T new_value, void* addr) {
-    return atomic_xchg_internal<ds>(new_value, addr);
+  atomic_xchg_maybe_locked(void* addr, T new_value) {
+    return atomic_xchg_internal<ds>(addr, new_value);
   }
 
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     AccessInternal::PossiblyLockedAccess<T>::value, T>::type
-  atomic_xchg_maybe_locked(T new_value, void* addr);
+  atomic_xchg_maybe_locked(void* addr, T new_value);
 
 public:
   template <typename T>
   static inline void store(void* addr, T value) {
     store_internal<decorators>(addr, value);
@@ -345,17 +343,17 @@
   static inline T load(void* addr) {
     return load_internal<decorators, T>(addr);
   }
 
   template <typename T>
-  static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {
-    return atomic_cmpxchg_maybe_locked<decorators>(new_value, addr, compare_value);
+  static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
+    return atomic_cmpxchg_maybe_locked<decorators>(addr, compare_value, new_value);
   }
 
   template <typename T>
-  static inline T atomic_xchg(T new_value, void* addr) {
-    return atomic_xchg_maybe_locked<decorators>(new_value, addr);
+  static inline T atomic_xchg(void* addr, T new_value) {
+    return atomic_xchg_maybe_locked<decorators>(addr, new_value);
   }
 
   template <typename T>
   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
@@ -370,18 +368,18 @@
   static T oop_load(void* addr);
   template <typename T>
   static T oop_load_at(oop base, ptrdiff_t offset);
 
   template <typename T>
-  static T oop_atomic_cmpxchg(T new_value, void* addr, T compare_value);
+  static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);
   template <typename T>
-  static T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value);
+  static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);
 
   template <typename T>
-  static T oop_atomic_xchg(T new_value, void* addr);
+  static T oop_atomic_xchg(void* addr, T new_value);
   template <typename T>
-  static T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset);
+  static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);
 
   template <typename T>
   static void store_at(oop base, ptrdiff_t offset, T value) {
     store(field_addr(base, offset), value);
   }
@@ -390,29 +388,27 @@
   static T load_at(oop base, ptrdiff_t offset) {
     return load<T>(field_addr(base, offset));
   }
 
   template <typename T>
-  static T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
-    return atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);
+  static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
+    return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
   }
 
   template <typename T>
-  static T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
-    return atomic_xchg(new_value, field_addr(base, offset));
+  static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
+    return atomic_xchg(field_addr(base, offset), new_value);
   }
 
   template <typename T>
   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                             size_t length);
 
   static void clone(oop src, oop dst, size_t size);
 
   static oop resolve(oop obj) { return obj; }
-
-  static bool equals(oop o1, oop o2) { return (void*)o1 == (void*)o2; }
 };
 
 // Below is the implementation of the first 4 steps of the template pipeline:
 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 //           and sets default decorators to sensible values.
@@ -517,50 +513,50 @@
   template <DecoratorSet decorators, typename T>
   struct RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG>: AllStatic {
     typedef typename AccessFunction<decorators, T, BARRIER_ATOMIC_CMPXCHG>::type func_t;
     static func_t _atomic_cmpxchg_func;
 
-    static T atomic_cmpxchg_init(T new_value, void* addr, T compare_value);
+    static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);
 
-    static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {
-      return _atomic_cmpxchg_func(new_value, addr, compare_value);
+    static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
+      return _atomic_cmpxchg_func(addr, compare_value, new_value);
     }
   };
 
   template <DecoratorSet decorators, typename T>
   struct RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG_AT>: AllStatic {
     typedef typename AccessFunction<decorators, T, BARRIER_ATOMIC_CMPXCHG_AT>::type func_t;
     static func_t _atomic_cmpxchg_at_func;
 
-    static T atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value);
+    static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);
 
-    static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
-      return _atomic_cmpxchg_at_func(new_value, base, offset, compare_value);
+    static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
+      return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);
     }
   };
 
   template <DecoratorSet decorators, typename T>
   struct RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG>: AllStatic {
     typedef typename AccessFunction<decorators, T, BARRIER_ATOMIC_XCHG>::type func_t;
     static func_t _atomic_xchg_func;
 
-    static T atomic_xchg_init(T new_value, void* addr);
+    static T atomic_xchg_init(void* addr, T new_value);
 
-    static inline T atomic_xchg(T new_value, void* addr) {
-      return _atomic_xchg_func(new_value, addr);
+    static inline T atomic_xchg(void* addr, T new_value) {
+      return _atomic_xchg_func(addr, new_value);
     }
   };
 
   template <DecoratorSet decorators, typename T>
   struct RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG_AT>: AllStatic {
     typedef typename AccessFunction<decorators, T, BARRIER_ATOMIC_XCHG_AT>::type func_t;
     static func_t _atomic_xchg_at_func;
 
-    static T atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset);
+    static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);
 
-    static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
-      return _atomic_xchg_at_func(new_value, base, offset);
+    static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
+      return _atomic_xchg_at_func(base, offset, new_value);
     }
   };
 
   template <DecoratorSet decorators, typename T>
   struct RuntimeDispatch<decorators, T, BARRIER_ARRAYCOPY>: AllStatic {
@@ -602,22 +598,10 @@
     static inline oop resolve(oop obj) {
       return _resolve_func(obj);
     }
   };
 
-  template <DecoratorSet decorators, typename T>
-  struct RuntimeDispatch<decorators, T, BARRIER_EQUALS>: AllStatic {
-    typedef typename AccessFunction<decorators, T, BARRIER_EQUALS>::type func_t;
-    static func_t _equals_func;
-
-    static bool equals_init(oop o1, oop o2);
-
-    static inline bool equals(oop o1, oop o2) {
-      return _equals_func(o1, o2);
-    }
-  };
-
   // Initialize the function pointers to point to the resolving function.
   template <DecoratorSet decorators, typename T>
   typename AccessFunction<decorators, T, BARRIER_STORE>::type
   RuntimeDispatch<decorators, T, BARRIER_STORE>::_store_func = &store_init;
 
@@ -659,14 +643,10 @@
 
   template <DecoratorSet decorators, typename T>
   typename AccessFunction<decorators, T, BARRIER_RESOLVE>::type
   RuntimeDispatch<decorators, T, BARRIER_RESOLVE>::_resolve_func = &resolve_init;
 
-  template <DecoratorSet decorators, typename T>
-  typename AccessFunction<decorators, T, BARRIER_EQUALS>::type
-  RuntimeDispatch<decorators, T, BARRIER_EQUALS>::_equals_func = &equals_init;
-
   // Step 3: Pre-runtime dispatching.
   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
   // not possible.
@@ -800,116 +780,116 @@
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value && CanHardwireRaw<decorators>::value, T>::type
-    atomic_cmpxchg(T new_value, void* addr, T compare_value) {
+    atomic_cmpxchg(void* addr, T compare_value, T new_value) {
       typedef RawAccessBarrier<decorators & RAW_DECORATOR_MASK> Raw;
       if (HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value) {
-        return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);
+        return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);
       } else {
-        return Raw::atomic_cmpxchg(new_value, addr, compare_value);
+        return Raw::atomic_cmpxchg(addr, compare_value, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value && !CanHardwireRaw<decorators>::value, T>::type
-    atomic_cmpxchg(T new_value, void* addr, T compare_value) {
+    atomic_cmpxchg(void* addr, T compare_value, T new_value) {
       if (UseCompressedOops) {
         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
-        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
       } else {
         const DecoratorSet expanded_decorators = decorators & ~convert_compressed_oops;
-        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       !HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_cmpxchg(T new_value, void* addr, T compare_value) {
+    atomic_cmpxchg(void* addr, T compare_value, T new_value) {
       if (is_hardwired_primitive<decorators>()) {
         const DecoratorSet expanded_decorators = decorators | AS_RAW;
-        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+        return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
       } else {
-        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG>::atomic_cmpxchg(new_value, addr, compare_value);
+        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG>::atomic_cmpxchg(addr, compare_value, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
-      return atomic_cmpxchg<decorators>(new_value, field_addr(base, offset), compare_value);
+    atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
+      return atomic_cmpxchg<decorators>(field_addr(base, offset), compare_value, new_value);
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       !HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
+    atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
       if (is_hardwired_primitive<decorators>()) {
         const DecoratorSet expanded_decorators = decorators | AS_RAW;
-        return PreRuntimeDispatch::atomic_cmpxchg_at<expanded_decorators>(new_value, base, offset, compare_value);
+        return PreRuntimeDispatch::atomic_cmpxchg_at<expanded_decorators>(base, offset, compare_value, new_value);
       } else {
-        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG_AT>::atomic_cmpxchg_at(new_value, base, offset, compare_value);
+        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_CMPXCHG_AT>::atomic_cmpxchg_at(base, offset, compare_value, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value && CanHardwireRaw<decorators>::value, T>::type
-    atomic_xchg(T new_value, void* addr) {
+    atomic_xchg(void* addr, T new_value) {
       typedef RawAccessBarrier<decorators & RAW_DECORATOR_MASK> Raw;
       if (HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value) {
-        return Raw::oop_atomic_xchg(new_value, addr);
+        return Raw::oop_atomic_xchg(addr, new_value);
       } else {
-        return Raw::atomic_xchg(new_value, addr);
+        return Raw::atomic_xchg(addr, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value && !CanHardwireRaw<decorators>::value, T>::type
-    atomic_xchg(T new_value, void* addr) {
+    atomic_xchg(void* addr, T new_value) {
       if (UseCompressedOops) {
         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
-        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
       } else {
         const DecoratorSet expanded_decorators = decorators & ~convert_compressed_oops;
-        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       !HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_xchg(T new_value, void* addr) {
+    atomic_xchg(void* addr, T new_value) {
       if (is_hardwired_primitive<decorators>()) {
         const DecoratorSet expanded_decorators = decorators | AS_RAW;
-        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
       } else {
-        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG>::atomic_xchg(new_value, addr);
+        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG>::atomic_xchg(addr, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
-      return atomic_xchg<decorators>(new_value, field_addr(base, offset));
+    atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
+      return atomic_xchg<decorators>(field_addr(base, offset), new_value);
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
       !HasDecorator<decorators, AS_RAW>::value, T>::type
-    atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
+    atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
       if (is_hardwired_primitive<decorators>()) {
         const DecoratorSet expanded_decorators = decorators | AS_RAW;
-        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, base, offset);
+        return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(base, offset, new_value);
       } else {
-        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG_AT>::atomic_xchg_at(new_value, base, offset);
+        return RuntimeDispatch<decorators, T, BARRIER_ATOMIC_XCHG_AT>::atomic_xchg_at(base, offset, new_value);
       }
     }
 
     template <DecoratorSet decorators, typename T>
     inline static typename EnableIf<
@@ -993,25 +973,10 @@
     inline static typename EnableIf<
       !HasDecorator<decorators, INTERNAL_BT_TO_SPACE_INVARIANT>::value, oop>::type
     resolve(oop obj) {
       return RuntimeDispatch<decorators, oop, BARRIER_RESOLVE>::resolve(obj);
     }
-
-    template <DecoratorSet decorators>
-    inline static typename EnableIf<
-      HasDecorator<decorators, AS_RAW>::value || HasDecorator<decorators, INTERNAL_BT_TO_SPACE_INVARIANT>::value, bool>::type
-    equals(oop o1, oop o2) {
-      typedef RawAccessBarrier<decorators & RAW_DECORATOR_MASK> Raw;
-      return Raw::equals(o1, o2);
-    }
-
-    template <DecoratorSet decorators>
-    inline static typename EnableIf<
-      !HasDecorator<decorators, AS_RAW>::value && !HasDecorator<decorators, INTERNAL_BT_TO_SPACE_INVARIANT>::value, bool>::type
-    equals(oop o1, oop o2) {
-      return RuntimeDispatch<decorators, oop, BARRIER_EQUALS>::equals(o1, o2);
-    }
   };
 
   // Step 2: Reduce types.
   // Enforce that for non-oop types, T and P have to be strictly the same.
   // P is the type of the address and T is the type of the values.
@@ -1051,60 +1016,60 @@
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
     PreRuntimeDispatch::store<expanded_decorators>(addr, value);
   }
 
   template <DecoratorSet decorators, typename T>
-  inline T atomic_cmpxchg_reduce_types(T new_value, T* addr, T compare_value) {
-    return PreRuntimeDispatch::atomic_cmpxchg<decorators>(new_value, addr, compare_value);
+  inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {
+    return PreRuntimeDispatch::atomic_cmpxchg<decorators>(addr, compare_value, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline oop atomic_cmpxchg_reduce_types(oop new_value, narrowOop* addr, oop compare_value) {
+  inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
-    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline narrowOop atomic_cmpxchg_reduce_types(narrowOop new_value, narrowOop* addr, narrowOop compare_value) {
+  inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
-    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline oop atomic_cmpxchg_reduce_types(oop new_value,
-                                         HeapWord* addr,
-                                         oop compare_value) {
+  inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,
+                                         oop compare_value,
+                                         oop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
-    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(new_value, addr, compare_value);
+    return PreRuntimeDispatch::atomic_cmpxchg<expanded_decorators>(addr, compare_value, new_value);
   }
 
   template <DecoratorSet decorators, typename T>
-  inline T atomic_xchg_reduce_types(T new_value, T* addr) {
+  inline T atomic_xchg_reduce_types(T* addr, T new_value) {
     const DecoratorSet expanded_decorators = decorators;
-    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline oop atomic_xchg_reduce_types(oop new_value, narrowOop* addr) {
+  inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
-    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline narrowOop atomic_xchg_reduce_types(narrowOop new_value, narrowOop* addr) {
+  inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
-    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
   }
 
   template <DecoratorSet decorators>
-  inline oop atomic_xchg_reduce_types(oop new_value, HeapWord* addr) {
+  inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {
     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
-    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(new_value, addr);
+    return PreRuntimeDispatch::atomic_xchg<expanded_decorators>(addr, new_value);
   }
 
   template <DecoratorSet decorators, typename T>
   inline T load_reduce_types(T* addr) {
     return PreRuntimeDispatch::load<decorators, T>(addr);
@@ -1224,26 +1189,26 @@
                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)>::value;
     return PreRuntimeDispatch::load_at<expanded_decorators, DecayedT>(base, offset);
   }
 
   template <DecoratorSet decorators, typename P, typename T>
-  inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {
+  inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {
     verify_types<decorators, T>();
     typedef typename Decay<P>::type DecayedP;
     typedef typename Decay<T>::type DecayedT;
     DecayedT new_decayed_value = new_value;
     DecayedT compare_decayed_value = compare_value;
     const DecoratorSet expanded_decorators = DecoratorFixup<
       (!HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?
       (MO_SEQ_CST | decorators) : decorators>::value;
-    return atomic_cmpxchg_reduce_types<expanded_decorators>(new_decayed_value,
-                                                            const_cast<DecayedP*>(addr),
-                                                            compare_decayed_value);
+    return atomic_cmpxchg_reduce_types<expanded_decorators>(const_cast<DecayedP*>(addr),
+                                                            compare_decayed_value,
+                                                            new_decayed_value);
   }
 
   template <DecoratorSet decorators, typename T>
-  inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
+  inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
     verify_types<decorators, T>();
     typedef typename Decay<T>::type DecayedT;
     DecayedT new_decayed_value = new_value;
     DecayedT compare_decayed_value = compare_value;
     // Determine default memory ordering
@@ -1252,36 +1217,36 @@
       (MO_SEQ_CST | decorators) : decorators>::value;
     // Potentially remember that we need compressed oop awareness
     const DecoratorSet final_decorators = expanded_decorators |
                                           (HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value ?
                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
-    return PreRuntimeDispatch::atomic_cmpxchg_at<final_decorators>(new_decayed_value, base,
-                                                                   offset, compare_decayed_value);
+    return PreRuntimeDispatch::atomic_cmpxchg_at<final_decorators>(base, offset, compare_decayed_value,
+                                                                   new_decayed_value);
   }
 
   template <DecoratorSet decorators, typename P, typename T>
-  inline T atomic_xchg(T new_value, P* addr) {
+  inline T atomic_xchg(P* addr, T new_value) {
     verify_types<decorators, T>();
     typedef typename Decay<P>::type DecayedP;
     typedef typename Decay<T>::type DecayedT;
     DecayedT new_decayed_value = new_value;
     // atomic_xchg is only available in SEQ_CST flavour.
     const DecoratorSet expanded_decorators = DecoratorFixup<decorators | MO_SEQ_CST>::value;
-    return atomic_xchg_reduce_types<expanded_decorators>(new_decayed_value,
-                                                         const_cast<DecayedP*>(addr));
+    return atomic_xchg_reduce_types<expanded_decorators>(const_cast<DecayedP*>(addr),
+                                                         new_decayed_value);
   }
 
   template <DecoratorSet decorators, typename T>
-  inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
+  inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
     verify_types<decorators, T>();
     typedef typename Decay<T>::type DecayedT;
     DecayedT new_decayed_value = new_value;
     // atomic_xchg is only available in SEQ_CST flavour.
     const DecoratorSet expanded_decorators = DecoratorFixup<decorators | MO_SEQ_CST |
                                              (HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value ?
                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)>::value;
-    return PreRuntimeDispatch::atomic_xchg_at<expanded_decorators>(new_decayed_value, base, offset);
+    return PreRuntimeDispatch::atomic_xchg_at<expanded_decorators>(base, offset, new_decayed_value);
   }
 
   template <DecoratorSet decorators, typename T>
   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
@@ -1306,16 +1271,10 @@
   inline oop resolve(oop obj) {
     const DecoratorSet expanded_decorators = DecoratorFixup<decorators>::value;
     return PreRuntimeDispatch::resolve<expanded_decorators>(obj);
   }
 
-  template <DecoratorSet decorators>
-  inline bool equals(oop o1, oop o2) {
-    const DecoratorSet expanded_decorators = DecoratorFixup<decorators>::value;
-    return PreRuntimeDispatch::equals<expanded_decorators>(o1, o2);
-  }
-
   // Infer the type that should be returned from an Access::oop_load.
   template <typename P, DecoratorSet decorators>
   class OopLoadProxy: public StackObj {
   private:
     P *const _addr;

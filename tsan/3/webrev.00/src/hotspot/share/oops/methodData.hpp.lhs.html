<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed">  29 #include &quot;memory/universe.hpp&quot;</span>
  30 #include &quot;oops/metadata.hpp&quot;
  31 #include &quot;oops/method.hpp&quot;
  32 #include &quot;oops/oop.hpp&quot;
  33 #include &quot;runtime/atomic.hpp&quot;
  34 #include &quot;utilities/align.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed">  35 #if INCLUDE_JVMCI</span>
<span class="line-removed">  36 #include &quot;jvmci/jvmci_globals.hpp&quot;</span>
<span class="line-removed">  37 #endif</span>
  38 
  39 class BytecodeStream;
<a name="4" id="anc4"></a><span class="line-removed">  40 class KlassSizeStats;</span>
  41 
  42 // The MethodData object collects counts and other profile information
  43 // during zeroth-tier (interpretive) and first-tier execution.
  44 // The profile is used later by compilation heuristics.  Some heuristics
  45 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  46 // optimization often has a down-side, a corner case that it handles
  47 // poorly, but which is thought to be rare.  The profile provides
  48 // evidence of this rarity for a given method or even BCI.  It allows
  49 // the compiler to back out of the optimization at places where it
  50 // has historically been a poor choice.  Other heuristics try to use
  51 // specific information gathered about types observed at a given site.
  52 //
  53 // All data in the profile is approximate.  It is expected to be accurate
  54 // on the whole, but the system expects occasional inaccuraces, due to
  55 // counter overflow, multiprocessor races during data collection, space
  56 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  57 // optimization quality but will not affect correctness.  Also, each MDO
  58 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  59 // to assess the quality (&quot;maturity&quot;) of its data.
  60 //
  61 // Short (&lt;32-bit) counters are designed to overflow to a known &quot;saturated&quot;
  62 // state.  Also, certain recorded per-BCI events are given one-bit counters
  63 // which overflow to a saturated state which applied to all counters at
  64 // that BCI.  In other words, there is a small lattice which approximates
  65 // the ideal of an infinite-precision counter for each event at each BCI,
  66 // and the lattice quickly &quot;bottoms out&quot; in a state where all counters
  67 // are taken to be indefinitely large.
  68 //
  69 // The reader will find many data races in profile gathering code, starting
  70 // with invocation counter incrementation.  None of these races harm correct
  71 // execution of the compiled code.
  72 
  73 // forward decl
  74 class ProfileData;
  75 
  76 // DataLayout
  77 //
  78 // Overlay for generic profiling data.
  79 class DataLayout {
  80   friend class VMStructs;
  81   friend class JVMCIVMStructs;
  82 
  83 private:
  84   // Every data layout begins with a header.  This header
  85   // contains a tag, which is used to indicate the size/layout
  86   // of the data, 8 bits of flags, which can be used in any way,
  87   // 32 bits of trap history (none/one reason/many reasons),
  88   // and a bci, which is used to tie this piece of data to a
  89   // specific bci in the bytecodes.
  90   union {
  91     u8 _bits;
  92     struct {
  93       u1 _tag;
  94       u1 _flags;
  95       u2 _bci;
  96       u4 _traps;
  97     } _struct;
  98   } _header;
  99 
 100   // The data layout has an arbitrary number of cells, each sized
 101   // to accomodate a pointer or an integer.
 102   intptr_t _cells[1];
 103 
 104   // Some types of data layouts need a length field.
 105   static bool needs_array_len(u1 tag);
 106 
 107 public:
 108   enum {
 109     counter_increment = 1
 110   };
 111 
 112   enum {
 113     cell_size = sizeof(intptr_t)
 114   };
 115 
 116   // Tag values
 117   enum {
 118     no_tag,
 119     bit_data_tag,
 120     counter_data_tag,
 121     jump_data_tag,
 122     receiver_type_data_tag,
 123     virtual_call_data_tag,
 124     ret_data_tag,
 125     branch_data_tag,
 126     multi_branch_data_tag,
 127     arg_info_data_tag,
 128     call_type_data_tag,
 129     virtual_call_type_data_tag,
 130     parameters_type_data_tag,
 131     speculative_trap_data_tag
 132   };
 133 
 134   enum {
 135     // The trap state breaks down as [recompile:1 | reason:31].
 136     // This further breakdown is defined in deoptimization.cpp.
 137     // See Deoptimization::trap_state_reason for an assert that
 138     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 139     //
 140     // The trap_state is collected only if ProfileTraps is true.
 141     trap_bits = 1+31,  // 31: enough to distinguish [0..Reason_RECORDED_LIMIT].
 142     trap_mask = -1,
 143     first_flag = 0
 144   };
 145 
 146   // Size computation
 147   static int header_size_in_bytes() {
 148     return header_size_in_cells() * cell_size;
 149   }
 150   static int header_size_in_cells() {
 151     return LP64_ONLY(1) NOT_LP64(2);
 152   }
 153 
 154   static int compute_size_in_bytes(int cell_count) {
 155     return header_size_in_bytes() + cell_count * cell_size;
 156   }
 157 
 158   // Initialization
 159   void initialize(u1 tag, u2 bci, int cell_count);
 160 
 161   // Accessors
 162   u1 tag() {
 163     return _header._struct._tag;
 164   }
 165 
 166   // Return 32 bits of trap state.
 167   // The state tells if traps with zero, one, or many reasons have occurred.
 168   // It also tells whether zero or many recompilations have occurred.
 169   // The associated trap histogram in the MDO itself tells whether
 170   // traps are common or not.  If a BCI shows that a trap X has
 171   // occurred, and the MDO shows N occurrences of X, we make the
 172   // simplifying assumption that all N occurrences can be blamed
 173   // on that BCI.
 174   uint trap_state() const {
 175     return _header._struct._traps;
 176   }
 177 
 178   void set_trap_state(uint new_state) {
 179     assert(ProfileTraps, &quot;used only under +ProfileTraps&quot;);
 180     uint old_flags = _header._struct._traps;
 181     _header._struct._traps = new_state | old_flags;
 182   }
 183 
 184   u1 flags() const {
 185     return _header._struct._flags;
 186   }
 187 
 188   u2 bci() const {
 189     return _header._struct._bci;
 190   }
 191 
 192   void set_header(u8 value) {
 193     _header._bits = value;
 194   }
 195   u8 header() {
 196     return _header._bits;
 197   }
 198   void set_cell_at(int index, intptr_t value) {
 199     _cells[index] = value;
 200   }
 201   void release_set_cell_at(int index, intptr_t value);
 202   intptr_t cell_at(int index) const {
 203     return _cells[index];
 204   }
 205 
 206   void set_flag_at(u1 flag_number) {
 207     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 208   }
 209   bool flag_at(u1 flag_number) const {
 210     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 211   }
 212 
 213   // Low-level support for code generation.
 214   static ByteSize header_offset() {
 215     return byte_offset_of(DataLayout, _header);
 216   }
 217   static ByteSize tag_offset() {
 218     return byte_offset_of(DataLayout, _header._struct._tag);
 219   }
 220   static ByteSize flags_offset() {
 221     return byte_offset_of(DataLayout, _header._struct._flags);
 222   }
 223   static ByteSize bci_offset() {
 224     return byte_offset_of(DataLayout, _header._struct._bci);
 225   }
 226   static ByteSize cell_offset(int index) {
 227     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 228   }
 229   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 230   static u1 flag_number_to_constant(u1 flag_number) {
 231     DataLayout temp; temp.set_header(0);
 232     temp.set_flag_at(flag_number);
 233     return temp._header._struct._flags;
 234   }
 235   // Return a value which, when or-ed as a word into _header, sets the flag.
 236   static u8 flag_mask_to_header_mask(uint byte_constant) {
 237     DataLayout temp; temp.set_header(0);
 238     temp._header._struct._flags = byte_constant;
 239     return temp._header._bits;
 240   }
 241 
 242   ProfileData* data_in();
 243 
 244   // GC support
 245   void clean_weak_klass_links(bool always_clean);
 246 
 247   // Redefinition support
 248   void clean_weak_method_links();
 249   DEBUG_ONLY(void verify_clean_weak_method_links();)
 250 };
 251 
 252 
 253 // ProfileData class hierarchy
 254 class ProfileData;
 255 class   BitData;
 256 class     CounterData;
 257 class       ReceiverTypeData;
 258 class         VirtualCallData;
 259 class           VirtualCallTypeData;
 260 class       RetData;
 261 class       CallTypeData;
 262 class   JumpData;
 263 class     BranchData;
 264 class   ArrayData;
 265 class     MultiBranchData;
 266 class     ArgInfoData;
 267 class     ParametersTypeData;
 268 class   SpeculativeTrapData;
 269 
 270 // ProfileData
 271 //
 272 // A ProfileData object is created to refer to a section of profiling
 273 // data in a structured way.
 274 class ProfileData : public ResourceObj {
 275   friend class TypeEntries;
 276   friend class ReturnTypeEntry;
 277   friend class TypeStackSlotEntries;
 278 private:
 279   enum {
 280     tab_width_one = 16,
 281     tab_width_two = 36
 282   };
 283 
 284   // This is a pointer to a section of profiling data.
 285   DataLayout* _data;
 286 
 287   char* print_data_on_helper(const MethodData* md) const;
 288 
 289 protected:
 290   DataLayout* data() { return _data; }
 291   const DataLayout* data() const { return _data; }
 292 
 293   enum {
 294     cell_size = DataLayout::cell_size
 295   };
 296 
 297 public:
 298   // How many cells are in this?
 299   virtual int cell_count() const {
 300     ShouldNotReachHere();
 301     return -1;
 302   }
 303 
 304   // Return the size of this data.
 305   int size_in_bytes() {
 306     return DataLayout::compute_size_in_bytes(cell_count());
 307   }
 308 
 309 protected:
 310   // Low-level accessors for underlying data
 311   void set_intptr_at(int index, intptr_t value) {
 312     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 313     data()-&gt;set_cell_at(index, value);
 314   }
 315   void release_set_intptr_at(int index, intptr_t value);
 316   intptr_t intptr_at(int index) const {
 317     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 318     return data()-&gt;cell_at(index);
 319   }
 320   void set_uint_at(int index, uint value) {
 321     set_intptr_at(index, (intptr_t) value);
 322   }
 323   void release_set_uint_at(int index, uint value);
 324   uint uint_at(int index) const {
 325     return (uint)intptr_at(index);
 326   }
 327   void set_int_at(int index, int value) {
 328     set_intptr_at(index, (intptr_t) value);
 329   }
 330   void release_set_int_at(int index, int value);
 331   int int_at(int index) const {
 332     return (int)intptr_at(index);
 333   }
 334   int int_at_unchecked(int index) const {
 335     return (int)data()-&gt;cell_at(index);
 336   }
 337   void set_oop_at(int index, oop value) {
 338     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 339   }
 340   oop oop_at(int index) const {
 341     return cast_to_oop(intptr_at(index));
 342   }
 343 
 344   void set_flag_at(int flag_number) {
 345     data()-&gt;set_flag_at(flag_number);
 346   }
 347   bool flag_at(int flag_number) const {
 348     return data()-&gt;flag_at(flag_number);
 349   }
 350 
 351   // two convenient imports for use by subclasses:
 352   static ByteSize cell_offset(int index) {
 353     return DataLayout::cell_offset(index);
 354   }
 355   static int flag_number_to_constant(int flag_number) {
 356     return DataLayout::flag_number_to_constant(flag_number);
 357   }
 358 
 359   ProfileData(DataLayout* data) {
 360     _data = data;
 361   }
 362 
 363 public:
 364   // Constructor for invalid ProfileData.
 365   ProfileData();
 366 
 367   u2 bci() const {
 368     return data()-&gt;bci();
 369   }
 370 
 371   address dp() {
 372     return (address)_data;
 373   }
 374 
 375   int trap_state() const {
 376     return data()-&gt;trap_state();
 377   }
 378   void set_trap_state(int new_state) {
 379     data()-&gt;set_trap_state(new_state);
 380   }
 381 
 382   // Type checking
 383   virtual bool is_BitData()         const { return false; }
 384   virtual bool is_CounterData()     const { return false; }
 385   virtual bool is_JumpData()        const { return false; }
 386   virtual bool is_ReceiverTypeData()const { return false; }
 387   virtual bool is_VirtualCallData() const { return false; }
 388   virtual bool is_RetData()         const { return false; }
 389   virtual bool is_BranchData()      const { return false; }
 390   virtual bool is_ArrayData()       const { return false; }
 391   virtual bool is_MultiBranchData() const { return false; }
 392   virtual bool is_ArgInfoData()     const { return false; }
 393   virtual bool is_CallTypeData()    const { return false; }
 394   virtual bool is_VirtualCallTypeData()const { return false; }
 395   virtual bool is_ParametersTypeData() const { return false; }
 396   virtual bool is_SpeculativeTrapData()const { return false; }
 397 
 398 
 399   BitData* as_BitData() const {
 400     assert(is_BitData(), &quot;wrong type&quot;);
 401     return is_BitData()         ? (BitData*)        this : NULL;
 402   }
 403   CounterData* as_CounterData() const {
 404     assert(is_CounterData(), &quot;wrong type&quot;);
 405     return is_CounterData()     ? (CounterData*)    this : NULL;
 406   }
 407   JumpData* as_JumpData() const {
 408     assert(is_JumpData(), &quot;wrong type&quot;);
 409     return is_JumpData()        ? (JumpData*)       this : NULL;
 410   }
 411   ReceiverTypeData* as_ReceiverTypeData() const {
 412     assert(is_ReceiverTypeData(), &quot;wrong type&quot;);
 413     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 414   }
 415   VirtualCallData* as_VirtualCallData() const {
 416     assert(is_VirtualCallData(), &quot;wrong type&quot;);
 417     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 418   }
 419   RetData* as_RetData() const {
 420     assert(is_RetData(), &quot;wrong type&quot;);
 421     return is_RetData()         ? (RetData*)        this : NULL;
 422   }
 423   BranchData* as_BranchData() const {
 424     assert(is_BranchData(), &quot;wrong type&quot;);
 425     return is_BranchData()      ? (BranchData*)     this : NULL;
 426   }
 427   ArrayData* as_ArrayData() const {
 428     assert(is_ArrayData(), &quot;wrong type&quot;);
 429     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 430   }
 431   MultiBranchData* as_MultiBranchData() const {
 432     assert(is_MultiBranchData(), &quot;wrong type&quot;);
 433     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 434   }
 435   ArgInfoData* as_ArgInfoData() const {
 436     assert(is_ArgInfoData(), &quot;wrong type&quot;);
 437     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 438   }
 439   CallTypeData* as_CallTypeData() const {
 440     assert(is_CallTypeData(), &quot;wrong type&quot;);
 441     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 442   }
 443   VirtualCallTypeData* as_VirtualCallTypeData() const {
 444     assert(is_VirtualCallTypeData(), &quot;wrong type&quot;);
 445     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 446   }
 447   ParametersTypeData* as_ParametersTypeData() const {
 448     assert(is_ParametersTypeData(), &quot;wrong type&quot;);
 449     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 450   }
 451   SpeculativeTrapData* as_SpeculativeTrapData() const {
 452     assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
 453     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 454   }
 455 
 456 
 457   // Subclass specific initialization
 458   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 459 
 460   // GC support
 461   virtual void clean_weak_klass_links(bool always_clean) {}
 462 
 463   // Redefinition support
 464   virtual void clean_weak_method_links() {}
 465   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 466 
 467   // CI translation: ProfileData can represent both MethodDataOop data
 468   // as well as CIMethodData data. This function is provided for translating
 469   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 470   // most ProfileData don&#39;t require any translation, so we provide the null
 471   // translation here, and the required translators are in the ci subclasses.
 472   virtual void translate_from(const ProfileData* data) {}
 473 
 474   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 475     ShouldNotReachHere();
 476   }
 477 
 478   void print_data_on(outputStream* st, const MethodData* md) const;
 479 
 480   void print_shared(outputStream* st, const char* name, const char* extra) const;
 481   void tab(outputStream* st, bool first = false) const;
 482 };
 483 
 484 // BitData
 485 //
 486 // A BitData holds a flag or two in its header.
 487 class BitData : public ProfileData {
 488   friend class VMStructs;
 489   friend class JVMCIVMStructs;
 490 protected:
 491   enum {
 492     // null_seen:
 493     //  saw a null operand (cast/aastore/instanceof)
 494       null_seen_flag              = DataLayout::first_flag + 0
 495 #if INCLUDE_JVMCI
 496     // bytecode threw any exception
 497     , exception_seen_flag         = null_seen_flag + 1
 498 #endif
 499   };
 500   enum { bit_cell_count = 0 };  // no additional data fields needed.
 501 public:
 502   BitData(DataLayout* layout) : ProfileData(layout) {
 503   }
 504 
 505   virtual bool is_BitData() const { return true; }
 506 
 507   static int static_cell_count() {
 508     return bit_cell_count;
 509   }
 510 
 511   virtual int cell_count() const {
 512     return static_cell_count();
 513   }
 514 
 515   // Accessor
 516 
 517   // The null_seen flag bit is specially known to the interpreter.
 518   // Consulting it allows the compiler to avoid setting up null_check traps.
 519   bool null_seen()     { return flag_at(null_seen_flag); }
 520   void set_null_seen()    { set_flag_at(null_seen_flag); }
 521 
 522 #if INCLUDE_JVMCI
 523   // true if an exception was thrown at the specific BCI
 524   bool exception_seen() { return flag_at(exception_seen_flag); }
 525   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 526 #endif
 527 
 528   // Code generation support
 529   static int null_seen_byte_constant() {
 530     return flag_number_to_constant(null_seen_flag);
 531   }
 532 
 533   static ByteSize bit_data_size() {
 534     return cell_offset(bit_cell_count);
 535   }
 536 
 537   void print_data_on(outputStream* st, const char* extra = NULL) const;
 538 };
 539 
 540 // CounterData
 541 //
 542 // A CounterData corresponds to a simple counter.
 543 class CounterData : public BitData {
 544   friend class VMStructs;
 545   friend class JVMCIVMStructs;
 546 protected:
 547   enum {
 548     count_off,
 549     counter_cell_count
 550   };
 551 public:
 552   CounterData(DataLayout* layout) : BitData(layout) {}
 553 
 554   virtual bool is_CounterData() const { return true; }
 555 
 556   static int static_cell_count() {
 557     return counter_cell_count;
 558   }
 559 
 560   virtual int cell_count() const {
 561     return static_cell_count();
 562   }
 563 
 564   // Direct accessor
<a name="5" id="anc5"></a><span class="line-modified"> 565   uint count() const {</span>
<span class="line-modified"> 566     return uint_at(count_off);</span>






 567   }
 568 
 569   // Code generation support
 570   static ByteSize count_offset() {
 571     return cell_offset(count_off);
 572   }
 573   static ByteSize counter_data_size() {
 574     return cell_offset(counter_cell_count);
 575   }
 576 
<a name="6" id="anc6"></a><span class="line-modified"> 577   void set_count(uint count) {</span>
<span class="line-modified"> 578     set_uint_at(count_off, count);</span>
 579   }
 580 
 581   void print_data_on(outputStream* st, const char* extra = NULL) const;
 582 };
 583 
 584 // JumpData
 585 //
 586 // A JumpData is used to access profiling information for a direct
 587 // branch.  It is a counter, used for counting the number of branches,
 588 // plus a data displacement, used for realigning the data pointer to
 589 // the corresponding target bci.
 590 class JumpData : public ProfileData {
 591   friend class VMStructs;
 592   friend class JVMCIVMStructs;
 593 protected:
 594   enum {
 595     taken_off_set,
 596     displacement_off_set,
 597     jump_cell_count
 598   };
 599 
 600   void set_displacement(int displacement) {
 601     set_int_at(displacement_off_set, displacement);
 602   }
 603 
 604 public:
 605   JumpData(DataLayout* layout) : ProfileData(layout) {
 606     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 607       layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
 608   }
 609 
 610   virtual bool is_JumpData() const { return true; }
 611 
 612   static int static_cell_count() {
 613     return jump_cell_count;
 614   }
 615 
 616   virtual int cell_count() const {
 617     return static_cell_count();
 618   }
 619 
 620   // Direct accessor
 621   uint taken() const {
 622     return uint_at(taken_off_set);
 623   }
 624 
 625   void set_taken(uint cnt) {
 626     set_uint_at(taken_off_set, cnt);
 627   }
 628 
 629   // Saturating counter
 630   uint inc_taken() {
 631     uint cnt = taken() + 1;
 632     // Did we wrap? Will compiler screw us??
 633     if (cnt == 0) cnt--;
 634     set_uint_at(taken_off_set, cnt);
 635     return cnt;
 636   }
 637 
 638   int displacement() const {
 639     return int_at(displacement_off_set);
 640   }
 641 
 642   // Code generation support
 643   static ByteSize taken_offset() {
 644     return cell_offset(taken_off_set);
 645   }
 646 
 647   static ByteSize displacement_offset() {
 648     return cell_offset(displacement_off_set);
 649   }
 650 
 651   // Specific initialization.
 652   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 653 
 654   void print_data_on(outputStream* st, const char* extra = NULL) const;
 655 };
 656 
 657 // Entries in a ProfileData object to record types: it can either be
 658 // none (no profile), unknown (conflicting profile data) or a klass if
 659 // a single one is seen. Whether a null reference was seen is also
 660 // recorded. No counter is associated with the type and a single type
 661 // is tracked (unlike VirtualCallData).
 662 class TypeEntries {
 663 
 664 public:
 665 
 666   // A single cell is used to record information for a type:
 667   // - the cell is initialized to 0
 668   // - when a type is discovered it is stored in the cell
 669   // - bit zero of the cell is used to record whether a null reference
 670   // was encountered or not
 671   // - bit 1 is set to record a conflict in the type information
 672 
 673   enum {
 674     null_seen = 1,
 675     type_mask = ~null_seen,
 676     type_unknown = 2,
 677     status_bits = null_seen | type_unknown,
 678     type_klass_mask = ~status_bits
 679   };
 680 
 681   // what to initialize a cell to
 682   static intptr_t type_none() {
 683     return 0;
 684   }
 685 
 686   // null seen = bit 0 set?
 687   static bool was_null_seen(intptr_t v) {
 688     return (v &amp; null_seen) != 0;
 689   }
 690 
 691   // conflicting type information = bit 1 set?
 692   static bool is_type_unknown(intptr_t v) {
 693     return (v &amp; type_unknown) != 0;
 694   }
 695 
 696   // not type information yet = all bits cleared, ignoring bit 0?
 697   static bool is_type_none(intptr_t v) {
 698     return (v &amp; type_mask) == 0;
 699   }
 700 
 701   // recorded type: cell without bit 0 and 1
 702   static intptr_t klass_part(intptr_t v) {
 703     intptr_t r = v &amp; type_klass_mask;
 704     return r;
 705   }
 706 
 707   // type recorded
 708   static Klass* valid_klass(intptr_t k) {
 709     if (!is_type_none(k) &amp;&amp;
 710         !is_type_unknown(k)) {
 711       Klass* res = (Klass*)klass_part(k);
 712       assert(res != NULL, &quot;invalid&quot;);
 713       return res;
 714     } else {
 715       return NULL;
 716     }
 717   }
 718 
 719   static intptr_t with_status(intptr_t k, intptr_t in) {
 720     return k | (in &amp; status_bits);
 721   }
 722 
 723   static intptr_t with_status(Klass* k, intptr_t in) {
 724     return with_status((intptr_t)k, in);
 725   }
 726 
 727   static void print_klass(outputStream* st, intptr_t k);
 728 
 729 protected:
 730   // ProfileData object these entries are part of
 731   ProfileData* _pd;
 732   // offset within the ProfileData object where the entries start
 733   const int _base_off;
 734 
 735   TypeEntries(int base_off)
 736     : _pd(NULL), _base_off(base_off) {}
 737 
 738   void set_intptr_at(int index, intptr_t value) {
 739     _pd-&gt;set_intptr_at(index, value);
 740   }
 741 
 742   intptr_t intptr_at(int index) const {
 743     return _pd-&gt;intptr_at(index);
 744   }
 745 
 746 public:
 747   void set_profile_data(ProfileData* pd) {
 748     _pd = pd;
 749   }
 750 };
 751 
 752 // Type entries used for arguments passed at a call and parameters on
 753 // method entry. 2 cells per entry: one for the type encoded as in
 754 // TypeEntries and one initialized with the stack slot where the
 755 // profiled object is to be found so that the interpreter can locate
 756 // it quickly.
 757 class TypeStackSlotEntries : public TypeEntries {
 758 
 759 private:
 760   enum {
 761     stack_slot_entry,
 762     type_entry,
 763     per_arg_cell_count
 764   };
 765 
 766   // offset of cell for stack slot for entry i within ProfileData object
 767   int stack_slot_offset(int i) const {
 768     return _base_off + stack_slot_local_offset(i);
 769   }
 770 
 771   const int _number_of_entries;
 772 
 773   // offset of cell for type for entry i within ProfileData object
 774   int type_offset_in_cells(int i) const {
 775     return _base_off + type_local_offset(i);
 776   }
 777 
 778 public:
 779 
 780   TypeStackSlotEntries(int base_off, int nb_entries)
 781     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 782 
 783   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 784 
 785   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 786 
 787   int number_of_entries() const { return _number_of_entries; }
 788 
 789   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 790   static int stack_slot_local_offset(int i) {
 791     return i * per_arg_cell_count + stack_slot_entry;
 792   }
 793 
 794   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 795   static int type_local_offset(int i) {
 796     return i * per_arg_cell_count + type_entry;
 797   }
 798 
 799   // stack slot for entry i
 800   uint stack_slot(int i) const {
 801     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 802     return _pd-&gt;uint_at(stack_slot_offset(i));
 803   }
 804 
 805   // set stack slot for entry i
 806   void set_stack_slot(int i, uint num) {
 807     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 808     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 809   }
 810 
 811   // type for entry i
 812   intptr_t type(int i) const {
 813     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 814     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 815   }
 816 
 817   // set type for entry i
 818   void set_type(int i, intptr_t k) {
 819     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 820     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 821   }
 822 
 823   static ByteSize per_arg_size() {
 824     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 825   }
 826 
 827   static int per_arg_count() {
 828     return per_arg_cell_count;
 829   }
 830 
 831   ByteSize type_offset(int i) const {
 832     return DataLayout::cell_offset(type_offset_in_cells(i));
 833   }
 834 
 835   // GC support
 836   void clean_weak_klass_links(bool always_clean);
 837 
 838   void print_data_on(outputStream* st) const;
 839 };
 840 
 841 // Type entry used for return from a call. A single cell to record the
 842 // type.
 843 class ReturnTypeEntry : public TypeEntries {
 844 
 845 private:
 846   enum {
 847     cell_count = 1
 848   };
 849 
 850 public:
 851   ReturnTypeEntry(int base_off)
 852     : TypeEntries(base_off) {}
 853 
 854   void post_initialize() {
 855     set_type(type_none());
 856   }
 857 
 858   intptr_t type() const {
 859     return _pd-&gt;intptr_at(_base_off);
 860   }
 861 
 862   void set_type(intptr_t k) {
 863     _pd-&gt;set_intptr_at(_base_off, k);
 864   }
 865 
 866   static int static_cell_count() {
 867     return cell_count;
 868   }
 869 
 870   static ByteSize size() {
 871     return in_ByteSize(cell_count * DataLayout::cell_size);
 872   }
 873 
 874   ByteSize type_offset() {
 875     return DataLayout::cell_offset(_base_off);
 876   }
 877 
 878   // GC support
 879   void clean_weak_klass_links(bool always_clean);
 880 
 881   void print_data_on(outputStream* st) const;
 882 };
 883 
 884 // Entries to collect type information at a call: contains arguments
 885 // (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a
 886 // number of cells. Because the number of cells for the return type is
 887 // smaller than the number of cells for the type of an arguments, the
 888 // number of cells is used to tell how many arguments are profiled and
 889 // whether a return value is profiled. See has_arguments() and
 890 // has_return().
 891 class TypeEntriesAtCall {
 892 private:
 893   static int stack_slot_local_offset(int i) {
 894     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 895   }
 896 
 897   static int argument_type_local_offset(int i) {
 898     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
 899   }
 900 
 901 public:
 902 
 903   static int header_cell_count() {
 904     return 1;
 905   }
 906 
 907   static int cell_count_local_offset() {
 908     return 0;
 909   }
 910 
 911   static int compute_cell_count(BytecodeStream* stream);
 912 
 913   static void initialize(DataLayout* dl, int base, int cell_count) {
 914     int off = base + cell_count_local_offset();
 915     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
 916   }
 917 
 918   static bool arguments_profiling_enabled();
 919   static bool return_profiling_enabled();
 920 
 921   // Code generation support
 922   static ByteSize cell_count_offset() {
 923     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
 924   }
 925 
 926   static ByteSize args_data_offset() {
 927     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
 928   }
 929 
 930   static ByteSize stack_slot_offset(int i) {
 931     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
 932   }
 933 
 934   static ByteSize argument_type_offset(int i) {
 935     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
 936   }
 937 
 938   static ByteSize return_only_size() {
 939     return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
 940   }
 941 
 942 };
 943 
 944 // CallTypeData
 945 //
 946 // A CallTypeData is used to access profiling information about a non
 947 // virtual call for which we collect type information about arguments
 948 // and return value.
 949 class CallTypeData : public CounterData {
 950 private:
 951   // entries for arguments if any
 952   TypeStackSlotEntries _args;
 953   // entry for return type if any
 954   ReturnTypeEntry _ret;
 955 
 956   int cell_count_global_offset() const {
 957     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
 958   }
 959 
 960   // number of cells not counting the header
 961   int cell_count_no_header() const {
 962     return uint_at(cell_count_global_offset());
 963   }
 964 
 965   void check_number_of_arguments(int total) {
 966     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
 967   }
 968 
 969 public:
 970   CallTypeData(DataLayout* layout) :
 971     CounterData(layout),
 972     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
 973     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
 974   {
 975     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
 976     // Some compilers (VC++) don&#39;t want this passed in member initialization list
 977     _args.set_profile_data(this);
 978     _ret.set_profile_data(this);
 979   }
 980 
 981   const TypeStackSlotEntries* args() const {
 982     assert(has_arguments(), &quot;no profiling of arguments&quot;);
 983     return &amp;_args;
 984   }
 985 
 986   const ReturnTypeEntry* ret() const {
 987     assert(has_return(), &quot;no profiling of return value&quot;);
 988     return &amp;_ret;
 989   }
 990 
 991   virtual bool is_CallTypeData() const { return true; }
 992 
 993   static int static_cell_count() {
 994     return -1;
 995   }
 996 
 997   static int compute_cell_count(BytecodeStream* stream) {
 998     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
 999   }
1000 
1001   static void initialize(DataLayout* dl, int cell_count) {
1002     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1003   }
1004 
1005   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1006 
1007   virtual int cell_count() const {
1008     return CounterData::static_cell_count() +
1009       TypeEntriesAtCall::header_cell_count() +
1010       int_at_unchecked(cell_count_global_offset());
1011   }
1012 
1013   int number_of_arguments() const {
1014     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1015   }
1016 
1017   void set_argument_type(int i, Klass* k) {
1018     assert(has_arguments(), &quot;no arguments!&quot;);
1019     intptr_t current = _args.type(i);
1020     _args.set_type(i, TypeEntries::with_status(k, current));
1021   }
1022 
1023   void set_return_type(Klass* k) {
1024     assert(has_return(), &quot;no return!&quot;);
1025     intptr_t current = _ret.type();
1026     _ret.set_type(TypeEntries::with_status(k, current));
1027   }
1028 
1029   // An entry for a return value takes less space than an entry for an
1030   // argument so if the number of cells exceeds the number of cells
1031   // needed for an argument, this object contains type information for
1032   // at least one argument.
1033   bool has_arguments() const {
1034     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1035     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1036     return res;
1037   }
1038 
1039   // An entry for a return value takes less space than an entry for an
1040   // argument, so if the remainder of the number of cells divided by
1041   // the number of cells for an argument is not null, a return value
1042   // is profiled in this object.
1043   bool has_return() const {
1044     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1045     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1046     return res;
1047   }
1048 
1049   // Code generation support
1050   static ByteSize args_data_offset() {
1051     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1052   }
1053 
1054   ByteSize argument_type_offset(int i) {
1055     return _args.type_offset(i);
1056   }
1057 
1058   ByteSize return_type_offset() {
1059     return _ret.type_offset();
1060   }
1061 
1062   // GC support
1063   virtual void clean_weak_klass_links(bool always_clean) {
1064     if (has_arguments()) {
1065       _args.clean_weak_klass_links(always_clean);
1066     }
1067     if (has_return()) {
1068       _ret.clean_weak_klass_links(always_clean);
1069     }
1070   }
1071 
1072   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1073 };
1074 
1075 // ReceiverTypeData
1076 //
1077 // A ReceiverTypeData is used to access profiling information about a
1078 // dynamic type check.  It consists of a counter which counts the total times
1079 // that the check is reached, and a series of (Klass*, count) pairs
1080 // which are used to store a type profile for the receiver of the check.
1081 class ReceiverTypeData : public CounterData {
1082   friend class VMStructs;
1083   friend class JVMCIVMStructs;
1084 protected:
1085   enum {
1086 #if INCLUDE_JVMCI
1087     // Description of the different counters
1088     // ReceiverTypeData for instanceof/checkcast/aastore:
1089     //   count is decremented for failed type checks
1090     //   JVMCI only: nonprofiled_count is incremented on type overflow
1091     // VirtualCallData for invokevirtual/invokeinterface:
1092     //   count is incremented on type overflow
1093     //   JVMCI only: nonprofiled_count is incremented on method overflow
1094 
1095     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1096     nonprofiled_count_off_set = counter_cell_count,
1097     receiver0_offset,
1098 #else
1099     receiver0_offset = counter_cell_count,
1100 #endif
1101     count0_offset,
1102     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1103   };
1104 
1105 public:
1106   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1107     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1108            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1109            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1110   }
1111 
1112   virtual bool is_ReceiverTypeData() const { return true; }
1113 
1114   static int static_cell_count() {
1115     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1116   }
1117 
1118   virtual int cell_count() const {
1119     return static_cell_count();
1120   }
1121 
1122   // Direct accessors
1123   static uint row_limit() {
1124     return TypeProfileWidth;
1125   }
1126   static int receiver_cell_index(uint row) {
1127     return receiver0_offset + row * receiver_type_row_cell_count;
1128   }
1129   static int receiver_count_cell_index(uint row) {
1130     return count0_offset + row * receiver_type_row_cell_count;
1131   }
1132 
1133   Klass* receiver(uint row) const {
1134     assert(row &lt; row_limit(), &quot;oob&quot;);
1135 
1136     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1137     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
1138     return recv;
1139   }
1140 
1141   void set_receiver(uint row, Klass* k) {
1142     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1143     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1144   }
1145 
1146   uint receiver_count(uint row) const {
1147     assert(row &lt; row_limit(), &quot;oob&quot;);
1148     return uint_at(receiver_count_cell_index(row));
1149   }
1150 
1151   void set_receiver_count(uint row, uint count) {
1152     assert(row &lt; row_limit(), &quot;oob&quot;);
1153     set_uint_at(receiver_count_cell_index(row), count);
1154   }
1155 
1156   void clear_row(uint row) {
1157     assert(row &lt; row_limit(), &quot;oob&quot;);
1158     // Clear total count - indicator of polymorphic call site.
1159     // The site may look like as monomorphic after that but
1160     // it allow to have more accurate profiling information because
1161     // there was execution phase change since klasses were unloaded.
1162     // If the site is still polymorphic then MDO will be updated
1163     // to reflect it. But it could be the case that the site becomes
1164     // only bimorphic. Then keeping total count not 0 will be wrong.
1165     // Even if we use monomorphic (when it is not) for compilation
1166     // we will only have trap, deoptimization and recompile again
1167     // with updated MDO after executing method in Interpreter.
1168     // An additional receiver will be recorded in the cleaned row
1169     // during next call execution.
1170     //
1171     // Note: our profiling logic works with empty rows in any slot.
1172     // We do sorting a profiling info (ciCallProfile) for compilation.
1173     //
1174     set_count(0);
1175     set_receiver(row, NULL);
1176     set_receiver_count(row, 0);
1177 #if INCLUDE_JVMCI
1178     if (!this-&gt;is_VirtualCallData()) {
1179       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1180       // must also be reset (see &quot;Description of the different counters&quot; above)
1181       set_nonprofiled_count(0);
1182     }
1183 #endif
1184   }
1185 
1186   // Code generation support
1187   static ByteSize receiver_offset(uint row) {
1188     return cell_offset(receiver_cell_index(row));
1189   }
1190   static ByteSize receiver_count_offset(uint row) {
1191     return cell_offset(receiver_count_cell_index(row));
1192   }
1193 #if INCLUDE_JVMCI
1194   static ByteSize nonprofiled_receiver_count_offset() {
1195     return cell_offset(nonprofiled_count_off_set);
1196   }
1197   uint nonprofiled_count() const {
1198     return uint_at(nonprofiled_count_off_set);
1199   }
1200   void set_nonprofiled_count(uint count) {
1201     set_uint_at(nonprofiled_count_off_set, count);
1202   }
1203 #endif // INCLUDE_JVMCI
1204   static ByteSize receiver_type_data_size() {
1205     return cell_offset(static_cell_count());
1206   }
1207 
1208   // GC support
1209   virtual void clean_weak_klass_links(bool always_clean);
1210 
1211   void print_receiver_data_on(outputStream* st) const;
1212   void print_data_on(outputStream* st, const char* extra = NULL) const;
1213 };
1214 
1215 // VirtualCallData
1216 //
1217 // A VirtualCallData is used to access profiling information about a
1218 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1219 class VirtualCallData : public ReceiverTypeData {
1220 public:
1221   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1222     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1223            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1224   }
1225 
1226   virtual bool is_VirtualCallData() const { return true; }
1227 
1228   static int static_cell_count() {
1229     // At this point we could add more profile state, e.g., for arguments.
1230     // But for now it&#39;s the same size as the base record type.
1231     return ReceiverTypeData::static_cell_count() JVMCI_ONLY(+ (uint) MethodProfileWidth * receiver_type_row_cell_count);
1232   }
1233 
1234   virtual int cell_count() const {
1235     return static_cell_count();
1236   }
1237 
1238   // Direct accessors
1239   static ByteSize virtual_call_data_size() {
1240     return cell_offset(static_cell_count());
1241   }
1242 
1243 #if INCLUDE_JVMCI
1244   static ByteSize method_offset(uint row) {
1245     return cell_offset(method_cell_index(row));
1246   }
1247   static ByteSize method_count_offset(uint row) {
1248     return cell_offset(method_count_cell_index(row));
1249   }
1250   static int method_cell_index(uint row) {
1251     return receiver0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1252   }
1253   static int method_count_cell_index(uint row) {
1254     return count0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1255   }
1256   static uint method_row_limit() {
1257     return MethodProfileWidth;
1258   }
1259 
1260   Method* method(uint row) const {
1261     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1262 
1263     Method* method = (Method*)intptr_at(method_cell_index(row));
1264     assert(method == NULL || method-&gt;is_method(), &quot;must be&quot;);
1265     return method;
1266   }
1267 
1268   uint method_count(uint row) const {
1269     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1270     return uint_at(method_count_cell_index(row));
1271   }
1272 
1273   void set_method(uint row, Method* m) {
1274     assert((uint)row &lt; method_row_limit(), &quot;oob&quot;);
1275     set_intptr_at(method_cell_index(row), (uintptr_t)m);
1276   }
1277 
1278   void set_method_count(uint row, uint count) {
1279     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1280     set_uint_at(method_count_cell_index(row), count);
1281   }
1282 
1283   void clear_method_row(uint row) {
1284     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1285     // Clear total count - indicator of polymorphic call site (see comment for clear_row() in ReceiverTypeData).
1286     set_nonprofiled_count(0);
1287     set_method(row, NULL);
1288     set_method_count(row, 0);
1289   }
1290 
1291   // GC support
1292   virtual void clean_weak_klass_links(bool always_clean);
1293 
1294   // Redefinition support
1295   virtual void clean_weak_method_links();
1296 #endif // INCLUDE_JVMCI
1297 
1298   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1299   void print_data_on(outputStream* st, const char* extra = NULL) const;
1300 };
1301 
1302 // VirtualCallTypeData
1303 //
1304 // A VirtualCallTypeData is used to access profiling information about
1305 // a virtual call for which we collect type information about
1306 // arguments and return value.
1307 class VirtualCallTypeData : public VirtualCallData {
1308 private:
1309   // entries for arguments if any
1310   TypeStackSlotEntries _args;
1311   // entry for return type if any
1312   ReturnTypeEntry _ret;
1313 
1314   int cell_count_global_offset() const {
1315     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1316   }
1317 
1318   // number of cells not counting the header
1319   int cell_count_no_header() const {
1320     return uint_at(cell_count_global_offset());
1321   }
1322 
1323   void check_number_of_arguments(int total) {
1324     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
1325   }
1326 
1327 public:
1328   VirtualCallTypeData(DataLayout* layout) :
1329     VirtualCallData(layout),
1330     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1331     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
1332   {
1333     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1334     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1335     _args.set_profile_data(this);
1336     _ret.set_profile_data(this);
1337   }
1338 
1339   const TypeStackSlotEntries* args() const {
1340     assert(has_arguments(), &quot;no profiling of arguments&quot;);
1341     return &amp;_args;
1342   }
1343 
1344   const ReturnTypeEntry* ret() const {
1345     assert(has_return(), &quot;no profiling of return value&quot;);
1346     return &amp;_ret;
1347   }
1348 
1349   virtual bool is_VirtualCallTypeData() const { return true; }
1350 
1351   static int static_cell_count() {
1352     return -1;
1353   }
1354 
1355   static int compute_cell_count(BytecodeStream* stream) {
1356     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1357   }
1358 
1359   static void initialize(DataLayout* dl, int cell_count) {
1360     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1361   }
1362 
1363   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1364 
1365   virtual int cell_count() const {
1366     return VirtualCallData::static_cell_count() +
1367       TypeEntriesAtCall::header_cell_count() +
1368       int_at_unchecked(cell_count_global_offset());
1369   }
1370 
1371   int number_of_arguments() const {
1372     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1373   }
1374 
1375   void set_argument_type(int i, Klass* k) {
1376     assert(has_arguments(), &quot;no arguments!&quot;);
1377     intptr_t current = _args.type(i);
1378     _args.set_type(i, TypeEntries::with_status(k, current));
1379   }
1380 
1381   void set_return_type(Klass* k) {
1382     assert(has_return(), &quot;no return!&quot;);
1383     intptr_t current = _ret.type();
1384     _ret.set_type(TypeEntries::with_status(k, current));
1385   }
1386 
1387   // An entry for a return value takes less space than an entry for an
1388   // argument, so if the remainder of the number of cells divided by
1389   // the number of cells for an argument is not null, a return value
1390   // is profiled in this object.
1391   bool has_return() const {
1392     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1393     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1394     return res;
1395   }
1396 
1397   // An entry for a return value takes less space than an entry for an
1398   // argument so if the number of cells exceeds the number of cells
1399   // needed for an argument, this object contains type information for
1400   // at least one argument.
1401   bool has_arguments() const {
1402     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1403     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1404     return res;
1405   }
1406 
1407   // Code generation support
1408   static ByteSize args_data_offset() {
1409     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1410   }
1411 
1412   ByteSize argument_type_offset(int i) {
1413     return _args.type_offset(i);
1414   }
1415 
1416   ByteSize return_type_offset() {
1417     return _ret.type_offset();
1418   }
1419 
1420   // GC support
1421   virtual void clean_weak_klass_links(bool always_clean) {
1422     ReceiverTypeData::clean_weak_klass_links(always_clean);
1423     if (has_arguments()) {
1424       _args.clean_weak_klass_links(always_clean);
1425     }
1426     if (has_return()) {
1427       _ret.clean_weak_klass_links(always_clean);
1428     }
1429   }
1430 
1431   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1432 };
1433 
1434 // RetData
1435 //
1436 // A RetData is used to access profiling information for a ret bytecode.
1437 // It is composed of a count of the number of times that the ret has
1438 // been executed, followed by a series of triples of the form
1439 // (bci, count, di) which count the number of times that some bci was the
1440 // target of the ret and cache a corresponding data displacement.
1441 class RetData : public CounterData {
1442 protected:
1443   enum {
1444     bci0_offset = counter_cell_count,
1445     count0_offset,
1446     displacement0_offset,
1447     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1448   };
1449 
1450   void set_bci(uint row, int bci) {
1451     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1452     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1453   }
1454   void release_set_bci(uint row, int bci);
1455   void set_bci_count(uint row, uint count) {
1456     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1457     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1458   }
1459   void set_bci_displacement(uint row, int disp) {
1460     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1461   }
1462 
1463 public:
1464   RetData(DataLayout* layout) : CounterData(layout) {
1465     assert(layout-&gt;tag() == DataLayout::ret_data_tag, &quot;wrong type&quot;);
1466   }
1467 
1468   virtual bool is_RetData() const { return true; }
1469 
1470   enum {
1471     no_bci = -1 // value of bci when bci1/2 are not in use.
1472   };
1473 
1474   static int static_cell_count() {
1475     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1476   }
1477 
1478   virtual int cell_count() const {
1479     return static_cell_count();
1480   }
1481 
1482   static uint row_limit() {
1483     return BciProfileWidth;
1484   }
1485   static int bci_cell_index(uint row) {
1486     return bci0_offset + row * ret_row_cell_count;
1487   }
1488   static int bci_count_cell_index(uint row) {
1489     return count0_offset + row * ret_row_cell_count;
1490   }
1491   static int bci_displacement_cell_index(uint row) {
1492     return displacement0_offset + row * ret_row_cell_count;
1493   }
1494 
1495   // Direct accessors
1496   int bci(uint row) const {
1497     return int_at(bci_cell_index(row));
1498   }
1499   uint bci_count(uint row) const {
1500     return uint_at(bci_count_cell_index(row));
1501   }
1502   int bci_displacement(uint row) const {
1503     return int_at(bci_displacement_cell_index(row));
1504   }
1505 
1506   // Interpreter Runtime support
1507   address fixup_ret(int return_bci, MethodData* mdo);
1508 
1509   // Code generation support
1510   static ByteSize bci_offset(uint row) {
1511     return cell_offset(bci_cell_index(row));
1512   }
1513   static ByteSize bci_count_offset(uint row) {
1514     return cell_offset(bci_count_cell_index(row));
1515   }
1516   static ByteSize bci_displacement_offset(uint row) {
1517     return cell_offset(bci_displacement_cell_index(row));
1518   }
1519 
1520   // Specific initialization.
1521   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1522 
1523   void print_data_on(outputStream* st, const char* extra = NULL) const;
1524 };
1525 
1526 // BranchData
1527 //
1528 // A BranchData is used to access profiling data for a two-way branch.
1529 // It consists of taken and not_taken counts as well as a data displacement
1530 // for the taken case.
1531 class BranchData : public JumpData {
1532   friend class VMStructs;
1533   friend class JVMCIVMStructs;
1534 protected:
1535   enum {
1536     not_taken_off_set = jump_cell_count,
1537     branch_cell_count
1538   };
1539 
1540   void set_displacement(int displacement) {
1541     set_int_at(displacement_off_set, displacement);
1542   }
1543 
1544 public:
1545   BranchData(DataLayout* layout) : JumpData(layout) {
1546     assert(layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
1547   }
1548 
1549   virtual bool is_BranchData() const { return true; }
1550 
1551   static int static_cell_count() {
1552     return branch_cell_count;
1553   }
1554 
1555   virtual int cell_count() const {
1556     return static_cell_count();
1557   }
1558 
1559   // Direct accessor
1560   uint not_taken() const {
1561     return uint_at(not_taken_off_set);
1562   }
1563 
1564   void set_not_taken(uint cnt) {
1565     set_uint_at(not_taken_off_set, cnt);
1566   }
1567 
1568   uint inc_not_taken() {
1569     uint cnt = not_taken() + 1;
1570     // Did we wrap? Will compiler screw us??
1571     if (cnt == 0) cnt--;
1572     set_uint_at(not_taken_off_set, cnt);
1573     return cnt;
1574   }
1575 
1576   // Code generation support
1577   static ByteSize not_taken_offset() {
1578     return cell_offset(not_taken_off_set);
1579   }
1580   static ByteSize branch_data_size() {
1581     return cell_offset(branch_cell_count);
1582   }
1583 
1584   // Specific initialization.
1585   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1586 
1587   void print_data_on(outputStream* st, const char* extra = NULL) const;
1588 };
1589 
1590 // ArrayData
1591 //
1592 // A ArrayData is a base class for accessing profiling data which does
1593 // not have a statically known size.  It consists of an array length
1594 // and an array start.
1595 class ArrayData : public ProfileData {
1596   friend class VMStructs;
1597   friend class JVMCIVMStructs;
1598 protected:
1599   friend class DataLayout;
1600 
1601   enum {
1602     array_len_off_set,
1603     array_start_off_set
1604   };
1605 
1606   uint array_uint_at(int index) const {
1607     int aindex = index + array_start_off_set;
1608     return uint_at(aindex);
1609   }
1610   int array_int_at(int index) const {
1611     int aindex = index + array_start_off_set;
1612     return int_at(aindex);
1613   }
1614   oop array_oop_at(int index) const {
1615     int aindex = index + array_start_off_set;
1616     return oop_at(aindex);
1617   }
1618   void array_set_int_at(int index, int value) {
1619     int aindex = index + array_start_off_set;
1620     set_int_at(aindex, value);
1621   }
1622 
1623   // Code generation support for subclasses.
1624   static ByteSize array_element_offset(int index) {
1625     return cell_offset(array_start_off_set + index);
1626   }
1627 
1628 public:
1629   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1630 
1631   virtual bool is_ArrayData() const { return true; }
1632 
1633   static int static_cell_count() {
1634     return -1;
1635   }
1636 
1637   int array_len() const {
1638     return int_at_unchecked(array_len_off_set);
1639   }
1640 
1641   virtual int cell_count() const {
1642     return array_len() + 1;
1643   }
1644 
1645   // Code generation support
1646   static ByteSize array_len_offset() {
1647     return cell_offset(array_len_off_set);
1648   }
1649   static ByteSize array_start_offset() {
1650     return cell_offset(array_start_off_set);
1651   }
1652 };
1653 
1654 // MultiBranchData
1655 //
1656 // A MultiBranchData is used to access profiling information for
1657 // a multi-way branch (*switch bytecodes).  It consists of a series
1658 // of (count, displacement) pairs, which count the number of times each
1659 // case was taken and specify the data displacment for each branch target.
1660 class MultiBranchData : public ArrayData {
1661   friend class VMStructs;
1662   friend class JVMCIVMStructs;
1663 protected:
1664   enum {
1665     default_count_off_set,
1666     default_disaplacement_off_set,
1667     case_array_start
1668   };
1669   enum {
1670     relative_count_off_set,
1671     relative_displacement_off_set,
1672     per_case_cell_count
1673   };
1674 
1675   void set_default_displacement(int displacement) {
1676     array_set_int_at(default_disaplacement_off_set, displacement);
1677   }
1678   void set_displacement_at(int index, int displacement) {
1679     array_set_int_at(case_array_start +
1680                      index * per_case_cell_count +
1681                      relative_displacement_off_set,
1682                      displacement);
1683   }
1684 
1685 public:
1686   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1687     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, &quot;wrong type&quot;);
1688   }
1689 
1690   virtual bool is_MultiBranchData() const { return true; }
1691 
1692   static int compute_cell_count(BytecodeStream* stream);
1693 
1694   int number_of_cases() const {
1695     int alen = array_len() - 2; // get rid of default case here.
1696     assert(alen % per_case_cell_count == 0, &quot;must be even&quot;);
1697     return (alen / per_case_cell_count);
1698   }
1699 
1700   uint default_count() const {
1701     return array_uint_at(default_count_off_set);
1702   }
1703   int default_displacement() const {
1704     return array_int_at(default_disaplacement_off_set);
1705   }
1706 
1707   uint count_at(int index) const {
1708     return array_uint_at(case_array_start +
1709                          index * per_case_cell_count +
1710                          relative_count_off_set);
1711   }
1712   int displacement_at(int index) const {
1713     return array_int_at(case_array_start +
1714                         index * per_case_cell_count +
1715                         relative_displacement_off_set);
1716   }
1717 
1718   // Code generation support
1719   static ByteSize default_count_offset() {
1720     return array_element_offset(default_count_off_set);
1721   }
1722   static ByteSize default_displacement_offset() {
1723     return array_element_offset(default_disaplacement_off_set);
1724   }
1725   static ByteSize case_count_offset(int index) {
1726     return case_array_offset() +
1727            (per_case_size() * index) +
1728            relative_count_offset();
1729   }
1730   static ByteSize case_array_offset() {
1731     return array_element_offset(case_array_start);
1732   }
1733   static ByteSize per_case_size() {
1734     return in_ByteSize(per_case_cell_count) * cell_size;
1735   }
1736   static ByteSize relative_count_offset() {
1737     return in_ByteSize(relative_count_off_set) * cell_size;
1738   }
1739   static ByteSize relative_displacement_offset() {
1740     return in_ByteSize(relative_displacement_off_set) * cell_size;
1741   }
1742 
1743   // Specific initialization.
1744   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1745 
1746   void print_data_on(outputStream* st, const char* extra = NULL) const;
1747 };
1748 
1749 class ArgInfoData : public ArrayData {
1750 
1751 public:
1752   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1753     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, &quot;wrong type&quot;);
1754   }
1755 
1756   virtual bool is_ArgInfoData() const { return true; }
1757 
1758 
1759   int number_of_args() const {
1760     return array_len();
1761   }
1762 
1763   uint arg_modified(int arg) const {
1764     return array_uint_at(arg);
1765   }
1766 
1767   void set_arg_modified(int arg, uint val) {
1768     array_set_int_at(arg, val);
1769   }
1770 
1771   void print_data_on(outputStream* st, const char* extra = NULL) const;
1772 };
1773 
1774 // ParametersTypeData
1775 //
1776 // A ParametersTypeData is used to access profiling information about
1777 // types of parameters to a method
1778 class ParametersTypeData : public ArrayData {
1779 
1780 private:
1781   TypeStackSlotEntries _parameters;
1782 
1783   static int stack_slot_local_offset(int i) {
1784     assert_profiling_enabled();
1785     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1786   }
1787 
1788   static int type_local_offset(int i) {
1789     assert_profiling_enabled();
1790     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
1791   }
1792 
1793   static bool profiling_enabled();
1794   static void assert_profiling_enabled() {
1795     assert(profiling_enabled(), &quot;method parameters profiling should be on&quot;);
1796   }
1797 
1798 public:
1799   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
1800     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, &quot;wrong type&quot;);
1801     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1802     _parameters.set_profile_data(this);
1803   }
1804 
1805   static int compute_cell_count(Method* m);
1806 
1807   virtual bool is_ParametersTypeData() const { return true; }
1808 
1809   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1810 
1811   int number_of_parameters() const {
1812     return array_len() / TypeStackSlotEntries::per_arg_count();
1813   }
1814 
1815   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
1816 
1817   uint stack_slot(int i) const {
1818     return _parameters.stack_slot(i);
1819   }
1820 
1821   void set_type(int i, Klass* k) {
1822     intptr_t current = _parameters.type(i);
1823     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
1824   }
1825 
1826   virtual void clean_weak_klass_links(bool always_clean) {
1827     _parameters.clean_weak_klass_links(always_clean);
1828   }
1829 
1830   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1831 
1832   static ByteSize stack_slot_offset(int i) {
1833     return cell_offset(stack_slot_local_offset(i));
1834   }
1835 
1836   static ByteSize type_offset(int i) {
1837     return cell_offset(type_local_offset(i));
1838   }
1839 };
1840 
1841 // SpeculativeTrapData
1842 //
1843 // A SpeculativeTrapData is used to record traps due to type
1844 // speculation. It records the root of the compilation: that type
1845 // speculation is wrong in the context of one compilation (for
1846 // method1) doesn&#39;t mean it&#39;s wrong in the context of another one (for
1847 // method2). Type speculation could have more/different data in the
1848 // context of the compilation of method2 and it&#39;s worthwhile to try an
1849 // optimization that failed for compilation of method1 in the context
1850 // of compilation of method2.
1851 // Space for SpeculativeTrapData entries is allocated from the extra
1852 // data space in the MDO. If we run out of space, the trap data for
1853 // the ProfileData at that bci is updated.
1854 class SpeculativeTrapData : public ProfileData {
1855 protected:
1856   enum {
1857     speculative_trap_method,
1858 #ifndef _LP64
1859     // The size of the area for traps is a multiple of the header
1860     // size, 2 cells on 32 bits. Packed at the end of this area are
1861     // argument info entries (with tag
1862     // DataLayout::arg_info_data_tag). The logic in
1863     // MethodData::bci_to_extra_data() that guarantees traps don&#39;t
1864     // overflow over argument info entries assumes the size of a
1865     // SpeculativeTrapData is twice the header size. On 32 bits, a
1866     // SpeculativeTrapData must be 4 cells.
1867     padding,
1868 #endif
1869     speculative_trap_cell_count
1870   };
1871 public:
1872   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
1873     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, &quot;wrong type&quot;);
1874   }
1875 
1876   virtual bool is_SpeculativeTrapData() const { return true; }
1877 
1878   static int static_cell_count() {
1879     return speculative_trap_cell_count;
1880   }
1881 
1882   virtual int cell_count() const {
1883     return static_cell_count();
1884   }
1885 
1886   // Direct accessor
1887   Method* method() const {
1888     return (Method*)intptr_at(speculative_trap_method);
1889   }
1890 
1891   void set_method(Method* m) {
1892     assert(!m-&gt;is_old(), &quot;cannot add old methods&quot;);
1893     set_intptr_at(speculative_trap_method, (intptr_t)m);
1894   }
1895 
1896   static ByteSize method_offset() {
1897     return cell_offset(speculative_trap_method);
1898   }
1899 
1900   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1901 };
1902 
1903 // MethodData*
1904 //
1905 // A MethodData* holds information which has been collected about
1906 // a method.  Its layout looks like this:
1907 //
1908 // -----------------------------
1909 // | header                    |
1910 // | klass                     |
1911 // -----------------------------
1912 // | method                    |
1913 // | size of the MethodData* |
1914 // -----------------------------
1915 // | Data entries...           |
1916 // |   (variable size)         |
1917 // |                           |
1918 // .                           .
1919 // .                           .
1920 // .                           .
1921 // |                           |
1922 // -----------------------------
1923 //
1924 // The data entry area is a heterogeneous array of DataLayouts. Each
1925 // DataLayout in the array corresponds to a specific bytecode in the
1926 // method.  The entries in the array are sorted by the corresponding
1927 // bytecode.  Access to the data is via resource-allocated ProfileData,
1928 // which point to the underlying blocks of DataLayout structures.
1929 //
1930 // During interpretation, if profiling in enabled, the interpreter
1931 // maintains a method data pointer (mdp), which points at the entry
1932 // in the array corresponding to the current bci.  In the course of
1933 // intepretation, when a bytecode is encountered that has profile data
1934 // associated with it, the entry pointed to by mdp is updated, then the
1935 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1936 // is NULL to begin with, the interpreter assumes that the current method
1937 // is not (yet) being profiled.
1938 //
1939 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1940 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1941 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1942 // in certain ProfileData objects that indicate the amount the mdp must be
1943 // adjusted in the event of a change in control flow.
1944 //
1945 
1946 class CleanExtraDataClosure : public StackObj {
1947 public:
1948   virtual bool is_live(Method* m) = 0;
1949 };
1950 
1951 
<a name="7" id="anc7"></a>



































1952 class MethodData : public Metadata {
1953   friend class VMStructs;
1954   friend class JVMCIVMStructs;
1955 private:
1956   friend class ProfileData;
1957   friend class TypeEntriesAtCall;
1958 
1959   // If you add a new field that points to any metaspace object, you
1960   // must add this field to MethodData::metaspace_pointers_do().
1961 
1962   // Back pointer to the Method*
1963   Method* _method;
1964 
1965   // Size of this oop in bytes
1966   int _size;
1967 
1968   // Cached hint for bci_to_dp and bci_to_data
1969   int _hint_di;
1970 
1971   Mutex _extra_data_lock;
1972 
1973   MethodData(const methodHandle&amp; method, int size, TRAPS);
1974 public:
1975   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
<a name="8" id="anc8"></a><span class="line-modified">1976   MethodData() : _extra_data_lock(Monitor::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
1977 
1978   bool is_methodData() const volatile { return true; }
1979   void initialize();
1980 
1981   // Whole-method sticky bits and flags
1982   enum {
<a name="9" id="anc9"></a><span class="line-modified">1983     _trap_hist_limit    = 24 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
1984     _trap_hist_mask     = max_jubyte,
1985     _extra_data_count   = 4     // extra DataLayout headers, for trap history
1986   }; // Public flag values
1987 private:
1988   uint _nof_decompiles;             // count of all nmethod removals
1989   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
1990   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
1991   union {
1992     intptr_t _align;
1993     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
1994   } _trap_hist;
1995 
1996   // Support for interprocedural escape analysis, from Thomas Kotzmann.
1997   intx              _eflags;          // flags on escape information
1998   intx              _arg_local;       // bit set of non-escaping arguments
1999   intx              _arg_stack;       // bit set of stack-allocatable arguments
2000   intx              _arg_returned;    // bit set of returned arguments
2001 
2002   int _creation_mileage;              // method mileage at MDO creation
2003 
2004   // How many invocations has this MDO seen?
2005   // These counters are used to determine the exact age of MDO.
2006   // We need those because in tiered a method can be concurrently
2007   // executed at different levels.
2008   InvocationCounter _invocation_counter;
2009   // Same for backedges.
2010   InvocationCounter _backedge_counter;
2011   // Counter values at the time profiling started.
2012   int               _invocation_counter_start;
2013   int               _backedge_counter_start;
2014   uint              _tenure_traps;
2015   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2016   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2017 
2018 #if INCLUDE_RTM_OPT
2019   // State of RTM code generation during compilation of the method
2020   int               _rtm_state;
2021 #endif
2022 
2023   // Number of loops and blocks is computed when compiling the first
2024   // time with C1. It is used to determine if method is trivial.
2025   short             _num_loops;
2026   short             _num_blocks;
2027   // Does this method contain anything worth profiling?
2028   enum WouldProfile {unknown, no_profile, profile};
2029   WouldProfile      _would_profile;
2030 
2031 #if INCLUDE_JVMCI
2032   // Support for HotSpotMethodData.setCompiledIRSize(int)
<a name="10" id="anc10"></a><span class="line-modified">2033   int               _jvmci_ir_size;</span>

2034 #endif
2035 
2036   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2037   int _data_size;
2038 
2039   // data index for the area dedicated to parameters. -1 if no
2040   // parameter profiling.
2041   enum { no_parameters = -2, parameters_uninitialized = -1 };
2042   int _parameters_type_data_di;
<a name="11" id="anc11"></a><span class="line-removed">2043   int parameters_size_in_bytes() const {</span>
<span class="line-removed">2044     ParametersTypeData* param = parameters_type_data();</span>
<span class="line-removed">2045     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="line-removed">2046   }</span>
2047 
2048   // Beginning of the data entries
2049   intptr_t _data[1];
2050 
2051   // Helper for size computation
2052   static int compute_data_size(BytecodeStream* stream);
2053   static int bytecode_cell_count(Bytecodes::Code code);
2054   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2055   enum { no_profile_data = -1, variable_cell_count = -2 };
2056 
2057   // Helper for initialization
2058   DataLayout* data_layout_at(int data_index) const {
2059     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2060     return (DataLayout*) (((address)_data) + data_index);
2061   }
2062 
2063   // Initialize an individual data segment.  Returns the size of
2064   // the segment in bytes.
2065   int initialize_data(BytecodeStream* stream, int data_index);
2066 
2067   // Helper for data_at
2068   DataLayout* limit_data_position() const {
2069     return data_layout_at(_data_size);
2070   }
2071   bool out_of_bounds(int data_index) const {
2072     return data_index &gt;= data_size();
2073   }
2074 
2075   // Give each of the data entries a chance to perform specific
2076   // data initialization.
2077   void post_initialize(BytecodeStream* stream);
2078 
2079   // hint accessors
2080   int      hint_di() const  { return _hint_di; }
2081   void set_hint_di(int di)  {
2082     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
2083     _hint_di = di;
2084   }
2085   ProfileData* data_before(int bci) {
2086     // avoid SEGV on this edge case
2087     if (data_size() == 0)
2088       return NULL;
2089     int hint = hint_di();
2090     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2091       return data_at(hint);
2092     return first_data();
2093   }
2094 
2095   // What is the index of the first data entry?
2096   int first_di() const { return 0; }
2097 
2098   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2099   // Find or create an extra ProfileData:
2100   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2101 
2102   // return the argument info cell
2103   ArgInfoData *arg_info();
2104 
2105   enum {
2106     no_type_profile = 0,
2107     type_profile_jsr292 = 1,
2108     type_profile_all = 2
2109   };
2110 
2111   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2112   static bool profile_unsafe(const methodHandle&amp; m, int bci);
2113   static int profile_arguments_flag();
2114   static bool profile_all_arguments();
2115   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2116   static int profile_return_flag();
2117   static bool profile_all_return();
2118   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2119   static int profile_parameters_flag();
2120   static bool profile_parameters_jsr292_only();
2121   static bool profile_all_parameters();
2122 
2123   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2124   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2125 
2126 public:
2127   void clean_extra_data(CleanExtraDataClosure* cl);
2128 
2129   static int header_size() {
2130     return sizeof(MethodData)/wordSize;
2131   }
2132 
2133   // Compute the size of a MethodData* before it is created.
2134   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2135   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2136   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2137 
2138   // Determine if a given bytecode can have profile information.
2139   static bool bytecode_has_profile(Bytecodes::Code code) {
2140     return bytecode_cell_count(code) != no_profile_data;
2141   }
2142 
2143   // reset into original state
2144   void init();
2145 
2146   // My size
2147   int size_in_bytes() const { return _size; }
2148   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
<a name="12" id="anc12"></a><span class="line-removed">2149 #if INCLUDE_SERVICES</span>
<span class="line-removed">2150   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">2151 #endif</span>
2152 
2153   int      creation_mileage() const  { return _creation_mileage; }
2154   void set_creation_mileage(int x)   { _creation_mileage = x; }
2155 
2156   int invocation_count() {
2157     if (invocation_counter()-&gt;carry()) {
2158       return InvocationCounter::count_limit;
2159     }
2160     return invocation_counter()-&gt;count();
2161   }
2162   int backedge_count() {
2163     if (backedge_counter()-&gt;carry()) {
2164       return InvocationCounter::count_limit;
2165     }
2166     return backedge_counter()-&gt;count();
2167   }
2168 
2169   int invocation_count_start() {
2170     if (invocation_counter()-&gt;carry()) {
2171       return 0;
2172     }
2173     return _invocation_counter_start;
2174   }
2175 
2176   int backedge_count_start() {
2177     if (backedge_counter()-&gt;carry()) {
2178       return 0;
2179     }
2180     return _backedge_counter_start;
2181   }
2182 
2183   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2184   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2185 
2186   void reset_start_counters() {
2187     _invocation_counter_start = invocation_count();
2188     _backedge_counter_start = backedge_count();
2189   }
2190 
2191   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2192   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2193 
<a name="13" id="anc13"></a>





2194 #if INCLUDE_RTM_OPT
2195   int rtm_state() const {
2196     return _rtm_state;
2197   }
2198   void set_rtm_state(RTMState rstate) {
2199     _rtm_state = (int)rstate;
2200   }
2201   void atomic_set_rtm_state(RTMState rstate) {
<a name="14" id="anc14"></a><span class="line-modified">2202     Atomic::store((int)rstate, &amp;_rtm_state);</span>
2203   }
2204 
2205   static int rtm_state_offset_in_bytes() {
2206     return offset_of(MethodData, _rtm_state);
2207   }
2208 #endif
2209 
2210   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2211   bool would_profile() const                  { return _would_profile != no_profile; }
2212 
2213   int num_loops() const                       { return _num_loops;  }
2214   void set_num_loops(int n)                   { _num_loops = n;     }
2215   int num_blocks() const                      { return _num_blocks; }
2216   void set_num_blocks(int n)                  { _num_blocks = n;    }
2217 
2218   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2219   static int mileage_of(Method* m);
2220 
2221   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2222   enum EscapeFlag {
2223     estimated    = 1 &lt;&lt; 0,
2224     return_local = 1 &lt;&lt; 1,
2225     return_allocated = 1 &lt;&lt; 2,
2226     allocated_escapes = 1 &lt;&lt; 3,
2227     unknown_modified = 1 &lt;&lt; 4
2228   };
2229 
2230   intx eflags()                                  { return _eflags; }
2231   intx arg_local()                               { return _arg_local; }
2232   intx arg_stack()                               { return _arg_stack; }
2233   intx arg_returned()                            { return _arg_returned; }
2234   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2235                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2236                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2237                                                    return aid-&gt;arg_modified(a); }
2238 
2239   void set_eflags(intx v)                        { _eflags = v; }
2240   void set_arg_local(intx v)                     { _arg_local = v; }
2241   void set_arg_stack(intx v)                     { _arg_stack = v; }
2242   void set_arg_returned(intx v)                  { _arg_returned = v; }
2243   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2244                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2245                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2246                                                    aid-&gt;set_arg_modified(a, v); }
2247 
2248   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2249 
2250   // Location and size of data area
2251   address data_base() const {
2252     return (address) _data;
2253   }
2254   int data_size() const {
2255     return _data_size;
2256   }
2257 
<a name="15" id="anc15"></a>




2258   // Accessors
2259   Method* method() const { return _method; }
2260 
2261   // Get the data at an arbitrary (sort of) data index.
2262   ProfileData* data_at(int data_index) const;
2263 
2264   // Walk through the data in order.
2265   ProfileData* first_data() const { return data_at(first_di()); }
2266   ProfileData* next_data(ProfileData* current) const;
2267   bool is_valid(ProfileData* current) const { return current != NULL; }
2268 
2269   // Convert a dp (data pointer) to a di (data index).
2270   int dp_to_di(address dp) const {
2271     return dp - ((address)_data);
2272   }
2273 
2274   // bci to di/dp conversion.
2275   address bci_to_dp(int bci);
2276   int bci_to_di(int bci) {
2277     return dp_to_di(bci_to_dp(bci));
2278   }
2279 
2280   // Get the data at an arbitrary bci, or NULL if there is none.
2281   ProfileData* bci_to_data(int bci);
2282 
2283   // Same, but try to create an extra_data record if one is needed:
2284   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2285     ProfileData* data = NULL;
2286     // If m not NULL, try to allocate a SpeculativeTrapData entry
2287     if (m == NULL) {
2288       data = bci_to_data(bci);
2289     }
2290     if (data != NULL) {
2291       return data;
2292     }
2293     data = bci_to_extra_data(bci, m, true);
2294     if (data != NULL) {
2295       return data;
2296     }
2297     // If SpeculativeTrapData allocation fails try to allocate a
2298     // regular entry
2299     data = bci_to_data(bci);
2300     if (data != NULL) {
2301       return data;
2302     }
2303     return bci_to_extra_data(bci, NULL, true);
2304   }
2305 
2306   // Add a handful of extra data records, for trap tracking.
2307   DataLayout* extra_data_base() const  { return limit_data_position(); }
2308   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2309   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2310                                                               parameters_size_in_bytes()); }
2311   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2312   static DataLayout* next_extra(DataLayout* dp);
2313 
2314   // Return (uint)-1 for overflow.
2315   uint trap_count(int reason) const {
2316     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2317     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2318   }
2319   // For loops:
2320   static uint trap_reason_limit() { return _trap_hist_limit; }
2321   static uint trap_count_limit()  { return _trap_hist_mask; }
2322   uint inc_trap_count(int reason) {
2323     // Count another trap, anywhere in this method.
2324     assert(reason &gt;= 0, &quot;must be single trap&quot;);
2325     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2326     uint cnt1 = 1 + _trap_hist._array[reason];
2327     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2328       _trap_hist._array[reason] = cnt1;
2329       return cnt1;
2330     } else {
2331       return _trap_hist_mask + (++_nof_overflow_traps);
2332     }
2333   }
2334 
2335   uint overflow_trap_count() const {
2336     return _nof_overflow_traps;
2337   }
2338   uint overflow_recompile_count() const {
2339     return _nof_overflow_recompiles;
2340   }
2341   void inc_overflow_recompile_count() {
2342     _nof_overflow_recompiles += 1;
2343   }
2344   uint decompile_count() const {
2345     return _nof_decompiles;
2346   }
2347   void inc_decompile_count() {
2348     _nof_decompiles += 1;
2349     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
<a name="16" id="anc16"></a><span class="line-modified">2350       method()-&gt;set_not_compilable(CompLevel_full_optimization, true, &quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;);</span>
2351     }
2352   }
2353   uint tenure_traps() const {
2354     return _tenure_traps;
2355   }
2356   void inc_tenure_traps() {
2357     _tenure_traps += 1;
2358   }
2359 
2360   // Return pointer to area dedicated to parameters in MDO
2361   ParametersTypeData* parameters_type_data() const {
2362     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2363     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2364   }
2365 
2366   int parameters_type_data_di() const {
2367     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2368     return _parameters_type_data_di;
2369   }
2370 
2371   // Support for code generation
2372   static ByteSize data_offset() {
2373     return byte_offset_of(MethodData, _data[0]);
2374   }
2375 
2376   static ByteSize trap_history_offset() {
2377     return byte_offset_of(MethodData, _trap_hist._array);
2378   }
2379 
2380   static ByteSize invocation_counter_offset() {
2381     return byte_offset_of(MethodData, _invocation_counter);
2382   }
2383 
2384   static ByteSize backedge_counter_offset() {
2385     return byte_offset_of(MethodData, _backedge_counter);
2386   }
2387 
2388   static ByteSize invoke_mask_offset() {
2389     return byte_offset_of(MethodData, _invoke_mask);
2390   }
2391 
2392   static ByteSize backedge_mask_offset() {
2393     return byte_offset_of(MethodData, _backedge_mask);
2394   }
2395 
2396   static ByteSize parameters_type_data_di_offset() {
2397     return byte_offset_of(MethodData, _parameters_type_data_di);
2398   }
2399 
2400   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2401   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2402 
<a name="17" id="anc17"></a><span class="line-modified">2403   // Deallocation support - no pointer fields to deallocate</span>
2404   void deallocate_contents(ClassLoaderData* loader_data) {}
2405 
2406   // GC support
2407   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2408 
2409   // Printing
2410   void print_on      (outputStream* st) const;
2411   void print_value_on(outputStream* st) const;
2412 
2413   // printing support for method data
2414   void print_data_on(outputStream* st) const;
2415 
2416   const char* internal_name() const { return &quot;{method data}&quot;; }
2417 
2418   // verification
2419   void verify_on(outputStream* st);
2420   void verify_data_on(outputStream* st);
2421 
2422   static bool profile_parameters_for_method(const methodHandle&amp; m);
2423   static bool profile_arguments();
2424   static bool profile_arguments_jsr292_only();
2425   static bool profile_return();
2426   static bool profile_parameters();
2427   static bool profile_return_jsr292_only();
2428 
2429   void clean_method_data(bool always_clean);
2430   void clean_weak_method_links();
2431   DEBUG_ONLY(void verify_clean_weak_method_links();)
2432   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2433 };
2434 
2435 #endif // SHARE_OOPS_METHODDATA_HPP
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
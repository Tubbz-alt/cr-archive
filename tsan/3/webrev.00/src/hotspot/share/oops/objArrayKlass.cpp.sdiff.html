<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 89           ek = element_klass-&gt;array_klass(n, CHECK_0);
 90         }  // re-lock
 91         return ek;
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
100   Symbol* name = NULL;
101   if (!element_klass-&gt;is_instance_klass() ||
102       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {
103 
104     ResourceMark rm(THREAD);
105     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
106     int len = element_klass-&gt;name()-&gt;utf8_length();
107     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
108     int idx = 0;
<span class="line-modified">109     new_str[idx++] = &#39;[&#39;;</span>
110     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
<span class="line-modified">111       new_str[idx++] = &#39;L&#39;;</span>
112     }
113     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
114     idx += len;
115     if (element_klass-&gt;is_instance_klass()) {
<span class="line-modified">116       new_str[idx++] = &#39;;&#39;;</span>
117     }
118     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">119     name = SymbolTable::new_permanent_symbol(new_str, CHECK_0);</span>
120     if (element_klass-&gt;is_instance_klass()) {
121       InstanceKlass* ik = InstanceKlass::cast(element_klass);
122       ik-&gt;set_array_name(name);
123     }
124   }
125 
126   // Initialize instance variables
127   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_0);
128 
<span class="line-removed">129   // Add all classes to our internal class loader list here,</span>
<span class="line-removed">130   // including classes in the bootstrap (NULL) class loader.</span>
<span class="line-removed">131   // GC walks these as strong roots.</span>
<span class="line-removed">132   loader_data-&gt;add_class(oak);</span>
<span class="line-removed">133 </span>
134   ModuleEntry* module = oak-&gt;module();
135   assert(module != NULL, &quot;No module entry for array&quot;);
136 
137   // Call complete_create_array_klass after all instance variables has been initialized.
138   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_0);
139 







140   return oak;
141 }
142 
143 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
144   this-&gt;set_dimension(n);
145   this-&gt;set_element_klass(element_klass);
146   // decrement refcount because object arrays are not explicitly freed.  The
147   // InstanceKlass array_name() keeps the name counted while the klass is
148   // loaded.
149   name-&gt;decrement_refcount();
150 
151   Klass* bk;
152   if (element_klass-&gt;is_objArray_klass()) {
153     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
154   } else {
155     bk = element_klass;
156   }
157   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
158   this-&gt;set_bottom_klass(bk);
159   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
</pre>
<hr />
<pre>
193         h_array-&gt;obj_at_put(index, sub_array);
194       }
195     } else {
196       // Since this array dimension has zero length, nothing will be
197       // allocated, however the lower dimension values must be checked
198       // for illegal values.
199       for (int i = 0; i &lt; rank - 1; ++i) {
200         sizes += 1;
201         if (*sizes &lt; 0) {
202           THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));
203         }
204       }
205     }
206   }
207   return h_array();
208 }
209 
210 // Either oop or narrowOop depending on UseCompressedOops.
211 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
212                             arrayOop d, size_t dst_offset, int length, TRAPS) {
<span class="line-modified">213   if (oopDesc::equals(s, d)) {</span>
214     // since source and destination are equal we do not need conversion checks.
215     assert(length &gt; 0, &quot;sanity check&quot;);
216     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
217   } else {
218     // We have to make sure all elements conform to the destination array
219     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
220     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
221     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
222       // elements are guaranteed to be subtypes, so no check necessary
223       ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
224     } else {
225       // slow case: need individual subtype checks
226       // note: don&#39;t use obj_at_put below because it includes a redundant store check
227       if (!ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length)) {
228         ResourceMark rm(THREAD);
229         stringStream ss;
230         if (!bound-&gt;is_subtype_of(stype)) {
231           ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into %s[]&quot;,
232                    stype-&gt;external_name(), bound-&gt;external_name());
233         } else {
</pre>
<hr />
<pre>
309   } else {
310     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(src_pos);
311     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(dst_pos);
312     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(s, src_offset, NULL) ==
313            objArrayOop(s)-&gt;obj_at_addr_raw&lt;oop&gt;(src_pos), &quot;sanity&quot;);
314     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(d, dst_offset, NULL) ==
315            objArrayOop(d)-&gt;obj_at_addr_raw&lt;oop&gt;(dst_pos), &quot;sanity&quot;);
316     do_copy(s, src_offset, d, dst_offset, length, CHECK);
317   }
318 }
319 
320 
321 Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
322 
323   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
324   int dim = dimension();
325   if (dim == n) return this;
326 
327   // lock-free read needs acquire semantics
328   if (higher_dimension_acquire() == NULL) {
<span class="line-modified">329     if (or_null)  return NULL;</span>
330 
331     ResourceMark rm;
332     JavaThread *jt = (JavaThread *)THREAD;
333     {
334       // Ensure atomic creation of higher dimensions
<span class="line-modified">335       MutexLocker mu(MultiArray_lock, THREAD);</span>
336 
337       // Check if another thread beat us
338       if (higher_dimension() == NULL) {
339 
340         // Create multi-dim klass object and link them together
341         Klass* k =
342           ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
343         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
344         ak-&gt;set_lower_dimension(this);
345         // use &#39;release&#39; to pair with lock-free load
346         release_set_higher_dimension(ak);
347         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
348       }
349     }
<span class="line-removed">350   } else {</span>
<span class="line-removed">351     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
352   }
353 
354   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
355   if (or_null) {
356     return ak-&gt;array_klass_or_null(n);
357   }

358   return ak-&gt;array_klass(n, THREAD);
359 }
360 
361 Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
362   return array_klass_impl(or_null, dimension() +  1, THREAD);
363 }
364 
365 bool ObjArrayKlass::can_be_primary_super_slow() const {
366   if (!bottom_klass()-&gt;can_be_primary_super())
367     // array of interfaces
368     return false;
369   else
370     return Klass::can_be_primary_super_slow();
371 }
372 
373 GrowableArray&lt;Klass*&gt;* ObjArrayKlass::compute_secondary_supers(int num_extra_slots,
374                                                                Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
375   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
376   // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
377   const Array&lt;Klass*&gt;* elem_supers = element_klass()-&gt;secondary_supers();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 89           ek = element_klass-&gt;array_klass(n, CHECK_0);
 90         }  // re-lock
 91         return ek;
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
100   Symbol* name = NULL;
101   if (!element_klass-&gt;is_instance_klass() ||
102       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {
103 
104     ResourceMark rm(THREAD);
105     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
106     int len = element_klass-&gt;name()-&gt;utf8_length();
107     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
108     int idx = 0;
<span class="line-modified">109     new_str[idx++] = JVM_SIGNATURE_ARRAY;</span>
110     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
<span class="line-modified">111       new_str[idx++] = JVM_SIGNATURE_CLASS;</span>
112     }
113     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
114     idx += len;
115     if (element_klass-&gt;is_instance_klass()) {
<span class="line-modified">116       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;</span>
117     }
118     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">119     name = SymbolTable::new_permanent_symbol(new_str);</span>
120     if (element_klass-&gt;is_instance_klass()) {
121       InstanceKlass* ik = InstanceKlass::cast(element_klass);
122       ik-&gt;set_array_name(name);
123     }
124   }
125 
126   // Initialize instance variables
127   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_0);
128 





129   ModuleEntry* module = oak-&gt;module();
130   assert(module != NULL, &quot;No module entry for array&quot;);
131 
132   // Call complete_create_array_klass after all instance variables has been initialized.
133   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_0);
134 
<span class="line-added">135   // Add all classes to our internal class loader list here,</span>
<span class="line-added">136   // including classes in the bootstrap (NULL) class loader.</span>
<span class="line-added">137   // Do this step after creating the mirror so that if the</span>
<span class="line-added">138   // mirror creation fails, loaded_classes_do() doesn&#39;t find</span>
<span class="line-added">139   // an array class without a mirror.</span>
<span class="line-added">140   loader_data-&gt;add_class(oak);</span>
<span class="line-added">141 </span>
142   return oak;
143 }
144 
145 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
146   this-&gt;set_dimension(n);
147   this-&gt;set_element_klass(element_klass);
148   // decrement refcount because object arrays are not explicitly freed.  The
149   // InstanceKlass array_name() keeps the name counted while the klass is
150   // loaded.
151   name-&gt;decrement_refcount();
152 
153   Klass* bk;
154   if (element_klass-&gt;is_objArray_klass()) {
155     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
156   } else {
157     bk = element_klass;
158   }
159   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
160   this-&gt;set_bottom_klass(bk);
161   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
</pre>
<hr />
<pre>
195         h_array-&gt;obj_at_put(index, sub_array);
196       }
197     } else {
198       // Since this array dimension has zero length, nothing will be
199       // allocated, however the lower dimension values must be checked
200       // for illegal values.
201       for (int i = 0; i &lt; rank - 1; ++i) {
202         sizes += 1;
203         if (*sizes &lt; 0) {
204           THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));
205         }
206       }
207     }
208   }
209   return h_array();
210 }
211 
212 // Either oop or narrowOop depending on UseCompressedOops.
213 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
214                             arrayOop d, size_t dst_offset, int length, TRAPS) {
<span class="line-modified">215   if (s == d) {</span>
216     // since source and destination are equal we do not need conversion checks.
217     assert(length &gt; 0, &quot;sanity check&quot;);
218     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
219   } else {
220     // We have to make sure all elements conform to the destination array
221     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
222     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
223     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
224       // elements are guaranteed to be subtypes, so no check necessary
225       ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
226     } else {
227       // slow case: need individual subtype checks
228       // note: don&#39;t use obj_at_put below because it includes a redundant store check
229       if (!ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length)) {
230         ResourceMark rm(THREAD);
231         stringStream ss;
232         if (!bound-&gt;is_subtype_of(stype)) {
233           ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into %s[]&quot;,
234                    stype-&gt;external_name(), bound-&gt;external_name());
235         } else {
</pre>
<hr />
<pre>
311   } else {
312     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(src_pos);
313     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(dst_pos);
314     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(s, src_offset, NULL) ==
315            objArrayOop(s)-&gt;obj_at_addr_raw&lt;oop&gt;(src_pos), &quot;sanity&quot;);
316     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(d, dst_offset, NULL) ==
317            objArrayOop(d)-&gt;obj_at_addr_raw&lt;oop&gt;(dst_pos), &quot;sanity&quot;);
318     do_copy(s, src_offset, d, dst_offset, length, CHECK);
319   }
320 }
321 
322 
323 Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
324 
325   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
326   int dim = dimension();
327   if (dim == n) return this;
328 
329   // lock-free read needs acquire semantics
330   if (higher_dimension_acquire() == NULL) {
<span class="line-modified">331     if (or_null) return NULL;</span>
332 
333     ResourceMark rm;
334     JavaThread *jt = (JavaThread *)THREAD;
335     {
336       // Ensure atomic creation of higher dimensions
<span class="line-modified">337       MutexLocker mu(THREAD, MultiArray_lock);</span>
338 
339       // Check if another thread beat us
340       if (higher_dimension() == NULL) {
341 
342         // Create multi-dim klass object and link them together
343         Klass* k =
344           ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
345         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
346         ak-&gt;set_lower_dimension(this);
347         // use &#39;release&#39; to pair with lock-free load
348         release_set_higher_dimension(ak);
349         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
350       }
351     }


352   }
353 
354   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
355   if (or_null) {
356     return ak-&gt;array_klass_or_null(n);
357   }
<span class="line-added">358   THREAD-&gt;check_possible_safepoint();</span>
359   return ak-&gt;array_klass(n, THREAD);
360 }
361 
362 Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
363   return array_klass_impl(or_null, dimension() +  1, THREAD);
364 }
365 
366 bool ObjArrayKlass::can_be_primary_super_slow() const {
367   if (!bottom_klass()-&gt;can_be_primary_super())
368     // array of interfaces
369     return false;
370   else
371     return Klass::can_be_primary_super_slow();
372 }
373 
374 GrowableArray&lt;Klass*&gt;* ObjArrayKlass::compute_secondary_supers(int num_extra_slots,
375                                                                Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
376   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
377   // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
378   const Array&lt;Klass*&gt;* elem_supers = element_klass()-&gt;secondary_supers();
</pre>
</td>
</tr>
</table>
<center><a href="methodData.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
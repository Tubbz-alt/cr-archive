<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/accessBackend.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 26 #define SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
 27 
 28 #include &quot;oops/access.hpp&quot;
 29 #include &quot;oops/accessBackend.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 template &lt;DecoratorSet decorators&gt;
 34 template &lt;DecoratorSet idecorators, typename T&gt;
 35 inline typename EnableIf&lt;
 36   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 37 RawAccessBarrier&lt;decorators&gt;::decode_internal(typename HeapOopType&lt;idecorators&gt;::type value) {
 38   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 39     return CompressedOops::decode_not_null(value);
 40   } else {
 41     return CompressedOops::decode(value);
 42   }
 43 }
 44 
 45 template &lt;DecoratorSet decorators&gt;
 46 template &lt;DecoratorSet idecorators, typename T&gt;
 47 inline typename EnableIf&lt;
 48   AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 49   typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 50 RawAccessBarrier&lt;decorators&gt;::encode_internal(T value) {
 51   if (HasDecorator&lt;decorators, IS_NOT_NULL&gt;::value) {
 52     return CompressedOops::encode_not_null(value);
 53   } else {
 54     return CompressedOops::encode(value);
 55   }
 56 }
 57 
 58 template &lt;DecoratorSet decorators&gt;
 59 template &lt;typename T&gt;
 60 inline void RawAccessBarrier&lt;decorators&gt;::oop_store(void* addr, T value) {
 61   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 62   Encoded encoded = encode(value);
 63   store(reinterpret_cast&lt;Encoded*&gt;(addr), encoded);
 64 }
 65 
 66 template &lt;DecoratorSet decorators&gt;
 67 template &lt;typename T&gt;
 68 inline void RawAccessBarrier&lt;decorators&gt;::oop_store_at(oop base, ptrdiff_t offset, T value) {
 69   oop_store(field_addr(base, offset), value);
 70 }
 71 
 72 template &lt;DecoratorSet decorators&gt;
 73 template &lt;typename T&gt;
 74 inline T RawAccessBarrier&lt;decorators&gt;::oop_load(void* addr) {
 75   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 76   Encoded encoded = load&lt;Encoded&gt;(reinterpret_cast&lt;Encoded*&gt;(addr));
 77   return decode&lt;T&gt;(encoded);
 78 }
 79 
 80 template &lt;DecoratorSet decorators&gt;
 81 template &lt;typename T&gt;
 82 inline T RawAccessBarrier&lt;decorators&gt;::oop_load_at(oop base, ptrdiff_t offset) {
 83   return oop_load&lt;T&gt;(field_addr(base, offset));
 84 }
 85 
 86 template &lt;DecoratorSet decorators&gt;
 87 template &lt;typename T&gt;
 88 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(T new_value, void* addr, T compare_value) {
 89   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
 90   Encoded encoded_new = encode(new_value);
 91   Encoded encoded_compare = encode(compare_value);
 92   Encoded encoded_result = atomic_cmpxchg(encoded_new,
 93                                           reinterpret_cast&lt;Encoded*&gt;(addr),
 94                                           encoded_compare);
 95   return decode&lt;T&gt;(encoded_result);
 96 }
 97 
 98 template &lt;DecoratorSet decorators&gt;
 99 template &lt;typename T&gt;
100 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
101   return oop_atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);
102 }
103 
104 template &lt;DecoratorSet decorators&gt;
105 template &lt;typename T&gt;
106 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(T new_value, void* addr) {
107   typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
108   Encoded encoded_new = encode(new_value);
109   Encoded encoded_result = atomic_xchg(encoded_new, reinterpret_cast&lt;Encoded*&gt;(addr));
110   return decode&lt;T&gt;(encoded_result);
111 }
112 
113 template &lt;DecoratorSet decorators&gt;
114 template &lt;typename T&gt;
115 inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {
116   return oop_atomic_xchg(new_value, field_addr(base, offset));
117 }
118 
119 template &lt;DecoratorSet decorators&gt;
120 template &lt;typename T&gt;
121 inline bool RawAccessBarrier&lt;decorators&gt;::oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
122                                                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
123                                                         size_t length) {
124   return arraycopy(src_obj, src_offset_in_bytes, src_raw,
125                    dst_obj, dst_offset_in_bytes, dst_raw,
126                    length);
127 }
128 
129 template &lt;DecoratorSet decorators&gt;
130 template &lt;DecoratorSet ds, typename T&gt;
131 inline typename EnableIf&lt;
132   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
133 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
134   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
135     OrderAccess::fence();
136   }
137   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));
138 }
139 
140 template &lt;DecoratorSet decorators&gt;
141 template &lt;DecoratorSet ds, typename T&gt;
142 inline typename EnableIf&lt;
143   HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
144 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
145   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));
146 }
147 
148 template &lt;DecoratorSet decorators&gt;
149 template &lt;DecoratorSet ds, typename T&gt;
150 inline typename EnableIf&lt;
151   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
152 RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
153   return Atomic::load(reinterpret_cast&lt;const volatile T*&gt;(addr));
154 }
155 
156 template &lt;DecoratorSet decorators&gt;
157 template &lt;DecoratorSet ds, typename T&gt;
158 inline typename EnableIf&lt;
159   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
160 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
161   OrderAccess::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);
162 }
163 
164 template &lt;DecoratorSet decorators&gt;
165 template &lt;DecoratorSet ds, typename T&gt;
166 inline typename EnableIf&lt;
167   HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
168 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
169   OrderAccess::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);
170 }
171 
172 template &lt;DecoratorSet decorators&gt;
173 template &lt;DecoratorSet ds, typename T&gt;
174 inline typename EnableIf&lt;
175   HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
176 RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
177   Atomic::store(value, reinterpret_cast&lt;volatile T*&gt;(addr));
178 }
179 
180 template &lt;DecoratorSet decorators&gt;
181 template &lt;DecoratorSet ds, typename T&gt;
182 inline typename EnableIf&lt;
183   HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
184 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {
185   return Atomic::cmpxchg(new_value,
186                          reinterpret_cast&lt;volatile T*&gt;(addr),
187                          compare_value,
188                          memory_order_relaxed);
189 }
190 
191 template &lt;DecoratorSet decorators&gt;
192 template &lt;DecoratorSet ds, typename T&gt;
193 inline typename EnableIf&lt;
194   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
195 RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {
196   return Atomic::cmpxchg(new_value,
197                          reinterpret_cast&lt;volatile T*&gt;(addr),
198                          compare_value,
199                          memory_order_conservative);
200 }
201 
202 template &lt;DecoratorSet decorators&gt;
203 template &lt;DecoratorSet ds, typename T&gt;
204 inline typename EnableIf&lt;
205   HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
206 RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(T new_value, void* addr) {
207   return Atomic::xchg(new_value,
208                       reinterpret_cast&lt;volatile T*&gt;(addr));
209 }
210 
211 // For platforms that do not have native support for wide atomics,
212 // we can emulate the atomicity using a lock. So here we check
213 // whether that is necessary or not.
214 
215 template &lt;DecoratorSet ds&gt;
216 template &lt;DecoratorSet decorators, typename T&gt;
217 inline typename EnableIf&lt;
218   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
219 RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(T new_value, void* addr) {
220   if (!AccessInternal::wide_atomic_needs_locking()) {
221     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);
222   } else {
223     AccessInternal::AccessLocker access_lock;
224     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
225     T old_val = RawAccess&lt;&gt;::load(p);
226     RawAccess&lt;&gt;::store(p, new_value);
227     return old_val;
228   }
229 }
230 
231 template &lt;DecoratorSet ds&gt;
232 template &lt;DecoratorSet decorators, typename T&gt;
233 inline typename EnableIf&lt;
234   AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
235 RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {
236   if (!AccessInternal::wide_atomic_needs_locking()) {
237     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);
238   } else {
239     AccessInternal::AccessLocker access_lock;
240     volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
241     T old_val = RawAccess&lt;&gt;::load(p);
242     if (old_val == compare_value) {
243       RawAccess&lt;&gt;::store(p, new_value);
244     }
245     return old_val;
246   }
247 }
248 
249 class RawAccessBarrierArrayCopy: public AllStatic {
250   template&lt;typename T&gt; struct IsHeapWordSized: public IntegralConstant&lt;bool, sizeof(T) == HeapWordSize&gt; { };
251 public:
252   template &lt;DecoratorSet decorators, typename T&gt;
253   static inline typename EnableIf&lt;
254     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value&gt;::type
255   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
256             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
257             size_t length) {
258     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
259     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
260 
261     // We do not check for ARRAYCOPY_ATOMIC for oops, because they are unconditionally always atomic.
262     if (HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value) {
263       AccessInternal::arraycopy_arrayof_conjoint_oops(src_raw, dst_raw, length);
264     } else {
265       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
266       AccessInternal::arraycopy_conjoint_oops(reinterpret_cast&lt;OopType*&gt;(src_raw),
267                                               reinterpret_cast&lt;OopType*&gt;(dst_raw), length);
268     }
269   }
270 
271   template &lt;DecoratorSet decorators, typename T&gt;
272   static inline typename EnableIf&lt;
273     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
274     HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value&gt;::type
275   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
276             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
277             size_t length) {
278     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
279     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
280 
281     AccessInternal::arraycopy_arrayof_conjoint(src_raw, dst_raw, length);
282   }
283 
284   template &lt;DecoratorSet decorators, typename T&gt;
285   static inline typename EnableIf&lt;
286     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
287     HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value&gt;::type
288   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
289             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
290             size_t length) {
291     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
292     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
293 
294     // There is only a disjoint optimization for word granularity copying
295     if (HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value) {
296       AccessInternal::arraycopy_disjoint_words_atomic(src_raw, dst_raw, length);
297     } else {
298       AccessInternal::arraycopy_disjoint_words(src_raw, dst_raw, length);
299     }
300   }
301 
302   template &lt;DecoratorSet decorators, typename T&gt;
303   static inline typename EnableIf&lt;
304     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
305     !(HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value) &amp;&amp;
306     !HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value &amp;&amp;
307     !HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value&gt;::type
308   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
309             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
310             size_t length) {
311     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
312     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
313 
314     AccessInternal::arraycopy_conjoint(src_raw, dst_raw, length);
315   }
316 
317   template &lt;DecoratorSet decorators, typename T&gt;
318   static inline typename EnableIf&lt;
319     !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
320     !(HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value &amp;&amp; IsHeapWordSized&lt;T&gt;::value) &amp;&amp;
321     !HasDecorator&lt;decorators, ARRAYCOPY_ARRAYOF&gt;::value &amp;&amp;
322     HasDecorator&lt;decorators, ARRAYCOPY_ATOMIC&gt;::value&gt;::type
323   arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
324             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
325             size_t length) {
326     src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
327     dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
328 
329     AccessInternal::arraycopy_conjoint_atomic(src_raw, dst_raw, length);
330   }
331 };
332 
333 template&lt;&gt; struct RawAccessBarrierArrayCopy::IsHeapWordSized&lt;void&gt;: public IntegralConstant&lt;bool, false&gt; { };
334 
335 template &lt;DecoratorSet decorators&gt;
336 template &lt;typename T&gt;
337 inline bool RawAccessBarrier&lt;decorators&gt;::arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
338                                                     arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
339                                                     size_t length) {
340   RawAccessBarrierArrayCopy::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
341                                                    dst_obj, dst_offset_in_bytes, dst_raw,
342                                                    length);
343   return true;
344 }
345 
346 template &lt;DecoratorSet decorators&gt;
347 inline void RawAccessBarrier&lt;decorators&gt;::clone(oop src, oop dst, size_t size) {
348   // 4839641 (4840070): We must do an oop-atomic copy, because if another thread
349   // is modifying a reference field in the clonee, a non-oop-atomic copy might
350   // be suspended in the middle of copying the pointer and end up with parts
351   // of two different pointers in the field.  Subsequent dereferences will crash.
352   // 4846409: an oop-copy of objects with long or double fields or arrays of same
353   // won&#39;t copy the longs/doubles atomically in 32-bit vm&#39;s, so we copy jlongs instead
354   // of oops.  We know objects are aligned on a minimum of an jlong boundary.
355   // The same is true of StubRoutines::object_copy and the various oop_copy
356   // variants, and of the code generated by the inline_native_clone intrinsic.
357 
358   assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;objects misaligned&quot;);
359   AccessInternal::arraycopy_conjoint_atomic(reinterpret_cast&lt;jlong*&gt;((oopDesc*)src),
360                                             reinterpret_cast&lt;jlong*&gt;((oopDesc*)dst),
361                                             align_object_size(size) / HeapWordsPerLong);
362   // Clear the header
363   dst-&gt;init_mark_raw();
364 }
365 
366 #endif // SHARE_OOPS_ACCESSBACKEND_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/markOop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_MARKOOP_INLINE_HPP
 26 #define SHARE_OOPS_MARKOOP_INLINE_HPP
 27 
 28 #include &quot;oops/klass.hpp&quot;
 29 #include &quot;oops/markOop.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/globals.hpp&quot;
 32 
 33 // Should this header be preserved during GC (when biased locking is enabled)?
 34 inline bool markOopDesc::must_be_preserved_with_bias(oop obj_containing_mark) const {
 35   assert(UseBiasedLocking, &quot;unexpected&quot;);
 36   if (has_bias_pattern()) {
 37     // Will reset bias at end of collection
 38     // Mark words of biased and currently locked objects are preserved separately
 39     return false;
 40   }
 41   markOop prototype_header = prototype_for_object(obj_containing_mark);
 42   if (prototype_header-&gt;has_bias_pattern()) {
 43     // Individual instance which has its bias revoked; must return
 44     // true for correctness
 45     return true;
 46   }
 47   return (!is_unlocked() || !has_no_hash());
 48 }
 49 
 50 // Should this header be preserved during GC?
 51 inline bool markOopDesc::must_be_preserved(oop obj_containing_mark) const {
 52   if (!UseBiasedLocking)
 53     return (!is_unlocked() || !has_no_hash());
 54   return must_be_preserved_with_bias(obj_containing_mark);
 55 }
 56 
 57 // Should this header be preserved in the case of a promotion failure
 58 // during scavenge (when biased locking is enabled)?
 59 inline bool markOopDesc::must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const {
 60   assert(UseBiasedLocking, &quot;unexpected&quot;);
 61   // We don&#39;t explicitly save off the mark words of biased and
 62   // currently-locked objects during scavenges, so if during a
 63   // promotion failure we encounter either a biased mark word or a
 64   // klass which still has a biasable prototype header, we have to
 65   // preserve the mark word. This results in oversaving, but promotion
 66   // failures are rare, and this avoids adding more complex logic to
 67   // the scavengers to call new variants of
 68   // BiasedLocking::preserve_marks() / restore_marks() in the middle
 69   // of a scavenge when a promotion failure has first been detected.
 70   if (has_bias_pattern() ||
 71       prototype_for_object(obj_containing_mark)-&gt;has_bias_pattern()) {
 72     return true;
 73   }
 74   return (!is_unlocked() || !has_no_hash());
 75 }
 76 
 77 // Should this header be preserved in the case of a promotion failure
 78 // during scavenge?
 79 inline bool markOopDesc::must_be_preserved_for_promotion_failure(oop obj_containing_mark) const {
 80   if (!UseBiasedLocking)
 81     return (!is_unlocked() || !has_no_hash());
 82   return must_be_preserved_with_bias_for_promotion_failure(obj_containing_mark);
 83 }
 84 
 85 
 86 // Same as must_be_preserved_with_bias_for_promotion_failure() except that
 87 // it takes a Klass* argument, instead of the object of which this is the mark word.
 88 inline bool markOopDesc::must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {
 89   assert(UseBiasedLocking, &quot;unexpected&quot;);
 90   // CMS scavenges preserve mark words in similar fashion to promotion failures; see above
 91   if (has_bias_pattern() ||
 92       klass_of_obj_containing_mark-&gt;prototype_header()-&gt;has_bias_pattern()) {
 93     return true;
 94   }
 95   return (!is_unlocked() || !has_no_hash());
 96 }
 97 
 98 // Same as must_be_preserved_for_promotion_failure() except that
 99 // it takes a Klass* argument, instead of the object of which this is the mark word.
100 inline bool markOopDesc::must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {
101   if (!UseBiasedLocking)
102     return (!is_unlocked() || !has_no_hash());
103   return must_be_preserved_with_bias_for_cms_scavenge(klass_of_obj_containing_mark);
104 }
105 
106 inline markOop markOopDesc::prototype_for_object(oop obj) {
107 #ifdef ASSERT
108   markOop prototype_header = obj-&gt;klass()-&gt;prototype_header();
109   assert(prototype_header == prototype() || prototype_header-&gt;has_bias_pattern(), &quot;corrupt prototype header&quot;);
110 #endif
111   return obj-&gt;klass()-&gt;prototype_header();
112 }
113 
114 #endif // SHARE_OOPS_MARKOOP_INLINE_HPP
    </pre>
  </body>
</html>
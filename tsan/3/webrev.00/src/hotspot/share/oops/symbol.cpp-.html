<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/symbol.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;classfile/altHashing.hpp&quot;
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/symbol.hpp&quot;
 35 #include &quot;runtime/atomic.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 
 38 uint32_t Symbol::pack_length_and_refcount(int length, int refcount) {
 39   STATIC_ASSERT(max_symbol_length == ((1 &lt;&lt; 16) - 1));
 40   STATIC_ASSERT(PERM_REFCOUNT == ((1 &lt;&lt; 16) - 1));
 41   assert(length &gt;= 0, &quot;negative length&quot;);
 42   assert(length &lt;= max_symbol_length, &quot;too long symbol&quot;);
 43   assert(refcount &gt;= 0, &quot;negative refcount&quot;);
 44   assert(refcount &lt;= PERM_REFCOUNT, &quot;invalid refcount&quot;);
 45   uint32_t hi = length;
 46   uint32_t lo = refcount;
 47   return (hi &lt;&lt; 16) | lo;
 48 }
 49 
 50 Symbol::Symbol(const u1* name, int length, int refcount) {
 51   _length_and_refcount =  pack_length_and_refcount(length, refcount);
 52   _identity_hash = (short)os::random();
 53   for (int i = 0; i &lt; length; i++) {
 54     byte_at_put(i, name[i]);
 55   }
 56 }
 57 
 58 void* Symbol::operator new(size_t sz, int len, TRAPS) throw() {
 59   int alloc_size = size(len)*wordSize;
 60   address res = (address) AllocateHeap(alloc_size, mtSymbol);
 61   return res;
 62 }
 63 
 64 void* Symbol::operator new(size_t sz, int len, Arena* arena, TRAPS) throw() {
 65   int alloc_size = size(len)*wordSize;
 66   address res = (address)arena-&gt;Amalloc_4(alloc_size);
 67   return res;
 68 }
 69 
 70 void Symbol::operator delete(void *p) {
 71   assert(((Symbol*)p)-&gt;refcount() == 0, &quot;should not call this&quot;);
 72   FreeHeap(p);
 73 }
 74 
 75 // ------------------------------------------------------------------
 76 // Symbol::starts_with
 77 //
 78 // Tests if the symbol starts with the specified prefix of the given
 79 // length.
 80 bool Symbol::starts_with(const char* prefix, int len) const {
 81   if (len &gt; utf8_length()) return false;
 82   while (len-- &gt; 0) {
 83     if (prefix[len] != char_at(len))
 84       return false;
 85   }
 86   assert(len == -1, &quot;we should be at the beginning&quot;);
 87   return true;
 88 }
 89 
 90 
 91 // ------------------------------------------------------------------
 92 // Symbol::index_of
 93 //
 94 // Finds if the given string is a substring of this symbol&#39;s utf8 bytes.
 95 // Return -1 on failure.  Otherwise return the first index where str occurs.
 96 int Symbol::index_of_at(int i, const char* str, int len) const {
 97   assert(i &gt;= 0 &amp;&amp; i &lt;= utf8_length(), &quot;oob&quot;);
 98   if (len &lt;= 0)  return 0;
 99   char first_char = str[0];
100   address bytes = (address) ((Symbol*)this)-&gt;base();
101   address limit = bytes + utf8_length() - len;  // inclusive limit
102   address scan = bytes + i;
103   if (scan &gt; limit)
104     return -1;
105   for (; scan &lt;= limit; scan++) {
106     scan = (address) memchr(scan, first_char, (limit + 1 - scan));
107     if (scan == NULL)
108       return -1;  // not found
109     assert(scan &gt;= bytes+i &amp;&amp; scan &lt;= limit, &quot;scan oob&quot;);
110     if (memcmp(scan, str, len) == 0)
111       return (int)(scan - bytes);
112   }
113   return -1;
114 }
115 
116 
117 char* Symbol::as_C_string(char* buf, int size) const {
118   if (size &gt; 0) {
119     int len = MIN2(size - 1, utf8_length());
120     for (int i = 0; i &lt; len; i++) {
121       buf[i] = char_at(i);
122     }
123     buf[len] = &#39;\0&#39;;
124   }
125   return buf;
126 }
127 
128 char* Symbol::as_C_string() const {
129   int len = utf8_length();
130   char* str = NEW_RESOURCE_ARRAY(char, len + 1);
131   return as_C_string(str, len + 1);
132 }
133 
134 void Symbol::print_utf8_on(outputStream* st) const {
135   st-&gt;print(&quot;%s&quot;, as_C_string());
136 }
137 
138 void Symbol::print_symbol_on(outputStream* st) const {
139   char *s;
140   st = st ? st : tty;
141   {
142     // ResourceMark may not affect st-&gt;print(). If st is a string
143     // stream it could resize, using the same resource arena.
144     ResourceMark rm;
145     s = as_quoted_ascii();
146     s = os::strdup(s);
147   }
148   if (s == NULL) {
149     st-&gt;print(&quot;(null)&quot;);
150   } else {
151     st-&gt;print(&quot;%s&quot;, s);
152     os::free(s);
153   }
154 }
155 
156 char* Symbol::as_quoted_ascii() const {
157   const char *ptr = (const char *)&amp;_body[0];
158   int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());
159   char* result = NEW_RESOURCE_ARRAY(char, quoted_length + 1);
160   UTF8::as_quoted_ascii(ptr, utf8_length(), result, quoted_length + 1);
161   return result;
162 }
163 
164 jchar* Symbol::as_unicode(int&amp; length) const {
165   Symbol* this_ptr = (Symbol*)this;
166   length = UTF8::unicode_length((char*)this_ptr-&gt;bytes(), utf8_length());
167   jchar* result = NEW_RESOURCE_ARRAY(jchar, length);
168   if (length &gt; 0) {
169     UTF8::convert_to_unicode((char*)this_ptr-&gt;bytes(), result, length);
170   }
171   return result;
172 }
173 
174 const char* Symbol::as_klass_external_name(char* buf, int size) const {
175   if (size &gt; 0) {
176     char* str    = as_C_string(buf, size);
177     int   length = (int)strlen(str);
178     // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
179     for (int index = 0; index &lt; length; index++) {
180       if (str[index] == &#39;/&#39;) {
181         str[index] = &#39;.&#39;;
182       }
183     }
184     return str;
185   } else {
186     return buf;
187   }
188 }
189 
190 const char* Symbol::as_klass_external_name() const {
191   char* str    = as_C_string();
192   int   length = (int)strlen(str);
193   // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
194   for (int index = 0; index &lt; length; index++) {
195     if (str[index] == &#39;/&#39;) {
196       str[index] = &#39;.&#39;;
197     }
198   }
199   return str;
200 }
201 
202 // Increment refcount while checking for zero.  If the Symbol&#39;s refcount becomes zero
203 // a thread could be concurrently removing the Symbol.  This is used during SymbolTable
204 // lookup to avoid reviving a dead Symbol.
205 bool Symbol::try_increment_refcount() {
206   uint32_t found = _length_and_refcount;
207   while (true) {
208     uint32_t old_value = found;
209     int refc = extract_refcount(old_value);
210     if (refc == PERM_REFCOUNT) {
211       return true;  // sticky max or created permanent
212     } else if (refc == 0) {
213       return false; // dead, can&#39;t revive.
214     } else {
215       found = Atomic::cmpxchg(old_value + 1, &amp;_length_and_refcount, old_value);
216       if (found == old_value) {
217         return true; // successfully updated.
218       }
219       // refcount changed, try again.
220     }
221   }
222 }
223 
224 // The increment_refcount() is called when not doing lookup. It is assumed that you
225 // have a symbol with a non-zero refcount and it can&#39;t become zero while referenced by
226 // this caller.
227 void Symbol::increment_refcount() {
228   if (!try_increment_refcount()) {
229 #ifdef ASSERT
230     print();
231     fatal(&quot;refcount has gone to zero&quot;);
232 #endif
233   }
234 #ifndef PRODUCT
235   if (refcount() != PERM_REFCOUNT) { // not a permanent symbol
236     NOT_PRODUCT(Atomic::inc(&amp;_total_count);)
237   }
238 #endif
239 }
240 
241 // Decrement refcount potentially while racing increment, so we need
242 // to check the value after attempting to decrement so that if another
243 // thread increments to PERM_REFCOUNT the value is not decremented.
244 void Symbol::decrement_refcount() {
245   uint32_t found = _length_and_refcount;
246   while (true) {
247     uint32_t old_value = found;
248     int refc = extract_refcount(old_value);
249     if (refc == PERM_REFCOUNT) {
250       return;  // refcount is permanent, permanent is sticky
251     } else if (refc == 0) {
252 #ifdef ASSERT
253       print();
254       fatal(&quot;refcount underflow&quot;);
255 #endif
256       return;
257     } else {
258       found = Atomic::cmpxchg(old_value - 1, &amp;_length_and_refcount, old_value);
259       if (found == old_value) {
260         return;  // successfully updated.
261       }
262       // refcount changed, try again.
263     }
264   }
265 }
266 
267 void Symbol::make_permanent() {
268   uint32_t found = _length_and_refcount;
269   while (true) {
270     uint32_t old_value = found;
271     int refc = extract_refcount(old_value);
272     if (refc == PERM_REFCOUNT) {
273       return;  // refcount is permanent, permanent is sticky
274     } else if (refc == 0) {
275 #ifdef ASSERT
276       print();
277       fatal(&quot;refcount underflow&quot;);
278 #endif
279       return;
280     } else {
281       int len = extract_length(old_value);
282       found = Atomic::cmpxchg(pack_length_and_refcount(len, PERM_REFCOUNT), &amp;_length_and_refcount, old_value);
283       if (found == old_value) {
284         return;  // successfully updated.
285       }
286       // refcount changed, try again.
287     }
288   }
289 }
290 
291 void Symbol::metaspace_pointers_do(MetaspaceClosure* it) {
292   if (log_is_enabled(Trace, cds)) {
293     LogStream trace_stream(Log(cds)::trace());
294     trace_stream.print(&quot;Iter(Symbol): %p &quot;, this);
295     print_value_on(&amp;trace_stream);
296     trace_stream.cr();
297   }
298 }
299 
300 void Symbol::print_on(outputStream* st) const {
301   st-&gt;print(&quot;Symbol: &#39;&quot;);
302   print_symbol_on(st);
303   st-&gt;print(&quot;&#39;&quot;);
304   st-&gt;print(&quot; count %d&quot;, refcount());
305 }
306 
307 // The print_value functions are present in all builds, to support the
308 // disassembler and error reporting.
309 void Symbol::print_value_on(outputStream* st) const {
310   st-&gt;print(&quot;&#39;&quot;);
311   for (int i = 0; i &lt; utf8_length(); i++) {
312     st-&gt;print(&quot;%c&quot;, char_at(i));
313   }
314   st-&gt;print(&quot;&#39;&quot;);
315 }
316 
317 bool Symbol::is_valid(Symbol* s) {
318   if (!is_aligned(s, sizeof(MetaWord))) return false;
319   if ((size_t)s &lt; os::min_page_size()) return false;
320 
321   if (!os::is_readable_range(s, s + 1)) return false;
322 
323   // Symbols are not allocated in Java heap.
324   if (Universe::heap()-&gt;is_in_reserved(s)) return false;
325 
326   int len = s-&gt;utf8_length();
327   if (len &lt; 0) return false;
328 
329   jbyte* bytes = (jbyte*) s-&gt;bytes();
330   return os::is_readable_range(bytes, bytes + len);
331 }
332 
333 // SymbolTable prints this in its statistics
334 NOT_PRODUCT(size_t Symbol::_total_count = 0;)
    </pre>
  </body>
</html>
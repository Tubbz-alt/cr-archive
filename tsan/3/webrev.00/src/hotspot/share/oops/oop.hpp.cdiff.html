<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/oop.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #define SHARE_OOPS_OOP_HPP
  
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/memRegion.hpp&quot;
  #include &quot;oops/access.hpp&quot;
<span class="line-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/metadata.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,44 ***</span>
  // oopDesc is abstract.
  // (see oopHierarchy for complete oop class hierarchy)
  //
  // no virtual functions allowed
  
<span class="line-removed">- extern bool always_do_update_barrier;</span>
<span class="line-removed">- </span>
  // Forward declarations.
  class OopClosure;
  class ScanClosure;
  class FastScanClosure;
  class FilteringClosure;
<span class="line-removed">- class CMSIsAliveClosure;</span>
  
  class PSPromotionManager;
  class ParCompactionManager;
  
  class oopDesc {
    friend class VMStructs;
    friend class JVMCIVMStructs;
   private:
<span class="line-modified">!   volatile markOop _mark;</span>
    union _metadata {
      Klass*      _klass;
      narrowKlass _compressed_klass;
    } _metadata;
  
   public:
<span class="line-modified">!   inline markOop  mark()          const;</span>
<span class="line-modified">!   inline markOop  mark_raw()      const;</span>
<span class="line-modified">!   inline markOop* mark_addr_raw() const;</span>
  
<span class="line-modified">!   inline void set_mark(volatile markOop m);</span>
<span class="line-modified">!   inline void set_mark_raw(volatile markOop m);</span>
<span class="line-modified">!   static inline void set_mark_raw(HeapWord* mem, markOop m);</span>
  
<span class="line-modified">!   inline void release_set_mark(markOop m);</span>
<span class="line-modified">!   inline markOop cas_set_mark(markOop new_mark, markOop old_mark);</span>
<span class="line-modified">!   inline markOop cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative);</span>
  
    // Used only to re-initialize the mark word (e.g., of promoted
    // objects during a GC) -- requires a valid klass pointer
    inline void init_mark();
    inline void init_mark_raw();
<span class="line-new-header">--- 38,41 ---</span>
  // oopDesc is abstract.
  // (see oopHierarchy for complete oop class hierarchy)
  //
  // no virtual functions allowed
  
  // Forward declarations.
  class OopClosure;
  class ScanClosure;
  class FastScanClosure;
  class FilteringClosure;
  
  class PSPromotionManager;
  class ParCompactionManager;
  
  class oopDesc {
    friend class VMStructs;
    friend class JVMCIVMStructs;
   private:
<span class="line-modified">!   volatile markWord _mark;</span>
    union _metadata {
      Klass*      _klass;
      narrowKlass _compressed_klass;
    } _metadata;
  
   public:
<span class="line-modified">!   inline markWord  mark()          const;</span>
<span class="line-modified">!   inline markWord  mark_raw()      const;</span>
<span class="line-modified">!   inline markWord* mark_addr_raw() const;</span>
  
<span class="line-modified">!   inline void set_mark(volatile markWord m);</span>
<span class="line-modified">!   inline void set_mark_raw(volatile markWord m);</span>
<span class="line-modified">!   static inline void set_mark_raw(HeapWord* mem, markWord m);</span>
  
<span class="line-modified">!   inline void release_set_mark(markWord m);</span>
<span class="line-modified">!   inline markWord cas_set_mark(markWord new_mark, markWord old_mark);</span>
<span class="line-modified">!   inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);</span>
  
    // Used only to re-initialize the mark word (e.g., of promoted
    // objects during a GC) -- requires a valid klass pointer
    inline void init_mark();
    inline void init_mark_raw();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,13 ***</span>
  
    // For klass field compression
    inline int klass_gap() const;
    inline void set_klass_gap(int z);
    static inline void set_klass_gap(HeapWord* mem, int z);
<span class="line-removed">-   // For when the klass pointer is being used as a linked list &quot;next&quot; field.</span>
<span class="line-removed">-   inline void set_klass_to_list_ptr(oop k);</span>
<span class="line-removed">-   inline oop list_ptr_from_klass();</span>
  
    // size of object header, aligned to platform wordSize
    static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
  
    // Returns whether this is an instance of k or an instance of a subclass of k
<span class="line-new-header">--- 90,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,14 ***</span>
      } else {
        return 0;
      }
    }
  
<span class="line-removed">-   inline static bool equals(oop o1, oop o2) { return Access&lt;&gt;::equals(o1, o2); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline static bool equals_raw(oop o1, oop o2) { return RawAccess&lt;&gt;::equals(o1, o2); }</span>
<span class="line-removed">- </span>
    // Access to fields in a instanceOop through these methods.
    template &lt;DecoratorSet decorator&gt;
    oop obj_field_access(int offset) const;
    oop obj_field(int offset) const;
    void obj_field_put(int offset, oop value);
<span class="line-new-header">--- 144,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,10 ***</span>
<span class="line-new-header">--- 167,12 ---</span>
    jchar char_field(int offset) const;
    void char_field_put(int offset, jchar contents);
  
    jboolean bool_field(int offset) const;
    void bool_field_put(int offset, jboolean contents);
<span class="line-added">+   jboolean bool_field_volatile(int offset) const;</span>
<span class="line-added">+   void bool_field_put_volatile(int offset, jboolean contents);</span>
  
    jint int_field(int offset) const;
    jint int_field_raw(int offset) const;
    void int_field_put(int offset, jint contents);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,29 ***</span>
    inline bool has_bias_pattern_raw() const;
  
    // asserts and guarantees
    static bool is_oop(oop obj, bool ignore_mark_word = false);
    static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   inline bool is_unlocked_oop() const;</span>
<span class="line-removed">-   static bool is_archived_object(oop p) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
<span class="line-removed">- #endif</span>
  
    // garbage collection
    inline bool is_gc_marked() const;
  
    // Forward pointer operations for scavenge
    inline bool is_forwarded() const;
  
    inline void forward_to(oop p);
<span class="line-modified">!   inline bool cas_forward_to(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);</span>
  
    // Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.
    // Exactly one thread succeeds in inserting the forwarding pointer, and
    // this call returns &quot;NULL&quot; for that thread; any other thread has the
    // value of the forwarding pointer returned and does not modify &quot;this&quot;.
<span class="line-modified">!   inline oop forward_to_atomic(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);</span>
  
    inline oop forwardee() const;
    inline oop forwardee_acquire() const;
  
    // Age of object during scavenge
<span class="line-new-header">--- 246,27 ---</span>
    inline bool has_bias_pattern_raw() const;
  
    // asserts and guarantees
    static bool is_oop(oop obj, bool ignore_mark_word = false);
    static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);
  
    // garbage collection
    inline bool is_gc_marked() const;
  
    // Forward pointer operations for scavenge
    inline bool is_forwarded() const;
  
<span class="line-added">+   void verify_forwardee(oop forwardee) NOT_DEBUG_RETURN;</span>
<span class="line-added">+ </span>
    inline void forward_to(oop p);
<span class="line-modified">!   inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);</span>
  
    // Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.
    // Exactly one thread succeeds in inserting the forwarding pointer, and
    // this call returns &quot;NULL&quot; for that thread; any other thread has the
    // value of the forwarding pointer returned and does not modify &quot;this&quot;.
<span class="line-modified">!   inline oop forward_to_atomic(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);</span>
  
    inline oop forwardee() const;
    inline oop forwardee_acquire() const;
  
    // Age of object during scavenge
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,13 ***</span>
    // safepoint if called on a biased object. Calling code must be aware of that.
    inline intptr_t identity_hash();
    intptr_t slow_identity_hash();
  
    // marks are forwarded to stack when object is locked
<span class="line-modified">!   inline bool    has_displaced_mark_raw() const;</span>
<span class="line-modified">!   inline markOop displaced_mark_raw() const;</span>
<span class="line-modified">!   inline void    set_displaced_mark_raw(markOop m);</span>
  
    static bool has_klass_gap();
  
    // for code generation
    static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }
<span class="line-new-header">--- 298,18 ---</span>
    // safepoint if called on a biased object. Calling code must be aware of that.
    inline intptr_t identity_hash();
    intptr_t slow_identity_hash();
  
    // marks are forwarded to stack when object is locked
<span class="line-modified">!   inline bool     has_displaced_mark_raw() const;</span>
<span class="line-modified">!   inline markWord displaced_mark_raw() const;</span>
<span class="line-modified">!   inline void     set_displaced_mark_raw(markWord m);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Checks if the mark word needs to be preserved</span>
<span class="line-added">+   inline bool mark_must_be_preserved() const;</span>
<span class="line-added">+   inline bool mark_must_be_preserved(markWord m) const;</span>
<span class="line-added">+   inline bool mark_must_be_preserved_for_promotion_failure(markWord m) const;</span>
  
    static bool has_klass_gap();
  
    // for code generation
    static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,13 ***</span>
      assert(has_klass_gap(), &quot;only applicable to compressed klass pointers&quot;);
      return klass_offset_in_bytes() + sizeof(narrowKlass);
    }
  
    // for error reporting
<span class="line-removed">-   static oop   decode_oop_raw(narrowOop narrow_oop);</span>
    static void* load_klass_raw(oop obj);
    static void* load_oop_raw(oop obj, int offset);
<span class="line-removed">-   static bool  is_valid(oop obj);</span>
<span class="line-removed">-   static oop   oop_or_null(address addr);</span>
  };
  
  #endif // SHARE_OOPS_OOP_HPP
<span class="line-new-header">--- 318,10 ---</span>
</pre>
<center><a href="oop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
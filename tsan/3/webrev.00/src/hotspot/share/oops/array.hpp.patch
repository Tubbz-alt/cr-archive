diff a/src/hotspot/share/oops/array.hpp b/src/hotspot/share/oops/array.hpp
--- a/src/hotspot/share/oops/array.hpp
+++ b/src/hotspot/share/oops/array.hpp
@@ -25,12 +25,13 @@
 #ifndef SHARE_OOPS_ARRAY_HPP
 #define SHARE_OOPS_ARRAY_HPP
 
 #include "memory/allocation.hpp"
 #include "memory/metaspace.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/align.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 // Array for metadata allocation
 
 template <typename T>
 class Array: public MetaspaceObj {
@@ -47,13 +48,11 @@
   void initialize(int length) {
     _length = length;
   }
 
  private:
-  // Turn off copy constructor and assignment operator.
-  Array(const Array<T>&);
-  void operator=(const Array<T>&);
+  NONCOPYABLE(Array);
 
   void* operator new(size_t size, ClassLoaderData* loader_data, int length, TRAPS) throw() {
     size_t word_size = Array::size(length);
     return (void*) Metaspace::allocate(loader_data, word_size,
                                        MetaspaceObj::array_type(sizeof(T)), THREAD);
@@ -120,12 +119,12 @@
   T    at(int i) const                 { assert(i >= 0 && i< _length, "oob: 0 <= %d < %d", i, _length); return _data[i]; }
   void at_put(const int i, const T& x) { assert(i >= 0 && i< _length, "oob: 0 <= %d < %d", i, _length); _data[i] = x; }
   T*   adr_at(const int i)             { assert(i >= 0 && i< _length, "oob: 0 <= %d < %d", i, _length); return &_data[i]; }
   int  find(const T& x)                { return index_of(x); }
 
-  T at_acquire(const int i)            { return OrderAccess::load_acquire(adr_at(i)); }
-  void release_at_put(int i, T x)      { OrderAccess::release_store(adr_at(i), x); }
+  T at_acquire(const int i)            { return Atomic::load_acquire(adr_at(i)); }
+  void release_at_put(int i, T x)      { Atomic::release_store(adr_at(i), x); }
 
   static int size(int length) {
     size_t bytes = align_up(byte_sizeof(length), BytesPerWord);
     size_t words = bytes / BytesPerWord;
 

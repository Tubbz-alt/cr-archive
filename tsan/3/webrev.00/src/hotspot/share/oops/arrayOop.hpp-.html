<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/arrayOop.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ARRAYOOP_HPP
 26 #define SHARE_OOPS_ARRAYOOP_HPP
 27 
 28 #include &quot;memory/universe.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
 31 
 32 // arrayOopDesc is the abstract baseclass for all arrays.  It doesn&#39;t
 33 // declare pure virtual to enforce this because that would allocate a vtbl
 34 // in each instance, which we don&#39;t want.
 35 
 36 // The layout of array Oops is:
 37 //
 38 //  markOop
 39 //  Klass*    // 32 bits if compressed but declared 64 in LP64.
 40 //  length    // shares klass memory or allocated after declared fields.
 41 
 42 
 43 class arrayOopDesc : public oopDesc {
 44   friend class VMStructs;
 45   friend class arrayOopDescTest;
 46 
 47   // Interpreter/Compiler offsets
 48 
 49   // Header size computation.
 50   // The header is considered the oop part of this type plus the length.
 51   // Returns the aligned header_size_in_bytes.  This is not equivalent to
 52   // sizeof(arrayOopDesc) which should not appear in the code.
 53   static int header_size_in_bytes() {
 54     size_t hs = align_up(length_offset_in_bytes() + sizeof(int),
 55                               HeapWordSize);
 56 #ifdef ASSERT
 57     // make sure it isn&#39;t called before UseCompressedOops is initialized.
 58     static size_t arrayoopdesc_hs = 0;
 59     if (arrayoopdesc_hs == 0) arrayoopdesc_hs = hs;
 60     assert(arrayoopdesc_hs == hs, &quot;header size can&#39;t change&quot;);
 61 #endif // ASSERT
 62     return (int)hs;
 63   }
 64 
 65   // Check whether an element of a typeArrayOop with the given type must be
 66   // aligned 0 mod 8.  The typeArrayOop itself must be aligned at least this
 67   // strongly.
 68   static bool element_type_should_be_aligned(BasicType type) {
 69     return type == T_DOUBLE || type == T_LONG;
 70   }
 71 
 72  public:
 73   // The _length field is not declared in C++.  It is allocated after the
 74   // declared nonstatic fields in arrayOopDesc if not compressed, otherwise
 75   // it occupies the second half of the _klass field in oopDesc.
 76   static int length_offset_in_bytes() {
 77     return UseCompressedClassPointers ? klass_gap_offset_in_bytes() :
 78                                sizeof(arrayOopDesc);
 79   }
 80 
 81   // Returns the offset of the first element.
 82   static int base_offset_in_bytes(BasicType type) {
 83     return header_size(type) * HeapWordSize;
 84   }
 85 
 86   // Returns the address of the first element. The elements in the array will not
 87   // relocate from this address until a subsequent thread transition.
 88   inline void* base(BasicType type) const;
 89   inline void* base_raw(BasicType type) const; // GC barrier invariant
 90 
 91   template &lt;typename T&gt;
 92   static T* obj_offset_to_raw(arrayOop obj, size_t offset_in_bytes, T* raw) {
 93     if (obj != NULL) {
 94       assert(raw == NULL, &quot;either raw or in-heap&quot;);
 95       char* base = reinterpret_cast&lt;char*&gt;((void*) obj);
 96       raw = reinterpret_cast&lt;T*&gt;(base + offset_in_bytes);
 97     } else {
 98       assert(raw != NULL, &quot;either raw or in-heap&quot;);
 99     }
100     return raw;
101   }
102 
103   // Tells whether index is within bounds.
104   bool is_within_bounds(int index) const        { return 0 &lt;= index &amp;&amp; index &lt; length(); }
105 
106   // Accessors for instance variable which is not a C++ declared nonstatic
107   // field.
108   int length() const {
109     return *(int*)(((intptr_t)this) + length_offset_in_bytes());
110   }
111   void set_length(int length) {
112     set_length((HeapWord*)this, length);
113   }
114   static void set_length(HeapWord* mem, int length) {
115     *(int*)(((char*)mem) + length_offset_in_bytes()) = length;
116   }
117 
118   // Should only be called with constants as argument
119   // (will not constant fold otherwise)
120   // Returns the header size in words aligned to the requirements of the
121   // array object type.
122   static int header_size(BasicType type) {
123     size_t typesize_in_bytes = header_size_in_bytes();
124     return (int)(element_type_should_be_aligned(type)
125       ? align_object_offset(typesize_in_bytes/HeapWordSize)
126       : typesize_in_bytes/HeapWordSize);
127   }
128 
129   // Return the maximum length of an array of BasicType.  The length can passed
130   // to typeArrayOop::object_size(scale, length, header_size) without causing an
131   // overflow. We also need to make sure that this will not overflow a size_t on
132   // 32 bit platforms when we convert it to a byte size.
133   static int32_t max_array_length(BasicType type) {
134     assert(type &gt;= 0 &amp;&amp; type &lt; T_CONFLICT, &quot;wrong type&quot;);
135     assert(type2aelembytes(type) != 0, &quot;wrong type&quot;);
136 
137     const size_t max_element_words_per_size_t =
138       align_down((SIZE_MAX/HeapWordSize - header_size(type)), MinObjAlignment);
139     const size_t max_elements_per_size_t =
140       HeapWordSize * max_element_words_per_size_t / type2aelembytes(type);
141     if ((size_t)max_jint &lt; max_elements_per_size_t) {
142       // It should be ok to return max_jint here, but parts of the code
143       // (CollectedHeap, Klass::oop_oop_iterate(), and more) uses an int for
144       // passing around the size (in words) of an object. So, we need to avoid
145       // overflowing an int when we add the header. See CRs 4718400 and 7110613.
146       return align_down(max_jint - header_size(type), MinObjAlignment);
147     }
148     return (int32_t)max_elements_per_size_t;
149   }
150 
151 };
152 
153 #endif // SHARE_OOPS_ARRAYOOP_HPP
    </pre>
  </body>
</html>
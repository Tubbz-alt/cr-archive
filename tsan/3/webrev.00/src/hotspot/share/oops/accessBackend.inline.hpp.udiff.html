<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/accessBackend.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="accessBackend.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,10 +27,12 @@</span>
  
  #include &quot;oops/access.hpp&quot;
  #include &quot;oops/accessBackend.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet idecorators, typename T&gt;
  inline typename EnableIf&lt;
    AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,39 +85,39 @@</span>
    return oop_load&lt;T&gt;(field_addr(base, offset));
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="udiff-line-modified-added">+ inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
    typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
    Encoded encoded_new = encode(new_value);
    Encoded encoded_compare = encode(compare_value);
<span class="udiff-line-modified-removed">-   Encoded encoded_result = atomic_cmpxchg(encoded_new,</span>
<span class="udiff-line-modified-removed">-                                           reinterpret_cast&lt;Encoded*&gt;(addr),</span>
<span class="udiff-line-modified-removed">-                                           encoded_compare);</span>
<span class="udiff-line-modified-added">+   Encoded encoded_result = atomic_cmpxchg(reinterpret_cast&lt;Encoded*&gt;(addr),</span>
<span class="udiff-line-modified-added">+                                           encoded_compare,</span>
<span class="udiff-line-modified-added">+                                           encoded_new);</span>
    return decode&lt;T&gt;(encoded_result);
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="udiff-line-modified-removed">-   return oop_atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);</span>
<span class="udiff-line-modified-added">+ inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="udiff-line-modified-added">+   return oop_atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(T new_value, void* addr) {</span>
<span class="udiff-line-modified-added">+ inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg(void* addr, T new_value) {</span>
    typedef typename AccessInternal::EncodedType&lt;decorators, T&gt;::type Encoded;
    Encoded encoded_new = encode(new_value);
<span class="udiff-line-modified-removed">-   Encoded encoded_result = atomic_xchg(encoded_new, reinterpret_cast&lt;Encoded*&gt;(addr));</span>
<span class="udiff-line-modified-added">+   Encoded encoded_result = atomic_xchg(reinterpret_cast&lt;Encoded*&gt;(addr), encoded_new);</span>
    return decode&lt;T&gt;(encoded_result);
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-modified-removed">-   return oop_atomic_xchg(new_value, field_addr(base, offset));</span>
<span class="udiff-line-modified-added">+ inline T RawAccessBarrier&lt;decorators&gt;::oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="udiff-line-modified-added">+   return oop_atomic_xchg(field_addr(base, offset), new_value);</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;typename T&gt;
  inline bool RawAccessBarrier&lt;decorators&gt;::oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,19 +134,19 @@</span>
    HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
  RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
      OrderAccess::fence();
    }
<span class="udiff-line-modified-removed">-   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
<span class="udiff-line-modified-added">+   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
  RawAccessBarrier&lt;decorators&gt;::load_internal(void* addr) {
<span class="udiff-line-modified-removed">-   return OrderAccess::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
<span class="udiff-line-modified-added">+   return Atomic::load_acquire(reinterpret_cast&lt;const volatile T*&gt;(addr));</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,71 +158,71 @@</span>
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
  RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="udiff-line-modified-removed">-   OrderAccess::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store_fence(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
  RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
  RawAccessBarrier&lt;decorators&gt;::store_internal(void* addr, T value) {
<span class="udiff-line-modified-removed">-   Atomic::store(value, reinterpret_cast&lt;volatile T*&gt;(addr));</span>
<span class="udiff-line-modified-added">+   Atomic::store(reinterpret_cast&lt;volatile T*&gt;(addr), value);</span>
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="udiff-line-modified-removed">- RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {</span>
<span class="udiff-line-modified-removed">-   return Atomic::cmpxchg(new_value,</span>
<span class="udiff-line-removed">-                          reinterpret_cast&lt;volatile T*&gt;(addr),</span>
<span class="udiff-line-modified-added">+ RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {</span>
<span class="udiff-line-modified-added">+   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>
                           compare_value,
<span class="udiff-line-added">+                          new_value,</span>
                           memory_order_relaxed);
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="udiff-line-modified-removed">- RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(T new_value, void* addr, T compare_value) {</span>
<span class="udiff-line-modified-removed">-   return Atomic::cmpxchg(new_value,</span>
<span class="udiff-line-removed">-                          reinterpret_cast&lt;volatile T*&gt;(addr),</span>
<span class="udiff-line-modified-added">+ RawAccessBarrier&lt;decorators&gt;::atomic_cmpxchg_internal(void* addr, T compare_value, T new_value) {</span>
<span class="udiff-line-modified-added">+   return Atomic::cmpxchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>
                           compare_value,
<span class="udiff-line-added">+                          new_value,</span>
                           memory_order_conservative);
  }
  
  template &lt;DecoratorSet decorators&gt;
  template &lt;DecoratorSet ds, typename T&gt;
  inline typename EnableIf&lt;
    HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="udiff-line-modified-removed">- RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(T new_value, void* addr) {</span>
<span class="udiff-line-modified-removed">-   return Atomic::xchg(new_value,</span>
<span class="udiff-line-modified-removed">-                       reinterpret_cast&lt;volatile T*&gt;(addr));</span>
<span class="udiff-line-modified-added">+ RawAccessBarrier&lt;decorators&gt;::atomic_xchg_internal(void* addr, T new_value) {</span>
<span class="udiff-line-modified-added">+   return Atomic::xchg(reinterpret_cast&lt;volatile T*&gt;(addr),</span>
<span class="udiff-line-modified-added">+                       new_value);</span>
  }
  
  // For platforms that do not have native support for wide atomics,
  // we can emulate the atomicity using a lock. So here we check
  // whether that is necessary or not.
  
  template &lt;DecoratorSet ds&gt;
  template &lt;DecoratorSet decorators, typename T&gt;
  inline typename EnableIf&lt;
    AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="udiff-line-modified-removed">- RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(T new_value, void* addr) {</span>
<span class="udiff-line-modified-added">+ RawAccessBarrier&lt;ds&gt;::atomic_xchg_maybe_locked(void* addr, T new_value) {</span>
    if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="udiff-line-modified-removed">-     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);</span>
<span class="udiff-line-modified-added">+     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);</span>
    } else {
      AccessInternal::AccessLocker access_lock;
      volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
      T old_val = RawAccess&lt;&gt;::load(p);
      RawAccess&lt;&gt;::store(p, new_value);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,13 +232,13 @@</span>
  
  template &lt;DecoratorSet ds&gt;
  template &lt;DecoratorSet decorators, typename T&gt;
  inline typename EnableIf&lt;
    AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="udiff-line-modified-removed">- RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {</span>
<span class="udiff-line-modified-added">+ RawAccessBarrier&lt;ds&gt;::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {</span>
    if (!AccessInternal::wide_atomic_needs_locking()) {
<span class="udiff-line-modified-removed">-     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);</span>
<span class="udiff-line-modified-added">+     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);</span>
    } else {
      AccessInternal::AccessLocker access_lock;
      volatile T* p = reinterpret_cast&lt;volatile T*&gt;(addr);
      T old_val = RawAccess&lt;&gt;::load(p);
      if (old_val == compare_value) {
</pre>
<center><a href="accessBackend.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;memory/heapShared.hpp&quot;
 34 #include &quot;memory/metadataFactory.hpp&quot;
 35 #include &quot;memory/metaspaceClosure.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed"> 38 #include &quot;memory/universe.hpp&quot;</span>
 39 #include &quot;oops/access.inline.hpp&quot;

 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-removed"> 47 #include &quot;runtime/orderAccess.hpp&quot;</span>
 48 #include &quot;utilities/macros.hpp&quot;
 49 
 50 // Implementation of ConstantPoolCacheEntry
 51 
 52 void ConstantPoolCacheEntry::initialize_entry(int index) {
 53   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
 54   _indices = index;
 55   _f1 = NULL;
 56   _f2 = _flags = 0;
 57   assert(constant_pool_index() == index, &quot;&quot;);
 58 }
 59 
 60 void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {
 61   assert((_indices &amp; (~cp_index_mask)) == 0, &quot;sanity&quot;);
 62   assert(_f1 == NULL, &quot;sanity&quot;);
 63   assert(_flags == 0, &quot;sanity&quot;);
 64   if (!f2_used) {
 65     assert(_f2 == 0, &quot;sanity&quot;);
 66   }
 67 }
</pre>
<hr />
<pre>
 80                                        int field_index_or_method_params) {
 81   assert(state &lt; number_of_states, &quot;Invalid state in make_flags&quot;);
 82   int f = ((int)state &lt;&lt; tos_state_shift) | option_bits | field_index_or_method_params;
 83   // Preserve existing flag bit values
 84   // The low bits are a field offset, or else the method parameter size.
 85 #ifdef ASSERT
 86   TosState old_state = flag_state();
 87   assert(old_state == (TosState)0 || old_state == state,
 88          &quot;inconsistent cpCache flags state&quot;);
 89 #endif
 90   return (_flags | f) ;
 91 }
 92 
 93 void ConstantPoolCacheEntry::set_bytecode_1(Bytecodes::Code code) {
 94 #ifdef ASSERT
 95   // Read once.
 96   volatile Bytecodes::Code c = bytecode_1();
 97   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
 98 #endif
 99   // Need to flush pending stores here before bytecode is written.
<span class="line-modified">100   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));</span>
101 }
102 
103 void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
104 #ifdef ASSERT
105   // Read once.
106   volatile Bytecodes::Code c = bytecode_2();
107   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
108 #endif
109   // Need to flush pending stores here before bytecode is written.
<span class="line-modified">110   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));</span>
111 }
112 
113 // Sets f1, ordering with previous writes.
114 void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
115   assert(f1 != NULL, &quot;&quot;);
<span class="line-modified">116   OrderAccess::release_store(&amp;_f1, f1);</span>
117 }
118 
119 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
<span class="line-modified">120   OrderAccess::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));</span>
121 }
122 
123 // Note that concurrent update of both bytecodes can leave one of them
124 // reset to zero.  This is harmless; the interpreter will simply re-resolve
125 // the damaged entry.  More seriously, the memory synchronization is needed
126 // to flush other fields (f1, f2) completely to memory before the bytecodes
127 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
128 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
129                                        Bytecodes::Code put_code,
130                                        Klass* field_holder,
131                                        int field_index,
132                                        int field_offset,
133                                        TosState field_type,
134                                        bool is_final,
135                                        bool is_volatile,
136                                        bool is_tsan_ignore,
137                                        Klass* root_klass) {
138   set_f1(field_holder);
139   set_f2(field_offset);
140   assert((field_index &amp; field_index_mask) == field_index,
</pre>
<hr />
<pre>
144                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift) |
145                   ((is_tsan_ignore ? 1 : 0) &lt;&lt; is_tsan_ignore_shift),
146                   field_index);
147   set_bytecode_1(get_code);
148   set_bytecode_2(put_code);
149   NOT_PRODUCT(verify(tty));
150 }
151 
152 void ConstantPoolCacheEntry::set_parameter_size(int value) {
153   // This routine is called only in corner cases where the CPCE is not yet initialized.
154   // See AbstractInterpreter::deopt_continue_after_entry.
155   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
156          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
157   // Setting the parameter size by itself is only safe if the
158   // current value of _flags is 0, otherwise another thread may have
159   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
160   // bother trying to update it once it&#39;s nonzero but always make
161   // sure that the final parameter size agrees with what was passed.
162   if (_flags == 0) {
163     intx newflags = (value &amp; parameter_size_mask);
<span class="line-modified">164     Atomic::cmpxchg(newflags, &amp;_flags, (intx)0);</span>
165   }
166   guarantee(parameter_size() == value,
167             &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
168 }
169 
170 void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
171                                                        const methodHandle&amp; method,
172                                                        int vtable_index,
<span class="line-modified">173                                                        bool sender_is_interface,</span>
<span class="line-removed">174                                                        InstanceKlass* pool_holder) {</span>
175   bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
176   assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
177   assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
178 
179   int byte_no = -1;
180   bool change_to_virtual = false;
181   InstanceKlass* holder = NULL;  // have to declare this outside the switch
182   switch (invoke_code) {
183     case Bytecodes::_invokeinterface:
184       holder = method-&gt;method_holder();
185       // check for private interface method invocations
186       if (vtable_index == Method::nonvirtual_vtable_index &amp;&amp; holder-&gt;is_interface() ) {
187         assert(method-&gt;is_private(), &quot;unexpected non-private method&quot;);
188         assert(method-&gt;can_be_statically_bound(), &quot;unexpected non-statically-bound method&quot;);
189         // set_f2_as_vfinal_method checks if is_vfinal flag is true.
190         set_method_flags(as_TosState(method-&gt;result_type()),
191                          (                             1      &lt;&lt; is_vfinal_shift) |
192                          ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
193                          method()-&gt;size_of_parameters());
194         set_f2_as_vfinal_method(method());
</pre>
<hr />
<pre>
247       set_f1(method());
248       byte_no = 1;
249       break;
250     default:
251       ShouldNotReachHere();
252       break;
253   }
254 
255   // Note:  byte_no also appears in TemplateTable::resolve.
256   if (byte_no == 1) {
257     assert(invoke_code != Bytecodes::_invokevirtual &amp;&amp;
258            invoke_code != Bytecodes::_invokeinterface, &quot;&quot;);
259     bool do_resolve = true;
260     // Don&#39;t mark invokespecial to method as resolved if sender is an interface.  The receiver
261     // has to be checked that it is a subclass of the current class every time this bytecode
262     // is executed.
263     if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
264         method-&gt;name() != vmSymbols::object_initializer_name()) {
265       do_resolve = false;
266     }
<span class="line-removed">267     // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed</span>
<span class="line-removed">268     // initialization. An invokestatic must only proceed if the class is initialized, but if</span>
<span class="line-removed">269     // we resolve it before then that class initialization check is skipped. However if the call</span>
<span class="line-removed">270     // is from the same class we can resolve as we must be executing with &lt;clinit&gt; on our call stack.</span>
271     if (invoke_code == Bytecodes::_invokestatic) {
<span class="line-modified">272       if (!method-&gt;method_holder()-&gt;is_initialized() &amp;&amp;</span>
<span class="line-modified">273           method-&gt;method_holder() != pool_holder) {</span>











274         do_resolve = false;
<span class="line-removed">275       } else {</span>
<span class="line-removed">276         assert(method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="line-removed">277                method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),</span>
<span class="line-removed">278                &quot;invalid class initialization state for invoke_static&quot;);</span>
279       }
280     }
281     if (do_resolve) {
282       set_bytecode_1(invoke_code);
283     }
284   } else if (byte_no == 2)  {
285     if (change_to_virtual) {
286       assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
287       // NOTE: THIS IS A HACK - BE VERY CAREFUL!!!
288       //
289       // Workaround for the case where we encounter an invokeinterface, but we
290       // should really have an _invokevirtual since the resolved method is a
291       // virtual method in java.lang.Object. This is a corner case in the spec
292       // but is presumably legal. javac does not generate this code.
293       //
294       // We do not set bytecode_1() to _invokeinterface, because that is the
295       // bytecode # used by the interpreter to see if it is resolved.  In this
296       // case, the method gets reresolved with caller for each interface call
297       // because the actual selected method may not be public.
298       //
</pre>
<hr />
<pre>
304               ((method-&gt;is_private() ||
305                 (method-&gt;is_final() &amp;&amp; method-&gt;method_holder() == SystemDictionary::Object_klass())))),
306              &quot;unexpected invocation mode&quot;);
307       if (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
308           (method-&gt;is_private() || method-&gt;is_final())) {
309         // We set bytecode_1() to _invokeinterface, because that is the
310         // bytecode # used by the interpreter to see if it is resolved.
311         // We set bytecode_2() to _invokevirtual.
312         set_bytecode_1(invoke_code);
313       }
314     }
315     // set up for invokevirtual, even if linking for invokeinterface also:
316     set_bytecode_2(Bytecodes::_invokevirtual);
317   } else {
318     ShouldNotReachHere();
319   }
320   NOT_PRODUCT(verify(tty));
321 }
322 
323 void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
<span class="line-modified">324                                              bool sender_is_interface, InstanceKlass* pool_holder) {</span>
325   int index = Method::nonvirtual_vtable_index;
326   // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">327   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface, pool_holder);</span>
328 }
329 
330 void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
331   // either the method is a miranda or its holder should accept the given index
332   assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
333   // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">334   set_direct_or_vtable_call(invoke_code, method, index, false, NULL /* not used */);</span>
335 }
336 
337 void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
338                                              Klass* referenced_klass,
339                                              const methodHandle&amp; method, int index) {
340   assert(method-&gt;method_holder()-&gt;verify_itable_index(index), &quot;&quot;);
341   assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
342   InstanceKlass* interf = method-&gt;method_holder();
343   assert(interf-&gt;is_interface(), &quot;must be an interface&quot;);
344   assert(!method-&gt;is_final_method(), &quot;interfaces do not have final methods; cannot link to one here&quot;);
345   set_f1(referenced_klass);
346   set_f2((intx)method());
347   set_method_flags(as_TosState(method-&gt;result_type()),
348                    0,  // no option bits
349                    method()-&gt;size_of_parameters());
350   set_bytecode_1(Bytecodes::_invokeinterface);
351 }
352 
353 
354 void ConstantPoolCacheEntry::set_method_handle(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
</pre>
<hr />
<pre>
384 
385   if (indy_resolution_failed()) {
386     // Before we got here, another thread got a LinkageError exception during
387     // resolution.  Ignore our success and throw their exception.
388     ConstantPoolCache* cpCache = cpool-&gt;cache();
389     int index = -1;
390     for (int i = 0; i &lt; cpCache-&gt;length(); i++) {
391       if (cpCache-&gt;entry_at(i) == this) {
392         index = i;
393         break;
394       }
395     }
396     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
397     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
398                           ConstantPool::encode_invokedynamic_index(index));
399     Thread* THREAD = Thread::current();
400     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
401     return;
402   }
403 
<span class="line-modified">404   const methodHandle adapter = call_info.resolved_method();</span>
405   const Handle appendix      = call_info.resolved_appendix();
406   const bool has_appendix    = appendix.not_null();
407 
408   // Write the flags.
409   // MHs and indy are always sig-poly and have a local signature.
410   set_method_flags(as_TosState(adapter-&gt;result_type()),
411                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
412                    (                   1      &lt;&lt; has_local_signature_shift ) |
413                    (                   1      &lt;&lt; is_final_shift            ),
414                    adapter-&gt;size_of_parameters());
415 
416   if (TraceInvokeDynamic) {
417     ttyLocker ttyl;
418     tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
419                   invoke_code,
420                   p2i(appendix()),
421                   (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
<span class="line-modified">422                   p2i(adapter()));</span>
423     adapter-&gt;print();
424     if (has_appendix)  appendix()-&gt;print();
425   }
426 
427   // Method handle invokes and invokedynamic sites use both cp cache words.
428   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
429   // In the general case, this could be the call site&#39;s MethodType,
430   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
431   // f1 contains the adapter method which manages the actual call.
432   // In the general case, this is a compiled LambdaForm.
433   // (The Java code is free to optimize these calls by binding other
434   // sorts of methods and appendices to call sites.)
435   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
436   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
437   // Even with the appendix, the method will never take more than 255 parameter slots.
438   //
439   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
440   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
441   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
442   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
443   // This allows us to create fewer Methods, while keeping type safety.
444   //
445 
446   // Store appendix, if any.
447   if (has_appendix) {
448     const int appendix_index = f2_as_index();
449     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
450     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
451     resolved_references-&gt;obj_at_put(appendix_index, appendix());
452   }
453 
<span class="line-modified">454   release_set_f1(adapter());  // This must be the last one to set (see NOTE above)!</span>
455 
456   // The interpreter assembly code does not check byte_2,
457   // but it is used by is_resolved, method_if_resolved, etc.
458   set_bytecode_1(invoke_code);
459   NOT_PRODUCT(verify(tty));
460   if (TraceInvokeDynamic) {
461     ttyLocker ttyl;
462     this-&gt;print(tty, 0);
463   }
464 
465   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
466   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
467 }
468 
469 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
470   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
471 
472   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
473   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
474          &quot;No LinkageError exception&quot;);
</pre>
<hr />
<pre>
491     return false;
492   }
493 
494   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
495   Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);
496 
497   SystemDictionary::add_resolution_error(cpool, index, error, message);
498   set_indy_resolution_failed();
499   return true;
500 }
501 
502 Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle&amp; cpool) {
503   // Decode the action of set_method and set_interface_call
504   Bytecodes::Code invoke_code = bytecode_1();
505   if (invoke_code != (Bytecodes::Code)0) {
506     Metadata* f1 = f1_ord();
507     if (f1 != NULL) {
508       switch (invoke_code) {
509       case Bytecodes::_invokeinterface:
510         assert(f1-&gt;is_klass(), &quot;&quot;);
<span class="line-modified">511         return klassItable::method_for_itable_index((InstanceKlass*)f1, f2_as_index());</span>
512       case Bytecodes::_invokestatic:
513       case Bytecodes::_invokespecial:
514         assert(!has_appendix(), &quot;&quot;);
515       case Bytecodes::_invokehandle:
516       case Bytecodes::_invokedynamic:
517         assert(f1-&gt;is_method(), &quot;&quot;);
518         return (Method*)f1;
519       default:
520         break;
521       }
522     }
523   }
524   invoke_code = bytecode_2();
525   if (invoke_code != (Bytecodes::Code)0) {
526     switch (invoke_code) {
527     case Bytecodes::_invokevirtual:
528       if (is_vfinal()) {
529         // invokevirtual
530         Method* m = f2_as_vfinal_method();
531         assert(m-&gt;is_method(), &quot;&quot;);
</pre>
<hr />
<pre>
691     assert(entry_at(offset) == e, &quot;sanity&quot;);
692   }
693 
694   for (int ref = 0; ref &lt; invokedynamic_references_map.length(); ref++) {
695     const int cpci = invokedynamic_references_map.at(ref);
696     if (cpci &gt;= 0) {
697       entry_at(cpci)-&gt;initialize_resolved_reference_index(ref);
698     }
699   }
700 }
701 
702 void ConstantPoolCache::verify_just_initialized() {
703   DEBUG_ONLY(walk_entries_for_initialization(/*check_only = */ true));
704 }
705 
706 void ConstantPoolCache::remove_unshareable_info() {
707   walk_entries_for_initialization(/*check_only = */ false);
708 }
709 
710 void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
<span class="line-modified">711   assert(DumpSharedSpaces, &quot;sanity&quot;);</span>
712   // When dumping the archive, we want to clean up the ConstantPoolCache
713   // to remove any effect of linking due to the execution of Java code --
714   // each ConstantPoolCacheEntry will have the same contents as if
715   // ConstantPoolCache::initialize has just returned:
716   //
717   // - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.
718   // - We keep the &quot;f2&quot; field for entries used by invokedynamic and invokehandle
719   // - All other bits in the entries are cleared to zero.
720   ResourceMark rm;
721 
722   InstanceKlass* ik = constant_pool()-&gt;pool_holder();
723   bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
724   memset(f2_used, 0, sizeof(bool) * length());
725 


726   // Find all the slots that we need to preserve f2
727   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
728     Method* m = ik-&gt;methods()-&gt;at(i);
<span class="line-modified">729     RawBytecodeStream bcs(m);</span>
730     while (!bcs.is_last_bytecode()) {
731       Bytecodes::Code opcode = bcs.raw_next();
732       switch (opcode) {
733       case Bytecodes::_invokedynamic: {
734           int index = Bytes::get_native_u4(bcs.bcp() + 1);
735           int cp_cache_index = constant_pool()-&gt;invokedynamic_cp_cache_index(index);
736           f2_used[cp_cache_index] = 1;
737         }
738         break;
739       case Bytecodes::_invokehandle: {
740           int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);
741           f2_used[cp_cache_index] = 1;
742         }
743         break;
744       default:
745         break;
746       }
747     }
748   }
749 
</pre>
</td>
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;memory/heapShared.hpp&quot;
 34 #include &quot;memory/metadataFactory.hpp&quot;
 35 #include &quot;memory/metaspaceClosure.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;

 38 #include &quot;oops/access.inline.hpp&quot;
<span class="line-added"> 39 #include &quot;oops/compressedOops.hpp&quot;</span>
 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;

 47 #include &quot;utilities/macros.hpp&quot;
 48 
 49 // Implementation of ConstantPoolCacheEntry
 50 
 51 void ConstantPoolCacheEntry::initialize_entry(int index) {
 52   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
 53   _indices = index;
 54   _f1 = NULL;
 55   _f2 = _flags = 0;
 56   assert(constant_pool_index() == index, &quot;&quot;);
 57 }
 58 
 59 void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {
 60   assert((_indices &amp; (~cp_index_mask)) == 0, &quot;sanity&quot;);
 61   assert(_f1 == NULL, &quot;sanity&quot;);
 62   assert(_flags == 0, &quot;sanity&quot;);
 63   if (!f2_used) {
 64     assert(_f2 == 0, &quot;sanity&quot;);
 65   }
 66 }
</pre>
<hr />
<pre>
 79                                        int field_index_or_method_params) {
 80   assert(state &lt; number_of_states, &quot;Invalid state in make_flags&quot;);
 81   int f = ((int)state &lt;&lt; tos_state_shift) | option_bits | field_index_or_method_params;
 82   // Preserve existing flag bit values
 83   // The low bits are a field offset, or else the method parameter size.
 84 #ifdef ASSERT
 85   TosState old_state = flag_state();
 86   assert(old_state == (TosState)0 || old_state == state,
 87          &quot;inconsistent cpCache flags state&quot;);
 88 #endif
 89   return (_flags | f) ;
 90 }
 91 
 92 void ConstantPoolCacheEntry::set_bytecode_1(Bytecodes::Code code) {
 93 #ifdef ASSERT
 94   // Read once.
 95   volatile Bytecodes::Code c = bytecode_1();
 96   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
 97 #endif
 98   // Need to flush pending stores here before bytecode is written.
<span class="line-modified"> 99   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));</span>
100 }
101 
102 void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
103 #ifdef ASSERT
104   // Read once.
105   volatile Bytecodes::Code c = bytecode_2();
106   assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
107 #endif
108   // Need to flush pending stores here before bytecode is written.
<span class="line-modified">109   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));</span>
110 }
111 
112 // Sets f1, ordering with previous writes.
113 void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
114   assert(f1 != NULL, &quot;&quot;);
<span class="line-modified">115   Atomic::release_store(&amp;_f1, f1);</span>
116 }
117 
118 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
<span class="line-modified">119   Atomic::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));</span>
120 }
121 
122 // Note that concurrent update of both bytecodes can leave one of them
123 // reset to zero.  This is harmless; the interpreter will simply re-resolve
124 // the damaged entry.  More seriously, the memory synchronization is needed
125 // to flush other fields (f1, f2) completely to memory before the bytecodes
126 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
127 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
128                                        Bytecodes::Code put_code,
129                                        Klass* field_holder,
130                                        int field_index,
131                                        int field_offset,
132                                        TosState field_type,
133                                        bool is_final,
134                                        bool is_volatile,
135                                        bool is_tsan_ignore,
136                                        Klass* root_klass) {
137   set_f1(field_holder);
138   set_f2(field_offset);
139   assert((field_index &amp; field_index_mask) == field_index,
</pre>
<hr />
<pre>
143                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift) |
144                   ((is_tsan_ignore ? 1 : 0) &lt;&lt; is_tsan_ignore_shift),
145                   field_index);
146   set_bytecode_1(get_code);
147   set_bytecode_2(put_code);
148   NOT_PRODUCT(verify(tty));
149 }
150 
151 void ConstantPoolCacheEntry::set_parameter_size(int value) {
152   // This routine is called only in corner cases where the CPCE is not yet initialized.
153   // See AbstractInterpreter::deopt_continue_after_entry.
154   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
155          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
156   // Setting the parameter size by itself is only safe if the
157   // current value of _flags is 0, otherwise another thread may have
158   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
159   // bother trying to update it once it&#39;s nonzero but always make
160   // sure that the final parameter size agrees with what was passed.
161   if (_flags == 0) {
162     intx newflags = (value &amp; parameter_size_mask);
<span class="line-modified">163     Atomic::cmpxchg(&amp;_flags, (intx)0, newflags);</span>
164   }
165   guarantee(parameter_size() == value,
166             &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
167 }
168 
169 void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
170                                                        const methodHandle&amp; method,
171                                                        int vtable_index,
<span class="line-modified">172                                                        bool sender_is_interface) {</span>

173   bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
174   assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
175   assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
176 
177   int byte_no = -1;
178   bool change_to_virtual = false;
179   InstanceKlass* holder = NULL;  // have to declare this outside the switch
180   switch (invoke_code) {
181     case Bytecodes::_invokeinterface:
182       holder = method-&gt;method_holder();
183       // check for private interface method invocations
184       if (vtable_index == Method::nonvirtual_vtable_index &amp;&amp; holder-&gt;is_interface() ) {
185         assert(method-&gt;is_private(), &quot;unexpected non-private method&quot;);
186         assert(method-&gt;can_be_statically_bound(), &quot;unexpected non-statically-bound method&quot;);
187         // set_f2_as_vfinal_method checks if is_vfinal flag is true.
188         set_method_flags(as_TosState(method-&gt;result_type()),
189                          (                             1      &lt;&lt; is_vfinal_shift) |
190                          ((method-&gt;is_final_method() ? 1 : 0) &lt;&lt; is_final_shift),
191                          method()-&gt;size_of_parameters());
192         set_f2_as_vfinal_method(method());
</pre>
<hr />
<pre>
245       set_f1(method());
246       byte_no = 1;
247       break;
248     default:
249       ShouldNotReachHere();
250       break;
251   }
252 
253   // Note:  byte_no also appears in TemplateTable::resolve.
254   if (byte_no == 1) {
255     assert(invoke_code != Bytecodes::_invokevirtual &amp;&amp;
256            invoke_code != Bytecodes::_invokeinterface, &quot;&quot;);
257     bool do_resolve = true;
258     // Don&#39;t mark invokespecial to method as resolved if sender is an interface.  The receiver
259     // has to be checked that it is a subclass of the current class every time this bytecode
260     // is executed.
261     if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
262         method-&gt;name() != vmSymbols::object_initializer_name()) {
263       do_resolve = false;
264     }




265     if (invoke_code == Bytecodes::_invokestatic) {
<span class="line-modified">266       assert(method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="line-modified">267              method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),</span>
<span class="line-added">268              &quot;invalid class initialization state for invoke_static&quot;);</span>
<span class="line-added">269 </span>
<span class="line-added">270       if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="line-added">271         // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed</span>
<span class="line-added">272         // initialization. An invokestatic must only proceed if the class is initialized, but if</span>
<span class="line-added">273         // we resolve it before then that class initialization check is skipped.</span>
<span class="line-added">274         //</span>
<span class="line-added">275         // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),</span>
<span class="line-added">276         // template interpreter supports fast class initialization check for</span>
<span class="line-added">277         // invokestatic which doesn&#39;t require call site re-resolution to</span>
<span class="line-added">278         // enforce class initialization barrier.</span>
279         do_resolve = false;




280       }
281     }
282     if (do_resolve) {
283       set_bytecode_1(invoke_code);
284     }
285   } else if (byte_no == 2)  {
286     if (change_to_virtual) {
287       assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
288       // NOTE: THIS IS A HACK - BE VERY CAREFUL!!!
289       //
290       // Workaround for the case where we encounter an invokeinterface, but we
291       // should really have an _invokevirtual since the resolved method is a
292       // virtual method in java.lang.Object. This is a corner case in the spec
293       // but is presumably legal. javac does not generate this code.
294       //
295       // We do not set bytecode_1() to _invokeinterface, because that is the
296       // bytecode # used by the interpreter to see if it is resolved.  In this
297       // case, the method gets reresolved with caller for each interface call
298       // because the actual selected method may not be public.
299       //
</pre>
<hr />
<pre>
305               ((method-&gt;is_private() ||
306                 (method-&gt;is_final() &amp;&amp; method-&gt;method_holder() == SystemDictionary::Object_klass())))),
307              &quot;unexpected invocation mode&quot;);
308       if (invoke_code == Bytecodes::_invokeinterface &amp;&amp;
309           (method-&gt;is_private() || method-&gt;is_final())) {
310         // We set bytecode_1() to _invokeinterface, because that is the
311         // bytecode # used by the interpreter to see if it is resolved.
312         // We set bytecode_2() to _invokevirtual.
313         set_bytecode_1(invoke_code);
314       }
315     }
316     // set up for invokevirtual, even if linking for invokeinterface also:
317     set_bytecode_2(Bytecodes::_invokevirtual);
318   } else {
319     ShouldNotReachHere();
320   }
321   NOT_PRODUCT(verify(tty));
322 }
323 
324 void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
<span class="line-modified">325                                              bool sender_is_interface) {</span>
326   int index = Method::nonvirtual_vtable_index;
327   // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">328   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface);</span>
329 }
330 
331 void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
332   // either the method is a miranda or its holder should accept the given index
333   assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
334   // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">335   set_direct_or_vtable_call(invoke_code, method, index, false);</span>
336 }
337 
338 void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
339                                              Klass* referenced_klass,
340                                              const methodHandle&amp; method, int index) {
341   assert(method-&gt;method_holder()-&gt;verify_itable_index(index), &quot;&quot;);
342   assert(invoke_code == Bytecodes::_invokeinterface, &quot;&quot;);
343   InstanceKlass* interf = method-&gt;method_holder();
344   assert(interf-&gt;is_interface(), &quot;must be an interface&quot;);
345   assert(!method-&gt;is_final_method(), &quot;interfaces do not have final methods; cannot link to one here&quot;);
346   set_f1(referenced_klass);
347   set_f2((intx)method());
348   set_method_flags(as_TosState(method-&gt;result_type()),
349                    0,  // no option bits
350                    method()-&gt;size_of_parameters());
351   set_bytecode_1(Bytecodes::_invokeinterface);
352 }
353 
354 
355 void ConstantPoolCacheEntry::set_method_handle(const constantPoolHandle&amp; cpool, const CallInfo &amp;call_info) {
</pre>
<hr />
<pre>
385 
386   if (indy_resolution_failed()) {
387     // Before we got here, another thread got a LinkageError exception during
388     // resolution.  Ignore our success and throw their exception.
389     ConstantPoolCache* cpCache = cpool-&gt;cache();
390     int index = -1;
391     for (int i = 0; i &lt; cpCache-&gt;length(); i++) {
392       if (cpCache-&gt;entry_at(i) == this) {
393         index = i;
394         break;
395       }
396     }
397     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
398     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
399                           ConstantPool::encode_invokedynamic_index(index));
400     Thread* THREAD = Thread::current();
401     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
402     return;
403   }
404 
<span class="line-modified">405   Method* adapter            = call_info.resolved_method();</span>
406   const Handle appendix      = call_info.resolved_appendix();
407   const bool has_appendix    = appendix.not_null();
408 
409   // Write the flags.
410   // MHs and indy are always sig-poly and have a local signature.
411   set_method_flags(as_TosState(adapter-&gt;result_type()),
412                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
413                    (                   1      &lt;&lt; has_local_signature_shift ) |
414                    (                   1      &lt;&lt; is_final_shift            ),
415                    adapter-&gt;size_of_parameters());
416 
417   if (TraceInvokeDynamic) {
418     ttyLocker ttyl;
419     tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
420                   invoke_code,
421                   p2i(appendix()),
422                   (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
<span class="line-modified">423                   p2i(adapter));</span>
424     adapter-&gt;print();
425     if (has_appendix)  appendix()-&gt;print();
426   }
427 
428   // Method handle invokes and invokedynamic sites use both cp cache words.
429   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
430   // In the general case, this could be the call site&#39;s MethodType,
431   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
432   // f1 contains the adapter method which manages the actual call.
433   // In the general case, this is a compiled LambdaForm.
434   // (The Java code is free to optimize these calls by binding other
435   // sorts of methods and appendices to call sites.)
436   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
437   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
438   // Even with the appendix, the method will never take more than 255 parameter slots.
439   //
440   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
441   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
442   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
443   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
444   // This allows us to create fewer Methods, while keeping type safety.
445   //
446 
447   // Store appendix, if any.
448   if (has_appendix) {
449     const int appendix_index = f2_as_index();
450     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
451     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
452     resolved_references-&gt;obj_at_put(appendix_index, appendix());
453   }
454 
<span class="line-modified">455   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!</span>
456 
457   // The interpreter assembly code does not check byte_2,
458   // but it is used by is_resolved, method_if_resolved, etc.
459   set_bytecode_1(invoke_code);
460   NOT_PRODUCT(verify(tty));
461   if (TraceInvokeDynamic) {
462     ttyLocker ttyl;
463     this-&gt;print(tty, 0);
464   }
465 
466   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
467   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
468 }
469 
470 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
471   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
472 
473   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
474   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
475          &quot;No LinkageError exception&quot;);
</pre>
<hr />
<pre>
492     return false;
493   }
494 
495   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
496   Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);
497 
498   SystemDictionary::add_resolution_error(cpool, index, error, message);
499   set_indy_resolution_failed();
500   return true;
501 }
502 
503 Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle&amp; cpool) {
504   // Decode the action of set_method and set_interface_call
505   Bytecodes::Code invoke_code = bytecode_1();
506   if (invoke_code != (Bytecodes::Code)0) {
507     Metadata* f1 = f1_ord();
508     if (f1 != NULL) {
509       switch (invoke_code) {
510       case Bytecodes::_invokeinterface:
511         assert(f1-&gt;is_klass(), &quot;&quot;);
<span class="line-modified">512         return f2_as_interface_method();</span>
513       case Bytecodes::_invokestatic:
514       case Bytecodes::_invokespecial:
515         assert(!has_appendix(), &quot;&quot;);
516       case Bytecodes::_invokehandle:
517       case Bytecodes::_invokedynamic:
518         assert(f1-&gt;is_method(), &quot;&quot;);
519         return (Method*)f1;
520       default:
521         break;
522       }
523     }
524   }
525   invoke_code = bytecode_2();
526   if (invoke_code != (Bytecodes::Code)0) {
527     switch (invoke_code) {
528     case Bytecodes::_invokevirtual:
529       if (is_vfinal()) {
530         // invokevirtual
531         Method* m = f2_as_vfinal_method();
532         assert(m-&gt;is_method(), &quot;&quot;);
</pre>
<hr />
<pre>
692     assert(entry_at(offset) == e, &quot;sanity&quot;);
693   }
694 
695   for (int ref = 0; ref &lt; invokedynamic_references_map.length(); ref++) {
696     const int cpci = invokedynamic_references_map.at(ref);
697     if (cpci &gt;= 0) {
698       entry_at(cpci)-&gt;initialize_resolved_reference_index(ref);
699     }
700   }
701 }
702 
703 void ConstantPoolCache::verify_just_initialized() {
704   DEBUG_ONLY(walk_entries_for_initialization(/*check_only = */ true));
705 }
706 
707 void ConstantPoolCache::remove_unshareable_info() {
708   walk_entries_for_initialization(/*check_only = */ false);
709 }
710 
711 void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
<span class="line-modified">712   Arguments::assert_is_dumping_archive();</span>
713   // When dumping the archive, we want to clean up the ConstantPoolCache
714   // to remove any effect of linking due to the execution of Java code --
715   // each ConstantPoolCacheEntry will have the same contents as if
716   // ConstantPoolCache::initialize has just returned:
717   //
718   // - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.
719   // - We keep the &quot;f2&quot; field for entries used by invokedynamic and invokehandle
720   // - All other bits in the entries are cleared to zero.
721   ResourceMark rm;
722 
723   InstanceKlass* ik = constant_pool()-&gt;pool_holder();
724   bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
725   memset(f2_used, 0, sizeof(bool) * length());
726 
<span class="line-added">727   Thread* THREAD = Thread::current();</span>
<span class="line-added">728 </span>
729   // Find all the slots that we need to preserve f2
730   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
731     Method* m = ik-&gt;methods()-&gt;at(i);
<span class="line-modified">732     RawBytecodeStream bcs(methodHandle(THREAD, m));</span>
733     while (!bcs.is_last_bytecode()) {
734       Bytecodes::Code opcode = bcs.raw_next();
735       switch (opcode) {
736       case Bytecodes::_invokedynamic: {
737           int index = Bytes::get_native_u4(bcs.bcp() + 1);
738           int cp_cache_index = constant_pool()-&gt;invokedynamic_cp_cache_index(index);
739           f2_used[cp_cache_index] = 1;
740         }
741         break;
742       case Bytecodes::_invokehandle: {
743           int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);
744           f2_used[cp_cache_index] = 1;
745         }
746         break;
747       default:
748         break;
749       }
750     }
751   }
752 
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
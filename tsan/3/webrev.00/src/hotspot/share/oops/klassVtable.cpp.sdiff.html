<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klassVtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 111     if (Universe::is_bootstrapping()) {
 112       // Someone is attempting to override java.lang.Object incorrectly on the
 113       // bootclasspath.  The JVM cannot recover from this error including throwing
 114       // an exception
 115       vm_exit_during_initialization(&quot;Incompatible definition of java.lang.Object&quot;);
 116     } else {
 117       // Someone is attempting to redefine java.lang.Object incorrectly.  The
 118       // only way this should happen is from
 119       // SystemDictionary::resolve_from_stream(), which will detect this later
 120       // and throw a security exception.  So don&#39;t assert here to let
 121       // the exception occur.
 122       vtable_length = Universe::base_vtable_size();
 123     }
 124   }
 125   assert(vtable_length % vtableEntry::size() == 0, &quot;bad vtable length&quot;);
 126   assert(vtable_length &gt;= Universe::base_vtable_size(), &quot;vtable too small&quot;);
 127 
 128   *vtable_length_ret = vtable_length;
 129 }
 130 
<span class="line-removed"> 131 int klassVtable::index_of(Method* m, int len) const {</span>
<span class="line-removed"> 132   assert(m-&gt;has_vtable_index(), &quot;do not ask this of non-vtable methods&quot;);</span>
<span class="line-removed"> 133   return m-&gt;vtable_index();</span>
<span class="line-removed"> 134 }</span>
<span class="line-removed"> 135 </span>
 136 // Copy super class&#39;s vtable to the first part (prefix) of this class&#39;s vtable,
 137 // and return the number of entries copied.  Expects that &#39;super&#39; is the Java
 138 // super class (arrays can have &quot;array&quot; super classes that must be skipped).
 139 int klassVtable::initialize_from_super(Klass* super) {
 140   if (super == NULL) {
 141     return 0;
 142   } else if (is_preinitialized_vtable()) {
 143     // A shared class&#39; vtable is preinitialized at dump time. No need to copy
 144     // methods from super class for shared class, as that was already done
 145     // during archiving time. However, if Jvmti has redefined a class,
 146     // copy super class&#39;s vtable in case the super class has changed.
 147     return super-&gt;vtable().length();
 148   } else {
 149     // copy methods from superKlass
 150     klassVtable superVtable = super-&gt;vtable();
 151     assert(superVtable.length() &lt;= _length, &quot;vtable too short&quot;);
 152 #ifdef ASSERT
 153     superVtable.verify(tty, true);
 154 #endif
 155     superVtable.copy_vtable_to(table());
 156     if (log_develop_is_enabled(Trace, vtables)) {
 157       ResourceMark rm;
 158       log_develop_trace(vtables)(&quot;copy vtable from %s to %s size %d&quot;,
 159                                  super-&gt;internal_name(), klass()-&gt;internal_name(),
 160                                  _length);
 161     }
 162     return superVtable.length();
 163   }
 164 }
 165 
 166 //
 167 // Revised lookup semantics   introduced 1.3 (Kestrel beta)
 168 void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {
 169 
 170   // Note:  Arrays can have intermediate array supers.  Use java_super to skip them.
 171   InstanceKlass* super = _klass-&gt;java_super();
<span class="line-removed"> 172   int nofNewEntries = 0;</span>
 173 
 174   bool is_shared = _klass-&gt;is_shared();
 175 
 176   if (!_klass-&gt;is_array_klass()) {
 177     ResourceMark rm(THREAD);
 178     log_develop_debug(vtables)(&quot;Initializing: %s&quot;, _klass-&gt;name()-&gt;as_C_string());
 179   }
 180 
 181 #ifdef ASSERT
 182   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
 183   oop* end_of_vtable = (oop*)&amp;table()[_length];
 184   assert(end_of_vtable &lt;= end_of_obj, &quot;vtable extends beyond end&quot;);
 185 #endif
 186 
 187   if (Universe::is_bootstrapping()) {
 188     assert(!is_shared, &quot;sanity&quot;);
 189     // just clear everything
 190     for (int i = 0; i &lt; _length; i++) table()[i].clear();
 191     return;
 192   }
</pre>
<hr />
<pre>
 280 
 281 // Called for cases where a method does not override its superclass&#39; vtable entry
 282 // For bytecodes not produced by javac together it is possible that a method does not override
 283 // the superclass&#39;s method, but might indirectly override a super-super class&#39;s vtable entry
 284 // If none found, return a null superk, else return the superk of the method this does override
 285 // For public and protected methods: if they override a superclass, they will
 286 // also be overridden themselves appropriately.
 287 // Private methods do not override, and are not overridden and are not in the vtable.
 288 // Package Private methods are trickier:
 289 // e.g. P1.A, pub m
 290 // P2.B extends A, package private m
 291 // P1.C extends B, public m
 292 // P1.C.m needs to override P1.A.m and can not override P2.B.m
 293 // Therefore: all package private methods need their own vtable entries for
 294 // them to be the root of an inheritance overriding decision
 295 // Package private methods may also override other vtable entries
 296 InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method,
 297                             int vtable_index, Handle target_loader, Symbol* target_classname, Thread * THREAD) {
 298   InstanceKlass* superk = initialsuper;
 299   while (superk != NULL &amp;&amp; superk-&gt;super() != NULL) {
<span class="line-modified"> 300     InstanceKlass* supersuperklass = InstanceKlass::cast(superk-&gt;super());</span>
<span class="line-removed"> 301     klassVtable ssVtable = supersuperklass-&gt;vtable();</span>
 302     if (vtable_index &lt; ssVtable.length()) {
 303       Method* super_method = ssVtable.method_at(vtable_index);



 304 #ifndef PRODUCT
 305       Symbol* name= target_method()-&gt;name();
 306       Symbol* signature = target_method()-&gt;signature();
 307       assert(super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature, &quot;vtable entry name/sig mismatch&quot;);
 308 #endif
<span class="line-modified"> 309       if (supersuperklass-&gt;is_override(super_method, target_loader, target_classname, THREAD)) {</span>

 310         if (log_develop_is_enabled(Trace, vtables)) {
 311           ResourceMark rm(THREAD);
 312           LogTarget(Trace, vtables) lt;
 313           LogStream ls(lt);
 314           char* sig = target_method()-&gt;name_and_sig_as_C_string();
 315           ls.print(&quot;transitive overriding superclass %s with %s index %d, original flags: &quot;,
<span class="line-modified"> 316                        supersuperklass-&gt;internal_name(),</span>
 317                        sig, vtable_index);
 318           super_method-&gt;print_linkage_flags(&amp;ls);
 319           ls.print(&quot;overriders flags: &quot;);
 320           target_method-&gt;print_linkage_flags(&amp;ls);
 321           ls.cr();
 322         }
 323 
 324         break; // return found superk
 325       }
 326     } else  {
 327       // super class has no vtable entry here, stop transitive search
 328       superk = (InstanceKlass*)NULL;
 329       break;
 330     }
 331     // if no override found yet, continue to search up
 332     superk = superk-&gt;super() == NULL ? NULL : InstanceKlass::cast(superk-&gt;super());
 333   }
 334 
 335   return superk;
 336 }
</pre>
<hr />
<pre>
 450     } else {
 451       super_method = method_at(i);
 452     }
 453     // Check if method name matches.  Ignore match if klass is an interface and the
 454     // matching method is a non-public java.lang.Object method.  (See JVMS 5.4.3.4)
 455     // This is safe because the method at this slot should never get invoked.
 456     // (TBD: put in a method to throw NoSuchMethodError if this slot is ever used.)
 457     if (super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature &amp;&amp;
 458         (!_klass-&gt;is_interface() ||
 459          !SystemDictionary::is_nonpublic_Object_method(super_method))) {
 460 
 461       // get super_klass for method_holder for the found method
 462       InstanceKlass* super_klass =  super_method-&gt;method_holder();
 463 
 464       // Whether the method is being overridden
 465       bool overrides = false;
 466 
 467       // private methods are also never overridden
 468       if (!super_method-&gt;is_private() &amp;&amp;
 469           (is_default
<span class="line-modified"> 470           || ((super_klass-&gt;is_override(super_method, target_loader, target_classname, THREAD))</span>
 471           || ((klass-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION)
 472           &amp;&amp; ((super_klass = find_transitive_override(super_klass,
 473                              target_method, i, target_loader,
 474                              target_classname, THREAD))
 475                              != (InstanceKlass*)NULL)))))
 476         {
 477         // Package private methods always need a new entry to root their own
 478         // overriding. They may also override other methods.
 479         if (!target_method()-&gt;is_package_private()) {
 480           allocate_new = false;
 481         }
 482 
 483         // Do not check loader constraints for overpass methods because overpass
 484         // methods are created by the jvm to throw exceptions.
 485         if (checkconstraints &amp;&amp; !target_method()-&gt;is_overpass()) {
 486           // Override vtable entry if passes loader constraint check
 487           // if loader constraint checking requested
 488           // No need to visit his super, since he and his super
 489           // have already made any needed loader constraints.
 490           // Since loader constraints are transitive, it is enough
 491           // to link to the first super, and we get all the others.
 492           Handle super_loader(THREAD, super_klass-&gt;class_loader());
 493 
<span class="line-modified"> 494           if (!oopDesc::equals(target_loader(), super_loader())) {</span>
 495             ResourceMark rm(THREAD);
 496             Symbol* failed_type_symbol =
 497               SystemDictionary::check_signature_loaders(signature, target_loader,
 498                                                         super_loader, true,
 499                                                         CHECK_(false));
 500             if (failed_type_symbol != NULL) {
 501               stringStream ss;
 502               ss.print(&quot;loader constraint violation for class %s: when selecting &quot;
<span class="line-modified"> 503                        &quot;overriding method %s the class loader %s of the &quot;</span>


 504                        &quot;selected method&#39;s type %s, and the class loader %s for its super &quot;
 505                        &quot;type %s have different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="line-removed"> 506                        klass-&gt;external_name(),</span>
<span class="line-removed"> 507                        target_method()-&gt;name_and_sig_as_C_string(),</span>
 508                        target_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 509                        target_klass-&gt;external_name(),
 510                        super_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 511                        super_klass-&gt;external_name(),
 512                        failed_type_symbol-&gt;as_klass_external_name(),
 513                        target_klass-&gt;class_in_module_of_loader(false, true),
 514                        super_klass-&gt;class_in_module_of_loader(false, true));
 515               THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);
 516             }
 517           }
 518         }
 519 
 520         put_method_at(target_method(), i);
 521         overrides = true;
 522         if (!is_default) {
 523           target_method()-&gt;set_vtable_index(i);
 524         } else {
 525           if (def_vtable_indices != NULL) {
 526             if (is_preinitialized_vtable()) {
 527               // At runtime initialize_vtable is rerun as part of link_class_impl()
</pre>
<hr />
<pre>
 614       target_method()-&gt;method_holder()-&gt;is_interface()  &amp;&amp;
 615       !target_method()-&gt;is_abstract()) {
 616     assert(target_method()-&gt;is_default_method(),
 617            &quot;unexpected interface method type&quot;);
 618     return false;
 619   }
 620 
 621   // we need a new entry if there is no superclass
 622   if (super == NULL) {
 623     return true;
 624   }
 625 
 626   // Package private methods always need a new entry to root their own
 627   // overriding. This allows transitive overriding to work.
 628   if (target_method()-&gt;is_package_private()) {
 629     return true;
 630   }
 631 
 632   // search through the super class hierarchy to see if we need
 633   // a new entry
<span class="line-modified"> 634   ResourceMark rm;</span>
 635   Symbol* name = target_method()-&gt;name();
 636   Symbol* signature = target_method()-&gt;signature();
 637   const Klass* k = super;
 638   Method* super_method = NULL;
 639   InstanceKlass *holder = NULL;
 640   Method* recheck_method =  NULL;

 641   while (k != NULL) {
 642     // lookup through the hierarchy for a method with matching name and sign.
 643     super_method = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
 644     if (super_method == NULL) {
 645       break; // we still have to search for a matching miranda method
 646     }
 647     // get the class holding the matching method
 648     // make sure you use that class for is_override
 649     InstanceKlass* superk = super_method-&gt;method_holder();
 650     // we want only instance method matches
 651     // ignore private methods found via lookup_method since they do not participate in overriding,
 652     // and since we do override around them: e.g. a.m pub/b.m private/c.m pub,
 653     // ignore private, c.m pub does override a.m pub
 654     // For classes that were not javac&#39;d together, we also do transitive overriding around
 655     // methods that have less accessibility
 656     if ((!super_method-&gt;is_static()) &amp;&amp;
 657        (!super_method-&gt;is_private())) {
<span class="line-modified"> 658       if (superk-&gt;is_override(super_method, classloader, classname, THREAD)) {</span>
 659         return false;
 660       // else keep looking for transitive overrides
 661       }










 662     }
 663 
 664     // Start with lookup result and continue to search up, for versions supporting transitive override
 665     if (major_version &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION) {
 666       k = superk-&gt;super(); // haven&#39;t found an override match yet; continue to look
 667     } else {
 668       break;
 669     }
 670   }
 671 









 672   // if the target method is public or protected it may have a matching
 673   // miranda method in the super, whose entry it should re-use.
 674   // Actually, to handle cases that javac would not generate, we need
 675   // this check for all access permissions.
 676   const InstanceKlass *sk = InstanceKlass::cast(super);
 677   if (sk-&gt;has_miranda_methods()) {
 678     if (sk-&gt;lookup_method_in_all_interfaces(name, signature, Klass::find_defaults) != NULL) {
<span class="line-modified"> 679       return false;  // found a matching miranda; we do not need a new entry</span>
 680     }
 681   }
 682   return true; // found no match; we need a new entry
 683 }
 684 
 685 // Support for miranda methods
 686 
 687 // get the vtable index of a miranda method with matching &quot;name&quot; and &quot;signature&quot;
 688 int klassVtable::index_of_miranda(Symbol* name, Symbol* signature) {
 689   // search from the bottom, might be faster
 690   for (int i = (length() - 1); i &gt;= 0; i--) {
 691     Method* m = table()[i].method();
 692     if (is_miranda_entry_at(i) &amp;&amp;
 693         m-&gt;name() == name &amp;&amp; m-&gt;signature() == signature) {
 694       return i;
 695     }
 696   }
 697   return Method::invalid_vtable_index;
 698 }
 699 
</pre>
<hr />
<pre>
 992   tty-&gt;print_cr(&quot;vtable dump --&quot;);
 993   for (int i = 0; i &lt; length(); i++) {
 994     Method* m = unchecked_method_at(i);
 995     if (m != NULL) {
 996       tty-&gt;print(&quot;      (%5d)  &quot;, i);
 997       m-&gt;access_flags().print_on(tty);
 998       if (m-&gt;is_default_method()) {
 999         tty-&gt;print(&quot;default &quot;);
1000       }
1001       if (m-&gt;is_overpass()) {
1002         tty-&gt;print(&quot;overpass&quot;);
1003       }
1004       tty-&gt;print(&quot; --  &quot;);
1005       m-&gt;print_name(tty);
1006       tty-&gt;cr();
1007     }
1008   }
1009 }
1010 #endif // INCLUDE_JVMTI
1011 
<span class="line-removed">1012 // CDS/RedefineClasses support - clear vtables so they can be reinitialized</span>
<span class="line-removed">1013 void klassVtable::clear_vtable() {</span>
<span class="line-removed">1014   for (int i = 0; i &lt; _length; i++) table()[i].clear();</span>
<span class="line-removed">1015 }</span>
<span class="line-removed">1016 </span>
<span class="line-removed">1017 bool klassVtable::is_initialized() {</span>
<span class="line-removed">1018   return _length == 0 || table()[0].method() != NULL;</span>
<span class="line-removed">1019 }</span>
<span class="line-removed">1020 </span>
1021 //-----------------------------------------------------------------------------------------
1022 // Itable code
1023 
1024 // Initialize a itableMethodEntry
1025 void itableMethodEntry::initialize(Method* m) {
1026   if (m == NULL) return;
1027 
1028 #ifdef ASSERT
1029   if (MetaspaceShared::is_in_shared_metaspace((void*)&amp;_method) &amp;&amp;
1030      !MetaspaceShared::remapped_readwrite()) {
1031     // At runtime initialize_itable is rerun as part of link_class_impl()
1032     // for a shared class loaded by the non-boot loader.
1033     // The dumptime itable method entry should be the same as the runtime entry.
1034     assert(_method == m, &quot;sanity&quot;);
1035   }
1036 #endif
1037   _method = m;
1038 }
1039 
1040 klassItable::klassItable(InstanceKlass* klass) {
</pre>
<hr />
<pre>
1175     Method* mm = methods-&gt;at(--nof_methods_copy);
1176     assert(!mm-&gt;has_itable_index() || mm-&gt;itable_index() &lt; length, &quot;&quot;);
1177   }
1178 #endif //ASSERT
1179   // return the rightmost itable index, plus one; or 0 if no methods have
1180   // itable indices
1181   return length;
1182 }
1183 
1184 
1185 void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {
1186   assert(interf-&gt;is_interface(), &quot;must be&quot;);
1187   Array&lt;Method*&gt;* methods = interf-&gt;methods();
1188   int nof_methods = methods-&gt;length();
1189   HandleMark hm;
1190   Handle interface_loader (THREAD, interf-&gt;class_loader());
1191 
1192   int ime_count = method_count_for_interface(interf);
1193   for (int i = 0; i &lt; nof_methods; i++) {
1194     Method* m = methods-&gt;at(i);
<span class="line-modified">1195     methodHandle target;</span>
1196     if (m-&gt;has_itable_index()) {
1197       // This search must match the runtime resolution, i.e. selection search for invokeinterface
1198       // to correctly enforce loader constraints for interface method inheritance.
1199       // Private methods are skipped as a private class method can never be the implementation
1200       // of an interface method.
1201       // Invokespecial does not perform selection based on the receiver, so it does not use
1202       // the cached itable.
1203       target = LinkResolver::lookup_instance_method_in_klasses(_klass, m-&gt;name(), m-&gt;signature(),
1204                                                                Klass::skip_private, CHECK);
1205     }
1206     if (target == NULL || !target-&gt;is_public() || target-&gt;is_abstract() || target-&gt;is_overpass()) {
1207       assert(target == NULL || !target-&gt;is_overpass() || target-&gt;is_public(),
1208              &quot;Non-public overpass method!&quot;);
1209       // Entry does not resolve. Leave it empty for AbstractMethodError or other error.
1210       if (!(target == NULL) &amp;&amp; !target-&gt;is_public()) {
1211         // Stuff an IllegalAccessError throwing method in there instead.
1212         itableOffsetEntry::method_entry(_klass, method_table_offset)[m-&gt;itable_index()].
1213             initialize(Universe::throw_illegal_access_error());
1214       }
1215     } else {
1216       // Entry did resolve, check loader constraints before initializing
1217       // if checkconstraints requested
1218       if (checkconstraints) {
1219         Handle method_holder_loader (THREAD, target-&gt;method_holder()-&gt;class_loader());
<span class="line-modified">1220         if (!oopDesc::equals(method_holder_loader(), interface_loader())) {</span>

1221           ResourceMark rm(THREAD);
1222           Symbol* failed_type_symbol =
1223             SystemDictionary::check_signature_loaders(m-&gt;signature(),
1224                                                       method_holder_loader,
1225                                                       interface_loader,
1226                                                       true, CHECK);
1227           if (failed_type_symbol != NULL) {
1228             stringStream ss;
1229             ss.print(&quot;loader constraint violation in interface itable&quot;
<span class="line-modified">1230                      &quot; initialization for class %s: when selecting method %s the&quot;</span>
<span class="line-modified">1231                      &quot; class loader %s for super interface %s, and the class&quot;</span>
<span class="line-modified">1232                      &quot; loader %s of the selected method&#39;s type, %s have&quot;</span>


1233                      &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
<span class="line-removed">1234                      _klass-&gt;external_name(),</span>
<span class="line-removed">1235                      m-&gt;name_and_sig_as_C_string(),</span>
1236                      interf-&gt;class_loader_data()-&gt;loader_name_and_id(),
1237                      interf-&gt;external_name(),
<span class="line-modified">1238                      target()-&gt;method_holder()-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">1239                      target()-&gt;method_holder()-&gt;external_name(),</span>

1240                      failed_type_symbol-&gt;as_klass_external_name(),
1241                      interf-&gt;class_in_module_of_loader(false, true),
<span class="line-modified">1242                      target()-&gt;method_holder()-&gt;class_in_module_of_loader(false, true));</span>
1243             THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
1244           }
1245         }
1246       }
1247 
1248       // ime may have moved during GC so recalculate address
1249       int ime_num = m-&gt;itable_index();
1250       assert(ime_num &lt; ime_count, &quot;oob&quot;);
<span class="line-modified">1251       itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target());</span>
1252       if (log_develop_is_enabled(Trace, itables)) {
1253         ResourceMark rm(THREAD);
<span class="line-modified">1254         if (target() != NULL) {</span>
1255           LogTarget(Trace, itables) lt;
1256           LogStream ls(lt);
<span class="line-modified">1257           char* sig = target()-&gt;name_and_sig_as_C_string();</span>
1258           ls.print(&quot;interface: %s, ime_num: %d, target: %s, method_holder: %s &quot;,
1259                        interf-&gt;internal_name(), ime_num, sig,
<span class="line-modified">1260                        target()-&gt;method_holder()-&gt;internal_name());</span>
1261           ls.print(&quot;target_method flags: &quot;);
<span class="line-modified">1262           target()-&gt;print_linkage_flags(&amp;ls);</span>
1263           ls.cr();
1264         }
1265       }
1266     }
1267   }
1268 }
1269 
1270 #if INCLUDE_JVMTI
1271 // search the itable for uses of either obsolete or EMCP methods
1272 void klassItable::adjust_method_entries(bool * trace_name_printed) {
1273 
1274   itableMethodEntry* ime = method_entry(0);
1275   for (int i = 0; i &lt; _size_method_table; i++, ime++) {
1276     Method* old_method = ime-&gt;method();
1277     if (old_method == NULL || !old_method-&gt;is_old()) {
1278       continue; // skip uninteresting entries
1279     }
1280     assert(!old_method-&gt;is_deleted(), &quot;itable methods may not be deleted&quot;);
1281     Method* new_method = old_method-&gt;get_new_method();
1282     ime-&gt;initialize(new_method);
</pre>
<hr />
<pre>
1430          &quot;mismatch calculation of itable size&quot;);
1431 
1432   // Fill-out offset table
1433   itableOffsetEntry* ioe = (itableOffsetEntry*)klass-&gt;start_of_itable();
1434   itableMethodEntry* ime = (itableMethodEntry*)(ioe + nof_interfaces);
1435   intptr_t* end               = klass-&gt;end_of_itable();
1436   assert((oop*)(ime + nof_methods) &lt;= (oop*)klass-&gt;start_of_nonstatic_oop_maps(), &quot;wrong offset calculation (1)&quot;);
1437   assert((oop*)(end) == (oop*)(ime + nof_methods),                      &quot;wrong offset calculation (2)&quot;);
1438 
1439   // Visit all interfaces and initialize itable offset table
1440   SetupItableClosure sic((address)klass, ioe, ime);
1441   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;sic);
1442 
1443 #ifdef ASSERT
1444   ime  = sic.method_entry();
1445   oop* v = (oop*) klass-&gt;end_of_itable();
1446   assert( (oop*)(ime) == v, &quot;wrong offset calculation (2)&quot;);
1447 #endif
1448 }
1449 
<span class="line-removed">1450 </span>
<span class="line-removed">1451 // inverse to itable_index</span>
<span class="line-removed">1452 Method* klassItable::method_for_itable_index(InstanceKlass* intf, int itable_index) {</span>
<span class="line-removed">1453   assert(intf-&gt;is_interface(), &quot;sanity check&quot;);</span>
<span class="line-removed">1454   assert(intf-&gt;verify_itable_index(itable_index), &quot;&quot;);</span>
<span class="line-removed">1455   Array&lt;Method*&gt;* methods = InstanceKlass::cast(intf)-&gt;methods();</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457   if (itable_index &lt; 0 || itable_index &gt;= method_count_for_interface(intf))</span>
<span class="line-removed">1458     return NULL;                // help caller defend against bad indices</span>
<span class="line-removed">1459 </span>
<span class="line-removed">1460   int index = itable_index;</span>
<span class="line-removed">1461   Method* m = methods-&gt;at(index);</span>
<span class="line-removed">1462   int index2 = -1;</span>
<span class="line-removed">1463   while (!m-&gt;has_itable_index() ||</span>
<span class="line-removed">1464          (index2 = m-&gt;itable_index()) != itable_index) {</span>
<span class="line-removed">1465     assert(index2 &lt; itable_index, &quot;monotonic&quot;);</span>
<span class="line-removed">1466     if (++index == methods-&gt;length())</span>
<span class="line-removed">1467       return NULL;</span>
<span class="line-removed">1468     m = methods-&gt;at(index);</span>
<span class="line-removed">1469   }</span>
<span class="line-removed">1470   assert(m-&gt;itable_index() == itable_index, &quot;correct inverse&quot;);</span>
<span class="line-removed">1471 </span>
<span class="line-removed">1472   return m;</span>
<span class="line-removed">1473 }</span>
<span class="line-removed">1474 </span>
1475 void klassVtable::verify(outputStream* st, bool forced) {
1476   // make sure table is initialized
1477   if (!Universe::is_fully_initialized()) return;
1478 #ifndef PRODUCT
1479   // avoid redundant verifies
1480   if (!forced &amp;&amp; _verify_count == Universe::verify_count()) return;
1481   _verify_count = Universe::verify_count();
1482 #endif
1483   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
1484   oop* end_of_vtable = (oop *)&amp;table()[_length];
1485   if (end_of_vtable &gt; end_of_obj) {
1486     ResourceMark rm;
1487     fatal(&quot;klass %s: klass object too short (vtable extends beyond end)&quot;,
1488           _klass-&gt;internal_name());
1489   }
1490 
1491   for (int i = 0; i &lt; _length; i++) table()[i].verify(this, st);
1492   // verify consistency with superKlass vtable
1493   Klass* super = _klass-&gt;super();
1494   if (super != NULL) {
</pre>
<hr />
<pre>
1503 void klassVtable::verify_against(outputStream* st, klassVtable* vt, int index) {
1504   vtableEntry* vte = &amp;vt-&gt;table()[index];
1505   if (vte-&gt;method()-&gt;name()      != table()[index].method()-&gt;name() ||
1506       vte-&gt;method()-&gt;signature() != table()[index].method()-&gt;signature()) {
1507     fatal(&quot;mismatched name/signature of vtable entries&quot;);
1508   }
1509 }
1510 
1511 #ifndef PRODUCT
1512 void klassVtable::print() {
1513   ResourceMark rm;
1514   tty-&gt;print(&quot;klassVtable for klass %s (length %d):\n&quot;, _klass-&gt;internal_name(), length());
1515   for (int i = 0; i &lt; length(); i++) {
1516     table()[i].print();
1517     tty-&gt;cr();
1518   }
1519 }
1520 #endif
1521 
1522 void vtableEntry::verify(klassVtable* vt, outputStream* st) {
<span class="line-removed">1523   NOT_PRODUCT(FlagSetting fs(IgnoreLockingAssertions, true));</span>
1524   Klass* vtklass = vt-&gt;klass();
1525   if (vtklass-&gt;is_instance_klass() &amp;&amp;
1526      (InstanceKlass::cast(vtklass)-&gt;major_version() &gt;= klassVtable::VTABLE_TRANSITIVE_OVERRIDE_VERSION)) {
1527     assert(method() != NULL, &quot;must have set method&quot;);
1528   }
1529   if (method() != NULL) {
1530     method()-&gt;verify();
1531     // we sub_type, because it could be a miranda method
1532     if (!vtklass-&gt;is_subtype_of(method()-&gt;method_holder())) {
1533 #ifndef PRODUCT
1534       print();
1535 #endif
1536       fatal(&quot;vtableEntry &quot; PTR_FORMAT &quot;: method is from subclass&quot;, p2i(this));
1537     }
1538  }
1539 }
1540 
1541 #ifndef PRODUCT
1542 
1543 void vtableEntry::print() {
</pre>
</td>
<td>
<hr />
<pre>
 111     if (Universe::is_bootstrapping()) {
 112       // Someone is attempting to override java.lang.Object incorrectly on the
 113       // bootclasspath.  The JVM cannot recover from this error including throwing
 114       // an exception
 115       vm_exit_during_initialization(&quot;Incompatible definition of java.lang.Object&quot;);
 116     } else {
 117       // Someone is attempting to redefine java.lang.Object incorrectly.  The
 118       // only way this should happen is from
 119       // SystemDictionary::resolve_from_stream(), which will detect this later
 120       // and throw a security exception.  So don&#39;t assert here to let
 121       // the exception occur.
 122       vtable_length = Universe::base_vtable_size();
 123     }
 124   }
 125   assert(vtable_length % vtableEntry::size() == 0, &quot;bad vtable length&quot;);
 126   assert(vtable_length &gt;= Universe::base_vtable_size(), &quot;vtable too small&quot;);
 127 
 128   *vtable_length_ret = vtable_length;
 129 }
 130 





 131 // Copy super class&#39;s vtable to the first part (prefix) of this class&#39;s vtable,
 132 // and return the number of entries copied.  Expects that &#39;super&#39; is the Java
 133 // super class (arrays can have &quot;array&quot; super classes that must be skipped).
 134 int klassVtable::initialize_from_super(Klass* super) {
 135   if (super == NULL) {
 136     return 0;
 137   } else if (is_preinitialized_vtable()) {
 138     // A shared class&#39; vtable is preinitialized at dump time. No need to copy
 139     // methods from super class for shared class, as that was already done
 140     // during archiving time. However, if Jvmti has redefined a class,
 141     // copy super class&#39;s vtable in case the super class has changed.
 142     return super-&gt;vtable().length();
 143   } else {
 144     // copy methods from superKlass
 145     klassVtable superVtable = super-&gt;vtable();
 146     assert(superVtable.length() &lt;= _length, &quot;vtable too short&quot;);
 147 #ifdef ASSERT
 148     superVtable.verify(tty, true);
 149 #endif
 150     superVtable.copy_vtable_to(table());
 151     if (log_develop_is_enabled(Trace, vtables)) {
 152       ResourceMark rm;
 153       log_develop_trace(vtables)(&quot;copy vtable from %s to %s size %d&quot;,
 154                                  super-&gt;internal_name(), klass()-&gt;internal_name(),
 155                                  _length);
 156     }
 157     return superVtable.length();
 158   }
 159 }
 160 
 161 //
 162 // Revised lookup semantics   introduced 1.3 (Kestrel beta)
 163 void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {
 164 
 165   // Note:  Arrays can have intermediate array supers.  Use java_super to skip them.
 166   InstanceKlass* super = _klass-&gt;java_super();

 167 
 168   bool is_shared = _klass-&gt;is_shared();
 169 
 170   if (!_klass-&gt;is_array_klass()) {
 171     ResourceMark rm(THREAD);
 172     log_develop_debug(vtables)(&quot;Initializing: %s&quot;, _klass-&gt;name()-&gt;as_C_string());
 173   }
 174 
 175 #ifdef ASSERT
 176   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
 177   oop* end_of_vtable = (oop*)&amp;table()[_length];
 178   assert(end_of_vtable &lt;= end_of_obj, &quot;vtable extends beyond end&quot;);
 179 #endif
 180 
 181   if (Universe::is_bootstrapping()) {
 182     assert(!is_shared, &quot;sanity&quot;);
 183     // just clear everything
 184     for (int i = 0; i &lt; _length; i++) table()[i].clear();
 185     return;
 186   }
</pre>
<hr />
<pre>
 274 
 275 // Called for cases where a method does not override its superclass&#39; vtable entry
 276 // For bytecodes not produced by javac together it is possible that a method does not override
 277 // the superclass&#39;s method, but might indirectly override a super-super class&#39;s vtable entry
 278 // If none found, return a null superk, else return the superk of the method this does override
 279 // For public and protected methods: if they override a superclass, they will
 280 // also be overridden themselves appropriately.
 281 // Private methods do not override, and are not overridden and are not in the vtable.
 282 // Package Private methods are trickier:
 283 // e.g. P1.A, pub m
 284 // P2.B extends A, package private m
 285 // P1.C extends B, public m
 286 // P1.C.m needs to override P1.A.m and can not override P2.B.m
 287 // Therefore: all package private methods need their own vtable entries for
 288 // them to be the root of an inheritance overriding decision
 289 // Package private methods may also override other vtable entries
 290 InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method,
 291                             int vtable_index, Handle target_loader, Symbol* target_classname, Thread * THREAD) {
 292   InstanceKlass* superk = initialsuper;
 293   while (superk != NULL &amp;&amp; superk-&gt;super() != NULL) {
<span class="line-modified"> 294     klassVtable ssVtable = (superk-&gt;super())-&gt;vtable();</span>

 295     if (vtable_index &lt; ssVtable.length()) {
 296       Method* super_method = ssVtable.method_at(vtable_index);
<span class="line-added"> 297       // get the class holding the matching method</span>
<span class="line-added"> 298       // make sure you use that class for is_override</span>
<span class="line-added"> 299       InstanceKlass* supermethodholder = super_method-&gt;method_holder();</span>
 300 #ifndef PRODUCT
 301       Symbol* name= target_method()-&gt;name();
 302       Symbol* signature = target_method()-&gt;signature();
 303       assert(super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature, &quot;vtable entry name/sig mismatch&quot;);
 304 #endif
<span class="line-modified"> 305 </span>
<span class="line-added"> 306       if (supermethodholder-&gt;is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD)) {</span>
 307         if (log_develop_is_enabled(Trace, vtables)) {
 308           ResourceMark rm(THREAD);
 309           LogTarget(Trace, vtables) lt;
 310           LogStream ls(lt);
 311           char* sig = target_method()-&gt;name_and_sig_as_C_string();
 312           ls.print(&quot;transitive overriding superclass %s with %s index %d, original flags: &quot;,
<span class="line-modified"> 313                        supermethodholder-&gt;internal_name(),</span>
 314                        sig, vtable_index);
 315           super_method-&gt;print_linkage_flags(&amp;ls);
 316           ls.print(&quot;overriders flags: &quot;);
 317           target_method-&gt;print_linkage_flags(&amp;ls);
 318           ls.cr();
 319         }
 320 
 321         break; // return found superk
 322       }
 323     } else  {
 324       // super class has no vtable entry here, stop transitive search
 325       superk = (InstanceKlass*)NULL;
 326       break;
 327     }
 328     // if no override found yet, continue to search up
 329     superk = superk-&gt;super() == NULL ? NULL : InstanceKlass::cast(superk-&gt;super());
 330   }
 331 
 332   return superk;
 333 }
</pre>
<hr />
<pre>
 447     } else {
 448       super_method = method_at(i);
 449     }
 450     // Check if method name matches.  Ignore match if klass is an interface and the
 451     // matching method is a non-public java.lang.Object method.  (See JVMS 5.4.3.4)
 452     // This is safe because the method at this slot should never get invoked.
 453     // (TBD: put in a method to throw NoSuchMethodError if this slot is ever used.)
 454     if (super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature &amp;&amp;
 455         (!_klass-&gt;is_interface() ||
 456          !SystemDictionary::is_nonpublic_Object_method(super_method))) {
 457 
 458       // get super_klass for method_holder for the found method
 459       InstanceKlass* super_klass =  super_method-&gt;method_holder();
 460 
 461       // Whether the method is being overridden
 462       bool overrides = false;
 463 
 464       // private methods are also never overridden
 465       if (!super_method-&gt;is_private() &amp;&amp;
 466           (is_default
<span class="line-modified"> 467           || ((super_klass-&gt;is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD))</span>
 468           || ((klass-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION)
 469           &amp;&amp; ((super_klass = find_transitive_override(super_klass,
 470                              target_method, i, target_loader,
 471                              target_classname, THREAD))
 472                              != (InstanceKlass*)NULL)))))
 473         {
 474         // Package private methods always need a new entry to root their own
 475         // overriding. They may also override other methods.
 476         if (!target_method()-&gt;is_package_private()) {
 477           allocate_new = false;
 478         }
 479 
 480         // Do not check loader constraints for overpass methods because overpass
 481         // methods are created by the jvm to throw exceptions.
 482         if (checkconstraints &amp;&amp; !target_method()-&gt;is_overpass()) {
 483           // Override vtable entry if passes loader constraint check
 484           // if loader constraint checking requested
 485           // No need to visit his super, since he and his super
 486           // have already made any needed loader constraints.
 487           // Since loader constraints are transitive, it is enough
 488           // to link to the first super, and we get all the others.
 489           Handle super_loader(THREAD, super_klass-&gt;class_loader());
 490 
<span class="line-modified"> 491           if (target_loader() != super_loader()) {</span>
 492             ResourceMark rm(THREAD);
 493             Symbol* failed_type_symbol =
 494               SystemDictionary::check_signature_loaders(signature, target_loader,
 495                                                         super_loader, true,
 496                                                         CHECK_(false));
 497             if (failed_type_symbol != NULL) {
 498               stringStream ss;
 499               ss.print(&quot;loader constraint violation for class %s: when selecting &quot;
<span class="line-modified"> 500                        &quot;overriding method &#39;&quot;, klass-&gt;external_name());</span>
<span class="line-added"> 501               target_method()-&gt;print_external_name(&amp;ss),</span>
<span class="line-added"> 502               ss.print(&quot;&#39; the class loader %s of the &quot;</span>
 503                        &quot;selected method&#39;s type %s, and the class loader %s for its super &quot;
 504                        &quot;type %s have different Class objects for the type %s used in the signature (%s; %s)&quot;,


 505                        target_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 506                        target_klass-&gt;external_name(),
 507                        super_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 508                        super_klass-&gt;external_name(),
 509                        failed_type_symbol-&gt;as_klass_external_name(),
 510                        target_klass-&gt;class_in_module_of_loader(false, true),
 511                        super_klass-&gt;class_in_module_of_loader(false, true));
 512               THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);
 513             }
 514           }
 515         }
 516 
 517         put_method_at(target_method(), i);
 518         overrides = true;
 519         if (!is_default) {
 520           target_method()-&gt;set_vtable_index(i);
 521         } else {
 522           if (def_vtable_indices != NULL) {
 523             if (is_preinitialized_vtable()) {
 524               // At runtime initialize_vtable is rerun as part of link_class_impl()
</pre>
<hr />
<pre>
 611       target_method()-&gt;method_holder()-&gt;is_interface()  &amp;&amp;
 612       !target_method()-&gt;is_abstract()) {
 613     assert(target_method()-&gt;is_default_method(),
 614            &quot;unexpected interface method type&quot;);
 615     return false;
 616   }
 617 
 618   // we need a new entry if there is no superclass
 619   if (super == NULL) {
 620     return true;
 621   }
 622 
 623   // Package private methods always need a new entry to root their own
 624   // overriding. This allows transitive overriding to work.
 625   if (target_method()-&gt;is_package_private()) {
 626     return true;
 627   }
 628 
 629   // search through the super class hierarchy to see if we need
 630   // a new entry
<span class="line-modified"> 631   ResourceMark rm(THREAD);</span>
 632   Symbol* name = target_method()-&gt;name();
 633   Symbol* signature = target_method()-&gt;signature();
 634   const Klass* k = super;
 635   Method* super_method = NULL;
 636   InstanceKlass *holder = NULL;
 637   Method* recheck_method =  NULL;
<span class="line-added"> 638   bool found_pkg_prvt_method = false;</span>
 639   while (k != NULL) {
 640     // lookup through the hierarchy for a method with matching name and sign.
 641     super_method = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
 642     if (super_method == NULL) {
 643       break; // we still have to search for a matching miranda method
 644     }
 645     // get the class holding the matching method
 646     // make sure you use that class for is_override
 647     InstanceKlass* superk = super_method-&gt;method_holder();
 648     // we want only instance method matches
 649     // ignore private methods found via lookup_method since they do not participate in overriding,
 650     // and since we do override around them: e.g. a.m pub/b.m private/c.m pub,
 651     // ignore private, c.m pub does override a.m pub
 652     // For classes that were not javac&#39;d together, we also do transitive overriding around
 653     // methods that have less accessibility
 654     if ((!super_method-&gt;is_static()) &amp;&amp;
 655        (!super_method-&gt;is_private())) {
<span class="line-modified"> 656       if (superk-&gt;is_override(methodHandle(THREAD, super_method), classloader, classname, THREAD)) {</span>
 657         return false;
 658       // else keep looking for transitive overrides
 659       }
<span class="line-added"> 660       // If we get here then one of the super classes has a package private method</span>
<span class="line-added"> 661       // that will not get overridden because it is in a different package.  But,</span>
<span class="line-added"> 662       // that package private method does &quot;override&quot; any matching methods in super</span>
<span class="line-added"> 663       // interfaces, so there will be no miranda vtable entry created.  So, set flag</span>
<span class="line-added"> 664       // to TRUE for use below, in case there are no methods in super classes that</span>
<span class="line-added"> 665       // this target method overrides.</span>
<span class="line-added"> 666       assert(super_method-&gt;is_package_private(), &quot;super_method must be package private&quot;);</span>
<span class="line-added"> 667       assert(!superk-&gt;is_same_class_package(classloader(), classname),</span>
<span class="line-added"> 668              &quot;Must be different packages&quot;);</span>
<span class="line-added"> 669       found_pkg_prvt_method = true;</span>
 670     }
 671 
 672     // Start with lookup result and continue to search up, for versions supporting transitive override
 673     if (major_version &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION) {
 674       k = superk-&gt;super(); // haven&#39;t found an override match yet; continue to look
 675     } else {
 676       break;
 677     }
 678   }
 679 
<span class="line-added"> 680   // If found_pkg_prvt_method is set, then the ONLY matching method in the</span>
<span class="line-added"> 681   // superclasses is package private in another package. That matching method will</span>
<span class="line-added"> 682   // prevent a miranda vtable entry from being created. Because the target method can not</span>
<span class="line-added"> 683   // override the package private method in another package, then it needs to be the root</span>
<span class="line-added"> 684   // for its own vtable entry.</span>
<span class="line-added"> 685   if (found_pkg_prvt_method) {</span>
<span class="line-added"> 686      return true;</span>
<span class="line-added"> 687   }</span>
<span class="line-added"> 688 </span>
 689   // if the target method is public or protected it may have a matching
 690   // miranda method in the super, whose entry it should re-use.
 691   // Actually, to handle cases that javac would not generate, we need
 692   // this check for all access permissions.
 693   const InstanceKlass *sk = InstanceKlass::cast(super);
 694   if (sk-&gt;has_miranda_methods()) {
 695     if (sk-&gt;lookup_method_in_all_interfaces(name, signature, Klass::find_defaults) != NULL) {
<span class="line-modified"> 696       return false; // found a matching miranda; we do not need a new entry</span>
 697     }
 698   }
 699   return true; // found no match; we need a new entry
 700 }
 701 
 702 // Support for miranda methods
 703 
 704 // get the vtable index of a miranda method with matching &quot;name&quot; and &quot;signature&quot;
 705 int klassVtable::index_of_miranda(Symbol* name, Symbol* signature) {
 706   // search from the bottom, might be faster
 707   for (int i = (length() - 1); i &gt;= 0; i--) {
 708     Method* m = table()[i].method();
 709     if (is_miranda_entry_at(i) &amp;&amp;
 710         m-&gt;name() == name &amp;&amp; m-&gt;signature() == signature) {
 711       return i;
 712     }
 713   }
 714   return Method::invalid_vtable_index;
 715 }
 716 
</pre>
<hr />
<pre>
1009   tty-&gt;print_cr(&quot;vtable dump --&quot;);
1010   for (int i = 0; i &lt; length(); i++) {
1011     Method* m = unchecked_method_at(i);
1012     if (m != NULL) {
1013       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1014       m-&gt;access_flags().print_on(tty);
1015       if (m-&gt;is_default_method()) {
1016         tty-&gt;print(&quot;default &quot;);
1017       }
1018       if (m-&gt;is_overpass()) {
1019         tty-&gt;print(&quot;overpass&quot;);
1020       }
1021       tty-&gt;print(&quot; --  &quot;);
1022       m-&gt;print_name(tty);
1023       tty-&gt;cr();
1024     }
1025   }
1026 }
1027 #endif // INCLUDE_JVMTI
1028 









1029 //-----------------------------------------------------------------------------------------
1030 // Itable code
1031 
1032 // Initialize a itableMethodEntry
1033 void itableMethodEntry::initialize(Method* m) {
1034   if (m == NULL) return;
1035 
1036 #ifdef ASSERT
1037   if (MetaspaceShared::is_in_shared_metaspace((void*)&amp;_method) &amp;&amp;
1038      !MetaspaceShared::remapped_readwrite()) {
1039     // At runtime initialize_itable is rerun as part of link_class_impl()
1040     // for a shared class loaded by the non-boot loader.
1041     // The dumptime itable method entry should be the same as the runtime entry.
1042     assert(_method == m, &quot;sanity&quot;);
1043   }
1044 #endif
1045   _method = m;
1046 }
1047 
1048 klassItable::klassItable(InstanceKlass* klass) {
</pre>
<hr />
<pre>
1183     Method* mm = methods-&gt;at(--nof_methods_copy);
1184     assert(!mm-&gt;has_itable_index() || mm-&gt;itable_index() &lt; length, &quot;&quot;);
1185   }
1186 #endif //ASSERT
1187   // return the rightmost itable index, plus one; or 0 if no methods have
1188   // itable indices
1189   return length;
1190 }
1191 
1192 
1193 void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {
1194   assert(interf-&gt;is_interface(), &quot;must be&quot;);
1195   Array&lt;Method*&gt;* methods = interf-&gt;methods();
1196   int nof_methods = methods-&gt;length();
1197   HandleMark hm;
1198   Handle interface_loader (THREAD, interf-&gt;class_loader());
1199 
1200   int ime_count = method_count_for_interface(interf);
1201   for (int i = 0; i &lt; nof_methods; i++) {
1202     Method* m = methods-&gt;at(i);
<span class="line-modified">1203     Method* target = NULL;</span>
1204     if (m-&gt;has_itable_index()) {
1205       // This search must match the runtime resolution, i.e. selection search for invokeinterface
1206       // to correctly enforce loader constraints for interface method inheritance.
1207       // Private methods are skipped as a private class method can never be the implementation
1208       // of an interface method.
1209       // Invokespecial does not perform selection based on the receiver, so it does not use
1210       // the cached itable.
1211       target = LinkResolver::lookup_instance_method_in_klasses(_klass, m-&gt;name(), m-&gt;signature(),
1212                                                                Klass::skip_private, CHECK);
1213     }
1214     if (target == NULL || !target-&gt;is_public() || target-&gt;is_abstract() || target-&gt;is_overpass()) {
1215       assert(target == NULL || !target-&gt;is_overpass() || target-&gt;is_public(),
1216              &quot;Non-public overpass method!&quot;);
1217       // Entry does not resolve. Leave it empty for AbstractMethodError or other error.
1218       if (!(target == NULL) &amp;&amp; !target-&gt;is_public()) {
1219         // Stuff an IllegalAccessError throwing method in there instead.
1220         itableOffsetEntry::method_entry(_klass, method_table_offset)[m-&gt;itable_index()].
1221             initialize(Universe::throw_illegal_access_error());
1222       }
1223     } else {
1224       // Entry did resolve, check loader constraints before initializing
1225       // if checkconstraints requested
1226       if (checkconstraints) {
1227         Handle method_holder_loader (THREAD, target-&gt;method_holder()-&gt;class_loader());
<span class="line-modified">1228         InstanceKlass* method_holder = target-&gt;method_holder();</span>
<span class="line-added">1229         if (method_holder_loader() != interface_loader()) {</span>
1230           ResourceMark rm(THREAD);
1231           Symbol* failed_type_symbol =
1232             SystemDictionary::check_signature_loaders(m-&gt;signature(),
1233                                                       method_holder_loader,
1234                                                       interface_loader,
1235                                                       true, CHECK);
1236           if (failed_type_symbol != NULL) {
1237             stringStream ss;
1238             ss.print(&quot;loader constraint violation in interface itable&quot;
<span class="line-modified">1239                      &quot; initialization for class %s: when selecting method &#39;&quot;,</span>
<span class="line-modified">1240                      _klass-&gt;external_name());</span>
<span class="line-modified">1241             m-&gt;print_external_name(&amp;ss),</span>
<span class="line-added">1242             ss.print(&quot;&#39; the class loader %s for super interface %s, and the class&quot;</span>
<span class="line-added">1243                      &quot; loader %s of the selected method&#39;s %s, %s have&quot;</span>
1244                      &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,


1245                      interf-&gt;class_loader_data()-&gt;loader_name_and_id(),
1246                      interf-&gt;external_name(),
<span class="line-modified">1247                      method_holder-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">1248                      method_holder-&gt;external_kind(),</span>
<span class="line-added">1249                      method_holder-&gt;external_name(),</span>
1250                      failed_type_symbol-&gt;as_klass_external_name(),
1251                      interf-&gt;class_in_module_of_loader(false, true),
<span class="line-modified">1252                      method_holder-&gt;class_in_module_of_loader(false, true));</span>
1253             THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
1254           }
1255         }
1256       }
1257 
1258       // ime may have moved during GC so recalculate address
1259       int ime_num = m-&gt;itable_index();
1260       assert(ime_num &lt; ime_count, &quot;oob&quot;);
<span class="line-modified">1261       itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target);</span>
1262       if (log_develop_is_enabled(Trace, itables)) {
1263         ResourceMark rm(THREAD);
<span class="line-modified">1264         if (target != NULL) {</span>
1265           LogTarget(Trace, itables) lt;
1266           LogStream ls(lt);
<span class="line-modified">1267           char* sig = target-&gt;name_and_sig_as_C_string();</span>
1268           ls.print(&quot;interface: %s, ime_num: %d, target: %s, method_holder: %s &quot;,
1269                        interf-&gt;internal_name(), ime_num, sig,
<span class="line-modified">1270                        target-&gt;method_holder()-&gt;internal_name());</span>
1271           ls.print(&quot;target_method flags: &quot;);
<span class="line-modified">1272           target-&gt;print_linkage_flags(&amp;ls);</span>
1273           ls.cr();
1274         }
1275       }
1276     }
1277   }
1278 }
1279 
1280 #if INCLUDE_JVMTI
1281 // search the itable for uses of either obsolete or EMCP methods
1282 void klassItable::adjust_method_entries(bool * trace_name_printed) {
1283 
1284   itableMethodEntry* ime = method_entry(0);
1285   for (int i = 0; i &lt; _size_method_table; i++, ime++) {
1286     Method* old_method = ime-&gt;method();
1287     if (old_method == NULL || !old_method-&gt;is_old()) {
1288       continue; // skip uninteresting entries
1289     }
1290     assert(!old_method-&gt;is_deleted(), &quot;itable methods may not be deleted&quot;);
1291     Method* new_method = old_method-&gt;get_new_method();
1292     ime-&gt;initialize(new_method);
</pre>
<hr />
<pre>
1440          &quot;mismatch calculation of itable size&quot;);
1441 
1442   // Fill-out offset table
1443   itableOffsetEntry* ioe = (itableOffsetEntry*)klass-&gt;start_of_itable();
1444   itableMethodEntry* ime = (itableMethodEntry*)(ioe + nof_interfaces);
1445   intptr_t* end               = klass-&gt;end_of_itable();
1446   assert((oop*)(ime + nof_methods) &lt;= (oop*)klass-&gt;start_of_nonstatic_oop_maps(), &quot;wrong offset calculation (1)&quot;);
1447   assert((oop*)(end) == (oop*)(ime + nof_methods),                      &quot;wrong offset calculation (2)&quot;);
1448 
1449   // Visit all interfaces and initialize itable offset table
1450   SetupItableClosure sic((address)klass, ioe, ime);
1451   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;sic);
1452 
1453 #ifdef ASSERT
1454   ime  = sic.method_entry();
1455   oop* v = (oop*) klass-&gt;end_of_itable();
1456   assert( (oop*)(ime) == v, &quot;wrong offset calculation (2)&quot;);
1457 #endif
1458 }
1459 

























1460 void klassVtable::verify(outputStream* st, bool forced) {
1461   // make sure table is initialized
1462   if (!Universe::is_fully_initialized()) return;
1463 #ifndef PRODUCT
1464   // avoid redundant verifies
1465   if (!forced &amp;&amp; _verify_count == Universe::verify_count()) return;
1466   _verify_count = Universe::verify_count();
1467 #endif
1468   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
1469   oop* end_of_vtable = (oop *)&amp;table()[_length];
1470   if (end_of_vtable &gt; end_of_obj) {
1471     ResourceMark rm;
1472     fatal(&quot;klass %s: klass object too short (vtable extends beyond end)&quot;,
1473           _klass-&gt;internal_name());
1474   }
1475 
1476   for (int i = 0; i &lt; _length; i++) table()[i].verify(this, st);
1477   // verify consistency with superKlass vtable
1478   Klass* super = _klass-&gt;super();
1479   if (super != NULL) {
</pre>
<hr />
<pre>
1488 void klassVtable::verify_against(outputStream* st, klassVtable* vt, int index) {
1489   vtableEntry* vte = &amp;vt-&gt;table()[index];
1490   if (vte-&gt;method()-&gt;name()      != table()[index].method()-&gt;name() ||
1491       vte-&gt;method()-&gt;signature() != table()[index].method()-&gt;signature()) {
1492     fatal(&quot;mismatched name/signature of vtable entries&quot;);
1493   }
1494 }
1495 
1496 #ifndef PRODUCT
1497 void klassVtable::print() {
1498   ResourceMark rm;
1499   tty-&gt;print(&quot;klassVtable for klass %s (length %d):\n&quot;, _klass-&gt;internal_name(), length());
1500   for (int i = 0; i &lt; length(); i++) {
1501     table()[i].print();
1502     tty-&gt;cr();
1503   }
1504 }
1505 #endif
1506 
1507 void vtableEntry::verify(klassVtable* vt, outputStream* st) {

1508   Klass* vtklass = vt-&gt;klass();
1509   if (vtklass-&gt;is_instance_klass() &amp;&amp;
1510      (InstanceKlass::cast(vtklass)-&gt;major_version() &gt;= klassVtable::VTABLE_TRANSITIVE_OVERRIDE_VERSION)) {
1511     assert(method() != NULL, &quot;must have set method&quot;);
1512   }
1513   if (method() != NULL) {
1514     method()-&gt;verify();
1515     // we sub_type, because it could be a miranda method
1516     if (!vtklass-&gt;is_subtype_of(method()-&gt;method_holder())) {
1517 #ifndef PRODUCT
1518       print();
1519 #endif
1520       fatal(&quot;vtableEntry &quot; PTR_FORMAT &quot;: method is from subclass&quot;, p2i(this));
1521     }
1522  }
1523 }
1524 
1525 #ifndef PRODUCT
1526 
1527 void vtableEntry::print() {
</pre>
</td>
</tr>
</table>
<center><a href="klass.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassVtable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
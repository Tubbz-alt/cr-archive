diff a/src/hotspot/share/oops/klassVtable.hpp b/src/hotspot/share/oops/klassVtable.hpp
--- a/src/hotspot/share/oops/klassVtable.hpp
+++ b/src/hotspot/share/oops/klassVtable.hpp
@@ -46,17 +46,10 @@
   int          _length;           // length of vtable (number of entries)
 #ifndef PRODUCT
   int          _verify_count;     // to make verify faster
 #endif
 
-  // Ordering important, so greater_than (>) can be used as an merge operator.
-  enum AccessType {
-    acc_private         = 0,
-    acc_package_private = 1,
-    acc_publicprotected = 2
-  };
-
  public:
   klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
     _tableOffset = (address)base - (address)klass; _length = length;
   }
 
@@ -64,26 +57,16 @@
   vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
   Klass* klass() const            { return _klass;  }
   int length() const              { return _length; }
   inline Method* method_at(int i) const;
   inline Method* unchecked_method_at(int i) const;
-  inline Method** adr_method_at(int i) const;
 
   // searching; all methods return -1 if not found
-  int index_of(Method* m) const                         { return index_of(m, _length); }
   int index_of_miranda(Symbol* name, Symbol* signature);
 
   void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
 
-  // CDS/RedefineClasses support - clear vtables so they can be reinitialized
-  // at dump time.  Clearing gives us an easy way to tell if the vtable has
-  // already been reinitialized at dump time (see dump.cpp).  Vtables can
-  // be initialized at run time by RedefineClasses so dumping the right order
-  // is necessary.
-  void clear_vtable();
-  bool is_initialized();
-
   // computes vtable length (in words) and the number of miranda methods
   static void compute_vtable_size_and_num_mirandas(int* vtable_length,
                                                    int* num_new_mirandas,
                                                    GrowableArray<Method*>* all_mirandas,
                                                    const Klass* super,
@@ -123,11 +106,10 @@
   enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
 
  private:
   void copy_vtable_to(vtableEntry* start);
   int  initialize_from_super(Klass* super);
-  int  index_of(Method* m, int len) const; // same as index_of, but search only up to len
   void put_method_at(Method* m, int index);
   static bool needs_new_vtable_entry(const methodHandle& m,
                                      const Klass* super,
                                      Handle classloader,
                                      Symbol* classname,
@@ -221,16 +203,10 @@
 inline Method* klassVtable::unchecked_method_at(int i) const {
   assert(i >= 0 && i < _length, "index out of bounds");
   return table()[i].method();
 }
 
-inline Method** klassVtable::adr_method_at(int i) const {
-  // Allow one past the last entry to be referenced; useful for loop bounds.
-  assert(i >= 0 && i <= _length, "index out of bounds");
-  return (Method**)(address(table() + i) + vtableEntry::method_offset_in_bytes());
-}
-
 // --------------------------------------------------------------------------------
 class klassItable;
 class itableMethodEntry;
 
 class itableOffsetEntry {
@@ -331,13 +307,10 @@
   static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
   static int method_count_for_interface(InstanceKlass* klass);
   static int compute_itable_size(Array<InstanceKlass*>* transitive_interfaces);
   static void setup_itable_offset_table(InstanceKlass* klass);
 
-  // Resolving of method to index
-  static Method* method_for_itable_index(InstanceKlass* klass, int itable_index);
-
   // Debugging/Statistics
   static void print_statistics() PRODUCT_RETURN;
  private:
   intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
   intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,22 +24,17 @@</span>
  
  #ifndef SHARE_OOPS_METHODDATA_HPP
  #define SHARE_OOPS_METHODDATA_HPP
  
  #include &quot;interpreter/bytecodes.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/metadata.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">- #include &quot;jvmci/jvmci_globals.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
  
  class BytecodeStream;
<span class="udiff-line-removed">- class KlassSizeStats;</span>
  
  // The MethodData object collects counts and other profile information
  // during zeroth-tier (interpretive) and first-tier execution.
  // The profile is used later by compilation heuristics.  Some heuristics
  // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -560,24 +555,30 @@</span>
    virtual int cell_count() const {
      return static_cell_count();
    }
  
    // Direct accessor
<span class="udiff-line-modified-removed">-   uint count() const {</span>
<span class="udiff-line-modified-removed">-     return uint_at(count_off);</span>
<span class="udiff-line-modified-added">+   int count() const {</span>
<span class="udiff-line-modified-added">+     intptr_t raw_data = intptr_at(count_off);</span>
<span class="udiff-line-added">+     if (raw_data &gt; max_jint) {</span>
<span class="udiff-line-added">+       raw_data = max_jint;</span>
<span class="udiff-line-added">+     } else if (raw_data &lt; min_jint) {</span>
<span class="udiff-line-added">+       raw_data = min_jint;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return int(raw_data);</span>
    }
  
    // Code generation support
    static ByteSize count_offset() {
      return cell_offset(count_off);
    }
    static ByteSize counter_data_size() {
      return cell_offset(counter_cell_count);
    }
  
<span class="udiff-line-modified-removed">-   void set_count(uint count) {</span>
<span class="udiff-line-modified-removed">-     set_uint_at(count_off, count);</span>
<span class="udiff-line-modified-added">+   void set_count(int count) {</span>
<span class="udiff-line-modified-added">+     set_int_at(count_off, count);</span>
    }
  
    void print_data_on(outputStream* st, const char* extra = NULL) const;
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1947,10 +1948,46 @@</span>
  public:
    virtual bool is_live(Method* m) = 0;
  };
  
  
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+ // Encapsulates an encoded speculation reason. These are linked together in</span>
<span class="udiff-line-added">+ // a list that is atomically appended to during deoptimization. Entries are</span>
<span class="udiff-line-added">+ // never removed from the list.</span>
<span class="udiff-line-added">+ // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding</span>
<span class="udiff-line-added">+ class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="udiff-line-added">+  private:</span>
<span class="udiff-line-added">+   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself</span>
<span class="udiff-line-added">+   // is an array embedded at the end of this object.</span>
<span class="udiff-line-added">+   int   _data_len;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Next entry in a linked list.</span>
<span class="udiff-line-added">+   FailedSpeculation* _next;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   FailedSpeculation(address data, int data_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   FailedSpeculation** next_adr() { return &amp;_next; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Placement new operator for inlining the speculation data into</span>
<span class="udiff-line-added">+   // the FailedSpeculation object.</span>
<span class="udiff-line-added">+   void* operator new(size_t size, size_t fs_size) throw();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }</span>
<span class="udiff-line-added">+   int data_len() const { return _data_len; }</span>
<span class="udiff-line-added">+   FailedSpeculation* next() const { return _next; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).</span>
<span class="udiff-line-added">+   // Returns false if the FailedSpeculation object could not be allocated.</span>
<span class="udiff-line-added">+   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Frees all entries in the linked list whose head is at (*failed_speculations_address).</span>
<span class="udiff-line-added">+   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  class MethodData : public Metadata {
    friend class VMStructs;
    friend class JVMCIVMStructs;
  private:
    friend class ProfileData;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1971,18 +2008,18 @@</span>
    Mutex _extra_data_lock;
  
    MethodData(const methodHandle&amp; method, int size, TRAPS);
  public:
    static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
<span class="udiff-line-modified-removed">-   MethodData() : _extra_data_lock(Monitor::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
<span class="udiff-line-modified-added">+   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
  
    bool is_methodData() const volatile { return true; }
    void initialize();
  
    // Whole-method sticky bits and flags
    enum {
<span class="udiff-line-modified-removed">-     _trap_hist_limit    = 24 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
<span class="udiff-line-modified-added">+     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
      _trap_hist_mask     = max_jubyte,
      _extra_data_count   = 4     // extra DataLayout headers, for trap history
    }; // Public flag values
  private:
    uint _nof_decompiles;             // count of all nmethod removals
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2028,24 +2065,21 @@</span>
    enum WouldProfile {unknown, no_profile, profile};
    WouldProfile      _would_profile;
  
  #if INCLUDE_JVMCI
    // Support for HotSpotMethodData.setCompiledIRSize(int)
<span class="udiff-line-modified-removed">-   int               _jvmci_ir_size;</span>
<span class="udiff-line-modified-added">+   int                _jvmci_ir_size;</span>
<span class="udiff-line-added">+   FailedSpeculation* _failed_speculations;</span>
  #endif
  
    // Size of _data array in bytes.  (Excludes header and extra_data fields.)
    int _data_size;
  
    // data index for the area dedicated to parameters. -1 if no
    // parameter profiling.
    enum { no_parameters = -2, parameters_uninitialized = -1 };
    int _parameters_type_data_di;
<span class="udiff-line-removed">-   int parameters_size_in_bytes() const {</span>
<span class="udiff-line-removed">-     ParametersTypeData* param = parameters_type_data();</span>
<span class="udiff-line-removed">-     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="udiff-line-removed">-   }</span>
  
    // Beginning of the data entries
    intptr_t _data[1];
  
    // Helper for size computation
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2144,13 +2178,10 @@</span>
    void init();
  
    // My size
    int size_in_bytes() const { return _size; }
    int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
<span class="udiff-line-removed">- #if INCLUDE_SERVICES</span>
<span class="udiff-line-removed">-   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="udiff-line-removed">- #endif</span>
  
    int      creation_mileage() const  { return _creation_mileage; }
    void set_creation_mileage(int x)   { _creation_mileage = x; }
  
    int invocation_count() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2189,19 +2220,25 @@</span>
    }
  
    InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
    InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
  
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   FailedSpeculation** get_failed_speculations_address() {</span>
<span class="udiff-line-added">+     return &amp;_failed_speculations;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #if INCLUDE_RTM_OPT
    int rtm_state() const {
      return _rtm_state;
    }
    void set_rtm_state(RTMState rstate) {
      _rtm_state = (int)rstate;
    }
    void atomic_set_rtm_state(RTMState rstate) {
<span class="udiff-line-modified-removed">-     Atomic::store((int)rstate, &amp;_rtm_state);</span>
<span class="udiff-line-modified-added">+     Atomic::store(&amp;_rtm_state, (int)rstate);</span>
    }
  
    static int rtm_state_offset_in_bytes() {
      return offset_of(MethodData, _rtm_state);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2253,10 +2290,15 @@</span>
    }
    int data_size() const {
      return _data_size;
    }
  
<span class="udiff-line-added">+   int parameters_size_in_bytes() const {</span>
<span class="udiff-line-added">+     ParametersTypeData* param = parameters_type_data();</span>
<span class="udiff-line-added">+     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Accessors
    Method* method() const { return _method; }
  
    // Get the data at an arbitrary (sort of) data index.
    ProfileData* data_at(int data_index) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2345,11 +2387,11 @@</span>
      return _nof_decompiles;
    }
    void inc_decompile_count() {
      _nof_decompiles += 1;
      if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
<span class="udiff-line-modified-removed">-       method()-&gt;set_not_compilable(CompLevel_full_optimization, true, &quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;);</span>
<span class="udiff-line-modified-added">+       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);</span>
      }
    }
    uint tenure_traps() const {
      return _tenure_traps;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2398,11 +2440,11 @@</span>
    }
  
    virtual void metaspace_pointers_do(MetaspaceClosure* iter);
    virtual MetaspaceObj::Type type() const { return MethodDataType; }
  
<span class="udiff-line-modified-removed">-   // Deallocation support - no pointer fields to deallocate</span>
<span class="udiff-line-modified-added">+   // Deallocation support - no metaspace pointer fields to deallocate</span>
    void deallocate_contents(ClassLoaderData* loader_data) {}
  
    // GC support
    void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
  
</pre>
<center><a href="methodData.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
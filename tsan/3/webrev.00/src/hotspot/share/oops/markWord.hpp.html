<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/markWord.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_MARKWORD_HPP
 26 #define SHARE_OOPS_MARKWORD_HPP
 27 
 28 #include &quot;metaprogramming/integralConstant.hpp&quot;
 29 #include &quot;metaprogramming/primitiveConversions.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 #include &quot;runtime/globals.hpp&quot;
 32 
 33 // The markWord describes the header of an object.
 34 //
 35 // Bit-format of an object header (most significant first, big endian layout below):
 36 //
 37 //  32 bits:
 38 //  --------
 39 //             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
 40 //             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
 41 //
 42 //  64 bits:
 43 //  --------
 44 //  unused:25 hash:31 --&gt;| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)
 45 //  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)
 46 //
 47 //  - hash contains the identity hash value: largest value is
 48 //    31 bits, see os::random().  Also, 64-bit vm&#39;s require
 49 //    a hash value no bigger than 32 bits because they will not
 50 //    properly generate a mask larger than that: see library_call.cpp
 51 //    and c1_CodePatterns_sparc.cpp.
 52 //
 53 //  - the biased lock pattern is used to bias a lock toward a given
 54 //    thread. When this pattern is set in the low three bits, the lock
 55 //    is either biased toward a given thread or &quot;anonymously&quot; biased,
 56 //    indicating that it is possible for it to be biased. When the
 57 //    lock is biased toward a given thread, locking and unlocking can
 58 //    be performed by that thread without using atomic operations.
 59 //    When a lock&#39;s bias is revoked, it reverts back to the normal
 60 //    locking scheme described below.
 61 //
 62 //    Note that we are overloading the meaning of the &quot;unlocked&quot; state
 63 //    of the header. Because we steal a bit from the age we can
 64 //    guarantee that the bias pattern will never be seen for a truly
 65 //    unlocked object.
 66 //
 67 //    Note also that the biased state contains the age bits normally
 68 //    contained in the object header. Large increases in scavenge
 69 //    times were seen when these bits were absent and an arbitrary age
 70 //    assigned to all biased objects, because they tended to consume a
 71 //    significant fraction of the eden semispaces and were not
 72 //    promoted promptly, causing an increase in the amount of copying
 73 //    performed. The runtime system aligns all JavaThread* pointers to
 74 //    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))
 75 //    to make room for the age bits &amp; the epoch bits (used in support of
 76 //    biased locking).
 77 //
 78 //    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
 79 //    [0           | epoch | age | 1 | 01]       lock is anonymously biased
 80 //
 81 //  - the two lock bits are used to describe three states: locked/unlocked and monitor.
 82 //
 83 //    [ptr             | 00]  locked             ptr points to real header on stack
 84 //    [header      | 0 | 01]  unlocked           regular object header
 85 //    [ptr             | 10]  monitor            inflated lock (header is wapped out)
 86 //    [ptr             | 11]  marked             used to mark an object
 87 //
 88 //    We assume that stack/thread pointers have the lowest two bits cleared.
 89 
 90 class BasicLock;
 91 class ObjectMonitor;
 92 class JavaThread;
 93 
 94 class markWord {
 95  private:
 96   uintptr_t _value;
 97 
 98  public:
 99   explicit markWord(uintptr_t value) : _value(value) {}
100 
101   markWord() { /* uninitialized */}
102 
103   // It is critical for performance that this class be trivially
104   // destructable, copyable, and assignable.
105 
106   static markWord from_pointer(void* ptr) {
107     return markWord((uintptr_t)ptr);
108   }
109   void* to_pointer() const {
110     return (void*)_value;
111   }
112 
113   bool operator==(const markWord&amp; other) const {
114     return _value == other._value;
115   }
116   bool operator!=(const markWord&amp; other) const {
117     return !operator==(other);
118   }
119 
120   // Conversion
121   uintptr_t value() const { return _value; }
122 
123   // Constants
124   static const int age_bits                       = 4;
125   static const int lock_bits                      = 2;
126   static const int biased_lock_bits               = 1;
127   static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;
128   static const int hash_bits                      = max_hash_bits &gt; 31 ? 31 : max_hash_bits;
129   static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);
130   static const int epoch_bits                     = 2;
131 
132   // The biased locking code currently requires that the age bits be
133   // contiguous to the lock bits.
134   static const int lock_shift                     = 0;
135   static const int biased_lock_shift              = lock_bits;
136   static const int age_shift                      = lock_bits + biased_lock_bits;
137   static const int unused_gap_shift               = age_shift + age_bits;
138   static const int hash_shift                     = unused_gap_shift + unused_gap_bits;
139   static const int epoch_shift                    = hash_shift;
140 
141   static const uintptr_t lock_mask                = right_n_bits(lock_bits);
142   static const uintptr_t lock_mask_in_place       = lock_mask &lt;&lt; lock_shift;
143   static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);
144   static const uintptr_t biased_lock_mask_in_place= biased_lock_mask &lt;&lt; lock_shift;
145   static const uintptr_t biased_lock_bit_in_place = 1 &lt;&lt; biased_lock_shift;
146   static const uintptr_t age_mask                 = right_n_bits(age_bits);
147   static const uintptr_t age_mask_in_place        = age_mask &lt;&lt; age_shift;
148   static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);
149   static const uintptr_t epoch_mask_in_place      = epoch_mask &lt;&lt; epoch_shift;
150 
151   static const uintptr_t hash_mask                = right_n_bits(hash_bits);
152   static const uintptr_t hash_mask_in_place       = hash_mask &lt;&lt; hash_shift;
153 
154   // Alignment of JavaThread pointers encoded in object header required by biased locking
155   static const size_t biased_lock_alignment       = 2 &lt;&lt; (epoch_shift + epoch_bits);
156 
157   static const uintptr_t locked_value             = 0;
158   static const uintptr_t unlocked_value           = 1;
159   static const uintptr_t monitor_value            = 2;
160   static const uintptr_t marked_value             = 3;
161   static const uintptr_t biased_lock_pattern      = 5;
162 
163   static const uintptr_t no_hash                  = 0 ;  // no hash value assigned
164   static const uintptr_t no_hash_in_place         = (address_word)no_hash &lt;&lt; hash_shift;
165   static const uintptr_t no_lock_in_place         = unlocked_value;
166 
167   static const uint max_age                       = age_mask;
168 
169   static const int max_bias_epoch                 = epoch_mask;
170 
171   // Creates a markWord with all bits set to zero.
172   static markWord zero() { return markWord(uintptr_t(0)); }
173 
174   // Biased Locking accessors.
175   // These must be checked by all code which calls into the
176   // ObjectSynchronizer and other code. The biasing is not understood
177   // by the lower-level CAS-based locking code, although the runtime
178   // fixes up biased locks to be compatible with it when a bias is
179   // revoked.
180   bool has_bias_pattern() const {
181     return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);
182   }
183   JavaThread* biased_locker() const {
184     assert(has_bias_pattern(), &quot;should not call this otherwise&quot;);
185     return (JavaThread*) mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place));
186   }
187   // Indicates that the mark has the bias bit set but that it has not
188   // yet been biased toward a particular thread
189   bool is_biased_anonymously() const {
190     return (has_bias_pattern() &amp;&amp; (biased_locker() == NULL));
191   }
192   // Indicates epoch in which this bias was acquired. If the epoch
193   // changes due to too many bias revocations occurring, the biases
194   // from the previous epochs are all considered invalid.
195   int bias_epoch() const {
196     assert(has_bias_pattern(), &quot;should not call this otherwise&quot;);
197     return (mask_bits(value(), epoch_mask_in_place) &gt;&gt; epoch_shift);
198   }
199   markWord set_bias_epoch(int epoch) {
200     assert(has_bias_pattern(), &quot;should not call this otherwise&quot;);
201     assert((epoch &amp; (~epoch_mask)) == 0, &quot;epoch overflow&quot;);
202     return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch &lt;&lt; epoch_shift));
203   }
204   markWord incr_bias_epoch() {
205     return set_bias_epoch((1 + bias_epoch()) &amp; epoch_mask);
206   }
207   // Prototype mark for initialization
208   static markWord biased_locking_prototype() {
209     return markWord( biased_lock_pattern );
210   }
211 
212   // lock accessors (note that these assume lock_shift == 0)
213   bool is_locked()   const {
214     return (mask_bits(value(), lock_mask_in_place) != unlocked_value);
215   }
216   bool is_unlocked() const {
217     return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);
218   }
219   bool is_marked()   const {
220     return (mask_bits(value(), lock_mask_in_place) == marked_value);
221   }
222   bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }
223 
224   // Special temporary state of the markWord while being inflated.
225   // Code that looks at mark outside a lock need to take this into account.
226   bool is_being_inflated() const { return (value() == 0); }
227 
228   // Distinguished markword value - used when inflating over
229   // an existing stacklock.  0 indicates the markword is &quot;BUSY&quot;.
230   // Lockword mutators that use a LD...CAS idiom should always
231   // check for and avoid overwriting a 0 value installed by some
232   // other thread.  (They should spin or block instead.  The 0 value
233   // is transient and *should* be short-lived).
234   static markWord INFLATING() { return zero(); }    // inflate-in-progress
235 
236   // Should this header be preserved during GC?
237   template &lt;typename KlassProxy&gt;
238   inline bool must_be_preserved(KlassProxy klass) const;
239 
240   // Should this header (including its age bits) be preserved in the
241   // case of a promotion failure during scavenge?
242   // Note that we special case this situation. We want to avoid
243   // calling BiasedLocking::preserve_marks()/restore_marks() (which
244   // decrease the number of mark words that need to be preserved
245   // during GC) during each scavenge. During scavenges in which there
246   // is no promotion failure, we actually don&#39;t need to call the above
247   // routines at all, since we don&#39;t mutate and re-initialize the
248   // marks of promoted objects using init_mark(). However, during
249   // scavenges which result in promotion failure, we do re-initialize
250   // the mark words of objects, meaning that we should have called
251   // these mark word preservation routines. Currently there&#39;s no good
252   // place in which to call them in any of the scavengers (although
253   // guarded by appropriate locks we could make one), but the
254   // observation is that promotion failures are quite rare and
255   // reducing the number of mark words preserved during them isn&#39;t a
256   // high priority.
257   template &lt;typename KlassProxy&gt;
258   inline bool must_be_preserved_for_promotion_failure(KlassProxy klass) const;
259 
260   // WARNING: The following routines are used EXCLUSIVELY by
261   // synchronization functions. They are not really gc safe.
262   // They must get updated if markWord layout get changed.
263   markWord set_unlocked() const {
264     return markWord(value() | unlocked_value);
265   }
266   bool has_locker() const {
267     return ((value() &amp; lock_mask_in_place) == locked_value);
268   }
269   BasicLock* locker() const {
270     assert(has_locker(), &quot;check&quot;);
271     return (BasicLock*) value();
272   }
273   bool has_monitor() const {
274     return ((value() &amp; monitor_value) != 0);
275   }
276   ObjectMonitor* monitor() const {
277     assert(has_monitor(), &quot;check&quot;);
278     // Use xor instead of &amp;~ to provide one extra tag-bit check.
279     return (ObjectMonitor*) (value() ^ monitor_value);
280   }
281   bool has_displaced_mark_helper() const {
282     return ((value() &amp; unlocked_value) == 0);
283   }
284   markWord displaced_mark_helper() const {
285     assert(has_displaced_mark_helper(), &quot;check&quot;);
286     uintptr_t ptr = (value() &amp; ~monitor_value);
287     return *(markWord*)ptr;
288   }
289   void set_displaced_mark_helper(markWord m) const {
290     assert(has_displaced_mark_helper(), &quot;check&quot;);
291     uintptr_t ptr = (value() &amp; ~monitor_value);
292     ((markWord*)ptr)-&gt;_value = m._value;
293   }
294   markWord copy_set_hash(intptr_t hash) const {
295     uintptr_t tmp = value() &amp; (~hash_mask_in_place);
296     tmp |= ((hash &amp; hash_mask) &lt;&lt; hash_shift);
297     return markWord(tmp);
298   }
299   // it is only used to be stored into BasicLock as the
300   // indicator that the lock is using heavyweight monitor
301   static markWord unused_mark() {
302     return markWord(marked_value);
303   }
304   // the following two functions create the markWord to be
305   // stored into object header, it encodes monitor info
306   static markWord encode(BasicLock* lock) {
307     return from_pointer(lock);
308   }
309   static markWord encode(ObjectMonitor* monitor) {
310     uintptr_t tmp = (uintptr_t) monitor;
311     return markWord(tmp | monitor_value);
312   }
313   static markWord encode(JavaThread* thread, uint age, int bias_epoch) {
314     uintptr_t tmp = (uintptr_t) thread;
315     assert(UseBiasedLocking &amp;&amp; ((tmp &amp; (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), &quot;misaligned JavaThread pointer&quot;);
316     assert(age &lt;= max_age, &quot;age too large&quot;);
317     assert(bias_epoch &lt;= max_bias_epoch, &quot;bias epoch too large&quot;);
318     return markWord(tmp | (bias_epoch &lt;&lt; epoch_shift) | (age &lt;&lt; age_shift) | biased_lock_pattern);
319   }
320 
321   // used to encode pointers during GC
322   markWord clear_lock_bits() { return markWord(value() &amp; ~lock_mask_in_place); }
323 
324   // age operations
325   markWord set_marked()   { return markWord((value() &amp; ~lock_mask_in_place) | marked_value); }
326   markWord set_unmarked() { return markWord((value() &amp; ~lock_mask_in_place) | unlocked_value); }
327 
328   uint     age()           const { return mask_bits(value() &gt;&gt; age_shift, age_mask); }
329   markWord set_age(uint v) const {
330     assert((v &amp; ~age_mask) == 0, &quot;shouldn&#39;t overflow age field&quot;);
331     return markWord((value() &amp; ~age_mask_in_place) | ((v &amp; age_mask) &lt;&lt; age_shift));
332   }
333   markWord incr_age()      const { return age() == max_age ? markWord(_value) : set_age(age() + 1); }
334 
335   // hash operations
336   intptr_t hash() const {
337     return mask_bits(value() &gt;&gt; hash_shift, hash_mask);
338   }
339 
340   bool has_no_hash() const {
341     return hash() == no_hash;
342   }
343 
344   // Prototype mark for initialization
345   static markWord prototype() {
346     return markWord( no_hash_in_place | no_lock_in_place );
347   }
348 
349   // Helper function for restoration of unmarked mark oops during GC
350   static inline markWord prototype_for_klass(const Klass* klass);
351 
352   // Debugging
353   void print_on(outputStream* st) const;
354 
355   // Prepare address of oop for placement into mark
356   inline static markWord encode_pointer_as_mark(void* p) { return from_pointer(p).set_marked(); }
357 
358   // Recover address of oop from encoded form used in mark
359   inline void* decode_pointer() { if (UseBiasedLocking &amp;&amp; has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }
360 };
361 
362 // Support atomic operations.
363 template&lt;&gt;
364 struct PrimitiveConversions::Translate&lt;markWord&gt; : public TrueType {
365   typedef markWord Value;
366   typedef uintptr_t Decayed;
367 
368   static Decayed decay(const Value&amp; x) { return x.value(); }
369   static Value recover(Decayed x) { return Value(x); }
370 };
371 
372 #endif // SHARE_OOPS_MARKWORD_HPP
    </pre>
  </body>
</html>
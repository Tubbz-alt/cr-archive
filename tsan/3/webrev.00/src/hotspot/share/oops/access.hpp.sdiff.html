<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/access.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/virtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="access.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/access.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 // Some decorators are set at buildtime, such as whether primitives require GC barriers or not, others
 42 // at callsites such as whether an access is in the heap or not, and others are resolved at runtime
 43 // such as GC-specific barriers and encoding/decoding compressed oops. For more information about what
 44 // decorators are available, cf. oops/accessDecorators.hpp.
 45 // By pipelining handling of these decorators, the design of the Access API allows separation of concern
 46 // over the different orthogonal concerns of decorators, while providing a powerful way of
 47 // expressing these orthogonal semantic properties in a unified way.
 48 //
 49 // == OPERATIONS ==
 50 // * load: Load a value from an address.
 51 // * load_at: Load a value from an internal pointer relative to a base object.
 52 // * store: Store a value at an address.
 53 // * store_at: Store a value in an internal pointer relative to a base object.
 54 // * atomic_cmpxchg: Atomically compare-and-swap a new value at an address if previous value matched the compared value.
 55 // * atomic_cmpxchg_at: Atomically compare-and-swap a new value at an internal pointer address if previous value matched the compared value.
 56 // * atomic_xchg: Atomically swap a new value at an address if previous value matched the compared value.
 57 // * atomic_xchg_at: Atomically swap a new value at an internal pointer address if previous value matched the compared value.
 58 // * arraycopy: Copy data from one heap array to another heap array. The ArrayAccess class has convenience functions for this.
 59 // * clone: Clone the contents of an object to a newly allocated object.
 60 // * resolve: Resolve a stable to-space invariant oop that is guaranteed not to relocate its payload until a subsequent thread transition.
<span class="line-removed"> 61 // * equals: Object equality, e.g. when different copies of the same objects are in use (from-space vs. to-space)</span>
 62 //
 63 // == IMPLEMENTATION ==
 64 // Each access goes through the following steps in a template pipeline.
 65 // There are essentially 5 steps for each access:
 66 // * Step 1:   Set default decorators and decay types. This step gets rid of CV qualifiers
 67 //             and sets default decorators to sensible values.
 68 // * Step 2:   Reduce types. This step makes sure there is only a single T type and not
 69 //             multiple types. The P type of the address and T type of the value must
 70 //             match.
 71 // * Step 3:   Pre-runtime dispatch. This step checks whether a runtime call can be
 72 //             avoided, and in that case avoids it (calling raw accesses or
 73 //             primitive accesses in a build that does not require primitive GC barriers)
 74 // * Step 4:   Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 75 //             BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 76 //             to the access.
 77 // * Step 5.a: Barrier resolution. This step is invoked the first time a runtime-dispatch
 78 //             happens for an access. The appropriate BarrierSet::AccessBarrier accessor
 79 //             is resolved, then the function pointer is updated to that accessor for
 80 //             future invocations.
 81 // * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
</pre>
<hr />
<pre>
149                       AS_DECORATOR_MASK | IS_ARRAY&gt;();
150     AccessInternal::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
151                                           dst_obj, dst_offset_in_bytes, dst_raw,
152                                           length);
153   }
154 
155 public:
156   // Primitive heap accesses
157   static inline AccessInternal::LoadAtProxy&lt;decorators&gt; load_at(oop base, ptrdiff_t offset) {
158     verify_primitive_decorators&lt;load_mo_decorators&gt;();
159     return AccessInternal::LoadAtProxy&lt;decorators&gt;(base, offset);
160   }
161 
162   template &lt;typename T&gt;
163   static inline void store_at(oop base, ptrdiff_t offset, T value) {
164     verify_primitive_decorators&lt;store_mo_decorators&gt;();
165     AccessInternal::store_at&lt;decorators&gt;(base, offset, value);
166   }
167 
168   template &lt;typename T&gt;
<span class="line-modified">169   static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
170     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<span class="line-modified">171     return AccessInternal::atomic_cmpxchg_at&lt;decorators&gt;(new_value, base, offset, compare_value);</span>
172   }
173 
174   template &lt;typename T&gt;
<span class="line-modified">175   static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
176     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<span class="line-modified">177     return AccessInternal::atomic_xchg_at&lt;decorators&gt;(new_value, base, offset);</span>
178   }
179 
180   // Oop heap accesses
181   static inline AccessInternal::OopLoadAtProxy&lt;decorators&gt; oop_load_at(oop base, ptrdiff_t offset) {
182     verify_heap_oop_decorators&lt;load_mo_decorators&gt;();
183     return AccessInternal::OopLoadAtProxy&lt;decorators&gt;(base, offset);
184   }
185 
186   template &lt;typename T&gt;
187   static inline void oop_store_at(oop base, ptrdiff_t offset, T value) {
188     verify_heap_oop_decorators&lt;store_mo_decorators&gt;();
189     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
190     OopType oop_value = value;
191     AccessInternal::store_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, oop_value);
192   }
193 
194   template &lt;typename T&gt;
<span class="line-modified">195   static inline T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
196     verify_heap_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
197     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
198     OopType new_oop_value = new_value;
199     OopType compare_oop_value = compare_value;
<span class="line-modified">200     return AccessInternal::atomic_cmpxchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, base, offset, compare_oop_value);</span>
201   }
202 
203   template &lt;typename T&gt;
<span class="line-modified">204   static inline T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
205     verify_heap_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
206     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
207     OopType new_oop_value = new_value;
<span class="line-modified">208     return AccessInternal::atomic_xchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, base, offset);</span>
209   }
210 
211   // Clone an object from src to dst
212   static inline void clone(oop src, oop dst, size_t size) {
213     verify_decorators&lt;IN_HEAP&gt;();
214     AccessInternal::clone&lt;decorators&gt;(src, dst, size);
215   }
216 
217   // Primitive accesses
218   template &lt;typename P&gt;
219   static inline P load(P* addr) {
220     verify_primitive_decorators&lt;load_mo_decorators&gt;();
221     return AccessInternal::load&lt;decorators, P, P&gt;(addr);
222   }
223 
224   template &lt;typename P, typename T&gt;
225   static inline void store(P* addr, T value) {
226     verify_primitive_decorators&lt;store_mo_decorators&gt;();
227     AccessInternal::store&lt;decorators&gt;(addr, value);
228   }
229 
230   template &lt;typename P, typename T&gt;
<span class="line-modified">231   static inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
232     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<span class="line-modified">233     return AccessInternal::atomic_cmpxchg&lt;decorators&gt;(new_value, addr, compare_value);</span>
234   }
235 
236   template &lt;typename P, typename T&gt;
<span class="line-modified">237   static inline T atomic_xchg(T new_value, P* addr) {</span>
238     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<span class="line-modified">239     return AccessInternal::atomic_xchg&lt;decorators&gt;(new_value, addr);</span>
240   }
241 
242   // Oop accesses
243   template &lt;typename P&gt;
244   static inline AccessInternal::OopLoadProxy&lt;P, decorators&gt; oop_load(P* addr) {
245     verify_oop_decorators&lt;load_mo_decorators&gt;();
246     return AccessInternal::OopLoadProxy&lt;P, decorators&gt;(addr);
247   }
248 
249   template &lt;typename P, typename T&gt;
250   static inline void oop_store(P* addr, T value) {
251     verify_oop_decorators&lt;store_mo_decorators&gt;();
252     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
253     OopType oop_value = value;
254     AccessInternal::store&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(addr, oop_value);
255   }
256 
257   template &lt;typename P, typename T&gt;
<span class="line-modified">258   static inline T oop_atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
259     verify_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
260     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
261     OopType new_oop_value = new_value;
262     OopType compare_oop_value = compare_value;
<span class="line-modified">263     return AccessInternal::atomic_cmpxchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, addr, compare_oop_value);</span>
264   }
265 
266   template &lt;typename P, typename T&gt;
<span class="line-modified">267   static inline T oop_atomic_xchg(T new_value, P* addr) {</span>
268     verify_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
269     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
270     OopType new_oop_value = new_value;
<span class="line-modified">271     return AccessInternal::atomic_xchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, addr);</span>
272   }
273 
274   static oop resolve(oop obj) {
275     verify_decorators&lt;DECORATORS_NONE&gt;();
276     return AccessInternal::resolve&lt;decorators&gt;(obj);
277   }
<span class="line-removed">278 </span>
<span class="line-removed">279   static bool equals(oop o1, oop o2) {</span>
<span class="line-removed">280     verify_decorators&lt;AS_RAW&gt;();</span>
<span class="line-removed">281     return AccessInternal::equals&lt;decorators&gt;(o1, o2);</span>
<span class="line-removed">282   }</span>
283 };
284 
285 // Helper for performing raw accesses (knows only of memory ordering
286 // atomicity decorators as well as compressed oops)
287 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
288 class RawAccess: public Access&lt;AS_RAW | decorators&gt; {};
289 
290 // Helper for performing normal accesses on the heap. These accesses
291 // may resolve an accessor on a GC barrier set
292 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
293 class HeapAccess: public Access&lt;IN_HEAP | decorators&gt; {};
294 
295 // Helper for performing normal accesses in roots. These accesses
296 // may resolve an accessor on a GC barrier set
297 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
298 class NativeAccess: public Access&lt;IN_NATIVE | decorators&gt; {};
299 
300 // Helper for array access.
301 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
302 class ArrayAccess: public HeapAccess&lt;IS_ARRAY | decorators&gt; {
</pre>
</td>
<td>
<hr />
<pre>
 41 // Some decorators are set at buildtime, such as whether primitives require GC barriers or not, others
 42 // at callsites such as whether an access is in the heap or not, and others are resolved at runtime
 43 // such as GC-specific barriers and encoding/decoding compressed oops. For more information about what
 44 // decorators are available, cf. oops/accessDecorators.hpp.
 45 // By pipelining handling of these decorators, the design of the Access API allows separation of concern
 46 // over the different orthogonal concerns of decorators, while providing a powerful way of
 47 // expressing these orthogonal semantic properties in a unified way.
 48 //
 49 // == OPERATIONS ==
 50 // * load: Load a value from an address.
 51 // * load_at: Load a value from an internal pointer relative to a base object.
 52 // * store: Store a value at an address.
 53 // * store_at: Store a value in an internal pointer relative to a base object.
 54 // * atomic_cmpxchg: Atomically compare-and-swap a new value at an address if previous value matched the compared value.
 55 // * atomic_cmpxchg_at: Atomically compare-and-swap a new value at an internal pointer address if previous value matched the compared value.
 56 // * atomic_xchg: Atomically swap a new value at an address if previous value matched the compared value.
 57 // * atomic_xchg_at: Atomically swap a new value at an internal pointer address if previous value matched the compared value.
 58 // * arraycopy: Copy data from one heap array to another heap array. The ArrayAccess class has convenience functions for this.
 59 // * clone: Clone the contents of an object to a newly allocated object.
 60 // * resolve: Resolve a stable to-space invariant oop that is guaranteed not to relocate its payload until a subsequent thread transition.

 61 //
 62 // == IMPLEMENTATION ==
 63 // Each access goes through the following steps in a template pipeline.
 64 // There are essentially 5 steps for each access:
 65 // * Step 1:   Set default decorators and decay types. This step gets rid of CV qualifiers
 66 //             and sets default decorators to sensible values.
 67 // * Step 2:   Reduce types. This step makes sure there is only a single T type and not
 68 //             multiple types. The P type of the address and T type of the value must
 69 //             match.
 70 // * Step 3:   Pre-runtime dispatch. This step checks whether a runtime call can be
 71 //             avoided, and in that case avoids it (calling raw accesses or
 72 //             primitive accesses in a build that does not require primitive GC barriers)
 73 // * Step 4:   Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 74 //             BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 75 //             to the access.
 76 // * Step 5.a: Barrier resolution. This step is invoked the first time a runtime-dispatch
 77 //             happens for an access. The appropriate BarrierSet::AccessBarrier accessor
 78 //             is resolved, then the function pointer is updated to that accessor for
 79 //             future invocations.
 80 // * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
</pre>
<hr />
<pre>
148                       AS_DECORATOR_MASK | IS_ARRAY&gt;();
149     AccessInternal::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
150                                           dst_obj, dst_offset_in_bytes, dst_raw,
151                                           length);
152   }
153 
154 public:
155   // Primitive heap accesses
156   static inline AccessInternal::LoadAtProxy&lt;decorators&gt; load_at(oop base, ptrdiff_t offset) {
157     verify_primitive_decorators&lt;load_mo_decorators&gt;();
158     return AccessInternal::LoadAtProxy&lt;decorators&gt;(base, offset);
159   }
160 
161   template &lt;typename T&gt;
162   static inline void store_at(oop base, ptrdiff_t offset, T value) {
163     verify_primitive_decorators&lt;store_mo_decorators&gt;();
164     AccessInternal::store_at&lt;decorators&gt;(base, offset, value);
165   }
166 
167   template &lt;typename T&gt;
<span class="line-modified">168   static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
169     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<span class="line-modified">170     return AccessInternal::atomic_cmpxchg_at&lt;decorators&gt;(base, offset, compare_value, new_value);</span>
171   }
172 
173   template &lt;typename T&gt;
<span class="line-modified">174   static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
175     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<span class="line-modified">176     return AccessInternal::atomic_xchg_at&lt;decorators&gt;(base, offset, new_value);</span>
177   }
178 
179   // Oop heap accesses
180   static inline AccessInternal::OopLoadAtProxy&lt;decorators&gt; oop_load_at(oop base, ptrdiff_t offset) {
181     verify_heap_oop_decorators&lt;load_mo_decorators&gt;();
182     return AccessInternal::OopLoadAtProxy&lt;decorators&gt;(base, offset);
183   }
184 
185   template &lt;typename T&gt;
186   static inline void oop_store_at(oop base, ptrdiff_t offset, T value) {
187     verify_heap_oop_decorators&lt;store_mo_decorators&gt;();
188     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
189     OopType oop_value = value;
190     AccessInternal::store_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, oop_value);
191   }
192 
193   template &lt;typename T&gt;
<span class="line-modified">194   static inline T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
195     verify_heap_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
196     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
197     OopType new_oop_value = new_value;
198     OopType compare_oop_value = compare_value;
<span class="line-modified">199     return AccessInternal::atomic_cmpxchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, compare_oop_value, new_oop_value);</span>
200   }
201 
202   template &lt;typename T&gt;
<span class="line-modified">203   static inline T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
204     verify_heap_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
205     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
206     OopType new_oop_value = new_value;
<span class="line-modified">207     return AccessInternal::atomic_xchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, new_oop_value);</span>
208   }
209 
210   // Clone an object from src to dst
211   static inline void clone(oop src, oop dst, size_t size) {
212     verify_decorators&lt;IN_HEAP&gt;();
213     AccessInternal::clone&lt;decorators&gt;(src, dst, size);
214   }
215 
216   // Primitive accesses
217   template &lt;typename P&gt;
218   static inline P load(P* addr) {
219     verify_primitive_decorators&lt;load_mo_decorators&gt;();
220     return AccessInternal::load&lt;decorators, P, P&gt;(addr);
221   }
222 
223   template &lt;typename P, typename T&gt;
224   static inline void store(P* addr, T value) {
225     verify_primitive_decorators&lt;store_mo_decorators&gt;();
226     AccessInternal::store&lt;decorators&gt;(addr, value);
227   }
228 
229   template &lt;typename P, typename T&gt;
<span class="line-modified">230   static inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {</span>
231     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<span class="line-modified">232     return AccessInternal::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);</span>
233   }
234 
235   template &lt;typename P, typename T&gt;
<span class="line-modified">236   static inline T atomic_xchg(P* addr, T new_value) {</span>
237     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<span class="line-modified">238     return AccessInternal::atomic_xchg&lt;decorators&gt;(addr, new_value);</span>
239   }
240 
241   // Oop accesses
242   template &lt;typename P&gt;
243   static inline AccessInternal::OopLoadProxy&lt;P, decorators&gt; oop_load(P* addr) {
244     verify_oop_decorators&lt;load_mo_decorators&gt;();
245     return AccessInternal::OopLoadProxy&lt;P, decorators&gt;(addr);
246   }
247 
248   template &lt;typename P, typename T&gt;
249   static inline void oop_store(P* addr, T value) {
250     verify_oop_decorators&lt;store_mo_decorators&gt;();
251     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
252     OopType oop_value = value;
253     AccessInternal::store&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(addr, oop_value);
254   }
255 
256   template &lt;typename P, typename T&gt;
<span class="line-modified">257   static inline T oop_atomic_cmpxchg(P* addr, T compare_value, T new_value) {</span>
258     verify_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
259     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
260     OopType new_oop_value = new_value;
261     OopType compare_oop_value = compare_value;
<span class="line-modified">262     return AccessInternal::atomic_cmpxchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(addr, compare_oop_value, new_oop_value);</span>
263   }
264 
265   template &lt;typename P, typename T&gt;
<span class="line-modified">266   static inline T oop_atomic_xchg(P* addr, T new_value) {</span>
267     verify_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
268     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
269     OopType new_oop_value = new_value;
<span class="line-modified">270     return AccessInternal::atomic_xchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(addr, new_oop_value);</span>
271   }
272 
273   static oop resolve(oop obj) {
274     verify_decorators&lt;DECORATORS_NONE&gt;();
275     return AccessInternal::resolve&lt;decorators&gt;(obj);
276   }





277 };
278 
279 // Helper for performing raw accesses (knows only of memory ordering
280 // atomicity decorators as well as compressed oops)
281 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
282 class RawAccess: public Access&lt;AS_RAW | decorators&gt; {};
283 
284 // Helper for performing normal accesses on the heap. These accesses
285 // may resolve an accessor on a GC barrier set
286 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
287 class HeapAccess: public Access&lt;IN_HEAP | decorators&gt; {};
288 
289 // Helper for performing normal accesses in roots. These accesses
290 // may resolve an accessor on a GC barrier set
291 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
292 class NativeAccess: public Access&lt;IN_NATIVE | decorators&gt; {};
293 
294 // Helper for array access.
295 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
296 class ArrayAccess: public HeapAccess&lt;IS_ARRAY | decorators&gt; {
</pre>
</td>
</tr>
</table>
<center><a href="../memory/virtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="access.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
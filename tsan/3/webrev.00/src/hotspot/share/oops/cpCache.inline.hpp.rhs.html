<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/cpCache.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CPCACHE_INLINE_HPP
 26 #define SHARE_OOPS_CPCACHE_INLINE_HPP
 27 
 28 #include &quot;oops/cpCache.hpp&quot;
 29 #include &quot;oops/oopHandle.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;runtime/atomic.hpp&quot;</span>
 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32 inline int ConstantPoolCacheEntry::indices_ord() const { return Atomic::load_acquire(&amp;_indices); }</span>
 33 
 34 inline Bytecodes::Code ConstantPoolCacheEntry::bytecode_1() const {
 35   return Bytecodes::cast((indices_ord() &gt;&gt; bytecode_1_shift) &amp; bytecode_1_mask);
 36 }
 37 
 38 inline Bytecodes::Code ConstantPoolCacheEntry::bytecode_2() const {
 39   return Bytecodes::cast((indices_ord() &gt;&gt; bytecode_2_shift) &amp; bytecode_2_mask);
 40 }
 41 
 42 // Has this bytecode been resolved? Only valid for invokes and get/put field/static.
 43 inline bool ConstantPoolCacheEntry::is_resolved(Bytecodes::Code code) const {
 44   switch (bytecode_number(code)) {
 45     case 1:  return (bytecode_1() == code);
 46     case 2:  return (bytecode_2() == code);
 47   }
 48   return false;      // default: not resolved
 49 }
 50 
 51 inline Method* ConstantPoolCacheEntry::f2_as_interface_method() const {
 52   assert(bytecode_1() == Bytecodes::_invokeinterface, &quot;&quot;);
 53   return (Method*)_f2;
 54 }
 55 
<a name="3" id="anc3"></a><span class="line-modified"> 56 inline Metadata* ConstantPoolCacheEntry::f1_ord() const { return (Metadata *)Atomic::load_acquire(&amp;_f1); }</span>
 57 
 58 inline Method* ConstantPoolCacheEntry::f1_as_method() const {
 59   Metadata* f1 = f1_ord(); assert(f1 == NULL || f1-&gt;is_method(), &quot;&quot;);
 60   return (Method*)f1;
 61 }
 62 
 63 inline Klass* ConstantPoolCacheEntry::f1_as_klass() const {
 64   Metadata* f1 = f1_ord(); assert(f1 == NULL || f1-&gt;is_klass(), &quot;&quot;);
 65   return (Klass*)f1;
 66 }
 67 
 68 inline bool ConstantPoolCacheEntry::is_f1_null() const { Metadata* f1 = f1_ord(); return f1 == NULL; }
 69 
 70 inline bool ConstantPoolCacheEntry::has_appendix() const {
 71   return (!is_f1_null()) &amp;&amp; (_flags &amp; (1 &lt;&lt; has_appendix_shift)) != 0;
 72 }
 73 
 74 inline bool ConstantPoolCacheEntry::has_local_signature() const {
 75   return (!is_f1_null()) &amp;&amp; (_flags &amp; (1 &lt;&lt; has_local_signature_shift)) != 0;
 76 }
 77 
<a name="4" id="anc4"></a><span class="line-modified"> 78 inline intx ConstantPoolCacheEntry::flags_ord() const   { return (intx)Atomic::load_acquire(&amp;_flags); }</span>
 79 
 80 inline bool ConstantPoolCacheEntry::indy_resolution_failed() const {
 81   intx flags = flags_ord();
 82   return (flags &amp; (1 &lt;&lt; indy_resolution_failed_shift)) != 0;
 83 }
 84 
 85 // Constructor
 86 inline ConstantPoolCache::ConstantPoolCache(int length,
 87                                             const intStack&amp; inverse_index_map,
 88                                             const intStack&amp; invokedynamic_inverse_index_map,
 89                                             const intStack&amp; invokedynamic_references_map) :
 90                                                   _length(length),
 91                                                   _constant_pool(NULL) {
 92   CDS_JAVA_HEAP_ONLY(_archived_references = 0;)
 93   initialize(inverse_index_map, invokedynamic_inverse_index_map,
 94              invokedynamic_references_map);
 95   for (int i = 0; i &lt; length; i++) {
 96     assert(entry_at(i)-&gt;is_f1_null(), &quot;Failed to clear?&quot;);
 97   }
 98 }
 99 
100 inline oop ConstantPoolCache::resolved_references() { return _resolved_references.resolve(); }
101 
102 #endif // SHARE_OOPS_CPCACHE_INLINE_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
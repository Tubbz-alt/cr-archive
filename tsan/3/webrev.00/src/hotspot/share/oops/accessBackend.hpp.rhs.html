<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  41 #include &quot;runtime/globals.hpp&quot;</span>
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 
  55 namespace AccessInternal {
  56   enum BarrierType {
  57     BARRIER_STORE,
  58     BARRIER_STORE_AT,
  59     BARRIER_LOAD,
  60     BARRIER_LOAD_AT,
  61     BARRIER_ATOMIC_CMPXCHG,
  62     BARRIER_ATOMIC_CMPXCHG_AT,
  63     BARRIER_ATOMIC_XCHG,
  64     BARRIER_ATOMIC_XCHG_AT,
  65     BARRIER_ARRAYCOPY,
  66     BARRIER_CLONE,
<a name="2" id="anc2"></a><span class="line-modified">  67     BARRIER_RESOLVE</span>

  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
  87   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  88     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  89              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  90   }
  91 
  92   // This metafunction returns whether it is possible for a type T to require
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<a name="3" id="anc3"></a><span class="line-modified"> 105     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
<span class="line-modified"> 106     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);</span>
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
<a name="4" id="anc4"></a><span class="line-modified"> 110     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);</span>
<span class="line-modified"> 111     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);</span>
 112 
 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
 117     typedef oop (*resolve_func_t)(oop obj);
<a name="5" id="anc5"></a>
 118   };
 119 
 120   template &lt;DecoratorSet decorators&gt;
 121   struct AccessFunctionTypes&lt;decorators, void&gt; {
 122     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 124                                      size_t length);
 125   };
 126 
 127   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 128 
 129 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 130   template &lt;DecoratorSet decorators, typename T&gt;                    \
 131   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 132     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 133   }
 134   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
<a name="6" id="anc6"></a>
 145 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 146 
 147   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 148   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 149 
 150   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 151   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 152 
 153   class AccessLocker {
 154   public:
 155     AccessLocker();
 156     ~AccessLocker();
 157   };
 158   bool wide_atomic_needs_locking();
 159 
 160   void* field_addr(oop base, ptrdiff_t offset);
 161 
 162   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 163   // faster build times, given how frequently included access is.
 164   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
 165   void arraycopy_conjoint_oops(oop* src, oop* dst, size_t length);
 166   void arraycopy_conjoint_oops(narrowOop* src, narrowOop* dst, size_t length);
 167 
 168   void arraycopy_disjoint_words(void* src, void* dst, size_t length);
 169   void arraycopy_disjoint_words_atomic(void* src, void* dst, size_t length);
 170 
 171   template&lt;typename T&gt;
 172   void arraycopy_conjoint(T* src, T* dst, size_t length);
 173   template&lt;typename T&gt;
 174   void arraycopy_arrayof_conjoint(T* src, T* dst, size_t length);
 175   template&lt;typename T&gt;
 176   void arraycopy_conjoint_atomic(T* src, T* dst, size_t length);
 177 }
 178 
 179 // This mask specifies what decorators are relevant for raw accesses. When passing
 180 // accesses to the raw layer, irrelevant decorators are removed.
 181 const DecoratorSet RAW_DECORATOR_MASK = INTERNAL_DECORATOR_MASK | MO_DECORATOR_MASK |
 182                                         ARRAYCOPY_DECORATOR_MASK | IS_NOT_NULL;
 183 
 184 // The RawAccessBarrier performs raw accesses with additional knowledge of
 185 // memory ordering, so that OrderAccess/Atomic is called when necessary.
 186 // It additionally handles compressed oops, and hence is not completely &quot;raw&quot;
 187 // strictly speaking.
 188 template &lt;DecoratorSet decorators&gt;
 189 class RawAccessBarrier: public AllStatic {
 190 protected:
 191   static inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 192     return AccessInternal::field_addr(base, byte_offset);
 193   }
 194 
 195 protected:
 196   // Only encode if INTERNAL_VALUE_IS_OOP
 197   template &lt;DecoratorSet idecorators, typename T&gt;
 198   static inline typename EnableIf&lt;
 199     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 200     typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 201   encode_internal(T value);
 202 
 203   template &lt;DecoratorSet idecorators, typename T&gt;
 204   static inline typename EnableIf&lt;
 205     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 206   encode_internal(T value) {
 207     return value;
 208   }
 209 
 210   template &lt;typename T&gt;
 211   static inline typename AccessInternal::EncodedType&lt;decorators, T&gt;::type
 212   encode(T value) {
 213     return encode_internal&lt;decorators, T&gt;(value);
 214   }
 215 
 216   // Only decode if INTERNAL_VALUE_IS_OOP
 217   template &lt;DecoratorSet idecorators, typename T&gt;
 218   static inline typename EnableIf&lt;
 219     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 220   decode_internal(typename HeapOopType&lt;idecorators&gt;::type value);
 221 
 222   template &lt;DecoratorSet idecorators, typename T&gt;
 223   static inline typename EnableIf&lt;
 224     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 225   decode_internal(T value) {
 226     return value;
 227   }
 228 
 229   template &lt;typename T&gt;
 230   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 231     return decode_internal&lt;decorators, T&gt;(value);
 232   }
 233 
 234 protected:
 235   template &lt;DecoratorSet ds, typename T&gt;
 236   static typename EnableIf&lt;
 237     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 238   load_internal(void* addr);
 239 
 240   template &lt;DecoratorSet ds, typename T&gt;
 241   static typename EnableIf&lt;
 242     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 243   load_internal(void* addr);
 244 
 245   template &lt;DecoratorSet ds, typename T&gt;
 246   static typename EnableIf&lt;
 247     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 248   load_internal(void* addr);
 249 
 250   template &lt;DecoratorSet ds, typename T&gt;
 251   static inline typename EnableIf&lt;
 252     HasDecorator&lt;ds, MO_VOLATILE&gt;::value, T&gt;::type
 253   load_internal(void* addr) {
 254     return *reinterpret_cast&lt;const volatile T*&gt;(addr);
 255   }
 256 
 257   template &lt;DecoratorSet ds, typename T&gt;
 258   static inline typename EnableIf&lt;
 259     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 260   load_internal(void* addr) {
 261     return *reinterpret_cast&lt;T*&gt;(addr);
 262   }
 263 
 264   template &lt;DecoratorSet ds, typename T&gt;
 265   static typename EnableIf&lt;
 266     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 267   store_internal(void* addr, T value);
 268 
 269   template &lt;DecoratorSet ds, typename T&gt;
 270   static typename EnableIf&lt;
 271     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 272   store_internal(void* addr, T value);
 273 
 274   template &lt;DecoratorSet ds, typename T&gt;
 275   static typename EnableIf&lt;
 276     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 277   store_internal(void* addr, T value);
 278 
 279   template &lt;DecoratorSet ds, typename T&gt;
 280   static inline typename EnableIf&lt;
 281     HasDecorator&lt;ds, MO_VOLATILE&gt;::value&gt;::type
 282   store_internal(void* addr, T value) {
 283     (void)const_cast&lt;T&amp;&gt;(*reinterpret_cast&lt;volatile T*&gt;(addr) = value);
 284   }
 285 
 286   template &lt;DecoratorSet ds, typename T&gt;
 287   static inline typename EnableIf&lt;
 288     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 289   store_internal(void* addr, T value) {
 290     *reinterpret_cast&lt;T*&gt;(addr) = value;
 291   }
 292 
 293   template &lt;DecoratorSet ds, typename T&gt;
 294   static typename EnableIf&lt;
 295     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<a name="7" id="anc7"></a><span class="line-modified"> 296   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
 297 
 298   template &lt;DecoratorSet ds, typename T&gt;
 299   static typename EnableIf&lt;
 300     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<a name="8" id="anc8"></a><span class="line-modified"> 301   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
 302 
 303   template &lt;DecoratorSet ds, typename T&gt;
 304   static typename EnableIf&lt;
 305     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<a name="9" id="anc9"></a><span class="line-modified"> 306   atomic_xchg_internal(void* addr, T new_value);</span>
 307 
 308   // The following *_locked mechanisms serve the purpose of handling atomic operations
 309   // that are larger than a machine can handle, and then possibly opt for using
 310   // a slower path using a mutex to perform the operation.
 311 
 312   template &lt;DecoratorSet ds, typename T&gt;
 313   static inline typename EnableIf&lt;
 314     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="10" id="anc10"></a><span class="line-modified"> 315   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 316     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);</span>
 317   }
 318 
 319   template &lt;DecoratorSet ds, typename T&gt;
 320   static typename EnableIf&lt;
 321     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="11" id="anc11"></a><span class="line-modified"> 322   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);</span>
 323 
 324   template &lt;DecoratorSet ds, typename T&gt;
 325   static inline typename EnableIf&lt;
 326     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="12" id="anc12"></a><span class="line-modified"> 327   atomic_xchg_maybe_locked(void* addr, T new_value) {</span>
<span class="line-modified"> 328     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);</span>
 329   }
 330 
 331   template &lt;DecoratorSet ds, typename T&gt;
 332   static typename EnableIf&lt;
 333     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<a name="13" id="anc13"></a><span class="line-modified"> 334   atomic_xchg_maybe_locked(void* addr, T new_value);</span>
 335 
 336 public:
 337   template &lt;typename T&gt;
 338   static inline void store(void* addr, T value) {
 339     store_internal&lt;decorators&gt;(addr, value);
 340   }
 341 
 342   template &lt;typename T&gt;
 343   static inline T load(void* addr) {
 344     return load_internal&lt;decorators, T&gt;(addr);
 345   }
 346 
 347   template &lt;typename T&gt;
<a name="14" id="anc14"></a><span class="line-modified"> 348   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 349     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);</span>
 350   }
 351 
 352   template &lt;typename T&gt;
<a name="15" id="anc15"></a><span class="line-modified"> 353   static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified"> 354     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);</span>
 355   }
 356 
 357   template &lt;typename T&gt;
 358   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 359                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 360                         size_t length);
 361 
 362   template &lt;typename T&gt;
 363   static void oop_store(void* addr, T value);
 364   template &lt;typename T&gt;
 365   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 366 
 367   template &lt;typename T&gt;
 368   static T oop_load(void* addr);
 369   template &lt;typename T&gt;
 370   static T oop_load_at(oop base, ptrdiff_t offset);
 371 
 372   template &lt;typename T&gt;
<a name="16" id="anc16"></a><span class="line-modified"> 373   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);</span>
 374   template &lt;typename T&gt;
<a name="17" id="anc17"></a><span class="line-modified"> 375   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
 376 
 377   template &lt;typename T&gt;
<a name="18" id="anc18"></a><span class="line-modified"> 378   static T oop_atomic_xchg(void* addr, T new_value);</span>
 379   template &lt;typename T&gt;
<a name="19" id="anc19"></a><span class="line-modified"> 380   static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);</span>
 381 
 382   template &lt;typename T&gt;
 383   static void store_at(oop base, ptrdiff_t offset, T value) {
 384     store(field_addr(base, offset), value);
 385   }
 386 
 387   template &lt;typename T&gt;
 388   static T load_at(oop base, ptrdiff_t offset) {
 389     return load&lt;T&gt;(field_addr(base, offset));
 390   }
 391 
 392   template &lt;typename T&gt;
<a name="20" id="anc20"></a><span class="line-modified"> 393   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 394     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);</span>
 395   }
 396 
 397   template &lt;typename T&gt;
<a name="21" id="anc21"></a><span class="line-modified"> 398   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 399     return atomic_xchg(field_addr(base, offset), new_value);</span>
 400   }
 401 
 402   template &lt;typename T&gt;
 403   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 404                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 405                             size_t length);
 406 
 407   static void clone(oop src, oop dst, size_t size);
 408 
 409   static oop resolve(oop obj) { return obj; }
<a name="22" id="anc22"></a>

 410 };
 411 
 412 // Below is the implementation of the first 4 steps of the template pipeline:
 413 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 414 //           and sets default decorators to sensible values.
 415 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 416 //           multiple types. The P type of the address and T type of the value must
 417 //           match.
 418 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 419 //           avoided, and in that case avoids it (calling raw accesses or
 420 //           primitive accesses in a build that does not require primitive GC barriers)
 421 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 422 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 423 //           to the access.
 424 
 425 namespace AccessInternal {
 426   template &lt;typename T&gt;
 427   struct OopOrNarrowOopInternal: AllStatic {
 428     typedef oop type;
 429   };
 430 
 431   template &lt;&gt;
 432   struct OopOrNarrowOopInternal&lt;narrowOop&gt;: AllStatic {
 433     typedef narrowOop type;
 434   };
 435 
 436   // This metafunction returns a canonicalized oop/narrowOop type for a passed
 437   // in oop-like types passed in from oop_* overloads where the user has sworn
 438   // that the passed in values should be oop-like (e.g. oop, oopDesc*, arrayOop,
 439   // narrowOoop, instanceOopDesc*, and random other things).
 440   // In the oop_* overloads, it must hold that if the passed in type T is not
 441   // narrowOop, then it by contract has to be one of many oop-like types implicitly
 442   // convertible to oop, and hence returns oop as the canonical oop type.
 443   // If it turns out it was not, then the implicit conversion to oop will fail
 444   // to compile, as desired.
 445   template &lt;typename T&gt;
 446   struct OopOrNarrowOop: AllStatic {
 447     typedef typename OopOrNarrowOopInternal&lt;typename Decay&lt;T&gt;::type&gt;::type type;
 448   };
 449 
 450   inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 451     return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
 452   }
 453   // Step 4: Runtime dispatch
 454   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
 455   // accessor. This is required when the access either depends on whether compressed oops
 456   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
 457   // barriers). The way it works is that a function pointer initially pointing to an
 458   // accessor resolution function gets called for each access. Upon first invocation,
 459   // it resolves which accessor to be used in future invocations and patches the
 460   // function pointer to this new accessor.
 461 
 462   template &lt;DecoratorSet decorators, typename T, BarrierType type&gt;
 463   struct RuntimeDispatch: AllStatic {};
 464 
 465   template &lt;DecoratorSet decorators, typename T&gt;
 466   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;: AllStatic {
 467     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type func_t;
 468     static func_t _store_func;
 469 
 470     static void store_init(void* addr, T value);
 471 
 472     static inline void store(void* addr, T value) {
 473       _store_func(addr, value);
 474     }
 475   };
 476 
 477   template &lt;DecoratorSet decorators, typename T&gt;
 478   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;: AllStatic {
 479     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type func_t;
 480     static func_t _store_at_func;
 481 
 482     static void store_at_init(oop base, ptrdiff_t offset, T value);
 483 
 484     static inline void store_at(oop base, ptrdiff_t offset, T value) {
 485       _store_at_func(base, offset, value);
 486     }
 487   };
 488 
 489   template &lt;DecoratorSet decorators, typename T&gt;
 490   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;: AllStatic {
 491     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type func_t;
 492     static func_t _load_func;
 493 
 494     static T load_init(void* addr);
 495 
 496     static inline T load(void* addr) {
 497       return _load_func(addr);
 498     }
 499   };
 500 
 501   template &lt;DecoratorSet decorators, typename T&gt;
 502   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 503     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 504     static func_t _load_at_func;
 505 
 506     static T load_at_init(oop base, ptrdiff_t offset);
 507 
 508     static inline T load_at(oop base, ptrdiff_t offset) {
 509       return _load_at_func(base, offset);
 510     }
 511   };
 512 
 513   template &lt;DecoratorSet decorators, typename T&gt;
 514   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 515     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 516     static func_t _atomic_cmpxchg_func;
 517 
<a name="23" id="anc23"></a><span class="line-modified"> 518     static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);</span>
 519 
<a name="24" id="anc24"></a><span class="line-modified"> 520     static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 521       return _atomic_cmpxchg_func(addr, compare_value, new_value);</span>
 522     }
 523   };
 524 
 525   template &lt;DecoratorSet decorators, typename T&gt;
 526   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 527     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 528     static func_t _atomic_cmpxchg_at_func;
 529 
<a name="25" id="anc25"></a><span class="line-modified"> 530     static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
 531 
<a name="26" id="anc26"></a><span class="line-modified"> 532     static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 533       return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);</span>
 534     }
 535   };
 536 
 537   template &lt;DecoratorSet decorators, typename T&gt;
 538   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 539     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 540     static func_t _atomic_xchg_func;
 541 
<a name="27" id="anc27"></a><span class="line-modified"> 542     static T atomic_xchg_init(void* addr, T new_value);</span>
 543 
<a name="28" id="anc28"></a><span class="line-modified"> 544     static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified"> 545       return _atomic_xchg_func(addr, new_value);</span>
 546     }
 547   };
 548 
 549   template &lt;DecoratorSet decorators, typename T&gt;
 550   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 551     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 552     static func_t _atomic_xchg_at_func;
 553 
<a name="29" id="anc29"></a><span class="line-modified"> 554     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);</span>
 555 
<a name="30" id="anc30"></a><span class="line-modified"> 556     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 557       return _atomic_xchg_at_func(base, offset, new_value);</span>
 558     }
 559   };
 560 
 561   template &lt;DecoratorSet decorators, typename T&gt;
 562   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 563     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 564     static func_t _arraycopy_func;
 565 
 566     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 567                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 568                                size_t length);
 569 
 570     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 571                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 572                                  size_t length) {
 573       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 574                              dst_obj, dst_offset_in_bytes, dst_raw,
 575                              length);
 576     }
 577   };
 578 
 579   template &lt;DecoratorSet decorators, typename T&gt;
 580   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 581     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 582     static func_t _clone_func;
 583 
 584     static void clone_init(oop src, oop dst, size_t size);
 585 
 586     static inline void clone(oop src, oop dst, size_t size) {
 587       _clone_func(src, dst, size);
 588     }
 589   };
 590 
 591   template &lt;DecoratorSet decorators, typename T&gt;
 592   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 593     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 594     static func_t _resolve_func;
 595 
 596     static oop resolve_init(oop obj);
 597 
 598     static inline oop resolve(oop obj) {
 599       return _resolve_func(obj);
 600     }
 601   };
 602 
<a name="31" id="anc31"></a>











 603   // Initialize the function pointers to point to the resolving function.
 604   template &lt;DecoratorSet decorators, typename T&gt;
 605   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 606   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 607 
 608   template &lt;DecoratorSet decorators, typename T&gt;
 609   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 610   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 611 
 612   template &lt;DecoratorSet decorators, typename T&gt;
 613   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 614   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 615 
 616   template &lt;DecoratorSet decorators, typename T&gt;
 617   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 618   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 619 
 620   template &lt;DecoratorSet decorators, typename T&gt;
 621   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 622   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
 623 
 624   template &lt;DecoratorSet decorators, typename T&gt;
 625   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 626   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 627 
 628   template &lt;DecoratorSet decorators, typename T&gt;
 629   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 630   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 631 
 632   template &lt;DecoratorSet decorators, typename T&gt;
 633   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 634   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 635 
 636   template &lt;DecoratorSet decorators, typename T&gt;
 637   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 638   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 639 
 640   template &lt;DecoratorSet decorators, typename T&gt;
 641   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 642   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 643 
 644   template &lt;DecoratorSet decorators, typename T&gt;
 645   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 646   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 647 
<a name="32" id="anc32"></a>



 648   // Step 3: Pre-runtime dispatching.
 649   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 650   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 651   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 652   // not possible.
 653   struct PreRuntimeDispatch: AllStatic {
 654     template&lt;DecoratorSet decorators&gt;
 655     struct CanHardwireRaw: public IntegralConstant&lt;
 656       bool,
 657       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 658       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 659       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 660     {};
 661 
 662     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 663 
 664     template&lt;DecoratorSet decorators&gt;
 665     static bool is_hardwired_primitive() {
 666       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 667              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
 668     }
 669 
 670     template &lt;DecoratorSet decorators, typename T&gt;
 671     inline static typename EnableIf&lt;
 672       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 673     store(void* addr, T value) {
 674       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 675       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 676         Raw::oop_store(addr, value);
 677       } else {
 678         Raw::store(addr, value);
 679       }
 680     }
 681 
 682     template &lt;DecoratorSet decorators, typename T&gt;
 683     inline static typename EnableIf&lt;
 684       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 685     store(void* addr, T value) {
 686       if (UseCompressedOops) {
 687         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 688         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 689       } else {
 690         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 691         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 692       }
 693     }
 694 
 695     template &lt;DecoratorSet decorators, typename T&gt;
 696     inline static typename EnableIf&lt;
 697       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 698     store(void* addr, T value) {
 699       if (is_hardwired_primitive&lt;decorators&gt;()) {
 700         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 701         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 702       } else {
 703         RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store(addr, value);
 704       }
 705     }
 706 
 707     template &lt;DecoratorSet decorators, typename T&gt;
 708     inline static typename EnableIf&lt;
 709       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 710     store_at(oop base, ptrdiff_t offset, T value) {
 711       store&lt;decorators&gt;(field_addr(base, offset), value);
 712     }
 713 
 714     template &lt;DecoratorSet decorators, typename T&gt;
 715     inline static typename EnableIf&lt;
 716       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 717     store_at(oop base, ptrdiff_t offset, T value) {
 718       if (is_hardwired_primitive&lt;decorators&gt;()) {
 719         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 720         PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, value);
 721       } else {
 722         RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at(base, offset, value);
 723       }
 724     }
 725 
 726     template &lt;DecoratorSet decorators, typename T&gt;
 727     inline static typename EnableIf&lt;
 728       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 729     load(void* addr) {
 730       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 731       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 732         return Raw::template oop_load&lt;T&gt;(addr);
 733       } else {
 734         return Raw::template load&lt;T&gt;(addr);
 735       }
 736     }
 737 
 738     template &lt;DecoratorSet decorators, typename T&gt;
 739     inline static typename EnableIf&lt;
 740       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 741     load(void* addr) {
 742       if (UseCompressedOops) {
 743         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 744         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 745       } else {
 746         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 747         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 748       }
 749     }
 750 
 751     template &lt;DecoratorSet decorators, typename T&gt;
 752     inline static typename EnableIf&lt;
 753       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 754     load(void* addr) {
 755       if (is_hardwired_primitive&lt;decorators&gt;()) {
 756         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 757         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 758       } else {
 759         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load(addr);
 760       }
 761     }
 762 
 763     template &lt;DecoratorSet decorators, typename T&gt;
 764     inline static typename EnableIf&lt;
 765       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 766     load_at(oop base, ptrdiff_t offset) {
 767       return load&lt;decorators, T&gt;(field_addr(base, offset));
 768     }
 769 
 770     template &lt;DecoratorSet decorators, typename T&gt;
 771     inline static typename EnableIf&lt;
 772       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 773     load_at(oop base, ptrdiff_t offset) {
 774       if (is_hardwired_primitive&lt;decorators&gt;()) {
 775         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 776         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 777       } else {
 778         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 779       }
 780     }
 781 
 782     template &lt;DecoratorSet decorators, typename T&gt;
 783     inline static typename EnableIf&lt;
 784       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="33" id="anc33"></a><span class="line-modified"> 785     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 786       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 787       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<a name="34" id="anc34"></a><span class="line-modified"> 788         return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
 789       } else {
<a name="35" id="anc35"></a><span class="line-modified"> 790         return Raw::atomic_cmpxchg(addr, compare_value, new_value);</span>
 791       }
 792     }
 793 
 794     template &lt;DecoratorSet decorators, typename T&gt;
 795     inline static typename EnableIf&lt;
 796       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="36" id="anc36"></a><span class="line-modified"> 797     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 798       if (UseCompressedOops) {
 799         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<a name="37" id="anc37"></a><span class="line-modified"> 800         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 801       } else {
 802         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<a name="38" id="anc38"></a><span class="line-modified"> 803         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 804       }
 805     }
 806 
 807     template &lt;DecoratorSet decorators, typename T&gt;
 808     inline static typename EnableIf&lt;
 809       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="39" id="anc39"></a><span class="line-modified"> 810     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 811       if (is_hardwired_primitive&lt;decorators&gt;()) {
 812         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="40" id="anc40"></a><span class="line-modified"> 813         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 814       } else {
<a name="41" id="anc41"></a><span class="line-modified"> 815         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(addr, compare_value, new_value);</span>
 816       }
 817     }
 818 
 819     template &lt;DecoratorSet decorators, typename T&gt;
 820     inline static typename EnableIf&lt;
 821       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="42" id="anc42"></a><span class="line-modified"> 822     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 823       return atomic_cmpxchg&lt;decorators&gt;(field_addr(base, offset), compare_value, new_value);</span>
 824     }
 825 
 826     template &lt;DecoratorSet decorators, typename T&gt;
 827     inline static typename EnableIf&lt;
 828       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="43" id="anc43"></a><span class="line-modified"> 829     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
 830       if (is_hardwired_primitive&lt;decorators&gt;()) {
 831         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="44" id="anc44"></a><span class="line-modified"> 832         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(base, offset, compare_value, new_value);</span>
 833       } else {
<a name="45" id="anc45"></a><span class="line-modified"> 834         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(base, offset, compare_value, new_value);</span>
 835       }
 836     }
 837 
 838     template &lt;DecoratorSet decorators, typename T&gt;
 839     inline static typename EnableIf&lt;
 840       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="46" id="anc46"></a><span class="line-modified"> 841     atomic_xchg(void* addr, T new_value) {</span>
 842       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 843       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<a name="47" id="anc47"></a><span class="line-modified"> 844         return Raw::oop_atomic_xchg(addr, new_value);</span>
 845       } else {
<a name="48" id="anc48"></a><span class="line-modified"> 846         return Raw::atomic_xchg(addr, new_value);</span>
 847       }
 848     }
 849 
 850     template &lt;DecoratorSet decorators, typename T&gt;
 851     inline static typename EnableIf&lt;
 852       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<a name="49" id="anc49"></a><span class="line-modified"> 853     atomic_xchg(void* addr, T new_value) {</span>
 854       if (UseCompressedOops) {
 855         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<a name="50" id="anc50"></a><span class="line-modified"> 856         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 857       } else {
 858         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<a name="51" id="anc51"></a><span class="line-modified"> 859         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 860       }
 861     }
 862 
 863     template &lt;DecoratorSet decorators, typename T&gt;
 864     inline static typename EnableIf&lt;
 865       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="52" id="anc52"></a><span class="line-modified"> 866     atomic_xchg(void* addr, T new_value) {</span>
 867       if (is_hardwired_primitive&lt;decorators&gt;()) {
 868         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="53" id="anc53"></a><span class="line-modified"> 869         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 870       } else {
<a name="54" id="anc54"></a><span class="line-modified"> 871         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(addr, new_value);</span>
 872       }
 873     }
 874 
 875     template &lt;DecoratorSet decorators, typename T&gt;
 876     inline static typename EnableIf&lt;
 877       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="55" id="anc55"></a><span class="line-modified"> 878     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 879       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);</span>
 880     }
 881 
 882     template &lt;DecoratorSet decorators, typename T&gt;
 883     inline static typename EnableIf&lt;
 884       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<a name="56" id="anc56"></a><span class="line-modified"> 885     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
 886       if (is_hardwired_primitive&lt;decorators&gt;()) {
 887         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="57" id="anc57"></a><span class="line-modified"> 888         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);</span>
 889       } else {
<a name="58" id="anc58"></a><span class="line-modified"> 890         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);</span>
 891       }
 892     }
 893 
 894     template &lt;DecoratorSet decorators, typename T&gt;
 895     inline static typename EnableIf&lt;
 896       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 897     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 898               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 899               size_t length) {
 900       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 901       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 902         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,
 903                                   dst_obj, dst_offset_in_bytes, dst_raw,
 904                                   length);
 905       } else {
 906         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 907                               dst_obj, dst_offset_in_bytes, dst_raw,
 908                               length);
 909       }
 910     }
 911 
 912     template &lt;DecoratorSet decorators, typename T&gt;
 913     inline static typename EnableIf&lt;
 914       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 915     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 916               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 917               size_t length) {
 918       if (UseCompressedOops) {
 919         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 920         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 921                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 922                                                                   length);
 923       } else {
 924         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 925         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 926                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 927                                                                   length);
 928       }
 929     }
 930 
 931     template &lt;DecoratorSet decorators, typename T&gt;
 932     inline static typename EnableIf&lt;
 933       !HasDecorator&lt;decorators, AS_RAW&gt;::value, bool&gt;::type
 934     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 935               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 936               size_t length) {
 937       if (is_hardwired_primitive&lt;decorators&gt;()) {
 938         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 939         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 940                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
 941                                                                   length);
 942       } else {
 943         return RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 944                                                                             dst_obj, dst_offset_in_bytes, dst_raw,
 945                                                                             length);
 946       }
 947     }
 948 
 949     template &lt;DecoratorSet decorators&gt;
 950     inline static typename EnableIf&lt;
 951       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 952     clone(oop src, oop dst, size_t size) {
 953       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 954       Raw::clone(src, dst, size);
 955     }
 956 
 957     template &lt;DecoratorSet decorators&gt;
 958     inline static typename EnableIf&lt;
 959       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 960     clone(oop src, oop dst, size_t size) {
 961       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 962     }
 963 
 964     template &lt;DecoratorSet decorators&gt;
 965     inline static typename EnableIf&lt;
 966       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 967     resolve(oop obj) {
 968       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 969       return Raw::resolve(obj);
 970     }
 971 
 972     template &lt;DecoratorSet decorators&gt;
 973     inline static typename EnableIf&lt;
 974       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 975     resolve(oop obj) {
 976       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 977     }
<a name="59" id="anc59"></a>














 978   };
 979 
 980   // Step 2: Reduce types.
 981   // Enforce that for non-oop types, T and P have to be strictly the same.
 982   // P is the type of the address and T is the type of the values.
 983   // As for oop types, it is allow to send T in {narrowOop, oop} and
 984   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
 985   // the subsequent table. (columns are P, rows are T)
 986   // |           | HeapWord  |   oop   | narrowOop |
 987   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
 988   // | narrowOop |     x     |    x    |  hw-none  |
 989   //
 990   // x means not allowed
 991   // rt-comp means it must be checked at runtime whether the oop is compressed.
 992   // hw-none means it is statically known the oop will not be compressed.
 993   // hw-comp means it is statically known the oop will be compressed.
 994 
 995   template &lt;DecoratorSet decorators, typename T&gt;
 996   inline void store_reduce_types(T* addr, T value) {
 997     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
 998   }
 999 
1000   template &lt;DecoratorSet decorators&gt;
1001   inline void store_reduce_types(narrowOop* addr, oop value) {
1002     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1003                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1004     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1005   }
1006 
1007   template &lt;DecoratorSet decorators&gt;
1008   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
1009     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1010                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1011     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1012   }
1013 
1014   template &lt;DecoratorSet decorators&gt;
1015   inline void store_reduce_types(HeapWord* addr, oop value) {
1016     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1017     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1018   }
1019 
1020   template &lt;DecoratorSet decorators, typename T&gt;
<a name="60" id="anc60"></a><span class="line-modified">1021   inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {</span>
<span class="line-modified">1022     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);</span>
1023   }
1024 
1025   template &lt;DecoratorSet decorators&gt;
<a name="61" id="anc61"></a><span class="line-modified">1026   inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {</span>
1027     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1028                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="62" id="anc62"></a><span class="line-modified">1029     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1030   }
1031 
1032   template &lt;DecoratorSet decorators&gt;
<a name="63" id="anc63"></a><span class="line-modified">1033   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {</span>
1034     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1035                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="64" id="anc64"></a><span class="line-modified">1036     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1037   }
1038 
1039   template &lt;DecoratorSet decorators&gt;
<a name="65" id="anc65"></a><span class="line-modified">1040   inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,</span>
<span class="line-modified">1041                                          oop compare_value,</span>
<span class="line-modified">1042                                          oop new_value) {</span>
1043     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<a name="66" id="anc66"></a><span class="line-modified">1044     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1045   }
1046 
1047   template &lt;DecoratorSet decorators, typename T&gt;
<a name="67" id="anc67"></a><span class="line-modified">1048   inline T atomic_xchg_reduce_types(T* addr, T new_value) {</span>
1049     const DecoratorSet expanded_decorators = decorators;
<a name="68" id="anc68"></a><span class="line-modified">1050     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1051   }
1052 
1053   template &lt;DecoratorSet decorators&gt;
<a name="69" id="anc69"></a><span class="line-modified">1054   inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {</span>
1055     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1056                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="70" id="anc70"></a><span class="line-modified">1057     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1058   }
1059 
1060   template &lt;DecoratorSet decorators&gt;
<a name="71" id="anc71"></a><span class="line-modified">1061   inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {</span>
1062     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1063                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="72" id="anc72"></a><span class="line-modified">1064     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1065   }
1066 
1067   template &lt;DecoratorSet decorators&gt;
<a name="73" id="anc73"></a><span class="line-modified">1068   inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {</span>
1069     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<a name="74" id="anc74"></a><span class="line-modified">1070     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1071   }
1072 
1073   template &lt;DecoratorSet decorators, typename T&gt;
1074   inline T load_reduce_types(T* addr) {
1075     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1076   }
1077 
1078   template &lt;DecoratorSet decorators, typename T&gt;
1079   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1080     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1081                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1082     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1083   }
1084 
1085   template &lt;DecoratorSet decorators, typename T&gt;
1086   inline oop load_reduce_types(HeapWord* addr) {
1087     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1088     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1089   }
1090 
1091   template &lt;DecoratorSet decorators, typename T&gt;
1092   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
1093                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1094                                      size_t length) {
1095     return PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1096                                                      dst_obj, dst_offset_in_bytes, dst_raw,
1097                                                      length);
1098   }
1099 
1100   template &lt;DecoratorSet decorators&gt;
1101   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,
1102                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1103                                      size_t length) {
1104     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1105     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1106                                                               dst_obj, dst_offset_in_bytes, dst_raw,
1107                                                               length);
1108   }
1109 
1110   template &lt;DecoratorSet decorators&gt;
1111   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,
1112                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1113                                      size_t length) {
1114     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1115                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1116     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1117                                                               dst_obj, dst_offset_in_bytes, dst_raw,
1118                                                               length);
1119   }
1120 
1121   // Step 1: Set default decorators. This step remembers if a type was volatile
1122   // and then sets the MO_VOLATILE decorator by default. Otherwise, a default
1123   // memory ordering is set for the access, and the implied decorator rules
1124   // are applied to select sensible defaults for decorators that have not been
1125   // explicitly set. For example, default object referent strength is set to strong.
1126   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1127   // and references from the types). This step also perform some type verification
1128   // that the passed in types make sense.
1129 
1130   template &lt;DecoratorSet decorators, typename T&gt;
1131   static void verify_types(){
1132     // If this fails to compile, then you have sent in something that is
1133     // not recognized as a valid primitive type to a primitive Access function.
1134     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1135                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1136                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1137   }
1138 
1139   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1140   inline void store(P* addr, T value) {
1141     verify_types&lt;decorators, T&gt;();
1142     typedef typename Decay&lt;P&gt;::type DecayedP;
1143     typedef typename Decay&lt;T&gt;::type DecayedT;
1144     DecayedT decayed_value = value;
1145     // If a volatile address is passed in but no memory ordering decorator,
1146     // set the memory ordering to MO_VOLATILE by default.
1147     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1148       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1149       (MO_VOLATILE | decorators) : decorators&gt;::value;
1150     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1151   }
1152 
1153   template &lt;DecoratorSet decorators, typename T&gt;
1154   inline void store_at(oop base, ptrdiff_t offset, T value) {
1155     verify_types&lt;decorators, T&gt;();
1156     typedef typename Decay&lt;T&gt;::type DecayedT;
1157     DecayedT decayed_value = value;
1158     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1159                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1160                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1161     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1162   }
1163 
1164   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1165   inline T load(P* addr) {
1166     verify_types&lt;decorators, T&gt;();
1167     typedef typename Decay&lt;P&gt;::type DecayedP;
1168     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1169                                  typename OopOrNarrowOop&lt;T&gt;::type,
1170                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1171     // If a volatile address is passed in but no memory ordering decorator,
1172     // set the memory ordering to MO_VOLATILE by default.
1173     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1174       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1175       (MO_VOLATILE | decorators) : decorators&gt;::value;
1176     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1177   }
1178 
1179   template &lt;DecoratorSet decorators, typename T&gt;
1180   inline T load_at(oop base, ptrdiff_t offset) {
1181     verify_types&lt;decorators, T&gt;();
1182     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1183                                  typename OopOrNarrowOop&lt;T&gt;::type,
1184                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1185     // Expand the decorators (figure out sensible defaults)
1186     // Potentially remember if we need compressed oop awareness
1187     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1188                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1189                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1190     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1191   }
1192 
1193   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<a name="75" id="anc75"></a><span class="line-modified">1194   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {</span>
1195     verify_types&lt;decorators, T&gt;();
1196     typedef typename Decay&lt;P&gt;::type DecayedP;
1197     typedef typename Decay&lt;T&gt;::type DecayedT;
1198     DecayedT new_decayed_value = new_value;
1199     DecayedT compare_decayed_value = compare_value;
1200     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1201       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1202       (MO_SEQ_CST | decorators) : decorators&gt;::value;
<a name="76" id="anc76"></a><span class="line-modified">1203     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1204                                                             compare_decayed_value,</span>
<span class="line-modified">1205                                                             new_decayed_value);</span>
1206   }
1207 
1208   template &lt;DecoratorSet decorators, typename T&gt;
<a name="77" id="anc77"></a><span class="line-modified">1209   inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
1210     verify_types&lt;decorators, T&gt;();
1211     typedef typename Decay&lt;T&gt;::type DecayedT;
1212     DecayedT new_decayed_value = new_value;
1213     DecayedT compare_decayed_value = compare_value;
1214     // Determine default memory ordering
1215     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1216       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1217       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1218     // Potentially remember that we need compressed oop awareness
1219     const DecoratorSet final_decorators = expanded_decorators |
1220                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1221                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<a name="78" id="anc78"></a><span class="line-modified">1222     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(base, offset, compare_decayed_value,</span>
<span class="line-modified">1223                                                                    new_decayed_value);</span>
1224   }
1225 
1226   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<a name="79" id="anc79"></a><span class="line-modified">1227   inline T atomic_xchg(P* addr, T new_value) {</span>
1228     verify_types&lt;decorators, T&gt;();
1229     typedef typename Decay&lt;P&gt;::type DecayedP;
1230     typedef typename Decay&lt;T&gt;::type DecayedT;
1231     DecayedT new_decayed_value = new_value;
1232     // atomic_xchg is only available in SEQ_CST flavour.
1233     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<a name="80" id="anc80"></a><span class="line-modified">1234     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1235                                                          new_decayed_value);</span>
1236   }
1237 
1238   template &lt;DecoratorSet decorators, typename T&gt;
<a name="81" id="anc81"></a><span class="line-modified">1239   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
1240     verify_types&lt;decorators, T&gt;();
1241     typedef typename Decay&lt;T&gt;::type DecayedT;
1242     DecayedT new_decayed_value = new_value;
1243     // atomic_xchg is only available in SEQ_CST flavour.
1244     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1245                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1246                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<a name="82" id="anc82"></a><span class="line-modified">1247     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);</span>
1248   }
1249 
1250   template &lt;DecoratorSet decorators, typename T&gt;
1251   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
1252                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1253                         size_t length) {
1254     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1255                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1256                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1257     typedef typename Decay&lt;T&gt;::type DecayedT;
1258     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
1259     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),
1260                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),
1261                                                        length);
1262   }
1263 
1264   template &lt;DecoratorSet decorators&gt;
1265   inline void clone(oop src, oop dst, size_t size) {
1266     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1267     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1268   }
1269 
1270   template &lt;DecoratorSet decorators&gt;
1271   inline oop resolve(oop obj) {
1272     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1273     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1274   }
1275 
<a name="83" id="anc83"></a>





1276   // Infer the type that should be returned from an Access::oop_load.
1277   template &lt;typename P, DecoratorSet decorators&gt;
1278   class OopLoadProxy: public StackObj {
1279   private:
1280     P *const _addr;
1281   public:
1282     OopLoadProxy(P* addr) : _addr(addr) {}
1283 
1284     inline operator oop() {
1285       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1286     }
1287 
1288     inline operator narrowOop() {
1289       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1290     }
1291 
1292     template &lt;typename T&gt;
1293     inline bool operator ==(const T&amp; other) const {
1294       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1295     }
1296 
1297     template &lt;typename T&gt;
1298     inline bool operator !=(const T&amp; other) const {
1299       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) != other;
1300     }
1301   };
1302 
1303   // Infer the type that should be returned from an Access::load_at.
1304   template &lt;DecoratorSet decorators&gt;
1305   class LoadAtProxy: public StackObj {
1306   private:
1307     const oop _base;
1308     const ptrdiff_t _offset;
1309   public:
1310     LoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1311 
1312     template &lt;typename T&gt;
1313     inline operator T() const {
1314       return load_at&lt;decorators, T&gt;(_base, _offset);
1315     }
1316 
1317     template &lt;typename T&gt;
1318     inline bool operator ==(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) == other; }
1319 
1320     template &lt;typename T&gt;
1321     inline bool operator !=(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) != other; }
1322   };
1323 
1324   // Infer the type that should be returned from an Access::oop_load_at.
1325   template &lt;DecoratorSet decorators&gt;
1326   class OopLoadAtProxy: public StackObj {
1327   private:
1328     const oop _base;
1329     const ptrdiff_t _offset;
1330   public:
1331     OopLoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1332 
1333     inline operator oop() const {
1334       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, oop&gt;(_base, _offset);
1335     }
1336 
1337     inline operator narrowOop() const {
1338       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, narrowOop&gt;(_base, _offset);
1339     }
1340 
1341     template &lt;typename T&gt;
1342     inline bool operator ==(const T&amp; other) const {
1343       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) == other;
1344     }
1345 
1346     template &lt;typename T&gt;
1347     inline bool operator !=(const T&amp; other) const {
1348       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) != other;
1349     }
1350   };
1351 }
1352 
1353 #endif // SHARE_OOPS_ACCESSBACKEND_HPP
<a name="84" id="anc84"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="84" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  #include &quot;metaprogramming/isPointer.hpp&quot;
  #include &quot;metaprogramming/isSame.hpp&quot;
  #include &quot;metaprogramming/isVolatile.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
  
  // This metafunction returns either oop or narrowOop depending on whether
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,12 ***</span>
      BARRIER_ATOMIC_CMPXCHG_AT,
      BARRIER_ATOMIC_XCHG,
      BARRIER_ATOMIC_XCHG_AT,
      BARRIER_ARRAYCOPY,
      BARRIER_CLONE,
<span class="line-modified">!     BARRIER_RESOLVE,</span>
<span class="line-removed">-     BARRIER_EQUALS</span>
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
      HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
<span class="line-new-header">--- 62,11 ---</span>
      BARRIER_ATOMIC_CMPXCHG_AT,
      BARRIER_ATOMIC_XCHG,
      BARRIER_ATOMIC_XCHG_AT,
      BARRIER_ARRAYCOPY,
      BARRIER_CLONE,
<span class="line-modified">!     BARRIER_RESOLVE</span>
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
      HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,24 ***</span>
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct AccessFunctionTypes {
      typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
      typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<span class="line-modified">!     typedef T (*atomic_cmpxchg_at_func_t)(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
<span class="line-modified">!     typedef T (*atomic_xchg_at_func_t)(T new_value, oop base, ptrdiff_t offset);</span>
  
      typedef T (*load_func_t)(void* addr);
      typedef void (*store_func_t)(void* addr, T value);
<span class="line-modified">!     typedef T (*atomic_cmpxchg_func_t)(T new_value, void* addr, T compare_value);</span>
<span class="line-modified">!     typedef T (*atomic_xchg_func_t)(T new_value, void* addr);</span>
  
      typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                       size_t length);
      typedef void (*clone_func_t)(oop src, oop dst, size_t size);
      typedef oop (*resolve_func_t)(oop obj);
<span class="line-removed">-     typedef bool (*equals_func_t)(oop o1, oop o2);</span>
    };
  
    template &lt;DecoratorSet decorators&gt;
    struct AccessFunctionTypes&lt;decorators, void&gt; {
      typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
<span class="line-new-header">--- 100,23 ---</span>
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct AccessFunctionTypes {
      typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
      typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<span class="line-modified">!     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
<span class="line-modified">!     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);</span>
  
      typedef T (*load_func_t)(void* addr);
      typedef void (*store_func_t)(void* addr, T value);
<span class="line-modified">!     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);</span>
<span class="line-modified">!     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);</span>
  
      typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                       size_t length);
      typedef void (*clone_func_t)(oop src, oop dst, size_t size);
      typedef oop (*resolve_func_t)(oop obj);
    };
  
    template &lt;DecoratorSet decorators&gt;
    struct AccessFunctionTypes&lt;decorators, void&gt; {
      typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,11 ***</span>
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
<span class="line-removed">-   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_EQUALS, equals_func_t);</span>
  #undef ACCESS_GENERATE_ACCESS_FUNCTION
  
    template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
    typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
  
<span class="line-new-header">--- 140,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,49 ***</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_internal(T new_value, void* addr);</span>
  
    // The following *_locked mechanisms serve the purpose of handling atomic operations
    // that are larger than a machine can handle, and then possibly opt for using
    // a slower path using a mutex to perform the operation.
  
    template &lt;DecoratorSet ds, typename T&gt;
    static inline typename EnableIf&lt;
      !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static inline typename EnableIf&lt;
      !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_maybe_locked(T new_value, void* addr) {</span>
<span class="line-modified">!     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_maybe_locked(T new_value, void* addr);</span>
  
  public:
    template &lt;typename T&gt;
    static inline void store(void* addr, T value) {
      store_internal&lt;decorators&gt;(addr, value);
<span class="line-new-header">--- 291,49 ---</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_internal(void* addr, T new_value);</span>
  
    // The following *_locked mechanisms serve the purpose of handling atomic operations
    // that are larger than a machine can handle, and then possibly opt for using
    // a slower path using a mutex to perform the operation.
  
    template &lt;DecoratorSet ds, typename T&gt;
    static inline typename EnableIf&lt;
      !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);</span>
  
    template &lt;DecoratorSet ds, typename T&gt;
    static inline typename EnableIf&lt;
      !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_maybe_locked(void* addr, T new_value) {</span>
<span class="line-modified">!     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);</span>
    }
  
    template &lt;DecoratorSet ds, typename T&gt;
    static typename EnableIf&lt;
      AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified">!   atomic_xchg_maybe_locked(void* addr, T new_value);</span>
  
  public:
    template &lt;typename T&gt;
    static inline void store(void* addr, T value) {
      store_internal&lt;decorators&gt;(addr, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,17 ***</span>
    static inline T load(void* addr) {
      return load_internal&lt;decorators, T&gt;(addr);
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified">!     return atomic_xchg_maybe_locked&lt;decorators&gt;(new_value, addr);</span>
    }
  
    template &lt;typename T&gt;
    static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
<span class="line-new-header">--- 343,17 ---</span>
    static inline T load(void* addr) {
      return load_internal&lt;decorators, T&gt;(addr);
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified">!     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);</span>
    }
  
    template &lt;typename T&gt;
    static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,18 ***</span>
    static T oop_load(void* addr);
    template &lt;typename T&gt;
    static T oop_load_at(oop base, ptrdiff_t offset);
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_cmpxchg(T new_value, void* addr, T compare_value);</span>
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_xchg(T new_value, void* addr);</span>
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset);</span>
  
    template &lt;typename T&gt;
    static void store_at(oop base, ptrdiff_t offset, T value) {
      store(field_addr(base, offset), value);
    }
<span class="line-new-header">--- 368,18 ---</span>
    static T oop_load(void* addr);
    template &lt;typename T&gt;
    static T oop_load_at(oop base, ptrdiff_t offset);
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);</span>
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_xchg(void* addr, T new_value);</span>
    template &lt;typename T&gt;
<span class="line-modified">!   static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);</span>
  
    template &lt;typename T&gt;
    static void store_at(oop base, ptrdiff_t offset, T value) {
      store(field_addr(base, offset), value);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,29 ***</span>
    static T load_at(oop base, ptrdiff_t offset) {
      return load&lt;T&gt;(field_addr(base, offset));
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);</span>
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">!     return atomic_xchg(new_value, field_addr(base, offset));</span>
    }
  
    template &lt;typename T&gt;
    static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                              arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                              size_t length);
  
    static void clone(oop src, oop dst, size_t size);
  
    static oop resolve(oop obj) { return obj; }
<span class="line-removed">- </span>
<span class="line-removed">-   static bool equals(oop o1, oop o2) { return (void*)o1 == (void*)o2; }</span>
  };
  
  // Below is the implementation of the first 4 steps of the template pipeline:
  // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
  //           and sets default decorators to sensible values.
<span class="line-new-header">--- 388,27 ---</span>
    static T load_at(oop base, ptrdiff_t offset) {
      return load&lt;T&gt;(field_addr(base, offset));
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">!     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);</span>
    }
  
    template &lt;typename T&gt;
<span class="line-modified">!   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">!     return atomic_xchg(field_addr(base, offset), new_value);</span>
    }
  
    template &lt;typename T&gt;
    static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                              arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                              size_t length);
  
    static void clone(oop src, oop dst, size_t size);
  
    static oop resolve(oop obj) { return obj; }
  };
  
  // Below is the implementation of the first 4 steps of the template pipeline:
  // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
  //           and sets default decorators to sensible values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,50 ***</span>
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
      static func_t _atomic_cmpxchg_func;
  
<span class="line-modified">!     static T atomic_cmpxchg_init(T new_value, void* addr, T compare_value);</span>
  
<span class="line-modified">!     static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified">!       return _atomic_cmpxchg_func(new_value, addr, compare_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
      static func_t _atomic_cmpxchg_at_func;
  
<span class="line-modified">!     static T atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
  
<span class="line-modified">!     static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">!       return _atomic_cmpxchg_at_func(new_value, base, offset, compare_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
      static func_t _atomic_xchg_func;
  
<span class="line-modified">!     static T atomic_xchg_init(T new_value, void* addr);</span>
  
<span class="line-modified">!     static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified">!       return _atomic_xchg_func(new_value, addr);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
      static func_t _atomic_xchg_at_func;
  
<span class="line-modified">!     static T atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset);</span>
  
<span class="line-modified">!     static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">!       return _atomic_xchg_at_func(new_value, base, offset);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
<span class="line-new-header">--- 513,50 ---</span>
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
      static func_t _atomic_cmpxchg_func;
  
<span class="line-modified">!     static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);</span>
  
<span class="line-modified">!     static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified">!       return _atomic_cmpxchg_func(addr, compare_value, new_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
      static func_t _atomic_cmpxchg_at_func;
  
<span class="line-modified">!     static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
  
<span class="line-modified">!     static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">!       return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
      static func_t _atomic_xchg_func;
  
<span class="line-modified">!     static T atomic_xchg_init(void* addr, T new_value);</span>
  
<span class="line-modified">!     static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified">!       return _atomic_xchg_func(addr, new_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
      static func_t _atomic_xchg_at_func;
  
<span class="line-modified">!     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);</span>
  
<span class="line-modified">!     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">!       return _atomic_xchg_at_func(base, offset, new_value);</span>
      }
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,22 ***</span>
      static inline oop resolve(oop obj) {
        return _resolve_func(obj);
      }
    };
  
<span class="line-removed">-   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed">-   struct RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;: AllStatic {</span>
<span class="line-removed">-     typedef typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type func_t;</span>
<span class="line-removed">-     static func_t _equals_func;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static bool equals_init(oop o1, oop o2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed">-       return _equals_func(o1, o2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
    // Initialize the function pointers to point to the resolving function.
    template &lt;DecoratorSet decorators, typename T&gt;
    typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
    RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
  
<span class="line-new-header">--- 598,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,14 ***</span>
  
    template &lt;DecoratorSet decorators, typename T&gt;
    typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
    RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
  
<span class="line-removed">-   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed">-   typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type</span>
<span class="line-removed">-   RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;::_equals_func = &amp;equals_init;</span>
<span class="line-removed">- </span>
    // Step 3: Pre-runtime dispatching.
    // The PreRuntimeDispatch class is responsible for filtering the barrier strength
    // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
    // dispatch point. Otherwise it goes through a runtime check if hardwiring was
    // not possible.
<span class="line-new-header">--- 643,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,116 ***</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
        if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified">!         return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
        } else {
<span class="line-modified">!         return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
        if (UseCompressedOops) {
          const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
        } else {
          const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(new_value, addr, compare_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">!       return atomic_cmpxchg&lt;decorators&gt;(new_value, field_addr(base, offset), compare_value);</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(new_value, base, offset, compare_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(T new_value, void* addr) {</span>
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
        if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified">!         return Raw::oop_atomic_xchg(new_value, addr);</span>
        } else {
<span class="line-modified">!         return Raw::atomic_xchg(new_value, addr);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(T new_value, void* addr) {</span>
        if (UseCompressedOops) {
          const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
        } else {
          const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(T new_value, void* addr) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(new_value, addr);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">!       return atomic_xchg&lt;decorators&gt;(new_value, field_addr(base, offset));</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, base, offset);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(new_value, base, offset);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
<span class="line-new-header">--- 780,116 ---</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
        if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified">!         return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
        } else {
<span class="line-modified">!         return Raw::atomic_cmpxchg(addr, compare_value, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
        if (UseCompressedOops) {
          const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
        } else {
          const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(addr, compare_value, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">!       return atomic_cmpxchg&lt;decorators&gt;(field_addr(base, offset), compare_value, new_value);</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(base, offset, compare_value, new_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(base, offset, compare_value, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(void* addr, T new_value) {</span>
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
        if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified">!         return Raw::oop_atomic_xchg(addr, new_value);</span>
        } else {
<span class="line-modified">!         return Raw::atomic_xchg(addr, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(void* addr, T new_value) {</span>
        if (UseCompressedOops) {
          const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
        } else {
          const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg(void* addr, T new_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(addr, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">!       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);</span>
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified">!     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified">!         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);</span>
        } else {
<span class="line-modified">!         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,25 ***</span>
      inline static typename EnableIf&lt;
        !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
      resolve(oop obj) {
        return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">-     inline static typename EnableIf&lt;</span>
<span class="line-removed">-       HasDecorator&lt;decorators, AS_RAW&gt;::value || HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">-     equals(oop o1, oop o2) {</span>
<span class="line-removed">-       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;</span>
<span class="line-removed">-       return Raw::equals(o1, o2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">-     inline static typename EnableIf&lt;</span>
<span class="line-removed">-       !HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">-     equals(oop o1, oop o2) {</span>
<span class="line-removed">-       return RuntimeDispatch&lt;decorators, oop, BARRIER_EQUALS&gt;::equals(o1, o2);</span>
<span class="line-removed">-     }</span>
    };
  
    // Step 2: Reduce types.
    // Enforce that for non-oop types, T and P have to be strictly the same.
    // P is the type of the address and T is the type of the values.
<span class="line-new-header">--- 973,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1051,60 ***</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
      PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg_reduce_types(T new_value, T* addr, T compare_value) {</span>
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_cmpxchg_reduce_types(oop new_value, narrowOop* addr, oop compare_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop new_value, narrowOop* addr, narrowOop compare_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_cmpxchg_reduce_types(oop new_value,</span>
<span class="line-modified">!                                          HeapWord* addr,</span>
<span class="line-modified">!                                          oop compare_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg_reduce_types(T new_value, T* addr) {</span>
      const DecoratorSet expanded_decorators = decorators;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_xchg_reduce_types(oop new_value, narrowOop* addr) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline narrowOop atomic_xchg_reduce_types(narrowOop new_value, narrowOop* addr) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_xchg_reduce_types(oop new_value, HeapWord* addr) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
    inline T load_reduce_types(T* addr) {
      return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
<span class="line-new-header">--- 1016,60 ---</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
      PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {</span>
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,</span>
<span class="line-modified">!                                          oop compare_value,</span>
<span class="line-modified">!                                          oop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg_reduce_types(T* addr, T new_value) {</span>
      const DecoratorSet expanded_decorators = decorators;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="line-modified">!   inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
    inline T load_reduce_types(T* addr) {
      return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1224,26 ***</span>
                                                INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
      return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
    }
  
    template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;P&gt;::type DecayedP;
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      DecayedT compare_decayed_value = compare_value;
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;
        (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
        (MO_SEQ_CST | decorators) : decorators&gt;::value;
<span class="line-modified">!     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">!                                                             const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">!                                                             compare_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      DecayedT compare_decayed_value = compare_value;
      // Determine default memory ordering
<span class="line-new-header">--- 1189,26 ---</span>
                                                INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
      return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
    }
  
    template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;P&gt;::type DecayedP;
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      DecayedT compare_decayed_value = compare_value;
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;
        (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
        (MO_SEQ_CST | decorators) : decorators&gt;::value;
<span class="line-modified">!     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">!                                                             compare_decayed_value,</span>
<span class="line-modified">!                                                             new_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      DecayedT compare_decayed_value = compare_value;
      // Determine default memory ordering
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1252,36 ***</span>
        (MO_SEQ_CST | decorators) : decorators&gt;::value;
      // Potentially remember that we need compressed oop awareness
      const DecoratorSet final_decorators = expanded_decorators |
                                            (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
                                             INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(new_decayed_value, base,</span>
<span class="line-modified">!                                                                    offset, compare_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg(T new_value, P* addr) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;P&gt;::type DecayedP;
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      // atomic_xchg is only available in SEQ_CST flavour.
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<span class="line-modified">!     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">!                                                          const_cast&lt;DecayedP*&gt;(addr));</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      // atomic_xchg is only available in SEQ_CST flavour.
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
                                               (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
                                                INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(new_decayed_value, base, offset);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
    inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
<span class="line-new-header">--- 1217,36 ---</span>
        (MO_SEQ_CST | decorators) : decorators&gt;::value;
      // Potentially remember that we need compressed oop awareness
      const DecoratorSet final_decorators = expanded_decorators |
                                            (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
                                             INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<span class="line-modified">!     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(base, offset, compare_decayed_value,</span>
<span class="line-modified">!                                                                    new_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg(P* addr, T new_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;P&gt;::type DecayedP;
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      // atomic_xchg is only available in SEQ_CST flavour.
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<span class="line-modified">!     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">!                                                          new_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">!   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
      verify_types&lt;decorators, T&gt;();
      typedef typename Decay&lt;T&gt;::type DecayedT;
      DecayedT new_decayed_value = new_value;
      // atomic_xchg is only available in SEQ_CST flavour.
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
                                               (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
                                                INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<span class="line-modified">!     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);</span>
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
    inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1306,16 ***</span>
    inline oop resolve(oop obj) {
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
      return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
    }
  
<span class="line-removed">-   template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">-   inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed">-     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;</span>
<span class="line-removed">-     return PreRuntimeDispatch::equals&lt;expanded_decorators&gt;(o1, o2);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Infer the type that should be returned from an Access::oop_load.
    template &lt;typename P, DecoratorSet decorators&gt;
    class OopLoadProxy: public StackObj {
    private:
      P *const _addr;
<span class="line-new-header">--- 1271,10 ---</span>
</pre>
<center><a href="access.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
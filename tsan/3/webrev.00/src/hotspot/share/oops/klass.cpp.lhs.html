<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/klass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 28 #include &quot;classfile/dictionary.hpp&quot;
 29 #include &quot;classfile/javaClasses.hpp&quot;
<a name="2" id="anc2"></a>
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 34 #include &quot;memory/heapInspection.hpp&quot;</span>
 35 #include &quot;memory/heapShared.hpp&quot;
 36 #include &quot;memory/metadataFactory.hpp&quot;
 37 #include &quot;memory/metaspaceClosure.hpp&quot;
 38 #include &quot;memory/metaspaceShared.hpp&quot;
 39 #include &quot;memory/oopFactory.hpp&quot;
 40 #include &quot;memory/resourceArea.hpp&quot;
<a name="4" id="anc4"></a>
 41 #include &quot;oops/compressedOops.inline.hpp&quot;
 42 #include &quot;oops/instanceKlass.hpp&quot;
 43 #include &quot;oops/klass.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;oops/oopHandle.inline.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 48 #include &quot;runtime/orderAccess.hpp&quot;</span>
 49 #include &quot;utilities/macros.hpp&quot;
<a name="6" id="anc6"></a>
 50 #include &quot;utilities/stack.inline.hpp&quot;
 51 
 52 void Klass::set_java_mirror(Handle m) {
 53   assert(!m.is_null(), &quot;New mirror should never be null.&quot;);
 54   assert(_java_mirror.resolve() == NULL, &quot;should only be used to initialize mirror&quot;);
 55   _java_mirror = class_loader_data()-&gt;add_handle(m);
 56 }
 57 
<a name="7" id="anc7"></a><span class="line-removed"> 58 oop Klass::java_mirror() const {</span>
<span class="line-removed"> 59   return _java_mirror.resolve();</span>
<span class="line-removed"> 60 }</span>
<span class="line-removed"> 61 </span>
 62 oop Klass::java_mirror_no_keepalive() const {
 63   return _java_mirror.peek();
 64 }
 65 
 66 bool Klass::is_cloneable() const {
 67   return _access_flags.is_cloneable_fast() ||
 68          is_subtype_of(SystemDictionary::Cloneable_klass());
 69 }
 70 
 71 void Klass::set_is_cloneable() {
 72   if (name() == vmSymbols::java_lang_invoke_MemberName()) {
 73     assert(is_final(), &quot;no subclasses allowed&quot;);
 74     // MemberName cloning should not be intrinsified and always happen in JVM_Clone.
 75   } else if (is_instance_klass() &amp;&amp; InstanceKlass::cast(this)-&gt;reference_type() != REF_NONE) {
 76     // Reference cloning should not be intrinsified and always happen in JVM_Clone.
 77   } else {
 78     _access_flags.set_is_cloneable_fast();
 79   }
 80 }
 81 
 82 void Klass::set_name(Symbol* n) {
 83   _name = n;
 84   if (_name != NULL) _name-&gt;increment_refcount();
 85 }
 86 
 87 bool Klass::is_subclass_of(const Klass* k) const {
 88   // Run up the super chain and check
 89   if (this == k) return true;
 90 
 91   Klass* t = const_cast&lt;Klass*&gt;(this)-&gt;super();
 92 
 93   while (t != NULL) {
 94     if (t == k) return true;
 95     t = t-&gt;super();
 96   }
 97   return false;
 98 }
 99 
100 bool Klass::search_secondary_supers(Klass* k) const {
101   // Put some extra logic here out-of-line, before the search proper.
102   // This cuts down the size of the inline method.
103 
104   // This is necessary, since I am never in my own secondary_super list.
105   if (this == k)
106     return true;
107   // Scan the array-of-objects for a match
108   int cnt = secondary_supers()-&gt;length();
109   for (int i = 0; i &lt; cnt; i++) {
110     if (secondary_supers()-&gt;at(i) == k) {
111       ((Klass*)this)-&gt;set_secondary_super_cache(k);
112       return true;
113     }
114   }
115   return false;
116 }
117 
118 // Return self, except for abstract classes with exactly 1
119 // implementor.  Then return the 1 concrete implementation.
120 Klass *Klass::up_cast_abstract() {
121   Klass *r = this;
122   while( r-&gt;is_abstract() ) {   // Receiver is abstract?
123     Klass *s = r-&gt;subklass();   // Check for exactly 1 subklass
124     if (s == NULL || s-&gt;next_sibling() != NULL) // Oops; wrong count; give up
125       return this;              // Return &#39;this&#39; as a no-progress flag
126     r = s;                    // Loop till find concrete class
127   }
128   return r;                   // Return the 1 concrete class
129 }
130 
131 // Find LCA in class hierarchy
132 Klass *Klass::LCA( Klass *k2 ) {
133   Klass *k1 = this;
134   while( 1 ) {
135     if( k1-&gt;is_subtype_of(k2) ) return k2;
136     if( k2-&gt;is_subtype_of(k1) ) return k1;
137     k1 = k1-&gt;super();
138     k2 = k2-&gt;super();
139   }
140 }
141 
142 
143 void Klass::check_valid_for_instantiation(bool throwError, TRAPS) {
144   ResourceMark rm(THREAD);
145   THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
146             : vmSymbols::java_lang_InstantiationException(), external_name());
147 }
148 
149 
150 void Klass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) {
151   ResourceMark rm(THREAD);
152   assert(s != NULL, &quot;Throw NPE!&quot;);
153   THROW_MSG(vmSymbols::java_lang_ArrayStoreException(),
154             err_msg(&quot;arraycopy: source type %s is not an array&quot;, s-&gt;klass()-&gt;external_name()));
155 }
156 
157 
158 void Klass::initialize(TRAPS) {
159   ShouldNotReachHere();
160 }
161 
162 Klass* Klass::find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
163 #ifdef ASSERT
164   tty-&gt;print_cr(&quot;Error: find_field called on a klass oop.&quot;
165                 &quot; Likely error: reflection method does not correctly&quot;
166                 &quot; wrap return value in a mirror object.&quot;);
167 #endif
168   ShouldNotReachHere();
169   return NULL;
170 }
171 
172 Method* Klass::uncached_lookup_method(const Symbol* name, const Symbol* signature,
173                                       OverpassLookupMode overpass_mode,
174                                       PrivateLookupMode private_mode) const {
175 #ifdef ASSERT
176   tty-&gt;print_cr(&quot;Error: uncached_lookup_method called on a klass oop.&quot;
177                 &quot; Likely error: reflection method does not correctly&quot;
178                 &quot; wrap return value in a mirror object.&quot;);
179 #endif
180   ShouldNotReachHere();
181   return NULL;
182 }
183 
184 void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {
185   return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);
186 }
187 
188 // &quot;Normal&quot; instantiation is preceeded by a MetaspaceObj allocation
189 // which zeros out memory - calloc equivalent.
190 // The constructor is also used from CppVtableCloner,
191 // which doesn&#39;t zero out the memory before calling the constructor.
192 // Need to set the _java_mirror field explicitly to not hit an assert that the field
193 // should be NULL before setting it.
194 Klass::Klass(KlassID id) : _id(id),
195                            _java_mirror(NULL),
<a name="8" id="anc8"></a><span class="line-modified">196                            _prototype_header(markOopDesc::prototype()),</span>
197                            _shared_class_path_index(-1) {
198   CDS_ONLY(_shared_class_flags = 0;)
199   CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)
200   _primary_supers[0] = this;
201   set_super_check_offset(in_bytes(primary_supers_offset()));
202 }
203 
204 jint Klass::array_layout_helper(BasicType etype) {
205   assert(etype &gt;= T_BOOLEAN &amp;&amp; etype &lt;= T_OBJECT, &quot;valid etype&quot;);
206   // Note that T_ARRAY is not allowed here.
207   int  hsize = arrayOopDesc::base_offset_in_bytes(etype);
208   int  esize = type2aelembytes(etype);
209   bool isobj = (etype == T_OBJECT);
210   int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;
211   int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));
212 
213   assert(lh &lt; (int)_lh_neutral_value, &quot;must look like an array layout&quot;);
214   assert(layout_helper_is_array(lh), &quot;correct kind&quot;);
215   assert(layout_helper_is_objArray(lh) == isobj, &quot;correct kind&quot;);
216   assert(layout_helper_is_typeArray(lh) == !isobj, &quot;correct kind&quot;);
217   assert(layout_helper_header_size(lh) == hsize, &quot;correct decode&quot;);
218   assert(layout_helper_element_type(lh) == etype, &quot;correct decode&quot;);
219   assert(1 &lt;&lt; layout_helper_log2_element_size(lh) == esize, &quot;correct decode&quot;);
220 
221   return lh;
222 }
223 
224 bool Klass::can_be_primary_super_slow() const {
225   if (super() == NULL)
226     return true;
227   else if (super()-&gt;super_depth() &gt;= primary_super_limit()-1)
228     return false;
229   else
230     return true;
231 }
232 
233 void Klass::initialize_supers(Klass* k, Array&lt;InstanceKlass*&gt;* transitive_interfaces, TRAPS) {
234   if (k == NULL) {
235     set_super(NULL);
236     _primary_supers[0] = this;
237     assert(super_depth() == 0, &quot;Object must already be initialized properly&quot;);
238   } else if (k != super() || k == SystemDictionary::Object_klass()) {
239     assert(super() == NULL || super() == SystemDictionary::Object_klass(),
240            &quot;initialize this only once to a non-trivial value&quot;);
241     set_super(k);
242     Klass* sup = k;
243     int sup_depth = sup-&gt;super_depth();
244     juint my_depth  = MIN2(sup_depth + 1, (int)primary_super_limit());
245     if (!can_be_primary_super_slow())
246       my_depth = primary_super_limit();
247     for (juint i = 0; i &lt; my_depth; i++) {
248       _primary_supers[i] = sup-&gt;_primary_supers[i];
249     }
250     Klass* *super_check_cell;
251     if (my_depth &lt; primary_super_limit()) {
252       _primary_supers[my_depth] = this;
253       super_check_cell = &amp;_primary_supers[my_depth];
254     } else {
255       // Overflow of the primary_supers array forces me to be secondary.
256       super_check_cell = &amp;_secondary_super_cache;
257     }
258     set_super_check_offset((address)super_check_cell - (address) this);
259 
260 #ifdef ASSERT
261     {
262       juint j = super_depth();
263       assert(j == my_depth, &quot;computed accessor gets right answer&quot;);
264       Klass* t = this;
265       while (!t-&gt;can_be_primary_super()) {
266         t = t-&gt;super();
267         j = t-&gt;super_depth();
268       }
269       for (juint j1 = j+1; j1 &lt; primary_super_limit(); j1++) {
270         assert(primary_super_of_depth(j1) == NULL, &quot;super list padding&quot;);
271       }
272       while (t != NULL) {
273         assert(primary_super_of_depth(j) == t, &quot;super list initialization&quot;);
274         t = t-&gt;super();
275         --j;
276       }
277       assert(j == (juint)-1, &quot;correct depth count&quot;);
278     }
279 #endif
280   }
281 
282   if (secondary_supers() == NULL) {
283 
284     // Now compute the list of secondary supertypes.
285     // Secondaries can occasionally be on the super chain,
286     // if the inline &quot;_primary_supers&quot; array overflows.
287     int extras = 0;
288     Klass* p;
289     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
290       ++extras;
291     }
292 
293     ResourceMark rm(THREAD);  // need to reclaim GrowableArrays allocated below
294 
295     // Compute the &quot;real&quot; non-extra secondaries.
296     GrowableArray&lt;Klass*&gt;* secondaries = compute_secondary_supers(extras, transitive_interfaces);
297     if (secondaries == NULL) {
298       // secondary_supers set by compute_secondary_supers
299       return;
300     }
301 
302     GrowableArray&lt;Klass*&gt;* primaries = new GrowableArray&lt;Klass*&gt;(extras);
303 
304     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
305       int i;                    // Scan for overflow primaries being duplicates of 2nd&#39;arys
306 
307       // This happens frequently for very deeply nested arrays: the
308       // primary superclass chain overflows into the secondary.  The
309       // secondary list contains the element_klass&#39;s secondaries with
310       // an extra array dimension added.  If the element_klass&#39;s
311       // secondary list already contains some primary overflows, they
312       // (with the extra level of array-ness) will collide with the
313       // normal primary superclass overflows.
314       for( i = 0; i &lt; secondaries-&gt;length(); i++ ) {
315         if( secondaries-&gt;at(i) == p )
316           break;
317       }
318       if( i &lt; secondaries-&gt;length() )
319         continue;               // It&#39;s a dup, don&#39;t put it in
320       primaries-&gt;push(p);
321     }
322     // Combine the two arrays into a metadata object to pack the array.
323     // The primaries are added in the reverse order, then the secondaries.
324     int new_length = primaries-&gt;length() + secondaries-&gt;length();
325     Array&lt;Klass*&gt;* s2 = MetadataFactory::new_array&lt;Klass*&gt;(
326                                        class_loader_data(), new_length, CHECK);
327     int fill_p = primaries-&gt;length();
328     for (int j = 0; j &lt; fill_p; j++) {
329       s2-&gt;at_put(j, primaries-&gt;pop());  // add primaries in reverse order.
330     }
331     for( int j = 0; j &lt; secondaries-&gt;length(); j++ ) {
332       s2-&gt;at_put(j+fill_p, secondaries-&gt;at(j));  // add secondaries on the end.
333     }
334 
335   #ifdef ASSERT
336       // We must not copy any NULL placeholders left over from bootstrap.
337     for (int j = 0; j &lt; s2-&gt;length(); j++) {
338       assert(s2-&gt;at(j) != NULL, &quot;correct bootstrapping order&quot;);
339     }
340   #endif
341 
342     set_secondary_supers(s2);
343   }
344 }
345 
346 GrowableArray&lt;Klass*&gt;* Klass::compute_secondary_supers(int num_extra_slots,
347                                                        Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
348   assert(num_extra_slots == 0, &quot;override for complex klasses&quot;);
349   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
350   set_secondary_supers(Universe::the_empty_klass_array());
351   return NULL;
352 }
353 
354 
355 // superklass links
356 InstanceKlass* Klass::superklass() const {
357   assert(super() == NULL || super()-&gt;is_instance_klass(), &quot;must be instance klass&quot;);
358   return _super == NULL ? NULL : InstanceKlass::cast(_super);
359 }
360 
361 // subklass links.  Used by the compiler (and vtable initialization)
362 // May be cleaned concurrently, so must use the Compile_lock.
363 // The log parameter is for clean_weak_klass_links to report unlinked classes.
364 Klass* Klass::subklass(bool log) const {
365   // Need load_acquire on the _subklass, because it races with inserts that
366   // publishes freshly initialized data.
<a name="9" id="anc9"></a><span class="line-modified">367   for (Klass* chain = OrderAccess::load_acquire(&amp;_subklass);</span>
368        chain != NULL;
369        // Do not need load_acquire on _next_sibling, because inserts never
370        // create _next_sibling edges to dead data.
371        chain = Atomic::load(&amp;chain-&gt;_next_sibling))
372   {
373     if (chain-&gt;is_loader_alive()) {
374       return chain;
375     } else if (log) {
376       if (log_is_enabled(Trace, class, unload)) {
377         ResourceMark rm;
378         log_trace(class, unload)(&quot;unlinking class (subclass): %s&quot;, chain-&gt;external_name());
379       }
380     }
381   }
382   return NULL;
383 }
384 
385 Klass* Klass::next_sibling(bool log) const {
386   // Do not need load_acquire on _next_sibling, because inserts never
387   // create _next_sibling edges to dead data.
388   for (Klass* chain = Atomic::load(&amp;_next_sibling);
389        chain != NULL;
390        chain = Atomic::load(&amp;chain-&gt;_next_sibling)) {
391     // Only return alive klass, there may be stale klass
392     // in this chain if cleaned concurrently.
393     if (chain-&gt;is_loader_alive()) {
394       return chain;
395     } else if (log) {
396       if (log_is_enabled(Trace, class, unload)) {
397         ResourceMark rm;
398         log_trace(class, unload)(&quot;unlinking class (sibling): %s&quot;, chain-&gt;external_name());
399       }
400     }
401   }
402   return NULL;
403 }
404 
405 void Klass::set_subklass(Klass* s) {
406   assert(s != this, &quot;sanity check&quot;);
<a name="10" id="anc10"></a><span class="line-modified">407   OrderAccess::release_store(&amp;_subklass, s);</span>
408 }
409 
410 void Klass::set_next_sibling(Klass* s) {
411   assert(s != this, &quot;sanity check&quot;);
412   // Does not need release semantics. If used by cleanup, it will link to
413   // already safely published data, and if used by inserts, will be published
414   // safely using cmpxchg.
<a name="11" id="anc11"></a><span class="line-modified">415   Atomic::store(s, &amp;_next_sibling);</span>
416 }
417 
418 void Klass::append_to_sibling_list() {
419   assert_locked_or_safepoint(Compile_lock);
420   debug_only(verify();)
421   // add ourselves to superklass&#39; subklass list
422   InstanceKlass* super = superklass();
423   if (super == NULL) return;        // special case: class Object
424   assert((!super-&gt;is_interface()    // interfaces cannot be supers
425           &amp;&amp; (super-&gt;superklass() == NULL || !is_interface())),
426          &quot;an interface can only be a subklass of Object&quot;);
427 
428   // Make sure there is no stale subklass head
429   super-&gt;clean_subklass();
430 
431   for (;;) {
<a name="12" id="anc12"></a><span class="line-modified">432     Klass* prev_first_subklass = OrderAccess::load_acquire(&amp;_super-&gt;_subklass);</span>
433     if (prev_first_subklass != NULL) {
434       // set our sibling to be the superklass&#39; previous first subklass
435       assert(prev_first_subklass-&gt;is_loader_alive(), &quot;May not attach not alive klasses&quot;);
436       set_next_sibling(prev_first_subklass);
437     }
438     // Note that the prev_first_subklass is always alive, meaning no sibling_next links
439     // are ever created to not alive klasses. This is an important invariant of the lock-free
440     // cleaning protocol, that allows us to safely unlink dead klasses from the sibling list.
<a name="13" id="anc13"></a><span class="line-modified">441     if (Atomic::cmpxchg(this, &amp;super-&gt;_subklass, prev_first_subklass) == prev_first_subklass) {</span>
442       return;
443     }
444   }
445   debug_only(verify();)
446 }
447 
448 void Klass::clean_subklass() {
449   for (;;) {
450     // Need load_acquire, due to contending with concurrent inserts
<a name="14" id="anc14"></a><span class="line-modified">451     Klass* subklass = OrderAccess::load_acquire(&amp;_subklass);</span>
452     if (subklass == NULL || subklass-&gt;is_loader_alive()) {
453       return;
454     }
455     // Try to fix _subklass until it points at something not dead.
<a name="15" id="anc15"></a><span class="line-modified">456     Atomic::cmpxchg(subklass-&gt;next_sibling(), &amp;_subklass, subklass);</span>
457   }
458 }
459 
460 void Klass::clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses) {
461   if (!ClassUnloading || !unloading_occurred) {
462     return;
463   }
464 
465   Klass* root = SystemDictionary::Object_klass();
466   Stack&lt;Klass*, mtGC&gt; stack;
467 
468   stack.push(root);
469   while (!stack.is_empty()) {
470     Klass* current = stack.pop();
471 
472     assert(current-&gt;is_loader_alive(), &quot;just checking, this should be live&quot;);
473 
474     // Find and set the first alive subklass
475     Klass* sub = current-&gt;subklass(true);
476     current-&gt;clean_subklass();
477     if (sub != NULL) {
478       stack.push(sub);
479     }
480 
481     // Find and set the first alive sibling
482     Klass* sibling = current-&gt;next_sibling(true);
483     current-&gt;set_next_sibling(sibling);
484     if (sibling != NULL) {
485       stack.push(sibling);
486     }
487 
488     // Clean the implementors list and method data.
489     if (clean_alive_klasses &amp;&amp; current-&gt;is_instance_klass()) {
490       InstanceKlass* ik = InstanceKlass::cast(current);
491       ik-&gt;clean_weak_instanceklass_links();
492 
493       // JVMTI RedefineClasses creates previous versions that are not in
494       // the class hierarchy, so process them here.
495       while ((ik = ik-&gt;previous_versions()) != NULL) {
496         ik-&gt;clean_weak_instanceklass_links();
497       }
498     }
499   }
500 }
501 
502 void Klass::metaspace_pointers_do(MetaspaceClosure* it) {
503   if (log_is_enabled(Trace, cds)) {
504     ResourceMark rm;
505     log_trace(cds)(&quot;Iter(Klass): %p (%s)&quot;, this, external_name());
506   }
507 
508   it-&gt;push(&amp;_name);
509   it-&gt;push(&amp;_secondary_super_cache);
510   it-&gt;push(&amp;_secondary_supers);
511   for (int i = 0; i &lt; _primary_super_limit; i++) {
512     it-&gt;push(&amp;_primary_supers[i]);
513   }
514   it-&gt;push(&amp;_super);
515   it-&gt;push((Klass**)&amp;_subklass);
516   it-&gt;push((Klass**)&amp;_next_sibling);
517   it-&gt;push(&amp;_next_link);
518 
519   vtableEntry* vt = start_of_vtable();
520   for (int i=0; i&lt;vtable_length(); i++) {
521     it-&gt;push(vt[i].method_addr());
522   }
523 }
524 
525 void Klass::remove_unshareable_info() {
<a name="16" id="anc16"></a><span class="line-modified">526   assert (DumpSharedSpaces, &quot;only called for DumpSharedSpaces&quot;);</span>

527   JFR_ONLY(REMOVE_ID(this);)
528   if (log_is_enabled(Trace, cds, unshareable)) {
529     ResourceMark rm;
530     log_trace(cds, unshareable)(&quot;remove: %s&quot;, external_name());
531   }
532 
533   set_subklass(NULL);
534   set_next_sibling(NULL);
535   set_next_link(NULL);
536 
537   // Null out class_loader_data because we don&#39;t share that yet.
538   set_class_loader_data(NULL);
539   set_is_shared();
540 }
541 
542 void Klass::remove_java_mirror() {
<a name="17" id="anc17"></a><span class="line-modified">543   assert (DumpSharedSpaces, &quot;only called for DumpSharedSpaces&quot;);</span>
544   if (log_is_enabled(Trace, cds, unshareable)) {
545     ResourceMark rm;
546     log_trace(cds, unshareable)(&quot;remove java_mirror: %s&quot;, external_name());
547   }
548   // Just null out the mirror.  The class_loader_data() no longer exists.
549   _java_mirror = NULL;
550 }
551 
552 void Klass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
553   assert(is_klass(), &quot;ensure C++ vtable is restored&quot;);
554   assert(is_shared(), &quot;must be set&quot;);
555   JFR_ONLY(RESTORE_ID(this);)
556   if (log_is_enabled(Trace, cds, unshareable)) {
<a name="18" id="anc18"></a><span class="line-modified">557     ResourceMark rm;</span>
558     log_trace(cds, unshareable)(&quot;restore: %s&quot;, external_name());
559   }
560 
561   // If an exception happened during CDS restore, some of these fields may already be
562   // set.  We leave the class on the CLD list, even if incomplete so that we don&#39;t
563   // modify the CLD list outside a safepoint.
564   if (class_loader_data() == NULL) {
565     // Restore class_loader_data to the null class loader data
566     set_class_loader_data(loader_data);
567 
568     // Add to null class loader list first before creating the mirror
569     // (same order as class file parsing)
570     loader_data-&gt;add_class(this);
571   }
572 
573   Handle loader(THREAD, loader_data-&gt;class_loader());
574   ModuleEntry* module_entry = NULL;
575   Klass* k = this;
576   if (k-&gt;is_objArray_klass()) {
577     k = ObjArrayKlass::cast(k)-&gt;bottom_klass();
578   }
579   // Obtain klass&#39; module.
580   if (k-&gt;is_instance_klass()) {
581     InstanceKlass* ik = (InstanceKlass*) k;
582     module_entry = ik-&gt;module();
583   } else {
584     module_entry = ModuleEntryTable::javabase_moduleEntry();
585   }
586   // Obtain java.lang.Module, if available
587   Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL));
588 
589   if (this-&gt;has_raw_archived_mirror()) {
<a name="19" id="anc19"></a><span class="line-modified">590     ResourceMark rm;</span>
591     log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
592     if (HeapShared::open_archive_heap_region_mapped()) {
593       bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
594                                                               protection_domain,
595                                                               CHECK);
596       if (present) {
597         return;
598       }
599     }
600 
601     // No archived mirror data
602     log_debug(cds, mirror)(&quot;No archived mirror data for %s&quot;, external_name());
603     _java_mirror = NULL;
604     this-&gt;clear_has_raw_archived_mirror();
605   }
606 
607   // Only recreate it if not present.  A previous attempt to restore may have
608   // gotten an OOM later but keep the mirror if it was created.
609   if (java_mirror() == NULL) {
610     log_trace(cds, mirror)(&quot;Recreate mirror for %s&quot;, external_name());
611     java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, CHECK);
612   }
613 }
614 
615 #if INCLUDE_CDS_JAVA_HEAP
616 // Used at CDS dump time to access the archived mirror. No GC barrier.
617 oop Klass::archived_java_mirror_raw() {
618   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
619   return CompressedOops::decode(_archived_mirror);
620 }
621 
622 narrowOop Klass::archived_java_mirror_raw_narrow() {
623   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
624   return _archived_mirror;
625 }
626 
627 // No GC barrier
628 void Klass::set_archived_java_mirror_raw(oop m) {
629   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
630   _archived_mirror = CompressedOops::encode(m);
631 }
632 #endif // INCLUDE_CDS_JAVA_HEAP
633 
634 Klass* Klass::array_klass_or_null(int rank) {
635   EXCEPTION_MARK;
636   // No exception can be thrown by array_klass_impl when called with or_null == true.
637   // (In anycase, the execption mark will fail if it do so)
638   return array_klass_impl(true, rank, THREAD);
639 }
640 
641 
642 Klass* Klass::array_klass_or_null() {
643   EXCEPTION_MARK;
644   // No exception can be thrown by array_klass_impl when called with or_null == true.
645   // (In anycase, the execption mark will fail if it do so)
646   return array_klass_impl(true, THREAD);
647 }
648 
649 
650 Klass* Klass::array_klass_impl(bool or_null, int rank, TRAPS) {
651   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
652   return NULL;
653 }
654 
655 
656 Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
657   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
658   return NULL;
659 }
660 
661 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
662   if (length &gt; max_length) {
663     if (!THREAD-&gt;in_retryable_allocation()) {
664       report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);
665       JvmtiExport::post_array_size_exhausted();
666       THROW_OOP(Universe::out_of_memory_error_array_size());
667     } else {
668       THROW_OOP(Universe::out_of_memory_error_retry());
669     }
670   } else if (length &lt; 0) {
671     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
672   }
673 }
674 
<a name="20" id="anc20"></a><span class="line-removed">675 oop Klass::class_loader() const { return class_loader_data()-&gt;class_loader(); }</span>
<span class="line-removed">676 </span>
677 // In product mode, this function doesn&#39;t have virtual function calls so
678 // there might be some performance advantage to handling InstanceKlass here.
679 const char* Klass::external_name() const {
680   if (is_instance_klass()) {
681     const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
682     if (ik-&gt;is_unsafe_anonymous()) {
683       char addr_buf[20];
684       jio_snprintf(addr_buf, 20, &quot;/&quot; INTPTR_FORMAT, p2i(ik));
685       size_t addr_len = strlen(addr_buf);
686       size_t name_len = name()-&gt;utf8_length();
687       char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);
688       name()-&gt;as_klass_external_name(result, (int) name_len + 1);
689       assert(strlen(result) == name_len, &quot;&quot;);
690       strcpy(result + name_len, addr_buf);
691       assert(strlen(result) == name_len + addr_len, &quot;&quot;);
692       return result;
693     }
694   }
695   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
696   return name()-&gt;as_klass_external_name();
697 }
698 
699 const char* Klass::signature_name() const {
700   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
701   return name()-&gt;as_C_string();
702 }
703 
704 const char* Klass::external_kind() const {
705   if (is_interface()) return &quot;interface&quot;;
706   if (is_abstract()) return &quot;abstract class&quot;;
707   return &quot;class&quot;;
708 }
709 
710 // Unless overridden, modifier_flags is 0.
711 jint Klass::compute_modifier_flags(TRAPS) const {
712   return 0;
713 }
714 
715 int Klass::atomic_incr_biased_lock_revocation_count() {
<a name="21" id="anc21"></a><span class="line-modified">716   return (int) Atomic::add(1, &amp;_biased_lock_revocation_count);</span>
717 }
718 
719 // Unless overridden, jvmti_class_status has no flags set.
720 jint Klass::jvmti_class_status() const {
721   return 0;
722 }
723 
724 
725 // Printing
726 
727 void Klass::print_on(outputStream* st) const {
728   ResourceMark rm;
729   // print title
730   st-&gt;print(&quot;%s&quot;, internal_name());
731   print_address_on(st);
732   st-&gt;cr();
733 }
734 
<a name="22" id="anc22"></a>

735 void Klass::oop_print_on(oop obj, outputStream* st) {
<a name="23" id="anc23"></a><span class="line-removed">736   ResourceMark rm;</span>
737   // print title
738   st-&gt;print_cr(&quot;%s &quot;, internal_name());
739   obj-&gt;print_address_on(st);
740 
741   if (WizardMode) {
742      // print header
<a name="24" id="anc24"></a><span class="line-modified">743      obj-&gt;mark()-&gt;print_on(st);</span>



744   }
745 
746   // print class
<a name="25" id="anc25"></a><span class="line-modified">747   st-&gt;print(&quot; - klass: &quot;);</span>
748   obj-&gt;klass()-&gt;print_value_on(st);
749   st-&gt;cr();
750 }
751 
752 void Klass::oop_print_value_on(oop obj, outputStream* st) {
753   // print title
754   ResourceMark rm;              // Cannot print in debug mode without this
755   st-&gt;print(&quot;%s&quot;, internal_name());
756   obj-&gt;print_address_on(st);
757 }
758 
<a name="26" id="anc26"></a><span class="line-removed">759 #if INCLUDE_SERVICES</span>
<span class="line-removed">760 // Size Statistics</span>
<span class="line-removed">761 void Klass::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">762   sz-&gt;_klass_bytes = sz-&gt;count(this);</span>
<span class="line-removed">763   sz-&gt;_mirror_bytes = sz-&gt;count(java_mirror());</span>
<span class="line-removed">764   sz-&gt;_secondary_supers_bytes = sz-&gt;count_array(secondary_supers());</span>
<span class="line-removed">765 </span>
<span class="line-removed">766   sz-&gt;_ro_bytes += sz-&gt;_secondary_supers_bytes;</span>
<span class="line-removed">767   sz-&gt;_rw_bytes += sz-&gt;_klass_bytes + sz-&gt;_mirror_bytes;</span>
<span class="line-removed">768 }</span>
<span class="line-removed">769 #endif // INCLUDE_SERVICES</span>
<span class="line-removed">770 </span>
771 // Verification
772 
773 void Klass::verify_on(outputStream* st) {
774 
775   // This can be expensive, but it is worth checking that this klass is actually
776   // in the CLD graph but not in production.
777   assert(Metaspace::contains((address)this), &quot;Should be&quot;);
778 
779   guarantee(this-&gt;is_klass(),&quot;should be klass&quot;);
780 
781   if (super() != NULL) {
782     guarantee(super()-&gt;is_klass(), &quot;should be klass&quot;);
783   }
784   if (secondary_super_cache() != NULL) {
785     Klass* ko = secondary_super_cache();
786     guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
787   }
788   for ( uint i = 0; i &lt; primary_super_limit(); i++ ) {
789     Klass* ko = _primary_supers[i];
790     if (ko != NULL) {
791       guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
792     }
793   }
794 
795   if (java_mirror_no_keepalive() != NULL) {
796     guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), &quot;should be instance&quot;);
797   }
798 }
799 
800 void Klass::oop_verify_on(oop obj, outputStream* st) {
801   guarantee(oopDesc::is_oop(obj),  &quot;should be oop&quot;);
802   guarantee(obj-&gt;klass()-&gt;is_klass(), &quot;klass field is not a klass&quot;);
803 }
804 
<a name="27" id="anc27"></a><span class="line-removed">805 Klass* Klass::decode_klass_raw(narrowKlass narrow_klass) {</span>
<span class="line-removed">806   return (Klass*)(void*)( (uintptr_t)Universe::narrow_klass_base() +</span>
<span class="line-removed">807                          ((uintptr_t)narrow_klass &lt;&lt; Universe::narrow_klass_shift()));</span>
<span class="line-removed">808 }</span>
<span class="line-removed">809 </span>
810 bool Klass::is_valid(Klass* k) {
811   if (!is_aligned(k, sizeof(MetaWord))) return false;
812   if ((size_t)k &lt; os::min_page_size()) return false;
813 
814   if (!os::is_readable_range(k, k + 1)) return false;
<a name="28" id="anc28"></a><span class="line-modified">815   if (!MetaspaceUtils::is_range_in_committed(k, k + 1)) return false;</span>
816 
817   if (!Symbol::is_valid(k-&gt;name())) return false;
818   return ClassLoaderDataGraph::is_valid(k-&gt;class_loader_data());
819 }
820 
<a name="29" id="anc29"></a><span class="line-removed">821 klassVtable Klass::vtable() const {</span>
<span class="line-removed">822   return klassVtable(const_cast&lt;Klass*&gt;(this), start_of_vtable(), vtable_length() / vtableEntry::size());</span>
<span class="line-removed">823 }</span>
<span class="line-removed">824 </span>
<span class="line-removed">825 vtableEntry* Klass::start_of_vtable() const {</span>
<span class="line-removed">826   return (vtableEntry*) ((address)this + in_bytes(vtable_start_offset()));</span>
<span class="line-removed">827 }</span>
<span class="line-removed">828 </span>
829 Method* Klass::method_at_vtable(int index)  {
830 #ifndef PRODUCT
831   assert(index &gt;= 0, &quot;valid vtable index&quot;);
832   if (DebugVtables) {
833     verify_vtable_index(index);
834   }
835 #endif
836   return start_of_vtable()[index].method();
837 }
838 
<a name="30" id="anc30"></a><span class="line-removed">839 ByteSize Klass::vtable_start_offset() {</span>
<span class="line-removed">840   return in_ByteSize(InstanceKlass::header_size() * wordSize);</span>
<span class="line-removed">841 }</span>
842 
843 #ifndef PRODUCT
844 
845 bool Klass::verify_vtable_index(int i) {
846   int limit = vtable_length()/vtableEntry::size();
847   assert(i &gt;= 0 &amp;&amp; i &lt; limit, &quot;index %d out of bounds %d&quot;, i, limit);
848   return true;
849 }
850 
851 #endif // PRODUCT
852 
853 // Caller needs ResourceMark
854 // joint_in_module_of_loader provides an optimization if 2 classes are in
855 // the same module to succinctly print out relevant information about their
856 // module name and class loader&#39;s name_and_id for error messages.
857 // Format:
858 //   &lt;fully-qualified-external-class-name1&gt; and &lt;fully-qualified-external-class-name2&gt;
859 //                      are in module &lt;module-name&gt;[@&lt;version&gt;]
860 //                      of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
861 const char* Klass::joint_in_module_of_loader(const Klass* class2, bool include_parent_loader) const {
862   assert(module() == class2-&gt;module(), &quot;classes do not have the same module&quot;);
863   const char* class1_name = external_name();
864   size_t len = strlen(class1_name) + 1;
865 
866   const char* class2_description = class2-&gt;class_in_module_of_loader(true, include_parent_loader);
867   len += strlen(class2_description);
868 
869   len += strlen(&quot; and &quot;);
870 
871   char* joint_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
872 
873   // Just return the FQN if error when allocating string
874   if (joint_description == NULL) {
875     return class1_name;
876   }
877 
878   jio_snprintf(joint_description, len, &quot;%s and %s&quot;,
879                class1_name,
880                class2_description);
881 
882   return joint_description;
883 }
884 
885 // Caller needs ResourceMark
886 // class_in_module_of_loader provides a standard way to include
887 // relevant information about a class, such as its module name as
888 // well as its class loader&#39;s name_and_id, in error messages and logging.
889 // Format:
890 //   &lt;fully-qualified-external-class-name&gt; is in module &lt;module-name&gt;[@&lt;version&gt;]
891 //                                         of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
892 const char* Klass::class_in_module_of_loader(bool use_are, bool include_parent_loader) const {
893   // 1. fully qualified external name of class
894   const char* klass_name = external_name();
895   size_t len = strlen(klass_name) + 1;
896 
897   // 2. module name + @version
898   const char* module_name = &quot;&quot;;
899   const char* version = &quot;&quot;;
900   bool has_version = false;
901   bool module_is_named = false;
902   const char* module_name_phrase = &quot;&quot;;
903   const Klass* bottom_klass = is_objArray_klass() ?
904                                 ObjArrayKlass::cast(this)-&gt;bottom_klass() : this;
905   if (bottom_klass-&gt;is_instance_klass()) {
906     ModuleEntry* module = InstanceKlass::cast(bottom_klass)-&gt;module();
907     if (module-&gt;is_named()) {
908       module_is_named = true;
909       module_name_phrase = &quot;module &quot;;
910       module_name = module-&gt;name()-&gt;as_C_string();
911       len += strlen(module_name);
912       // Use version if exists and is not a jdk module
913       if (module-&gt;should_show_version()) {
914         has_version = true;
915         version = module-&gt;version()-&gt;as_C_string();
916         // Include stlen(version) + 1 for the &quot;@&quot;
917         len += strlen(version) + 1;
918       }
919     } else {
920       module_name = UNNAMED_MODULE;
921       len += UNNAMED_MODULE_LEN;
922     }
923   } else {
924     // klass is an array of primitives, module is java.base
925     module_is_named = true;
926     module_name_phrase = &quot;module &quot;;
927     module_name = JAVA_BASE_NAME;
928     len += JAVA_BASE_NAME_LEN;
929   }
930 
931   // 3. class loader&#39;s name_and_id
932   ClassLoaderData* cld = class_loader_data();
933   assert(cld != NULL, &quot;class_loader_data should not be null&quot;);
934   const char* loader_name_and_id = cld-&gt;loader_name_and_id();
935   len += strlen(loader_name_and_id);
936 
937   // 4. include parent loader information
938   const char* parent_loader_phrase = &quot;&quot;;
939   const char* parent_loader_name_and_id = &quot;&quot;;
940   if (include_parent_loader &amp;&amp;
941       !cld-&gt;is_builtin_class_loader_data()) {
942     oop parent_loader = java_lang_ClassLoader::parent(class_loader());
943     ClassLoaderData *parent_cld = ClassLoaderData::class_loader_data_or_null(parent_loader);
944     // The parent loader&#39;s ClassLoaderData could be null if it is
945     // a delegating class loader that has never defined a class.
946     // In this case the loader&#39;s name must be obtained via the parent loader&#39;s oop.
947     if (parent_cld == NULL) {
948       oop cl_name_and_id = java_lang_ClassLoader::nameAndId(parent_loader);
949       if (cl_name_and_id != NULL) {
950         parent_loader_name_and_id = java_lang_String::as_utf8_string(cl_name_and_id);
951       }
952     } else {
953       parent_loader_name_and_id = parent_cld-&gt;loader_name_and_id();
954     }
955     parent_loader_phrase = &quot;, parent loader &quot;;
956     len += strlen(parent_loader_phrase) + strlen(parent_loader_name_and_id);
957   }
958 
959   // Start to construct final full class description string
960   len += ((use_are) ? strlen(&quot; are in &quot;) : strlen(&quot; is in &quot;));
961   len += strlen(module_name_phrase) + strlen(&quot; of loader &quot;);
962 
963   char* class_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
964 
965   // Just return the FQN if error when allocating string
966   if (class_description == NULL) {
967     return klass_name;
968   }
969 
970   jio_snprintf(class_description, len, &quot;%s %s in %s%s%s%s of loader %s%s%s&quot;,
971                klass_name,
972                (use_are) ? &quot;are&quot; : &quot;is&quot;,
973                module_name_phrase,
974                module_name,
975                (has_version) ? &quot;@&quot; : &quot;&quot;,
976                (has_version) ? version : &quot;&quot;,
977                loader_name_and_id,
978                parent_loader_phrase,
979                parent_loader_name_and_id);
980 
981   return class_description;
982 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
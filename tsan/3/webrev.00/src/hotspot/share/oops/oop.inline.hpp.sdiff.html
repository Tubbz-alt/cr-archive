<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_INLINE_HPP
 26 #define SHARE_OOPS_OOP_INLINE_HPP
 27 
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;

 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/arrayKlass.hpp&quot;
 31 #include &quot;oops/arrayOop.hpp&quot;
 32 #include &quot;oops/compressedOops.inline.hpp&quot;
 33 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified"> 34 #include &quot;oops/markOop.inline.hpp&quot;</span>
 35 #include &quot;oops/oop.hpp&quot;
 36 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed"> 37 #include &quot;runtime/orderAccess.hpp&quot;</span>
 38 #include &quot;runtime/os.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 
 42 // Implementation of all inlined member functions defined in oop.hpp
 43 // We need a separate file to avoid circular references
 44 
<span class="line-modified"> 45 markOop  oopDesc::mark()      const {</span>
<span class="line-modified"> 46   return HeapAccess&lt;MO_VOLATILE&gt;::load_at(as_oop(), mark_offset_in_bytes());</span>

 47 }
 48 
<span class="line-modified"> 49 markOop  oopDesc::mark_raw()  const {</span>
<span class="line-modified"> 50   return _mark;</span>
 51 }
 52 
<span class="line-modified"> 53 markOop* oopDesc::mark_addr_raw() const {</span>
<span class="line-modified"> 54   return (markOop*) &amp;_mark;</span>
 55 }
 56 
<span class="line-modified"> 57 void oopDesc::set_mark(volatile markOop m) {</span>
<span class="line-modified"> 58   HeapAccess&lt;MO_VOLATILE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m);</span>
 59 }
 60 
<span class="line-modified"> 61 void oopDesc::set_mark_raw(volatile markOop m) {</span>
<span class="line-modified"> 62   _mark = m;</span>
 63 }
 64 
<span class="line-modified"> 65 void oopDesc::set_mark_raw(HeapWord* mem, markOop m) {</span>
<span class="line-modified"> 66   *(markOop*)(((char*)mem) + mark_offset_in_bytes()) = m;</span>
 67 }
 68 
<span class="line-modified"> 69 void oopDesc::release_set_mark(markOop m) {</span>
<span class="line-modified"> 70   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m);</span>
 71 }
 72 
<span class="line-modified"> 73 markOop oopDesc::cas_set_mark(markOop new_mark, markOop old_mark) {</span>
<span class="line-modified"> 74   return HeapAccess&lt;&gt;::atomic_cmpxchg_at(new_mark, as_oop(), mark_offset_in_bytes(), old_mark);</span>

 75 }
 76 
<span class="line-modified"> 77 markOop oopDesc::cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order) {</span>
<span class="line-modified"> 78   return Atomic::cmpxchg(new_mark, &amp;_mark, old_mark, order);</span>
 79 }
 80 
 81 void oopDesc::init_mark() {
<span class="line-modified"> 82   set_mark(markOopDesc::prototype_for_object(this));</span>
 83 }
 84 
 85 void oopDesc::init_mark_raw() {
<span class="line-modified"> 86   set_mark_raw(markOopDesc::prototype_for_object(this));</span>
 87 }
 88 
 89 Klass* oopDesc::klass() const {
 90   if (UseCompressedClassPointers) {
<span class="line-modified"> 91     return Klass::decode_klass_not_null(_metadata._compressed_klass);</span>
 92   } else {
 93     return _metadata._klass;
 94   }
 95 }
 96 
 97 Klass* oopDesc::klass_or_null() const volatile {
 98   if (UseCompressedClassPointers) {
<span class="line-modified"> 99     return Klass::decode_klass(_metadata._compressed_klass);</span>
100   } else {
101     return _metadata._klass;
102   }
103 }
104 
105 Klass* oopDesc::klass_or_null_acquire() const volatile {
106   if (UseCompressedClassPointers) {
107     // Workaround for non-const load_acquire parameter.
108     const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
109     volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">110     return Klass::decode_klass(OrderAccess::load_acquire(xaddr));</span>
111   } else {
<span class="line-modified">112     return OrderAccess::load_acquire(&amp;_metadata._klass);</span>
113   }
114 }
115 
116 Klass** oopDesc::klass_addr(HeapWord* mem) {
117   // Only used internally and with CMS and will not work with
118   // UseCompressedOops
119   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
120   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
121   return (Klass**) (((char*)mem) + in_bytes(offset));
122 }
123 
124 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
125   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
126   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
127   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
128 }
129 
130 Klass** oopDesc::klass_addr() {
131   return klass_addr((HeapWord*)this);
132 }
133 
134 narrowKlass* oopDesc::compressed_klass_addr() {
135   return compressed_klass_addr((HeapWord*)this);
136 }
137 
138 #define CHECK_SET_KLASS(k)                                                \
139   do {                                                                    \
140     assert(Universe::is_bootstrapping() || k != NULL, &quot;NULL Klass&quot;);      \
141     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \
142   } while (0)
143 
144 void oopDesc::set_klass(Klass* k) {
145   CHECK_SET_KLASS(k);
146   if (UseCompressedClassPointers) {
<span class="line-modified">147     *compressed_klass_addr() = Klass::encode_klass_not_null(k);</span>
148   } else {
149     *klass_addr() = k;
150   }
151 }
152 
153 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
154   CHECK_SET_KLASS(klass);
155   if (UseCompressedClassPointers) {
<span class="line-modified">156     OrderAccess::release_store(compressed_klass_addr(mem),</span>
<span class="line-modified">157                                Klass::encode_klass_not_null(klass));</span>
158   } else {
<span class="line-modified">159     OrderAccess::release_store(klass_addr(mem), klass);</span>
160   }
161 }
162 
163 #undef CHECK_SET_KLASS
164 
165 int oopDesc::klass_gap() const {
166   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
167 }
168 
169 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
170   if (UseCompressedClassPointers) {
171     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
172   }
173 }
174 
175 void oopDesc::set_klass_gap(int v) {
176   set_klass_gap((HeapWord*)this, v);
177 }
178 
<span class="line-removed">179 void oopDesc::set_klass_to_list_ptr(oop k) {</span>
<span class="line-removed">180   // This is only to be used during GC, for from-space objects, so no</span>
<span class="line-removed">181   // barrier is needed.</span>
<span class="line-removed">182   if (UseCompressedClassPointers) {</span>
<span class="line-removed">183     _metadata._compressed_klass = (narrowKlass)CompressedOops::encode(k);  // may be null (parnew overflow handling)</span>
<span class="line-removed">184   } else {</span>
<span class="line-removed">185     _metadata._klass = (Klass*)(address)k;</span>
<span class="line-removed">186   }</span>
<span class="line-removed">187 }</span>
<span class="line-removed">188 </span>
<span class="line-removed">189 oop oopDesc::list_ptr_from_klass() {</span>
<span class="line-removed">190   // This is only to be used during GC, for from-space objects.</span>
<span class="line-removed">191   if (UseCompressedClassPointers) {</span>
<span class="line-removed">192     return CompressedOops::decode((narrowOop)_metadata._compressed_klass);</span>
<span class="line-removed">193   } else {</span>
<span class="line-removed">194     // Special case for GC</span>
<span class="line-removed">195     return (oop)(address)_metadata._klass;</span>
<span class="line-removed">196   }</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
199 bool oopDesc::is_a(Klass* k) const {
200   return klass()-&gt;is_subtype_of(k);
201 }
202 
203 int oopDesc::size()  {
204   return size_given_klass(klass());
205 }
206 
207 int oopDesc::size_given_klass(Klass* klass)  {
208   int lh = klass-&gt;layout_helper();
209   int s;
210 
211   // lh is now a value computed at class initialization that may hint
212   // at the size.  For instances, this is positive and equal to the
213   // size.  For arrays, this is negative and provides log2 of the
214   // array element size.  For other oops, it is zero and thus requires
215   // a virtual call.
216   //
217   // We go to all this trouble because the size computation is at the
218   // heart of phase 2 of mark-compaction, and called for every object,
</pre>
<hr />
<pre>
224       s = lh &gt;&gt; LogHeapWordSize;  // deliver size scaled by wordSize
225     } else {
226       s = klass-&gt;oop_size(this);
227     }
228   } else if (lh &lt;= Klass::_lh_neutral_value) {
229     // The most common case is instances; fall through if so.
230     if (lh &lt; Klass::_lh_neutral_value) {
231       // Second most common case is arrays.  We have to fetch the
232       // length of the array, shift (multiply) it appropriately,
233       // up to wordSize, add the header, and align to object size.
234       size_t size_in_bytes;
235       size_t array_length = (size_t) ((arrayOop)this)-&gt;length();
236       size_in_bytes = array_length &lt;&lt; Klass::layout_helper_log2_element_size(lh);
237       size_in_bytes += Klass::layout_helper_header_size(lh);
238 
239       // This code could be simplified, but by keeping array_header_in_bytes
240       // in units of bytes and doing it this way we can round up just once,
241       // skipping the intermediate round to HeapWordSize.
242       s = (int)(align_up(size_in_bytes, MinObjAlignmentInBytes) / HeapWordSize);
243 
<span class="line-modified">244       // ParNew (used by CMS), UseParallelGC and UseG1GC can change the length field</span>
245       // of an &quot;old copy&quot; of an object array in the young gen so it indicates
246       // the grey portion of an already copied array. This will cause the first
247       // disjunct below to fail if the two comparands are computed across such
248       // a concurrent change.
<span class="line-removed">249       // ParNew also runs with promotion labs (which look like int</span>
<span class="line-removed">250       // filler arrays) which are subject to changing their declared size</span>
<span class="line-removed">251       // when finally retiring a PLAB; this also can cause the first disjunct</span>
<span class="line-removed">252       // to fail for another worker thread that is concurrently walking the block</span>
<span class="line-removed">253       // offset table. Both these invariant failures are benign for their</span>
<span class="line-removed">254       // current uses; we relax the assertion checking to cover these two cases below:</span>
<span class="line-removed">255       //     is_objArray() &amp;&amp; is_forwarded()   // covers first scenario above</span>
<span class="line-removed">256       //  || is_typeArray()                    // covers second scenario above</span>
<span class="line-removed">257       // If and when UseParallelGC uses the same obj array oop stealing/chunking</span>
<span class="line-removed">258       // technique, we will need to suitably modify the assertion.</span>
259       assert((s == klass-&gt;oop_size(this)) ||
<span class="line-modified">260              (Universe::heap()-&gt;is_gc_active() &amp;&amp;</span>
<span class="line-removed">261               ((is_typeArray() &amp;&amp; UseConcMarkSweepGC) ||</span>
<span class="line-removed">262                (is_objArray()  &amp;&amp; is_forwarded() &amp;&amp; (UseConcMarkSweepGC || UseParallelGC || UseG1GC)))),</span>
263              &quot;wrong array object size&quot;);
264     } else {
265       // Must be zero, so bite the bullet and take the virtual call.
266       s = klass-&gt;oop_size(this);
267     }
268   }
269 
270   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
271   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
272   return s;
273 }
274 
275 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
276 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
277 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
278 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }
279 
280 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
281 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
282 
283 template &lt;class T&gt;
284 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
285 
286 template &lt;typename T&gt;
287 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
288 
289 template &lt;DecoratorSet decorators&gt;
290 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
291 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
292 
293 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
294 
295 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
296 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
297 
298 inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
299 inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
300 
<span class="line-modified">301 inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);                }</span>
302 inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }
<span class="line-modified">303 </span>

304 inline jshort oopDesc::short_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
305 inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
306 
307 inline jint oopDesc::int_field(int offset) const                    { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
308 inline jint oopDesc::int_field_raw(int offset) const                { return RawAccess&lt;&gt;::load_at(as_oop(), offset);   }
309 inline void oopDesc::int_field_put(int offset, jint value)          { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
310 
311 inline jlong oopDesc::long_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
312 inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
313 
314 inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
315 inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
316 
317 inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
318 inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
319 
320 bool oopDesc::is_locked() const {
<span class="line-modified">321   return mark()-&gt;is_locked();</span>
322 }
323 
324 bool oopDesc::is_unlocked() const {
<span class="line-modified">325   return mark()-&gt;is_unlocked();</span>
326 }
327 
328 bool oopDesc::has_bias_pattern() const {
<span class="line-modified">329   return mark()-&gt;has_bias_pattern();</span>
330 }
331 
332 bool oopDesc::has_bias_pattern_raw() const {
<span class="line-modified">333   return mark_raw()-&gt;has_bias_pattern();</span>
334 }
335 
336 // Used only for markSweep, scavenging
337 bool oopDesc::is_gc_marked() const {
<span class="line-modified">338   return mark_raw()-&gt;is_marked();</span>
339 }
340 
341 // Used by scavengers
342 bool oopDesc::is_forwarded() const {
343   // The extra heap check is needed since the obj might be locked, in which case the
344   // mark would point to a stack location and have the sentinel bit cleared
<span class="line-modified">345   return mark_raw()-&gt;is_marked();</span>
346 }
347 
348 // Used by scavengers
349 void oopDesc::forward_to(oop p) {
<span class="line-modified">350   assert(check_obj_alignment(p),</span>
<span class="line-modified">351          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-modified">352   assert(Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">353          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">354   assert(!is_archived_object(oop(this)) &amp;&amp;</span>
<span class="line-removed">355          !is_archived_object(p),</span>
<span class="line-removed">356          &quot;forwarding archive object&quot;);</span>
<span class="line-removed">357   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">358   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
359   set_mark_raw(m);
360 }
361 
362 // Used by parallel scavengers
<span class="line-modified">363 bool oopDesc::cas_forward_to(oop p, markOop compare, atomic_memory_order order) {</span>
<span class="line-modified">364   assert(check_obj_alignment(p),</span>
<span class="line-modified">365          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-modified">366   assert(Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">367          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">368   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">369   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
370   return cas_set_mark_raw(m, compare, order) == compare;
371 }
372 
<span class="line-modified">373 oop oopDesc::forward_to_atomic(oop p, markOop compare, atomic_memory_order order) {</span>
<span class="line-modified">374   // CMS forwards some non-heap value into the mark oop to reserve oops during</span>
<span class="line-modified">375   // promotion, so the next two asserts do not hold.</span>
<span class="line-modified">376   assert(UseConcMarkSweepGC || check_obj_alignment(p),</span>
<span class="line-modified">377          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-removed">378   assert(UseConcMarkSweepGC || Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">379          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">380   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">381   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
<span class="line-removed">382   markOop old_mark = cas_set_mark_raw(m, compare, order);</span>
383   if (old_mark == compare) {
384     return NULL;
385   } else {
<span class="line-modified">386     return (oop)old_mark-&gt;decode_pointer();</span>
387   }
388 }
389 
390 // Note that the forwardee is not the same thing as the displaced_mark.
391 // The forwardee is used when copying during scavenge and mark-sweep.
392 // It does need to clear the low two locking- and GC-related bits.
393 oop oopDesc::forwardee() const {
<span class="line-modified">394   return (oop) mark_raw()-&gt;decode_pointer();</span>
395 }
396 
397 // Note that the forwardee is not the same thing as the displaced_mark.
398 // The forwardee is used when copying during scavenge and mark-sweep.
399 // It does need to clear the low two locking- and GC-related bits.
400 oop oopDesc::forwardee_acquire() const {
<span class="line-modified">401   markOop m = OrderAccess::load_acquire(&amp;_mark);</span>
<span class="line-removed">402   return (oop) m-&gt;decode_pointer();</span>
403 }
404 
405 // The following method needs to be MT safe.
406 uint oopDesc::age() const {
407   assert(!is_forwarded(), &quot;Attempt to read age from forwarded mark&quot;);
408   if (has_displaced_mark_raw()) {
<span class="line-modified">409     return displaced_mark_raw()-&gt;age();</span>
410   } else {
<span class="line-modified">411     return mark_raw()-&gt;age();</span>
412   }
413 }
414 
415 void oopDesc::incr_age() {
416   assert(!is_forwarded(), &quot;Attempt to increment age of forwarded mark&quot;);
417   if (has_displaced_mark_raw()) {
<span class="line-modified">418     set_displaced_mark_raw(displaced_mark_raw()-&gt;incr_age());</span>
419   } else {
<span class="line-modified">420     set_mark_raw(mark_raw()-&gt;incr_age());</span>
421   }
422 }
423 
424 template &lt;typename OopClosureType&gt;
425 void oopDesc::oop_iterate(OopClosureType* cl) {
426   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, klass());
427 }
428 
429 template &lt;typename OopClosureType&gt;
430 void oopDesc::oop_iterate(OopClosureType* cl, MemRegion mr) {
431   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, klass(), mr);
432 }
433 
434 template &lt;typename OopClosureType&gt;
435 int oopDesc::oop_iterate_size(OopClosureType* cl) {
436   Klass* k = klass();
437   int size = size_given_klass(k);
438   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, k);
439   return size;
440 }
</pre>
<hr />
<pre>
442 template &lt;typename OopClosureType&gt;
443 int oopDesc::oop_iterate_size(OopClosureType* cl, MemRegion mr) {
444   Klass* k = klass();
445   int size = size_given_klass(k);
446   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, k, mr);
447   return size;
448 }
449 
450 template &lt;typename OopClosureType&gt;
451 void oopDesc::oop_iterate_backwards(OopClosureType* cl) {
452   OopIteratorClosureDispatch::oop_oop_iterate_backwards(cl, this, klass());
453 }
454 
455 bool oopDesc::is_instanceof_or_null(oop obj, Klass* klass) {
456   return obj == NULL || obj-&gt;klass()-&gt;is_subtype_of(klass);
457 }
458 
459 intptr_t oopDesc::identity_hash() {
460   // Fast case; if the object is unlocked and the hash value is set, no locking is needed
461   // Note: The mark must be read into local variable to avoid concurrent updates.
<span class="line-modified">462   markOop mrk = mark();</span>
<span class="line-modified">463   if (mrk-&gt;is_unlocked() &amp;&amp; !mrk-&gt;has_no_hash()) {</span>
<span class="line-modified">464     return mrk-&gt;hash();</span>
<span class="line-modified">465   } else if (mrk-&gt;is_marked()) {</span>
<span class="line-modified">466     return mrk-&gt;hash();</span>
467   } else {
468     return slow_identity_hash();
469   }
470 }
471 
472 bool oopDesc::has_displaced_mark_raw() const {
<span class="line-modified">473   return mark_raw()-&gt;has_displaced_mark_helper();</span>

























474 }
475 
<span class="line-modified">476 markOop oopDesc::displaced_mark_raw() const {</span>
<span class="line-modified">477   return mark_raw()-&gt;displaced_mark_helper();</span>





478 }
479 
<span class="line-modified">480 void oopDesc::set_displaced_mark_raw(markOop m) {</span>
<span class="line-modified">481   mark_raw()-&gt;set_displaced_mark_helper(m);</span>
482 }
483 
484 #endif // SHARE_OOPS_OOP_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_INLINE_HPP
 26 #define SHARE_OOPS_OOP_INLINE_HPP
 27 
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added"> 29 #include &quot;memory/universe.hpp&quot;</span>
 30 #include &quot;oops/access.inline.hpp&quot;
 31 #include &quot;oops/arrayKlass.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
 33 #include &quot;oops/compressedOops.inline.hpp&quot;
 34 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified"> 35 #include &quot;oops/markWord.inline.hpp&quot;</span>
 36 #include &quot;oops/oop.hpp&quot;
 37 #include &quot;runtime/atomic.hpp&quot;

 38 #include &quot;runtime/os.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 
 42 // Implementation of all inlined member functions defined in oop.hpp
 43 // We need a separate file to avoid circular references
 44 
<span class="line-modified"> 45 markWord oopDesc::mark() const {</span>
<span class="line-modified"> 46   uintptr_t v = HeapAccess&lt;MO_VOLATILE&gt;::load_at(as_oop(), mark_offset_in_bytes());</span>
<span class="line-added"> 47   return markWord(v);</span>
 48 }
 49 
<span class="line-modified"> 50 markWord oopDesc::mark_raw() const {</span>
<span class="line-modified"> 51   return Atomic::load(&amp;_mark);</span>
 52 }
 53 
<span class="line-modified"> 54 markWord* oopDesc::mark_addr_raw() const {</span>
<span class="line-modified"> 55   return (markWord*) &amp;_mark;</span>
 56 }
 57 
<span class="line-modified"> 58 void oopDesc::set_mark(markWord m) {</span>
<span class="line-modified"> 59   HeapAccess&lt;MO_VOLATILE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());</span>
 60 }
 61 
<span class="line-modified"> 62 void oopDesc::set_mark_raw(markWord m) {</span>
<span class="line-modified"> 63   Atomic::store(&amp;_mark, m);</span>
 64 }
 65 
<span class="line-modified"> 66 void oopDesc::set_mark_raw(HeapWord* mem, markWord m) {</span>
<span class="line-modified"> 67   *(markWord*)(((char*)mem) + mark_offset_in_bytes()) = m;</span>
 68 }
 69 
<span class="line-modified"> 70 void oopDesc::release_set_mark(markWord m) {</span>
<span class="line-modified"> 71   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());</span>
 72 }
 73 
<span class="line-modified"> 74 markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {</span>
<span class="line-modified"> 75   uintptr_t v = HeapAccess&lt;&gt;::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());</span>
<span class="line-added"> 76   return markWord(v);</span>
 77 }
 78 
<span class="line-modified"> 79 markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {</span>
<span class="line-modified"> 80   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);</span>
 81 }
 82 
 83 void oopDesc::init_mark() {
<span class="line-modified"> 84   set_mark(markWord::prototype_for_klass(klass()));</span>
 85 }
 86 
 87 void oopDesc::init_mark_raw() {
<span class="line-modified"> 88   set_mark_raw(markWord::prototype_for_klass(klass()));</span>
 89 }
 90 
 91 Klass* oopDesc::klass() const {
 92   if (UseCompressedClassPointers) {
<span class="line-modified"> 93     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);</span>
 94   } else {
 95     return _metadata._klass;
 96   }
 97 }
 98 
 99 Klass* oopDesc::klass_or_null() const volatile {
100   if (UseCompressedClassPointers) {
<span class="line-modified">101     return CompressedKlassPointers::decode(_metadata._compressed_klass);</span>
102   } else {
103     return _metadata._klass;
104   }
105 }
106 
107 Klass* oopDesc::klass_or_null_acquire() const volatile {
108   if (UseCompressedClassPointers) {
109     // Workaround for non-const load_acquire parameter.
110     const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
111     volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">112     return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));</span>
113   } else {
<span class="line-modified">114     return Atomic::load_acquire(&amp;_metadata._klass);</span>
115   }
116 }
117 
118 Klass** oopDesc::klass_addr(HeapWord* mem) {
119   // Only used internally and with CMS and will not work with
120   // UseCompressedOops
121   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
122   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
123   return (Klass**) (((char*)mem) + in_bytes(offset));
124 }
125 
126 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
127   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
128   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
129   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
130 }
131 
132 Klass** oopDesc::klass_addr() {
133   return klass_addr((HeapWord*)this);
134 }
135 
136 narrowKlass* oopDesc::compressed_klass_addr() {
137   return compressed_klass_addr((HeapWord*)this);
138 }
139 
140 #define CHECK_SET_KLASS(k)                                                \
141   do {                                                                    \
142     assert(Universe::is_bootstrapping() || k != NULL, &quot;NULL Klass&quot;);      \
143     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \
144   } while (0)
145 
146 void oopDesc::set_klass(Klass* k) {
147   CHECK_SET_KLASS(k);
148   if (UseCompressedClassPointers) {
<span class="line-modified">149     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);</span>
150   } else {
151     *klass_addr() = k;
152   }
153 }
154 
155 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
156   CHECK_SET_KLASS(klass);
157   if (UseCompressedClassPointers) {
<span class="line-modified">158     Atomic::release_store(compressed_klass_addr(mem),</span>
<span class="line-modified">159                           CompressedKlassPointers::encode_not_null(klass));</span>
160   } else {
<span class="line-modified">161     Atomic::release_store(klass_addr(mem), klass);</span>
162   }
163 }
164 
165 #undef CHECK_SET_KLASS
166 
167 int oopDesc::klass_gap() const {
168   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
169 }
170 
171 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
172   if (UseCompressedClassPointers) {
173     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
174   }
175 }
176 
177 void oopDesc::set_klass_gap(int v) {
178   set_klass_gap((HeapWord*)this, v);
179 }
180 




















181 bool oopDesc::is_a(Klass* k) const {
182   return klass()-&gt;is_subtype_of(k);
183 }
184 
185 int oopDesc::size()  {
186   return size_given_klass(klass());
187 }
188 
189 int oopDesc::size_given_klass(Klass* klass)  {
190   int lh = klass-&gt;layout_helper();
191   int s;
192 
193   // lh is now a value computed at class initialization that may hint
194   // at the size.  For instances, this is positive and equal to the
195   // size.  For arrays, this is negative and provides log2 of the
196   // array element size.  For other oops, it is zero and thus requires
197   // a virtual call.
198   //
199   // We go to all this trouble because the size computation is at the
200   // heart of phase 2 of mark-compaction, and called for every object,
</pre>
<hr />
<pre>
206       s = lh &gt;&gt; LogHeapWordSize;  // deliver size scaled by wordSize
207     } else {
208       s = klass-&gt;oop_size(this);
209     }
210   } else if (lh &lt;= Klass::_lh_neutral_value) {
211     // The most common case is instances; fall through if so.
212     if (lh &lt; Klass::_lh_neutral_value) {
213       // Second most common case is arrays.  We have to fetch the
214       // length of the array, shift (multiply) it appropriately,
215       // up to wordSize, add the header, and align to object size.
216       size_t size_in_bytes;
217       size_t array_length = (size_t) ((arrayOop)this)-&gt;length();
218       size_in_bytes = array_length &lt;&lt; Klass::layout_helper_log2_element_size(lh);
219       size_in_bytes += Klass::layout_helper_header_size(lh);
220 
221       // This code could be simplified, but by keeping array_header_in_bytes
222       // in units of bytes and doing it this way we can round up just once,
223       // skipping the intermediate round to HeapWordSize.
224       s = (int)(align_up(size_in_bytes, MinObjAlignmentInBytes) / HeapWordSize);
225 
<span class="line-modified">226       // UseParallelGC and UseG1GC can change the length field</span>
227       // of an &quot;old copy&quot; of an object array in the young gen so it indicates
228       // the grey portion of an already copied array. This will cause the first
229       // disjunct below to fail if the two comparands are computed across such
230       // a concurrent change.










231       assert((s == klass-&gt;oop_size(this)) ||
<span class="line-modified">232              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),</span>


233              &quot;wrong array object size&quot;);
234     } else {
235       // Must be zero, so bite the bullet and take the virtual call.
236       s = klass-&gt;oop_size(this);
237     }
238   }
239 
240   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
241   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
242   return s;
243 }
244 
245 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
246 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
247 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
248 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }
249 
250 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
251 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
252 
253 template &lt;class T&gt;
254 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
255 
256 template &lt;typename T&gt;
257 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
258 
259 template &lt;DecoratorSet decorators&gt;
260 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
261 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
262 
263 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
264 
265 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
266 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
267 
268 inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
269 inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
270 
<span class="line-modified">271 inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess&lt;&gt;::load_at(as_oop(), offset); }</span>
272 inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }
<span class="line-modified">273 inline jboolean oopDesc::bool_field_volatile(int offset) const      { return HeapAccess&lt;MO_SEQ_CST&gt;::load_at(as_oop(), offset); }</span>
<span class="line-added">274 inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { HeapAccess&lt;MO_SEQ_CST&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }</span>
275 inline jshort oopDesc::short_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
276 inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
277 
278 inline jint oopDesc::int_field(int offset) const                    { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
279 inline jint oopDesc::int_field_raw(int offset) const                { return RawAccess&lt;&gt;::load_at(as_oop(), offset);   }
280 inline void oopDesc::int_field_put(int offset, jint value)          { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
281 
282 inline jlong oopDesc::long_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
283 inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
284 
285 inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
286 inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
287 
288 inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
289 inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
290 
291 bool oopDesc::is_locked() const {
<span class="line-modified">292   return mark().is_locked();</span>
293 }
294 
295 bool oopDesc::is_unlocked() const {
<span class="line-modified">296   return mark().is_unlocked();</span>
297 }
298 
299 bool oopDesc::has_bias_pattern() const {
<span class="line-modified">300   return mark().has_bias_pattern();</span>
301 }
302 
303 bool oopDesc::has_bias_pattern_raw() const {
<span class="line-modified">304   return mark_raw().has_bias_pattern();</span>
305 }
306 
307 // Used only for markSweep, scavenging
308 bool oopDesc::is_gc_marked() const {
<span class="line-modified">309   return mark_raw().is_marked();</span>
310 }
311 
312 // Used by scavengers
313 bool oopDesc::is_forwarded() const {
314   // The extra heap check is needed since the obj might be locked, in which case the
315   // mark would point to a stack location and have the sentinel bit cleared
<span class="line-modified">316   return mark_raw().is_marked();</span>
317 }
318 
319 // Used by scavengers
320 void oopDesc::forward_to(oop p) {
<span class="line-modified">321   verify_forwardee(p);</span>
<span class="line-modified">322   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">323   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>






324   set_mark_raw(m);
325 }
326 
327 // Used by parallel scavengers
<span class="line-modified">328 bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {</span>
<span class="line-modified">329   verify_forwardee(p);</span>
<span class="line-modified">330   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">331   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>



332   return cas_set_mark_raw(m, compare, order) == compare;
333 }
334 
<span class="line-modified">335 oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {</span>
<span class="line-modified">336   verify_forwardee(p);</span>
<span class="line-modified">337   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">338   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
<span class="line-modified">339   markWord old_mark = cas_set_mark_raw(m, compare, order);</span>





340   if (old_mark == compare) {
341     return NULL;
342   } else {
<span class="line-modified">343     return (oop)old_mark.decode_pointer();</span>
344   }
345 }
346 
347 // Note that the forwardee is not the same thing as the displaced_mark.
348 // The forwardee is used when copying during scavenge and mark-sweep.
349 // It does need to clear the low two locking- and GC-related bits.
350 oop oopDesc::forwardee() const {
<span class="line-modified">351   return (oop) mark_raw().decode_pointer();</span>
352 }
353 
354 // Note that the forwardee is not the same thing as the displaced_mark.
355 // The forwardee is used when copying during scavenge and mark-sweep.
356 // It does need to clear the low two locking- and GC-related bits.
357 oop oopDesc::forwardee_acquire() const {
<span class="line-modified">358   return (oop) Atomic::load_acquire(&amp;_mark).decode_pointer();</span>

359 }
360 
361 // The following method needs to be MT safe.
362 uint oopDesc::age() const {
363   assert(!is_forwarded(), &quot;Attempt to read age from forwarded mark&quot;);
364   if (has_displaced_mark_raw()) {
<span class="line-modified">365     return displaced_mark_raw().age();</span>
366   } else {
<span class="line-modified">367     return mark_raw().age();</span>
368   }
369 }
370 
371 void oopDesc::incr_age() {
372   assert(!is_forwarded(), &quot;Attempt to increment age of forwarded mark&quot;);
373   if (has_displaced_mark_raw()) {
<span class="line-modified">374     set_displaced_mark_raw(displaced_mark_raw().incr_age());</span>
375   } else {
<span class="line-modified">376     set_mark_raw(mark_raw().incr_age());</span>
377   }
378 }
379 
380 template &lt;typename OopClosureType&gt;
381 void oopDesc::oop_iterate(OopClosureType* cl) {
382   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, klass());
383 }
384 
385 template &lt;typename OopClosureType&gt;
386 void oopDesc::oop_iterate(OopClosureType* cl, MemRegion mr) {
387   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, klass(), mr);
388 }
389 
390 template &lt;typename OopClosureType&gt;
391 int oopDesc::oop_iterate_size(OopClosureType* cl) {
392   Klass* k = klass();
393   int size = size_given_klass(k);
394   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, k);
395   return size;
396 }
</pre>
<hr />
<pre>
398 template &lt;typename OopClosureType&gt;
399 int oopDesc::oop_iterate_size(OopClosureType* cl, MemRegion mr) {
400   Klass* k = klass();
401   int size = size_given_klass(k);
402   OopIteratorClosureDispatch::oop_oop_iterate(cl, this, k, mr);
403   return size;
404 }
405 
406 template &lt;typename OopClosureType&gt;
407 void oopDesc::oop_iterate_backwards(OopClosureType* cl) {
408   OopIteratorClosureDispatch::oop_oop_iterate_backwards(cl, this, klass());
409 }
410 
411 bool oopDesc::is_instanceof_or_null(oop obj, Klass* klass) {
412   return obj == NULL || obj-&gt;klass()-&gt;is_subtype_of(klass);
413 }
414 
415 intptr_t oopDesc::identity_hash() {
416   // Fast case; if the object is unlocked and the hash value is set, no locking is needed
417   // Note: The mark must be read into local variable to avoid concurrent updates.
<span class="line-modified">418   markWord mrk = mark();</span>
<span class="line-modified">419   if (mrk.is_unlocked() &amp;&amp; !mrk.has_no_hash()) {</span>
<span class="line-modified">420     return mrk.hash();</span>
<span class="line-modified">421   } else if (mrk.is_marked()) {</span>
<span class="line-modified">422     return mrk.hash();</span>
423   } else {
424     return slow_identity_hash();
425   }
426 }
427 
428 bool oopDesc::has_displaced_mark_raw() const {
<span class="line-modified">429   return mark_raw().has_displaced_mark_helper();</span>
<span class="line-added">430 }</span>
<span class="line-added">431 </span>
<span class="line-added">432 markWord oopDesc::displaced_mark_raw() const {</span>
<span class="line-added">433   return mark_raw().displaced_mark_helper();</span>
<span class="line-added">434 }</span>
<span class="line-added">435 </span>
<span class="line-added">436 void oopDesc::set_displaced_mark_raw(markWord m) {</span>
<span class="line-added">437   mark_raw().set_displaced_mark_helper(m);</span>
<span class="line-added">438 }</span>
<span class="line-added">439 </span>
<span class="line-added">440 // Supports deferred calling of obj-&gt;klass().</span>
<span class="line-added">441 class DeferredObjectToKlass {</span>
<span class="line-added">442   const oopDesc* _obj;</span>
<span class="line-added">443 </span>
<span class="line-added">444 public:</span>
<span class="line-added">445   DeferredObjectToKlass(const oopDesc* obj) : _obj(obj) {}</span>
<span class="line-added">446 </span>
<span class="line-added">447   // Implicitly convertible to const Klass*.</span>
<span class="line-added">448   operator const Klass*() const {</span>
<span class="line-added">449     return _obj-&gt;klass();</span>
<span class="line-added">450   }</span>
<span class="line-added">451 };</span>
<span class="line-added">452 </span>
<span class="line-added">453 bool oopDesc::mark_must_be_preserved() const {</span>
<span class="line-added">454   return mark_must_be_preserved(mark_raw());</span>
455 }
456 
<span class="line-modified">457 bool oopDesc::mark_must_be_preserved(markWord m) const {</span>
<span class="line-modified">458   // There&#39;s a circular dependency between oop.inline.hpp and</span>
<span class="line-added">459   // markWord.inline.hpp because markWord::must_be_preserved wants to call</span>
<span class="line-added">460   // oopDesc::klass(). This could be solved by calling klass() here. However,</span>
<span class="line-added">461   // not all paths inside must_be_preserved calls klass(). Defer the call until</span>
<span class="line-added">462   // the klass is actually needed.</span>
<span class="line-added">463   return m.must_be_preserved(DeferredObjectToKlass(this));</span>
464 }
465 
<span class="line-modified">466 bool oopDesc::mark_must_be_preserved_for_promotion_failure(markWord m) const {</span>
<span class="line-modified">467   return m.must_be_preserved_for_promotion_failure(DeferredObjectToKlass(this));</span>
468 }
469 
470 #endif // SHARE_OOPS_OOP_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
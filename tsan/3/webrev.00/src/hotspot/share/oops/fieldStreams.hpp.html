<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/fieldStreams.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_FIELDSTREAMS_HPP
 26 #define SHARE_OOPS_FIELDSTREAMS_HPP
 27 
 28 #include &quot;oops/instanceKlass.hpp&quot;
 29 #include &quot;oops/fieldInfo.hpp&quot;
 30 #include &quot;runtime/fieldDescriptor.hpp&quot;
 31 
 32 // The is the base class for iteration over the fields array
 33 // describing the declared fields in the class.  Several subclasses
 34 // are provided depending on the kind of iteration required.  The
 35 // JavaFieldStream is for iterating over regular Java fields and it
 36 // generally the preferred iterator.  InternalFieldStream only
 37 // iterates over fields that have been injected by the JVM.
 38 // AllFieldStream exposes all fields and should only be used in rare
 39 // cases.
 40 class FieldStreamBase : public StackObj {
 41  protected:
 42   Array&lt;u2&gt;*          _fields;
 43   constantPoolHandle  _constants;
 44   int                 _index;
 45   int                 _limit;
 46   int                 _generic_signature_slot;
 47   fieldDescriptor     _fd_buf;
 48 
 49   FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }
 50 
 51   int init_generic_signature_start_slot() {
 52     int length = _fields-&gt;length();
 53     int num_fields = _index;
 54     int skipped_generic_signature_slots = 0;
 55     FieldInfo* fi;
 56     AccessFlags flags;
 57     /* Scan from 0 to the current _index. Count the number of generic
 58        signature slots for field[0] to field[_index - 1]. */
 59     for (int i = 0; i &lt; _index; i++) {
 60       fi = FieldInfo::from_field_array(_fields, i);
 61       flags.set_flags(fi-&gt;access_flags());
 62       if (flags.field_has_generic_signature()) {
 63         length --;
 64         skipped_generic_signature_slots ++;
 65       }
 66     }
 67     /* Scan from the current _index. */
 68     for (int i = _index; i*FieldInfo::field_slots &lt; length; i++) {
 69       fi = FieldInfo::from_field_array(_fields, i);
 70       flags.set_flags(fi-&gt;access_flags());
 71       if (flags.field_has_generic_signature()) {
 72         length --;
 73       }
 74       num_fields ++;
 75     }
 76     _generic_signature_slot = length + skipped_generic_signature_slots;
 77     assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
 78     return num_fields;
 79   }
 80 
 81   inline FieldStreamBase(Array&lt;u2&gt;* fields, ConstantPool* constants, int start, int limit);
 82 
 83   inline FieldStreamBase(Array&lt;u2&gt;* fields, ConstantPool* constants);
 84  public:
 85   inline FieldStreamBase(InstanceKlass* klass);
 86 
 87   // accessors
 88   int index() const                 { return _index; }
 89   InstanceKlass* field_holder() const { return _constants-&gt;pool_holder(); }
 90 
 91   void next() {
 92     if (access_flags().field_has_generic_signature()) {
 93       _generic_signature_slot ++;
 94       assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
 95     }
 96     _index += 1;
 97   }
 98   bool done() const { return _index &gt;= _limit; }
 99 
100   // Accessors for current field
101   AccessFlags access_flags() const {
102     AccessFlags flags;
103     flags.set_flags(field()-&gt;access_flags());
104     return flags;
105   }
106 
107   void set_access_flags(u2 flags) const {
108     field()-&gt;set_access_flags(flags);
109   }
110 
111   void set_access_flags(AccessFlags flags) const {
112     set_access_flags(flags.as_short());
113   }
114 
115   Symbol* name() const {
116     return field()-&gt;name(_constants());
117   }
118 
119   Symbol* signature() const {
120     return field()-&gt;signature(_constants());
121   }
122 
123   Symbol* generic_signature() const {
124     if (access_flags().field_has_generic_signature()) {
125       assert(_generic_signature_slot &lt; _fields-&gt;length(), &quot;out of bounds&quot;);
126       int index = _fields-&gt;at(_generic_signature_slot);
127       return _constants-&gt;symbol_at(index);
128     } else {
129       return NULL;
130     }
131   }
132 
133   int offset() const {
134     return field()-&gt;offset();
135   }
136 
137   int allocation_type() const {
138     return field()-&gt;allocation_type();
139   }
140 
141   void set_offset(int offset) {
142     field()-&gt;set_offset(offset);
143   }
144 
145   bool is_offset_set() const {
146     return field()-&gt;is_offset_set();
147   }
148 
149   bool is_contended() const {
150     return field()-&gt;is_contended();
151   }
152 
153   int contended_group() const {
154     return field()-&gt;contended_group();
155   }
156 
157   // bridge to a heavier API:
158   fieldDescriptor&amp; field_descriptor() const {
159     fieldDescriptor&amp; field = const_cast&lt;fieldDescriptor&amp;&gt;(_fd_buf);
160     field.reinitialize(field_holder(), _index);
161     return field;
162   }
163 };
164 
165 // Iterate over only the internal fields
166 class JavaFieldStream : public FieldStreamBase {
167  public:
168   JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k-&gt;fields(), k-&gt;constants(), 0, k-&gt;java_fields_count()) {}
169 
170   int name_index() const {
171     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
172     return field()-&gt;name_index();
173   }
174   void set_name_index(int index) {
175     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
176     field()-&gt;set_name_index(index);
177   }
178   int signature_index() const {
179     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
180     return field()-&gt;signature_index();
181   }
182   void set_signature_index(int index) {
183     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
184     field()-&gt;set_signature_index(index);
185   }
186   int generic_signature_index() const {
187     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
188     if (access_flags().field_has_generic_signature()) {
189       assert(_generic_signature_slot &lt; _fields-&gt;length(), &quot;out of bounds&quot;);
190       return _fields-&gt;at(_generic_signature_slot);
191     } else {
192       return 0;
193     }
194   }
195   void set_generic_signature_index(int index) {
196     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
197     if (access_flags().field_has_generic_signature()) {
198       assert(_generic_signature_slot &lt; _fields-&gt;length(), &quot;out of bounds&quot;);
199       _fields-&gt;at_put(_generic_signature_slot, index);
200     }
201   }
202   int initval_index() const {
203     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
204     return field()-&gt;initval_index();
205   }
206   void set_initval_index(int index) {
207     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
208     return field()-&gt;set_initval_index(index);
209   }
210 };
211 
212 
213 // Iterate over only the internal fields
214 class InternalFieldStream : public FieldStreamBase {
215  public:
216   InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants(), k-&gt;java_fields_count(), 0) {}
217 };
218 
219 
220 class AllFieldStream : public FieldStreamBase {
221  public:
222   AllFieldStream(Array&lt;u2&gt;* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}
223   AllFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants()) {}
224 };
225 
226 #endif // SHARE_OOPS_FIELDSTREAMS_HPP
    </pre>
  </body>
</html>
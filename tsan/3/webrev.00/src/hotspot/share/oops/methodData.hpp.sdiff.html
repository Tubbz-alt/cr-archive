<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
<span class="line-removed">  29 #include &quot;memory/universe.hpp&quot;</span>
  30 #include &quot;oops/metadata.hpp&quot;
  31 #include &quot;oops/method.hpp&quot;
  32 #include &quot;oops/oop.hpp&quot;
  33 #include &quot;runtime/atomic.hpp&quot;
  34 #include &quot;utilities/align.hpp&quot;
<span class="line-removed">  35 #if INCLUDE_JVMCI</span>
<span class="line-removed">  36 #include &quot;jvmci/jvmci_globals.hpp&quot;</span>
<span class="line-removed">  37 #endif</span>
  38 
  39 class BytecodeStream;
<span class="line-removed">  40 class KlassSizeStats;</span>
  41 
  42 // The MethodData object collects counts and other profile information
  43 // during zeroth-tier (interpretive) and first-tier execution.
  44 // The profile is used later by compilation heuristics.  Some heuristics
  45 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  46 // optimization often has a down-side, a corner case that it handles
  47 // poorly, but which is thought to be rare.  The profile provides
  48 // evidence of this rarity for a given method or even BCI.  It allows
  49 // the compiler to back out of the optimization at places where it
  50 // has historically been a poor choice.  Other heuristics try to use
  51 // specific information gathered about types observed at a given site.
  52 //
  53 // All data in the profile is approximate.  It is expected to be accurate
  54 // on the whole, but the system expects occasional inaccuraces, due to
  55 // counter overflow, multiprocessor races during data collection, space
  56 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  57 // optimization quality but will not affect correctness.  Also, each MDO
  58 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  59 // to assess the quality (&quot;maturity&quot;) of its data.
  60 //
</pre>
<hr />
<pre>
 545   friend class JVMCIVMStructs;
 546 protected:
 547   enum {
 548     count_off,
 549     counter_cell_count
 550   };
 551 public:
 552   CounterData(DataLayout* layout) : BitData(layout) {}
 553 
 554   virtual bool is_CounterData() const { return true; }
 555 
 556   static int static_cell_count() {
 557     return counter_cell_count;
 558   }
 559 
 560   virtual int cell_count() const {
 561     return static_cell_count();
 562   }
 563 
 564   // Direct accessor
<span class="line-modified"> 565   uint count() const {</span>
<span class="line-modified"> 566     return uint_at(count_off);</span>






 567   }
 568 
 569   // Code generation support
 570   static ByteSize count_offset() {
 571     return cell_offset(count_off);
 572   }
 573   static ByteSize counter_data_size() {
 574     return cell_offset(counter_cell_count);
 575   }
 576 
<span class="line-modified"> 577   void set_count(uint count) {</span>
<span class="line-modified"> 578     set_uint_at(count_off, count);</span>
 579   }
 580 
 581   void print_data_on(outputStream* st, const char* extra = NULL) const;
 582 };
 583 
 584 // JumpData
 585 //
 586 // A JumpData is used to access profiling information for a direct
 587 // branch.  It is a counter, used for counting the number of branches,
 588 // plus a data displacement, used for realigning the data pointer to
 589 // the corresponding target bci.
 590 class JumpData : public ProfileData {
 591   friend class VMStructs;
 592   friend class JVMCIVMStructs;
 593 protected:
 594   enum {
 595     taken_off_set,
 596     displacement_off_set,
 597     jump_cell_count
 598   };
</pre>
<hr />
<pre>
1932 // in the array corresponding to the current bci.  In the course of
1933 // intepretation, when a bytecode is encountered that has profile data
1934 // associated with it, the entry pointed to by mdp is updated, then the
1935 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1936 // is NULL to begin with, the interpreter assumes that the current method
1937 // is not (yet) being profiled.
1938 //
1939 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1940 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1941 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1942 // in certain ProfileData objects that indicate the amount the mdp must be
1943 // adjusted in the event of a change in control flow.
1944 //
1945 
1946 class CleanExtraDataClosure : public StackObj {
1947 public:
1948   virtual bool is_live(Method* m) = 0;
1949 };
1950 
1951 




































1952 class MethodData : public Metadata {
1953   friend class VMStructs;
1954   friend class JVMCIVMStructs;
1955 private:
1956   friend class ProfileData;
1957   friend class TypeEntriesAtCall;
1958 
1959   // If you add a new field that points to any metaspace object, you
1960   // must add this field to MethodData::metaspace_pointers_do().
1961 
1962   // Back pointer to the Method*
1963   Method* _method;
1964 
1965   // Size of this oop in bytes
1966   int _size;
1967 
1968   // Cached hint for bci_to_dp and bci_to_data
1969   int _hint_di;
1970 
1971   Mutex _extra_data_lock;
1972 
1973   MethodData(const methodHandle&amp; method, int size, TRAPS);
1974 public:
1975   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
<span class="line-modified">1976   MethodData() : _extra_data_lock(Monitor::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
1977 
1978   bool is_methodData() const volatile { return true; }
1979   void initialize();
1980 
1981   // Whole-method sticky bits and flags
1982   enum {
<span class="line-modified">1983     _trap_hist_limit    = 24 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
1984     _trap_hist_mask     = max_jubyte,
1985     _extra_data_count   = 4     // extra DataLayout headers, for trap history
1986   }; // Public flag values
1987 private:
1988   uint _nof_decompiles;             // count of all nmethod removals
1989   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
1990   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
1991   union {
1992     intptr_t _align;
1993     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
1994   } _trap_hist;
1995 
1996   // Support for interprocedural escape analysis, from Thomas Kotzmann.
1997   intx              _eflags;          // flags on escape information
1998   intx              _arg_local;       // bit set of non-escaping arguments
1999   intx              _arg_stack;       // bit set of stack-allocatable arguments
2000   intx              _arg_returned;    // bit set of returned arguments
2001 
2002   int _creation_mileage;              // method mileage at MDO creation
2003 
</pre>
<hr />
<pre>
2013   int               _backedge_counter_start;
2014   uint              _tenure_traps;
2015   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2016   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2017 
2018 #if INCLUDE_RTM_OPT
2019   // State of RTM code generation during compilation of the method
2020   int               _rtm_state;
2021 #endif
2022 
2023   // Number of loops and blocks is computed when compiling the first
2024   // time with C1. It is used to determine if method is trivial.
2025   short             _num_loops;
2026   short             _num_blocks;
2027   // Does this method contain anything worth profiling?
2028   enum WouldProfile {unknown, no_profile, profile};
2029   WouldProfile      _would_profile;
2030 
2031 #if INCLUDE_JVMCI
2032   // Support for HotSpotMethodData.setCompiledIRSize(int)
<span class="line-modified">2033   int               _jvmci_ir_size;</span>

2034 #endif
2035 
2036   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2037   int _data_size;
2038 
2039   // data index for the area dedicated to parameters. -1 if no
2040   // parameter profiling.
2041   enum { no_parameters = -2, parameters_uninitialized = -1 };
2042   int _parameters_type_data_di;
<span class="line-removed">2043   int parameters_size_in_bytes() const {</span>
<span class="line-removed">2044     ParametersTypeData* param = parameters_type_data();</span>
<span class="line-removed">2045     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="line-removed">2046   }</span>
2047 
2048   // Beginning of the data entries
2049   intptr_t _data[1];
2050 
2051   // Helper for size computation
2052   static int compute_data_size(BytecodeStream* stream);
2053   static int bytecode_cell_count(Bytecodes::Code code);
2054   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2055   enum { no_profile_data = -1, variable_cell_count = -2 };
2056 
2057   // Helper for initialization
2058   DataLayout* data_layout_at(int data_index) const {
2059     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2060     return (DataLayout*) (((address)_data) + data_index);
2061   }
2062 
2063   // Initialize an individual data segment.  Returns the size of
2064   // the segment in bytes.
2065   int initialize_data(BytecodeStream* stream, int data_index);
2066 
</pre>
<hr />
<pre>
2129   static int header_size() {
2130     return sizeof(MethodData)/wordSize;
2131   }
2132 
2133   // Compute the size of a MethodData* before it is created.
2134   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2135   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2136   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2137 
2138   // Determine if a given bytecode can have profile information.
2139   static bool bytecode_has_profile(Bytecodes::Code code) {
2140     return bytecode_cell_count(code) != no_profile_data;
2141   }
2142 
2143   // reset into original state
2144   void init();
2145 
2146   // My size
2147   int size_in_bytes() const { return _size; }
2148   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
<span class="line-removed">2149 #if INCLUDE_SERVICES</span>
<span class="line-removed">2150   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">2151 #endif</span>
2152 
2153   int      creation_mileage() const  { return _creation_mileage; }
2154   void set_creation_mileage(int x)   { _creation_mileage = x; }
2155 
2156   int invocation_count() {
2157     if (invocation_counter()-&gt;carry()) {
2158       return InvocationCounter::count_limit;
2159     }
2160     return invocation_counter()-&gt;count();
2161   }
2162   int backedge_count() {
2163     if (backedge_counter()-&gt;carry()) {
2164       return InvocationCounter::count_limit;
2165     }
2166     return backedge_counter()-&gt;count();
2167   }
2168 
2169   int invocation_count_start() {
2170     if (invocation_counter()-&gt;carry()) {
2171       return 0;
</pre>
<hr />
<pre>
2174   }
2175 
2176   int backedge_count_start() {
2177     if (backedge_counter()-&gt;carry()) {
2178       return 0;
2179     }
2180     return _backedge_counter_start;
2181   }
2182 
2183   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2184   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2185 
2186   void reset_start_counters() {
2187     _invocation_counter_start = invocation_count();
2188     _backedge_counter_start = backedge_count();
2189   }
2190 
2191   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2192   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2193 






2194 #if INCLUDE_RTM_OPT
2195   int rtm_state() const {
2196     return _rtm_state;
2197   }
2198   void set_rtm_state(RTMState rstate) {
2199     _rtm_state = (int)rstate;
2200   }
2201   void atomic_set_rtm_state(RTMState rstate) {
<span class="line-modified">2202     Atomic::store((int)rstate, &amp;_rtm_state);</span>
2203   }
2204 
2205   static int rtm_state_offset_in_bytes() {
2206     return offset_of(MethodData, _rtm_state);
2207   }
2208 #endif
2209 
2210   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2211   bool would_profile() const                  { return _would_profile != no_profile; }
2212 
2213   int num_loops() const                       { return _num_loops;  }
2214   void set_num_loops(int n)                   { _num_loops = n;     }
2215   int num_blocks() const                      { return _num_blocks; }
2216   void set_num_blocks(int n)                  { _num_blocks = n;    }
2217 
2218   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2219   static int mileage_of(Method* m);
2220 
2221   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2222   enum EscapeFlag {
</pre>
<hr />
<pre>
2238 
2239   void set_eflags(intx v)                        { _eflags = v; }
2240   void set_arg_local(intx v)                     { _arg_local = v; }
2241   void set_arg_stack(intx v)                     { _arg_stack = v; }
2242   void set_arg_returned(intx v)                  { _arg_returned = v; }
2243   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2244                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2245                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2246                                                    aid-&gt;set_arg_modified(a, v); }
2247 
2248   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2249 
2250   // Location and size of data area
2251   address data_base() const {
2252     return (address) _data;
2253   }
2254   int data_size() const {
2255     return _data_size;
2256   }
2257 





2258   // Accessors
2259   Method* method() const { return _method; }
2260 
2261   // Get the data at an arbitrary (sort of) data index.
2262   ProfileData* data_at(int data_index) const;
2263 
2264   // Walk through the data in order.
2265   ProfileData* first_data() const { return data_at(first_di()); }
2266   ProfileData* next_data(ProfileData* current) const;
2267   bool is_valid(ProfileData* current) const { return current != NULL; }
2268 
2269   // Convert a dp (data pointer) to a di (data index).
2270   int dp_to_di(address dp) const {
2271     return dp - ((address)_data);
2272   }
2273 
2274   // bci to di/dp conversion.
2275   address bci_to_dp(int bci);
2276   int bci_to_di(int bci) {
2277     return dp_to_di(bci_to_dp(bci));
</pre>
<hr />
<pre>
2330     } else {
2331       return _trap_hist_mask + (++_nof_overflow_traps);
2332     }
2333   }
2334 
2335   uint overflow_trap_count() const {
2336     return _nof_overflow_traps;
2337   }
2338   uint overflow_recompile_count() const {
2339     return _nof_overflow_recompiles;
2340   }
2341   void inc_overflow_recompile_count() {
2342     _nof_overflow_recompiles += 1;
2343   }
2344   uint decompile_count() const {
2345     return _nof_decompiles;
2346   }
2347   void inc_decompile_count() {
2348     _nof_decompiles += 1;
2349     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
<span class="line-modified">2350       method()-&gt;set_not_compilable(CompLevel_full_optimization, true, &quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;);</span>
2351     }
2352   }
2353   uint tenure_traps() const {
2354     return _tenure_traps;
2355   }
2356   void inc_tenure_traps() {
2357     _tenure_traps += 1;
2358   }
2359 
2360   // Return pointer to area dedicated to parameters in MDO
2361   ParametersTypeData* parameters_type_data() const {
2362     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2363     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2364   }
2365 
2366   int parameters_type_data_di() const {
2367     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2368     return _parameters_type_data_di;
2369   }
2370 
</pre>
<hr />
<pre>
2383 
2384   static ByteSize backedge_counter_offset() {
2385     return byte_offset_of(MethodData, _backedge_counter);
2386   }
2387 
2388   static ByteSize invoke_mask_offset() {
2389     return byte_offset_of(MethodData, _invoke_mask);
2390   }
2391 
2392   static ByteSize backedge_mask_offset() {
2393     return byte_offset_of(MethodData, _backedge_mask);
2394   }
2395 
2396   static ByteSize parameters_type_data_di_offset() {
2397     return byte_offset_of(MethodData, _parameters_type_data_di);
2398   }
2399 
2400   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2401   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2402 
<span class="line-modified">2403   // Deallocation support - no pointer fields to deallocate</span>
2404   void deallocate_contents(ClassLoaderData* loader_data) {}
2405 
2406   // GC support
2407   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2408 
2409   // Printing
2410   void print_on      (outputStream* st) const;
2411   void print_value_on(outputStream* st) const;
2412 
2413   // printing support for method data
2414   void print_data_on(outputStream* st) const;
2415 
2416   const char* internal_name() const { return &quot;{method data}&quot;; }
2417 
2418   // verification
2419   void verify_on(outputStream* st);
2420   void verify_data_on(outputStream* st);
2421 
2422   static bool profile_parameters_for_method(const methodHandle&amp; m);
2423   static bool profile_arguments();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;

  29 #include &quot;oops/metadata.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;oops/oop.hpp&quot;
  32 #include &quot;runtime/atomic.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;



  34 
  35 class BytecodeStream;

  36 
  37 // The MethodData object collects counts and other profile information
  38 // during zeroth-tier (interpretive) and first-tier execution.
  39 // The profile is used later by compilation heuristics.  Some heuristics
  40 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  41 // optimization often has a down-side, a corner case that it handles
  42 // poorly, but which is thought to be rare.  The profile provides
  43 // evidence of this rarity for a given method or even BCI.  It allows
  44 // the compiler to back out of the optimization at places where it
  45 // has historically been a poor choice.  Other heuristics try to use
  46 // specific information gathered about types observed at a given site.
  47 //
  48 // All data in the profile is approximate.  It is expected to be accurate
  49 // on the whole, but the system expects occasional inaccuraces, due to
  50 // counter overflow, multiprocessor races during data collection, space
  51 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  52 // optimization quality but will not affect correctness.  Also, each MDO
  53 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  54 // to assess the quality (&quot;maturity&quot;) of its data.
  55 //
</pre>
<hr />
<pre>
 540   friend class JVMCIVMStructs;
 541 protected:
 542   enum {
 543     count_off,
 544     counter_cell_count
 545   };
 546 public:
 547   CounterData(DataLayout* layout) : BitData(layout) {}
 548 
 549   virtual bool is_CounterData() const { return true; }
 550 
 551   static int static_cell_count() {
 552     return counter_cell_count;
 553   }
 554 
 555   virtual int cell_count() const {
 556     return static_cell_count();
 557   }
 558 
 559   // Direct accessor
<span class="line-modified"> 560   int count() const {</span>
<span class="line-modified"> 561     intptr_t raw_data = intptr_at(count_off);</span>
<span class="line-added"> 562     if (raw_data &gt; max_jint) {</span>
<span class="line-added"> 563       raw_data = max_jint;</span>
<span class="line-added"> 564     } else if (raw_data &lt; min_jint) {</span>
<span class="line-added"> 565       raw_data = min_jint;</span>
<span class="line-added"> 566     }</span>
<span class="line-added"> 567     return int(raw_data);</span>
 568   }
 569 
 570   // Code generation support
 571   static ByteSize count_offset() {
 572     return cell_offset(count_off);
 573   }
 574   static ByteSize counter_data_size() {
 575     return cell_offset(counter_cell_count);
 576   }
 577 
<span class="line-modified"> 578   void set_count(int count) {</span>
<span class="line-modified"> 579     set_int_at(count_off, count);</span>
 580   }
 581 
 582   void print_data_on(outputStream* st, const char* extra = NULL) const;
 583 };
 584 
 585 // JumpData
 586 //
 587 // A JumpData is used to access profiling information for a direct
 588 // branch.  It is a counter, used for counting the number of branches,
 589 // plus a data displacement, used for realigning the data pointer to
 590 // the corresponding target bci.
 591 class JumpData : public ProfileData {
 592   friend class VMStructs;
 593   friend class JVMCIVMStructs;
 594 protected:
 595   enum {
 596     taken_off_set,
 597     displacement_off_set,
 598     jump_cell_count
 599   };
</pre>
<hr />
<pre>
1933 // in the array corresponding to the current bci.  In the course of
1934 // intepretation, when a bytecode is encountered that has profile data
1935 // associated with it, the entry pointed to by mdp is updated, then the
1936 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1937 // is NULL to begin with, the interpreter assumes that the current method
1938 // is not (yet) being profiled.
1939 //
1940 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1941 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1942 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1943 // in certain ProfileData objects that indicate the amount the mdp must be
1944 // adjusted in the event of a change in control flow.
1945 //
1946 
1947 class CleanExtraDataClosure : public StackObj {
1948 public:
1949   virtual bool is_live(Method* m) = 0;
1950 };
1951 
1952 
<span class="line-added">1953 #if INCLUDE_JVMCI</span>
<span class="line-added">1954 // Encapsulates an encoded speculation reason. These are linked together in</span>
<span class="line-added">1955 // a list that is atomically appended to during deoptimization. Entries are</span>
<span class="line-added">1956 // never removed from the list.</span>
<span class="line-added">1957 // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding</span>
<span class="line-added">1958 class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="line-added">1959  private:</span>
<span class="line-added">1960   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself</span>
<span class="line-added">1961   // is an array embedded at the end of this object.</span>
<span class="line-added">1962   int   _data_len;</span>
<span class="line-added">1963 </span>
<span class="line-added">1964   // Next entry in a linked list.</span>
<span class="line-added">1965   FailedSpeculation* _next;</span>
<span class="line-added">1966 </span>
<span class="line-added">1967   FailedSpeculation(address data, int data_len);</span>
<span class="line-added">1968 </span>
<span class="line-added">1969   FailedSpeculation** next_adr() { return &amp;_next; }</span>
<span class="line-added">1970 </span>
<span class="line-added">1971   // Placement new operator for inlining the speculation data into</span>
<span class="line-added">1972   // the FailedSpeculation object.</span>
<span class="line-added">1973   void* operator new(size_t size, size_t fs_size) throw();</span>
<span class="line-added">1974 </span>
<span class="line-added">1975  public:</span>
<span class="line-added">1976   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }</span>
<span class="line-added">1977   int data_len() const { return _data_len; }</span>
<span class="line-added">1978   FailedSpeculation* next() const { return _next; }</span>
<span class="line-added">1979 </span>
<span class="line-added">1980   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).</span>
<span class="line-added">1981   // Returns false if the FailedSpeculation object could not be allocated.</span>
<span class="line-added">1982   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);</span>
<span class="line-added">1983 </span>
<span class="line-added">1984   // Frees all entries in the linked list whose head is at (*failed_speculations_address).</span>
<span class="line-added">1985   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);</span>
<span class="line-added">1986 };</span>
<span class="line-added">1987 #endif</span>
<span class="line-added">1988 </span>
1989 class MethodData : public Metadata {
1990   friend class VMStructs;
1991   friend class JVMCIVMStructs;
1992 private:
1993   friend class ProfileData;
1994   friend class TypeEntriesAtCall;
1995 
1996   // If you add a new field that points to any metaspace object, you
1997   // must add this field to MethodData::metaspace_pointers_do().
1998 
1999   // Back pointer to the Method*
2000   Method* _method;
2001 
2002   // Size of this oop in bytes
2003   int _size;
2004 
2005   // Cached hint for bci_to_dp and bci_to_data
2006   int _hint_di;
2007 
2008   Mutex _extra_data_lock;
2009 
2010   MethodData(const methodHandle&amp; method, int size, TRAPS);
2011 public:
2012   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
<span class="line-modified">2013   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
2014 
2015   bool is_methodData() const volatile { return true; }
2016   void initialize();
2017 
2018   // Whole-method sticky bits and flags
2019   enum {
<span class="line-modified">2020     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
2021     _trap_hist_mask     = max_jubyte,
2022     _extra_data_count   = 4     // extra DataLayout headers, for trap history
2023   }; // Public flag values
2024 private:
2025   uint _nof_decompiles;             // count of all nmethod removals
2026   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
2027   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
2028   union {
2029     intptr_t _align;
2030     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
2031   } _trap_hist;
2032 
2033   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2034   intx              _eflags;          // flags on escape information
2035   intx              _arg_local;       // bit set of non-escaping arguments
2036   intx              _arg_stack;       // bit set of stack-allocatable arguments
2037   intx              _arg_returned;    // bit set of returned arguments
2038 
2039   int _creation_mileage;              // method mileage at MDO creation
2040 
</pre>
<hr />
<pre>
2050   int               _backedge_counter_start;
2051   uint              _tenure_traps;
2052   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2053   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2054 
2055 #if INCLUDE_RTM_OPT
2056   // State of RTM code generation during compilation of the method
2057   int               _rtm_state;
2058 #endif
2059 
2060   // Number of loops and blocks is computed when compiling the first
2061   // time with C1. It is used to determine if method is trivial.
2062   short             _num_loops;
2063   short             _num_blocks;
2064   // Does this method contain anything worth profiling?
2065   enum WouldProfile {unknown, no_profile, profile};
2066   WouldProfile      _would_profile;
2067 
2068 #if INCLUDE_JVMCI
2069   // Support for HotSpotMethodData.setCompiledIRSize(int)
<span class="line-modified">2070   int                _jvmci_ir_size;</span>
<span class="line-added">2071   FailedSpeculation* _failed_speculations;</span>
2072 #endif
2073 
2074   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2075   int _data_size;
2076 
2077   // data index for the area dedicated to parameters. -1 if no
2078   // parameter profiling.
2079   enum { no_parameters = -2, parameters_uninitialized = -1 };
2080   int _parameters_type_data_di;




2081 
2082   // Beginning of the data entries
2083   intptr_t _data[1];
2084 
2085   // Helper for size computation
2086   static int compute_data_size(BytecodeStream* stream);
2087   static int bytecode_cell_count(Bytecodes::Code code);
2088   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2089   enum { no_profile_data = -1, variable_cell_count = -2 };
2090 
2091   // Helper for initialization
2092   DataLayout* data_layout_at(int data_index) const {
2093     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2094     return (DataLayout*) (((address)_data) + data_index);
2095   }
2096 
2097   // Initialize an individual data segment.  Returns the size of
2098   // the segment in bytes.
2099   int initialize_data(BytecodeStream* stream, int data_index);
2100 
</pre>
<hr />
<pre>
2163   static int header_size() {
2164     return sizeof(MethodData)/wordSize;
2165   }
2166 
2167   // Compute the size of a MethodData* before it is created.
2168   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2169   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2170   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2171 
2172   // Determine if a given bytecode can have profile information.
2173   static bool bytecode_has_profile(Bytecodes::Code code) {
2174     return bytecode_cell_count(code) != no_profile_data;
2175   }
2176 
2177   // reset into original state
2178   void init();
2179 
2180   // My size
2181   int size_in_bytes() const { return _size; }
2182   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }



2183 
2184   int      creation_mileage() const  { return _creation_mileage; }
2185   void set_creation_mileage(int x)   { _creation_mileage = x; }
2186 
2187   int invocation_count() {
2188     if (invocation_counter()-&gt;carry()) {
2189       return InvocationCounter::count_limit;
2190     }
2191     return invocation_counter()-&gt;count();
2192   }
2193   int backedge_count() {
2194     if (backedge_counter()-&gt;carry()) {
2195       return InvocationCounter::count_limit;
2196     }
2197     return backedge_counter()-&gt;count();
2198   }
2199 
2200   int invocation_count_start() {
2201     if (invocation_counter()-&gt;carry()) {
2202       return 0;
</pre>
<hr />
<pre>
2205   }
2206 
2207   int backedge_count_start() {
2208     if (backedge_counter()-&gt;carry()) {
2209       return 0;
2210     }
2211     return _backedge_counter_start;
2212   }
2213 
2214   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2215   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2216 
2217   void reset_start_counters() {
2218     _invocation_counter_start = invocation_count();
2219     _backedge_counter_start = backedge_count();
2220   }
2221 
2222   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2223   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2224 
<span class="line-added">2225 #if INCLUDE_JVMCI</span>
<span class="line-added">2226   FailedSpeculation** get_failed_speculations_address() {</span>
<span class="line-added">2227     return &amp;_failed_speculations;</span>
<span class="line-added">2228   }</span>
<span class="line-added">2229 #endif</span>
<span class="line-added">2230 </span>
2231 #if INCLUDE_RTM_OPT
2232   int rtm_state() const {
2233     return _rtm_state;
2234   }
2235   void set_rtm_state(RTMState rstate) {
2236     _rtm_state = (int)rstate;
2237   }
2238   void atomic_set_rtm_state(RTMState rstate) {
<span class="line-modified">2239     Atomic::store(&amp;_rtm_state, (int)rstate);</span>
2240   }
2241 
2242   static int rtm_state_offset_in_bytes() {
2243     return offset_of(MethodData, _rtm_state);
2244   }
2245 #endif
2246 
2247   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2248   bool would_profile() const                  { return _would_profile != no_profile; }
2249 
2250   int num_loops() const                       { return _num_loops;  }
2251   void set_num_loops(int n)                   { _num_loops = n;     }
2252   int num_blocks() const                      { return _num_blocks; }
2253   void set_num_blocks(int n)                  { _num_blocks = n;    }
2254 
2255   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2256   static int mileage_of(Method* m);
2257 
2258   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2259   enum EscapeFlag {
</pre>
<hr />
<pre>
2275 
2276   void set_eflags(intx v)                        { _eflags = v; }
2277   void set_arg_local(intx v)                     { _arg_local = v; }
2278   void set_arg_stack(intx v)                     { _arg_stack = v; }
2279   void set_arg_returned(intx v)                  { _arg_returned = v; }
2280   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2281                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2282                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2283                                                    aid-&gt;set_arg_modified(a, v); }
2284 
2285   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2286 
2287   // Location and size of data area
2288   address data_base() const {
2289     return (address) _data;
2290   }
2291   int data_size() const {
2292     return _data_size;
2293   }
2294 
<span class="line-added">2295   int parameters_size_in_bytes() const {</span>
<span class="line-added">2296     ParametersTypeData* param = parameters_type_data();</span>
<span class="line-added">2297     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="line-added">2298   }</span>
<span class="line-added">2299 </span>
2300   // Accessors
2301   Method* method() const { return _method; }
2302 
2303   // Get the data at an arbitrary (sort of) data index.
2304   ProfileData* data_at(int data_index) const;
2305 
2306   // Walk through the data in order.
2307   ProfileData* first_data() const { return data_at(first_di()); }
2308   ProfileData* next_data(ProfileData* current) const;
2309   bool is_valid(ProfileData* current) const { return current != NULL; }
2310 
2311   // Convert a dp (data pointer) to a di (data index).
2312   int dp_to_di(address dp) const {
2313     return dp - ((address)_data);
2314   }
2315 
2316   // bci to di/dp conversion.
2317   address bci_to_dp(int bci);
2318   int bci_to_di(int bci) {
2319     return dp_to_di(bci_to_dp(bci));
</pre>
<hr />
<pre>
2372     } else {
2373       return _trap_hist_mask + (++_nof_overflow_traps);
2374     }
2375   }
2376 
2377   uint overflow_trap_count() const {
2378     return _nof_overflow_traps;
2379   }
2380   uint overflow_recompile_count() const {
2381     return _nof_overflow_recompiles;
2382   }
2383   void inc_overflow_recompile_count() {
2384     _nof_overflow_recompiles += 1;
2385   }
2386   uint decompile_count() const {
2387     return _nof_decompiles;
2388   }
2389   void inc_decompile_count() {
2390     _nof_decompiles += 1;
2391     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
<span class="line-modified">2392       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);</span>
2393     }
2394   }
2395   uint tenure_traps() const {
2396     return _tenure_traps;
2397   }
2398   void inc_tenure_traps() {
2399     _tenure_traps += 1;
2400   }
2401 
2402   // Return pointer to area dedicated to parameters in MDO
2403   ParametersTypeData* parameters_type_data() const {
2404     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2405     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2406   }
2407 
2408   int parameters_type_data_di() const {
2409     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2410     return _parameters_type_data_di;
2411   }
2412 
</pre>
<hr />
<pre>
2425 
2426   static ByteSize backedge_counter_offset() {
2427     return byte_offset_of(MethodData, _backedge_counter);
2428   }
2429 
2430   static ByteSize invoke_mask_offset() {
2431     return byte_offset_of(MethodData, _invoke_mask);
2432   }
2433 
2434   static ByteSize backedge_mask_offset() {
2435     return byte_offset_of(MethodData, _backedge_mask);
2436   }
2437 
2438   static ByteSize parameters_type_data_di_offset() {
2439     return byte_offset_of(MethodData, _parameters_type_data_di);
2440   }
2441 
2442   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2443   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2444 
<span class="line-modified">2445   // Deallocation support - no metaspace pointer fields to deallocate</span>
2446   void deallocate_contents(ClassLoaderData* loader_data) {}
2447 
2448   // GC support
2449   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2450 
2451   // Printing
2452   void print_on      (outputStream* st) const;
2453   void print_value_on(outputStream* st) const;
2454 
2455   // printing support for method data
2456   void print_data_on(outputStream* st) const;
2457 
2458   const char* internal_name() const { return &quot;{method data}&quot;; }
2459 
2460   // verification
2461   void verify_on(outputStream* st);
2462   void verify_data_on(outputStream* st);
2463 
2464   static bool profile_parameters_for_method(const methodHandle&amp; m);
2465   static bool profile_arguments();
</pre>
</td>
</tr>
</table>
<center><a href="methodData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
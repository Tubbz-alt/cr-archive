<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHOD_HPP
  26 #define SHARE_OOPS_METHOD_HPP
  27 
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;code/compressedStream.hpp&quot;
  30 #include &quot;compiler/compilerDefinitions.hpp&quot;
  31 #include &quot;compiler/oopMap.hpp&quot;
  32 #include &quot;interpreter/invocationCounter.hpp&quot;
  33 #include &quot;oops/annotations.hpp&quot;
  34 #include &quot;oops/constantPool.hpp&quot;
  35 #include &quot;oops/methodCounters.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/oop.hpp&quot;
  38 #include &quot;oops/typeArrayOop.hpp&quot;
  39 #include &quot;utilities/accessFlags.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;utilities/growableArray.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 #if INCLUDE_JFR
  44 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  45 #endif
  46 
  47 
  48 // A Method represents a Java method.
  49 //
  50 // Note that most applications load thousands of methods, so keeping the size of this
  51 // class small has a big impact on footprint.
  52 //
  53 // Note that native_function and signature_handler have to be at fixed offsets
  54 // (required by the interpreter)
  55 //
  56 //  Method embedded field layout (after declared fields):
  57 //   [EMBEDDED native_function       (present only if native) ]
  58 //   [EMBEDDED signature_handler     (present only if native) ]
  59 
  60 class CheckedExceptionElement;
  61 class LocalVariableTableElement;
  62 class AdapterHandlerEntry;
  63 class MethodData;
  64 class MethodCounters;
  65 class ConstMethod;
  66 class InlineTableSizes;
  67 class KlassSizeStats;
  68 class CompiledMethod;
  69 class InterpreterOopMap;
  70 
  71 class Method : public Metadata {
  72  friend class VMStructs;
  73  friend class JVMCIVMStructs;
  74  private:
  75   // If you add a new field that points to any metaspace object, you
  76   // must add this field to Method::metaspace_pointers_do().
  77   ConstMethod*      _constMethod;                // Method read-only data.
  78   MethodData*       _method_data;
  79   MethodCounters*   _method_counters;
  80   AccessFlags       _access_flags;               // Access flags
  81   int               _vtable_index;               // vtable index of this method (see VtableIndexFlag)
  82                                                  // note: can have vtables with &gt;2**16 elements (because of inheritance)
  83   u2                _intrinsic_id;               // vmSymbols::intrinsic_id (0 == _none)
  84 
  85   // Flags
  86   enum Flags {
  87     _caller_sensitive      = 1 &lt;&lt; 0,
  88     _force_inline          = 1 &lt;&lt; 1,
  89     _dont_inline           = 1 &lt;&lt; 2,
  90     _hidden                = 1 &lt;&lt; 3,
  91     _has_injected_profile  = 1 &lt;&lt; 4,
  92     _running_emcp          = 1 &lt;&lt; 5,
  93     _intrinsic_candidate   = 1 &lt;&lt; 6,
  94     _reserved_stack_access = 1 &lt;&lt; 7
  95   };
  96   mutable u2 _flags;
  97 
  98   JFR_ONLY(DEFINE_TRACE_FLAG;)
  99 
 100 #ifndef PRODUCT
 101   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 102 #endif
 103   // Entry point for calling both from and to the interpreter.
 104   address _i2i_entry;           // All-args-on-stack calling convention
 105   // Entry point for calling from compiled code, to compiled code if it exists
 106   // or else the interpreter.
 107   volatile address _from_compiled_entry;        // Cache of: _code ? _code-&gt;entry_point() : _adapter-&gt;c2i_entry()
 108   // The entry point for calling both from and to compiled code is
 109   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 110   // field can come and go.  It can transition from NULL to not-null at any
 111   // time (whenever a compile completes).  It can transition from not-null to
 112   // NULL only at safepoints (because of a de-opt).
 113   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 114   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry
 115 
 116 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 117   CompiledMethod* _aot_code;
 118 #endif
 119 
 120   // Constructor
 121   Method(ConstMethod* xconst, AccessFlags access_flags);
 122  public:
 123 
 124   static Method* allocate(ClassLoaderData* loader_data,
 125                           int byte_code_size,
 126                           AccessFlags access_flags,
 127                           InlineTableSizes* sizes,
 128                           ConstMethod::MethodType method_type,
 129                           TRAPS);
 130 
 131   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 132   Method(){}
 133 
 134   bool is_method() const volatile { return true; }
 135 
 136   void restore_unshareable_info(TRAPS);
 137 
 138   // accessors for instance variables
 139 
 140   ConstMethod* constMethod() const             { return _constMethod; }
 141   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 142 
 143 
 144   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 145   address from_compiled_entry() const;
 146   address from_compiled_entry_no_trampoline() const;
 147   address from_interpreted_entry() const;
 148 
 149   // access flag
 150   AccessFlags access_flags() const               { return _access_flags;  }
 151   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 152 
 153   // name
 154   Symbol* name() const                           { return constants()-&gt;symbol_at(name_index()); }
 155   int name_index() const                         { return constMethod()-&gt;name_index();         }
 156   void set_name_index(int index)                 { constMethod()-&gt;set_name_index(index);       }
 157 
 158   // signature
 159   Symbol* signature() const                      { return constants()-&gt;symbol_at(signature_index()); }
 160   int signature_index() const                    { return constMethod()-&gt;signature_index();         }
 161   void set_signature_index(int index)            { constMethod()-&gt;set_signature_index(index);       }
 162 
 163   // generics support
 164   Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()-&gt;symbol_at(idx) : (Symbol*)NULL); }
 165   int generic_signature_index() const            { return constMethod()-&gt;generic_signature_index(); }
 166   void set_generic_signature_index(int index)    { constMethod()-&gt;set_generic_signature_index(index); }
 167 
 168   // annotations support
 169   AnnotationArray* annotations() const           {
 170     return constMethod()-&gt;method_annotations();
 171   }
 172   AnnotationArray* parameter_annotations() const {
 173     return constMethod()-&gt;parameter_annotations();
 174   }
 175   AnnotationArray* annotation_default() const    {
 176     return constMethod()-&gt;default_annotations();
 177   }
 178   AnnotationArray* type_annotations() const      {
 179     return constMethod()-&gt;type_annotations();
 180   }
 181 
 182   // Helper routine: get klass name + &quot;.&quot; + method name + signature as
 183   // C string, for the purpose of providing more useful NoSuchMethodErrors
 184   // and fatal error handling. The string is allocated in resource
 185   // area if a buffer is not provided by the caller.
 186   char* name_and_sig_as_C_string() const;
 187   char* name_and_sig_as_C_string(char* buf, int size) const;
 188 
 189   // Static routine in the situations we don&#39;t have a Method*
 190   static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature);
 191   static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature, char* buf, int size);
 192 
 193   Bytecodes::Code java_code_at(int bci) const {
 194     return Bytecodes::java_code_at(this, bcp_from(bci));
 195   }
 196   Bytecodes::Code code_at(int bci) const {
 197     return Bytecodes::code_at(this, bcp_from(bci));
 198   }
 199 
 200   // JVMTI breakpoints
 201 #if !INCLUDE_JVMTI
 202   Bytecodes::Code orig_bytecode_at(int bci) const {
 203     ShouldNotReachHere();
 204     return Bytecodes::_shouldnotreachhere;
 205   }
 206   void set_orig_bytecode_at(int bci, Bytecodes::Code code) {
 207     ShouldNotReachHere();
 208   };
 209   u2   number_of_breakpoints() const {return 0;}
 210 #else // !INCLUDE_JVMTI
 211   Bytecodes::Code orig_bytecode_at(int bci) const;
 212   void set_orig_bytecode_at(int bci, Bytecodes::Code code);
 213   void set_breakpoint(int bci);
 214   void clear_breakpoint(int bci);
 215   void clear_all_breakpoints();
 216   // Tracking number of breakpoints, for fullspeed debugging.
 217   // Only mutated by VM thread.
 218   u2   number_of_breakpoints()             const {
 219     MethodCounters* mcs = method_counters();
 220     if (mcs == NULL) {
 221       return 0;
 222     } else {
 223       return mcs-&gt;number_of_breakpoints();
 224     }
 225   }
 226   void incr_number_of_breakpoints(TRAPS)         {
 227     MethodCounters* mcs = get_method_counters(CHECK);
 228     if (mcs != NULL) {
 229       mcs-&gt;incr_number_of_breakpoints();
 230     }
 231   }
 232   void decr_number_of_breakpoints(TRAPS)         {
 233     MethodCounters* mcs = get_method_counters(CHECK);
 234     if (mcs != NULL) {
 235       mcs-&gt;decr_number_of_breakpoints();
 236     }
 237   }
 238   // Initialization only
 239   void clear_number_of_breakpoints()             {
 240     MethodCounters* mcs = method_counters();
 241     if (mcs != NULL) {
 242       mcs-&gt;clear_number_of_breakpoints();
 243     }
 244   }
 245 #endif // !INCLUDE_JVMTI
 246 
 247   // index into InstanceKlass methods() array
 248   // note: also used by jfr
 249   u2 method_idnum() const           { return constMethod()-&gt;method_idnum(); }
 250   void set_method_idnum(u2 idnum)   { constMethod()-&gt;set_method_idnum(idnum); }
 251 
 252   u2 orig_method_idnum() const           { return constMethod()-&gt;orig_method_idnum(); }
 253   void set_orig_method_idnum(u2 idnum)   { constMethod()-&gt;set_orig_method_idnum(idnum); }
 254 
 255   // code size
 256   int code_size() const                  { return constMethod()-&gt;code_size(); }
 257 
 258   // method size in words
 259   int method_size() const                { return sizeof(Method)/wordSize + ( is_native() ? 2 : 0 ); }
 260 
 261   // constant pool for Klass* holding this method
 262   ConstantPool* constants() const              { return constMethod()-&gt;constants(); }
 263   void set_constants(ConstantPool* c)          { constMethod()-&gt;set_constants(c); }
 264 
 265   // max stack
 266   // return original max stack size for method verification
 267   int  verifier_max_stack() const                { return constMethod()-&gt;max_stack(); }
 268   int           max_stack() const                { return constMethod()-&gt;max_stack() + extra_stack_entries(); }
 269   void      set_max_stack(int size)              {        constMethod()-&gt;set_max_stack(size); }
 270 
 271   // max locals
 272   int  max_locals() const                        { return constMethod()-&gt;max_locals(); }
 273   void set_max_locals(int size)                  { constMethod()-&gt;set_max_locals(size); }
 274 
 275   int highest_comp_level() const;
 276   void set_highest_comp_level(int level);
 277   int highest_osr_comp_level() const;
 278   void set_highest_osr_comp_level(int level);
 279 
 280 #if COMPILER2_OR_JVMCI
 281   // Count of times method was exited via exception while interpreting
 282   void interpreter_throwout_increment(TRAPS) {
 283     MethodCounters* mcs = get_method_counters(CHECK);
 284     if (mcs != NULL) {
 285       mcs-&gt;interpreter_throwout_increment();
 286     }
 287   }
 288 #endif
 289 
 290   int  interpreter_throwout_count() const        {
 291     MethodCounters* mcs = method_counters();
 292     if (mcs == NULL) {
 293       return 0;
 294     } else {
 295       return mcs-&gt;interpreter_throwout_count();
 296     }
 297   }
 298 
 299   // size of parameters
 300   int  size_of_parameters() const                { return constMethod()-&gt;size_of_parameters(); }
 301   void set_size_of_parameters(int size)          { constMethod()-&gt;set_size_of_parameters(size); }
 302 
 303   bool has_stackmap_table() const {
 304     return constMethod()-&gt;has_stackmap_table();
 305   }
 306 
 307   Array&lt;u1&gt;* stackmap_data() const {
 308     return constMethod()-&gt;stackmap_data();
 309   }
 310 
 311   void set_stackmap_data(Array&lt;u1&gt;* sd) {
 312     constMethod()-&gt;set_stackmap_data(sd);
 313   }
 314 
 315   // exception handler table
 316   bool has_exception_handler() const
 317                              { return constMethod()-&gt;has_exception_handler(); }
 318   int exception_table_length() const
 319                              { return constMethod()-&gt;exception_table_length(); }
 320   ExceptionTableElement* exception_table_start() const
 321                              { return constMethod()-&gt;exception_table_start(); }
 322 
 323   // Finds the first entry point bci of an exception handler for an
 324   // exception of klass ex_klass thrown at throw_bci. A value of NULL
 325   // for ex_klass indicates that the exception klass is not known; in
 326   // this case it matches any constraint class. Returns -1 if the
 327   // exception cannot be handled in this method. The handler
 328   // constraint classes are loaded if necessary. Note that this may
 329   // throw an exception if loading of the constraint classes causes
 330   // an IllegalAccessError (bugid 4307310) or an OutOfMemoryError.
 331   // If an exception is thrown, returns the bci of the
 332   // exception handler which caused the exception to be thrown, which
 333   // is needed for proper retries. See, for example,
 334   // InterpreterRuntime::exception_handler_for_exception.
 335   static int fast_exception_handler_bci_for(const methodHandle&amp; mh, Klass* ex_klass, int throw_bci, TRAPS);
 336 
 337   // method data access
 338   MethodData* method_data() const              {
 339     return _method_data;
 340   }
 341 
 342   void set_method_data(MethodData* data);
 343 
 344   MethodCounters* method_counters() const {
 345     return _method_counters;
 346   }
 347 
 348   void clear_method_counters() {
 349     _method_counters = NULL;
 350   }
 351 
 352   bool init_method_counters(MethodCounters* counters);
 353 
 354 #ifdef TIERED
 355   // We are reusing interpreter_invocation_count as a holder for the previous event count!
 356   // We can do that since interpreter_invocation_count is not used in tiered.
 357   int prev_event_count() const                   {
 358     if (method_counters() == NULL) {
 359       return 0;
 360     } else {
 361       return method_counters()-&gt;interpreter_invocation_count();
 362     }
 363   }
 364   void set_prev_event_count(int count) {
 365     MethodCounters* mcs = method_counters();
 366     if (mcs != NULL) {
 367       mcs-&gt;set_interpreter_invocation_count(count);
 368     }
 369   }
 370   jlong prev_time() const                        {
 371     MethodCounters* mcs = method_counters();
 372     return mcs == NULL ? 0 : mcs-&gt;prev_time();
 373   }
 374   void set_prev_time(jlong time) {
 375     MethodCounters* mcs = method_counters();
 376     if (mcs != NULL) {
 377       mcs-&gt;set_prev_time(time);
 378     }
 379   }
 380   float rate() const                             {
 381     MethodCounters* mcs = method_counters();
 382     return mcs == NULL ? 0 : mcs-&gt;rate();
 383   }
 384   void set_rate(float rate) {
 385     MethodCounters* mcs = method_counters();
 386     if (mcs != NULL) {
 387       mcs-&gt;set_rate(rate);
 388     }
 389   }
 390 
 391 #if INCLUDE_AOT
 392   void set_aot_code(CompiledMethod* aot_code) {
 393     _aot_code = aot_code;
 394   }
 395 
 396   CompiledMethod* aot_code() const {
 397     return _aot_code;
 398   }
 399 #else
 400   CompiledMethod* aot_code() const { return NULL; }
 401 #endif // INCLUDE_AOT
 402 #endif // TIERED
 403 
 404   int nmethod_age() const {
 405     if (method_counters() == NULL) {
 406       return INT_MAX;
 407     } else {
 408       return method_counters()-&gt;nmethod_age();
 409     }
 410   }
 411 
 412   int invocation_count();
 413   int backedge_count();
 414 
 415   bool was_executed_more_than(int n);
 416   bool was_never_executed()                      { return !was_executed_more_than(0); }
 417 
 418   static void build_interpreter_method_data(const methodHandle&amp; method, TRAPS);
 419 
 420   static MethodCounters* build_method_counters(Method* m, TRAPS);
 421 
 422   int interpreter_invocation_count() {
 423     if (TieredCompilation) {
 424       return invocation_count();
 425     } else {
 426       MethodCounters* mcs = method_counters();
 427       return (mcs == NULL) ? 0 : mcs-&gt;interpreter_invocation_count();
 428     }
 429   }
 430 #if COMPILER2_OR_JVMCI
 431   int increment_interpreter_invocation_count(TRAPS) {
 432     if (TieredCompilation) ShouldNotReachHere();
 433     MethodCounters* mcs = get_method_counters(CHECK_0);
 434     return (mcs == NULL) ? 0 : mcs-&gt;increment_interpreter_invocation_count();
 435   }
 436 #endif
 437 
 438 #ifndef PRODUCT
 439   int  compiled_invocation_count() const         { return _compiled_invocation_count;  }
 440   void set_compiled_invocation_count(int count)  { _compiled_invocation_count = count; }
 441 #else
 442   // for PrintMethodData in a product build
 443   int  compiled_invocation_count() const         { return 0;  }
 444 #endif // not PRODUCT
 445 
 446   // Clear (non-shared space) pointers which could not be relevant
 447   // if this (shared) method were mapped into another JVM.
 448   void remove_unshareable_info();
 449 
 450   // nmethod/verified compiler entry
 451   address verified_code_entry();
 452   bool check_code() const;      // Not inline to avoid circular ref
 453   CompiledMethod* volatile code() const;
 454   void clear_code(bool acquire_lock = true);    // Clear out any compiled code
 455   static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
 456   void set_adapter_entry(AdapterHandlerEntry* adapter) {
 457     constMethod()-&gt;set_adapter_entry(adapter);
 458   }
 459   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
 460     constMethod()-&gt;update_adapter_trampoline(adapter);
 461   }
 462 
 463   address get_i2c_entry();
 464   address get_c2i_entry();
 465   address get_c2i_unverified_entry();
 466   AdapterHandlerEntry* adapter() const {
 467     return constMethod()-&gt;adapter();
 468   }
 469   // setup entry points
 470   void link_method(const methodHandle&amp; method, TRAPS);
 471   // clear entry points. Used by sharing code during dump time
 472   void unlink_method() NOT_CDS_RETURN;
 473 
 474   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 475   virtual MetaspaceObj::Type type() const { return MethodType; }
 476 
 477   // vtable index
 478   enum VtableIndexFlag {
 479     // Valid vtable indexes are non-negative (&gt;= 0).
 480     // These few negative values are used as sentinels.
 481     itable_index_max        = -10, // first itable index, growing downward
 482     pending_itable_index    = -9,  // itable index will be assigned
 483     invalid_vtable_index    = -4,  // distinct from any valid vtable index
 484     garbage_vtable_index    = -3,  // not yet linked; no vtable layout yet
 485     nonvirtual_vtable_index = -2   // there is no need for vtable dispatch
 486     // 6330203 Note:  Do not use -1, which was overloaded with many meanings.
 487   };
 488   DEBUG_ONLY(bool valid_vtable_index() const     { return _vtable_index &gt;= nonvirtual_vtable_index; })
 489   bool has_vtable_index() const                  { return _vtable_index &gt;= 0; }
 490   int  vtable_index() const                      { return _vtable_index; }
 491   void set_vtable_index(int index);
 492   DEBUG_ONLY(bool valid_itable_index() const     { return _vtable_index &lt;= pending_itable_index; })
 493   bool has_itable_index() const                  { return _vtable_index &lt;= itable_index_max; }
 494   int  itable_index() const                      { assert(valid_itable_index(), &quot;&quot;);
 495                                                    return itable_index_max - _vtable_index; }
 496   void set_itable_index(int index);
 497 
 498   // interpreter entry
 499   address interpreter_entry() const              { return _i2i_entry; }
 500   // Only used when first initialize so we can set _i2i_entry and _from_interpreted_entry
 501   void set_interpreter_entry(address entry) {
 502     assert(!is_shared(), &quot;shared method&#39;s interpreter entry should not be changed at run time&quot;);
 503     if (_i2i_entry != entry) {
 504       _i2i_entry = entry;
 505     }
 506     if (_from_interpreted_entry != entry) {
 507       _from_interpreted_entry = entry;
 508     }
 509   }
 510 
 511   // native function (used for native methods only)
 512   enum {
 513     native_bind_event_is_interesting = true
 514   };
 515   address native_function() const                { return *(native_function_addr()); }
 516   address critical_native_function();
 517 
 518   // Must specify a real function (not NULL).
 519   // Use clear_native_function() to unregister.
 520   void set_native_function(address function, bool post_event_flag);
 521   bool has_native_function() const;
 522   void clear_native_function();
 523 
 524   // signature handler (used for native methods only)
 525   address signature_handler() const              { return *(signature_handler_addr()); }
 526   void set_signature_handler(address handler);
 527 
 528   // Interpreter oopmap support
 529   void mask_for(int bci, InterpreterOopMap* mask);
 530 
 531   // operations on invocation counter
 532   void print_invocation_count();
 533 
 534   // byte codes
 535   void    set_code(address code)      { return constMethod()-&gt;set_code(code); }
 536   address code_base() const           { return constMethod()-&gt;code_base(); }
 537   bool    contains(address bcp) const { return constMethod()-&gt;contains(bcp); }
 538 
 539   // prints byte codes
 540   void print_codes() const            { print_codes_on(tty); }
 541   void print_codes_on(outputStream* st) const;
 542   void print_codes_on(int from, int to, outputStream* st) const;
 543 
 544   // method parameters
 545   bool has_method_parameters() const
 546                          { return constMethod()-&gt;has_method_parameters(); }
 547   int method_parameters_length() const
 548                          { return constMethod()-&gt;method_parameters_length(); }
 549   MethodParametersElement* method_parameters_start() const
 550                           { return constMethod()-&gt;method_parameters_start(); }
 551 
 552   // checked exceptions
 553   int checked_exceptions_length() const
 554                          { return constMethod()-&gt;checked_exceptions_length(); }
 555   CheckedExceptionElement* checked_exceptions_start() const
 556                           { return constMethod()-&gt;checked_exceptions_start(); }
 557 
 558   // localvariable table
 559   bool has_localvariable_table() const
 560                           { return constMethod()-&gt;has_localvariable_table(); }
 561   int localvariable_table_length() const
 562                         { return constMethod()-&gt;localvariable_table_length(); }
 563   LocalVariableTableElement* localvariable_table_start() const
 564                          { return constMethod()-&gt;localvariable_table_start(); }
 565 
 566   bool has_linenumber_table() const
 567                               { return constMethod()-&gt;has_linenumber_table(); }
 568   u_char* compressed_linenumber_table() const
 569                        { return constMethod()-&gt;compressed_linenumber_table(); }
 570 
 571   // method holder (the Klass* holding this method)
 572   InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
 573 
 574   void compute_size_of_parameters(Thread *thread); // word size of parameters (receiver if any + arguments)
 575   Symbol* klass_name() const;                    // returns the name of the method holder
 576   BasicType result_type() const;                 // type of the method result
 577   bool is_returning_oop() const                  { BasicType r = result_type(); return (r == T_OBJECT || r == T_ARRAY); }
 578   bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }
 579 
 580   // Checked exceptions thrown by this method (resolved to mirrors)
 581   objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
 582 
 583   // Access flags
 584   bool is_public() const                         { return access_flags().is_public();      }
 585   bool is_private() const                        { return access_flags().is_private();     }
 586   bool is_protected() const                      { return access_flags().is_protected();   }
 587   bool is_package_private() const                { return !is_public() &amp;&amp; !is_private() &amp;&amp; !is_protected(); }
 588   bool is_static() const                         { return access_flags().is_static();      }
 589   bool is_final() const                          { return access_flags().is_final();       }
 590   bool is_synchronized() const                   { return access_flags().is_synchronized();}
 591   bool is_native() const                         { return access_flags().is_native();      }
 592   bool is_abstract() const                       { return access_flags().is_abstract();    }
 593   bool is_strict() const                         { return access_flags().is_strict();      }
 594   bool is_synthetic() const                      { return access_flags().is_synthetic();   }
 595 
 596   // returns true if contains only return operation
 597   bool is_empty_method() const;
 598 
 599   // returns true if this is a vanilla constructor
 600   bool is_vanilla_constructor() const;
 601 
 602   // checks method and its method holder
 603   bool is_final_method() const;
 604   bool is_final_method(AccessFlags class_access_flags) const;
 605   // interface method declared with &#39;default&#39; - excludes private interface methods
 606   bool is_default_method() const;
 607 
 608   // true if method needs no dynamic dispatch (final and/or no vtable entry)
 609   bool can_be_statically_bound() const;
 610   bool can_be_statically_bound(AccessFlags class_access_flags) const;
 611 
 612   // returns true if the method has any backward branches.
 613   bool has_loops() {
 614     return access_flags().loops_flag_init() ? access_flags().has_loops() : compute_has_loops_flag();
 615   };
 616 
 617   bool compute_has_loops_flag();
 618 
 619   bool has_jsrs() {
 620     return access_flags().has_jsrs();
 621   };
 622   void set_has_jsrs() {
 623     _access_flags.set_has_jsrs();
 624   }
 625 
 626   // returns true if the method has any monitors.
 627   bool has_monitors() const                      { return is_synchronized() || access_flags().has_monitor_bytecodes(); }
 628   bool has_monitor_bytecodes() const             { return access_flags().has_monitor_bytecodes(); }
 629 
 630   void set_has_monitor_bytecodes()               { _access_flags.set_has_monitor_bytecodes(); }
 631 
 632   // monitor matching. This returns a conservative estimate of whether the monitorenter/monitorexit bytecodes
 633   // propererly nest in the method. It might return false, even though they actually nest properly, since the info.
 634   // has not been computed yet.
 635   bool guaranteed_monitor_matching() const       { return access_flags().is_monitor_matching(); }
 636   void set_guaranteed_monitor_matching()         { _access_flags.set_monitor_matching(); }
 637 
 638   // returns true if the method is an accessor function (setter/getter).
 639   bool is_accessor() const;
 640 
 641   // returns true if the method is a getter
 642   bool is_getter() const;
 643 
 644   // returns true if the method is a setter
 645   bool is_setter() const;
 646 
 647   // returns true if the method does nothing but return a constant of primitive type
 648   bool is_constant_getter() const;
 649 
 650   // returns true if the method is an initializer (&lt;init&gt; or &lt;clinit&gt;).
 651   bool is_initializer() const;
 652 
 653   // returns true if the method is static OR if the classfile version &lt; 51
 654   bool has_valid_initializer_flags() const;
 655 
 656   // returns true if the method name is &lt;clinit&gt; and the method has
 657   // valid static initializer flags.
 658   bool is_static_initializer() const;
 659 
 660   // returns true if the method name is &lt;init&gt;
 661   bool is_object_initializer() const;
 662 
 663   // compiled code support
 664   // NOTE: code() is inherently racy as deopt can be clearing code
 665   // simultaneously. Use with caution.
 666   bool has_compiled_code() const;
 667 
 668 #ifdef TIERED
 669   bool has_aot_code() const                      { return aot_code() != NULL; }
 670 #endif
 671 
 672   // sizing
 673   static int header_size()                       {
 674     return align_up((int)sizeof(Method), wordSize) / wordSize;
 675   }
 676   static int size(bool is_native);
 677   int size() const                               { return method_size(); }
 678 #if INCLUDE_SERVICES
 679   void collect_statistics(KlassSizeStats *sz) const;
 680 #endif
 681   void log_touched(TRAPS);
 682   static void print_touched_methods(outputStream* out);
 683 
 684   // interpreter support
 685   static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
 686   static ByteSize access_flags_offset()          { return byte_offset_of(Method, _access_flags      ); }
 687   static ByteSize from_compiled_offset()         { return byte_offset_of(Method, _from_compiled_entry); }
 688   static ByteSize code_offset()                  { return byte_offset_of(Method, _code); }
 689   static ByteSize method_data_offset()           {
 690     return byte_offset_of(Method, _method_data);
 691   }
 692   static ByteSize method_counters_offset()       {
 693     return byte_offset_of(Method, _method_counters);
 694   }
 695 #ifndef PRODUCT
 696   static ByteSize compiled_invocation_counter_offset() { return byte_offset_of(Method, _compiled_invocation_count); }
 697 #endif // not PRODUCT
 698   static ByteSize native_function_offset()       { return in_ByteSize(sizeof(Method));                 }
 699   static ByteSize from_interpreted_offset()      { return byte_offset_of(Method, _from_interpreted_entry ); }
 700   static ByteSize interpreter_entry_offset()     { return byte_offset_of(Method, _i2i_entry ); }
 701   static ByteSize signature_handler_offset()     { return in_ByteSize(sizeof(Method) + wordSize);      }
 702   static ByteSize itable_index_offset()          { return byte_offset_of(Method, _vtable_index ); }
 703 
 704   // for code generation
 705   static int method_data_offset_in_bytes()       { return offset_of(Method, _method_data); }
 706   static int intrinsic_id_offset_in_bytes()      { return offset_of(Method, _intrinsic_id); }
 707   static int intrinsic_id_size_in_bytes()        { return sizeof(u2); }
 708 
 709   // Static methods that are used to implement member methods where an exposed this pointer
 710   // is needed due to possible GCs
 711   static objArrayHandle resolved_checked_exceptions_impl(Method* method, TRAPS);
 712 
 713   // Returns the byte code index from the byte code pointer
 714   int     bci_from(address bcp) const;
 715   address bcp_from(int bci) const;
 716   address bcp_from(address bcp) const;
 717   int validate_bci_from_bcp(address bcp) const;
 718   int validate_bci(int bci) const;
 719 
 720   // Returns the line number for a bci if debugging information for the method is prowided,
 721   // -1 is returned otherwise.
 722   int line_number_from_bci(int bci) const;
 723 
 724   // Reflection support
 725   bool is_overridden_in(Klass* k) const;
 726 
 727   // Stack walking support
 728   bool is_ignored_by_security_stack_walk() const;
 729 
 730   // JSR 292 support
 731   bool is_method_handle_intrinsic() const;          // MethodHandles::is_signature_polymorphic_intrinsic(intrinsic_id)
 732   bool is_compiled_lambda_form() const;             // intrinsic_id() == vmIntrinsics::_compiledLambdaForm
 733   bool has_member_arg() const;                      // intrinsic_id() == vmIntrinsics::_linkToSpecial, etc.
 734   static methodHandle make_method_handle_intrinsic(vmIntrinsics::ID iid, // _invokeBasic, _linkToVirtual
 735                                                    Symbol* signature, //anything at all
 736                                                    TRAPS);
 737   static Klass* check_non_bcp_klass(Klass* klass);
 738 
 739   enum {
 740     // How many extra stack entries for invokedynamic
 741     extra_stack_entries_for_jsr292 = 1
 742   };
 743 
 744   // this operates only on invoke methods:
 745   // presize interpreter frames for extra interpreter stack entries, if needed
 746   // Account for the extra appendix argument for invokehandle/invokedynamic
 747   static int extra_stack_entries() { return extra_stack_entries_for_jsr292; }
 748   static int extra_stack_words();  // = extra_stack_entries() * Interpreter::stackElementSize
 749 
 750   // RedefineClasses() support:
 751   bool is_old() const                               { return access_flags().is_old(); }
 752   void set_is_old()                                 { _access_flags.set_is_old(); }
 753   bool is_obsolete() const                          { return access_flags().is_obsolete(); }
 754   void set_is_obsolete()                            { _access_flags.set_is_obsolete(); }
 755   bool is_deleted() const                           { return access_flags().is_deleted(); }
 756   void set_is_deleted()                             { _access_flags.set_is_deleted(); }
 757 
 758   bool is_running_emcp() const {
 759     // EMCP methods are old but not obsolete or deleted. Equivalent
 760     // Modulo Constant Pool means the method is equivalent except
 761     // the constant pool and instructions that access the constant
 762     // pool might be different.
 763     // If a breakpoint is set in a redefined method, its EMCP methods that are
 764     // still running must have a breakpoint also.
 765     return (_flags &amp; _running_emcp) != 0;
 766   }
 767 
 768   void set_running_emcp(bool x) {
 769     _flags = x ? (_flags | _running_emcp) : (_flags &amp; ~_running_emcp);
 770   }
 771 
 772   bool on_stack() const                             { return access_flags().on_stack(); }
 773   void set_on_stack(const bool value);
 774 
 775   // see the definition in Method*.cpp for the gory details
 776   bool should_not_be_cached() const;
 777 
 778   // JVMTI Native method prefixing support:
 779   bool is_prefixed_native() const                   { return access_flags().is_prefixed_native(); }
 780   void set_is_prefixed_native()                     { _access_flags.set_is_prefixed_native(); }
 781 
 782   // Rewriting support
 783   static methodHandle clone_with_new_data(const methodHandle&amp; m, u_char* new_code, int new_code_length,
 784                                           u_char* new_compressed_linenumber_table, int new_compressed_linenumber_size, TRAPS);
 785 
 786   // jmethodID handling
 787   // Because the useful life-span of a jmethodID cannot be determined,
 788   // once created they are never reclaimed.  The methods to which they refer,
 789   // however, can be GC&#39;ed away if the class is unloaded or if the method is
 790   // made obsolete or deleted -- in these cases, the jmethodID
 791   // refers to NULL (as is the case for any weak reference).
 792   static jmethodID make_jmethod_id(ClassLoaderData* loader_data, Method* mh);
 793   static void destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID mid);
 794 
 795   // Ensure there is enough capacity in the internal tracking data
 796   // structures to hold the number of jmethodIDs you plan to generate.
 797   // This saves substantial time doing allocations.
 798   static void ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity);
 799 
 800   // Use resolve_jmethod_id() in situations where the caller is expected
 801   // to provide a valid jmethodID; the only sanity checks are in asserts;
 802   // result guaranteed not to be NULL.
 803   inline static Method* resolve_jmethod_id(jmethodID mid) {
 804     assert(mid != NULL, &quot;JNI method id should not be null&quot;);
 805     return *((Method**)mid);
 806   }
 807 
 808   // Use checked_resolve_jmethod_id() in situations where the caller
 809   // should provide a valid jmethodID, but might not. NULL is returned
 810   // when the jmethodID does not refer to a valid method.
 811   static Method* checked_resolve_jmethod_id(jmethodID mid);
 812 
 813   static void change_method_associated_with_jmethod_id(jmethodID old_jmid_ptr, Method* new_method);
 814   static bool is_method_id(jmethodID mid);
 815 
 816   // Clear methods
 817   static void clear_jmethod_ids(ClassLoaderData* loader_data);
 818   static void print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;
 819 
 820   // Get this method&#39;s jmethodID -- allocate if it doesn&#39;t exist
 821   jmethodID jmethod_id()                            { return method_holder()-&gt;get_jmethod_id(this); }
 822 
 823   // Lookup the jmethodID for this method.  Return NULL if not found.
 824   // NOTE that this function can be called from a signal handler
 825   // (see AsyncGetCallTrace support for Forte Analyzer) and this
 826   // needs to be async-safe. No allocation should be done and
 827   // so handles are not used to avoid deadlock.
 828   jmethodID find_jmethod_id_or_null()               { return method_holder()-&gt;jmethod_id_or_null(this); }
 829 
 830   // Support for inlining of intrinsic methods
 831   vmIntrinsics::ID intrinsic_id() const          { return (vmIntrinsics::ID) _intrinsic_id;           }
 832   void     set_intrinsic_id(vmIntrinsics::ID id) {                           _intrinsic_id = (u2) id; }
 833 
 834   // Helper routines for intrinsic_id() and vmIntrinsics::method().
 835   void init_intrinsic_id();     // updates from _none if a match
 836   static vmSymbols::SID klass_id_for_intrinsics(const Klass* holder);
 837 
 838   bool caller_sensitive() {
 839     return (_flags &amp; _caller_sensitive) != 0;
 840   }
 841   void set_caller_sensitive(bool x) {
 842     _flags = x ? (_flags | _caller_sensitive) : (_flags &amp; ~_caller_sensitive);
 843   }
 844 
 845   bool force_inline() {
 846     return (_flags &amp; _force_inline) != 0;
 847   }
 848   void set_force_inline(bool x) {
 849     _flags = x ? (_flags | _force_inline) : (_flags &amp; ~_force_inline);
 850   }
 851 
 852   bool dont_inline() {
 853     return (_flags &amp; _dont_inline) != 0;
 854   }
 855   void set_dont_inline(bool x) {
 856     _flags = x ? (_flags | _dont_inline) : (_flags &amp; ~_dont_inline);
 857   }
 858 
 859   bool is_hidden() {
 860     return (_flags &amp; _hidden) != 0;
 861   }
 862   void set_hidden(bool x) {
 863     _flags = x ? (_flags | _hidden) : (_flags &amp; ~_hidden);
 864   }
 865 
 866   bool intrinsic_candidate() {
 867     return (_flags &amp; _intrinsic_candidate) != 0;
 868   }
 869   void set_intrinsic_candidate(bool x) {
 870     _flags = x ? (_flags | _intrinsic_candidate) : (_flags &amp; ~_intrinsic_candidate);
 871   }
 872 
 873   bool has_injected_profile() {
 874     return (_flags &amp; _has_injected_profile) != 0;
 875   }
 876   void set_has_injected_profile(bool x) {
 877     _flags = x ? (_flags | _has_injected_profile) : (_flags &amp; ~_has_injected_profile);
 878   }
 879 
 880   bool has_reserved_stack_access() {
 881     return (_flags &amp; _reserved_stack_access) != 0;
 882   }
 883 
 884   void set_has_reserved_stack_access(bool x) {
 885     _flags = x ? (_flags | _reserved_stack_access) : (_flags &amp; ~_reserved_stack_access);
 886   }
 887 
 888   JFR_ONLY(DEFINE_TRACE_FLAG_ACCESSOR;)
 889 
 890   ConstMethod::MethodType method_type() const {
 891       return _constMethod-&gt;method_type();
 892   }
 893   bool is_overpass() const { return method_type() == ConstMethod::OVERPASS; }
 894 
 895   // On-stack replacement support
 896   bool has_osr_nmethod(int level, bool match_level) {
 897    return method_holder()-&gt;lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;
 898   }
 899 
 900   int mark_osr_nmethods() {
 901     return method_holder()-&gt;mark_osr_nmethods(this);
 902   }
 903 
 904   nmethod* lookup_osr_nmethod_for(int bci, int level, bool match_level) {
 905     return method_holder()-&gt;lookup_osr_nmethod(this, bci, level, match_level);
 906   }
 907 
 908   // Find if klass for method is loaded
 909   bool is_klass_loaded_by_klass_index(int klass_index) const;
 910   bool is_klass_loaded(int refinfo_index, bool must_be_resolved = false) const;
 911 
 912   // Indicates whether compilation failed earlier for this method, or
 913   // whether it is not compilable for another reason like having a
 914   // breakpoint set in it.
 915   bool  is_not_compilable(int comp_level = CompLevel_any) const;
 916   void set_not_compilable(int comp_level = CompLevel_all, bool report = true, const char* reason = NULL);
 917   void set_not_compilable_quietly(int comp_level = CompLevel_all) {
 918     set_not_compilable(comp_level, false);
 919   }
 920   bool  is_not_osr_compilable(int comp_level = CompLevel_any) const;
 921   void set_not_osr_compilable(int comp_level = CompLevel_all, bool report = true, const char* reason = NULL);
 922   void set_not_osr_compilable_quietly(int comp_level = CompLevel_all) {
 923     set_not_osr_compilable(comp_level, false);
 924   }
 925   bool is_always_compilable() const;
 926 
 927  private:
 928   void print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason);
 929 
 930  public:
 931   MethodCounters* get_method_counters(TRAPS) {
 932     if (_method_counters == NULL) {
 933       build_method_counters(this, CHECK_AND_CLEAR_NULL);
 934     }
 935     return _method_counters;
 936   }
 937 
 938   bool   is_not_c1_compilable() const         { return access_flags().is_not_c1_compilable();  }
 939   void  set_not_c1_compilable()               {       _access_flags.set_not_c1_compilable();   }
 940   void clear_not_c1_compilable()              {       _access_flags.clear_not_c1_compilable(); }
 941   bool   is_not_c2_compilable() const         { return access_flags().is_not_c2_compilable();  }
 942   void  set_not_c2_compilable()               {       _access_flags.set_not_c2_compilable();   }
 943   void clear_not_c2_compilable()              {       _access_flags.clear_not_c2_compilable(); }
 944 
 945   bool    is_not_c1_osr_compilable() const    { return is_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
 946   void   set_not_c1_osr_compilable()          {       set_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
 947   void clear_not_c1_osr_compilable()          {     clear_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
 948   bool   is_not_c2_osr_compilable() const     { return access_flags().is_not_c2_osr_compilable();  }
 949   void  set_not_c2_osr_compilable()           {       _access_flags.set_not_c2_osr_compilable();   }
 950   void clear_not_c2_osr_compilable()          {       _access_flags.clear_not_c2_osr_compilable(); }
 951 
 952   // Background compilation support
 953   bool queued_for_compilation() const  { return access_flags().queued_for_compilation(); }
 954   void set_queued_for_compilation()    { _access_flags.set_queued_for_compilation();     }
 955   void clear_queued_for_compilation()  { _access_flags.clear_queued_for_compilation();   }
 956 
 957   // Resolve all classes in signature, return &#39;true&#39; if successful
 958   static bool load_signature_classes(const methodHandle&amp; m, TRAPS);
 959 
 960   // Return if true if not all classes references in signature, including return type, has been loaded
 961   static bool has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS);
 962 
 963   // Printing
 964   void print_short_name(outputStream* st = tty); // prints as klassname::methodname; Exposed so field engineers can debug VM
 965 #if INCLUDE_JVMTI
 966   void print_name(outputStream* st = tty); // prints as &quot;virtual void foo(int)&quot;; exposed for TraceRedefineClasses
 967 #else
 968   void print_name(outputStream* st = tty)        PRODUCT_RETURN; // prints as &quot;virtual void foo(int)&quot;
 969 #endif
 970 
 971   // Helper routine used for method sorting
 972   static void sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums = true);
 973 
 974   // Deallocation function for redefine classes or if an error occurs
 975   void deallocate_contents(ClassLoaderData* loader_data);
 976 
 977   Method* get_new_method() const {
 978     InstanceKlass* holder = method_holder();
 979     Method* new_method = holder-&gt;method_with_idnum(orig_method_idnum());
 980 
 981     assert(new_method != NULL, &quot;method_with_idnum() should not be NULL&quot;);
 982     assert(this != new_method, &quot;sanity check&quot;);
 983     return new_method;
 984   }
 985 
 986   // Printing
 987 #ifndef PRODUCT
 988   void print_on(outputStream* st) const;
 989 #endif
 990   void print_value_on(outputStream* st) const;
 991   void print_linkage_flags(outputStream* st) PRODUCT_RETURN;
 992 
 993   const char* internal_name() const { return &quot;{method}&quot;; }
 994 
 995   // Check for valid method pointer
 996   static bool has_method_vptr(const void* ptr);
 997   static bool is_valid_method(const Method* m);
 998 
 999   // Verify
1000   void verify() { verify_on(tty); }
1001   void verify_on(outputStream* st);
1002 
1003  private:
1004 
1005   // Inlined elements
1006   address* native_function_addr() const          { assert(is_native(), &quot;must be native&quot;); return (address*) (this+1); }
1007   address* signature_handler_addr() const        { return native_function_addr() + 1; }
1008 };
1009 
1010 
1011 // Utility class for compressing line number tables
1012 
1013 class CompressedLineNumberWriteStream: public CompressedWriteStream {
1014  private:
1015   int _bci;
1016   int _line;
1017  public:
1018   // Constructor
1019   CompressedLineNumberWriteStream(int initial_size) : CompressedWriteStream(initial_size), _bci(0), _line(0) {}
1020   CompressedLineNumberWriteStream(u_char* buffer, int initial_size) : CompressedWriteStream(buffer, initial_size), _bci(0), _line(0) {}
1021 
1022   // Write (bci, line number) pair to stream
1023   void write_pair_regular(int bci_delta, int line_delta);
1024 
1025   // If (bci delta, line delta) fits in (5-bit unsigned, 3-bit unsigned)
1026   // we save it as one byte, otherwise we write a 0xFF escape character
1027   // and use regular compression. 0x0 is used as end-of-stream terminator.
1028   void write_pair_inline(int bci, int line);
1029 
1030   void write_pair(int bci, int line);
1031 
1032   // Write end-of-stream marker
1033   void write_terminator()                        { write_byte(0); }
1034 };
1035 
1036 
1037 // Utility class for decompressing line number tables
1038 
1039 class CompressedLineNumberReadStream: public CompressedReadStream {
1040  private:
1041   int _bci;
1042   int _line;
1043  public:
1044   // Constructor
1045   CompressedLineNumberReadStream(u_char* buffer);
1046   // Read (bci, line number) pair from stream. Returns false at end-of-stream.
1047   bool read_pair();
1048   // Accessing bci and line number (after calling read_pair)
1049   int bci() const                               { return _bci; }
1050   int line() const                              { return _line; }
1051 };
1052 
1053 
1054 #if INCLUDE_JVMTI
1055 
1056 /// Fast Breakpoints.
1057 
1058 // If this structure gets more complicated (because bpts get numerous),
1059 // move it into its own header.
1060 
1061 // There is presently no provision for concurrent access
1062 // to breakpoint lists, which is only OK for JVMTI because
1063 // breakpoints are written only at safepoints, and are read
1064 // concurrently only outside of safepoints.
1065 
1066 class BreakpointInfo : public CHeapObj&lt;mtClass&gt; {
1067   friend class VMStructs;
1068  private:
1069   Bytecodes::Code  _orig_bytecode;
1070   int              _bci;
1071   u2               _name_index;       // of method
1072   u2               _signature_index;  // of method
1073   BreakpointInfo*  _next;             // simple storage allocation
1074 
1075  public:
1076   BreakpointInfo(Method* m, int bci);
1077 
1078   // accessors
1079   Bytecodes::Code orig_bytecode()                     { return _orig_bytecode; }
1080   void        set_orig_bytecode(Bytecodes::Code code) { _orig_bytecode = code; }
1081   int         bci()                                   { return _bci; }
1082 
1083   BreakpointInfo*          next() const               { return _next; }
1084   void                 set_next(BreakpointInfo* n)    { _next = n; }
1085 
1086   // helps for searchers
1087   bool match(const Method* m, int bci) {
1088     return bci == _bci &amp;&amp; match(m);
1089   }
1090 
1091   bool match(const Method* m) {
1092     return _name_index == m-&gt;name_index() &amp;&amp;
1093       _signature_index == m-&gt;signature_index();
1094   }
1095 
1096   void set(Method* method);
1097   void clear(Method* method);
1098 };
1099 
1100 #endif // INCLUDE_JVMTI
1101 
1102 // Utility class for access exception handlers
1103 class ExceptionTable : public StackObj {
1104  private:
1105   ExceptionTableElement* _table;
1106   u2  _length;
1107 
1108  public:
1109   ExceptionTable(const Method* m) {
1110     if (m-&gt;has_exception_handler()) {
1111       _table = m-&gt;exception_table_start();
1112       _length = m-&gt;exception_table_length();
1113     } else {
1114       _table = NULL;
1115       _length = 0;
1116     }
1117   }
1118 
1119   int length() const {
1120     return _length;
1121   }
1122 
1123   u2 start_pc(int idx) const {
1124     assert(idx &lt; _length, &quot;out of bounds&quot;);
1125     return _table[idx].start_pc;
1126   }
1127 
1128   void set_start_pc(int idx, u2 value) {
1129     assert(idx &lt; _length, &quot;out of bounds&quot;);
1130     _table[idx].start_pc = value;
1131   }
1132 
1133   u2 end_pc(int idx) const {
1134     assert(idx &lt; _length, &quot;out of bounds&quot;);
1135     return _table[idx].end_pc;
1136   }
1137 
1138   void set_end_pc(int idx, u2 value) {
1139     assert(idx &lt; _length, &quot;out of bounds&quot;);
1140     _table[idx].end_pc = value;
1141   }
1142 
1143   u2 handler_pc(int idx) const {
1144     assert(idx &lt; _length, &quot;out of bounds&quot;);
1145     return _table[idx].handler_pc;
1146   }
1147 
1148   void set_handler_pc(int idx, u2 value) {
1149     assert(idx &lt; _length, &quot;out of bounds&quot;);
1150     _table[idx].handler_pc = value;
1151   }
1152 
1153   u2 catch_type_index(int idx) const {
1154     assert(idx &lt; _length, &quot;out of bounds&quot;);
1155     return _table[idx].catch_type_index;
1156   }
1157 
1158   void set_catch_type_index(int idx, u2 value) {
1159     assert(idx &lt; _length, &quot;out of bounds&quot;);
1160     _table[idx].catch_type_index = value;
1161   }
1162 };
1163 
1164 #endif // SHARE_OOPS_METHOD_HPP
    </pre>
  </body>
</html>
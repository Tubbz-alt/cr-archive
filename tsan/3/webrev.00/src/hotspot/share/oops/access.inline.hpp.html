<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/access.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESS_INLINE_HPP
 26 #define SHARE_OOPS_ACCESS_INLINE_HPP
 27 
 28 #include &quot;gc/shared/barrierSet.inline.hpp&quot;
 29 #include &quot;gc/shared/barrierSetConfig.inline.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
 31 #include &quot;oops/accessBackend.inline.hpp&quot;
 32 
 33 // This file outlines the last 2 steps of the template pipeline of accesses going through
 34 // the Access API.
 35 // * Step 5.a: Barrier resolution. This step is invoked the first time a runtime-dispatch
 36 //             happens for an access. The appropriate BarrierSet::AccessBarrier accessor
 37 //             is resolved, then the function pointer is updated to that accessor for
 38 //             future invocations.
 39 // * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
 40 //             as the address type of an oop on the heap (is it oop* or narrowOop*) to
 41 //             the appropriate type. It also splits sufficiently orthogonal accesses into
 42 //             different functions, such as whether the access involves oops or primitives
 43 //             and whether the access is performed on the heap or outside. Then the
 44 //             appropriate BarrierSet::AccessBarrier is called to perform the access.
 45 
 46 namespace AccessInternal {
 47   // Step 5.b: Post-runtime dispatch.
 48   // This class is the last step before calling the BarrierSet::AccessBarrier.
 49   // Here we make sure to figure out types that were not known prior to the
 50   // runtime dispatch, such as whether an oop on the heap is oop or narrowOop.
 51   // We also split orthogonal barriers such as handling primitives vs oops
 52   // and on-heap vs off-heap into different calls to the barrier set.
 53   template &lt;class GCBarrierType, BarrierType type, DecoratorSet decorators&gt;
 54   struct PostRuntimeDispatch: public AllStatic { };
 55 
 56   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 57   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_STORE, decorators&gt;: public AllStatic {
 58     template &lt;typename T&gt;
 59     static void access_barrier(void* addr, T value) {
 60       GCBarrierType::store_in_heap(reinterpret_cast&lt;T*&gt;(addr), value);
 61     }
 62 
 63     static void oop_access_barrier(void* addr, oop value) {
 64       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 65       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 66         GCBarrierType::oop_store_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), value);
 67       } else {
 68         GCBarrierType::oop_store_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), value);
 69       }
 70     }
 71   };
 72 
 73   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 74   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD, decorators&gt;: public AllStatic {
 75     template &lt;typename T&gt;
 76     static T access_barrier(void* addr) {
 77       return GCBarrierType::load_in_heap(reinterpret_cast&lt;T*&gt;(addr));
 78     }
 79 
 80     static oop oop_access_barrier(void* addr) {
 81       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 82       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 83         return GCBarrierType::oop_load_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 84       } else {
 85         return GCBarrierType::oop_load_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 86       }
 87     }
 88   };
 89 
 90   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 91   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG, decorators&gt;: public AllStatic {
 92     template &lt;typename T&gt;
 93     static T access_barrier(void* addr, T new_value) {
 94       return GCBarrierType::atomic_xchg_in_heap(reinterpret_cast&lt;T*&gt;(addr), new_value);
 95     }
 96 
 97     static oop oop_access_barrier(void* addr, oop new_value) {
 98       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 99       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
100         return GCBarrierType::oop_atomic_xchg_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), new_value);
101       } else {
102         return GCBarrierType::oop_atomic_xchg_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), new_value);
103       }
104     }
105   };
106 
107   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
108   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG, decorators&gt;: public AllStatic {
109     template &lt;typename T&gt;
110     static T access_barrier(void* addr, T compare_value, T new_value) {
111       return GCBarrierType::atomic_cmpxchg_in_heap(reinterpret_cast&lt;T*&gt;(addr), compare_value, new_value);
112     }
113 
114     static oop oop_access_barrier(void* addr, oop compare_value, oop new_value) {
115       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
116       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
117         return GCBarrierType::oop_atomic_cmpxchg_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), compare_value, new_value);
118       } else {
119         return GCBarrierType::oop_atomic_cmpxchg_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), compare_value, new_value);
120       }
121     }
122   };
123 
124   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
125   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ARRAYCOPY, decorators&gt;: public AllStatic {
126     template &lt;typename T&gt;
127     static bool access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
128                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
129                                size_t length) {
130       GCBarrierType::arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw,
131                                        dst_obj, dst_offset_in_bytes, dst_raw,
132                                        length);
133       return true;
134     }
135 
136     template &lt;typename T&gt;
137     static bool oop_access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
138                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
139                                    size_t length) {
140       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
141       return GCBarrierType::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, reinterpret_cast&lt;OopType*&gt;(src_raw),
142                                                   dst_obj, dst_offset_in_bytes, reinterpret_cast&lt;OopType*&gt;(dst_raw),
143                                                   length);
144     }
145   };
146 
147   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
148   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_STORE_AT, decorators&gt;: public AllStatic {
149     template &lt;typename T&gt;
150     static void access_barrier(oop base, ptrdiff_t offset, T value) {
151       GCBarrierType::store_in_heap_at(base, offset, value);
152     }
153 
154     static void oop_access_barrier(oop base, ptrdiff_t offset, oop value) {
155       GCBarrierType::oop_store_in_heap_at(base, offset, value);
156     }
157   };
158 
159   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
160   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD_AT, decorators&gt;: public AllStatic {
161     template &lt;typename T&gt;
162     static T access_barrier(oop base, ptrdiff_t offset) {
163       return GCBarrierType::template load_in_heap_at&lt;T&gt;(base, offset);
164     }
165 
166     static oop oop_access_barrier(oop base, ptrdiff_t offset) {
167       return GCBarrierType::oop_load_in_heap_at(base, offset);
168     }
169   };
170 
171   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
172   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG_AT, decorators&gt;: public AllStatic {
173     template &lt;typename T&gt;
174     static T access_barrier(oop base, ptrdiff_t offset, T new_value) {
175       return GCBarrierType::atomic_xchg_in_heap_at(base, offset, new_value);
176     }
177 
178     static oop oop_access_barrier(oop base, ptrdiff_t offset, oop new_value) {
179       return GCBarrierType::oop_atomic_xchg_in_heap_at(base, offset, new_value);
180     }
181   };
182 
183   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
184   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG_AT, decorators&gt;: public AllStatic {
185     template &lt;typename T&gt;
186     static T access_barrier(oop base, ptrdiff_t offset, T compare_value, T new_value) {
187       return GCBarrierType::atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);
188     }
189 
190     static oop oop_access_barrier(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {
191       return GCBarrierType::oop_atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);
192     }
193   };
194 
195   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
196   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_CLONE, decorators&gt;: public AllStatic {
197     static void access_barrier(oop src, oop dst, size_t size) {
198       GCBarrierType::clone_in_heap(src, dst, size);
199     }
200   };
201 
202   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
203   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_RESOLVE, decorators&gt;: public AllStatic {
204     static oop access_barrier(oop obj) {
205       return GCBarrierType::resolve(obj);
206     }
207   };
208 
209   // Resolving accessors with barriers from the barrier set happens in two steps.
210   // 1. Expand paths with runtime-decorators, e.g. is UseCompressedOops on or off.
211   // 2. Expand paths for each BarrierSet available in the system.
212   template &lt;DecoratorSet decorators, typename FunctionPointerT, BarrierType barrier_type&gt;
213   struct BarrierResolver: public AllStatic {
214     template &lt;DecoratorSet ds&gt;
215     static typename EnableIf&lt;
216       HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
217       FunctionPointerT&gt;::type
218     resolve_barrier_gc() {
219       BarrierSet* bs = BarrierSet::barrier_set();
220       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
221       switch (bs-&gt;kind()) {
222 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
223         case BarrierSet::bs_name: {                                     \
224           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
225             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::oop_access_barrier; \
226         }                                                               \
227         break;
228         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
229 #undef BARRIER_SET_RESOLVE_BARRIER_CLOSURE
230 
231       default:
232         fatal(&quot;BarrierSet AccessBarrier resolving not implemented&quot;);
233         return NULL;
234       };
235     }
236 
237     template &lt;DecoratorSet ds&gt;
238     static typename EnableIf&lt;
239       !HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
240       FunctionPointerT&gt;::type
241     resolve_barrier_gc() {
242       BarrierSet* bs = BarrierSet::barrier_set();
243       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
244       switch (bs-&gt;kind()) {
245 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
246         case BarrierSet::bs_name: {                                       \
247           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
248             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::access_barrier; \
249         }                                                                 \
250         break;
251         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
252 #undef BARRIER_SET_RESOLVE_BARRIER_CLOSURE
253 
254       default:
255         fatal(&quot;BarrierSet AccessBarrier resolving not implemented&quot;);
256         return NULL;
257       };
258     }
259 
260     static FunctionPointerT resolve_barrier_rt() {
261       if (UseCompressedOops) {
262         const DecoratorSet expanded_decorators = decorators | INTERNAL_RT_USE_COMPRESSED_OOPS;
263         return resolve_barrier_gc&lt;expanded_decorators&gt;();
264       } else {
265         return resolve_barrier_gc&lt;decorators&gt;();
266       }
267     }
268 
269     static FunctionPointerT resolve_barrier() {
270       return resolve_barrier_rt();
271     }
272   };
273 
274   // Step 5.a: Barrier resolution
275   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
276   // accessor. This is required when the access either depends on whether compressed oops
277   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
278   // barriers). The way it works is that a function pointer initially pointing to an
279   // accessor resolution function gets called for each access. Upon first invocation,
280   // it resolves which accessor to be used in future invocations and patches the
281   // function pointer to this new accessor.
282 
283   template &lt;DecoratorSet decorators, typename T&gt;
284   void RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store_init(void* addr, T value) {
285     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE&gt;::resolve_barrier();
286     _store_func = function;
287     function(addr, value);
288   }
289 
290   template &lt;DecoratorSet decorators, typename T&gt;
291   void RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at_init(oop base, ptrdiff_t offset, T value) {
292     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE_AT&gt;::resolve_barrier();
293     _store_at_func = function;
294     function(base, offset, value);
295   }
296 
297   template &lt;DecoratorSet decorators, typename T&gt;
298   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load_init(void* addr) {
299     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD&gt;::resolve_barrier();
300     _load_func = function;
301     return function(addr);
302   }
303 
304   template &lt;DecoratorSet decorators, typename T&gt;
305   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at_init(oop base, ptrdiff_t offset) {
306     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD_AT&gt;::resolve_barrier();
307     _load_at_func = function;
308     return function(base, offset);
309   }
310 
311   template &lt;DecoratorSet decorators, typename T&gt;
312   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg_init(void* addr, T compare_value, T new_value) {
313     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG&gt;::resolve_barrier();
314     _atomic_cmpxchg_func = function;
315     return function(addr, compare_value, new_value);
316   }
317 
318   template &lt;DecoratorSet decorators, typename T&gt;
319   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value) {
320     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG_AT&gt;::resolve_barrier();
321     _atomic_cmpxchg_at_func = function;
322     return function(base, offset, compare_value, new_value);
323   }
324 
325   template &lt;DecoratorSet decorators, typename T&gt;
326   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg_init(void* addr, T new_value) {
327     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG&gt;::resolve_barrier();
328     _atomic_xchg_func = function;
329     return function(addr, new_value);
330   }
331 
332   template &lt;DecoratorSet decorators, typename T&gt;
333   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value) {
334     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG_AT&gt;::resolve_barrier();
335     _atomic_xchg_at_func = function;
336     return function(base, offset, new_value);
337   }
338 
339   template &lt;DecoratorSet decorators, typename T&gt;
340   bool RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
341                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
342                                                                          size_t length) {
343     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ARRAYCOPY&gt;::resolve_barrier();
344     _arraycopy_func = function;
345     return function(src_obj, src_offset_in_bytes, src_raw,
346                     dst_obj, dst_offset_in_bytes, dst_raw,
347                     length);
348   }
349 
350   template &lt;DecoratorSet decorators, typename T&gt;
351   void RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::clone_init(oop src, oop dst, size_t size) {
352     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_CLONE&gt;::resolve_barrier();
353     _clone_func = function;
354     function(src, dst, size);
355   }
356 
357   template &lt;DecoratorSet decorators, typename T&gt;
358   oop RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::resolve_init(oop obj) {
359     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_RESOLVE&gt;::resolve_barrier();
360     _resolve_func = function;
361     return function(obj);
362   }
363 }
364 
365 #endif // SHARE_OOPS_ACCESS_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/access.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESS_HPP
 26 #define SHARE_OOPS_ACCESS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/accessBackend.hpp&quot;
 30 #include &quot;oops/accessDecorators.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 
 36 // = GENERAL =
 37 // Access is an API for performing accesses with declarative semantics. Each access can have a number of &quot;decorators&quot;.
 38 // A decorator is an attribute or property that affects the way a memory access is performed in some way.
 39 // There are different groups of decorators. Some have to do with memory ordering, others to do with,
 40 // e.g. strength of references, strength of GC barriers, or whether compression should be applied or not.
 41 // Some decorators are set at buildtime, such as whether primitives require GC barriers or not, others
 42 // at callsites such as whether an access is in the heap or not, and others are resolved at runtime
 43 // such as GC-specific barriers and encoding/decoding compressed oops. For more information about what
 44 // decorators are available, cf. oops/accessDecorators.hpp.
 45 // By pipelining handling of these decorators, the design of the Access API allows separation of concern
 46 // over the different orthogonal concerns of decorators, while providing a powerful way of
 47 // expressing these orthogonal semantic properties in a unified way.
 48 //
 49 // == OPERATIONS ==
 50 // * load: Load a value from an address.
 51 // * load_at: Load a value from an internal pointer relative to a base object.
 52 // * store: Store a value at an address.
 53 // * store_at: Store a value in an internal pointer relative to a base object.
 54 // * atomic_cmpxchg: Atomically compare-and-swap a new value at an address if previous value matched the compared value.
 55 // * atomic_cmpxchg_at: Atomically compare-and-swap a new value at an internal pointer address if previous value matched the compared value.
 56 // * atomic_xchg: Atomically swap a new value at an address if previous value matched the compared value.
 57 // * atomic_xchg_at: Atomically swap a new value at an internal pointer address if previous value matched the compared value.
 58 // * arraycopy: Copy data from one heap array to another heap array. The ArrayAccess class has convenience functions for this.
 59 // * clone: Clone the contents of an object to a newly allocated object.
 60 // * resolve: Resolve a stable to-space invariant oop that is guaranteed not to relocate its payload until a subsequent thread transition.
<a name="1" id="anc1"></a><span class="line-removed"> 61 // * equals: Object equality, e.g. when different copies of the same objects are in use (from-space vs. to-space)</span>
 62 //
 63 // == IMPLEMENTATION ==
 64 // Each access goes through the following steps in a template pipeline.
 65 // There are essentially 5 steps for each access:
 66 // * Step 1:   Set default decorators and decay types. This step gets rid of CV qualifiers
 67 //             and sets default decorators to sensible values.
 68 // * Step 2:   Reduce types. This step makes sure there is only a single T type and not
 69 //             multiple types. The P type of the address and T type of the value must
 70 //             match.
 71 // * Step 3:   Pre-runtime dispatch. This step checks whether a runtime call can be
 72 //             avoided, and in that case avoids it (calling raw accesses or
 73 //             primitive accesses in a build that does not require primitive GC barriers)
 74 // * Step 4:   Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 75 //             BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 76 //             to the access.
 77 // * Step 5.a: Barrier resolution. This step is invoked the first time a runtime-dispatch
 78 //             happens for an access. The appropriate BarrierSet::AccessBarrier accessor
 79 //             is resolved, then the function pointer is updated to that accessor for
 80 //             future invocations.
 81 // * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
 82 //             as the address type of an oop on the heap (is it oop* or narrowOop*) to
 83 //             the appropriate type. It also splits sufficiently orthogonal accesses into
 84 //             different functions, such as whether the access involves oops or primitives
 85 //             and whether the access is performed on the heap or outside. Then the
 86 //             appropriate BarrierSet::AccessBarrier is called to perform the access.
 87 //
 88 // The implementation of step 1-4 resides in in accessBackend.hpp, to allow selected
 89 // accesses to be accessible from only access.hpp, as opposed to access.inline.hpp.
 90 // Steps 5.a and 5.b require knowledge about the GC backends, and therefore needs to
 91 // include the various GC backend .inline.hpp headers. Their implementation resides in
 92 // access.inline.hpp. The accesses that are allowed through the access.hpp file
 93 // must be instantiated in access.cpp using the INSTANTIATE_HPP_ACCESS macro.
 94 
 95 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
 96 class Access: public AllStatic {
 97   // This function asserts that if an access gets passed in a decorator outside
 98   // of the expected_decorators, then something is wrong. It additionally checks
 99   // the consistency of the decorators so that supposedly disjoint decorators are indeed
100   // disjoint. For example, an access can not be both in heap and on root at the
101   // same time.
102   template &lt;DecoratorSet expected_decorators&gt;
103   static void verify_decorators();
104 
105   template &lt;DecoratorSet expected_mo_decorators&gt;
106   static void verify_primitive_decorators() {
107     const DecoratorSet primitive_decorators = (AS_DECORATOR_MASK ^ AS_NO_KEEPALIVE) |
108                                               IN_HEAP | IS_ARRAY;
109     verify_decorators&lt;expected_mo_decorators | primitive_decorators&gt;();
110   }
111 
112   template &lt;DecoratorSet expected_mo_decorators&gt;
113   static void verify_oop_decorators() {
114     const DecoratorSet oop_decorators = AS_DECORATOR_MASK | IN_DECORATOR_MASK |
115                                         (ON_DECORATOR_MASK ^ ON_UNKNOWN_OOP_REF) | // no unknown oop refs outside of the heap
116                                         IS_ARRAY | IS_NOT_NULL | IS_DEST_UNINITIALIZED;
117     verify_decorators&lt;expected_mo_decorators | oop_decorators&gt;();
118   }
119 
120   template &lt;DecoratorSet expected_mo_decorators&gt;
121   static void verify_heap_oop_decorators() {
122     const DecoratorSet heap_oop_decorators = AS_DECORATOR_MASK | ON_DECORATOR_MASK |
123                                              IN_HEAP | IS_ARRAY | IS_NOT_NULL;
124     verify_decorators&lt;expected_mo_decorators | heap_oop_decorators&gt;();
125   }
126 
127   static const DecoratorSet load_mo_decorators = MO_UNORDERED | MO_VOLATILE | MO_RELAXED | MO_ACQUIRE | MO_SEQ_CST;
128   static const DecoratorSet store_mo_decorators = MO_UNORDERED | MO_VOLATILE | MO_RELAXED | MO_RELEASE | MO_SEQ_CST;
129   static const DecoratorSet atomic_xchg_mo_decorators = MO_SEQ_CST;
130   static const DecoratorSet atomic_cmpxchg_mo_decorators = MO_RELAXED | MO_SEQ_CST;
131 
132 protected:
133   template &lt;typename T&gt;
134   static inline bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
135                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
136                                    size_t length) {
137     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
138                       AS_DECORATOR_MASK | IS_ARRAY | IS_DEST_UNINITIALIZED&gt;();
139     return AccessInternal::arraycopy&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(src_obj, src_offset_in_bytes, src_raw,
140                                                                          dst_obj, dst_offset_in_bytes, dst_raw,
141                                                                          length);
142   }
143 
144   template &lt;typename T&gt;
145   static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
146                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
147                                size_t length) {
148     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
149                       AS_DECORATOR_MASK | IS_ARRAY&gt;();
150     AccessInternal::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
151                                           dst_obj, dst_offset_in_bytes, dst_raw,
152                                           length);
153   }
154 
155 public:
156   // Primitive heap accesses
157   static inline AccessInternal::LoadAtProxy&lt;decorators&gt; load_at(oop base, ptrdiff_t offset) {
158     verify_primitive_decorators&lt;load_mo_decorators&gt;();
159     return AccessInternal::LoadAtProxy&lt;decorators&gt;(base, offset);
160   }
161 
162   template &lt;typename T&gt;
163   static inline void store_at(oop base, ptrdiff_t offset, T value) {
164     verify_primitive_decorators&lt;store_mo_decorators&gt;();
165     AccessInternal::store_at&lt;decorators&gt;(base, offset, value);
166   }
167 
168   template &lt;typename T&gt;
<a name="2" id="anc2"></a><span class="line-modified">169   static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
170     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<a name="3" id="anc3"></a><span class="line-modified">171     return AccessInternal::atomic_cmpxchg_at&lt;decorators&gt;(new_value, base, offset, compare_value);</span>
172   }
173 
174   template &lt;typename T&gt;
<a name="4" id="anc4"></a><span class="line-modified">175   static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
176     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<a name="5" id="anc5"></a><span class="line-modified">177     return AccessInternal::atomic_xchg_at&lt;decorators&gt;(new_value, base, offset);</span>
178   }
179 
180   // Oop heap accesses
181   static inline AccessInternal::OopLoadAtProxy&lt;decorators&gt; oop_load_at(oop base, ptrdiff_t offset) {
182     verify_heap_oop_decorators&lt;load_mo_decorators&gt;();
183     return AccessInternal::OopLoadAtProxy&lt;decorators&gt;(base, offset);
184   }
185 
186   template &lt;typename T&gt;
187   static inline void oop_store_at(oop base, ptrdiff_t offset, T value) {
188     verify_heap_oop_decorators&lt;store_mo_decorators&gt;();
189     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
190     OopType oop_value = value;
191     AccessInternal::store_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, oop_value);
192   }
193 
194   template &lt;typename T&gt;
<a name="6" id="anc6"></a><span class="line-modified">195   static inline T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
196     verify_heap_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
197     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
198     OopType new_oop_value = new_value;
199     OopType compare_oop_value = compare_value;
<a name="7" id="anc7"></a><span class="line-modified">200     return AccessInternal::atomic_cmpxchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, base, offset, compare_oop_value);</span>
201   }
202 
203   template &lt;typename T&gt;
<a name="8" id="anc8"></a><span class="line-modified">204   static inline T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
205     verify_heap_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
206     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
207     OopType new_oop_value = new_value;
<a name="9" id="anc9"></a><span class="line-modified">208     return AccessInternal::atomic_xchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, base, offset);</span>
209   }
210 
211   // Clone an object from src to dst
212   static inline void clone(oop src, oop dst, size_t size) {
213     verify_decorators&lt;IN_HEAP&gt;();
214     AccessInternal::clone&lt;decorators&gt;(src, dst, size);
215   }
216 
217   // Primitive accesses
218   template &lt;typename P&gt;
219   static inline P load(P* addr) {
220     verify_primitive_decorators&lt;load_mo_decorators&gt;();
221     return AccessInternal::load&lt;decorators, P, P&gt;(addr);
222   }
223 
224   template &lt;typename P, typename T&gt;
225   static inline void store(P* addr, T value) {
226     verify_primitive_decorators&lt;store_mo_decorators&gt;();
227     AccessInternal::store&lt;decorators&gt;(addr, value);
228   }
229 
230   template &lt;typename P, typename T&gt;
<a name="10" id="anc10"></a><span class="line-modified">231   static inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
232     verify_primitive_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
<a name="11" id="anc11"></a><span class="line-modified">233     return AccessInternal::atomic_cmpxchg&lt;decorators&gt;(new_value, addr, compare_value);</span>
234   }
235 
236   template &lt;typename P, typename T&gt;
<a name="12" id="anc12"></a><span class="line-modified">237   static inline T atomic_xchg(T new_value, P* addr) {</span>
238     verify_primitive_decorators&lt;atomic_xchg_mo_decorators&gt;();
<a name="13" id="anc13"></a><span class="line-modified">239     return AccessInternal::atomic_xchg&lt;decorators&gt;(new_value, addr);</span>
240   }
241 
242   // Oop accesses
243   template &lt;typename P&gt;
244   static inline AccessInternal::OopLoadProxy&lt;P, decorators&gt; oop_load(P* addr) {
245     verify_oop_decorators&lt;load_mo_decorators&gt;();
246     return AccessInternal::OopLoadProxy&lt;P, decorators&gt;(addr);
247   }
248 
249   template &lt;typename P, typename T&gt;
250   static inline void oop_store(P* addr, T value) {
251     verify_oop_decorators&lt;store_mo_decorators&gt;();
252     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
253     OopType oop_value = value;
254     AccessInternal::store&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(addr, oop_value);
255   }
256 
257   template &lt;typename P, typename T&gt;
<a name="14" id="anc14"></a><span class="line-modified">258   static inline T oop_atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
259     verify_oop_decorators&lt;atomic_cmpxchg_mo_decorators&gt;();
260     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
261     OopType new_oop_value = new_value;
262     OopType compare_oop_value = compare_value;
<a name="15" id="anc15"></a><span class="line-modified">263     return AccessInternal::atomic_cmpxchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, addr, compare_oop_value);</span>
264   }
265 
266   template &lt;typename P, typename T&gt;
<a name="16" id="anc16"></a><span class="line-modified">267   static inline T oop_atomic_xchg(T new_value, P* addr) {</span>
268     verify_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
269     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
270     OopType new_oop_value = new_value;
<a name="17" id="anc17"></a><span class="line-modified">271     return AccessInternal::atomic_xchg&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(new_oop_value, addr);</span>
272   }
273 
274   static oop resolve(oop obj) {
275     verify_decorators&lt;DECORATORS_NONE&gt;();
276     return AccessInternal::resolve&lt;decorators&gt;(obj);
277   }
<a name="18" id="anc18"></a><span class="line-removed">278 </span>
<span class="line-removed">279   static bool equals(oop o1, oop o2) {</span>
<span class="line-removed">280     verify_decorators&lt;AS_RAW&gt;();</span>
<span class="line-removed">281     return AccessInternal::equals&lt;decorators&gt;(o1, o2);</span>
<span class="line-removed">282   }</span>
283 };
284 
285 // Helper for performing raw accesses (knows only of memory ordering
286 // atomicity decorators as well as compressed oops)
287 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
288 class RawAccess: public Access&lt;AS_RAW | decorators&gt; {};
289 
290 // Helper for performing normal accesses on the heap. These accesses
291 // may resolve an accessor on a GC barrier set
292 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
293 class HeapAccess: public Access&lt;IN_HEAP | decorators&gt; {};
294 
295 // Helper for performing normal accesses in roots. These accesses
296 // may resolve an accessor on a GC barrier set
297 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
298 class NativeAccess: public Access&lt;IN_NATIVE | decorators&gt; {};
299 
300 // Helper for array access.
301 template &lt;DecoratorSet decorators = DECORATORS_NONE&gt;
302 class ArrayAccess: public HeapAccess&lt;IS_ARRAY | decorators&gt; {
303   typedef HeapAccess&lt;IS_ARRAY | decorators&gt; AccessT;
304 public:
305   template &lt;typename T&gt;
306   static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes,
307                                arrayOop dst_obj, size_t dst_offset_in_bytes,
308                                size_t length) {
309     AccessT::arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast&lt;const T*&gt;(NULL),
310                        dst_obj, dst_offset_in_bytes, reinterpret_cast&lt;T*&gt;(NULL),
311                        length);
312   }
313 
314   template &lt;typename T&gt;
315   static inline void arraycopy_to_native(arrayOop src_obj, size_t src_offset_in_bytes,
316                                          T* dst,
317                                          size_t length) {
318     AccessT::arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast&lt;const T*&gt;(NULL),
319                        NULL, 0, dst,
320                        length);
321   }
322 
323   template &lt;typename T&gt;
324   static inline void arraycopy_from_native(const T* src,
325                                            arrayOop dst_obj, size_t dst_offset_in_bytes,
326                                            size_t length) {
327     AccessT::arraycopy(NULL, 0, src,
328                        dst_obj, dst_offset_in_bytes, reinterpret_cast&lt;T*&gt;(NULL),
329                        length);
330   }
331 
332   static inline bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes,
333                                    arrayOop dst_obj, size_t dst_offset_in_bytes,
334                                    size_t length) {
335     return AccessT::oop_arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast&lt;const HeapWord*&gt;(NULL),
336                                   dst_obj, dst_offset_in_bytes, reinterpret_cast&lt;HeapWord*&gt;(NULL),
337                                   length);
338   }
339 
340   template &lt;typename T&gt;
341   static inline bool oop_arraycopy_raw(T* src, T* dst, size_t length) {
342     return AccessT::oop_arraycopy(NULL, 0, src,
343                                   NULL, 0, dst,
344                                   length);
345   }
346 
347 };
348 
349 template &lt;DecoratorSet decorators&gt;
350 template &lt;DecoratorSet expected_decorators&gt;
351 void Access&lt;decorators&gt;::verify_decorators() {
352   STATIC_ASSERT((~expected_decorators &amp; decorators) == 0); // unexpected decorator used
353   const DecoratorSet barrier_strength_decorators = decorators &amp; AS_DECORATOR_MASK;
354   STATIC_ASSERT(barrier_strength_decorators == 0 || ( // make sure barrier strength decorators are disjoint if set
355     (barrier_strength_decorators ^ AS_NO_KEEPALIVE) == 0 ||
356     (barrier_strength_decorators ^ AS_RAW) == 0 ||
357     (barrier_strength_decorators ^ AS_NORMAL) == 0
358   ));
359   const DecoratorSet ref_strength_decorators = decorators &amp; ON_DECORATOR_MASK;
360   STATIC_ASSERT(ref_strength_decorators == 0 || ( // make sure ref strength decorators are disjoint if set
361     (ref_strength_decorators ^ ON_STRONG_OOP_REF) == 0 ||
362     (ref_strength_decorators ^ ON_WEAK_OOP_REF) == 0 ||
363     (ref_strength_decorators ^ ON_PHANTOM_OOP_REF) == 0 ||
364     (ref_strength_decorators ^ ON_UNKNOWN_OOP_REF) == 0
365   ));
366   const DecoratorSet memory_ordering_decorators = decorators &amp; MO_DECORATOR_MASK;
367   STATIC_ASSERT(memory_ordering_decorators == 0 || ( // make sure memory ordering decorators are disjoint if set
368     (memory_ordering_decorators ^ MO_UNORDERED) == 0 ||
369     (memory_ordering_decorators ^ MO_VOLATILE) == 0 ||
370     (memory_ordering_decorators ^ MO_RELAXED) == 0 ||
371     (memory_ordering_decorators ^ MO_ACQUIRE) == 0 ||
372     (memory_ordering_decorators ^ MO_RELEASE) == 0 ||
373     (memory_ordering_decorators ^ MO_SEQ_CST) == 0
374   ));
375   const DecoratorSet location_decorators = decorators &amp; IN_DECORATOR_MASK;
376   STATIC_ASSERT(location_decorators == 0 || ( // make sure location decorators are disjoint if set
377     (location_decorators ^ IN_NATIVE) == 0 ||
378     (location_decorators ^ IN_HEAP) == 0
379   ));
380 }
381 
382 #endif // SHARE_OOPS_ACCESS_HPP
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
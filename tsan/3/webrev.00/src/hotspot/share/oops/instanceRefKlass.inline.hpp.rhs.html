<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/instanceRefKlass.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
 26 #define SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;oops/access.inline.hpp&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;oops/instanceKlass.inline.hpp&quot;
 33 #include &quot;oops/instanceRefKlass.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
 39 template &lt;typename T, class OopClosureType, class Contains&gt;
 40 void InstanceRefKlass::do_referent(oop obj, OopClosureType* closure, Contains&amp; contains) {
 41   T* referent_addr = (T*)java_lang_ref_Reference::referent_addr_raw(obj);
 42   if (contains(referent_addr)) {
 43     Devirtualizer::do_oop(closure, referent_addr);
 44   }
 45 }
 46 
 47 template &lt;typename T, class OopClosureType, class Contains&gt;
 48 void InstanceRefKlass::do_discovered(oop obj, OopClosureType* closure, Contains&amp; contains) {
 49   T* discovered_addr = (T*)java_lang_ref_Reference::discovered_addr_raw(obj);
 50   if (contains(discovered_addr)) {
 51     Devirtualizer::do_oop(closure, discovered_addr);
 52   }
 53 }
 54 
 55 static inline oop load_referent(oop obj, ReferenceType type) {
 56   if (type == REF_PHANTOM) {
 57     return HeapAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(java_lang_ref_Reference::referent_addr_raw(obj));
 58   } else {
 59     return HeapAccess&lt;ON_WEAK_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(java_lang_ref_Reference::referent_addr_raw(obj));
 60   }
 61 }
 62 
 63 template &lt;typename T, class OopClosureType&gt;
 64 bool InstanceRefKlass::try_discover(oop obj, ReferenceType type, OopClosureType* closure) {
 65   ReferenceDiscoverer* rd = closure-&gt;ref_discoverer();
 66   if (rd != NULL) {
 67     oop referent = load_referent(obj, type);
 68     if (referent != NULL) {
 69       if (!referent-&gt;is_gc_marked()) {
 70         // Only try to discover if not yet marked.
 71         return rd-&gt;discover_reference(obj, type);
 72       }
 73     }
 74   }
 75   return false;
 76 }
 77 
 78 template &lt;typename T, class OopClosureType, class Contains&gt;
 79 void InstanceRefKlass::oop_oop_iterate_discovery(oop obj, ReferenceType type, OopClosureType* closure, Contains&amp; contains) {
 80   // Try to discover reference and return if it succeeds.
 81   if (try_discover&lt;T&gt;(obj, type, closure)) {
 82     return;
 83   }
 84 
 85   // Treat referent and discovered as normal oops.
 86   do_referent&lt;T&gt;(obj, closure, contains);
 87   do_discovered&lt;T&gt;(obj, closure, contains);
 88 }
 89 
 90 template &lt;typename T, class OopClosureType, class Contains&gt;
 91 void InstanceRefKlass::oop_oop_iterate_discovered_and_discovery(oop obj, ReferenceType type, OopClosureType* closure, Contains&amp; contains) {
 92   // Explicitly apply closure to the discovered field.
 93   do_discovered&lt;T&gt;(obj, closure, contains);
 94   // Then do normal reference processing with discovery.
 95   oop_oop_iterate_discovery&lt;T&gt;(obj, type, closure, contains);
 96 }
 97 
 98 template &lt;typename T, class OopClosureType, class Contains&gt;
 99 void InstanceRefKlass::oop_oop_iterate_fields(oop obj, OopClosureType* closure, Contains&amp; contains) {
100   assert(closure-&gt;ref_discoverer() == NULL, &quot;ReferenceDiscoverer should not be set&quot;);
101   do_referent&lt;T&gt;(obj, closure, contains);
102   do_discovered&lt;T&gt;(obj, closure, contains);
103 }
104 
105 template &lt;typename T, class OopClosureType, class Contains&gt;
106 void InstanceRefKlass::oop_oop_iterate_fields_except_referent(oop obj, OopClosureType* closure, Contains&amp; contains) {
107   assert(closure-&gt;ref_discoverer() == NULL, &quot;ReferenceDiscoverer should not be set&quot;);
108   do_discovered&lt;T&gt;(obj, closure, contains);
109 }
110 
111 template &lt;typename T, class OopClosureType, class Contains&gt;
112 void InstanceRefKlass::oop_oop_iterate_ref_processing(oop obj, OopClosureType* closure, Contains&amp; contains) {
113   switch (closure-&gt;reference_iteration_mode()) {
114     case OopIterateClosure::DO_DISCOVERY:
115       trace_reference_gc&lt;T&gt;(&quot;do_discovery&quot;, obj);
116       oop_oop_iterate_discovery&lt;T&gt;(obj, reference_type(), closure, contains);
117       break;
118     case OopIterateClosure::DO_DISCOVERED_AND_DISCOVERY:
119       trace_reference_gc&lt;T&gt;(&quot;do_discovered_and_discovery&quot;, obj);
120       oop_oop_iterate_discovered_and_discovery&lt;T&gt;(obj, reference_type(), closure, contains);
121       break;
122     case OopIterateClosure::DO_FIELDS:
123       trace_reference_gc&lt;T&gt;(&quot;do_fields&quot;, obj);
124       oop_oop_iterate_fields&lt;T&gt;(obj, closure, contains);
125       break;
126     case OopIterateClosure::DO_FIELDS_EXCEPT_REFERENT:
127       trace_reference_gc&lt;T&gt;(&quot;do_fields_except_referent&quot;, obj);
128       oop_oop_iterate_fields_except_referent&lt;T&gt;(obj, closure, contains);
129       break;
130     default:
131       ShouldNotReachHere();
132   }
133 }
134 
135 class AlwaysContains {
136  public:
137   template &lt;typename T&gt; bool operator()(T* p) const { return true; }
138 };
139 
140 template &lt;typename T, class OopClosureType&gt;
141 void InstanceRefKlass::oop_oop_iterate_ref_processing(oop obj, OopClosureType* closure) {
142   AlwaysContains always_contains;
143   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure, always_contains);
144 }
145 
146 class MrContains {
147   const MemRegion _mr;
148  public:
149   MrContains(MemRegion mr) : _mr(mr) {}
150   template &lt;typename T&gt; bool operator()(T* p) const { return _mr.contains(p); }
151 };
152 
153 template &lt;typename T, class OopClosureType&gt;
154 void InstanceRefKlass::oop_oop_iterate_ref_processing_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
155   const MrContains contains(mr);
156   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure, contains);
157 }
158 
159 template &lt;typename T, class OopClosureType&gt;
160 void InstanceRefKlass::oop_oop_iterate(oop obj, OopClosureType* closure) {
161   InstanceKlass::oop_oop_iterate&lt;T&gt;(obj, closure);
162 
163   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure);
164 }
165 
166 template &lt;typename T, class OopClosureType&gt;
167 void InstanceRefKlass::oop_oop_iterate_reverse(oop obj, OopClosureType* closure) {
168   InstanceKlass::oop_oop_iterate_reverse&lt;T&gt;(obj, closure);
169 
170   oop_oop_iterate_ref_processing&lt;T&gt;(obj, closure);
171 }
172 
173 template &lt;typename T, class OopClosureType&gt;
174 void InstanceRefKlass::oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
175   InstanceKlass::oop_oop_iterate_bounded&lt;T&gt;(obj, closure, mr);
176 
177   oop_oop_iterate_ref_processing_bounded&lt;T&gt;(obj, closure, mr);
178 }
179 
180 #ifdef ASSERT
181 template &lt;typename T&gt;
182 void InstanceRefKlass::trace_reference_gc(const char *s, oop obj) {
183   T* referent_addr   = (T*) java_lang_ref_Reference::referent_addr_raw(obj);
184   T* discovered_addr = (T*) java_lang_ref_Reference::discovered_addr_raw(obj);
185 
186   log_develop_trace(gc, ref)(&quot;InstanceRefKlass %s for obj &quot; PTR_FORMAT, s, p2i(obj));
187   if (java_lang_ref_Reference::is_phantom(obj)) {
188     log_develop_trace(gc, ref)(&quot;     referent_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
189                                p2i(referent_addr), p2i((oop)HeapAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(referent_addr)));
190   } else {
191     log_develop_trace(gc, ref)(&quot;     referent_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
192                                p2i(referent_addr), p2i((oop)HeapAccess&lt;ON_WEAK_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(referent_addr)));
193   }
194   log_develop_trace(gc, ref)(&quot;     discovered_addr/* &quot; PTR_FORMAT &quot; / &quot; PTR_FORMAT,
195       p2i(discovered_addr), p2i((oop)HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(discovered_addr)));
196 }
197 #endif
198 
199 #endif // SHARE_OOPS_INSTANCEREFKLASS_INLINE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
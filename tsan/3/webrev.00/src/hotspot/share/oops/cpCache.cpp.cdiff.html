<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,20 ***</span>
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  
  // Implementation of ConstantPoolCacheEntry
  
  void ConstantPoolCacheEntry::initialize_entry(int index) {
<span class="line-new-header">--- 33,19 ---</span>
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // Implementation of ConstantPoolCacheEntry
  
  void ConstantPoolCacheEntry::initialize_entry(int index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,31 ***</span>
    // Read once.
    volatile Bytecodes::Code c = bytecode_1();
    assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
  #endif
    // Need to flush pending stores here before bytecode is written.
<span class="line-modified">!   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));</span>
  }
  
  void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
  #ifdef ASSERT
    // Read once.
    volatile Bytecodes::Code c = bytecode_2();
    assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
  #endif
    // Need to flush pending stores here before bytecode is written.
<span class="line-modified">!   OrderAccess::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));</span>
  }
  
  // Sets f1, ordering with previous writes.
  void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
    assert(f1 != NULL, &quot;&quot;);
<span class="line-modified">!   OrderAccess::release_store(&amp;_f1, f1);</span>
  }
  
  void ConstantPoolCacheEntry::set_indy_resolution_failed() {
<span class="line-modified">!   OrderAccess::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));</span>
  }
  
  // Note that concurrent update of both bytecodes can leave one of them
  // reset to zero.  This is harmless; the interpreter will simply re-resolve
  // the damaged entry.  More seriously, the memory synchronization is needed
<span class="line-new-header">--- 94,31 ---</span>
    // Read once.
    volatile Bytecodes::Code c = bytecode_1();
    assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
  #endif
    // Need to flush pending stores here before bytecode is written.
<span class="line-modified">!   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_1_shift));</span>
  }
  
  void ConstantPoolCacheEntry::set_bytecode_2(Bytecodes::Code code) {
  #ifdef ASSERT
    // Read once.
    volatile Bytecodes::Code c = bytecode_2();
    assert(c == 0 || c == code || code == 0, &quot;update must be consistent&quot;);
  #endif
    // Need to flush pending stores here before bytecode is written.
<span class="line-modified">!   Atomic::release_store(&amp;_indices, _indices | ((u_char)code &lt;&lt; bytecode_2_shift));</span>
  }
  
  // Sets f1, ordering with previous writes.
  void ConstantPoolCacheEntry::release_set_f1(Metadata* f1) {
    assert(f1 != NULL, &quot;&quot;);
<span class="line-modified">!   Atomic::release_store(&amp;_f1, f1);</span>
  }
  
  void ConstantPoolCacheEntry::set_indy_resolution_failed() {
<span class="line-modified">!   Atomic::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));</span>
  }
  
  // Note that concurrent update of both bytecodes can leave one of them
  // reset to zero.  This is harmless; the interpreter will simply re-resolve
  // the damaged entry.  More seriously, the memory synchronization is needed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,21 ***</span>
    // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
    // bother trying to update it once it&#39;s nonzero but always make
    // sure that the final parameter size agrees with what was passed.
    if (_flags == 0) {
      intx newflags = (value &amp; parameter_size_mask);
<span class="line-modified">!     Atomic::cmpxchg(newflags, &amp;_flags, (intx)0);</span>
    }
    guarantee(parameter_size() == value,
              &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
  }
  
  void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
                                                         const methodHandle&amp; method,
                                                         int vtable_index,
<span class="line-modified">!                                                        bool sender_is_interface,</span>
<span class="line-removed">-                                                        InstanceKlass* pool_holder) {</span>
    bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
    assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
    assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
  
    int byte_no = -1;
<span class="line-new-header">--- 158,20 ---</span>
    // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
    // bother trying to update it once it&#39;s nonzero but always make
    // sure that the final parameter size agrees with what was passed.
    if (_flags == 0) {
      intx newflags = (value &amp; parameter_size_mask);
<span class="line-modified">!     Atomic::cmpxchg(&amp;_flags, (intx)0, newflags);</span>
    }
    guarantee(parameter_size() == value,
              &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
  }
  
  void ConstantPoolCacheEntry::set_direct_or_vtable_call(Bytecodes::Code invoke_code,
                                                         const methodHandle&amp; method,
                                                         int vtable_index,
<span class="line-modified">!                                                        bool sender_is_interface) {</span>
    bool is_vtable_call = (vtable_index &gt;= 0);  // FIXME: split this method on this boolean
    assert(method-&gt;interpreter_entry() != NULL, &quot;should have been set at this point&quot;);
    assert(!method-&gt;is_obsolete(),  &quot;attempt to write obsolete method to cpCache&quot;);
  
    int byte_no = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,22 ***</span>
      // is executed.
      if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
          method-&gt;name() != vmSymbols::object_initializer_name()) {
        do_resolve = false;
      }
<span class="line-removed">-     // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed</span>
<span class="line-removed">-     // initialization. An invokestatic must only proceed if the class is initialized, but if</span>
<span class="line-removed">-     // we resolve it before then that class initialization check is skipped. However if the call</span>
<span class="line-removed">-     // is from the same class we can resolve as we must be executing with &lt;clinit&gt; on our call stack.</span>
      if (invoke_code == Bytecodes::_invokestatic) {
<span class="line-modified">!       if (!method-&gt;method_holder()-&gt;is_initialized() &amp;&amp;</span>
<span class="line-modified">!           method-&gt;method_holder() != pool_holder) {</span>
          do_resolve = false;
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         assert(method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="line-removed">-                method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),</span>
<span class="line-removed">-                &quot;invalid class initialization state for invoke_static&quot;);</span>
        }
      }
      if (do_resolve) {
        set_bytecode_1(invoke_code);
      }
<span class="line-new-header">--- 260,25 ---</span>
      // is executed.
      if (invoke_code == Bytecodes::_invokespecial &amp;&amp; sender_is_interface &amp;&amp;
          method-&gt;name() != vmSymbols::object_initializer_name()) {
        do_resolve = false;
      }
      if (invoke_code == Bytecodes::_invokestatic) {
<span class="line-modified">!       assert(method-&gt;method_holder()-&gt;is_initialized() ||</span>
<span class="line-modified">!              method-&gt;method_holder()-&gt;is_reentrant_initialization(Thread::current()),</span>
<span class="line-added">+              &quot;invalid class initialization state for invoke_static&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="line-added">+         // Don&#39;t mark invokestatic to method as resolved if the holder class has not yet completed</span>
<span class="line-added">+         // initialization. An invokestatic must only proceed if the class is initialized, but if</span>
<span class="line-added">+         // we resolve it before then that class initialization check is skipped.</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),</span>
<span class="line-added">+         // template interpreter supports fast class initialization check for</span>
<span class="line-added">+         // invokestatic which doesn&#39;t require call site re-resolution to</span>
<span class="line-added">+         // enforce class initialization barrier.</span>
          do_resolve = false;
        }
      }
      if (do_resolve) {
        set_bytecode_1(invoke_code);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,21 ***</span>
    }
    NOT_PRODUCT(verify(tty));
  }
  
  void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
<span class="line-modified">!                                              bool sender_is_interface, InstanceKlass* pool_holder) {</span>
    int index = Method::nonvirtual_vtable_index;
    // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">!   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface, pool_holder);</span>
  }
  
  void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
    // either the method is a miranda or its holder should accept the given index
    assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
    // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">!   set_direct_or_vtable_call(invoke_code, method, index, false, NULL /* not used */);</span>
  }
  
  void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
                                               Klass* referenced_klass,
                                               const methodHandle&amp; method, int index) {
<span class="line-new-header">--- 320,21 ---</span>
    }
    NOT_PRODUCT(verify(tty));
  }
  
  void ConstantPoolCacheEntry::set_direct_call(Bytecodes::Code invoke_code, const methodHandle&amp; method,
<span class="line-modified">!                                              bool sender_is_interface) {</span>
    int index = Method::nonvirtual_vtable_index;
    // index &lt; 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">!   set_direct_or_vtable_call(invoke_code, method, index, sender_is_interface);</span>
  }
  
  void ConstantPoolCacheEntry::set_vtable_call(Bytecodes::Code invoke_code, const methodHandle&amp; method, int index) {
    // either the method is a miranda or its holder should accept the given index
    assert(method-&gt;method_holder()-&gt;is_interface() || method-&gt;method_holder()-&gt;verify_vtable_index(index), &quot;&quot;);
    // index &gt;= 0; FIXME: inline and customize set_direct_or_vtable_call
<span class="line-modified">!   set_direct_or_vtable_call(invoke_code, method, index, false);</span>
  }
  
  void ConstantPoolCacheEntry::set_itable_call(Bytecodes::Code invoke_code,
                                               Klass* referenced_klass,
                                               const methodHandle&amp; method, int index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,11 ***</span>
      Thread* THREAD = Thread::current();
      ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
      return;
    }
  
<span class="line-modified">!   const methodHandle adapter = call_info.resolved_method();</span>
    const Handle appendix      = call_info.resolved_appendix();
    const bool has_appendix    = appendix.not_null();
  
    // Write the flags.
    // MHs and indy are always sig-poly and have a local signature.
<span class="line-new-header">--- 400,11 ---</span>
      Thread* THREAD = Thread::current();
      ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
      return;
    }
  
<span class="line-modified">!   Method* adapter            = call_info.resolved_method();</span>
    const Handle appendix      = call_info.resolved_appendix();
    const bool has_appendix    = appendix.not_null();
  
    // Write the flags.
    // MHs and indy are always sig-poly and have a local signature.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 417,11 ***</span>
      ttyLocker ttyl;
      tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
                    invoke_code,
                    p2i(appendix()),
                    (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
<span class="line-modified">!                   p2i(adapter()));</span>
      adapter-&gt;print();
      if (has_appendix)  appendix()-&gt;print();
    }
  
    // Method handle invokes and invokedynamic sites use both cp cache words.
<span class="line-new-header">--- 418,11 ---</span>
      ttyLocker ttyl;
      tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,
                    invoke_code,
                    p2i(appendix()),
                    (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),
<span class="line-modified">!                   p2i(adapter));</span>
      adapter-&gt;print();
      if (has_appendix)  appendix()-&gt;print();
    }
  
    // Method handle invokes and invokedynamic sites use both cp cache words.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,11 ***</span>
      assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
      assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
      resolved_references-&gt;obj_at_put(appendix_index, appendix());
    }
  
<span class="line-modified">!   release_set_f1(adapter());  // This must be the last one to set (see NOTE above)!</span>
  
    // The interpreter assembly code does not check byte_2,
    // but it is used by is_resolved, method_if_resolved, etc.
    set_bytecode_1(invoke_code);
    NOT_PRODUCT(verify(tty));
<span class="line-new-header">--- 450,11 ---</span>
      assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
      assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
      resolved_references-&gt;obj_at_put(appendix_index, appendix());
    }
  
<span class="line-modified">!   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!</span>
  
    // The interpreter assembly code does not check byte_2,
    // but it is used by is_resolved, method_if_resolved, etc.
    set_bytecode_1(invoke_code);
    NOT_PRODUCT(verify(tty));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,11 ***</span>
      Metadata* f1 = f1_ord();
      if (f1 != NULL) {
        switch (invoke_code) {
        case Bytecodes::_invokeinterface:
          assert(f1-&gt;is_klass(), &quot;&quot;);
<span class="line-modified">!         return klassItable::method_for_itable_index((InstanceKlass*)f1, f2_as_index());</span>
        case Bytecodes::_invokestatic:
        case Bytecodes::_invokespecial:
          assert(!has_appendix(), &quot;&quot;);
        case Bytecodes::_invokehandle:
        case Bytecodes::_invokedynamic:
<span class="line-new-header">--- 507,11 ---</span>
      Metadata* f1 = f1_ord();
      if (f1 != NULL) {
        switch (invoke_code) {
        case Bytecodes::_invokeinterface:
          assert(f1-&gt;is_klass(), &quot;&quot;);
<span class="line-modified">!         return f2_as_interface_method();</span>
        case Bytecodes::_invokestatic:
        case Bytecodes::_invokespecial:
          assert(!has_appendix(), &quot;&quot;);
        case Bytecodes::_invokehandle:
        case Bytecodes::_invokedynamic:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,11 ***</span>
  void ConstantPoolCache::remove_unshareable_info() {
    walk_entries_for_initialization(/*check_only = */ false);
  }
  
  void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;sanity&quot;);</span>
    // When dumping the archive, we want to clean up the ConstantPoolCache
    // to remove any effect of linking due to the execution of Java code --
    // each ConstantPoolCacheEntry will have the same contents as if
    // ConstantPoolCache::initialize has just returned:
    //
<span class="line-new-header">--- 707,11 ---</span>
  void ConstantPoolCache::remove_unshareable_info() {
    walk_entries_for_initialization(/*check_only = */ false);
  }
  
  void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
    // When dumping the archive, we want to clean up the ConstantPoolCache
    // to remove any effect of linking due to the execution of Java code --
    // each ConstantPoolCacheEntry will have the same contents as if
    // ConstantPoolCache::initialize has just returned:
    //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,14 ***</span>
  
    InstanceKlass* ik = constant_pool()-&gt;pool_holder();
    bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
    memset(f2_used, 0, sizeof(bool) * length());
  
    // Find all the slots that we need to preserve f2
    for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
      Method* m = ik-&gt;methods()-&gt;at(i);
<span class="line-modified">!     RawBytecodeStream bcs(m);</span>
      while (!bcs.is_last_bytecode()) {
        Bytecodes::Code opcode = bcs.raw_next();
        switch (opcode) {
        case Bytecodes::_invokedynamic: {
            int index = Bytes::get_native_u4(bcs.bcp() + 1);
<span class="line-new-header">--- 722,16 ---</span>
  
    InstanceKlass* ik = constant_pool()-&gt;pool_holder();
    bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());
    memset(f2_used, 0, sizeof(bool) * length());
  
<span class="line-added">+   Thread* THREAD = Thread::current();</span>
<span class="line-added">+ </span>
    // Find all the slots that we need to preserve f2
    for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
      Method* m = ik-&gt;methods()-&gt;at(i);
<span class="line-modified">!     RawBytecodeStream bcs(methodHandle(THREAD, m));</span>
      while (!bcs.is_last_bytecode()) {
        Bytecodes::Code opcode = bcs.raw_next();
        switch (opcode) {
        case Bytecodes::_invokedynamic: {
            int index = Bytes::get_native_u4(bcs.bcp() + 1);
</pre>
<center><a href="constantPool.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/compressedOops.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayOop.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constMethod.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/compressedOops.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
<span class="line-new-header">--- 25,13 ---</span>
  #ifndef SHARE_OOPS_COMPRESSEDOOPS_INLINE_HPP
  #define SHARE_OOPS_COMPRESSEDOOPS_INLINE_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/oop.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  
  // Functions for encoding and decoding compressed oops.
  // If the oops are compressed, the type passed to these overloaded functions
  // is narrowOop.  All functions are overloaded so they can be called by
  // template functions without conditionals (the compiler instantiates via
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,48 ***</span>
  
  // Algorithm for encoding and decoding oops from 64 bit pointers to 32 bit
  // offset from the heap base.  Saving the check for null can save instructions
  // in inner GC loops so these are separated.
  
<span class="line-modified">! namespace CompressedOops {</span>
<span class="line-modified">!   inline bool is_null(oop obj)       { return obj == NULL; }</span>
<span class="line-modified">!   inline bool is_null(narrowOop obj) { return obj == 0; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline oop decode_not_null(narrowOop v) {</span>
<span class="line-removed">-     assert(!is_null(v), &quot;narrow oop value can never be zero&quot;);</span>
<span class="line-removed">-     address base = Universe::narrow_oop_base();</span>
<span class="line-removed">-     int    shift = Universe::narrow_oop_shift();</span>
<span class="line-removed">-     oop result = (oop)(void*)((uintptr_t)base + ((uintptr_t)v &lt;&lt; shift));</span>
<span class="line-removed">-     assert(check_obj_alignment(result), &quot;address not aligned: &quot; INTPTR_FORMAT, p2i((void*) result));</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline oop decode(narrowOop v) {</span>
<span class="line-modified">!     return is_null(v) ? (oop)NULL : decode_not_null(v);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   inline narrowOop encode_not_null(oop v) {</span>
<span class="line-modified">!     assert(!is_null(v), &quot;oop value can never be zero&quot;);</span>
<span class="line-modified">!     assert(check_obj_alignment(v), &quot;Address not aligned&quot;);</span>
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in_reserved(v), &quot;Address not in heap&quot;);</span>
<span class="line-modified">!     address base = Universe::narrow_oop_base();</span>
<span class="line-modified">!     int    shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">!     uint64_t  pd = (uint64_t)(pointer_delta((void*)v, (void*)base, 1));</span>
<span class="line-modified">!     assert(OopEncodingHeapMax &gt; pd, &quot;change encoding max if new encoding&quot;);</span>
<span class="line-modified">!     uint64_t result = pd &gt;&gt; shift;</span>
<span class="line-modified">!     assert((result &amp; CONST64(0xffffffff00000000)) == 0, &quot;narrow oop overflow&quot;);</span>
<span class="line-modified">!     assert(oopDesc::equals_raw(decode(result), v), &quot;reversibility&quot;);</span>
<span class="line-modified">!     return (narrowOop)result;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   inline narrowOop encode(oop v) {</span>
<span class="line-modified">!     return is_null(v) ? (narrowOop)0 : encode_not_null(v);</span>
    }
  
<span class="line-modified">!   // No conversions needed for these overloads</span>
<span class="line-modified">!   inline oop decode_not_null(oop v)             { return v; }</span>
<span class="line-modified">!   inline oop decode(oop v)                      { return v; }</span>
<span class="line-modified">!   inline narrowOop encode_not_null(narrowOop v) { return v; }</span>
<span class="line-modified">!   inline narrowOop encode(narrowOop v)          { return v; }</span>
  }
  
  #endif // SHARE_OOPS_COMPRESSEDOOPS_INLINE_HPP
<span class="line-new-header">--- 39,71 ---</span>
  
  // Algorithm for encoding and decoding oops from 64 bit pointers to 32 bit
  // offset from the heap base.  Saving the check for null can save instructions
  // in inner GC loops so these are separated.
  
<span class="line-modified">! inline oop CompressedOops::decode_raw(narrowOop v) {</span>
<span class="line-modified">!   return (oop)(void*)((uintptr_t)base() + ((uintptr_t)v &lt;&lt; shift()));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! inline oop CompressedOops::decode_not_null(narrowOop v) {</span>
<span class="line-modified">!   assert(!is_null(v), &quot;narrow oop value can never be zero&quot;);</span>
<span class="line-modified">!   oop result = decode_raw(v);</span>
<span class="line-added">+   assert(is_object_aligned(result), &quot;address not aligned: &quot; INTPTR_FORMAT, p2i((void*) result));</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! inline oop CompressedOops::decode(narrowOop v) {</span>
<span class="line-modified">!   return is_null(v) ? (oop)NULL : decode_not_null(v);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! inline narrowOop CompressedOops::encode_not_null(oop v) {</span>
<span class="line-modified">!   assert(!is_null(v), &quot;oop value can never be zero&quot;);</span>
<span class="line-modified">!   assert(is_object_aligned(v), &quot;address not aligned: &quot; PTR_FORMAT, p2i((void*)v));</span>
<span class="line-modified">!   assert(is_in(v), &quot;address not in heap range: &quot; PTR_FORMAT, p2i((void*)v));</span>
<span class="line-modified">!   uint64_t  pd = (uint64_t)(pointer_delta((void*)v, (void*)base(), 1));</span>
<span class="line-modified">!   assert(OopEncodingHeapMax &gt; pd, &quot;change encoding max if new encoding&quot;);</span>
<span class="line-modified">!   uint64_t result = pd &gt;&gt; shift();</span>
<span class="line-modified">!   assert((result &amp; CONST64(0xffffffff00000000)) == 0, &quot;narrow oop overflow&quot;);</span>
<span class="line-modified">!   assert(decode(result) == v, &quot;reversibility&quot;);</span>
<span class="line-added">+   return (narrowOop)result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline narrowOop CompressedOops::encode(oop v) {</span>
<span class="line-added">+   return is_null(v) ? (narrowOop)0 : encode_not_null(v);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline bool check_alignment(Klass* v) {</span>
<span class="line-added">+   return (intptr_t)v % KlassAlignmentInBytes == 0;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {</span>
<span class="line-modified">!     return (Klass*)(void*)((uintptr_t)base() +((uintptr_t)v &lt;&lt; shift()));</span>
    }
  
<span class="line-modified">! inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {</span>
<span class="line-modified">!   assert(!is_null(v), &quot;narrow klass value can never be zero&quot;);</span>
<span class="line-modified">!   Klass* result = decode_raw(v);</span>
<span class="line-modified">!   assert(check_alignment(result), &quot;address not aligned: &quot; INTPTR_FORMAT, p2i((void*) result));</span>
<span class="line-modified">!   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline Klass* CompressedKlassPointers::decode(narrowKlass v) {</span>
<span class="line-added">+   return is_null(v) ? (Klass*)NULL : decode_not_null(v);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {</span>
<span class="line-added">+   assert(!is_null(v), &quot;klass value can never be zero&quot;);</span>
<span class="line-added">+   assert(check_alignment(v), &quot;Address not aligned&quot;);</span>
<span class="line-added">+   uint64_t pd = (uint64_t)(pointer_delta((void*)v, base(), 1));</span>
<span class="line-added">+   assert(KlassEncodingMetaspaceMax &gt; pd, &quot;change encoding max if new encoding&quot;);</span>
<span class="line-added">+   uint64_t result = pd &gt;&gt; shift();</span>
<span class="line-added">+   assert((result &amp; CONST64(0xffffffff00000000)) == 0, &quot;narrow klass pointer overflow&quot;);</span>
<span class="line-added">+   assert(decode(result) == v, &quot;reversibility&quot;);</span>
<span class="line-added">+   return (narrowKlass)result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline narrowKlass CompressedKlassPointers::encode(Klass* v) {</span>
<span class="line-added">+   return is_null(v) ? (narrowKlass)0 : encode_not_null(v);</span>
  }
  
  #endif // SHARE_OOPS_COMPRESSEDOOPS_INLINE_HPP
</pre>
<center><a href="arrayOop.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constMethod.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
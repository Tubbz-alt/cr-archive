<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/klassVtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;interpreter/linkResolver.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;logging/logStream.hpp&quot;
  34 #include &quot;memory/metaspaceShared.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/instanceKlass.hpp&quot;
  38 #include &quot;oops/klassVtable.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/objArrayOop.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;runtime/arguments.hpp&quot;
  43 #include &quot;runtime/flags/flagSetting.hpp&quot;
  44 #include &quot;runtime/handles.inline.hpp&quot;
  45 #include &quot;runtime/safepointVerifiers.hpp&quot;
  46 #include &quot;utilities/copy.hpp&quot;
  47 
  48 inline InstanceKlass* klassVtable::ik() const {
  49   return InstanceKlass::cast(_klass);
  50 }
  51 
  52 bool klassVtable::is_preinitialized_vtable() {
  53   return _klass-&gt;is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite();
  54 }
  55 
  56 
  57 // this function computes the vtable size (including the size needed for miranda
  58 // methods) and the number of miranda methods in this class.
  59 // Note on Miranda methods: Let&#39;s say there is a class C that implements
  60 // interface I, and none of C&#39;s superclasses implements I.
  61 // Let&#39;s say there is an abstract method m in I that neither C
  62 // nor any of its super classes implement (i.e there is no method of any access,
  63 // with the same name and signature as m), then m is a Miranda method which is
  64 // entered as a public abstract method in C&#39;s vtable.  From then on it should
  65 // treated as any other public method in C for method over-ride purposes.
  66 void klassVtable::compute_vtable_size_and_num_mirandas(
  67     int* vtable_length_ret, int* num_new_mirandas,
  68     GrowableArray&lt;Method*&gt;* all_mirandas, const Klass* super,
  69     Array&lt;Method*&gt;* methods, AccessFlags class_flags, u2 major_version,
  70     Handle classloader, Symbol* classname, Array&lt;InstanceKlass*&gt;* local_interfaces,
  71     TRAPS) {
  72   NoSafepointVerifier nsv;
  73 
  74   // set up default result values
  75   int vtable_length = 0;
  76 
  77   // start off with super&#39;s vtable length
  78   vtable_length = super == NULL ? 0 : super-&gt;vtable_length();
  79 
  80   // go thru each method in the methods table to see if it needs a new entry
  81   int len = methods-&gt;length();
  82   for (int i = 0; i &lt; len; i++) {
  83     assert(methods-&gt;at(i)-&gt;is_method(), &quot;must be a Method*&quot;);
  84     methodHandle mh(THREAD, methods-&gt;at(i));
  85 
  86     if (needs_new_vtable_entry(mh, super, classloader, classname, class_flags, major_version, THREAD)) {
  87       assert(!methods-&gt;at(i)-&gt;is_private(), &quot;private methods should not need a vtable entry&quot;);
  88       vtable_length += vtableEntry::size(); // we need a new entry
  89     }
  90   }
  91 
  92   GrowableArray&lt;Method*&gt; new_mirandas(20);
  93   // compute the number of mirandas methods that must be added to the end
  94   get_mirandas(&amp;new_mirandas, all_mirandas, super, methods, NULL, local_interfaces,
  95                class_flags.is_interface());
  96   *num_new_mirandas = new_mirandas.length();
  97 
  98   // Interfaces do not need interface methods in their vtables
  99   // This includes miranda methods and during later processing, default methods
 100   if (!class_flags.is_interface()) {
 101      vtable_length += *num_new_mirandas * vtableEntry::size();
 102   }
 103 
 104   if (Universe::is_bootstrapping() &amp;&amp; vtable_length == 0) {
 105     // array classes don&#39;t have their superclass set correctly during
 106     // bootstrapping
 107     vtable_length = Universe::base_vtable_size();
 108   }
 109 
 110   if (super == NULL &amp;&amp; vtable_length != Universe::base_vtable_size()) {
 111     if (Universe::is_bootstrapping()) {
 112       // Someone is attempting to override java.lang.Object incorrectly on the
 113       // bootclasspath.  The JVM cannot recover from this error including throwing
 114       // an exception
 115       vm_exit_during_initialization(&quot;Incompatible definition of java.lang.Object&quot;);
 116     } else {
 117       // Someone is attempting to redefine java.lang.Object incorrectly.  The
 118       // only way this should happen is from
 119       // SystemDictionary::resolve_from_stream(), which will detect this later
 120       // and throw a security exception.  So don&#39;t assert here to let
 121       // the exception occur.
 122       vtable_length = Universe::base_vtable_size();
 123     }
 124   }
 125   assert(vtable_length % vtableEntry::size() == 0, &quot;bad vtable length&quot;);
 126   assert(vtable_length &gt;= Universe::base_vtable_size(), &quot;vtable too small&quot;);
 127 
 128   *vtable_length_ret = vtable_length;
 129 }
 130 
 131 int klassVtable::index_of(Method* m, int len) const {
 132   assert(m-&gt;has_vtable_index(), &quot;do not ask this of non-vtable methods&quot;);
 133   return m-&gt;vtable_index();
 134 }
 135 
 136 // Copy super class&#39;s vtable to the first part (prefix) of this class&#39;s vtable,
 137 // and return the number of entries copied.  Expects that &#39;super&#39; is the Java
 138 // super class (arrays can have &quot;array&quot; super classes that must be skipped).
 139 int klassVtable::initialize_from_super(Klass* super) {
 140   if (super == NULL) {
 141     return 0;
 142   } else if (is_preinitialized_vtable()) {
 143     // A shared class&#39; vtable is preinitialized at dump time. No need to copy
 144     // methods from super class for shared class, as that was already done
 145     // during archiving time. However, if Jvmti has redefined a class,
 146     // copy super class&#39;s vtable in case the super class has changed.
 147     return super-&gt;vtable().length();
 148   } else {
 149     // copy methods from superKlass
 150     klassVtable superVtable = super-&gt;vtable();
 151     assert(superVtable.length() &lt;= _length, &quot;vtable too short&quot;);
 152 #ifdef ASSERT
 153     superVtable.verify(tty, true);
 154 #endif
 155     superVtable.copy_vtable_to(table());
 156     if (log_develop_is_enabled(Trace, vtables)) {
 157       ResourceMark rm;
 158       log_develop_trace(vtables)(&quot;copy vtable from %s to %s size %d&quot;,
 159                                  super-&gt;internal_name(), klass()-&gt;internal_name(),
 160                                  _length);
 161     }
 162     return superVtable.length();
 163   }
 164 }
 165 
 166 //
 167 // Revised lookup semantics   introduced 1.3 (Kestrel beta)
 168 void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {
 169 
 170   // Note:  Arrays can have intermediate array supers.  Use java_super to skip them.
 171   InstanceKlass* super = _klass-&gt;java_super();
 172   int nofNewEntries = 0;
 173 
 174   bool is_shared = _klass-&gt;is_shared();
 175 
 176   if (!_klass-&gt;is_array_klass()) {
 177     ResourceMark rm(THREAD);
 178     log_develop_debug(vtables)(&quot;Initializing: %s&quot;, _klass-&gt;name()-&gt;as_C_string());
 179   }
 180 
 181 #ifdef ASSERT
 182   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
 183   oop* end_of_vtable = (oop*)&amp;table()[_length];
 184   assert(end_of_vtable &lt;= end_of_obj, &quot;vtable extends beyond end&quot;);
 185 #endif
 186 
 187   if (Universe::is_bootstrapping()) {
 188     assert(!is_shared, &quot;sanity&quot;);
 189     // just clear everything
 190     for (int i = 0; i &lt; _length; i++) table()[i].clear();
 191     return;
 192   }
 193 
 194   int super_vtable_len = initialize_from_super(super);
 195   if (_klass-&gt;is_array_klass()) {
 196     assert(super_vtable_len == _length, &quot;arrays shouldn&#39;t introduce new methods&quot;);
 197   } else {
 198     assert(_klass-&gt;is_instance_klass(), &quot;must be InstanceKlass&quot;);
 199 
 200     Array&lt;Method*&gt;* methods = ik()-&gt;methods();
 201     int len = methods-&gt;length();
 202     int initialized = super_vtable_len;
 203 
 204     // Check each of this class&#39;s methods against super;
 205     // if override, replace in copy of super vtable, otherwise append to end
 206     for (int i = 0; i &lt; len; i++) {
 207       // update_inherited_vtable can stop for gc - ensure using handles
 208       HandleMark hm(THREAD);
 209       assert(methods-&gt;at(i)-&gt;is_method(), &quot;must be a Method*&quot;);
 210       methodHandle mh(THREAD, methods-&gt;at(i));
 211 
 212       bool needs_new_entry = update_inherited_vtable(ik(), mh, super_vtable_len, -1, checkconstraints, CHECK);
 213 
 214       if (needs_new_entry) {
 215         put_method_at(mh(), initialized);
 216         mh()-&gt;set_vtable_index(initialized); // set primary vtable index
 217         initialized++;
 218       }
 219     }
 220 
 221     // update vtable with default_methods
 222     Array&lt;Method*&gt;* default_methods = ik()-&gt;default_methods();
 223     if (default_methods != NULL) {
 224       len = default_methods-&gt;length();
 225       if (len &gt; 0) {
 226         Array&lt;int&gt;* def_vtable_indices = NULL;
 227         if ((def_vtable_indices = ik()-&gt;default_vtable_indices()) == NULL) {
 228           assert(!is_shared, &quot;shared class def_vtable_indices does not exist&quot;);
 229           def_vtable_indices = ik()-&gt;create_new_default_vtable_indices(len, CHECK);
 230         } else {
 231           assert(def_vtable_indices-&gt;length() == len, &quot;reinit vtable len?&quot;);
 232         }
 233         for (int i = 0; i &lt; len; i++) {
 234           HandleMark hm(THREAD);
 235           assert(default_methods-&gt;at(i)-&gt;is_method(), &quot;must be a Method*&quot;);
 236           methodHandle mh(THREAD, default_methods-&gt;at(i));
 237           assert(!mh-&gt;is_private(), &quot;private interface method in the default method list&quot;);
 238           bool needs_new_entry = update_inherited_vtable(ik(), mh, super_vtable_len, i, checkconstraints, CHECK);
 239 
 240           // needs new entry
 241           if (needs_new_entry) {
 242             put_method_at(mh(), initialized);
 243             if (is_preinitialized_vtable()) {
 244               // At runtime initialize_vtable is rerun for a shared class
 245               // (loaded by the non-boot loader) as part of link_class_impl().
 246               // The dumptime vtable index should be the same as the runtime index.
 247               assert(def_vtable_indices-&gt;at(i) == initialized,
 248                      &quot;dump time vtable index is different from runtime index&quot;);
 249             } else {
 250               def_vtable_indices-&gt;at_put(i, initialized); //set vtable index
 251             }
 252             initialized++;
 253           }
 254         }
 255       }
 256     }
 257 
 258     // add miranda methods; it will also return the updated initialized
 259     // Interfaces do not need interface methods in their vtables
 260     // This includes miranda methods and during later processing, default methods
 261     if (!ik()-&gt;is_interface()) {
 262       initialized = fill_in_mirandas(initialized, THREAD);
 263     }
 264 
 265     // In class hierarchies where the accessibility is not increasing (i.e., going from private -&gt;
 266     // package_private -&gt; public/protected), the vtable might actually be smaller than our initial
 267     // calculation, for classfile versions for which we do not do transitive override
 268     // calculations.
 269     if (ik()-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION) {
 270       assert(initialized == _length, &quot;vtable initialization failed&quot;);
 271     } else {
 272       assert(initialized &lt;= _length, &quot;vtable initialization failed&quot;);
 273       for(;initialized &lt; _length; initialized++) {
 274         table()[initialized].clear();
 275       }
 276     }
 277     NOT_PRODUCT(verify(tty, true));
 278   }
 279 }
 280 
 281 // Called for cases where a method does not override its superclass&#39; vtable entry
 282 // For bytecodes not produced by javac together it is possible that a method does not override
 283 // the superclass&#39;s method, but might indirectly override a super-super class&#39;s vtable entry
 284 // If none found, return a null superk, else return the superk of the method this does override
 285 // For public and protected methods: if they override a superclass, they will
 286 // also be overridden themselves appropriately.
 287 // Private methods do not override, and are not overridden and are not in the vtable.
 288 // Package Private methods are trickier:
 289 // e.g. P1.A, pub m
 290 // P2.B extends A, package private m
 291 // P1.C extends B, public m
 292 // P1.C.m needs to override P1.A.m and can not override P2.B.m
 293 // Therefore: all package private methods need their own vtable entries for
 294 // them to be the root of an inheritance overriding decision
 295 // Package private methods may also override other vtable entries
 296 InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method,
 297                             int vtable_index, Handle target_loader, Symbol* target_classname, Thread * THREAD) {
 298   InstanceKlass* superk = initialsuper;
 299   while (superk != NULL &amp;&amp; superk-&gt;super() != NULL) {
 300     InstanceKlass* supersuperklass = InstanceKlass::cast(superk-&gt;super());
 301     klassVtable ssVtable = supersuperklass-&gt;vtable();
 302     if (vtable_index &lt; ssVtable.length()) {
 303       Method* super_method = ssVtable.method_at(vtable_index);
 304 #ifndef PRODUCT
 305       Symbol* name= target_method()-&gt;name();
 306       Symbol* signature = target_method()-&gt;signature();
 307       assert(super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature, &quot;vtable entry name/sig mismatch&quot;);
 308 #endif
 309       if (supersuperklass-&gt;is_override(super_method, target_loader, target_classname, THREAD)) {
 310         if (log_develop_is_enabled(Trace, vtables)) {
 311           ResourceMark rm(THREAD);
 312           LogTarget(Trace, vtables) lt;
 313           LogStream ls(lt);
 314           char* sig = target_method()-&gt;name_and_sig_as_C_string();
 315           ls.print(&quot;transitive overriding superclass %s with %s index %d, original flags: &quot;,
 316                        supersuperklass-&gt;internal_name(),
 317                        sig, vtable_index);
 318           super_method-&gt;print_linkage_flags(&amp;ls);
 319           ls.print(&quot;overriders flags: &quot;);
 320           target_method-&gt;print_linkage_flags(&amp;ls);
 321           ls.cr();
 322         }
 323 
 324         break; // return found superk
 325       }
 326     } else  {
 327       // super class has no vtable entry here, stop transitive search
 328       superk = (InstanceKlass*)NULL;
 329       break;
 330     }
 331     // if no override found yet, continue to search up
 332     superk = superk-&gt;super() == NULL ? NULL : InstanceKlass::cast(superk-&gt;super());
 333   }
 334 
 335   return superk;
 336 }
 337 
 338 static void log_vtables(int i, bool overrides, const methodHandle&amp; target_method,
 339                         Klass* target_klass, Method* super_method,
 340                         Thread* thread) {
 341 #ifndef PRODUCT
 342   if (log_develop_is_enabled(Trace, vtables)) {
 343     ResourceMark rm(thread);
 344     LogTarget(Trace, vtables) lt;
 345     LogStream ls(lt);
 346     char* sig = target_method()-&gt;name_and_sig_as_C_string();
 347     if (overrides) {
 348       ls.print(&quot;overriding with %s index %d, original flags: &quot;,
 349                    sig, i);
 350     } else {
 351       ls.print(&quot;NOT overriding with %s index %d, original flags: &quot;,
 352                    sig, i);
 353     }
 354     super_method-&gt;print_linkage_flags(&amp;ls);
 355     ls.print(&quot;overriders flags: &quot;);
 356     target_method-&gt;print_linkage_flags(&amp;ls);
 357     ls.cr();
 358   }
 359 #endif
 360 }
 361 
 362 // Update child&#39;s copy of super vtable for overrides
 363 // OR return true if a new vtable entry is required.
 364 // Only called for InstanceKlass&#39;s, i.e. not for arrays
 365 // If that changed, could not use _klass as handle for klass
 366 bool klassVtable::update_inherited_vtable(InstanceKlass* klass, const methodHandle&amp; target_method,
 367                                           int super_vtable_len, int default_index,
 368                                           bool checkconstraints, TRAPS) {
 369   ResourceMark rm(THREAD);
 370   bool allocate_new = true;
 371   assert(klass-&gt;is_instance_klass(), &quot;must be InstanceKlass&quot;);
 372 
 373   Array&lt;int&gt;* def_vtable_indices = NULL;
 374   bool is_default = false;
 375 
 376   // default methods are non-private concrete methods in superinterfaces which are added
 377   // to the vtable with their real method_holder.
 378   // Since vtable and itable indices share the same storage, don&#39;t touch
 379   // the default method&#39;s real vtable/itable index.
 380   // default_vtable_indices stores the vtable value relative to this inheritor
 381   if (default_index &gt;= 0 ) {
 382     is_default = true;
 383     def_vtable_indices = klass-&gt;default_vtable_indices();
 384     assert(!target_method()-&gt;is_private(), &quot;private interface method flagged as default&quot;);
 385     assert(def_vtable_indices != NULL, &quot;def vtable alloc?&quot;);
 386     assert(default_index &lt;= def_vtable_indices-&gt;length(), &quot;def vtable len?&quot;);
 387   } else {
 388     assert(klass == target_method()-&gt;method_holder(), &quot;caller resp.&quot;);
 389     // Initialize the method&#39;s vtable index to &quot;nonvirtual&quot;.
 390     // If we allocate a vtable entry, we will update it to a non-negative number.
 391     target_method()-&gt;set_vtable_index(Method::nonvirtual_vtable_index);
 392   }
 393 
 394   // Private, static and &lt;init&gt; methods are never in
 395   if (target_method()-&gt;is_private() || target_method()-&gt;is_static() ||
 396       (target_method()-&gt;name()-&gt;fast_compare(vmSymbols::object_initializer_name()) == 0)) {
 397     return false;
 398   }
 399 
 400   if (target_method-&gt;is_final_method(klass-&gt;access_flags())) {
 401     // a final method never needs a new entry; final methods can be statically
 402     // resolved and they have to be present in the vtable only if they override
 403     // a super&#39;s method, in which case they re-use its entry
 404     allocate_new = false;
 405   } else if (klass-&gt;is_interface()) {
 406     allocate_new = false;  // see note below in needs_new_vtable_entry
 407     // An interface never allocates new vtable slots, only inherits old ones.
 408     // This method will either be assigned its own itable index later,
 409     // or be assigned an inherited vtable index in the loop below.
 410     // default methods inherited by classes store their vtable indices
 411     // in the inheritor&#39;s default_vtable_indices.
 412     // default methods inherited by interfaces may already have a
 413     // valid itable index, if so, don&#39;t change it.
 414     // Overpass methods in an interface will be assigned an itable index later
 415     // by an inheriting class.
 416     if ((!is_default || !target_method()-&gt;has_itable_index())) {
 417       target_method()-&gt;set_vtable_index(Method::pending_itable_index);
 418     }
 419   }
 420 
 421   // we need a new entry if there is no superclass
 422   Klass* super = klass-&gt;super();
 423   if (super == NULL) {
 424     return allocate_new;
 425   }
 426 
 427   // search through the vtable and update overridden entries
 428   // Since check_signature_loaders acquires SystemDictionary_lock
 429   // which can block for gc, once we are in this loop, use handles
 430   // For classfiles built with &gt;= jdk7, we now look for transitive overrides
 431 
 432   Symbol* name = target_method()-&gt;name();
 433   Symbol* signature = target_method()-&gt;signature();
 434 
 435   Klass* target_klass = target_method()-&gt;method_holder();
 436   if (target_klass == NULL) {
 437     target_klass = _klass;
 438   }
 439 
 440   Handle target_loader(THREAD, target_klass-&gt;class_loader());
 441 
 442   Symbol* target_classname = target_klass-&gt;name();
 443   for(int i = 0; i &lt; super_vtable_len; i++) {
 444     Method* super_method;
 445     if (is_preinitialized_vtable()) {
 446       // If this is a shared class, the vtable is already in the final state (fully
 447       // initialized). Need to look at the super&#39;s vtable.
 448       klassVtable superVtable = super-&gt;vtable();
 449       super_method = superVtable.method_at(i);
 450     } else {
 451       super_method = method_at(i);
 452     }
 453     // Check if method name matches.  Ignore match if klass is an interface and the
 454     // matching method is a non-public java.lang.Object method.  (See JVMS 5.4.3.4)
 455     // This is safe because the method at this slot should never get invoked.
 456     // (TBD: put in a method to throw NoSuchMethodError if this slot is ever used.)
 457     if (super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature &amp;&amp;
 458         (!_klass-&gt;is_interface() ||
 459          !SystemDictionary::is_nonpublic_Object_method(super_method))) {
 460 
 461       // get super_klass for method_holder for the found method
 462       InstanceKlass* super_klass =  super_method-&gt;method_holder();
 463 
 464       // Whether the method is being overridden
 465       bool overrides = false;
 466 
 467       // private methods are also never overridden
 468       if (!super_method-&gt;is_private() &amp;&amp;
 469           (is_default
 470           || ((super_klass-&gt;is_override(super_method, target_loader, target_classname, THREAD))
 471           || ((klass-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION)
 472           &amp;&amp; ((super_klass = find_transitive_override(super_klass,
 473                              target_method, i, target_loader,
 474                              target_classname, THREAD))
 475                              != (InstanceKlass*)NULL)))))
 476         {
 477         // Package private methods always need a new entry to root their own
 478         // overriding. They may also override other methods.
 479         if (!target_method()-&gt;is_package_private()) {
 480           allocate_new = false;
 481         }
 482 
 483         // Do not check loader constraints for overpass methods because overpass
 484         // methods are created by the jvm to throw exceptions.
 485         if (checkconstraints &amp;&amp; !target_method()-&gt;is_overpass()) {
 486           // Override vtable entry if passes loader constraint check
 487           // if loader constraint checking requested
 488           // No need to visit his super, since he and his super
 489           // have already made any needed loader constraints.
 490           // Since loader constraints are transitive, it is enough
 491           // to link to the first super, and we get all the others.
 492           Handle super_loader(THREAD, super_klass-&gt;class_loader());
 493 
 494           if (!oopDesc::equals(target_loader(), super_loader())) {
 495             ResourceMark rm(THREAD);
 496             Symbol* failed_type_symbol =
 497               SystemDictionary::check_signature_loaders(signature, target_loader,
 498                                                         super_loader, true,
 499                                                         CHECK_(false));
 500             if (failed_type_symbol != NULL) {
 501               stringStream ss;
 502               ss.print(&quot;loader constraint violation for class %s: when selecting &quot;
 503                        &quot;overriding method %s the class loader %s of the &quot;
 504                        &quot;selected method&#39;s type %s, and the class loader %s for its super &quot;
 505                        &quot;type %s have different Class objects for the type %s used in the signature (%s; %s)&quot;,
 506                        klass-&gt;external_name(),
 507                        target_method()-&gt;name_and_sig_as_C_string(),
 508                        target_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 509                        target_klass-&gt;external_name(),
 510                        super_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 511                        super_klass-&gt;external_name(),
 512                        failed_type_symbol-&gt;as_klass_external_name(),
 513                        target_klass-&gt;class_in_module_of_loader(false, true),
 514                        super_klass-&gt;class_in_module_of_loader(false, true));
 515               THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);
 516             }
 517           }
 518         }
 519 
 520         put_method_at(target_method(), i);
 521         overrides = true;
 522         if (!is_default) {
 523           target_method()-&gt;set_vtable_index(i);
 524         } else {
 525           if (def_vtable_indices != NULL) {
 526             if (is_preinitialized_vtable()) {
 527               // At runtime initialize_vtable is rerun as part of link_class_impl()
 528               // for a shared class loaded by the non-boot loader.
 529               // The dumptime vtable index should be the same as the runtime index.
 530               assert(def_vtable_indices-&gt;at(default_index) == i,
 531                      &quot;dump time vtable index is different from runtime index&quot;);
 532             } else {
 533               def_vtable_indices-&gt;at_put(default_index, i);
 534             }
 535           }
 536           assert(super_method-&gt;is_default_method() || super_method-&gt;is_overpass()
 537                  || super_method-&gt;is_abstract(), &quot;default override error&quot;);
 538         }
 539       } else {
 540         overrides = false;
 541       }
 542       log_vtables(i, overrides, target_method, target_klass, super_method, THREAD);
 543     }
 544   }
 545   return allocate_new;
 546 }
 547 
 548 void klassVtable::put_method_at(Method* m, int index) {
 549   assert(!m-&gt;is_private(), &quot;private methods should not be in vtable&quot;);
 550   if (is_preinitialized_vtable()) {
 551     // At runtime initialize_vtable is rerun as part of link_class_impl()
 552     // for shared class loaded by the non-boot loader to obtain the loader
 553     // constraints based on the runtime classloaders&#39; context. The dumptime
 554     // method at the vtable index should be the same as the runtime method.
 555     assert(table()[index].method() == m,
 556            &quot;archived method is different from the runtime method&quot;);
 557   } else {
 558     if (log_develop_is_enabled(Trace, vtables)) {
 559       ResourceMark rm;
 560       LogTarget(Trace, vtables) lt;
 561       LogStream ls(lt);
 562       const char* sig = (m != NULL) ? m-&gt;name_and_sig_as_C_string() : &quot;&lt;NULL&gt;&quot;;
 563       ls.print(&quot;adding %s at index %d, flags: &quot;, sig, index);
 564       if (m != NULL) {
 565         m-&gt;print_linkage_flags(&amp;ls);
 566       }
 567       ls.cr();
 568     }
 569     table()[index].set(m);
 570   }
 571 }
 572 
 573 // Find out if a method &quot;m&quot; with superclass &quot;super&quot;, loader &quot;classloader&quot; and
 574 // name &quot;classname&quot; needs a new vtable entry.  Let P be a class package defined
 575 // by &quot;classloader&quot; and &quot;classname&quot;.
 576 // NOTE: The logic used here is very similar to the one used for computing
 577 // the vtables indices for a method. We cannot directly use that function because,
 578 // we allocate the InstanceKlass at load time, and that requires that the
 579 // superclass has been loaded.
 580 // However, the vtable entries are filled in at link time, and therefore
 581 // the superclass&#39; vtable may not yet have been filled in.
 582 bool klassVtable::needs_new_vtable_entry(const methodHandle&amp; target_method,
 583                                          const Klass* super,
 584                                          Handle classloader,
 585                                          Symbol* classname,
 586                                          AccessFlags class_flags,
 587                                          u2 major_version,
 588                                          TRAPS) {
 589   if (class_flags.is_interface()) {
 590     // Interfaces do not use vtables, except for java.lang.Object methods,
 591     // so there is no point to assigning
 592     // a vtable index to any of their local methods.  If we refrain from doing this,
 593     // we can use Method::_vtable_index to hold the itable index
 594     return false;
 595   }
 596 
 597   if (target_method-&gt;is_final_method(class_flags) ||
 598       // a final method never needs a new entry; final methods can be statically
 599       // resolved and they have to be present in the vtable only if they override
 600       // a super&#39;s method, in which case they re-use its entry
 601       (target_method()-&gt;is_private()) ||
 602       // private methods don&#39;t need to be in vtable
 603       (target_method()-&gt;is_static()) ||
 604       // static methods don&#39;t need to be in vtable
 605       (target_method()-&gt;name()-&gt;fast_compare(vmSymbols::object_initializer_name()) == 0)
 606       // &lt;init&gt; is never called dynamically-bound
 607       ) {
 608     return false;
 609   }
 610 
 611   // Concrete interface methods do not need new entries, they override
 612   // abstract method entries using default inheritance rules
 613   if (target_method()-&gt;method_holder() != NULL &amp;&amp;
 614       target_method()-&gt;method_holder()-&gt;is_interface()  &amp;&amp;
 615       !target_method()-&gt;is_abstract()) {
 616     assert(target_method()-&gt;is_default_method(),
 617            &quot;unexpected interface method type&quot;);
 618     return false;
 619   }
 620 
 621   // we need a new entry if there is no superclass
 622   if (super == NULL) {
 623     return true;
 624   }
 625 
 626   // Package private methods always need a new entry to root their own
 627   // overriding. This allows transitive overriding to work.
 628   if (target_method()-&gt;is_package_private()) {
 629     return true;
 630   }
 631 
 632   // search through the super class hierarchy to see if we need
 633   // a new entry
 634   ResourceMark rm;
 635   Symbol* name = target_method()-&gt;name();
 636   Symbol* signature = target_method()-&gt;signature();
 637   const Klass* k = super;
 638   Method* super_method = NULL;
 639   InstanceKlass *holder = NULL;
 640   Method* recheck_method =  NULL;
 641   while (k != NULL) {
 642     // lookup through the hierarchy for a method with matching name and sign.
 643     super_method = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
 644     if (super_method == NULL) {
 645       break; // we still have to search for a matching miranda method
 646     }
 647     // get the class holding the matching method
 648     // make sure you use that class for is_override
 649     InstanceKlass* superk = super_method-&gt;method_holder();
 650     // we want only instance method matches
 651     // ignore private methods found via lookup_method since they do not participate in overriding,
 652     // and since we do override around them: e.g. a.m pub/b.m private/c.m pub,
 653     // ignore private, c.m pub does override a.m pub
 654     // For classes that were not javac&#39;d together, we also do transitive overriding around
 655     // methods that have less accessibility
 656     if ((!super_method-&gt;is_static()) &amp;&amp;
 657        (!super_method-&gt;is_private())) {
 658       if (superk-&gt;is_override(super_method, classloader, classname, THREAD)) {
 659         return false;
 660       // else keep looking for transitive overrides
 661       }
 662     }
 663 
 664     // Start with lookup result and continue to search up, for versions supporting transitive override
 665     if (major_version &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION) {
 666       k = superk-&gt;super(); // haven&#39;t found an override match yet; continue to look
 667     } else {
 668       break;
 669     }
 670   }
 671 
 672   // if the target method is public or protected it may have a matching
 673   // miranda method in the super, whose entry it should re-use.
 674   // Actually, to handle cases that javac would not generate, we need
 675   // this check for all access permissions.
 676   const InstanceKlass *sk = InstanceKlass::cast(super);
 677   if (sk-&gt;has_miranda_methods()) {
 678     if (sk-&gt;lookup_method_in_all_interfaces(name, signature, Klass::find_defaults) != NULL) {
 679       return false;  // found a matching miranda; we do not need a new entry
 680     }
 681   }
 682   return true; // found no match; we need a new entry
 683 }
 684 
 685 // Support for miranda methods
 686 
 687 // get the vtable index of a miranda method with matching &quot;name&quot; and &quot;signature&quot;
 688 int klassVtable::index_of_miranda(Symbol* name, Symbol* signature) {
 689   // search from the bottom, might be faster
 690   for (int i = (length() - 1); i &gt;= 0; i--) {
 691     Method* m = table()[i].method();
 692     if (is_miranda_entry_at(i) &amp;&amp;
 693         m-&gt;name() == name &amp;&amp; m-&gt;signature() == signature) {
 694       return i;
 695     }
 696   }
 697   return Method::invalid_vtable_index;
 698 }
 699 
 700 // check if an entry at an index is miranda
 701 // requires that method m at entry be declared (&quot;held&quot;) by an interface.
 702 bool klassVtable::is_miranda_entry_at(int i) {
 703   Method* m = method_at(i);
 704   Klass* method_holder = m-&gt;method_holder();
 705   InstanceKlass *mhk = InstanceKlass::cast(method_holder);
 706 
 707   // miranda methods are public abstract instance interface methods in a class&#39;s vtable
 708   if (mhk-&gt;is_interface()) {
 709     assert(m-&gt;is_public(), &quot;should be public&quot;);
 710     assert(ik()-&gt;implements_interface(method_holder) , &quot;this class should implement the interface&quot;);
 711     if (is_miranda(m, ik()-&gt;methods(), ik()-&gt;default_methods(), ik()-&gt;super(), klass()-&gt;is_interface())) {
 712       return true;
 713     }
 714   }
 715   return false;
 716 }
 717 
 718 // Check if a method is a miranda method, given a class&#39;s methods array,
 719 // its default_method table and its super class.
 720 // &quot;Miranda&quot; means an abstract non-private method that would not be
 721 // overridden for the local class.
 722 // A &quot;miranda&quot; method should only include non-private interface
 723 // instance methods, i.e. not private methods, not static methods,
 724 // not default methods (concrete interface methods), not overpass methods.
 725 // If a given class already has a local (including overpass) method, a
 726 // default method, or any of its superclasses has the same which would have
 727 // overridden an abstract method, then this is not a miranda method.
 728 //
 729 // Miranda methods are checked multiple times.
 730 // Pass 1: during class load/class file parsing: before vtable size calculation:
 731 // include superinterface abstract and default methods (non-private instance).
 732 // We include potential default methods to give them space in the vtable.
 733 // During the first run, the current instanceKlass has not yet been
 734 // created, the superclasses and superinterfaces do have instanceKlasses
 735 // but may not have vtables, the default_methods list is empty, no overpasses.
 736 // Default method generation uses the all_mirandas array as the starter set for
 737 // maximally-specific default method calculation.  So, for both classes and
 738 // interfaces, it is necessary that the first pass will find all non-private
 739 // interface instance methods, whether or not they are concrete.
 740 //
 741 // Pass 2: recalculated during vtable initialization: only include abstract methods.
 742 // The goal of pass 2 is to walk through the superinterfaces to see if any of
 743 // the superinterface methods (which were all abstract pre-default methods)
 744 // need to be added to the vtable.
 745 // With the addition of default methods, we have three new challenges:
 746 // overpasses, static interface methods and private interface methods.
 747 // Static and private interface methods do not get added to the vtable and
 748 // are not seen by the method resolution process, so we skip those.
 749 // Overpass methods are already in the vtable, so vtable lookup will
 750 // find them and we don&#39;t need to add a miranda method to the end of
 751 // the vtable. So we look for overpass methods and if they are found we
 752 // return false. Note that we inherit our superclasses vtable, so
 753 // the superclass&#39; search also needs to use find_overpass so that if
 754 // one is found we return false.
 755 // False means - we don&#39;t need a miranda method added to the vtable.
 756 //
 757 // During the second run, default_methods is set up, so concrete methods from
 758 // superinterfaces with matching names/signatures to default_methods are already
 759 // in the default_methods list and do not need to be appended to the vtable
 760 // as mirandas. Abstract methods may already have been handled via
 761 // overpasses - either local or superclass overpasses, which may be
 762 // in the vtable already.
 763 //
 764 // Pass 3: They are also checked by link resolution and selection,
 765 // for invocation on a method (not interface method) reference that
 766 // resolves to a method with an interface as its method_holder.
 767 // Used as part of walking from the bottom of the vtable to find
 768 // the vtable index for the miranda method.
 769 //
 770 // Part of the Miranda Rights in the US mean that if you do not have
 771 // an attorney one will be appointed for you.
 772 bool klassVtable::is_miranda(Method* m, Array&lt;Method*&gt;* class_methods,
 773                              Array&lt;Method*&gt;* default_methods, const Klass* super,
 774                              bool is_interface) {
 775   if (m-&gt;is_static() || m-&gt;is_private() || m-&gt;is_overpass()) {
 776     return false;
 777   }
 778   Symbol* name = m-&gt;name();
 779   Symbol* signature = m-&gt;signature();
 780 
 781   // First look in local methods to see if already covered
 782   if (InstanceKlass::find_local_method(class_methods, name, signature,
 783               Klass::find_overpass, Klass::skip_static, Klass::skip_private) != NULL)
 784   {
 785     return false;
 786   }
 787 
 788   // Check local default methods
 789   if ((default_methods != NULL) &amp;&amp;
 790     (InstanceKlass::find_method(default_methods, name, signature) != NULL))
 791    {
 792      return false;
 793    }
 794 
 795   // Iterate on all superclasses, which should be InstanceKlasses.
 796   // Note that we explicitly look for overpasses at each level.
 797   // Overpasses may or may not exist for supers for pass 1,
 798   // they should have been created for pass 2 and later.
 799 
 800   for (const Klass* cursuper = super; cursuper != NULL; cursuper = cursuper-&gt;super())
 801   {
 802      Method* found_mth = InstanceKlass::cast(cursuper)-&gt;find_local_method(name, signature,
 803        Klass::find_overpass, Klass::skip_static, Klass::skip_private);
 804      // Ignore non-public methods in java.lang.Object if klass is an interface.
 805      if (found_mth != NULL &amp;&amp; (!is_interface ||
 806          !SystemDictionary::is_nonpublic_Object_method(found_mth))) {
 807        return false;
 808      }
 809   }
 810 
 811   return true;
 812 }
 813 
 814 // Scans current_interface_methods for miranda methods that do not
 815 // already appear in new_mirandas, or default methods,  and are also not defined-and-non-private
 816 // in super (superclass).  These mirandas are added to all_mirandas if it is
 817 // not null; in addition, those that are not duplicates of miranda methods
 818 // inherited by super from its interfaces are added to new_mirandas.
 819 // Thus, new_mirandas will be the set of mirandas that this class introduces,
 820 // all_mirandas will be the set of all mirandas applicable to this class
 821 // including all defined in superclasses.
 822 void klassVtable::add_new_mirandas_to_lists(
 823     GrowableArray&lt;Method*&gt;* new_mirandas, GrowableArray&lt;Method*&gt;* all_mirandas,
 824     Array&lt;Method*&gt;* current_interface_methods, Array&lt;Method*&gt;* class_methods,
 825     Array&lt;Method*&gt;* default_methods, const Klass* super, bool is_interface) {
 826 
 827   // iterate thru the current interface&#39;s method to see if it a miranda
 828   int num_methods = current_interface_methods-&gt;length();
 829   for (int i = 0; i &lt; num_methods; i++) {
 830     Method* im = current_interface_methods-&gt;at(i);
 831     bool is_duplicate = false;
 832     int num_of_current_mirandas = new_mirandas-&gt;length();
 833     // check for duplicate mirandas in different interfaces we implement
 834     for (int j = 0; j &lt; num_of_current_mirandas; j++) {
 835       Method* miranda = new_mirandas-&gt;at(j);
 836       if ((im-&gt;name() == miranda-&gt;name()) &amp;&amp;
 837           (im-&gt;signature() == miranda-&gt;signature())) {
 838         is_duplicate = true;
 839         break;
 840       }
 841     }
 842 
 843     if (!is_duplicate) { // we don&#39;t want duplicate miranda entries in the vtable
 844       if (is_miranda(im, class_methods, default_methods, super, is_interface)) { // is it a miranda at all?
 845         const InstanceKlass *sk = InstanceKlass::cast(super);
 846         // check if it is a duplicate of a super&#39;s miranda
 847         if (sk-&gt;lookup_method_in_all_interfaces(im-&gt;name(), im-&gt;signature(), Klass::find_defaults) == NULL) {
 848           new_mirandas-&gt;append(im);
 849         }
 850         if (all_mirandas != NULL) {
 851           all_mirandas-&gt;append(im);
 852         }
 853       }
 854     }
 855   }
 856 }
 857 
 858 void klassVtable::get_mirandas(GrowableArray&lt;Method*&gt;* new_mirandas,
 859                                GrowableArray&lt;Method*&gt;* all_mirandas,
 860                                const Klass* super,
 861                                Array&lt;Method*&gt;* class_methods,
 862                                Array&lt;Method*&gt;* default_methods,
 863                                Array&lt;InstanceKlass*&gt;* local_interfaces,
 864                                bool is_interface) {
 865   assert((new_mirandas-&gt;length() == 0) , &quot;current mirandas must be 0&quot;);
 866 
 867   // iterate thru the local interfaces looking for a miranda
 868   int num_local_ifs = local_interfaces-&gt;length();
 869   for (int i = 0; i &lt; num_local_ifs; i++) {
 870     InstanceKlass *ik = InstanceKlass::cast(local_interfaces-&gt;at(i));
 871     add_new_mirandas_to_lists(new_mirandas, all_mirandas,
 872                               ik-&gt;methods(), class_methods,
 873                               default_methods, super, is_interface);
 874     // iterate thru each local&#39;s super interfaces
 875     Array&lt;InstanceKlass*&gt;* super_ifs = ik-&gt;transitive_interfaces();
 876     int num_super_ifs = super_ifs-&gt;length();
 877     for (int j = 0; j &lt; num_super_ifs; j++) {
 878       InstanceKlass *sik = super_ifs-&gt;at(j);
 879       add_new_mirandas_to_lists(new_mirandas, all_mirandas,
 880                                 sik-&gt;methods(), class_methods,
 881                                 default_methods, super, is_interface);
 882     }
 883   }
 884 }
 885 
 886 // Discover miranda methods (&quot;miranda&quot; = &quot;interface abstract, no binding&quot;),
 887 // and append them into the vtable starting at index initialized,
 888 // return the new value of initialized.
 889 // Miranda methods use vtable entries, but do not get assigned a vtable_index
 890 // The vtable_index is discovered by searching from the end of the vtable
 891 int klassVtable::fill_in_mirandas(int initialized, TRAPS) {
 892   ResourceMark rm(THREAD);
 893   GrowableArray&lt;Method*&gt; mirandas(20);
 894   get_mirandas(&amp;mirandas, NULL, ik()-&gt;super(), ik()-&gt;methods(),
 895                ik()-&gt;default_methods(), ik()-&gt;local_interfaces(),
 896                klass()-&gt;is_interface());
 897   for (int i = 0; i &lt; mirandas.length(); i++) {
 898     if (log_develop_is_enabled(Trace, vtables)) {
 899       Method* meth = mirandas.at(i);
 900       LogTarget(Trace, vtables) lt;
 901       LogStream ls(lt);
 902       if (meth != NULL) {
 903         char* sig = meth-&gt;name_and_sig_as_C_string();
 904         ls.print(&quot;fill in mirandas with %s index %d, flags: &quot;,
 905                      sig, initialized);
 906         meth-&gt;print_linkage_flags(&amp;ls);
 907         ls.cr();
 908       }
 909     }
 910     put_method_at(mirandas.at(i), initialized);
 911     ++initialized;
 912   }
 913   return initialized;
 914 }
 915 
 916 // Copy this class&#39;s vtable to the vtable beginning at start.
 917 // Used to copy superclass vtable to prefix of subclass&#39;s vtable.
 918 void klassVtable::copy_vtable_to(vtableEntry* start) {
 919   Copy::disjoint_words((HeapWord*)table(), (HeapWord*)start, _length * vtableEntry::size());
 920 }
 921 
 922 #if INCLUDE_JVMTI
 923 bool klassVtable::adjust_default_method(int vtable_index, Method* old_method, Method* new_method) {
 924   // If old_method is default, find this vtable index in default_vtable_indices
 925   // and replace that method in the _default_methods list
 926   bool updated = false;
 927 
 928   Array&lt;Method*&gt;* default_methods = ik()-&gt;default_methods();
 929   if (default_methods != NULL) {
 930     int len = default_methods-&gt;length();
 931     for (int idx = 0; idx &lt; len; idx++) {
 932       if (vtable_index == ik()-&gt;default_vtable_indices()-&gt;at(idx)) {
 933         if (default_methods-&gt;at(idx) == old_method) {
 934           default_methods-&gt;at_put(idx, new_method);
 935           updated = true;
 936         }
 937         break;
 938       }
 939     }
 940   }
 941   return updated;
 942 }
 943 
 944 // search the vtable for uses of either obsolete or EMCP methods
 945 void klassVtable::adjust_method_entries(bool * trace_name_printed) {
 946   int prn_enabled = 0;
 947   for (int index = 0; index &lt; length(); index++) {
 948     Method* old_method = unchecked_method_at(index);
 949     if (old_method == NULL || !old_method-&gt;is_old()) {
 950       continue; // skip uninteresting entries
 951     }
 952     assert(!old_method-&gt;is_deleted(), &quot;vtable methods may not be deleted&quot;);
 953 
 954     Method* new_method = old_method-&gt;get_new_method();
 955     put_method_at(new_method, index);
 956 
 957     // For default methods, need to update the _default_methods array
 958     // which can only have one method entry for a given signature
 959     bool updated_default = false;
 960     if (old_method-&gt;is_default_method()) {
 961       updated_default = adjust_default_method(index, old_method, new_method);
 962     }
 963 
 964     if (log_is_enabled(Info, redefine, class, update)) {
 965       ResourceMark rm;
 966       if (!(*trace_name_printed)) {
 967         log_info(redefine, class, update)
 968           (&quot;adjust: klassname=%s for methods from name=%s&quot;,
 969            _klass-&gt;external_name(), old_method-&gt;method_holder()-&gt;external_name());
 970         *trace_name_printed = true;
 971       }
 972       log_debug(redefine, class, update, vtables)
 973         (&quot;vtable method update: %s(%s), updated default = %s&quot;,
 974          new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string(), updated_default ? &quot;true&quot; : &quot;false&quot;);
 975     }
 976   }
 977 }
 978 
 979 // a vtable should never contain old or obsolete methods
 980 bool klassVtable::check_no_old_or_obsolete_entries() {
 981   for (int i = 0; i &lt; length(); i++) {
 982     Method* m = unchecked_method_at(i);
 983     if (m != NULL &amp;&amp;
 984         (NOT_PRODUCT(!m-&gt;is_valid() ||) m-&gt;is_old() || m-&gt;is_obsolete())) {
 985       return false;
 986     }
 987   }
 988   return true;
 989 }
 990 
 991 void klassVtable::dump_vtable() {
 992   tty-&gt;print_cr(&quot;vtable dump --&quot;);
 993   for (int i = 0; i &lt; length(); i++) {
 994     Method* m = unchecked_method_at(i);
 995     if (m != NULL) {
 996       tty-&gt;print(&quot;      (%5d)  &quot;, i);
 997       m-&gt;access_flags().print_on(tty);
 998       if (m-&gt;is_default_method()) {
 999         tty-&gt;print(&quot;default &quot;);
1000       }
1001       if (m-&gt;is_overpass()) {
1002         tty-&gt;print(&quot;overpass&quot;);
1003       }
1004       tty-&gt;print(&quot; --  &quot;);
1005       m-&gt;print_name(tty);
1006       tty-&gt;cr();
1007     }
1008   }
1009 }
1010 #endif // INCLUDE_JVMTI
1011 
1012 // CDS/RedefineClasses support - clear vtables so they can be reinitialized
1013 void klassVtable::clear_vtable() {
1014   for (int i = 0; i &lt; _length; i++) table()[i].clear();
1015 }
1016 
1017 bool klassVtable::is_initialized() {
1018   return _length == 0 || table()[0].method() != NULL;
1019 }
1020 
1021 //-----------------------------------------------------------------------------------------
1022 // Itable code
1023 
1024 // Initialize a itableMethodEntry
1025 void itableMethodEntry::initialize(Method* m) {
1026   if (m == NULL) return;
1027 
1028 #ifdef ASSERT
1029   if (MetaspaceShared::is_in_shared_metaspace((void*)&amp;_method) &amp;&amp;
1030      !MetaspaceShared::remapped_readwrite()) {
1031     // At runtime initialize_itable is rerun as part of link_class_impl()
1032     // for a shared class loaded by the non-boot loader.
1033     // The dumptime itable method entry should be the same as the runtime entry.
1034     assert(_method == m, &quot;sanity&quot;);
1035   }
1036 #endif
1037   _method = m;
1038 }
1039 
1040 klassItable::klassItable(InstanceKlass* klass) {
1041   _klass = klass;
1042 
1043   if (klass-&gt;itable_length() &gt; 0) {
1044     itableOffsetEntry* offset_entry = (itableOffsetEntry*)klass-&gt;start_of_itable();
1045     if (offset_entry  != NULL &amp;&amp; offset_entry-&gt;interface_klass() != NULL) { // Check that itable is initialized
1046       // First offset entry points to the first method_entry
1047       intptr_t* method_entry  = (intptr_t *)(((address)klass) + offset_entry-&gt;offset());
1048       intptr_t* end         = klass-&gt;end_of_itable();
1049 
1050       _table_offset      = (intptr_t*)offset_entry - (intptr_t*)klass;
1051       _size_offset_table = (method_entry - ((intptr_t*)offset_entry)) / itableOffsetEntry::size();
1052       _size_method_table = (end - method_entry)                  / itableMethodEntry::size();
1053       assert(_table_offset &gt;= 0 &amp;&amp; _size_offset_table &gt;= 0 &amp;&amp; _size_method_table &gt;= 0, &quot;wrong computation&quot;);
1054       return;
1055     }
1056   }
1057 
1058   // The length of the itable was either zero, or it has not yet been initialized.
1059   _table_offset      = 0;
1060   _size_offset_table = 0;
1061   _size_method_table = 0;
1062 }
1063 
1064 static int initialize_count = 0;
1065 
1066 // Initialization
1067 void klassItable::initialize_itable(bool checkconstraints, TRAPS) {
1068   if (_klass-&gt;is_interface()) {
1069     // This needs to go after vtable indices are assigned but
1070     // before implementors need to know the number of itable indices.
1071     assign_itable_indices_for_interface(InstanceKlass::cast(_klass), THREAD);
1072   }
1073 
1074   // Cannot be setup doing bootstrapping, interfaces don&#39;t have
1075   // itables, and klass with only ones entry have empty itables
1076   if (Universe::is_bootstrapping() ||
1077       _klass-&gt;is_interface() ||
1078       _klass-&gt;itable_length() == itableOffsetEntry::size()) return;
1079 
1080   // There&#39;s alway an extra itable entry so we can null-terminate it.
1081   guarantee(size_offset_table() &gt;= 1, &quot;too small&quot;);
1082   int num_interfaces = size_offset_table() - 1;
1083   if (num_interfaces &gt; 0) {
1084     ResourceMark rm(THREAD);
1085     log_develop_debug(itables)(&quot;%3d: Initializing itables for %s&quot;, ++initialize_count,
1086                        _klass-&gt;name()-&gt;as_C_string());
1087 
1088 
1089     // Iterate through all interfaces
1090     int i;
1091     for(i = 0; i &lt; num_interfaces; i++) {
1092       itableOffsetEntry* ioe = offset_entry(i);
1093       HandleMark hm(THREAD);
1094       Klass* interf = ioe-&gt;interface_klass();
1095       assert(interf != NULL &amp;&amp; ioe-&gt;offset() != 0, &quot;bad offset entry in itable&quot;);
1096       initialize_itable_for_interface(ioe-&gt;offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);
1097     }
1098 
1099   }
1100   // Check that the last entry is empty
1101   itableOffsetEntry* ioe = offset_entry(size_offset_table() - 1);
1102   guarantee(ioe-&gt;interface_klass() == NULL &amp;&amp; ioe-&gt;offset() == 0, &quot;terminator entry missing&quot;);
1103 }
1104 
1105 
1106 inline bool interface_method_needs_itable_index(Method* m) {
1107   if (m-&gt;is_static())           return false;   // e.g., Stream.empty
1108   if (m-&gt;is_initializer())      return false;   // &lt;init&gt; or &lt;clinit&gt;
1109   if (m-&gt;is_private())          return false;   // uses direct call
1110   // If an interface redeclares a method from java.lang.Object,
1111   // it should already have a vtable index, don&#39;t touch it.
1112   // e.g., CharSequence.toString (from initialize_vtable)
1113   // if (m-&gt;has_vtable_index())  return false; // NO!
1114   return true;
1115 }
1116 
1117 int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {
1118   // an interface does not have an itable, but its methods need to be numbered
1119   ResourceMark rm(THREAD);
1120   log_develop_debug(itables)(&quot;%3d: Initializing itable indices for interface %s&quot;,
1121                              ++initialize_count, klass-&gt;name()-&gt;as_C_string());
1122   Array&lt;Method*&gt;* methods = klass-&gt;methods();
1123   int nof_methods = methods-&gt;length();
1124   int ime_num = 0;
1125   for (int i = 0; i &lt; nof_methods; i++) {
1126     Method* m = methods-&gt;at(i);
1127     if (interface_method_needs_itable_index(m)) {
1128       assert(!m-&gt;is_final_method(), &quot;no final interface methods&quot;);
1129       // If m is already assigned a vtable index, do not disturb it.
1130       if (log_develop_is_enabled(Trace, itables)) {
1131         LogTarget(Trace, itables) lt;
1132         LogStream ls(lt);
1133         assert(m != NULL, &quot;methods can never be null&quot;);
1134         const char* sig = m-&gt;name_and_sig_as_C_string();
1135         if (m-&gt;has_vtable_index()) {
1136           ls.print(&quot;vtable index %d for method: %s, flags: &quot;, m-&gt;vtable_index(), sig);
1137         } else {
1138           ls.print(&quot;itable index %d for method: %s, flags: &quot;, ime_num, sig);
1139         }
1140         m-&gt;print_linkage_flags(&amp;ls);
1141         ls.cr();
1142       }
1143       if (!m-&gt;has_vtable_index()) {
1144         // A shared method could have an initialized itable_index that
1145         // is &lt; 0.
1146         assert(m-&gt;vtable_index() == Method::pending_itable_index ||
1147                m-&gt;is_shared(),
1148                &quot;set by initialize_vtable&quot;);
1149         m-&gt;set_itable_index(ime_num);
1150         // Progress to next itable entry
1151         ime_num++;
1152       }
1153     }
1154   }
1155   assert(ime_num == method_count_for_interface(klass), &quot;proper sizing&quot;);
1156   return ime_num;
1157 }
1158 
1159 int klassItable::method_count_for_interface(InstanceKlass* interf) {
1160   assert(interf-&gt;is_interface(), &quot;must be&quot;);
1161   Array&lt;Method*&gt;* methods = interf-&gt;methods();
1162   int nof_methods = methods-&gt;length();
1163   int length = 0;
1164   while (nof_methods &gt; 0) {
1165     Method* m = methods-&gt;at(nof_methods-1);
1166     if (m-&gt;has_itable_index()) {
1167       length = m-&gt;itable_index() + 1;
1168       break;
1169     }
1170     nof_methods -= 1;
1171   }
1172 #ifdef ASSERT
1173   int nof_methods_copy = nof_methods;
1174   while (nof_methods_copy &gt; 0) {
1175     Method* mm = methods-&gt;at(--nof_methods_copy);
1176     assert(!mm-&gt;has_itable_index() || mm-&gt;itable_index() &lt; length, &quot;&quot;);
1177   }
1178 #endif //ASSERT
1179   // return the rightmost itable index, plus one; or 0 if no methods have
1180   // itable indices
1181   return length;
1182 }
1183 
1184 
1185 void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {
1186   assert(interf-&gt;is_interface(), &quot;must be&quot;);
1187   Array&lt;Method*&gt;* methods = interf-&gt;methods();
1188   int nof_methods = methods-&gt;length();
1189   HandleMark hm;
1190   Handle interface_loader (THREAD, interf-&gt;class_loader());
1191 
1192   int ime_count = method_count_for_interface(interf);
1193   for (int i = 0; i &lt; nof_methods; i++) {
1194     Method* m = methods-&gt;at(i);
1195     methodHandle target;
1196     if (m-&gt;has_itable_index()) {
1197       // This search must match the runtime resolution, i.e. selection search for invokeinterface
1198       // to correctly enforce loader constraints for interface method inheritance.
1199       // Private methods are skipped as a private class method can never be the implementation
1200       // of an interface method.
1201       // Invokespecial does not perform selection based on the receiver, so it does not use
1202       // the cached itable.
1203       target = LinkResolver::lookup_instance_method_in_klasses(_klass, m-&gt;name(), m-&gt;signature(),
1204                                                                Klass::skip_private, CHECK);
1205     }
1206     if (target == NULL || !target-&gt;is_public() || target-&gt;is_abstract() || target-&gt;is_overpass()) {
1207       assert(target == NULL || !target-&gt;is_overpass() || target-&gt;is_public(),
1208              &quot;Non-public overpass method!&quot;);
1209       // Entry does not resolve. Leave it empty for AbstractMethodError or other error.
1210       if (!(target == NULL) &amp;&amp; !target-&gt;is_public()) {
1211         // Stuff an IllegalAccessError throwing method in there instead.
1212         itableOffsetEntry::method_entry(_klass, method_table_offset)[m-&gt;itable_index()].
1213             initialize(Universe::throw_illegal_access_error());
1214       }
1215     } else {
1216       // Entry did resolve, check loader constraints before initializing
1217       // if checkconstraints requested
1218       if (checkconstraints) {
1219         Handle method_holder_loader (THREAD, target-&gt;method_holder()-&gt;class_loader());
1220         if (!oopDesc::equals(method_holder_loader(), interface_loader())) {
1221           ResourceMark rm(THREAD);
1222           Symbol* failed_type_symbol =
1223             SystemDictionary::check_signature_loaders(m-&gt;signature(),
1224                                                       method_holder_loader,
1225                                                       interface_loader,
1226                                                       true, CHECK);
1227           if (failed_type_symbol != NULL) {
1228             stringStream ss;
1229             ss.print(&quot;loader constraint violation in interface itable&quot;
1230                      &quot; initialization for class %s: when selecting method %s the&quot;
1231                      &quot; class loader %s for super interface %s, and the class&quot;
1232                      &quot; loader %s of the selected method&#39;s type, %s have&quot;
1233                      &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
1234                      _klass-&gt;external_name(),
1235                      m-&gt;name_and_sig_as_C_string(),
1236                      interf-&gt;class_loader_data()-&gt;loader_name_and_id(),
1237                      interf-&gt;external_name(),
1238                      target()-&gt;method_holder()-&gt;class_loader_data()-&gt;loader_name_and_id(),
1239                      target()-&gt;method_holder()-&gt;external_name(),
1240                      failed_type_symbol-&gt;as_klass_external_name(),
1241                      interf-&gt;class_in_module_of_loader(false, true),
1242                      target()-&gt;method_holder()-&gt;class_in_module_of_loader(false, true));
1243             THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
1244           }
1245         }
1246       }
1247 
1248       // ime may have moved during GC so recalculate address
1249       int ime_num = m-&gt;itable_index();
1250       assert(ime_num &lt; ime_count, &quot;oob&quot;);
1251       itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target());
1252       if (log_develop_is_enabled(Trace, itables)) {
1253         ResourceMark rm(THREAD);
1254         if (target() != NULL) {
1255           LogTarget(Trace, itables) lt;
1256           LogStream ls(lt);
1257           char* sig = target()-&gt;name_and_sig_as_C_string();
1258           ls.print(&quot;interface: %s, ime_num: %d, target: %s, method_holder: %s &quot;,
1259                        interf-&gt;internal_name(), ime_num, sig,
1260                        target()-&gt;method_holder()-&gt;internal_name());
1261           ls.print(&quot;target_method flags: &quot;);
1262           target()-&gt;print_linkage_flags(&amp;ls);
1263           ls.cr();
1264         }
1265       }
1266     }
1267   }
1268 }
1269 
1270 #if INCLUDE_JVMTI
1271 // search the itable for uses of either obsolete or EMCP methods
1272 void klassItable::adjust_method_entries(bool * trace_name_printed) {
1273 
1274   itableMethodEntry* ime = method_entry(0);
1275   for (int i = 0; i &lt; _size_method_table; i++, ime++) {
1276     Method* old_method = ime-&gt;method();
1277     if (old_method == NULL || !old_method-&gt;is_old()) {
1278       continue; // skip uninteresting entries
1279     }
1280     assert(!old_method-&gt;is_deleted(), &quot;itable methods may not be deleted&quot;);
1281     Method* new_method = old_method-&gt;get_new_method();
1282     ime-&gt;initialize(new_method);
1283 
1284     if (log_is_enabled(Info, redefine, class, update)) {
1285       ResourceMark rm;
1286       if (!(*trace_name_printed)) {
1287         log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());
1288         *trace_name_printed = true;
1289       }
1290       log_trace(redefine, class, update, itables)
1291         (&quot;itable method update: %s(%s)&quot;, new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
1292     }
1293   }
1294 }
1295 
1296 // an itable should never contain old or obsolete methods
1297 bool klassItable::check_no_old_or_obsolete_entries() {
1298   itableMethodEntry* ime = method_entry(0);
1299   for (int i = 0; i &lt; _size_method_table; i++) {
1300     Method* m = ime-&gt;method();
1301     if (m != NULL &amp;&amp;
1302         (NOT_PRODUCT(!m-&gt;is_valid() ||) m-&gt;is_old() || m-&gt;is_obsolete())) {
1303       return false;
1304     }
1305     ime++;
1306   }
1307   return true;
1308 }
1309 
1310 void klassItable::dump_itable() {
1311   itableMethodEntry* ime = method_entry(0);
1312   tty-&gt;print_cr(&quot;itable dump --&quot;);
1313   for (int i = 0; i &lt; _size_method_table; i++) {
1314     Method* m = ime-&gt;method();
1315     if (m != NULL) {
1316       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1317       m-&gt;access_flags().print_on(tty);
1318       if (m-&gt;is_default_method()) {
1319         tty-&gt;print(&quot;default &quot;);
1320       }
1321       tty-&gt;print(&quot; --  &quot;);
1322       m-&gt;print_name(tty);
1323       tty-&gt;cr();
1324     }
1325     ime++;
1326   }
1327 }
1328 #endif // INCLUDE_JVMTI
1329 
1330 // Setup
1331 class InterfaceVisiterClosure : public StackObj {
1332  public:
1333   virtual void doit(InstanceKlass* intf, int method_count) = 0;
1334 };
1335 
1336 // Visit all interfaces with at least one itable method
1337 void visit_all_interfaces(Array&lt;InstanceKlass*&gt;* transitive_intf, InterfaceVisiterClosure *blk) {
1338   // Handle array argument
1339   for(int i = 0; i &lt; transitive_intf-&gt;length(); i++) {
1340     InstanceKlass* intf = transitive_intf-&gt;at(i);
1341     assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1342 
1343     // Find no. of itable methods
1344     int method_count = 0;
1345     // method_count = klassItable::method_count_for_interface(intf);
1346     Array&lt;Method*&gt;* methods = intf-&gt;methods();
1347     if (methods-&gt;length() &gt; 0) {
1348       for (int i = methods-&gt;length(); --i &gt;= 0; ) {
1349         if (interface_method_needs_itable_index(methods-&gt;at(i))) {
1350           method_count++;
1351         }
1352       }
1353     }
1354 
1355     // Visit all interfaces which either have any methods or can participate in receiver type check.
1356     // We do not bother to count methods in transitive interfaces, although that would allow us to skip
1357     // this step in the rare case of a zero-method interface extending another zero-method interface.
1358     if (method_count &gt; 0 || intf-&gt;transitive_interfaces()-&gt;length() &gt; 0) {
1359       blk-&gt;doit(intf, method_count);
1360     }
1361   }
1362 }
1363 
1364 class CountInterfacesClosure : public InterfaceVisiterClosure {
1365  private:
1366   int _nof_methods;
1367   int _nof_interfaces;
1368  public:
1369    CountInterfacesClosure() { _nof_methods = 0; _nof_interfaces = 0; }
1370 
1371    int nof_methods() const    { return _nof_methods; }
1372    int nof_interfaces() const { return _nof_interfaces; }
1373 
1374    void doit(InstanceKlass* intf, int method_count) { _nof_methods += method_count; _nof_interfaces++; }
1375 };
1376 
1377 class SetupItableClosure : public InterfaceVisiterClosure  {
1378  private:
1379   itableOffsetEntry* _offset_entry;
1380   itableMethodEntry* _method_entry;
1381   address            _klass_begin;
1382  public:
1383   SetupItableClosure(address klass_begin, itableOffsetEntry* offset_entry, itableMethodEntry* method_entry) {
1384     _klass_begin  = klass_begin;
1385     _offset_entry = offset_entry;
1386     _method_entry = method_entry;
1387   }
1388 
1389   itableMethodEntry* method_entry() const { return _method_entry; }
1390 
1391   void doit(InstanceKlass* intf, int method_count) {
1392     int offset = ((address)_method_entry) - _klass_begin;
1393     _offset_entry-&gt;initialize(intf, offset);
1394     _offset_entry++;
1395     _method_entry += method_count;
1396   }
1397 };
1398 
1399 int klassItable::compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
1400   // Count no of interfaces and total number of interface methods
1401   CountInterfacesClosure cic;
1402   visit_all_interfaces(transitive_interfaces, &amp;cic);
1403 
1404   // There&#39;s alway an extra itable entry so we can null-terminate it.
1405   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
1406 
1407   // Statistics
1408   update_stats(itable_size * wordSize);
1409 
1410   return itable_size;
1411 }
1412 
1413 
1414 // Fill out offset table and interface klasses into the itable space
1415 void klassItable::setup_itable_offset_table(InstanceKlass* klass) {
1416   if (klass-&gt;itable_length() == 0) return;
1417   assert(!klass-&gt;is_interface(), &quot;Should have zero length itable&quot;);
1418 
1419   // Count no of interfaces and total number of interface methods
1420   CountInterfacesClosure cic;
1421   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;cic);
1422   int nof_methods    = cic.nof_methods();
1423   int nof_interfaces = cic.nof_interfaces();
1424 
1425   // Add one extra entry so we can null-terminate the table
1426   nof_interfaces++;
1427 
1428   assert(compute_itable_size(klass-&gt;transitive_interfaces()) ==
1429          calc_itable_size(nof_interfaces, nof_methods),
1430          &quot;mismatch calculation of itable size&quot;);
1431 
1432   // Fill-out offset table
1433   itableOffsetEntry* ioe = (itableOffsetEntry*)klass-&gt;start_of_itable();
1434   itableMethodEntry* ime = (itableMethodEntry*)(ioe + nof_interfaces);
1435   intptr_t* end               = klass-&gt;end_of_itable();
1436   assert((oop*)(ime + nof_methods) &lt;= (oop*)klass-&gt;start_of_nonstatic_oop_maps(), &quot;wrong offset calculation (1)&quot;);
1437   assert((oop*)(end) == (oop*)(ime + nof_methods),                      &quot;wrong offset calculation (2)&quot;);
1438 
1439   // Visit all interfaces and initialize itable offset table
1440   SetupItableClosure sic((address)klass, ioe, ime);
1441   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;sic);
1442 
1443 #ifdef ASSERT
1444   ime  = sic.method_entry();
1445   oop* v = (oop*) klass-&gt;end_of_itable();
1446   assert( (oop*)(ime) == v, &quot;wrong offset calculation (2)&quot;);
1447 #endif
1448 }
1449 
1450 
1451 // inverse to itable_index
1452 Method* klassItable::method_for_itable_index(InstanceKlass* intf, int itable_index) {
1453   assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1454   assert(intf-&gt;verify_itable_index(itable_index), &quot;&quot;);
1455   Array&lt;Method*&gt;* methods = InstanceKlass::cast(intf)-&gt;methods();
1456 
1457   if (itable_index &lt; 0 || itable_index &gt;= method_count_for_interface(intf))
1458     return NULL;                // help caller defend against bad indices
1459 
1460   int index = itable_index;
1461   Method* m = methods-&gt;at(index);
1462   int index2 = -1;
1463   while (!m-&gt;has_itable_index() ||
1464          (index2 = m-&gt;itable_index()) != itable_index) {
1465     assert(index2 &lt; itable_index, &quot;monotonic&quot;);
1466     if (++index == methods-&gt;length())
1467       return NULL;
1468     m = methods-&gt;at(index);
1469   }
1470   assert(m-&gt;itable_index() == itable_index, &quot;correct inverse&quot;);
1471 
1472   return m;
1473 }
1474 
1475 void klassVtable::verify(outputStream* st, bool forced) {
1476   // make sure table is initialized
1477   if (!Universe::is_fully_initialized()) return;
1478 #ifndef PRODUCT
1479   // avoid redundant verifies
1480   if (!forced &amp;&amp; _verify_count == Universe::verify_count()) return;
1481   _verify_count = Universe::verify_count();
1482 #endif
1483   oop* end_of_obj = (oop*)_klass + _klass-&gt;size();
1484   oop* end_of_vtable = (oop *)&amp;table()[_length];
1485   if (end_of_vtable &gt; end_of_obj) {
1486     ResourceMark rm;
1487     fatal(&quot;klass %s: klass object too short (vtable extends beyond end)&quot;,
1488           _klass-&gt;internal_name());
1489   }
1490 
1491   for (int i = 0; i &lt; _length; i++) table()[i].verify(this, st);
1492   // verify consistency with superKlass vtable
1493   Klass* super = _klass-&gt;super();
1494   if (super != NULL) {
1495     InstanceKlass* sk = InstanceKlass::cast(super);
1496     klassVtable vt = sk-&gt;vtable();
1497     for (int i = 0; i &lt; vt.length(); i++) {
1498       verify_against(st, &amp;vt, i);
1499     }
1500   }
1501 }
1502 
1503 void klassVtable::verify_against(outputStream* st, klassVtable* vt, int index) {
1504   vtableEntry* vte = &amp;vt-&gt;table()[index];
1505   if (vte-&gt;method()-&gt;name()      != table()[index].method()-&gt;name() ||
1506       vte-&gt;method()-&gt;signature() != table()[index].method()-&gt;signature()) {
1507     fatal(&quot;mismatched name/signature of vtable entries&quot;);
1508   }
1509 }
1510 
1511 #ifndef PRODUCT
1512 void klassVtable::print() {
1513   ResourceMark rm;
1514   tty-&gt;print(&quot;klassVtable for klass %s (length %d):\n&quot;, _klass-&gt;internal_name(), length());
1515   for (int i = 0; i &lt; length(); i++) {
1516     table()[i].print();
1517     tty-&gt;cr();
1518   }
1519 }
1520 #endif
1521 
1522 void vtableEntry::verify(klassVtable* vt, outputStream* st) {
1523   NOT_PRODUCT(FlagSetting fs(IgnoreLockingAssertions, true));
1524   Klass* vtklass = vt-&gt;klass();
1525   if (vtklass-&gt;is_instance_klass() &amp;&amp;
1526      (InstanceKlass::cast(vtklass)-&gt;major_version() &gt;= klassVtable::VTABLE_TRANSITIVE_OVERRIDE_VERSION)) {
1527     assert(method() != NULL, &quot;must have set method&quot;);
1528   }
1529   if (method() != NULL) {
1530     method()-&gt;verify();
1531     // we sub_type, because it could be a miranda method
1532     if (!vtklass-&gt;is_subtype_of(method()-&gt;method_holder())) {
1533 #ifndef PRODUCT
1534       print();
1535 #endif
1536       fatal(&quot;vtableEntry &quot; PTR_FORMAT &quot;: method is from subclass&quot;, p2i(this));
1537     }
1538  }
1539 }
1540 
1541 #ifndef PRODUCT
1542 
1543 void vtableEntry::print() {
1544   ResourceMark rm;
1545   tty-&gt;print(&quot;vtableEntry %s: &quot;, method()-&gt;name()-&gt;as_C_string());
1546   if (Verbose) {
1547     tty-&gt;print(&quot;m &quot; PTR_FORMAT &quot; &quot;, p2i(method()));
1548   }
1549 }
1550 
1551 class VtableStats : AllStatic {
1552  public:
1553   static int no_klasses;                // # classes with vtables
1554   static int no_array_klasses;          // # array classes
1555   static int no_instance_klasses;       // # instanceKlasses
1556   static int sum_of_vtable_len;         // total # of vtable entries
1557   static int sum_of_array_vtable_len;   // total # of vtable entries in array klasses only
1558   static int fixed;                     // total fixed overhead in bytes
1559   static int filler;                    // overhead caused by filler bytes
1560   static int entries;                   // total bytes consumed by vtable entries
1561   static int array_entries;             // total bytes consumed by array vtable entries
1562 
1563   static void do_class(Klass* k) {
1564     Klass* kl = k;
1565     klassVtable vt = kl-&gt;vtable();
1566     no_klasses++;
1567     if (kl-&gt;is_instance_klass()) {
1568       no_instance_klasses++;
1569       kl-&gt;array_klasses_do(do_class);
1570     }
1571     if (kl-&gt;is_array_klass()) {
1572       no_array_klasses++;
1573       sum_of_array_vtable_len += vt.length();
1574     }
1575     sum_of_vtable_len += vt.length();
1576   }
1577 
1578   static void compute() {
1579     LockedClassesDo locked_do_class(&amp;do_class);
1580     ClassLoaderDataGraph::classes_do(&amp;locked_do_class);
1581     fixed  = no_klasses * oopSize;      // vtable length
1582     // filler size is a conservative approximation
1583     filler = oopSize * (no_klasses - no_instance_klasses) * (sizeof(InstanceKlass) - sizeof(ArrayKlass) - 1);
1584     entries = sizeof(vtableEntry) * sum_of_vtable_len;
1585     array_entries = sizeof(vtableEntry) * sum_of_array_vtable_len;
1586   }
1587 };
1588 
1589 int VtableStats::no_klasses = 0;
1590 int VtableStats::no_array_klasses = 0;
1591 int VtableStats::no_instance_klasses = 0;
1592 int VtableStats::sum_of_vtable_len = 0;
1593 int VtableStats::sum_of_array_vtable_len = 0;
1594 int VtableStats::fixed = 0;
1595 int VtableStats::filler = 0;
1596 int VtableStats::entries = 0;
1597 int VtableStats::array_entries = 0;
1598 
1599 void klassVtable::print_statistics() {
1600   ResourceMark rm;
1601   HandleMark hm;
1602   VtableStats::compute();
1603   tty-&gt;print_cr(&quot;vtable statistics:&quot;);
1604   tty-&gt;print_cr(&quot;%6d classes (%d instance, %d array)&quot;, VtableStats::no_klasses, VtableStats::no_instance_klasses, VtableStats::no_array_klasses);
1605   int total = VtableStats::fixed + VtableStats::filler + VtableStats::entries;
1606   tty-&gt;print_cr(&quot;%6d bytes fixed overhead (refs + vtable object header)&quot;, VtableStats::fixed);
1607   tty-&gt;print_cr(&quot;%6d bytes filler overhead&quot;, VtableStats::filler);
1608   tty-&gt;print_cr(&quot;%6d bytes for vtable entries (%d for arrays)&quot;, VtableStats::entries, VtableStats::array_entries);
1609   tty-&gt;print_cr(&quot;%6d bytes total&quot;, total);
1610 }
1611 
1612 int  klassItable::_total_classes;   // Total no. of classes with itables
1613 long klassItable::_total_size;      // Total no. of bytes used for itables
1614 
1615 void klassItable::print_statistics() {
1616  tty-&gt;print_cr(&quot;itable statistics:&quot;);
1617  tty-&gt;print_cr(&quot;%6d classes with itables&quot;, _total_classes);
1618  tty-&gt;print_cr(&quot;%6lu K uses for itables (average by class: %ld bytes)&quot;, _total_size / K, _total_size / _total_classes);
1619 }
1620 
1621 #endif // PRODUCT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constMethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,28 +28,29 @@</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/metadataOnStackMark.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
<span class="udiff-line-added">+ #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/heapInspection.hpp&quot;</span>
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/array.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/cpCache.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;runtime/fieldType.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228,11 +229,11 @@</span>
      build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
  
    symbol_at_put(name_index, name);
    name-&gt;increment_refcount();
    Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(adr, k);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(adr, k);</span>
  
    // The interpreter assumes when the tag is stored, the klass is resolved
    // and the Klass* non-NULL, so we need hardware store ordering here.
    if (k != NULL) {
      release_tag_at_put(class_index, JVM_CONSTANT_Class);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,11 +246,11 @@</span>
  void ConstantPool::klass_at_put(int class_index, Klass* k) {
    assert(k != NULL, &quot;must be valid klass&quot;);
    CPKlassSlot kslot = klass_slot_at(class_index);
    int resolved_klass_index = kslot.resolved_klass_index();
    Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(adr, k);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(adr, k);</span>
  
    // The interpreter assumes when the tag is stored, the klass is resolved
    // and the Klass* non-NULL, so we need hardware store ordering here.
    release_tag_at_put(class_index, JVM_CONSTANT_Class);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -278,13 +279,11 @@</span>
      for (int i = 0; i &lt; rr_len; i++) {
        oop p = rr-&gt;obj_at(i);
        rr-&gt;obj_at_put(i, NULL);
        if (p != NULL &amp;&amp; i &lt; ref_map_len) {
          int index = object_to_cp_index(i);
<span class="udiff-line-modified-removed">-         // Skip the entry if the string hash code is 0 since the string</span>
<span class="udiff-line-removed">-         // is not included in the shared string_table, see StringTable::copy_shared_string.</span>
<span class="udiff-line-removed">-         if (tag_at(index).is_string() &amp;&amp; java_lang_String::hash_code(p) != 0) {</span>
<span class="udiff-line-modified-added">+         if (tag_at(index).is_string()) {</span>
            oop op = StringTable::create_archived_string(p, THREAD);
            // If the String object is not archived (possibly too large),
            // NULL is returned. Also set it in the array, so we won&#39;t
            // have a &#39;bad&#39; reference in the archived resolved_reference
            // array.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,22 +368,33 @@</span>
      resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
  
    // If archiving heap objects is not allowed, clear the resolved references.
    // Otherwise, it is cleared after the resolved references array is cached
    // (see archive_resolved_references()).
<span class="udiff-line-modified-removed">-   if (!HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="udiff-line-modified-added">+   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also</span>
<span class="udiff-line-added">+   // as java objects are not archived in the top layer.</span>
<span class="udiff-line-added">+   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {</span>
      set_resolved_references(NULL);
    }
  
    // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
    // The _on_stack flag is used to prevent ConstantPools from deallocation during
    // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
    // we always set _on_stack to true to avoid having to change _flags during runtime.
    _flags |= (_on_stack | _is_shared);
    int num_klasses = 0;
    for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
<span class="udiff-line-modified-removed">-     assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during dump time&quot;);</span>
<span class="udiff-line-modified-added">+     if (!DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-added">+       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       if (tag_at(index).is_unresolved_klass_in_error() ||</span>
<span class="udiff-line-added">+           tag_at(index).is_method_handle_in_error()    ||</span>
<span class="udiff-line-added">+           tag_at(index).is_method_type_in_error()      ||</span>
<span class="udiff-line-added">+           tag_at(index).is_dynamic_constant_in_error()) {</span>
<span class="udiff-line-added">+         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      if (tag_at(index).is_klass()) {
        // This class was resolved as a side effect of executing Java code
        // during dump time. We need to restore it back to an UnresolvedClass,
        // so that the proper class loading and initialization can happen
        // at runtime.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -512,11 +522,11 @@</span>
    // logging for class+resolve.
    if (log_is_enabled(Debug, class, resolve)){
      trace_class_resolution(this_cp, k);
    }
    Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(adr, k);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(adr, k);</span>
    // The interpreter assumes when the tag is stored, the klass is resolved
    // and the Klass* stored in _resolved_klasses is non-NULL, so we need
    // hardware store ordering here.
    this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);
    return k;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -543,11 +553,12 @@</span>
      oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
      Handle h_prot (thread, protection_domain);
      Handle h_loader (thread, loader);
      Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
  
<span class="udiff-line-modified-removed">-     if (k != NULL) {</span>
<span class="udiff-line-modified-added">+     // Avoid constant pool verification at a safepoint, which takes the Module_lock.</span>
<span class="udiff-line-added">+     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {</span>
        // Make sure that resolving is legal
        EXCEPTION_MARK;
        // return NULL if verification fails
        verify_constant_pool_resolve(this_cp, k, THREAD);
        if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -714,11 +725,11 @@</span>
  char* ConstantPool::string_at_noresolve(int which) {
    return unresolved_string_at(which)-&gt;as_C_string();
  }
  
  BasicType ConstantPool::basic_type_for_signature_at(int which) const {
<span class="udiff-line-modified-removed">-   return FieldType::basic_type(symbol_at(which));</span>
<span class="udiff-line-modified-added">+   return Signature::basic_type(symbol_at(which));</span>
  }
  
  
  void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
    for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -747,10 +758,14 @@</span>
      break;
    case JVM_CONSTANT_MethodType:
      // return the method type signature in the error message
      message = this_cp-&gt;method_type_signature_at(which);
      break;
<span class="udiff-line-added">+   case JVM_CONSTANT_Dynamic:</span>
<span class="udiff-line-added">+     // return the name of the condy in the error message</span>
<span class="udiff-line-added">+     message = this_cp-&gt;uncached_name_ref_at(which);</span>
<span class="udiff-line-added">+     break;</span>
    default:
      ShouldNotReachHere();
    }
  
    return message;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -790,12 +805,13 @@</span>
      // If another thread resolved the reference, this is a race condition. This
      // thread may have had a security manager or something temporary.
      // This doesn&#39;t deterministically get an error.   So why do we save this?
      // We save this because jvmti can add classes to the bootclass path after
      // this error, so it needs to get the same error if the error is first.
<span class="udiff-line-modified-removed">-     jbyte old_tag = Atomic::cmpxchg((jbyte)error_tag,</span>
<span class="udiff-line-modified-removed">-                             (jbyte*)this_cp-&gt;tag_addr_at(which), (jbyte)tag.value());</span>
<span class="udiff-line-modified-added">+     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),</span>
<span class="udiff-line-modified-added">+                                     (jbyte)tag.value(),</span>
<span class="udiff-line-added">+                                     (jbyte)error_tag);</span>
      if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
        // MethodHandles and MethodType doesn&#39;t change to resolved version.
        assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
        // Forget the exception and use the resolved class.
        CLEAR_PENDING_EXCEPTION;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -821,11 +837,11 @@</span>
    constantTag tag = tag_at(which);
    if (tag.is_dynamic_constant() ||
        tag.is_dynamic_constant_in_error()) {
      // have to look at the signature for this one
      Symbol* constant_type = uncached_signature_ref_at(which);
<span class="udiff-line-modified-removed">-     return FieldType::basic_type(constant_type);</span>
<span class="udiff-line-modified-added">+     return Signature::basic_type(constant_type);</span>
    }
    return tag.basic_type();
  }
  
  // Called to resolve constants in the constant pool and return an oop.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -849,11 +865,11 @@</span>
    assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
  
    if (cache_index &gt;= 0) {
      result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
      if (result_oop != NULL) {
<span class="udiff-line-modified-removed">-       if (oopDesc::equals(result_oop, Universe::the_null_sentinel())) {</span>
<span class="udiff-line-modified-added">+       if (result_oop == Universe::the_null_sentinel()) {</span>
          DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
          assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
          result_oop = NULL;
        }
        if (status_return != NULL)  (*status_return) = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -909,43 +925,33 @@</span>
        break;
      }
  
    case JVM_CONSTANT_Dynamic:
      {
<span class="udiff-line-modified-removed">-       Klass* current_klass  = this_cp-&gt;pool_holder();</span>
<span class="udiff-line-modified-removed">-       Symbol* constant_name = this_cp-&gt;uncached_name_ref_at(index);</span>
<span class="udiff-line-removed">-       Symbol* constant_type = this_cp-&gt;uncached_signature_ref_at(index);</span>
<span class="udiff-line-modified-added">+       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.</span>
<span class="udiff-line-modified-added">+       BootstrapInfo bootstrap_specifier(this_cp, index);</span>
  
        // The initial step in resolving an unresolved symbolic reference to a
        // dynamically-computed constant is to resolve the symbolic reference to a
        // method handle which will be the bootstrap method for the dynamically-computed
        // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
        // method fails, then a MethodHandleInError is stored at the corresponding
        // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
        // set a DynamicConstantInError here since any subsequent use of this
        // bootstrap method will encounter the resolution of MethodHandleInError.
<span class="udiff-line-modified-removed">-       oop bsm_info = this_cp-&gt;resolve_bootstrap_specifier_at(index, THREAD);</span>
<span class="udiff-line-modified-removed">-       Exceptions::wrap_dynamic_exception(CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-       assert(bsm_info != NULL, &quot;&quot;);</span>
<span class="udiff-line-modified-removed">-       // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_Dynamic.</span>
<span class="udiff-line-removed">-       Handle bootstrap_specifier = Handle(THREAD, bsm_info);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.</span>
<span class="udiff-line-removed">-       Handle value = SystemDictionary::link_dynamic_constant(current_klass,</span>
<span class="udiff-line-removed">-                                                              index,</span>
<span class="udiff-line-removed">-                                                              bootstrap_specifier,</span>
<span class="udiff-line-removed">-                                                              constant_name,</span>
<span class="udiff-line-removed">-                                                              constant_type,</span>
<span class="udiff-line-removed">-                                                              THREAD);</span>
<span class="udiff-line-removed">-       result_oop = value();</span>
<span class="udiff-line-modified-added">+       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,</span>
<span class="udiff-line-modified-added">+       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()</span>
<span class="udiff-line-modified-added">+       // for the bootstrap_specifier created above.</span>
<span class="udiff-line-modified-added">+       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);</span>
        Exceptions::wrap_dynamic_exception(THREAD);
        if (HAS_PENDING_EXCEPTION) {
          // Resolution failure of the dynamically-computed constant, save_and_throw_exception
          // will check for a LinkageError and store a DynamicConstantInError.
          save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
        }
<span class="udiff-line-modified-removed">-       BasicType type = FieldType::basic_type(constant_type);</span>
<span class="udiff-line-modified-added">+       result_oop = bootstrap_specifier.resolved_value()();</span>
<span class="udiff-line-added">+       BasicType type = Signature::basic_type(bootstrap_specifier.signature());</span>
        if (!is_reference_type(type)) {
          // Make sure the primitive value is properly boxed.
          // This is a JDK responsibility.
          const char* fail = NULL;
          if (result_oop == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -961,10 +967,14 @@</span>
            // but do not save a DynamicInError resolution result.
            // See section 5.4.3 of the VM spec.
            THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
          }
        }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (TraceMethodHandles) {</span>
<span class="udiff-line-added">+         bootstrap_specifier.print_msg_on(tty, &quot;resolve_constant_at_impl&quot;);</span>
<span class="udiff-line-added">+       }</span>
        break;
      }
  
    case JVM_CONSTANT_String:
      assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1000,18 +1010,21 @@</span>
  
        // Check constant pool method consistency
        if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
            ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
          ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-         char buf[400];</span>
<span class="udiff-line-modified-removed">-         jio_snprintf(buf, sizeof(buf),</span>
<span class="udiff-line-modified-removed">-           &quot;Inconsistent constant pool data in classfile for class %s. &quot;</span>
<span class="udiff-line-modified-removed">-           &quot;Method %s%s at index %d is %s and should be %s&quot;,</span>
<span class="udiff-line-modified-removed">-           callee-&gt;name()-&gt;as_C_string(), name-&gt;as_C_string(), signature-&gt;as_C_string(), index,</span>
<span class="udiff-line-modified-removed">-           callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,</span>
<span class="udiff-line-modified-removed">-           callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);</span>
<span class="udiff-line-modified-removed">-         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>
<span class="udiff-line-modified-added">+         stringStream ss;</span>
<span class="udiff-line-modified-added">+         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;</span>
<span class="udiff-line-modified-added">+                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-modified-added">+         signature-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="udiff-line-modified-added">+         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());</span>
<span class="udiff-line-modified-added">+         signature-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="udiff-line-modified-added">+         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,</span>
<span class="udiff-line-modified-added">+                  index,</span>
<span class="udiff-line-added">+                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,</span>
<span class="udiff-line-added">+                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);</span>
<span class="udiff-line-added">+         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
        }
  
        Klass* klass = this_cp-&gt;pool_holder();
        Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
                                                                     callee, name, signature,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1082,16 +1095,16 @@</span>
      if (old_result == NULL) {
        return result_oop;  // was installed
      } else {
        // Return the winning thread&#39;s result.  This can be different than
        // the result here for MethodHandles.
<span class="udiff-line-modified-removed">-       if (oopDesc::equals(old_result, Universe::the_null_sentinel()))</span>
<span class="udiff-line-modified-added">+       if (old_result == Universe::the_null_sentinel())</span>
          old_result = NULL;
        return old_result;
      }
    } else {
<span class="udiff-line-modified-removed">-     assert(!oopDesc::equals(result_oop, Universe::the_null_sentinel()), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);</span>
      return result_oop;
    }
  }
  
  oop ConstantPool::uncached_string_at(int which, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1099,123 +1112,10 @@</span>
    oop str = StringTable::intern(sym, CHECK_(NULL));
    assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
    return str;
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- oop ConstantPool::resolve_bootstrap_specifier_at_impl(const constantPoolHandle&amp; this_cp, int index, TRAPS) {</span>
<span class="udiff-line-removed">-   assert((this_cp-&gt;tag_at(index).is_invoke_dynamic() ||</span>
<span class="udiff-line-removed">-           this_cp-&gt;tag_at(index).is_dynamic_constant()), &quot;Corrupted constant pool&quot;);</span>
<span class="udiff-line-removed">-   Handle bsm;</span>
<span class="udiff-line-removed">-   int argc;</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     // JVM_CONSTANT_InvokeDynamic is an ordered pair of [bootm, name&amp;mtype], plus optional arguments</span>
<span class="udiff-line-removed">-     // JVM_CONSTANT_Dynamic is an ordered pair of [bootm, name&amp;ftype], plus optional arguments</span>
<span class="udiff-line-removed">-     // In both cases, the bootm, being a JVM_CONSTANT_MethodHandle, has its own cache entry.</span>
<span class="udiff-line-removed">-     // It is accompanied by the optional arguments.</span>
<span class="udiff-line-removed">-     int bsm_index = this_cp-&gt;bootstrap_method_ref_index_at(index);</span>
<span class="udiff-line-removed">-     oop bsm_oop = this_cp-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK_NULL);</span>
<span class="udiff-line-removed">-     if (!java_lang_invoke_MethodHandle::is_instance(bsm_oop)) {</span>
<span class="udiff-line-removed">-       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;BSM not an MethodHandle&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Extract the optional static arguments.</span>
<span class="udiff-line-removed">-     argc = this_cp-&gt;bootstrap_argument_count_at(index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // if there are no static arguments, return the bsm by itself:</span>
<span class="udiff-line-removed">-     if (argc == 0 &amp;&amp; UseBootstrapCallInfo &lt; 2)  return bsm_oop;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bsm = Handle(THREAD, bsm_oop);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // We are going to return an ordered pair of {bsm, info}, using a 2-array.</span>
<span class="udiff-line-removed">-   objArrayHandle info;</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     objArrayOop info_oop = oopFactory::new_objArray(SystemDictionary::Object_klass(), 2, CHECK_NULL);</span>
<span class="udiff-line-removed">-     info = objArrayHandle(THREAD, info_oop);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   info-&gt;obj_at_put(0, bsm());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool use_BSCI;</span>
<span class="udiff-line-removed">-   switch (UseBootstrapCallInfo) {</span>
<span class="udiff-line-removed">-   default: use_BSCI = true;  break;  // stress mode</span>
<span class="udiff-line-removed">-   case 0:  use_BSCI = false; break;  // stress mode</span>
<span class="udiff-line-removed">-   case 1:                            // normal mode</span>
<span class="udiff-line-removed">-     // If we were to support an alternative mode of BSM invocation,</span>
<span class="udiff-line-removed">-     // we&#39;d convert to pull mode here if the BSM could be a candidate</span>
<span class="udiff-line-removed">-     // for that alternative mode.  We can&#39;t easily test for things</span>
<span class="udiff-line-removed">-     // like varargs here, but we can get away with approximate testing,</span>
<span class="udiff-line-removed">-     // since the JDK runtime will make up the difference either way.</span>
<span class="udiff-line-removed">-     // For now, exercise the pull-mode path if the BSM is of arity 2,</span>
<span class="udiff-line-removed">-     // or if there is a potential condy loop (see below).</span>
<span class="udiff-line-removed">-     oop mt_oop = java_lang_invoke_MethodHandle::type(bsm());</span>
<span class="udiff-line-removed">-     use_BSCI = (java_lang_invoke_MethodType::ptype_count(mt_oop) == 2);</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Here&#39;s a reason to use BSCI even if it wasn&#39;t requested:</span>
<span class="udiff-line-removed">-   // If a condy uses a condy argument, we want to avoid infinite</span>
<span class="udiff-line-removed">-   // recursion (condy loops) in the C code.  It&#39;s OK in Java,</span>
<span class="udiff-line-removed">-   // because Java has stack overflow checking, so we punt</span>
<span class="udiff-line-removed">-   // potentially cyclic cases from C to Java.</span>
<span class="udiff-line-removed">-   if (!use_BSCI &amp;&amp; this_cp-&gt;tag_at(index).is_dynamic_constant()) {</span>
<span class="udiff-line-removed">-     bool found_unresolved_condy = false;</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; argc; i++) {</span>
<span class="udiff-line-removed">-       int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);</span>
<span class="udiff-line-removed">-       if (this_cp-&gt;tag_at(arg_index).is_dynamic_constant()) {</span>
<span class="udiff-line-removed">-         // potential recursion point condy -&gt; condy</span>
<span class="udiff-line-removed">-         bool found_it = false;</span>
<span class="udiff-line-removed">-         this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK_NULL);</span>
<span class="udiff-line-removed">-         if (!found_it) { found_unresolved_condy = true; break; }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (found_unresolved_condy)</span>
<span class="udiff-line-removed">-       use_BSCI = true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const int SMALL_ARITY = 5;</span>
<span class="udiff-line-removed">-   if (use_BSCI &amp;&amp; argc &lt;= SMALL_ARITY &amp;&amp; UseBootstrapCallInfo &lt;= 2) {</span>
<span class="udiff-line-removed">-     // If there are only a few arguments, and none of them need linking,</span>
<span class="udiff-line-removed">-     // push them, instead of asking the JDK runtime to turn around and</span>
<span class="udiff-line-removed">-     // pull them, saving a JVM/JDK transition in some simple cases.</span>
<span class="udiff-line-removed">-     bool all_resolved = true;</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; argc; i++) {</span>
<span class="udiff-line-removed">-       bool found_it = false;</span>
<span class="udiff-line-removed">-       int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);</span>
<span class="udiff-line-removed">-       this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK_NULL);</span>
<span class="udiff-line-removed">-       if (!found_it) { all_resolved = false; break; }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (all_resolved)</span>
<span class="udiff-line-removed">-       use_BSCI = false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (!use_BSCI) {</span>
<span class="udiff-line-removed">-     // return {bsm, {arg...}}; resolution of arguments is done immediately, before JDK code is called</span>
<span class="udiff-line-removed">-     objArrayOop args_oop = oopFactory::new_objArray(SystemDictionary::Object_klass(), argc, CHECK_NULL);</span>
<span class="udiff-line-removed">-     info-&gt;obj_at_put(1, args_oop);   // may overwrite with args[0] below</span>
<span class="udiff-line-removed">-     objArrayHandle args(THREAD, args_oop);</span>
<span class="udiff-line-removed">-     copy_bootstrap_arguments_at_impl(this_cp, index, 0, argc, args, 0, true, Handle(), CHECK_NULL);</span>
<span class="udiff-line-removed">-     if (argc == 1) {</span>
<span class="udiff-line-removed">-       // try to discard the singleton array</span>
<span class="udiff-line-removed">-       oop arg_oop = args-&gt;obj_at(0);</span>
<span class="udiff-line-removed">-       if (arg_oop != NULL &amp;&amp; !arg_oop-&gt;is_array()) {</span>
<span class="udiff-line-removed">-         // JVM treats arrays and nulls specially in this position,</span>
<span class="udiff-line-removed">-         // but other things are just single arguments</span>
<span class="udiff-line-removed">-         info-&gt;obj_at_put(1, arg_oop);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // return {bsm, {arg_count, pool_index}}; JDK code must pull the arguments as needed</span>
<span class="udiff-line-removed">-     typeArrayOop ints_oop = oopFactory::new_typeArray(T_INT, 2, CHECK_NULL);</span>
<span class="udiff-line-removed">-     ints_oop-&gt;int_at_put(0, argc);</span>
<span class="udiff-line-removed">-     ints_oop-&gt;int_at_put(1, index);</span>
<span class="udiff-line-removed">-     info-&gt;obj_at_put(1, ints_oop);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return info();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
                                                      int start_arg, int end_arg,
                                                      objArrayHandle info, int pos,
                                                      bool must_resolve, Handle if_not_available,
                                                      TRAPS) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1253,11 +1153,11 @@</span>
  }
  
  oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
    // If the string has already been interned, this entry will be non-null
    oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
<span class="udiff-line-modified-removed">-   assert(!oopDesc::equals(str, Universe::the_null_sentinel()), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   assert(str != Universe::the_null_sentinel(), &quot;&quot;);</span>
    if (str != NULL) return str;
    Symbol* sym = this_cp-&gt;unresolved_string_at(which);
    str = StringTable::intern(sym, CHECK_(NULL));
    this_cp-&gt;string_at_put(which, obj_index, str);
    assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1845,21 +1745,21 @@</span>
    }
    return false;
  } // end compare_operand_to()
  
  // Search constant pool search_cp for a bootstrap specifier that matches
<span class="udiff-line-modified-removed">- // this constant pool&#39;s bootstrap specifier at pattern_i index.</span>
<span class="udiff-line-modified-removed">- // Return the index of a matching bootstrap specifier or (-1) if there is no match.</span>
<span class="udiff-line-modified-added">+ // this constant pool&#39;s bootstrap specifier data at pattern_i index.</span>
<span class="udiff-line-modified-added">+ // Return the index of a matching bootstrap attribute record or (-1) if there is no match.</span>
  int ConstantPool::find_matching_operand(int pattern_i,
                      const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
    for (int i = 0; i &lt; search_len; i++) {
      bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
      if (found) {
        return i;
      }
    }
<span class="udiff-line-modified-removed">-   return -1;  // bootstrap specifier not found; return unused index (-1)</span>
<span class="udiff-line-modified-added">+   return -1;  // bootstrap specifier data not found; return unused index (-1)</span>
  } // end find_matching_operand()
  
  
  #ifndef PRODUCT
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2475,25 +2375,10 @@</span>
    if (cache() != NULL) {
      st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
    }
  }
  
<span class="udiff-line-removed">- #if INCLUDE_SERVICES</span>
<span class="udiff-line-removed">- // Size Statistics</span>
<span class="udiff-line-removed">- void ConstantPool::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="udiff-line-removed">-   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_bytes          = sz-&gt;count(this));</span>
<span class="udiff-line-removed">-   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_tags_bytes     = sz-&gt;count_array(tags()));</span>
<span class="udiff-line-removed">-   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_cache_bytes    = sz-&gt;count(cache()));</span>
<span class="udiff-line-removed">-   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_operands_bytes = sz-&gt;count_array(operands()));</span>
<span class="udiff-line-removed">-   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_refmap_bytes   = sz-&gt;count_array(reference_map()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   sz-&gt;_ro_bytes += sz-&gt;_cp_operands_bytes + sz-&gt;_cp_tags_bytes +</span>
<span class="udiff-line-removed">-                    sz-&gt;_cp_refmap_bytes;</span>
<span class="udiff-line-removed">-   sz-&gt;_rw_bytes += sz-&gt;_cp_bytes + sz-&gt;_cp_cache_bytes;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_SERVICES</span>
<span class="udiff-line-removed">- </span>
  // Verification
  
  void ConstantPool::verify_on(outputStream* st) {
    guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
    for (int i = 0; i&lt; length();  i++) {
</pre>
<center><a href="constMethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
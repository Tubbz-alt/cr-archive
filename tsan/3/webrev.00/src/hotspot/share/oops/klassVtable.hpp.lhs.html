<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/klassVtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_KLASSVTABLE_HPP
 26 #define SHARE_OOPS_KLASSVTABLE_HPP
 27 
 28 #include &quot;oops/oopsHierarchy.hpp&quot;
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
 32 // A klassVtable abstracts the variable-length vtable that is embedded in InstanceKlass
 33 // and ArrayKlass.  klassVtable objects are used just as convenient transient accessors to the vtable,
 34 // not to actually hold the vtable data.
 35 // Note: the klassVtable should not be accessed before the class has been verified
 36 // (until that point, the vtable is uninitialized).
 37 
 38 // Currently a klassVtable contains a direct reference to the vtable data, and is therefore
 39 // not preserved across GCs.
 40 
 41 class vtableEntry;
 42 
 43 class klassVtable {
 44   Klass*       _klass;            // my klass
 45   int          _tableOffset;      // offset of start of vtable data within klass
 46   int          _length;           // length of vtable (number of entries)
 47 #ifndef PRODUCT
 48   int          _verify_count;     // to make verify faster
 49 #endif
 50 
<a name="1" id="anc1"></a><span class="line-removed"> 51   // Ordering important, so greater_than (&gt;) can be used as an merge operator.</span>
<span class="line-removed"> 52   enum AccessType {</span>
<span class="line-removed"> 53     acc_private         = 0,</span>
<span class="line-removed"> 54     acc_package_private = 1,</span>
<span class="line-removed"> 55     acc_publicprotected = 2</span>
<span class="line-removed"> 56   };</span>
<span class="line-removed"> 57 </span>
 58  public:
 59   klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
 60     _tableOffset = (address)base - (address)klass; _length = length;
 61   }
 62 
 63   // accessors
 64   vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
 65   Klass* klass() const            { return _klass;  }
 66   int length() const              { return _length; }
 67   inline Method* method_at(int i) const;
 68   inline Method* unchecked_method_at(int i) const;
<a name="2" id="anc2"></a><span class="line-removed"> 69   inline Method** adr_method_at(int i) const;</span>
 70 
 71   // searching; all methods return -1 if not found
<a name="3" id="anc3"></a><span class="line-removed"> 72   int index_of(Method* m) const                         { return index_of(m, _length); }</span>
 73   int index_of_miranda(Symbol* name, Symbol* signature);
 74 
 75   void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
 76 
<a name="4" id="anc4"></a><span class="line-removed"> 77   // CDS/RedefineClasses support - clear vtables so they can be reinitialized</span>
<span class="line-removed"> 78   // at dump time.  Clearing gives us an easy way to tell if the vtable has</span>
<span class="line-removed"> 79   // already been reinitialized at dump time (see dump.cpp).  Vtables can</span>
<span class="line-removed"> 80   // be initialized at run time by RedefineClasses so dumping the right order</span>
<span class="line-removed"> 81   // is necessary.</span>
<span class="line-removed"> 82   void clear_vtable();</span>
<span class="line-removed"> 83   bool is_initialized();</span>
<span class="line-removed"> 84 </span>
 85   // computes vtable length (in words) and the number of miranda methods
 86   static void compute_vtable_size_and_num_mirandas(int* vtable_length,
 87                                                    int* num_new_mirandas,
 88                                                    GrowableArray&lt;Method*&gt;* all_mirandas,
 89                                                    const Klass* super,
 90                                                    Array&lt;Method*&gt;* methods,
 91                                                    AccessFlags class_flags,
 92                                                    u2 major_version,
 93                                                    Handle classloader,
 94                                                    Symbol* classname,
 95                                                    Array&lt;InstanceKlass*&gt;* local_interfaces,
 96                                                    TRAPS);
 97 
 98 #if INCLUDE_JVMTI
 99   // RedefineClasses() API support:
100   // If any entry of this vtable points to any of old_methods,
101   // replace it with the corresponding new_method.
102   // trace_name_printed is set to true if the current call has
103   // printed the klass name so that other routines in the adjust_*
104   // group don&#39;t print the klass name.
105   bool adjust_default_method(int vtable_index, Method* old_method, Method* new_method);
106   void adjust_method_entries(bool* trace_name_printed);
107   bool check_no_old_or_obsolete_entries();
108   void dump_vtable();
109 #endif // INCLUDE_JVMTI
110 
111   // Debugging code
112   void print()                                              PRODUCT_RETURN;
113   void verify(outputStream* st, bool force = false);
114   static void print_statistics()                            PRODUCT_RETURN;
115 
116  protected:
117   friend class vtableEntry;
118 
119  public:
120   // Transitive overridng rules for class files &lt; JDK1_7 use the older JVMS rules.
121   // Overriding is determined as we create the vtable, so we use the class file version
122   // of the class whose vtable we are calculating.
123   enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
124 
125  private:
126   void copy_vtable_to(vtableEntry* start);
127   int  initialize_from_super(Klass* super);
<a name="5" id="anc5"></a><span class="line-removed">128   int  index_of(Method* m, int len) const; // same as index_of, but search only up to len</span>
129   void put_method_at(Method* m, int index);
130   static bool needs_new_vtable_entry(const methodHandle&amp; m,
131                                      const Klass* super,
132                                      Handle classloader,
133                                      Symbol* classname,
134                                      AccessFlags access_flags,
135                                      u2 major_version,
136                                      TRAPS);
137 
138   bool update_inherited_vtable(InstanceKlass* klass, const methodHandle&amp; target_method, int super_vtable_len, int default_index, bool checkconstraints, TRAPS);
139  InstanceKlass* find_transitive_override(InstanceKlass* initialsuper, const methodHandle&amp; target_method, int vtable_index,
140                                          Handle target_loader, Symbol* target_classname, Thread* THREAD);
141 
142   // support for miranda methods
143   bool is_miranda_entry_at(int i);
144   int fill_in_mirandas(int initialized, TRAPS);
145   static bool is_miranda(Method* m, Array&lt;Method*&gt;* class_methods,
146                          Array&lt;Method*&gt;* default_methods, const Klass* super,
147                          bool is_interface);
148   static void add_new_mirandas_to_lists(
149       GrowableArray&lt;Method*&gt;* new_mirandas,
150       GrowableArray&lt;Method*&gt;* all_mirandas,
151       Array&lt;Method*&gt;* current_interface_methods,
152       Array&lt;Method*&gt;* class_methods,
153       Array&lt;Method*&gt;* default_methods,
154       const Klass* super,
155       bool is_interface);
156   static void get_mirandas(
157       GrowableArray&lt;Method*&gt;* new_mirandas,
158       GrowableArray&lt;Method*&gt;* all_mirandas,
159       const Klass* super,
160       Array&lt;Method*&gt;* class_methods,
161       Array&lt;Method*&gt;* default_methods,
162       Array&lt;InstanceKlass*&gt;* local_interfaces,
163       bool is_interface);
164   void verify_against(outputStream* st, klassVtable* vt, int index);
165   inline InstanceKlass* ik() const;
166   // When loading a class from CDS archive at run time, and no class redefintion
167   // has happened, it is expected that the class&#39;s itable/vtables are
168   // laid out exactly the same way as they had been during dump time.
169   // Therefore, in klassVtable::initialize_[iv]table, we do not layout the
170   // tables again. Instead, we only rerun the process to create/check
171   // the class loader constraints. In non-product builds, we add asserts to
172   // guarantee that the table&#39;s layout would be the same as at dump time.
173   //
174   // If JVMTI redefines any class, the read-only shared memory are remapped
175   // as read-write. A shared class&#39; vtable/itable are re-initialized and
176   // might have different layout due to class redefinition of the shared class
177   // or its super types.
178   bool is_preinitialized_vtable();
179 };
180 
181 
182 // private helper class for klassVtable
183 // description of entry points:
184 //    destination is interpreted:
185 //      from_compiled_code_entry_point -&gt; c2iadapter
186 //      from_interpreter_entry_point   -&gt; interpreter entry point
187 //    destination is compiled:
188 //      from_compiled_code_entry_point -&gt; nmethod entry point
189 //      from_interpreter_entry_point   -&gt; i2cadapter
190 class vtableEntry {
191   friend class VMStructs;
192   friend class JVMCIVMStructs;
193 
194  public:
195   // size in words
196   static int size()          { return sizeof(vtableEntry) / wordSize; }
197   static int size_in_bytes() { return sizeof(vtableEntry); }
198 
199   static int method_offset_in_bytes() { return offset_of(vtableEntry, _method); }
200   Method* method() const    { return _method; }
201   Method** method_addr()    { return &amp;_method; }
202 
203  private:
204   Method* _method;
205   void set(Method* method)  { assert(method != NULL, &quot;use clear&quot;); _method = method; }
206   void clear()                { _method = NULL; }
207   void print()                                        PRODUCT_RETURN;
208   void verify(klassVtable* vt, outputStream* st);
209 
210   friend class klassVtable;
211 };
212 
213 
214 inline Method* klassVtable::method_at(int i) const {
215   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
216   assert(table()[i].method() != NULL, &quot;should not be null&quot;);
217   assert(((Metadata*)table()[i].method())-&gt;is_method(), &quot;should be method&quot;);
218   return table()[i].method();
219 }
220 
221 inline Method* klassVtable::unchecked_method_at(int i) const {
222   assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
223   return table()[i].method();
224 }
225 
<a name="6" id="anc6"></a><span class="line-removed">226 inline Method** klassVtable::adr_method_at(int i) const {</span>
<span class="line-removed">227   // Allow one past the last entry to be referenced; useful for loop bounds.</span>
<span class="line-removed">228   assert(i &gt;= 0 &amp;&amp; i &lt;= _length, &quot;index out of bounds&quot;);</span>
<span class="line-removed">229   return (Method**)(address(table() + i) + vtableEntry::method_offset_in_bytes());</span>
<span class="line-removed">230 }</span>
<span class="line-removed">231 </span>
232 // --------------------------------------------------------------------------------
233 class klassItable;
234 class itableMethodEntry;
235 
236 class itableOffsetEntry {
237  private:
238   InstanceKlass* _interface;
239   int      _offset;
240  public:
241   InstanceKlass* interface_klass() const { return _interface; }
242   InstanceKlass**interface_klass_addr()  { return &amp;_interface; }
243   int      offset() const          { return _offset; }
244 
245   static itableMethodEntry* method_entry(Klass* k, int offset) { return (itableMethodEntry*)(((address)k) + offset); }
246   itableMethodEntry* first_method_entry(Klass* k)              { return method_entry(k, _offset); }
247 
248   void initialize(InstanceKlass* interf, int offset) { _interface = interf; _offset = offset; }
249 
250   // Static size and offset accessors
251   static int size()                       { return sizeof(itableOffsetEntry) / wordSize; }    // size in words
252   static int interface_offset_in_bytes()  { return offset_of(itableOffsetEntry, _interface); }
253   static int offset_offset_in_bytes()     { return offset_of(itableOffsetEntry, _offset); }
254 
255   friend class klassItable;
256 };
257 
258 
259 class itableMethodEntry {
260  private:
261   Method* _method;
262 
263  public:
264   Method* method() const { return _method; }
265   Method**method_addr() { return &amp;_method; }
266 
267   void clear()             { _method = NULL; }
268 
269   void initialize(Method* method);
270 
271   // Static size and offset accessors
272   static int size()                         { return sizeof(itableMethodEntry) / wordSize; }  // size in words
273   static int method_offset_in_bytes()       { return offset_of(itableMethodEntry, _method); }
274 
275   friend class klassItable;
276 };
277 
278 //
279 // Format of an itable
280 //
281 //    ---- offset table ---
282 //    Klass* of interface 1             \
283 //    offset to vtable from start of oop  / offset table entry
284 //    ...
285 //    Klass* of interface n             \
286 //    offset to vtable from start of oop  / offset table entry
287 //    --- vtable for interface 1 ---
288 //    Method*                             \
289 //    compiler entry point                / method table entry
290 //    ...
291 //    Method*                             \
292 //    compiler entry point                / method table entry
293 //    -- vtable for interface 2 ---
294 //    ...
295 //
296 class klassItable {
297  private:
298   InstanceKlass*       _klass;             // my klass
299   int                  _table_offset;      // offset of start of itable data within klass (in words)
300   int                  _size_offset_table; // size of offset table (in itableOffset entries)
301   int                  _size_method_table; // size of methodtable (in itableMethodEntry entries)
302 
303   void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h, bool checkconstraints, TRAPS);
304  public:
305   klassItable(InstanceKlass* klass);
306 
307   itableOffsetEntry* offset_entry(int i) { assert(0 &lt;= i &amp;&amp; i &lt;= _size_offset_table, &quot;index out of bounds&quot;);
308                                            return &amp;((itableOffsetEntry*)vtable_start())[i]; }
309 
310   itableMethodEntry* method_entry(int i) { assert(0 &lt;= i &amp;&amp; i &lt;= _size_method_table, &quot;index out of bounds&quot;);
311                                            return &amp;((itableMethodEntry*)method_start())[i]; }
312 
313   int size_offset_table()                { return _size_offset_table; }
314 
315   // Initialization
316   void initialize_itable(bool checkconstraints, TRAPS);
317 
318 #if INCLUDE_JVMTI
319   // RedefineClasses() API support:
320   // if any entry of this itable points to any of old_methods,
321   // replace it with the corresponding new_method.
322   // trace_name_printed is set to true if the current call has
323   // printed the klass name so that other routines in the adjust_*
324   // group don&#39;t print the klass name.
325   void adjust_method_entries(bool* trace_name_printed);
326   bool check_no_old_or_obsolete_entries();
327   void dump_itable();
328 #endif // INCLUDE_JVMTI
329 
330   // Setup of itable
331   static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
332   static int method_count_for_interface(InstanceKlass* klass);
333   static int compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces);
334   static void setup_itable_offset_table(InstanceKlass* klass);
335 
<a name="7" id="anc7"></a><span class="line-removed">336   // Resolving of method to index</span>
<span class="line-removed">337   static Method* method_for_itable_index(InstanceKlass* klass, int itable_index);</span>
<span class="line-removed">338 </span>
339   // Debugging/Statistics
340   static void print_statistics() PRODUCT_RETURN;
341  private:
342   intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
343   intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }
344 
345   // Helper methods
346   static int  calc_itable_size(int num_interfaces, int num_methods) { return (num_interfaces * itableOffsetEntry::size()) + (num_methods * itableMethodEntry::size()); }
347 
348   // Statistics
349   NOT_PRODUCT(static int  _total_classes;)   // Total no. of classes with itables
350   NOT_PRODUCT(static long _total_size;)      // Total no. of bytes used for itables
351 
352   static void update_stats(int size) PRODUCT_RETURN NOT_PRODUCT({ _total_classes++; _total_size += size; })
353 };
354 
355 #endif // SHARE_OOPS_KLASSVTABLE_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/constMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CONSTMETHOD_HPP
 26 #define SHARE_OOPS_CONSTMETHOD_HPP
 27 
 28 #include &quot;oops/oop.hpp&quot;
<a name="2" id="anc2"></a>
 29 #include &quot;utilities/align.hpp&quot;
 30 
 31 // An ConstMethod represents portions of a Java method which are not written to after
 32 // the classfile is parsed(*see below).  This part of the method can be shared across
 33 // processes in a read-only section with Class Data Sharing (CDS).  It&#39;s important
 34 // that this class doesn&#39;t have virtual functions because the vptr cannot be shared
 35 // with CDS.
 36 //
 37 // Note that most applications load thousands of methods, so keeping the size of this
 38 // structure small has a big impact on footprint.
 39 
 40 // The actual bytecodes are inlined after the end of the ConstMethod struct.
 41 //
 42 // The line number table is compressed and inlined following the byte codes. It is
 43 // found as the first byte following the byte codes.  Note that accessing the line
 44 // number and local variable tables is not performance critical at all.
 45 //
 46 // The checked exceptions table and the local variable table are inlined after the
 47 // line number table, and indexed from the end of the method. We do not compress the
 48 // checked exceptions table since the average length is less than 2, and it is used
 49 // by reflection so access should be fast.  We do not bother to compress the local
 50 // variable table either since it is mostly absent.
 51 //
 52 //
 53 //  ConstMethod embedded field layout (after declared fields):
 54 //    [EMBEDDED byte codes]
 55 //    [EMBEDDED compressed linenumber table]
 56 //     (see class CompressedLineNumberReadStream)
 57 //     (note that length is unknown until decompressed)
 58 //     (access flags bit tells whether table is present)
 59 //     (indexed from start of ConstMethod)
 60 //     (elements not necessarily sorted!)
 61 //    [EMBEDDED localvariable table elements + length (length last)]
 62 //     (length is u2, elements are 6-tuples of u2)
 63 //     (see class LocalVariableTableElement)
 64 //     (access flags bit tells whether table is present)
 65 //     (indexed from end of ConstMethod*)
 66 //    [EMBEDDED exception table + length (length last)]
 67 //     (length is u2, elements are 4-tuples of u2)
 68 //     (see class ExceptionTableElement)
 69 //     (access flags bit tells whether table is present)
 70 //     (indexed from end of ConstMethod*)
 71 //    [EMBEDDED checked exceptions elements + length (length last)]
 72 //     (length is u2, elements are u2)
 73 //     (see class CheckedExceptionElement)
 74 //     (access flags bit tells whether table is present)
 75 //     (indexed from end of ConstMethod*)
 76 //    [EMBEDDED method parameters elements + length (length last)]
 77 //     (length is u2, elements are u2, u4 structures)
 78 //     (see class MethodParametersElement)
 79 //     (access flags bit tells whether table is present)
 80 //     (indexed from end of ConstMethod*)
 81 //    [EMBEDDED generic signature index (u2)]
 82 //     (indexed from end of constMethodOop)
 83 //    [EMBEDDED annotations arrays - method, parameter, type, default]
 84 //      pointer to Array&lt;u1&gt; if annotation is present
 85 //
 86 // IMPORTANT: If anything gets added here, there need to be changes to
 87 // ensure that ServicabilityAgent doesn&#39;t get broken as a result!
 88 
 89 
 90 // Utility class describing elements in checked exceptions table inlined in Method*.
 91 class CheckedExceptionElement {
 92  public:
 93   u2 class_cp_index;
 94 };
 95 
 96 
 97 // Utility class describing elements in local variable table inlined in Method*.
 98 class LocalVariableTableElement {
 99  public:
100   u2 start_bci;
101   u2 length;
102   u2 name_cp_index;
103   u2 descriptor_cp_index;
104   u2 signature_cp_index;
105   u2 slot;
106 };
107 
108 // Utility class describing elements in exception table
109 class ExceptionTableElement {
110  public:
111   u2 start_pc;
112   u2 end_pc;
113   u2 handler_pc;
114   u2 catch_type_index;
115 };
116 
117 // Utility class describing elements in method parameters
118 class MethodParametersElement {
119  public:
120   u2 name_cp_index;
121   u2 flags;
122 };
123 
<a name="3" id="anc3"></a><span class="line-removed">124 class KlassSizeStats;</span>
125 class AdapterHandlerEntry;
126 
127 // Class to collect the sizes of ConstMethod inline tables
128 #define INLINE_TABLES_DO(do_element)            \
129   do_element(localvariable_table_length)        \
130   do_element(compressed_linenumber_size)        \
131   do_element(exception_table_length)            \
132   do_element(checked_exceptions_length)         \
133   do_element(method_parameters_length)          \
134   do_element(generic_signature_index)           \
135   do_element(method_annotations_length)         \
136   do_element(parameter_annotations_length)      \
137   do_element(type_annotations_length)           \
138   do_element(default_annotations_length)
139 
140 #define INLINE_TABLE_DECLARE(sym)    int _##sym;
141 #define INLINE_TABLE_PARAM(sym)      int sym,
142 #define INLINE_TABLE_INIT(sym)       _##sym(sym),
143 #define INLINE_TABLE_NULL(sym)       _##sym(0),
144 #define INLINE_TABLE_ACCESSOR(sym)   int sym() const { return _##sym; }
145 
146 class InlineTableSizes : StackObj {
147   // declarations
148   INLINE_TABLES_DO(INLINE_TABLE_DECLARE)
149   int _end;
150  public:
151   InlineTableSizes(
152       INLINE_TABLES_DO(INLINE_TABLE_PARAM)
153       int end) :
154       INLINE_TABLES_DO(INLINE_TABLE_INIT)
155       _end(end) {}
156 
157   // Default constructor for no inlined tables
158   InlineTableSizes() :
159       INLINE_TABLES_DO(INLINE_TABLE_NULL)
160       _end(0) {}
161 
162   // Accessors
163   INLINE_TABLES_DO(INLINE_TABLE_ACCESSOR)
164 };
165 #undef INLINE_TABLE_ACCESSOR
166 #undef INLINE_TABLE_NULL
167 #undef INLINE_TABLE_INIT
168 #undef INLINE_TABLE_PARAM
169 #undef INLINE_TABLE_DECLARE
170 
171 class ConstMethod : public MetaspaceObj {
172   friend class VMStructs;
173   friend class JVMCIVMStructs;
174 
175 public:
176   typedef enum { NORMAL, OVERPASS } MethodType;
177 
178 private:
179   enum {
180     _has_linenumber_table = 0x0001,
181     _has_checked_exceptions = 0x0002,
182     _has_localvariable_table = 0x0004,
183     _has_exception_table = 0x0008,
184     _has_generic_signature = 0x0010,
185     _has_method_parameters = 0x0020,
186     _is_overpass = 0x0040,
187     _has_method_annotations = 0x0080,
188     _has_parameter_annotations = 0x0100,
189     _has_type_annotations = 0x0200,
190     _has_default_annotations = 0x0400
191   };
192 
193   // Bit vector of signature
194   // Callers interpret 0=not initialized yet and
195   // -1=too many args to fix, must parse the slow way.
196   // The real initial value is special to account for nonatomicity of 64 bit
197   // loads and stores.  This value may updated and read without a lock by
198   // multiple threads, so is volatile.
199   volatile uint64_t _fingerprint;
200 
201   // If you add a new field that points to any metaspace object, you
202   // must add this field to ConstMethod::metaspace_pointers_do().
203 
204   ConstantPool*     _constants;                  // Constant pool
205 
206   // Raw stackmap data for the method
207   Array&lt;u1&gt;*        _stackmap_data;
208 
209   // Adapter blob (i2c/c2i) for this Method*. Set once when method is linked.
210   union {
211     AdapterHandlerEntry* _adapter;
212     AdapterHandlerEntry** _adapter_trampoline; // see comments around Method::link_method()
213   };
214 
215   int               _constMethod_size;
216   u2                _flags;
217   u1                _result_type;                 // BasicType of result
218 
219   // Size of Java bytecodes allocated immediately after Method*.
220   u2                _code_size;
221   u2                _name_index;                 // Method name (index in constant pool)
222   u2                _signature_index;            // Method signature (index in constant pool)
223   u2                _method_idnum;               // unique identification number for the method within the class
224                                                  // initially corresponds to the index into the methods array.
225                                                  // but this may change with redefinition
226   u2                _max_stack;                  // Maximum number of entries on the expression stack
227   u2                _max_locals;                 // Number of local variables used by this method
228   u2                _size_of_parameters;         // size of the parameter block (receiver + arguments) in words
229   u2                _orig_method_idnum;          // Original unique identification number for the method
230 
231   // Constructor
232   ConstMethod(int byte_code_size,
233               InlineTableSizes* sizes,
234               MethodType is_overpass,
235               int size);
236 public:
237 
238   static ConstMethod* allocate(ClassLoaderData* loader_data,
239                                int byte_code_size,
240                                InlineTableSizes* sizes,
241                                MethodType mt,
242                                TRAPS);
243 
244   // Inlined tables
245   void set_inlined_tables_length(InlineTableSizes* sizes);
246 
247   bool has_generic_signature() const
248     { return (_flags &amp; _has_generic_signature) != 0; }
249 
250   bool has_linenumber_table() const
251     { return (_flags &amp; _has_linenumber_table) != 0; }
252 
253   bool has_checked_exceptions() const
254     { return (_flags &amp; _has_checked_exceptions) != 0; }
255 
256   bool has_localvariable_table() const
257     { return (_flags &amp; _has_localvariable_table) != 0; }
258 
259   bool has_exception_handler() const
260     { return (_flags &amp; _has_exception_table) != 0; }
261 
262   bool has_method_parameters() const
263     { return (_flags &amp; _has_method_parameters) != 0; }
264 
265   MethodType method_type() const {
266     return ((_flags &amp; _is_overpass) == 0) ? NORMAL : OVERPASS;
267   }
268 
269   void set_method_type(MethodType mt) {
270     if (mt == NORMAL) {
271       _flags &amp;= ~(_is_overpass);
272     } else {
273       _flags |= _is_overpass;
274     }
275   }
276 
277   // constant pool
278   ConstantPool* constants() const        { return _constants; }
279   void set_constants(ConstantPool* c)    { _constants = c; }
280 
281   Method* method() const;
282 
283   // stackmap table data
284   Array&lt;u1&gt;* stackmap_data() const { return _stackmap_data; }
285   void set_stackmap_data(Array&lt;u1&gt;* sd) { _stackmap_data = sd; }
286   void copy_stackmap_data(ClassLoaderData* loader_data, u1* sd, int length, TRAPS);
287   bool has_stackmap_table() const { return _stackmap_data != NULL; }
288 
289   // adapter
290   void set_adapter_entry(AdapterHandlerEntry* adapter) {
<a name="4" id="anc4"></a><span class="line-modified">291     assert(!is_shared(), &quot;shared methods have fixed adapter_trampoline&quot;);</span>

292     _adapter = adapter;
293   }
294   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
<a name="5" id="anc5"></a><span class="line-modified">295     assert(DumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-modified">296     assert(*trampoline == NULL, &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>



297     _adapter_trampoline = trampoline;
298   }
299   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
300     assert(is_shared(), &quot;must be&quot;);
301     *_adapter_trampoline = adapter;
302     assert(this-&gt;adapter() == adapter, &quot;must be&quot;);
303   }
304   AdapterHandlerEntry* adapter() {
305     if (is_shared()) {
306       return *_adapter_trampoline;
307     } else {
308       return _adapter;
309     }
310   }
311 
312   void init_fingerprint() {
313     const uint64_t initval = UCONST64(0x8000000000000000);
314     _fingerprint = initval;
315   }
316 
317   uint64_t fingerprint() const                   {
318     // Since reads aren&#39;t atomic for 64 bits, if any of the high or low order
319     // word is the initial value, return 0.  See init_fingerprint for initval.
320     uint high_fp = (uint)(_fingerprint &gt;&gt; 32);
321     if ((int) _fingerprint == 0 || high_fp == 0x80000000) {
322       return 0L;
323     } else {
324       return _fingerprint;
325     }
326   }
327 
328   uint64_t set_fingerprint(uint64_t new_fingerprint) {
329 #ifdef ASSERT
330     // Assert only valid if complete/valid 64 bit _fingerprint value is read.
331     uint64_t oldfp = fingerprint();
332 #endif // ASSERT
333     _fingerprint = new_fingerprint;
334     assert(oldfp == 0L || new_fingerprint == oldfp,
335            &quot;fingerprint cannot change&quot;);
336     assert(((new_fingerprint &gt;&gt; 32) != 0x80000000) &amp;&amp; (int)new_fingerprint !=0,
337            &quot;fingerprint should call init to set initial value&quot;);
338     return new_fingerprint;
339   }
340 
341   // name
342   int name_index() const                         { return _name_index; }
343   void set_name_index(int index)                 { _name_index = index; }
344 
345   // signature
346   int signature_index() const                    { return _signature_index; }
347   void set_signature_index(int index)            { _signature_index = index; }
348 
349   // generics support
350   int generic_signature_index() const            {
351     if (has_generic_signature()) {
352       return *generic_signature_index_addr();
353     } else {
354       return 0;
355     }
356   }
357   void set_generic_signature_index(u2 index)    {
358     assert(has_generic_signature(), &quot;&quot;);
359     u2* addr = generic_signature_index_addr();
360     *addr = index;
361   }
362 
363   // Sizing
364   static int header_size() {
365     return align_up((int)sizeof(ConstMethod), wordSize) / wordSize;
366   }
367 
368   // Size needed
369   static int size(int code_size, InlineTableSizes* sizes);
370 
371   int size() const                    { return _constMethod_size;}
372   void set_constMethod_size(int size)     { _constMethod_size = size; }
373 
374   // ConstMethods should be stored in the read-only region of CDS archive.
375   static bool is_read_only_by_default() { return true; }
376 
<a name="6" id="anc6"></a><span class="line-removed">377 #if INCLUDE_SERVICES</span>
<span class="line-removed">378   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">379 #endif</span>
<span class="line-removed">380 </span>
381   // code size
382   int code_size() const                          { return _code_size; }
383   void set_code_size(int size) {
384     assert(max_method_code_size &lt; (1 &lt;&lt; 16),
385            &quot;u2 is too small to hold method code size in general&quot;);
386     assert(0 &lt;= size &amp;&amp; size &lt;= max_method_code_size, &quot;invalid code size&quot;);
387     _code_size = size;
388   }
389 
390   // linenumber table - note that length is unknown until decompression,
391   // see class CompressedLineNumberReadStream.
392   u_char* compressed_linenumber_table() const;         // not preserved by gc
393   u2* generic_signature_index_addr() const;
394   u2* checked_exceptions_length_addr() const;
395   u2* localvariable_table_length_addr() const;
396   u2* exception_table_length_addr() const;
397   u2* method_parameters_length_addr() const;
398 
399   // checked exceptions
400   int checked_exceptions_length() const;
401   CheckedExceptionElement* checked_exceptions_start() const;
402 
403   // localvariable table
404   int localvariable_table_length() const;
405   LocalVariableTableElement* localvariable_table_start() const;
406 
407   // exception table
408   int exception_table_length() const;
409   ExceptionTableElement* exception_table_start() const;
410 
411   // method parameters table
412 
413   // This returns -1 if no parameters are present, a non-negative
414   // value otherwise.  Note: sometimes, there are 0-length parameters
415   // attributes that must be reported up to the reflection API all the
416   // same.
417   int method_parameters_length() const;
418   MethodParametersElement* method_parameters_start() const;
419 
420   // method annotations
421   bool has_method_annotations() const
422     { return (_flags &amp; _has_method_annotations) != 0; }
423 
424   bool has_parameter_annotations() const
425     { return (_flags &amp; _has_parameter_annotations) != 0; }
426 
427   bool has_type_annotations() const
428     { return (_flags &amp; _has_type_annotations) != 0; }
429 
430   bool has_default_annotations() const
431     { return (_flags &amp; _has_default_annotations) != 0; }
432 
433 
434   AnnotationArray** method_annotations_addr() const;
435   AnnotationArray* method_annotations() const  {
436     return has_method_annotations() ? *(method_annotations_addr()) : NULL;
437   }
438   void set_method_annotations(AnnotationArray* anno) {
439     *(method_annotations_addr()) = anno;
440   }
441 
442   AnnotationArray** parameter_annotations_addr() const;
443   AnnotationArray* parameter_annotations() const {
444     return has_parameter_annotations() ? *(parameter_annotations_addr()) : NULL;
445   }
446   void set_parameter_annotations(AnnotationArray* anno) {
447     *(parameter_annotations_addr()) = anno;
448   }
449 
450   AnnotationArray** type_annotations_addr() const;
451   AnnotationArray* type_annotations() const {
452     return has_type_annotations() ? *(type_annotations_addr()) : NULL;
453   }
454   void set_type_annotations(AnnotationArray* anno) {
455     *(type_annotations_addr()) = anno;
456   }
457 
458   AnnotationArray** default_annotations_addr() const;
459   AnnotationArray* default_annotations() const {
460     return has_default_annotations() ? *(default_annotations_addr()) : NULL;
461   }
462   void set_default_annotations(AnnotationArray* anno) {
463     *(default_annotations_addr()) = anno;
464   }
465 
466   int method_annotations_length() const {
467     return has_method_annotations() ? method_annotations()-&gt;length() : 0;
468   }
469   int parameter_annotations_length() const {
470     return has_parameter_annotations() ? parameter_annotations()-&gt;length() : 0;
471   }
472   int type_annotations_length() const {
473     return has_type_annotations() ? type_annotations()-&gt;length() : 0;
474   }
475   int default_annotations_length() const {
476     return has_default_annotations() ? default_annotations()-&gt;length() : 0;
477   }
478 
479   // Copy annotations from other ConstMethod
480   void copy_annotations_from(ClassLoaderData* loader_data, ConstMethod* cm, TRAPS);
481 
482   // byte codes
483   void    set_code(address code) {
484     if (code_size() &gt; 0) {
485       memcpy(code_base(), code, code_size());
486     }
487   }
488   address code_base() const            { return (address) (this+1); }
489   address code_end() const             { return code_base() + code_size(); }
490   bool    contains(address bcp) const  { return code_base() &lt;= bcp
491                                                      &amp;&amp; bcp &lt; code_end(); }
492   // Offset to bytecodes
493   static ByteSize codes_offset()
494                             { return in_ByteSize(sizeof(ConstMethod)); }
495 
496   static ByteSize constants_offset()
497                             { return byte_offset_of(ConstMethod, _constants); }
498 
499   static ByteSize max_stack_offset()
500                             { return byte_offset_of(ConstMethod, _max_stack); }
501   static ByteSize size_of_locals_offset()
502                             { return byte_offset_of(ConstMethod, _max_locals); }
503   static ByteSize size_of_parameters_offset()
504                             { return byte_offset_of(ConstMethod, _size_of_parameters); }
505 
506   static ByteSize result_type_offset()
507                             { return byte_offset_of(ConstMethod, _result_type); }
508 
509   // Unique id for the method
510   static const u2 MAX_IDNUM;
511   static const u2 UNSET_IDNUM;
512   u2 method_idnum() const                        { return _method_idnum; }
513   void set_method_idnum(u2 idnum)                { _method_idnum = idnum; }
514 
515   u2 orig_method_idnum() const                   { return _orig_method_idnum; }
516   void set_orig_method_idnum(u2 idnum)           { _orig_method_idnum = idnum; }
517 
518   // max stack
519   int  max_stack() const                         { return _max_stack; }
520   void set_max_stack(int size)                   { _max_stack = size; }
521 
522   // max locals
523   int  max_locals() const                        { return _max_locals; }
524   void set_max_locals(int size)                  { _max_locals = size; }
525 
526   // size of parameters
527   int  size_of_parameters() const                { return _size_of_parameters; }
528   void set_size_of_parameters(int size)          { _size_of_parameters = size; }
529 
<a name="7" id="anc7"></a>



530   void set_result_type(BasicType rt)             { assert(rt &lt; 16, &quot;result type too large&quot;);
531                                                    _result_type = (u1)rt; }
532   // Deallocation for RedefineClasses
533   void deallocate_contents(ClassLoaderData* loader_data);
534   bool is_klass() const { return false; }
535   DEBUG_ONLY(bool on_stack() { return false; })
536 
537   void metaspace_pointers_do(MetaspaceClosure* it);
538   MetaspaceObj::Type type() const { return ConstMethodType; }
539 private:
540   // Since the size of the compressed line number table is unknown, the
541   // offsets of the other variable sized sections are computed backwards
542   // from the end of the ConstMethod*.
543 
544   // First byte after ConstMethod*
545   address constMethod_end() const
546                           { return (address)((intptr_t*)this + _constMethod_size); }
547 
548   // Last short in ConstMethod*
549   u2* last_u2_element() const;
550 
551  public:
552   // Printing
553   void print_on      (outputStream* st) const;
554   void print_value_on(outputStream* st) const;
555 
556   const char* internal_name() const { return &quot;{constMethod}&quot;; }
557 
558   // Verify
559   void verify_on(outputStream* st);
560 };
561 
562 #endif // SHARE_OOPS_CONSTMETHOD_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/oop.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_HPP
 26 #define SHARE_OOPS_OOP_HPP
 27 
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
 31 #include &quot;oops/metadata.hpp&quot;
 32 #include &quot;runtime/atomic.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
 36 // the format of Java objects so the fields can be accessed from C++.
 37 // oopDesc is abstract.
 38 // (see oopHierarchy for complete oop class hierarchy)
 39 //
 40 // no virtual functions allowed
 41 
 42 extern bool always_do_update_barrier;
 43 
 44 // Forward declarations.
 45 class OopClosure;
 46 class ScanClosure;
 47 class FastScanClosure;
 48 class FilteringClosure;
 49 class CMSIsAliveClosure;
 50 
 51 class PSPromotionManager;
 52 class ParCompactionManager;
 53 
 54 class oopDesc {
 55   friend class VMStructs;
 56   friend class JVMCIVMStructs;
 57  private:
 58   volatile markOop _mark;
 59   union _metadata {
 60     Klass*      _klass;
 61     narrowKlass _compressed_klass;
 62   } _metadata;
 63 
 64  public:
 65   inline markOop  mark()          const;
 66   inline markOop  mark_raw()      const;
 67   inline markOop* mark_addr_raw() const;
 68 
 69   inline void set_mark(volatile markOop m);
 70   inline void set_mark_raw(volatile markOop m);
 71   static inline void set_mark_raw(HeapWord* mem, markOop m);
 72 
 73   inline void release_set_mark(markOop m);
 74   inline markOop cas_set_mark(markOop new_mark, markOop old_mark);
 75   inline markOop cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative);
 76 
 77   // Used only to re-initialize the mark word (e.g., of promoted
 78   // objects during a GC) -- requires a valid klass pointer
 79   inline void init_mark();
 80   inline void init_mark_raw();
 81 
 82   inline Klass* klass() const;
 83   inline Klass* klass_or_null() const volatile;
 84   inline Klass* klass_or_null_acquire() const volatile;
 85   static inline Klass** klass_addr(HeapWord* mem);
 86   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
 87   inline Klass** klass_addr();
 88   inline narrowKlass* compressed_klass_addr();
 89 
 90   inline void set_klass(Klass* k);
 91   static inline void release_set_klass(HeapWord* mem, Klass* klass);
 92 
 93   // For klass field compression
 94   inline int klass_gap() const;
 95   inline void set_klass_gap(int z);
 96   static inline void set_klass_gap(HeapWord* mem, int z);
 97   // For when the klass pointer is being used as a linked list &quot;next&quot; field.
 98   inline void set_klass_to_list_ptr(oop k);
 99   inline oop list_ptr_from_klass();
100 
101   // size of object header, aligned to platform wordSize
102   static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
103 
104   // Returns whether this is an instance of k or an instance of a subclass of k
105   inline bool is_a(Klass* k) const;
106 
107   // Returns the actual oop size of the object
108   inline int size();
109 
110   // Sometimes (for complicated concurrency-related reasons), it is useful
111   // to be able to figure out the size of an object knowing its klass.
112   inline int size_given_klass(Klass* klass);
113 
114   // type test operations (inlined in oop.inline.hpp)
115   inline bool is_instance()            const;
116   inline bool is_array()               const;
117   inline bool is_objArray()            const;
118   inline bool is_typeArray()           const;
119 
120   // type test operations that don&#39;t require inclusion of oop.inline.hpp.
121   bool is_instance_noinline()          const;
122   bool is_array_noinline()             const;
123   bool is_objArray_noinline()          const;
124   bool is_typeArray_noinline()         const;
125 
126  protected:
127   inline oop        as_oop() const { return const_cast&lt;oopDesc*&gt;(this); }
128 
129  public:
130   // field addresses in oop
131   inline void* field_addr(int offset)     const;
132   inline void* field_addr_raw(int offset) const;
133 
134   // Need this as public for garbage collection.
135   template &lt;class T&gt; inline T* obj_field_addr_raw(int offset) const;
136 
137   template &lt;typename T&gt; inline size_t field_offset(T* p) const;
138 
139   // Standard compare function returns negative value if o1 &lt; o2
140   //                                   0              if o1 == o2
141   //                                   positive value if o1 &gt; o2
142   inline static int  compare(oop o1, oop o2) {
143     void* o1_addr = (void*)o1;
144     void* o2_addr = (void*)o2;
145     if (o1_addr &lt; o2_addr) {
146       return -1;
147     } else if (o1_addr &gt; o2_addr) {
148       return 1;
149     } else {
150       return 0;
151     }
152   }
153 
154   inline static bool equals(oop o1, oop o2) { return Access&lt;&gt;::equals(o1, o2); }
155 
156   inline static bool equals_raw(oop o1, oop o2) { return RawAccess&lt;&gt;::equals(o1, o2); }
157 
158   // Access to fields in a instanceOop through these methods.
159   template &lt;DecoratorSet decorator&gt;
160   oop obj_field_access(int offset) const;
161   oop obj_field(int offset) const;
162   void obj_field_put(int offset, oop value);
163   void obj_field_put_raw(int offset, oop value);
164   void obj_field_put_volatile(int offset, oop value);
165 
166   Metadata* metadata_field(int offset) const;
167   Metadata* metadata_field_raw(int offset) const;
168   void metadata_field_put(int offset, Metadata* value);
169 
170   Metadata* metadata_field_acquire(int offset) const;
171   void release_metadata_field_put(int offset, Metadata* value);
172 
173   jbyte byte_field(int offset) const;
174   void byte_field_put(int offset, jbyte contents);
175 
176   jchar char_field(int offset) const;
177   void char_field_put(int offset, jchar contents);
178 
179   jboolean bool_field(int offset) const;
180   void bool_field_put(int offset, jboolean contents);
181 
182   jint int_field(int offset) const;
183   jint int_field_raw(int offset) const;
184   void int_field_put(int offset, jint contents);
185 
186   jshort short_field(int offset) const;
187   void short_field_put(int offset, jshort contents);
188 
189   jlong long_field(int offset) const;
190   void long_field_put(int offset, jlong contents);
191 
192   jfloat float_field(int offset) const;
193   void float_field_put(int offset, jfloat contents);
194 
195   jdouble double_field(int offset) const;
196   void double_field_put(int offset, jdouble contents);
197 
198   address address_field(int offset) const;
199   void address_field_put(int offset, address contents);
200 
201   oop obj_field_acquire(int offset) const;
202   void release_obj_field_put(int offset, oop value);
203 
204   jbyte byte_field_acquire(int offset) const;
205   void release_byte_field_put(int offset, jbyte contents);
206 
207   jchar char_field_acquire(int offset) const;
208   void release_char_field_put(int offset, jchar contents);
209 
210   jboolean bool_field_acquire(int offset) const;
211   void release_bool_field_put(int offset, jboolean contents);
212 
213   jint int_field_acquire(int offset) const;
214   void release_int_field_put(int offset, jint contents);
215 
216   jshort short_field_acquire(int offset) const;
217   void release_short_field_put(int offset, jshort contents);
218 
219   jlong long_field_acquire(int offset) const;
220   void release_long_field_put(int offset, jlong contents);
221 
222   jfloat float_field_acquire(int offset) const;
223   void release_float_field_put(int offset, jfloat contents);
224 
225   jdouble double_field_acquire(int offset) const;
226   void release_double_field_put(int offset, jdouble contents);
227 
228   address address_field_acquire(int offset) const;
229   void release_address_field_put(int offset, address contents);
230 
231   // printing functions for VM debugging
232   void print_on(outputStream* st) const;        // First level print
233   void print_value_on(outputStream* st) const;  // Second level print.
234   void print_address_on(outputStream* st) const; // Address printing
235 
236   // printing on default output stream
237   void print();
238   void print_value();
239   void print_address();
240 
241   // return the print strings
242   char* print_string();
243   char* print_value_string();
244 
245   // verification operations
246   static void verify_on(outputStream* st, oopDesc* oop_desc);
247   static void verify(oopDesc* oopDesc);
248 
249   // locking operations
250   inline bool is_locked()   const;
251   inline bool is_unlocked() const;
252   inline bool has_bias_pattern() const;
253   inline bool has_bias_pattern_raw() const;
254 
255   // asserts and guarantees
256   static bool is_oop(oop obj, bool ignore_mark_word = false);
257   static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);
258 #ifndef PRODUCT
259   inline bool is_unlocked_oop() const;
260   static bool is_archived_object(oop p) NOT_CDS_JAVA_HEAP_RETURN_(false);
261 #endif
262 
263   // garbage collection
264   inline bool is_gc_marked() const;
265 
266   // Forward pointer operations for scavenge
267   inline bool is_forwarded() const;
268 
269   inline void forward_to(oop p);
270   inline bool cas_forward_to(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);
271 
272   // Like &quot;forward_to&quot;, but inserts the forwarding pointer atomically.
273   // Exactly one thread succeeds in inserting the forwarding pointer, and
274   // this call returns &quot;NULL&quot; for that thread; any other thread has the
275   // value of the forwarding pointer returned and does not modify &quot;this&quot;.
276   inline oop forward_to_atomic(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);
277 
278   inline oop forwardee() const;
279   inline oop forwardee_acquire() const;
280 
281   // Age of object during scavenge
282   inline uint age() const;
283   inline void incr_age();
284 
285   // mark-sweep support
286   void follow_body(int begin, int end);
287 
288   template &lt;typename OopClosureType&gt;
289   inline void oop_iterate(OopClosureType* cl);
290 
291   template &lt;typename OopClosureType&gt;
292   inline void oop_iterate(OopClosureType* cl, MemRegion mr);
293 
294   template &lt;typename OopClosureType&gt;
295   inline int oop_iterate_size(OopClosureType* cl);
296 
297   template &lt;typename OopClosureType&gt;
298   inline int oop_iterate_size(OopClosureType* cl, MemRegion mr);
299 
300   template &lt;typename OopClosureType&gt;
301   inline void oop_iterate_backwards(OopClosureType* cl);
302 
303   inline static bool is_instanceof_or_null(oop obj, Klass* klass);
304 
305   // identity hash; returns the identity hash key (computes it if necessary)
306   // NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a
307   // safepoint if called on a biased object. Calling code must be aware of that.
308   inline intptr_t identity_hash();
309   intptr_t slow_identity_hash();
310 
311   // marks are forwarded to stack when object is locked
312   inline bool    has_displaced_mark_raw() const;
313   inline markOop displaced_mark_raw() const;
314   inline void    set_displaced_mark_raw(markOop m);
315 
316   static bool has_klass_gap();
317 
318   // for code generation
319   static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }
320   static int klass_offset_in_bytes()     { return offset_of(oopDesc, _metadata._klass); }
321   static int klass_gap_offset_in_bytes() {
322     assert(has_klass_gap(), &quot;only applicable to compressed klass pointers&quot;);
323     return klass_offset_in_bytes() + sizeof(narrowKlass);
324   }
325 
326   // for error reporting
327   static oop   decode_oop_raw(narrowOop narrow_oop);
328   static void* load_klass_raw(oop obj);
329   static void* load_oop_raw(oop obj, int offset);
330   static bool  is_valid(oop obj);
331   static oop   oop_or_null(address addr);
332 };
333 
334 #endif // SHARE_OOPS_OOP_HPP
    </pre>
  </body>
</html>
diff a/src/hotspot/share/oops/instanceKlass.inline.hpp b/src/hotspot/share/oops/instanceKlass.inline.hpp
--- a/src/hotspot/share/oops/instanceKlass.inline.hpp
+++ b/src/hotspot/share/oops/instanceKlass.inline.hpp
@@ -27,29 +27,29 @@
 
 #include "memory/iterator.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/klass.hpp"
 #include "oops/oop.inline.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/macros.hpp"
 
 inline Klass* InstanceKlass::array_klasses_acquire() const {
-  return OrderAccess::load_acquire(&_array_klasses);
+  return Atomic::load_acquire(&_array_klasses);
 }
 
 inline void InstanceKlass::release_set_array_klasses(Klass* k) {
-  OrderAccess::release_store(&_array_klasses, k);
+  Atomic::release_store(&_array_klasses, k);
 }
 
 inline jmethodID* InstanceKlass::methods_jmethod_ids_acquire() const {
-  return OrderAccess::load_acquire(&_methods_jmethod_ids);
+  return Atomic::load_acquire(&_methods_jmethod_ids);
 }
 
 inline void InstanceKlass::release_set_methods_jmethod_ids(jmethodID* jmeths) {
-  OrderAccess::release_store(&_methods_jmethod_ids, jmeths);
+  Atomic::release_store(&_methods_jmethod_ids, jmeths);
 }
 
 // The iteration over the oops in objects is a hot path in the GC code.
 // By force inlining the following functions, we get similar GC performance
 // as the previous macro based implementation.

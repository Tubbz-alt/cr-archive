diff a/src/hotspot/share/oops/symbol.cpp b/src/hotspot/share/oops/symbol.cpp
--- a/src/hotspot/share/oops/symbol.cpp
+++ b/src/hotspot/share/oops/symbol.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,13 +29,15 @@
 #include "gc/shared/collectedHeap.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "oops/symbol.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/os.hpp"
+#include "utilities/utf8.hpp"
 
 uint32_t Symbol::pack_length_and_refcount(int length, int refcount) {
   STATIC_ASSERT(max_symbol_length == ((1 << 16) - 1));
   STATIC_ASSERT(PERM_REFCOUNT == ((1 << 16) - 1));
   assert(length >= 0, "negative length");
@@ -48,47 +50,66 @@
 }
 
 Symbol::Symbol(const u1* name, int length, int refcount) {
   _length_and_refcount =  pack_length_and_refcount(length, refcount);
   _identity_hash = (short)os::random();
+  _body[0] = 0;  // in case length == 0
   for (int i = 0; i < length; i++) {
     byte_at_put(i, name[i]);
   }
 }
 
-void* Symbol::operator new(size_t sz, int len, TRAPS) throw() {
+void* Symbol::operator new(size_t sz, int len) throw() {
   int alloc_size = size(len)*wordSize;
   address res = (address) AllocateHeap(alloc_size, mtSymbol);
   return res;
 }
 
-void* Symbol::operator new(size_t sz, int len, Arena* arena, TRAPS) throw() {
+void* Symbol::operator new(size_t sz, int len, Arena* arena) throw() {
   int alloc_size = size(len)*wordSize;
   address res = (address)arena->Amalloc_4(alloc_size);
   return res;
 }
 
 void Symbol::operator delete(void *p) {
   assert(((Symbol*)p)->refcount() == 0, "should not call this");
   FreeHeap(p);
 }
 
+void Symbol::set_permanent() {
+  // This is called at a safepoint during dumping of a dynamic CDS archive.
+  assert(SafepointSynchronize::is_at_safepoint(), "must be at a safepoint");
+  _length_and_refcount =  pack_length_and_refcount(length(), PERM_REFCOUNT);
+}
+
+
 // ------------------------------------------------------------------
-// Symbol::starts_with
+// Symbol::contains_byte_at
 //
-// Tests if the symbol starts with the specified prefix of the given
-// length.
-bool Symbol::starts_with(const char* prefix, int len) const {
-  if (len > utf8_length()) return false;
-  while (len-- > 0) {
-    if (prefix[len] != char_at(len))
-      return false;
-  }
-  assert(len == -1, "we should be at the beginning");
-  return true;
+// Tests if the symbol contains the given byte at the given position.
+bool Symbol::contains_byte_at(int position, char code_byte) const {
+  if (position < 0)  return false;  // can happen with ends_with
+  if (position >= utf8_length()) return false;
+  return code_byte == char_at(position);
 }
 
+// ------------------------------------------------------------------
+// Symbol::contains_utf8_at
+//
+// Tests if the symbol contains the given utf8 substring
+// at the given byte position.
+bool Symbol::contains_utf8_at(int position, const char* substring, int len) const {
+  assert(len >= 0 && substring != NULL, "substring must be valid");
+  if (len <= 1)
+    return len == 0 || contains_byte_at(position, substring[0]);
+  if (position < 0)  return false;  // can happen with ends_with
+  if (position + len > utf8_length()) return false;
+  if (memcmp((char*)base() + position, substring, len) == 0)
+    return true;
+  else
+    return false;
+}
 
 // ------------------------------------------------------------------
 // Symbol::index_of
 //
 // Finds if the given string is a substring of this symbol's utf8 bytes.
@@ -105,12 +126,15 @@
   for (; scan <= limit; scan++) {
     scan = (address) memchr(scan, first_char, (limit + 1 - scan));
     if (scan == NULL)
       return -1;  // not found
     assert(scan >= bytes+i && scan <= limit, "scan oob");
-    if (memcmp(scan, str, len) == 0)
+    if (len <= 2
+        ? (char) scan[len-1] == str[len-1]
+        : memcmp(scan+1, str+1, len-1) == 0) {
       return (int)(scan - bytes);
+    }
   }
   return -1;
 }
 
 
@@ -175,12 +199,12 @@
   if (size > 0) {
     char* str    = as_C_string(buf, size);
     int   length = (int)strlen(str);
     // Turn all '/'s into '.'s (also for array klasses)
     for (int index = 0; index < length; index++) {
-      if (str[index] == '/') {
-        str[index] = '.';
+      if (str[index] == JVM_SIGNATURE_SLASH) {
+        str[index] = JVM_SIGNATURE_DOT;
       }
     }
     return str;
   } else {
     return buf;
@@ -190,17 +214,72 @@
 const char* Symbol::as_klass_external_name() const {
   char* str    = as_C_string();
   int   length = (int)strlen(str);
   // Turn all '/'s into '.'s (also for array klasses)
   for (int index = 0; index < length; index++) {
-    if (str[index] == '/') {
-      str[index] = '.';
+    if (str[index] == JVM_SIGNATURE_SLASH) {
+      str[index] = JVM_SIGNATURE_DOT;
     }
   }
   return str;
 }
 
+static void print_class(outputStream *os, const SignatureStream& ss) {
+  int sb = ss.raw_symbol_begin(), se = ss.raw_symbol_end();
+  for (int i = sb; i < se; ++i) {
+    int ch = ss.raw_char_at(i);
+    if (ch == JVM_SIGNATURE_SLASH) {
+      os->put(JVM_SIGNATURE_DOT);
+    } else {
+      os->put(ch);
+    }
+  }
+}
+
+static void print_array(outputStream *os, SignatureStream& ss) {
+  int dimensions = ss.skip_array_prefix();
+  assert(dimensions > 0, "");
+  if (ss.is_reference()) {
+    print_class(os, ss);
+  } else {
+    os->print("%s", type2name(ss.type()));
+  }
+  for (int i = 0; i < dimensions; ++i) {
+    os->print("[]");
+  }
+}
+
+void Symbol::print_as_signature_external_return_type(outputStream *os) {
+  for (SignatureStream ss(this); !ss.is_done(); ss.next()) {
+    if (ss.at_return_type()) {
+      if (ss.is_array()) {
+        print_array(os, ss);
+      } else if (ss.is_reference()) {
+        print_class(os, ss);
+      } else {
+        os->print("%s", type2name(ss.type()));
+      }
+    }
+  }
+}
+
+void Symbol::print_as_signature_external_parameters(outputStream *os) {
+  bool first = true;
+  for (SignatureStream ss(this); !ss.is_done(); ss.next()) {
+    if (ss.at_return_type()) break;
+    if (!first) { os->print(", "); }
+    if (ss.is_array()) {
+      print_array(os, ss);
+    } else if (ss.is_reference()) {
+      print_class(os, ss);
+    } else {
+      os->print("%s", type2name(ss.type()));
+    }
+    first = false;
+  }
+}
+
 // Increment refcount while checking for zero.  If the Symbol's refcount becomes zero
 // a thread could be concurrently removing the Symbol.  This is used during SymbolTable
 // lookup to avoid reviving a dead Symbol.
 bool Symbol::try_increment_refcount() {
   uint32_t found = _length_and_refcount;
@@ -210,11 +289,11 @@
     if (refc == PERM_REFCOUNT) {
       return true;  // sticky max or created permanent
     } else if (refc == 0) {
       return false; // dead, can't revive.
     } else {
-      found = Atomic::cmpxchg(old_value + 1, &_length_and_refcount, old_value);
+      found = Atomic::cmpxchg(&_length_and_refcount, old_value, old_value + 1);
       if (found == old_value) {
         return true; // successfully updated.
       }
       // refcount changed, try again.
     }
@@ -253,11 +332,11 @@
       print();
       fatal("refcount underflow");
 #endif
       return;
     } else {
-      found = Atomic::cmpxchg(old_value - 1, &_length_and_refcount, old_value);
+      found = Atomic::cmpxchg(&_length_and_refcount, old_value, old_value - 1);
       if (found == old_value) {
         return;  // successfully updated.
       }
       // refcount changed, try again.
     }
@@ -277,11 +356,11 @@
       fatal("refcount underflow");
 #endif
       return;
     } else {
       int len = extract_length(old_value);
-      found = Atomic::cmpxchg(pack_length_and_refcount(len, PERM_REFCOUNT), &_length_and_refcount, old_value);
+      found = Atomic::cmpxchg(&_length_and_refcount, old_value, pack_length_and_refcount(len, PERM_REFCOUNT));
       if (found == old_value) {
         return;  // successfully updated.
       }
       // refcount changed, try again.
     }
@@ -302,28 +381,32 @@
   print_symbol_on(st);
   st->print("'");
   st->print(" count %d", refcount());
 }
 
+void Symbol::print() const { print_on(tty); }
+
 // The print_value functions are present in all builds, to support the
 // disassembler and error reporting.
 void Symbol::print_value_on(outputStream* st) const {
   st->print("'");
   for (int i = 0; i < utf8_length(); i++) {
     st->print("%c", char_at(i));
   }
   st->print("'");
 }
 
+void Symbol::print_value() const { print_value_on(tty); }
+
 bool Symbol::is_valid(Symbol* s) {
   if (!is_aligned(s, sizeof(MetaWord))) return false;
   if ((size_t)s < os::min_page_size()) return false;
 
   if (!os::is_readable_range(s, s + 1)) return false;
 
   // Symbols are not allocated in Java heap.
-  if (Universe::heap()->is_in_reserved(s)) return false;
+  if (Universe::heap()->is_in(s)) return false;
 
   int len = s->utf8_length();
   if (len < 0) return false;
 
   jbyte* bytes = (jbyte*) s->bytes();

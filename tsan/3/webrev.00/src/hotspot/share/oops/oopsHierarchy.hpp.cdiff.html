<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/oopsHierarchy.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopsHierarchy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oopsHierarchy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
  #ifndef SHARE_OOPS_OOPSHIERARCHY_HPP
  #define SHARE_OOPS_OOPSHIERARCHY_HPP
  
  #include &quot;metaprogramming/integralConstant.hpp&quot;
  #include &quot;metaprogramming/primitiveConversions.hpp&quot;
<span class="line-removed">- #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
  // OBJECT hierarchy
  // This hierarchy is a representation hierarchy, i.e. if A is a superclass
  // of B, A&#39;s representation is a prefix of B&#39;s representation.
<span class="line-new-header">--- 25,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,19 ***</span>
  
  // If compressed klass pointers then use narrowKlass.
  typedef juint  narrowKlass;
  
  typedef void* OopOrNarrowOopStar;
<span class="line-removed">- typedef class   markOopDesc*                markOop;</span>
  
  #ifndef CHECK_UNHANDLED_OOPS
  
<span class="line-modified">! typedef class oopDesc*                            oop;</span>
  typedef class   instanceOopDesc*            instanceOop;
<span class="line-modified">! typedef class   arrayOopDesc*                    arrayOop;</span>
  typedef class     objArrayOopDesc*            objArrayOop;
<span class="line-modified">! typedef class     typeArrayOopDesc*            typeArrayOop;</span>
  
  #else
  
  // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
  // carefully chosen set of constructors and conversion operators to go
<span class="line-new-header">--- 37,18 ---</span>
  
  // If compressed klass pointers then use narrowKlass.
  typedef juint  narrowKlass;
  
  typedef void* OopOrNarrowOopStar;
  
  #ifndef CHECK_UNHANDLED_OOPS
  
<span class="line-modified">! typedef class oopDesc*                    oop;</span>
  typedef class   instanceOopDesc*            instanceOop;
<span class="line-modified">! typedef class   arrayOopDesc*               arrayOop;</span>
  typedef class     objArrayOopDesc*            objArrayOop;
<span class="line-modified">! typedef class     typeArrayOopDesc*           typeArrayOop;</span>
  
  #else
  
  // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
  // carefully chosen set of constructors and conversion operators to go
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,20 ***</span>
  // Converting NULL to oop to Handle implicit is no longer accepted by the
  // compiler because there are too many steps in the conversion.  Use Handle()
  // instead, which generates less code anyway.
  
  class Thread;
<span class="line-removed">- class PromotedObject;</span>
  class oopDesc;
  
  class oop {
    oopDesc* _o;
  
    void register_oop();
    void unregister_oop();
  
<span class="line-removed">-   // friend class markOop;</span>
  public:
    void set_obj(const void* p)         {
      raw_set_obj(p);
      if (CheckUnhandledOops) register_oop();
    }
<span class="line-new-header">--- 68,20 ---</span>
  // Converting NULL to oop to Handle implicit is no longer accepted by the
  // compiler because there are too many steps in the conversion.  Use Handle()
  // instead, which generates less code anyway.
  
  class Thread;
  class oopDesc;
  
<span class="line-added">+ extern &quot;C&quot; bool CheckUnhandledOops;</span>
<span class="line-added">+ </span>
  class oop {
    oopDesc* _o;
  
    void register_oop();
    void unregister_oop();
  
  public:
    void set_obj(const void* p)         {
      raw_set_obj(p);
      if (CheckUnhandledOops) register_oop();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,38 ***</span>
  
    oopDesc* obj()  const volatile      { return _o; }
  
    // General access
    oopDesc*  operator-&gt;() const        { return obj(); }
<span class="line-modified">!   bool operator==(const oop o) const;</span>
    bool operator==(void *p) const      { return obj() == p; }
<span class="line-modified">!   bool operator!=(const volatile oop o) const;</span>
    bool operator!=(void *p) const      { return obj() != p; }
  
    // Assignment
    oop&amp; operator=(const oop&amp; o)                            { _o = o.obj(); return *this; }
    volatile oop&amp; operator=(const oop&amp; o) volatile          { _o = o.obj(); return *this; }
    volatile oop&amp; operator=(const volatile oop&amp; o) volatile { _o = o.obj(); return *this; }
  
    // Explict user conversions
<span class="line-removed">-   operator void* () const             { return (void *)obj(); }</span>
<span class="line-removed">- #ifndef SOLARIS</span>
<span class="line-removed">-   operator void* () const volatile    { return (void *)obj(); }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   operator HeapWord* () const         { return (HeapWord*)obj(); }</span>
    operator oopDesc* () const volatile { return obj(); }
<span class="line-removed">-   operator intptr_t* () const         { return (intptr_t*)obj(); }</span>
<span class="line-removed">-   operator PromotedObject* () const   { return (PromotedObject*)obj(); }</span>
<span class="line-removed">-   operator markOop () const volatile  { return markOop(obj()); }</span>
<span class="line-removed">-   operator address   () const         { return (address)obj(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // from javaCalls.cpp</span>
<span class="line-removed">-   operator jobject () const           { return (jobject)obj(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // from parNewGeneration and other things that want to get to the end of</span>
<span class="line-removed">-   // an oop for stuff (like ObjArrayKlass.cpp)</span>
<span class="line-removed">-   operator oop* () const              { return (oop *)obj(); }</span>
  };
  
  template&lt;&gt;
  struct PrimitiveConversions::Translate&lt;oop&gt; : public TrueType {
    typedef oop Value;
<span class="line-new-header">--- 97,22 ---</span>
  
    oopDesc* obj()  const volatile      { return _o; }
  
    // General access
    oopDesc*  operator-&gt;() const        { return obj(); }
<span class="line-modified">!   bool operator==(const oop o) const  { return obj() == o.obj(); }</span>
    bool operator==(void *p) const      { return obj() == p; }
<span class="line-modified">!   bool operator!=(const volatile oop o) const { return obj() != o.obj(); }</span>
    bool operator!=(void *p) const      { return obj() != p; }
  
    // Assignment
    oop&amp; operator=(const oop&amp; o)                            { _o = o.obj(); return *this; }
    volatile oop&amp; operator=(const oop&amp; o) volatile          { _o = o.obj(); return *this; }
    volatile oop&amp; operator=(const volatile oop&amp; o) volatile { _o = o.obj(); return *this; }
  
    // Explict user conversions
    operator oopDesc* () const volatile { return obj(); }
  };
  
  template&lt;&gt;
  struct PrimitiveConversions::Translate&lt;oop&gt; : public TrueType {
    typedef oop Value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,15 ***</span>
  // and pointer type. Define inline methods to provide the numerical conversions.
  template &lt;class T&gt; inline oop cast_to_oop(T value) {
    return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
  }
  template &lt;class T&gt; inline T cast_from_oop(oop o) {
<span class="line-modified">!   return (T)(CHECK_UNHANDLED_OOPS_ONLY((void*))o);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline bool check_obj_alignment(oop obj) {</span>
<span class="line-removed">-   return (cast_from_oop&lt;intptr_t&gt;(obj) &amp; MinObjAlignmentInBytesMask) == 0;</span>
  }
  
  // The metadata hierarchy is separate from the oop hierarchy
  
  //      class MetaspaceObj
<span class="line-new-header">--- 169,11 ---</span>
  // and pointer type. Define inline methods to provide the numerical conversions.
  template &lt;class T&gt; inline oop cast_to_oop(T value) {
    return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
  }
  template &lt;class T&gt; inline T cast_from_oop(oop o) {
<span class="line-modified">!   return (T)(CHECK_UNHANDLED_OOPS_ONLY((oopDesc*))o);</span>
  }
  
  // The metadata hierarchy is separate from the oop hierarchy
  
  //      class MetaspaceObj
</pre>
<center><a href="oopsHierarchy.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
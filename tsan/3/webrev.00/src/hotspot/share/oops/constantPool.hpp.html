<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_CONSTANTPOOL_HPP
  26 #define SHARE_OOPS_CONSTANTPOOL_HPP
  27 
  28 #include &quot;memory/allocation.hpp&quot;
  29 #include &quot;oops/arrayOop.hpp&quot;
  30 #include &quot;oops/cpCache.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oopHandle.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;oops/typeArrayOop.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/bytes.hpp&quot;
  38 #include &quot;utilities/constantTag.hpp&quot;
  39 
  40 // A ConstantPool is an array containing class constants as described in the
  41 // class file.
  42 //
  43 // Most of the constant pool entries are written during class parsing, which
  44 // is safe.  For klass types, the constant pool entry is
  45 // modified when the entry is resolved.  If a klass constant pool
  46 // entry is read without a lock, only the resolved state guarantees that
  47 // the entry in the constant pool is a klass object and not a Symbol*.
  48 
  49 class SymbolHashMap;
  50 
  51 class CPSlot {
  52  friend class ConstantPool;
  53   intptr_t _ptr;
  54   enum TagBits  {_pseudo_bit = 1};
  55  public:
  56 
  57   CPSlot(intptr_t ptr): _ptr(ptr) {}
  58   CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}
  59 
  60   intptr_t value()   { return _ptr; }
  61   bool is_pseudo_string() { return (_ptr &amp; _pseudo_bit) != 0; }
  62 
  63   Symbol* get_symbol() {
  64     return (Symbol*)(_ptr &amp; ~_pseudo_bit);
  65   }
  66 };
  67 
  68 // This represents a JVM_CONSTANT_Class, JVM_CONSTANT_UnresolvedClass, or
  69 // JVM_CONSTANT_UnresolvedClassInError slot in the constant pool.
  70 class CPKlassSlot {
  71   // cp-&gt;symbol_at(_name_index) gives the name of the class.
  72   int _name_index;
  73 
  74   // cp-&gt;_resolved_klasses-&gt;at(_resolved_klass_index) gives the Klass* for the class.
  75   int _resolved_klass_index;
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
 113   enum {
 114     _has_preresolution    = 1,       // Flags
 115     _on_stack             = 2,
 116     _is_shared            = 4,
 117     _has_dynamic_constant = 8
 118   };
 119 
 120   int                  _flags;  // old fashioned bit twiddling
 121   int                  _length; // number of elements in the array
 122 
 123   union {
 124     // set for CDS to restore resolved references
 125     int                _resolved_reference_length;
 126     // keeps version number for redefined classes (used in backtrace)
 127     int                _version;
 128   } _saved;
 129 
 130   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 131   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 132   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 133 
 134   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 135 
 136   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 137 
 138   int flags() const                            { return _flags; }
 139   void set_flags(int f)                        { _flags = f; }
 140 
 141  private:
 142   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 143 
 144   CPSlot slot_at(int which) const;
 145 
 146   void slot_at_put(int which, CPSlot s) const {
 147     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 148     assert(s.value() != 0, &quot;Caught something&quot;);
 149     *(intptr_t*)&amp;base()[which] = s.value();
 150   }
 151   intptr_t* obj_at_addr(int which) const {
 152     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 153     return (intptr_t*) &amp;base()[which];
 154   }
 155 
 156   jint* int_at_addr(int which) const {
 157     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 158     return (jint*) &amp;base()[which];
 159   }
 160 
 161   jlong* long_at_addr(int which) const {
 162     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 163     return (jlong*) &amp;base()[which];
 164   }
 165 
 166   jfloat* float_at_addr(int which) const {
 167     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 168     return (jfloat*) &amp;base()[which];
 169   }
 170 
 171   jdouble* double_at_addr(int which) const {
 172     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 173     return (jdouble*) &amp;base()[which];
 174   }
 175 
 176   ConstantPool(Array&lt;u1&gt;* tags);
 177   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 178  public:
 179   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 180 
 181   bool is_constantPool() const volatile     { return true; }
 182 
 183   Array&lt;u1&gt;* tags() const                   { return _tags; }
 184   Array&lt;u2&gt;* operands() const               { return _operands; }
 185 
 186   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 187   void set_has_preresolution() {
 188     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 189     _flags |= _has_preresolution;
 190   }
 191 
 192   // Redefine classes support.  If a method refering to this constant pool
 193   // is on the executing stack, or as a handle in vm code, this constant pool
 194   // can&#39;t be removed from the set of previous versions saved in the instance
 195   // class.
 196   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 197   void set_on_stack(const bool value);
 198 
 199   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 200   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 201 
 202   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 203   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 204 
 205   // Klass holding pool
 206   InstanceKlass* pool_holder() const      { return _pool_holder; }
 207   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 208   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 209 
 210   // Interpreter runtime support
 211   ConstantPoolCache* cache() const        { return _cache; }
 212   void set_cache(ConstantPoolCache* cache){ _cache = cache; }
 213 
 214   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 215   virtual MetaspaceObj::Type type() const { return ConstantPoolType; }
 216 
 217   // Create object cache in the constant pool
 218   void initialize_resolved_references(ClassLoaderData* loader_data,
 219                                       const intStack&amp; reference_map,
 220                                       int constant_pool_map_length,
 221                                       TRAPS);
 222 
 223   // resolved strings, methodHandles and callsite objects from the constant pool
 224   objArrayOop resolved_references()  const;
 225   objArrayOop resolved_references_or_null()  const;
 226   // mapping resolved object array indexes to cp indexes and back.
 227   int object_to_cp_index(int index)         { return reference_map()-&gt;at(index); }
 228   int cp_to_object_index(int index);
 229 
 230   void set_resolved_klasses(Array&lt;Klass*&gt;* rk)  { _resolved_klasses = rk; }
 231   Array&lt;Klass*&gt;* resolved_klasses() const       { return _resolved_klasses; }
 232   void allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS);
 233   void initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS);
 234 
 235   // Invokedynamic indexes.
 236   // They must look completely different from normal indexes.
 237   // The main reason is that byte swapping is sometimes done on normal indexes.
 238   // Finally, it is helpful for debugging to tell the two apart.
 239   static bool is_invokedynamic_index(int i) { return (i &lt; 0); }
 240   static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  &quot;&quot;); return ~i; }
 241   static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), &quot;&quot;); return ~i; }
 242 
 243 
 244   // The invokedynamic points at a CP cache entry.  This entry points back
 245   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
 246   // in the resolved_references array (which provides the appendix argument).
 247   int invokedynamic_cp_cache_index(int indy_index) const {
 248     assert(is_invokedynamic_index(indy_index), &quot;should be a invokedynamic index&quot;);
 249     int cache_index = decode_invokedynamic_index(indy_index);
 250     return cache_index;
 251   }
 252   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {
 253     // decode index that invokedynamic points to.
 254     int cp_cache_index = invokedynamic_cp_cache_index(indy_index);
 255     return cache()-&gt;entry_at(cp_cache_index);
 256   }
 257   // Given the per-instruction index of an indy instruction, report the
 258   // main constant pool entry for its bootstrap specifier.
 259   // From there, uncached_name/signature_ref_at will get the name/type.
 260   int invokedynamic_bootstrap_ref_index_at(int indy_index) const {
 261     return invokedynamic_cp_cache_entry_at(indy_index)-&gt;constant_pool_index();
 262   }
 263 
 264   // Assembly code support
 265   static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }
 266   static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }
 267   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
 268   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 269 
 270   // Storing constants
 271 
 272   // For temporary use while constructing constant pool
 273   void klass_index_at_put(int which, int name_index) {
 274     tag_at_put(which, JVM_CONSTANT_ClassIndex);
 275     *int_at_addr(which) = name_index;
 276   }
 277 
 278   // Unsafe anonymous class support:
 279   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
 280   void klass_at_put(int class_index, Klass* k);
 281 
 282   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
 283     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 284 
 285     assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 286     assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 287     *int_at_addr(which) =
 288       build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 289   }
 290 
 291   void method_handle_index_at_put(int which, int ref_kind, int ref_index) {
 292     tag_at_put(which, JVM_CONSTANT_MethodHandle);
 293     *int_at_addr(which) = ((jint) ref_index&lt;&lt;16) | ref_kind;
 294   }
 295 
 296   void method_type_index_at_put(int which, int ref_index) {
 297     tag_at_put(which, JVM_CONSTANT_MethodType);
 298     *int_at_addr(which) = ref_index;
 299   }
 300 
 301   void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 302     tag_at_put(which, JVM_CONSTANT_Dynamic);
 303     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 304   }
 305 
 306   void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 307     tag_at_put(which, JVM_CONSTANT_InvokeDynamic);
 308     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 309   }
 310 
 311   void unresolved_string_at_put(int which, Symbol* s) {
 312     release_tag_at_put(which, JVM_CONSTANT_String);
 313     slot_at_put(which, CPSlot(s));
 314   }
 315 
 316   void int_at_put(int which, jint i) {
 317     tag_at_put(which, JVM_CONSTANT_Integer);
 318     *int_at_addr(which) = i;
 319   }
 320 
 321   void long_at_put(int which, jlong l) {
 322     tag_at_put(which, JVM_CONSTANT_Long);
 323     // *long_at_addr(which) = l;
 324     Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &amp;l));
 325   }
 326 
 327   void float_at_put(int which, jfloat f) {
 328     tag_at_put(which, JVM_CONSTANT_Float);
 329     *float_at_addr(which) = f;
 330   }
 331 
 332   void double_at_put(int which, jdouble d) {
 333     tag_at_put(which, JVM_CONSTANT_Double);
 334     // *double_at_addr(which) = d;
 335     // u8 temp = *(u8*) &amp;d;
 336     Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &amp;d));
 337   }
 338 
 339   Symbol** symbol_at_addr(int which) const {
 340     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 341     return (Symbol**) &amp;base()[which];
 342   }
 343 
 344   void symbol_at_put(int which, Symbol* s) {
 345     assert(s-&gt;refcount() != 0, &quot;should have nonzero refcount&quot;);
 346     tag_at_put(which, JVM_CONSTANT_Utf8);
 347     *symbol_at_addr(which) = s;
 348   }
 349 
 350   void string_at_put(int which, int obj_index, oop str);
 351 
 352   // For temporary use while constructing constant pool
 353   void string_index_at_put(int which, int string_index) {
 354     tag_at_put(which, JVM_CONSTANT_StringIndex);
 355     *int_at_addr(which) = string_index;
 356   }
 357 
 358   void field_at_put(int which, int class_index, int name_and_type_index) {
 359     tag_at_put(which, JVM_CONSTANT_Fieldref);
 360     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 361   }
 362 
 363   void method_at_put(int which, int class_index, int name_and_type_index) {
 364     tag_at_put(which, JVM_CONSTANT_Methodref);
 365     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 366   }
 367 
 368   void interface_method_at_put(int which, int class_index, int name_and_type_index) {
 369     tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);
 370     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;  // Not so nice
 371   }
 372 
 373   void name_and_type_at_put(int which, int name_index, int signature_index) {
 374     tag_at_put(which, JVM_CONSTANT_NameAndType);
 375     *int_at_addr(which) = ((jint) signature_index&lt;&lt;16) | name_index;  // Not so nice
 376   }
 377 
 378   // Tag query
 379 
 380   constantTag tag_at(int which) const { return (constantTag)tags()-&gt;at_acquire(which); }
 381 
 382   // Fetching constants
 383 
 384   Klass* klass_at(int which, TRAPS) {
 385     constantPoolHandle h_this(THREAD, this);
 386     return klass_at_impl(h_this, which, true, THREAD);
 387   }
 388 
 389   // Version of klass_at that doesn&#39;t save the resolution error, called during deopt
 390   Klass* klass_at_ignore_error(int which, TRAPS) {
 391     constantPoolHandle h_this(THREAD, this);
 392     return klass_at_impl(h_this, which, false, THREAD);
 393   }
 394 
 395   CPKlassSlot klass_slot_at(int which) const {
 396     assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),
 397            &quot;Corrupted constant pool&quot;);
 398     int value = *int_at_addr(which);
 399     int name_index = extract_high_short_from_int(value);
 400     int resolved_klass_index = extract_low_short_from_int(value);
 401     return CPKlassSlot(name_index, resolved_klass_index);
 402   }
 403 
 404   Symbol* klass_name_at(int which) const;  // Returns the name, w/o resolving.
 405   int klass_name_index_at(int which) const {
 406     return klass_slot_at(which).name_index();
 407   }
 408 
 409   Klass* resolved_klass_at(int which) const;  // Used by Compiler
 410 
 411   // RedefineClasses() API support:
 412   Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }
 413   void temp_unresolved_klass_at_put(int which, int name_index) {
 414     // Used only during constant pool merging for class redefinition. The resolved klass index
 415     // will be initialized later by a call to initialize_unresolved_klasses().
 416     unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);
 417   }
 418 
 419   jint int_at(int which) {
 420     assert(tag_at(which).is_int(), &quot;Corrupted constant pool&quot;);
 421     return *int_at_addr(which);
 422   }
 423 
 424   jlong long_at(int which) {
 425     assert(tag_at(which).is_long(), &quot;Corrupted constant pool&quot;);
 426     // return *long_at_addr(which);
 427     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 428     return *((jlong*)&amp;tmp);
 429   }
 430 
 431   jfloat float_at(int which) {
 432     assert(tag_at(which).is_float(), &quot;Corrupted constant pool&quot;);
 433     return *float_at_addr(which);
 434   }
 435 
 436   jdouble double_at(int which) {
 437     assert(tag_at(which).is_double(), &quot;Corrupted constant pool&quot;);
 438     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 439     return *((jdouble*)&amp;tmp);
 440   }
 441 
 442   Symbol* symbol_at(int which) const {
 443     assert(tag_at(which).is_utf8(), &quot;Corrupted constant pool&quot;);
 444     return *symbol_at_addr(which);
 445   }
 446 
 447   oop string_at(int which, int obj_index, TRAPS) {
 448     constantPoolHandle h_this(THREAD, this);
 449     return string_at_impl(h_this, which, obj_index, THREAD);
 450   }
 451   oop string_at(int which, TRAPS) {
 452     int obj_index = cp_to_object_index(which);
 453     return string_at(which, obj_index, THREAD);
 454   }
 455 
 456   // Version that can be used before string oop array is created.
 457   oop uncached_string_at(int which, TRAPS);
 458 
 459   // A &quot;pseudo-string&quot; is an non-string oop that has found its way into
 460   // a String entry.
 461   // This can happen if the user patches a live
 462   // object into a CONSTANT_String entry of an unsafe anonymous class.
 463   // Method oops internally created for method handles may also
 464   // use pseudo-strings to link themselves to related metaobjects.
 465 
 466   bool is_pseudo_string_at(int which);
 467 
 468   oop pseudo_string_at(int which, int obj_index);
 469 
 470   oop pseudo_string_at(int which);
 471 
 472   void pseudo_string_at_put(int which, int obj_index, oop x) {
 473     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 474     Symbol* sym = unresolved_string_at(which);
 475     slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));
 476     string_at_put(which, obj_index, x);    // this works just fine
 477   }
 478 
 479   // only called when we are sure a string entry is already resolved (via an
 480   // earlier string_at call.
 481   oop resolved_string_at(int which) {
 482     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 483     // Must do an acquire here in case another thread resolved the klass
 484     // behind our back, lest we later load stale values thru the oop.
 485     // we might want a volatile_obj_at in ObjArrayKlass.
 486     int obj_index = cp_to_object_index(which);
 487     return resolved_references()-&gt;obj_at(obj_index);
 488   }
 489 
 490   Symbol* unresolved_string_at(int which) {
 491     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 492     Symbol* sym = slot_at(which).get_symbol();
 493     return sym;
 494   }
 495 
 496   // Returns an UTF8 for a CONSTANT_String entry at a given index.
 497   // UTF8 char* representation was chosen to avoid conversion of
 498   // java_lang_Strings at resolved entries into Symbol*s
 499   // or vice versa.
 500   char* string_at_noresolve(int which);
 501 
 502   jint name_and_type_at(int which) {
 503     assert(tag_at(which).is_name_and_type(), &quot;Corrupted constant pool&quot;);
 504     return *int_at_addr(which);
 505   }
 506 
 507   int method_handle_ref_kind_at(int which) {
 508     assert(tag_at(which).is_method_handle() ||
 509            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 510     return extract_low_short_from_int(*int_at_addr(which));  // mask out unwanted ref_index bits
 511   }
 512   int method_handle_index_at(int which) {
 513     assert(tag_at(which).is_method_handle() ||
 514            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 515     return extract_high_short_from_int(*int_at_addr(which));  // shift out unwanted ref_kind bits
 516   }
 517   int method_type_index_at(int which) {
 518     assert(tag_at(which).is_method_type() ||
 519            tag_at(which).is_method_type_in_error(), &quot;Corrupted constant pool&quot;);
 520     return *int_at_addr(which);
 521   }
 522 
 523   // Derived queries:
 524   Symbol* method_handle_name_ref_at(int which) {
 525     int member = method_handle_index_at(which);
 526     return impl_name_ref_at(member, true);
 527   }
 528   Symbol* method_handle_signature_ref_at(int which) {
 529     int member = method_handle_index_at(which);
 530     return impl_signature_ref_at(member, true);
 531   }
 532   int method_handle_klass_index_at(int which) {
 533     int member = method_handle_index_at(which);
 534     return impl_klass_ref_index_at(member, true);
 535   }
 536   Symbol* method_type_signature_at(int which) {
 537     int sym = method_type_index_at(which);
 538     return symbol_at(sym);
 539   }
 540 
 541   int bootstrap_name_and_type_ref_index_at(int which) {
 542     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 543     return extract_high_short_from_int(*int_at_addr(which));
 544   }
 545   int bootstrap_methods_attribute_index(int which) {
 546     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 547     return extract_low_short_from_int(*int_at_addr(which));
 548   }
 549   int bootstrap_operand_base(int which) {
 550     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 551     return operand_offset_at(operands(), bsms_attribute_index);
 552   }
 553   // The first part of the operands array consists of an index into the second part.
 554   // Extract a 32-bit index value from the first part.
 555   static int operand_offset_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 556     int n = (bsms_attribute_index * 2);
 557     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 558     // The first 32-bit index points to the beginning of the second part
 559     // of the operands array.  Make sure this index is in the first part.
 560     DEBUG_ONLY(int second_part = build_int_from_shorts(operands-&gt;at(0),
 561                                                        operands-&gt;at(1)));
 562     assert(second_part == 0 || n+2 &lt;= second_part, &quot;oob (2)&quot;);
 563     int offset = build_int_from_shorts(operands-&gt;at(n+0),
 564                                        operands-&gt;at(n+1));
 565     // The offset itself must point into the second part of the array.
 566     assert(offset == 0 || offset &gt;= second_part &amp;&amp; offset &lt;= operands-&gt;length(), &quot;oob (3)&quot;);
 567     return offset;
 568   }
 569   static void operand_offset_at_put(Array&lt;u2&gt;* operands, int bsms_attribute_index, int offset) {
 570     int n = bsms_attribute_index * 2;
 571     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 572     operands-&gt;at_put(n+0, extract_low_short_from_int(offset));
 573     operands-&gt;at_put(n+1, extract_high_short_from_int(offset));
 574   }
 575   static int operand_array_length(Array&lt;u2&gt;* operands) {
 576     if (operands == NULL || operands-&gt;length() == 0)  return 0;
 577     int second_part = operand_offset_at(operands, 0);
 578     return (second_part / 2);
 579   }
 580 
 581 #ifdef ASSERT
 582   // operand tuples fit together exactly, end to end
 583   static int operand_limit_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 584     int nextidx = bsms_attribute_index + 1;
 585     if (nextidx == operand_array_length(operands))
 586       return operands-&gt;length();
 587     else
 588       return operand_offset_at(operands, nextidx);
 589   }
 590   int bootstrap_operand_limit(int which) {
 591     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 592     return operand_limit_at(operands(), bsms_attribute_index);
 593   }
 594 #endif //ASSERT
 595 
 596   // Layout of InvokeDynamic and Dynamic bootstrap method specifier
 597   // data in second part of operands array.  This encodes one record in
 598   // the BootstrapMethods attribute.  The whole specifier also includes
 599   // the name and type information from the main constant pool entry.
 600   enum {
 601          _indy_bsm_offset  = 0,  // CONSTANT_MethodHandle bsm
 602          _indy_argc_offset = 1,  // u2 argc
 603          _indy_argv_offset = 2   // u2 argv[argc]
 604   };
 605 
 606   // These functions are used in RedefineClasses for CP merge
 607 
 608   int operand_offset_at(int bsms_attribute_index) {
 609     assert(0 &lt;= bsms_attribute_index &amp;&amp;
 610            bsms_attribute_index &lt; operand_array_length(operands()),
 611            &quot;Corrupted CP operands&quot;);
 612     return operand_offset_at(operands(), bsms_attribute_index);
 613   }
 614   int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {
 615     int offset = operand_offset_at(bsms_attribute_index);
 616     return operands()-&gt;at(offset + _indy_bsm_offset);
 617   }
 618   int operand_argument_count_at(int bsms_attribute_index) {
 619     int offset = operand_offset_at(bsms_attribute_index);
 620     int argc = operands()-&gt;at(offset + _indy_argc_offset);
 621     return argc;
 622   }
 623   int operand_argument_index_at(int bsms_attribute_index, int j) {
 624     int offset = operand_offset_at(bsms_attribute_index);
 625     return operands()-&gt;at(offset + _indy_argv_offset + j);
 626   }
 627   int operand_next_offset_at(int bsms_attribute_index) {
 628     int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset
 629                    + operand_argument_count_at(bsms_attribute_index);
 630     return offset;
 631   }
 632   // Compare a bootstrap specifier data in the operands arrays
 633   bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle&amp; cp2,
 634                           int bsms_attribute_index2, TRAPS);
 635   // Find a bootstrap specifier data in the operands array
 636   int find_matching_operand(int bsms_attribute_index, const constantPoolHandle&amp; search_cp,
 637                             int operands_cur_len, TRAPS);
 638   // Resize the operands array with delta_len and delta_size
 639   void resize_operands(int delta_len, int delta_size, TRAPS);
 640   // Extend the operands array with the length and size of the ext_cp operands
 641   void extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS);
 642   // Shrink the operands array to a smaller array with new_len length
 643   void shrink_operands(int new_len, TRAPS);
 644 
 645   int bootstrap_method_ref_index_at(int which) {
 646     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 647     int op_base = bootstrap_operand_base(which);
 648     return operands()-&gt;at(op_base + _indy_bsm_offset);
 649   }
 650   int bootstrap_argument_count_at(int which) {
 651     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 652     int op_base = bootstrap_operand_base(which);
 653     int argc = operands()-&gt;at(op_base + _indy_argc_offset);
 654     DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;
 655                int next_offset = bootstrap_operand_limit(which));
 656     assert(end_offset == next_offset, &quot;matched ending&quot;);
 657     return argc;
 658   }
 659   int bootstrap_argument_index_at(int which, int j) {
 660     int op_base = bootstrap_operand_base(which);
 661     DEBUG_ONLY(int argc = operands()-&gt;at(op_base + _indy_argc_offset));
 662     assert((uint)j &lt; (uint)argc, &quot;oob&quot;);
 663     return operands()-&gt;at(op_base + _indy_argv_offset + j);
 664   }
 665 
 666   // The following methods (name/signature/klass_ref_at, klass_ref_at_noresolve,
 667   // name_and_type_ref_index_at) all expect to be passed indices obtained
 668   // directly from the bytecode.
 669   // If the indices are meant to refer to fields or methods, they are
 670   // actually rewritten constant pool cache indices.
 671   // The routine remap_instruction_operand_from_cache manages the adjustment
 672   // of these values back to constant pool indices.
 673 
 674   // There are also &quot;uncached&quot; versions which do not adjust the operand index; see below.
 675 
 676   // FIXME: Consider renaming these with a prefix &quot;cached_&quot; to make the distinction clear.
 677   // In a few cases (the verifier) there are uses before a cpcache has been built,
 678   // which are handled by a dynamic check in remap_instruction_operand_from_cache.
 679   // FIXME: Remove the dynamic check, and adjust all callers to specify the correct mode.
 680 
 681   // Lookup for entries consisting of (klass_index, name_and_type index)
 682   Klass* klass_ref_at(int which, TRAPS);
 683   Symbol* klass_ref_at_noresolve(int which);
 684   Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }
 685   Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }
 686 
 687   int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }
 688   int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }
 689 
 690   int remap_instruction_operand_from_cache(int operand);  // operand must be biased by CPCACHE_INDEX_TAG
 691 
 692   constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }
 693 
 694   // Lookup for entries consisting of (name_index, signature_index)
 695   int name_ref_index_at(int which_nt);            // ==  low-order jshort of name_and_type_at(which_nt)
 696   int signature_ref_index_at(int which_nt);       // == high-order jshort of name_and_type_at(which_nt)
 697 
 698   BasicType basic_type_for_signature_at(int which) const;
 699 
 700   // Resolve string constants (to prevent allocation during compilation)
 701   void resolve_string_constants(TRAPS) {
 702     constantPoolHandle h_this(THREAD, this);
 703     resolve_string_constants_impl(h_this, CHECK);
 704   }
 705 
 706   // CDS support
 707   void archive_resolved_references(Thread *THREAD) NOT_CDS_JAVA_HEAP_RETURN;
 708   void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 709   void remove_unshareable_info();
 710   void restore_unshareable_info(TRAPS);
 711   // The ConstantPool vtable is restored by this call when the ConstantPool is
 712   // in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for
 713   // all the gory details.  SA, dtrace and pstack helpers distinguish metadata
 714   // by their vtable.
 715   void restore_vtable() { guarantee(is_constantPool(), &quot;vtable restored by this call&quot;); }
 716 
 717  private:
 718   enum { _no_index_sentinel = -1, _possible_index_sentinel = -2 };
 719  public:
 720 
 721   // Get the tag for a constant, which may involve a constant dynamic
 722   constantTag constant_tag_at(int which);
 723   // Get the basic type for a constant, which may involve a constant dynamic
 724   BasicType basic_type_for_constant_at(int which);
 725 
 726   // Resolve late bound constants.
 727   oop resolve_constant_at(int index, TRAPS) {
 728     constantPoolHandle h_this(THREAD, this);
 729     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 730   }
 731 
 732   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 733     constantPoolHandle h_this(THREAD, this);
 734     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 735   }
 736 
 737   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 738     constantPoolHandle h_this(THREAD, this);
 739     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 740   }
 741 
 742   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 743     constantPoolHandle h_this(THREAD, this);
 744     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 745   }
 746 
 747   void copy_bootstrap_arguments_at(int index,
 748                                    int start_arg, int end_arg,
 749                                    objArrayHandle info, int pos,
 750                                    bool must_resolve, Handle if_not_available, TRAPS) {
 751     constantPoolHandle h_this(THREAD, this);
 752     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 753                                      info, pos, must_resolve, if_not_available, THREAD);
 754   }
 755 
 756   // Klass name matches name at offset
 757   bool klass_name_at_matches(const InstanceKlass* k, int which);
 758 
 759   // Sizing
 760   int length() const                   { return _length; }
 761   void set_length(int length)          { _length = length; }
 762 
 763   // Tells whether index is within bounds.
 764   bool is_within_bounds(int index) const {
 765     return 0 &lt;= index &amp;&amp; index &lt; length();
 766   }
 767 
 768   // Sizing (in words)
 769   static int header_size()             {
 770     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 771   }
 772   static int size(int length)          { return align_metadata_size(header_size() + length); }
 773   int size() const                     { return size(length()); }
 774 
 775   // ConstantPools should be stored in the read-only region of CDS archive.
 776   static bool is_read_only_by_default() { return true; }
 777 
 778   friend class ClassFileParser;
 779   friend class SystemDictionary;
 780 
 781   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 782   template &lt;class T&gt; friend class CppVtableTesterA;
 783   template &lt;class T&gt; friend class CppVtableTesterB;
 784   template &lt;class T&gt; friend class CppVtableCloner;
 785 
 786   // Used by compiler to prevent classloading.
 787   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 788   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 789   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 790   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 791   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 792 
 793   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
 794   // future by other Java code. These take constant pool indices rather than
 795   // constant pool cache indices as do the peer methods above.
 796   Symbol* uncached_klass_ref_at_noresolve(int which);
 797   Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }
 798   Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }
 799   int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }
 800   int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }
 801 
 802   // Sharing
 803   int pre_resolve_shared_klasses(TRAPS);
 804 
 805   // Debugging
 806   const char* printable_name_at(int which) PRODUCT_RETURN0;
 807 
 808 #ifdef ASSERT
 809   enum { CPCACHE_INDEX_TAG = 0x10000 };  // helps keep CP cache indices distinct from CP indices
 810 #else
 811   enum { CPCACHE_INDEX_TAG = 0 };        // in product mode, this zero value is a no-op
 812 #endif //ASSERT
 813 
 814   static int decode_cpcache_index(int raw_index, bool invokedynamic_ok = false) {
 815     if (invokedynamic_ok &amp;&amp; is_invokedynamic_index(raw_index))
 816       return decode_invokedynamic_index(raw_index);
 817     else
 818       return raw_index - CPCACHE_INDEX_TAG;
 819   }
 820 
 821  private:
 822 
 823   void set_resolved_references(OopHandle s) { _cache-&gt;set_resolved_references(s); }
 824   Array&lt;u2&gt;* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache-&gt;reference_map(); }
 825   void set_reference_map(Array&lt;u2&gt;* o)    { _cache-&gt;set_reference_map(o); }
 826 
 827   // patch JSR 292 resolved references after the class is linked.
 828   void patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches);
 829 
 830   Symbol* impl_name_ref_at(int which, bool uncached);
 831   Symbol* impl_signature_ref_at(int which, bool uncached);
 832 
 833   int       impl_klass_ref_index_at(int which, bool uncached);
 834   int       impl_name_and_type_ref_index_at(int which, bool uncached);
 835   constantTag impl_tag_ref_at(int which, bool uncached);
 836 
 837   // Used while constructing constant pool (only by ClassFileParser)
 838   jint klass_index_at(int which) {
 839     assert(tag_at(which).is_klass_index(), &quot;Corrupted constant pool&quot;);
 840     return *int_at_addr(which);
 841   }
 842 
 843   jint string_index_at(int which) {
 844     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 845     return *int_at_addr(which);
 846   }
 847 
 848   // Performs the LinkResolver checks
 849   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 850 
 851   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 852   // handle GC while executing the method
 853   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 854                               bool save_resolution_error, TRAPS);
 855   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 856 
 857   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 858 
 859   // Resolve string constants (to prevent allocation during compilation)
 860   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 861 
 862   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 863                                       bool* status_return, TRAPS);
 864   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 865                                                int start_arg, int end_arg,
 866                                                objArrayHandle info, int pos,
 867                                                bool must_resolve, Handle if_not_available, TRAPS);
 868 
 869   // Exception handling
 870   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 871   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 872 
 873  public:
 874   // Exception handling
 875   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 876 
 877   // Merging ConstantPool* support:
 878   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 879   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 880     constantPoolHandle h_this(THREAD, this);
 881     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 882   }
 883   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 884   static void copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 885   static void copy_operands(const constantPoolHandle&amp; from_cp, const constantPoolHandle&amp; to_cp, TRAPS);
 886   int  find_matching_entry(int pattern_i, const constantPoolHandle&amp; search_cp, TRAPS);
 887   int  version() const                    { return _saved._version; }
 888   void set_version(int version)           { _saved._version = version; }
 889   void increment_and_save_version(int version) {
 890     _saved._version = version &gt;= 0 ? (version + 1) : version;  // keep overflow
 891   }
 892 
 893   void set_resolved_reference_length(int length) { _saved._resolved_reference_length = length; }
 894   int  resolved_reference_length() const  { return _saved._resolved_reference_length; }
 895 
 896   // Decrease ref counts of symbols that are in the constant pool
 897   // when the holder class is unloaded
 898   void unreference_symbols();
 899 
 900   // Deallocate constant pool for RedefineClasses
 901   void deallocate_contents(ClassLoaderData* loader_data);
 902   void release_C_heap_structures();
 903 
 904   // JVMTI accesss - GetConstantPool, RetransformClasses, ...
 905   friend class JvmtiConstantPoolReconstituter;
 906 
 907  private:
 908   jint cpool_entry_size(jint idx);
 909   jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);
 910 
 911   // Copy cpool bytes into byte array.
 912   // Returns:
 913   //  int &gt; 0, count of the raw cpool bytes that have been copied
 914   //        0, OutOfMemory error
 915   //       -1, Internal error
 916   int  copy_cpool_bytes(int cpool_size,
 917                         SymbolHashMap* tbl,
 918                         unsigned char *bytes);
 919 
 920  public:
 921   // Verify
 922   void verify_on(outputStream* st);
 923 
 924   // Printing
 925   void print_on(outputStream* st) const;
 926   void print_value_on(outputStream* st) const;
 927   void print_entry_on(int index, outputStream* st);
 928 
 929   const char* internal_name() const { return &quot;{constant pool}&quot;; }
 930 };
 931 
 932 class SymbolHashMapEntry : public CHeapObj&lt;mtSymbol&gt; {
 933  private:
 934   unsigned int        _hash;   // 32-bit hash for item
 935   SymbolHashMapEntry* _next;   // Next element in the linked list for this bucket
 936   Symbol*             _symbol; // 1-st part of the mapping: symbol =&gt; value
 937   u2                  _value;  // 2-nd part of the mapping: symbol =&gt; value
 938 
 939  public:
 940   unsigned   int hash() const             { return _hash;   }
 941   void       set_hash(unsigned int hash)  { _hash = hash;   }
 942 
 943   SymbolHashMapEntry* next() const        { return _next;   }
 944   void set_next(SymbolHashMapEntry* next) { _next = next;   }
 945 
 946   Symbol*    symbol() const               { return _symbol; }
 947   void       set_symbol(Symbol* sym)      { _symbol = sym;  }
 948 
 949   u2         value() const                {  return _value; }
 950   void       set_value(u2 value)          { _value = value; }
 951 
 952   SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)
 953     : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}
 954 
 955 }; // End SymbolHashMapEntry class
 956 
 957 
 958 class SymbolHashMapBucket : public CHeapObj&lt;mtSymbol&gt; {
 959 
 960 private:
 961   SymbolHashMapEntry*    _entry;
 962 
 963 public:
 964   SymbolHashMapEntry* entry() const         {  return _entry; }
 965   void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }
 966   void clear()                              { _entry = NULL;  }
 967 
 968 }; // End SymbolHashMapBucket class
 969 
 970 
 971 class SymbolHashMap: public CHeapObj&lt;mtSymbol&gt; {
 972 
 973  private:
 974   // Default number of entries in the table
 975   enum SymbolHashMap_Constants {
 976     _Def_HashMap_Size = 256
 977   };
 978 
 979   int                   _table_size;
 980   SymbolHashMapBucket*  _buckets;
 981 
 982   void initialize_table(int table_size);
 983 
 984  public:
 985 
 986   int table_size() const        { return _table_size; }
 987 
 988   SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }
 989   SymbolHashMap(int table_size) { initialize_table(table_size); }
 990 
 991   // hash P(31) from Kernighan &amp; Ritchie
 992   static unsigned int compute_hash(const char* str, int len) {
 993     unsigned int hash = 0;
 994     while (len-- &gt; 0) {
 995       hash = 31*hash + (unsigned) *str;
 996       str++;
 997     }
 998     return hash;
 999   }
1000 
1001   SymbolHashMapEntry* bucket(int i) {
1002     return _buckets[i].entry();
1003   }
1004 
1005   void add_entry(Symbol* sym, u2 value);
1006   SymbolHashMapEntry* find_entry(Symbol* sym);
1007 
1008   u2 symbol_to_value(Symbol* sym) {
1009     SymbolHashMapEntry *entry = find_entry(sym);
1010     return (entry == NULL) ? 0 : entry-&gt;value();
1011   }
1012 
1013   ~SymbolHashMap();
1014 }; // End SymbolHashMap class
1015 
1016 #endif // SHARE_OOPS_CONSTANTPOOL_HPP
    </pre>
  </body>
</html>
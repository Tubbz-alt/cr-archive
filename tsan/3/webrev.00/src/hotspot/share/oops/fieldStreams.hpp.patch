diff a/src/hotspot/share/oops/fieldStreams.hpp b/src/hotspot/share/oops/fieldStreams.hpp
--- a/src/hotspot/share/oops/fieldStreams.hpp
+++ b/src/hotspot/share/oops/fieldStreams.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -45,11 +45,10 @@
   int                 _limit;
   int                 _generic_signature_slot;
   fieldDescriptor     _fd_buf;
 
   FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }
-  InstanceKlass* field_holder() const { return _constants->pool_holder(); }
 
   int init_generic_signature_start_slot() {
     int length = _fields->length();
     int num_fields = _index;
     int skipped_generic_signature_slots = 0;
@@ -77,41 +76,19 @@
     _generic_signature_slot = length + skipped_generic_signature_slots;
     assert(_generic_signature_slot <= _fields->length(), "");
     return num_fields;
   }
 
-  FieldStreamBase(Array<u2>* fields, const constantPoolHandle& constants, int start, int limit) {
-    _fields = fields;
-    _constants = constants;
-    _index = start;
-    int num_fields = init_generic_signature_start_slot();
-    if (limit < start) {
-      _limit = num_fields;
-    } else {
-      _limit = limit;
-    }
-  }
-
-  FieldStreamBase(Array<u2>* fields, const constantPoolHandle& constants) {
-    _fields = fields;
-    _constants = constants;
-    _index = 0;
-    _limit = init_generic_signature_start_slot();
-  }
+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit);
 
+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants);
  public:
-  FieldStreamBase(InstanceKlass* klass) {
-    _fields = klass->fields();
-    _constants = klass->constants();
-    _index = 0;
-    _limit = klass->java_fields_count();
-    init_generic_signature_start_slot();
-    assert(klass == field_holder(), "");
-  }
+  inline FieldStreamBase(InstanceKlass* klass);
 
   // accessors
   int index() const                 { return _index; }
+  InstanceKlass* field_holder() const { return _constants->pool_holder(); }
 
   void next() {
     if (access_flags().field_has_generic_signature()) {
       _generic_signature_slot ++;
       assert(_generic_signature_slot <= _fields->length(), "");
@@ -134,15 +111,15 @@
   void set_access_flags(AccessFlags flags) const {
     set_access_flags(flags.as_short());
   }
 
   Symbol* name() const {
-    return field()->name(_constants);
+    return field()->name(_constants());
   }
 
   Symbol* signature() const {
-    return field()->signature(_constants);
+    return field()->signature(_constants());
   }
 
   Symbol* generic_signature() const {
     if (access_flags().field_has_generic_signature()) {
       assert(_generic_signature_slot < _fields->length(), "out of bounds");
@@ -240,10 +217,10 @@
 };
 
 
 class AllFieldStream : public FieldStreamBase {
  public:
-  AllFieldStream(Array<u2>* fields, const constantPoolHandle& constants): FieldStreamBase(fields, constants) {}
+  AllFieldStream(Array<u2>* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}
   AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants()) {}
 };
 
 #endif // SHARE_OOPS_FIELDSTREAMS_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
  class AdapterHandlerEntry;
  class MethodData;
  class MethodCounters;
  class ConstMethod;
  class InlineTableSizes;
<span class="line-removed">- class KlassSizeStats;</span>
  class CompiledMethod;
  class InterpreterOopMap;
  
  class Method : public Metadata {
   friend class VMStructs;
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,20 ***</span>
    AnnotationArray* type_annotations() const      {
      return constMethod()-&gt;type_annotations();
    }
  
    // Helper routine: get klass name + &quot;.&quot; + method name + signature as
<span class="line-modified">!   // C string, for the purpose of providing more useful NoSuchMethodErrors</span>
<span class="line-modified">!   // and fatal error handling. The string is allocated in resource</span>
    // area if a buffer is not provided by the caller.
    char* name_and_sig_as_C_string() const;
    char* name_and_sig_as_C_string(char* buf, int size) const;
  
    // Static routine in the situations we don&#39;t have a Method*
    static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature);
    static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature, char* buf, int size);
  
    Bytecodes::Code java_code_at(int bci) const {
      return Bytecodes::java_code_at(this, bcp_from(bci));
    }
    Bytecodes::Code code_at(int bci) const {
      return Bytecodes::code_at(this, bcp_from(bci));
<span class="line-new-header">--- 177,32 ---</span>
    AnnotationArray* type_annotations() const      {
      return constMethod()-&gt;type_annotations();
    }
  
    // Helper routine: get klass name + &quot;.&quot; + method name + signature as
<span class="line-modified">!   // C string, for the purpose of providing more useful</span>
<span class="line-modified">!   // fatal error handling. The string is allocated in resource</span>
    // area if a buffer is not provided by the caller.
    char* name_and_sig_as_C_string() const;
    char* name_and_sig_as_C_string(char* buf, int size) const;
  
    // Static routine in the situations we don&#39;t have a Method*
    static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature);
    static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature, char* buf, int size);
  
<span class="line-added">+   // Get return type + klass name + &quot;.&quot; + method name + ( parameters types )</span>
<span class="line-added">+   // as a C string or print it to an outputStream.</span>
<span class="line-added">+   // This is to be used to assemble strings passed to Java, so that</span>
<span class="line-added">+   // the text more resembles Java code. Used in exception messages.</span>
<span class="line-added">+   // Memory is allocated in the resource area; the caller needs</span>
<span class="line-added">+   // a ResourceMark.</span>
<span class="line-added">+   const char* external_name() const;</span>
<span class="line-added">+   void  print_external_name(outputStream *os) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   static const char* external_name(                  Klass* klass, Symbol* method_name, Symbol* signature);</span>
<span class="line-added">+   static void  print_external_name(outputStream *os, Klass* klass, Symbol* method_name, Symbol* signature);</span>
<span class="line-added">+ </span>
    Bytecodes::Code java_code_at(int bci) const {
      return Bytecodes::java_code_at(this, bcp_from(bci));
    }
    Bytecodes::Code code_at(int bci) const {
      return Bytecodes::code_at(this, bcp_from(bci));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,11 ***</span>
      } else {
        return mcs-&gt;interpreter_throwout_count();
      }
    }
  
<span class="line-modified">!   // size of parameters</span>
    int  size_of_parameters() const                { return constMethod()-&gt;size_of_parameters(); }
    void set_size_of_parameters(int size)          { constMethod()-&gt;set_size_of_parameters(size); }
  
    bool has_stackmap_table() const {
      return constMethod()-&gt;has_stackmap_table();
<span class="line-new-header">--- 305,14 ---</span>
      } else {
        return mcs-&gt;interpreter_throwout_count();
      }
    }
  
<span class="line-modified">!   // Derive stuff from the signature at load time.</span>
<span class="line-added">+   void compute_from_signature(Symbol* sig);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // size of parameters (receiver if any + arguments)</span>
    int  size_of_parameters() const                { return constMethod()-&gt;size_of_parameters(); }
    void set_size_of_parameters(int size)          { constMethod()-&gt;set_size_of_parameters(size); }
  
    bool has_stackmap_table() const {
      return constMethod()-&gt;has_stackmap_table();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,10 ***</span>
<span class="line-new-header">--- 346,16 ---</span>
    // exception handler which caused the exception to be thrown, which
    // is needed for proper retries. See, for example,
    // InterpreterRuntime::exception_handler_for_exception.
    static int fast_exception_handler_bci_for(const methodHandle&amp; mh, Klass* ex_klass, int throw_bci, TRAPS);
  
<span class="line-added">+   static bool register_native(Klass* k,</span>
<span class="line-added">+                               Symbol* name,</span>
<span class="line-added">+                               Symbol* signature,</span>
<span class="line-added">+                               address entry,</span>
<span class="line-added">+                               TRAPS);</span>
<span class="line-added">+ </span>
    // method data access
    MethodData* method_data() const              {
      return _method_data;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,22 ***</span>
  
    // nmethod/verified compiler entry
    address verified_code_entry();
    bool check_code() const;      // Not inline to avoid circular ref
    CompiledMethod* volatile code() const;
<span class="line-modified">!   void clear_code(bool acquire_lock = true);    // Clear out any compiled code</span>
    static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
    void set_adapter_entry(AdapterHandlerEntry* adapter) {
      constMethod()-&gt;set_adapter_entry(adapter);
    }
    void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
      constMethod()-&gt;update_adapter_trampoline(adapter);
    }
  
    address get_i2c_entry();
    address get_c2i_entry();
    address get_c2i_unverified_entry();
    AdapterHandlerEntry* adapter() const {
      return constMethod()-&gt;adapter();
    }
    // setup entry points
    void link_method(const methodHandle&amp; method, TRAPS);
<span class="line-new-header">--- 469,39 ---</span>
  
    // nmethod/verified compiler entry
    address verified_code_entry();
    bool check_code() const;      // Not inline to avoid circular ref
    CompiledMethod* volatile code() const;
<span class="line-modified">! </span>
<span class="line-added">+   // Locks CompiledMethod_lock if not held.</span>
<span class="line-added">+   void unlink_code(CompiledMethod *compare);</span>
<span class="line-added">+   // Locks CompiledMethod_lock if not held.</span>
<span class="line-added">+   void unlink_code();</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+   // Either called with CompiledMethod_lock held or from constructor.</span>
<span class="line-added">+   void clear_code();</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
    static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
    void set_adapter_entry(AdapterHandlerEntry* adapter) {
      constMethod()-&gt;set_adapter_entry(adapter);
    }
<span class="line-added">+   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {</span>
<span class="line-added">+     constMethod()-&gt;set_adapter_trampoline(trampoline);</span>
<span class="line-added">+   }</span>
    void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
      constMethod()-&gt;update_adapter_trampoline(adapter);
    }
<span class="line-added">+   void set_from_compiled_entry(address entry) {</span>
<span class="line-added">+     _from_compiled_entry =  entry;</span>
<span class="line-added">+   }</span>
  
    address get_i2c_entry();
    address get_c2i_entry();
    address get_c2i_unverified_entry();
<span class="line-added">+   address get_c2i_no_clinit_check_entry();</span>
    AdapterHandlerEntry* adapter() const {
      return constMethod()-&gt;adapter();
    }
    // setup entry points
    void link_method(const methodHandle&amp; method, TRAPS);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 497,11 ***</span>
  
    // interpreter entry
    address interpreter_entry() const              { return _i2i_entry; }
    // Only used when first initialize so we can set _i2i_entry and _from_interpreted_entry
    void set_interpreter_entry(address entry) {
<span class="line-modified">!     assert(!is_shared(), &quot;shared method&#39;s interpreter entry should not be changed at run time&quot;);</span>
      if (_i2i_entry != entry) {
        _i2i_entry = entry;
      }
      if (_from_interpreted_entry != entry) {
        _from_interpreted_entry = entry;
<span class="line-new-header">--- 534,12 ---</span>
  
    // interpreter entry
    address interpreter_entry() const              { return _i2i_entry; }
    // Only used when first initialize so we can set _i2i_entry and _from_interpreted_entry
    void set_interpreter_entry(address entry) {
<span class="line-modified">!     assert(!is_shared(),</span>
<span class="line-added">+            &quot;shared method&#39;s interpreter entry should not be changed at run time&quot;);</span>
      if (_i2i_entry != entry) {
        _i2i_entry = entry;
      }
      if (_from_interpreted_entry != entry) {
        _from_interpreted_entry = entry;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,11 ***</span>
    // native function (used for native methods only)
    enum {
      native_bind_event_is_interesting = true
    };
    address native_function() const                { return *(native_function_addr()); }
<span class="line-removed">-   address critical_native_function();</span>
  
    // Must specify a real function (not NULL).
    // Use clear_native_function() to unregister.
    void set_native_function(address function, bool post_event_flag);
    bool has_native_function() const;
<span class="line-new-header">--- 549,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,14 ***</span>
                         { return constMethod()-&gt;compressed_linenumber_table(); }
  
    // method holder (the Klass* holding this method)
    InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
  
<span class="line-removed">-   void compute_size_of_parameters(Thread *thread); // word size of parameters (receiver if any + arguments)</span>
    Symbol* klass_name() const;                    // returns the name of the method holder
<span class="line-modified">!   BasicType result_type() const;                 // type of the method result</span>
<span class="line-modified">!   bool is_returning_oop() const                  { BasicType r = result_type(); return (r == T_OBJECT || r == T_ARRAY); }</span>
    bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }
  
    // Checked exceptions thrown by this method (resolved to mirrors)
    objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
  
<span class="line-new-header">--- 606,13 ---</span>
                         { return constMethod()-&gt;compressed_linenumber_table(); }
  
    // method holder (the Klass* holding this method)
    InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
  
    Symbol* klass_name() const;                    // returns the name of the method holder
<span class="line-modified">!   BasicType result_type() const                  { return constMethod()-&gt;result_type(); }</span>
<span class="line-modified">!   bool is_returning_oop() const                  { BasicType r = result_type(); return is_reference_type(r); }</span>
    bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }
  
    // Checked exceptions thrown by this method (resolved to mirrors)
    objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,10 ***</span>
<span class="line-new-header">--- 641,11 ---</span>
    // interface method declared with &#39;default&#39; - excludes private interface methods
    bool is_default_method() const;
  
    // true if method needs no dynamic dispatch (final and/or no vtable entry)
    bool can_be_statically_bound() const;
<span class="line-added">+   bool can_be_statically_bound(InstanceKlass* context) const;</span>
    bool can_be_statically_bound(AccessFlags class_access_flags) const;
  
    // returns true if the method has any backward branches.
    bool has_loops() {
      return access_flags().loops_flag_init() ? access_flags().has_loops() : compute_has_loops_flag();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,19 ***</span>
  
  #ifdef TIERED
    bool has_aot_code() const                      { return aot_code() != NULL; }
  #endif
  
    // sizing
    static int header_size()                       {
      return align_up((int)sizeof(Method), wordSize) / wordSize;
    }
    static int size(bool is_native);
    int size() const                               { return method_size(); }
<span class="line-removed">- #if INCLUDE_SERVICES</span>
<span class="line-removed">-   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">- #endif</span>
    void log_touched(TRAPS);
    static void print_touched_methods(outputStream* out);
  
    // interpreter support
    static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
<span class="line-new-header">--- 704,18 ---</span>
  
  #ifdef TIERED
    bool has_aot_code() const                      { return aot_code() != NULL; }
  #endif
  
<span class="line-added">+   bool needs_clinit_barrier() const;</span>
<span class="line-added">+ </span>
    // sizing
    static int header_size()                       {
      return align_up((int)sizeof(Method), wordSize) / wordSize;
    }
    static int size(bool is_native);
    int size() const                               { return method_size(); }
    void log_touched(TRAPS);
    static void print_touched_methods(outputStream* out);
  
    // interpreter support
    static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 816,11 ***</span>
    // Clear methods
    static void clear_jmethod_ids(ClassLoaderData* loader_data);
    static void print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;
  
    // Get this method&#39;s jmethodID -- allocate if it doesn&#39;t exist
<span class="line-modified">!   jmethodID jmethod_id()                            { return method_holder()-&gt;get_jmethod_id(this); }</span>
  
    // Lookup the jmethodID for this method.  Return NULL if not found.
    // NOTE that this function can be called from a signal handler
    // (see AsyncGetCallTrace support for Forte Analyzer) and this
    // needs to be async-safe. No allocation should be done and
<span class="line-new-header">--- 852,11 ---</span>
    // Clear methods
    static void clear_jmethod_ids(ClassLoaderData* loader_data);
    static void print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;
  
    // Get this method&#39;s jmethodID -- allocate if it doesn&#39;t exist
<span class="line-modified">!   jmethodID jmethod_id();</span>
  
    // Lookup the jmethodID for this method.  Return NULL if not found.
    // NOTE that this function can be called from a signal handler
    // (see AsyncGetCallTrace support for Forte Analyzer) and this
    // needs to be async-safe. No allocation should be done and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,18 ***</span>
  
    // Indicates whether compilation failed earlier for this method, or
    // whether it is not compilable for another reason like having a
    // breakpoint set in it.
    bool  is_not_compilable(int comp_level = CompLevel_any) const;
<span class="line-modified">!   void set_not_compilable(int comp_level = CompLevel_all, bool report = true, const char* reason = NULL);</span>
<span class="line-modified">!   void set_not_compilable_quietly(int comp_level = CompLevel_all) {</span>
<span class="line-modified">!     set_not_compilable(comp_level, false);</span>
    }
    bool  is_not_osr_compilable(int comp_level = CompLevel_any) const;
<span class="line-modified">!   void set_not_osr_compilable(int comp_level = CompLevel_all, bool report = true, const char* reason = NULL);</span>
<span class="line-modified">!   void set_not_osr_compilable_quietly(int comp_level = CompLevel_all) {</span>
<span class="line-modified">!     set_not_osr_compilable(comp_level, false);</span>
    }
    bool is_always_compilable() const;
  
   private:
    void print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason);
<span class="line-new-header">--- 947,18 ---</span>
  
    // Indicates whether compilation failed earlier for this method, or
    // whether it is not compilable for another reason like having a
    // breakpoint set in it.
    bool  is_not_compilable(int comp_level = CompLevel_any) const;
<span class="line-modified">!   void set_not_compilable(const char* reason, int comp_level = CompLevel_all, bool report = true);</span>
<span class="line-modified">!   void set_not_compilable_quietly(const char* reason, int comp_level = CompLevel_all) {</span>
<span class="line-modified">!     set_not_compilable(reason, comp_level, false);</span>
    }
    bool  is_not_osr_compilable(int comp_level = CompLevel_any) const;
<span class="line-modified">!   void set_not_osr_compilable(const char* reason, int comp_level = CompLevel_all, bool report = true);</span>
<span class="line-modified">!   void set_not_osr_compilable_quietly(const char* reason, int comp_level = CompLevel_all) {</span>
<span class="line-modified">!     set_not_osr_compilable(reason, comp_level, false);</span>
    }
    bool is_always_compilable() const;
  
   private:
    void print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,16 ***</span>
    void print_name(outputStream* st = tty); // prints as &quot;virtual void foo(int)&quot;; exposed for TraceRedefineClasses
  #else
    void print_name(outputStream* st = tty)        PRODUCT_RETURN; // prints as &quot;virtual void foo(int)&quot;
  #endif
  
    // Helper routine used for method sorting
<span class="line-modified">!   static void sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums = true);</span>
  
    // Deallocation function for redefine classes or if an error occurs
    void deallocate_contents(ClassLoaderData* loader_data);
  
    Method* get_new_method() const {
      InstanceKlass* holder = method_holder();
      Method* new_method = holder-&gt;method_with_idnum(orig_method_idnum());
  
      assert(new_method != NULL, &quot;method_with_idnum() should not be NULL&quot;);
<span class="line-new-header">--- 1002,20 ---</span>
    void print_name(outputStream* st = tty); // prints as &quot;virtual void foo(int)&quot;; exposed for TraceRedefineClasses
  #else
    void print_name(outputStream* st = tty)        PRODUCT_RETURN; // prints as &quot;virtual void foo(int)&quot;
  #endif
  
<span class="line-added">+   typedef int (*method_comparator_func)(Method* a, Method* b);</span>
<span class="line-added">+ </span>
    // Helper routine used for method sorting
<span class="line-modified">!   static void sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums = true, method_comparator_func func = NULL);</span>
  
    // Deallocation function for redefine classes or if an error occurs
    void deallocate_contents(ClassLoaderData* loader_data);
  
<span class="line-added">+   void release_C_heap_structures();</span>
<span class="line-added">+ </span>
    Method* get_new_method() const {
      InstanceKlass* holder = method_holder();
      Method* new_method = holder-&gt;method_with_idnum(orig_method_idnum());
  
      assert(new_method != NULL, &quot;method_with_idnum() should not be NULL&quot;);
</pre>
<center><a href="method.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
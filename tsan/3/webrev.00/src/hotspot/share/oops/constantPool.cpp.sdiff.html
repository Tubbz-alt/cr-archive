<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;

  33 #include &quot;interpreter/linkResolver.hpp&quot;
  34 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed">  35 #include &quot;memory/heapInspection.hpp&quot;</span>
  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;

  42 #include &quot;oops/array.hpp&quot;
  43 #include &quot;oops/constantPool.inline.hpp&quot;
  44 #include &quot;oops/cpCache.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/objArrayKlass.hpp&quot;
  47 #include &quot;oops/objArrayOop.inline.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-modified">  50 #include &quot;runtime/fieldType.hpp&quot;</span>
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/init.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/signature.hpp&quot;
  55 #include &quot;runtime/thread.inline.hpp&quot;
  56 #include &quot;runtime/vframe.inline.hpp&quot;
  57 #include &quot;utilities/copy.hpp&quot;
  58 
  59 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  60   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  61   int size = ConstantPool::size(length);
  62   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  63 }
  64 
  65 #ifdef ASSERT
  66 
  67 // MetaspaceObj allocation invariant is calloc equivalent memory
  68 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  69 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  70   assert(tags != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 213       // All of these should have been reverted back to ClassIndex before calling
 214       // this function.
 215       ShouldNotReachHere();
 216 #endif
 217     }
 218   }
 219   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 220 }
 221 
 222 // Unsafe anonymous class support:
 223 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 224   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 225   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 226   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 227   *int_at_addr(class_index) =
 228     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 229 
 230   symbol_at_put(name_index, name);
 231   name-&gt;increment_refcount();
 232   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 233   OrderAccess::release_store(adr, k);</span>
 234 
 235   // The interpreter assumes when the tag is stored, the klass is resolved
 236   // and the Klass* non-NULL, so we need hardware store ordering here.
 237   if (k != NULL) {
 238     release_tag_at_put(class_index, JVM_CONSTANT_Class);
 239   } else {
 240     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);
 241   }
 242 }
 243 
 244 // Unsafe anonymous class support:
 245 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 246   assert(k != NULL, &quot;must be valid klass&quot;);
 247   CPKlassSlot kslot = klass_slot_at(class_index);
 248   int resolved_klass_index = kslot.resolved_klass_index();
 249   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 250   OrderAccess::release_store(adr, k);</span>
 251 
 252   // The interpreter assumes when the tag is stored, the klass is resolved
 253   // and the Klass* non-NULL, so we need hardware store ordering here.
 254   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 255 }
 256 
 257 #if INCLUDE_CDS_JAVA_HEAP
 258 // Archive the resolved references
 259 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 260   if (_cache == NULL) {
 261     return; // nothing to do
 262   }
 263 
 264   InstanceKlass *ik = pool_holder();
 265   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 266         ik-&gt;is_shared_app_class())) {
 267     // Archiving resolved references for classes from non-builtin loaders
 268     // is not yet supported.
 269     set_resolved_references(NULL);
 270     return;
 271   }
 272 
 273   objArrayOop rr = resolved_references();
 274   Array&lt;u2&gt;* ref_map = reference_map();
 275   if (rr != NULL) {
 276     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 277     int rr_len = rr-&gt;length();
 278     for (int i = 0; i &lt; rr_len; i++) {
 279       oop p = rr-&gt;obj_at(i);
 280       rr-&gt;obj_at_put(i, NULL);
 281       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 282         int index = object_to_cp_index(i);
<span class="line-modified"> 283         // Skip the entry if the string hash code is 0 since the string</span>
<span class="line-removed"> 284         // is not included in the shared string_table, see StringTable::copy_shared_string.</span>
<span class="line-removed"> 285         if (tag_at(index).is_string() &amp;&amp; java_lang_String::hash_code(p) != 0) {</span>
 286           oop op = StringTable::create_archived_string(p, THREAD);
 287           // If the String object is not archived (possibly too large),
 288           // NULL is returned. Also set it in the array, so we won&#39;t
 289           // have a &#39;bad&#39; reference in the archived resolved_reference
 290           // array.
 291           rr-&gt;obj_at_put(i, op);
 292         }
 293       }
 294     }
 295 
 296     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 297     // If the resolved references array is not archived (too large),
 298     // the &#39;archived&#39; object is NULL. No need to explicitly check
 299     // the return value of archive_heap_object here. At runtime, the
 300     // resolved references will be created using the normal process
 301     // when there is no archived value.
 302     _cache-&gt;set_archived_references(archived);
 303     set_resolved_references(NULL);
 304   }
 305 }
</pre>
<hr />
<pre>
 354         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 355         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 356         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 357       }
 358     }
 359   }
 360 }
 361 
 362 void ConstantPool::remove_unshareable_info() {
 363   // Resolved references are not in the shared archive.
 364   // Save the length for restoration.  It is not necessarily the same length
 365   // as reference_map.length() if invokedynamic is saved. It is needed when
 366   // re-creating the resolved reference array if archived heap data cannot be map
 367   // at runtime.
 368   set_resolved_reference_length(
 369     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 370 
 371   // If archiving heap objects is not allowed, clear the resolved references.
 372   // Otherwise, it is cleared after the resolved references array is cached
 373   // (see archive_resolved_references()).
<span class="line-modified"> 374   if (!HeapShared::is_heap_object_archiving_allowed()) {</span>


 375     set_resolved_references(NULL);
 376   }
 377 
 378   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 379   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 380   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 381   // we always set _on_stack to true to avoid having to change _flags during runtime.
 382   _flags |= (_on_stack | _is_shared);
 383   int num_klasses = 0;
 384   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
<span class="line-modified"> 385     assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during dump time&quot;);</span>









 386     if (tag_at(index).is_klass()) {
 387       // This class was resolved as a side effect of executing Java code
 388       // during dump time. We need to restore it back to an UnresolvedClass,
 389       // so that the proper class loading and initialization can happen
 390       // at runtime.
 391       CPKlassSlot kslot = klass_slot_at(index);
 392       int resolved_klass_index = kslot.resolved_klass_index();
 393       int name_index = kslot.name_index();
 394       assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 395       resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 396       tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 397       assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 398     }
 399   }
 400   if (cache() != NULL) {
 401     cache()-&gt;remove_unshareable_info();
 402   }
 403 }
 404 
 405 int ConstantPool::cp_to_object_index(int cp_index) {
</pre>
<hr />
<pre>
 497   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 498   if (HAS_PENDING_EXCEPTION) {
 499     if (save_resolution_error) {
 500       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 501       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 502       // some other thread has beaten us and has resolved the class.
 503       // To preserve old behavior, we return the resolved class.
 504       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 505       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 506       return klass;
 507     } else {
 508       return NULL;  // return the pending exception
 509     }
 510   }
 511 
 512   // logging for class+resolve.
 513   if (log_is_enabled(Debug, class, resolve)){
 514     trace_class_resolution(this_cp, k);
 515   }
 516   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 517   OrderAccess::release_store(adr, k);</span>
 518   // The interpreter assumes when the tag is stored, the klass is resolved
 519   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 520   // hardware store ordering here.
 521   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);
 522   return k;
 523 }
 524 
 525 
 526 // Does not update ConstantPool* - to avoid any exception throwing. Used
 527 // by compiler and exception handling.  Also used to avoid classloads for
 528 // instanceof operations. Returns NULL if the class has not been loaded or
 529 // if the verification of constant pool failed
 530 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 531   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 532   int resolved_klass_index = kslot.resolved_klass_index();
 533   int name_index = kslot.name_index();
 534   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 535 
 536   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 537   if (k != NULL) {
 538     return k;
 539   } else {
 540     Thread *thread = Thread::current();
 541     Symbol* name = this_cp-&gt;symbol_at(name_index);
 542     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 543     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 544     Handle h_prot (thread, protection_domain);
 545     Handle h_loader (thread, loader);
 546     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 547 
<span class="line-modified"> 548     if (k != NULL) {</span>

 549       // Make sure that resolving is legal
 550       EXCEPTION_MARK;
 551       // return NULL if verification fails
 552       verify_constant_pool_resolve(this_cp, k, THREAD);
 553       if (HAS_PENDING_EXCEPTION) {
 554         CLEAR_PENDING_EXCEPTION;
 555         return NULL;
 556       }
 557       return k;
 558     } else {
 559       return k;
 560     }
 561   }
 562 }
 563 
 564 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 565                                                    int which) {
 566   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 567   int cache_index = decode_cpcache_index(which, true);
 568   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
</pre>
<hr />
<pre>
 699 
 700 Symbol* ConstantPool::klass_name_at(int which) const {
 701   return symbol_at(klass_slot_at(which).name_index());
 702 }
 703 
 704 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 705   jint ref_index = klass_ref_index_at(which);
 706   return klass_at_noresolve(ref_index);
 707 }
 708 
 709 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 710   jint ref_index = uncached_klass_ref_index_at(which);
 711   return klass_at_noresolve(ref_index);
 712 }
 713 
 714 char* ConstantPool::string_at_noresolve(int which) {
 715   return unresolved_string_at(which)-&gt;as_C_string();
 716 }
 717 
 718 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
<span class="line-modified"> 719   return FieldType::basic_type(symbol_at(which));</span>
 720 }
 721 
 722 
 723 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 724   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 725     if (this_cp-&gt;tag_at(index).is_string()) {
 726       this_cp-&gt;string_at(index, CHECK);
 727     }
 728   }
 729 }
 730 
 731 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 732   // Dig out the detailed message to reuse if possible
 733   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 734   if (message != NULL) {
 735     return message;
 736   }
 737 
 738   // Return specific message for the tag
 739   switch (tag.value()) {
 740   case JVM_CONSTANT_UnresolvedClass:
 741     // return the class name in the error message
 742     message = this_cp-&gt;klass_name_at(which);
 743     break;
 744   case JVM_CONSTANT_MethodHandle:
 745     // return the method handle name in the error message
 746     message = this_cp-&gt;method_handle_name_ref_at(which);
 747     break;
 748   case JVM_CONSTANT_MethodType:
 749     // return the method type signature in the error message
 750     message = this_cp-&gt;method_type_signature_at(which);
 751     break;




 752   default:
 753     ShouldNotReachHere();
 754   }
 755 
 756   return message;
 757 }
 758 
 759 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 760   Symbol* message = NULL;
 761   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 762   assert(error != NULL, &quot;checking&quot;);
 763   CLEAR_PENDING_EXCEPTION;
 764   if (message != NULL) {
 765     ResourceMark rm;
 766     THROW_MSG(error, message-&gt;as_C_string());
 767   } else {
 768     THROW(error);
 769   }
 770 }
 771 
</pre>
<hr />
<pre>
 775                                             constantTag tag, TRAPS) {
 776   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 777 
 778   int error_tag = tag.error_value();
 779 
 780   if (!PENDING_EXCEPTION-&gt;
 781     is_a(SystemDictionary::LinkageError_klass())) {
 782     // Just throw the exception and don&#39;t prevent these classes from
 783     // being loaded due to virtual machine errors like StackOverflow
 784     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 785     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 786   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 787     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 788     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 789     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 790     // If another thread resolved the reference, this is a race condition. This
 791     // thread may have had a security manager or something temporary.
 792     // This doesn&#39;t deterministically get an error.   So why do we save this?
 793     // We save this because jvmti can add classes to the bootclass path after
 794     // this error, so it needs to get the same error if the error is first.
<span class="line-modified"> 795     jbyte old_tag = Atomic::cmpxchg((jbyte)error_tag,</span>
<span class="line-modified"> 796                             (jbyte*)this_cp-&gt;tag_addr_at(which), (jbyte)tag.value());</span>

 797     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 798       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 799       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 800       // Forget the exception and use the resolved class.
 801       CLEAR_PENDING_EXCEPTION;
 802     }
 803   } else {
 804     // some other thread put this in error state
 805     throw_resolution_error(this_cp, which, CHECK);
 806   }
 807 }
 808 
 809 constantTag ConstantPool::constant_tag_at(int which) {
 810   constantTag tag = tag_at(which);
 811   if (tag.is_dynamic_constant() ||
 812       tag.is_dynamic_constant_in_error()) {
 813     BasicType bt = basic_type_for_constant_at(which);
 814     // dynamic constant could return an array, treat as object
 815     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 816   }
 817   return tag;
 818 }
 819 
 820 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 821   constantTag tag = tag_at(which);
 822   if (tag.is_dynamic_constant() ||
 823       tag.is_dynamic_constant_in_error()) {
 824     // have to look at the signature for this one
 825     Symbol* constant_type = uncached_signature_ref_at(which);
<span class="line-modified"> 826     return FieldType::basic_type(constant_type);</span>
 827   }
 828   return tag.basic_type();
 829 }
 830 
 831 // Called to resolve constants in the constant pool and return an oop.
 832 // Some constant pool entries cache their resolved oop. This is also
 833 // called to create oops from constants to use in arguments for invokedynamic
 834 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 835                                            int index, int cache_index,
 836                                            bool* status_return, TRAPS) {
 837   oop result_oop = NULL;
 838   Handle throw_exception;
 839 
 840   if (cache_index == _possible_index_sentinel) {
 841     // It is possible that this constant is one which is cached in the objects.
 842     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 843     // FIXME: If bootstrap specifiers stress this code, consider putting in
 844     // a reverse index.  Binary search over a short array should do it.
 845     assert(index &gt; 0, &quot;valid index&quot;);
 846     cache_index = this_cp-&gt;cp_to_object_index(index);
 847   }
 848   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 849   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 850 
 851   if (cache_index &gt;= 0) {
 852     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 853     if (result_oop != NULL) {
<span class="line-modified"> 854       if (oopDesc::equals(result_oop, Universe::the_null_sentinel())) {</span>
 855         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 856         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 857         result_oop = NULL;
 858       }
 859       if (status_return != NULL)  (*status_return) = true;
 860       return result_oop;
 861       // That was easy...
 862     }
 863     index = this_cp-&gt;object_to_cp_index(cache_index);
 864   }
 865 
 866   jvalue prim_value;  // temp used only in a few cases below
 867 
 868   constantTag tag = this_cp-&gt;tag_at(index);
 869 
 870   if (status_return != NULL) {
 871     // don&#39;t trigger resolution if the constant might need it
 872     switch (tag.value()) {
 873     case JVM_CONSTANT_Class:
 874     {
</pre>
<hr />
<pre>
 894     }
 895     // from now on there is either success or an OOME
 896     (*status_return) = true;
 897   }
 898 
 899   switch (tag.value()) {
 900 
 901   case JVM_CONSTANT_UnresolvedClass:
 902   case JVM_CONSTANT_UnresolvedClassInError:
 903   case JVM_CONSTANT_Class:
 904     {
 905       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 906       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 907       // ldc wants the java mirror.
 908       result_oop = resolved-&gt;java_mirror();
 909       break;
 910     }
 911 
 912   case JVM_CONSTANT_Dynamic:
 913     {
<span class="line-modified"> 914       Klass* current_klass  = this_cp-&gt;pool_holder();</span>
<span class="line-modified"> 915       Symbol* constant_name = this_cp-&gt;uncached_name_ref_at(index);</span>
<span class="line-removed"> 916       Symbol* constant_type = this_cp-&gt;uncached_signature_ref_at(index);</span>
 917 
 918       // The initial step in resolving an unresolved symbolic reference to a
 919       // dynamically-computed constant is to resolve the symbolic reference to a
 920       // method handle which will be the bootstrap method for the dynamically-computed
 921       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 922       // method fails, then a MethodHandleInError is stored at the corresponding
 923       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 924       // set a DynamicConstantInError here since any subsequent use of this
 925       // bootstrap method will encounter the resolution of MethodHandleInError.
<span class="line-modified"> 926       oop bsm_info = this_cp-&gt;resolve_bootstrap_specifier_at(index, THREAD);</span>
<span class="line-modified"> 927       Exceptions::wrap_dynamic_exception(CHECK_NULL);</span>
<span class="line-modified"> 928       assert(bsm_info != NULL, &quot;&quot;);</span>
<span class="line-modified"> 929       // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_Dynamic.</span>
<span class="line-removed"> 930       Handle bootstrap_specifier = Handle(THREAD, bsm_info);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.</span>
<span class="line-removed"> 933       Handle value = SystemDictionary::link_dynamic_constant(current_klass,</span>
<span class="line-removed"> 934                                                              index,</span>
<span class="line-removed"> 935                                                              bootstrap_specifier,</span>
<span class="line-removed"> 936                                                              constant_name,</span>
<span class="line-removed"> 937                                                              constant_type,</span>
<span class="line-removed"> 938                                                              THREAD);</span>
<span class="line-removed"> 939       result_oop = value();</span>
 940       Exceptions::wrap_dynamic_exception(THREAD);
 941       if (HAS_PENDING_EXCEPTION) {
 942         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 943         // will check for a LinkageError and store a DynamicConstantInError.
 944         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 945       }
<span class="line-modified"> 946       BasicType type = FieldType::basic_type(constant_type);</span>

 947       if (!is_reference_type(type)) {
 948         // Make sure the primitive value is properly boxed.
 949         // This is a JDK responsibility.
 950         const char* fail = NULL;
 951         if (result_oop == NULL) {
 952           fail = &quot;null result instead of box&quot;;
 953         } else if (!is_java_primitive(type)) {
 954           // FIXME: support value types via unboxing
 955           fail = &quot;can only handle references and primitives&quot;;
 956         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 957           fail = &quot;primitive is not properly boxed&quot;;
 958         }
 959         if (fail != NULL) {
 960           // Since this exception is not a LinkageError, throw exception
 961           // but do not save a DynamicInError resolution result.
 962           // See section 5.4.3 of the VM spec.
 963           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 964         }
 965       }




 966       break;
 967     }
 968 
 969   case JVM_CONSTANT_String:
 970     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
 971     if (this_cp-&gt;is_pseudo_string_at(index)) {
 972       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
 973       break;
 974     }
 975     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
 976     break;
 977 
 978   case JVM_CONSTANT_DynamicInError:
 979   case JVM_CONSTANT_MethodHandleInError:
 980   case JVM_CONSTANT_MethodTypeInError:
 981     {
 982       throw_resolution_error(this_cp, index, CHECK_NULL);
 983       break;
 984     }
 985 
 986   case JVM_CONSTANT_MethodHandle:
 987     {
 988       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
 989       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
 990       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
 991       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
 992       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
 993       { ResourceMark rm(THREAD);
 994         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
 995                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
 996                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
 997       }
 998 
 999       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1000 
1001       // Check constant pool method consistency
1002       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1003           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1004         ResourceMark rm(THREAD);
<span class="line-modified">1005         char buf[400];</span>
<span class="line-modified">1006         jio_snprintf(buf, sizeof(buf),</span>
<span class="line-modified">1007           &quot;Inconsistent constant pool data in classfile for class %s. &quot;</span>
<span class="line-modified">1008           &quot;Method %s%s at index %d is %s and should be %s&quot;,</span>
<span class="line-modified">1009           callee-&gt;name()-&gt;as_C_string(), name-&gt;as_C_string(), signature-&gt;as_C_string(), index,</span>
<span class="line-modified">1010           callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,</span>
<span class="line-modified">1011           callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);</span>
<span class="line-modified">1012         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span>



1013       }
1014 
1015       Klass* klass = this_cp-&gt;pool_holder();
1016       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1017                                                                    callee, name, signature,
1018                                                                    THREAD);
1019       result_oop = value();
1020       if (HAS_PENDING_EXCEPTION) {
1021         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1022       }
1023       break;
1024     }
1025 
1026   case JVM_CONSTANT_MethodType:
1027     {
1028       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1029       { ResourceMark rm(THREAD);
1030         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1031                               index, this_cp-&gt;method_type_index_at(index),
1032                               signature-&gt;as_C_string());
</pre>
<hr />
<pre>
1067   default:
1068     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1069                               this_cp(), index, cache_index, tag.value()));
1070     assert(false, &quot;unexpected constant tag&quot;);
1071     break;
1072   }
1073 
1074   if (cache_index &gt;= 0) {
1075     // Benign race condition:  resolved_references may already be filled in.
1076     // The important thing here is that all threads pick up the same result.
1077     // It doesn&#39;t matter which racing thread wins, as long as only one
1078     // result is used by all threads, and all future queries.
1079     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1080     oop old_result = this_cp-&gt;resolved_references()
1081       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1082     if (old_result == NULL) {
1083       return result_oop;  // was installed
1084     } else {
1085       // Return the winning thread&#39;s result.  This can be different than
1086       // the result here for MethodHandles.
<span class="line-modified">1087       if (oopDesc::equals(old_result, Universe::the_null_sentinel()))</span>
1088         old_result = NULL;
1089       return old_result;
1090     }
1091   } else {
<span class="line-modified">1092     assert(!oopDesc::equals(result_oop, Universe::the_null_sentinel()), &quot;&quot;);</span>
1093     return result_oop;
1094   }
1095 }
1096 
1097 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1098   Symbol* sym = unresolved_string_at(which);
1099   oop str = StringTable::intern(sym, CHECK_(NULL));
1100   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1101   return str;
1102 }
1103 
<span class="line-removed">1104 </span>
<span class="line-removed">1105 oop ConstantPool::resolve_bootstrap_specifier_at_impl(const constantPoolHandle&amp; this_cp, int index, TRAPS) {</span>
<span class="line-removed">1106   assert((this_cp-&gt;tag_at(index).is_invoke_dynamic() ||</span>
<span class="line-removed">1107           this_cp-&gt;tag_at(index).is_dynamic_constant()), &quot;Corrupted constant pool&quot;);</span>
<span class="line-removed">1108   Handle bsm;</span>
<span class="line-removed">1109   int argc;</span>
<span class="line-removed">1110   {</span>
<span class="line-removed">1111     // JVM_CONSTANT_InvokeDynamic is an ordered pair of [bootm, name&amp;mtype], plus optional arguments</span>
<span class="line-removed">1112     // JVM_CONSTANT_Dynamic is an ordered pair of [bootm, name&amp;ftype], plus optional arguments</span>
<span class="line-removed">1113     // In both cases, the bootm, being a JVM_CONSTANT_MethodHandle, has its own cache entry.</span>
<span class="line-removed">1114     // It is accompanied by the optional arguments.</span>
<span class="line-removed">1115     int bsm_index = this_cp-&gt;bootstrap_method_ref_index_at(index);</span>
<span class="line-removed">1116     oop bsm_oop = this_cp-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK_NULL);</span>
<span class="line-removed">1117     if (!java_lang_invoke_MethodHandle::is_instance(bsm_oop)) {</span>
<span class="line-removed">1118       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;BSM not an MethodHandle&quot;);</span>
<span class="line-removed">1119     }</span>
<span class="line-removed">1120 </span>
<span class="line-removed">1121     // Extract the optional static arguments.</span>
<span class="line-removed">1122     argc = this_cp-&gt;bootstrap_argument_count_at(index);</span>
<span class="line-removed">1123 </span>
<span class="line-removed">1124     // if there are no static arguments, return the bsm by itself:</span>
<span class="line-removed">1125     if (argc == 0 &amp;&amp; UseBootstrapCallInfo &lt; 2)  return bsm_oop;</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127     bsm = Handle(THREAD, bsm_oop);</span>
<span class="line-removed">1128   }</span>
<span class="line-removed">1129 </span>
<span class="line-removed">1130   // We are going to return an ordered pair of {bsm, info}, using a 2-array.</span>
<span class="line-removed">1131   objArrayHandle info;</span>
<span class="line-removed">1132   {</span>
<span class="line-removed">1133     objArrayOop info_oop = oopFactory::new_objArray(SystemDictionary::Object_klass(), 2, CHECK_NULL);</span>
<span class="line-removed">1134     info = objArrayHandle(THREAD, info_oop);</span>
<span class="line-removed">1135   }</span>
<span class="line-removed">1136 </span>
<span class="line-removed">1137   info-&gt;obj_at_put(0, bsm());</span>
<span class="line-removed">1138 </span>
<span class="line-removed">1139   bool use_BSCI;</span>
<span class="line-removed">1140   switch (UseBootstrapCallInfo) {</span>
<span class="line-removed">1141   default: use_BSCI = true;  break;  // stress mode</span>
<span class="line-removed">1142   case 0:  use_BSCI = false; break;  // stress mode</span>
<span class="line-removed">1143   case 1:                            // normal mode</span>
<span class="line-removed">1144     // If we were to support an alternative mode of BSM invocation,</span>
<span class="line-removed">1145     // we&#39;d convert to pull mode here if the BSM could be a candidate</span>
<span class="line-removed">1146     // for that alternative mode.  We can&#39;t easily test for things</span>
<span class="line-removed">1147     // like varargs here, but we can get away with approximate testing,</span>
<span class="line-removed">1148     // since the JDK runtime will make up the difference either way.</span>
<span class="line-removed">1149     // For now, exercise the pull-mode path if the BSM is of arity 2,</span>
<span class="line-removed">1150     // or if there is a potential condy loop (see below).</span>
<span class="line-removed">1151     oop mt_oop = java_lang_invoke_MethodHandle::type(bsm());</span>
<span class="line-removed">1152     use_BSCI = (java_lang_invoke_MethodType::ptype_count(mt_oop) == 2);</span>
<span class="line-removed">1153     break;</span>
<span class="line-removed">1154   }</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156   // Here&#39;s a reason to use BSCI even if it wasn&#39;t requested:</span>
<span class="line-removed">1157   // If a condy uses a condy argument, we want to avoid infinite</span>
<span class="line-removed">1158   // recursion (condy loops) in the C code.  It&#39;s OK in Java,</span>
<span class="line-removed">1159   // because Java has stack overflow checking, so we punt</span>
<span class="line-removed">1160   // potentially cyclic cases from C to Java.</span>
<span class="line-removed">1161   if (!use_BSCI &amp;&amp; this_cp-&gt;tag_at(index).is_dynamic_constant()) {</span>
<span class="line-removed">1162     bool found_unresolved_condy = false;</span>
<span class="line-removed">1163     for (int i = 0; i &lt; argc; i++) {</span>
<span class="line-removed">1164       int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);</span>
<span class="line-removed">1165       if (this_cp-&gt;tag_at(arg_index).is_dynamic_constant()) {</span>
<span class="line-removed">1166         // potential recursion point condy -&gt; condy</span>
<span class="line-removed">1167         bool found_it = false;</span>
<span class="line-removed">1168         this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK_NULL);</span>
<span class="line-removed">1169         if (!found_it) { found_unresolved_condy = true; break; }</span>
<span class="line-removed">1170       }</span>
<span class="line-removed">1171     }</span>
<span class="line-removed">1172     if (found_unresolved_condy)</span>
<span class="line-removed">1173       use_BSCI = true;</span>
<span class="line-removed">1174   }</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176   const int SMALL_ARITY = 5;</span>
<span class="line-removed">1177   if (use_BSCI &amp;&amp; argc &lt;= SMALL_ARITY &amp;&amp; UseBootstrapCallInfo &lt;= 2) {</span>
<span class="line-removed">1178     // If there are only a few arguments, and none of them need linking,</span>
<span class="line-removed">1179     // push them, instead of asking the JDK runtime to turn around and</span>
<span class="line-removed">1180     // pull them, saving a JVM/JDK transition in some simple cases.</span>
<span class="line-removed">1181     bool all_resolved = true;</span>
<span class="line-removed">1182     for (int i = 0; i &lt; argc; i++) {</span>
<span class="line-removed">1183       bool found_it = false;</span>
<span class="line-removed">1184       int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);</span>
<span class="line-removed">1185       this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK_NULL);</span>
<span class="line-removed">1186       if (!found_it) { all_resolved = false; break; }</span>
<span class="line-removed">1187     }</span>
<span class="line-removed">1188     if (all_resolved)</span>
<span class="line-removed">1189       use_BSCI = false;</span>
<span class="line-removed">1190   }</span>
<span class="line-removed">1191 </span>
<span class="line-removed">1192   if (!use_BSCI) {</span>
<span class="line-removed">1193     // return {bsm, {arg...}}; resolution of arguments is done immediately, before JDK code is called</span>
<span class="line-removed">1194     objArrayOop args_oop = oopFactory::new_objArray(SystemDictionary::Object_klass(), argc, CHECK_NULL);</span>
<span class="line-removed">1195     info-&gt;obj_at_put(1, args_oop);   // may overwrite with args[0] below</span>
<span class="line-removed">1196     objArrayHandle args(THREAD, args_oop);</span>
<span class="line-removed">1197     copy_bootstrap_arguments_at_impl(this_cp, index, 0, argc, args, 0, true, Handle(), CHECK_NULL);</span>
<span class="line-removed">1198     if (argc == 1) {</span>
<span class="line-removed">1199       // try to discard the singleton array</span>
<span class="line-removed">1200       oop arg_oop = args-&gt;obj_at(0);</span>
<span class="line-removed">1201       if (arg_oop != NULL &amp;&amp; !arg_oop-&gt;is_array()) {</span>
<span class="line-removed">1202         // JVM treats arrays and nulls specially in this position,</span>
<span class="line-removed">1203         // but other things are just single arguments</span>
<span class="line-removed">1204         info-&gt;obj_at_put(1, arg_oop);</span>
<span class="line-removed">1205       }</span>
<span class="line-removed">1206     }</span>
<span class="line-removed">1207   } else {</span>
<span class="line-removed">1208     // return {bsm, {arg_count, pool_index}}; JDK code must pull the arguments as needed</span>
<span class="line-removed">1209     typeArrayOop ints_oop = oopFactory::new_typeArray(T_INT, 2, CHECK_NULL);</span>
<span class="line-removed">1210     ints_oop-&gt;int_at_put(0, argc);</span>
<span class="line-removed">1211     ints_oop-&gt;int_at_put(1, index);</span>
<span class="line-removed">1212     info-&gt;obj_at_put(1, ints_oop);</span>
<span class="line-removed">1213   }</span>
<span class="line-removed">1214   return info();</span>
<span class="line-removed">1215 }</span>
<span class="line-removed">1216 </span>
1217 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1218                                                     int start_arg, int end_arg,
1219                                                     objArrayHandle info, int pos,
1220                                                     bool must_resolve, Handle if_not_available,
1221                                                     TRAPS) {
1222   int argc;
1223   int limit = pos + end_arg - start_arg;
1224   // checks: index in range [0..this_cp-&gt;length),
1225   // tag at index, start..end in range [0..argc],
1226   // info array non-null, pos..limit in [0..info.length]
1227   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1228       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1229         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1230       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1231       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1232       (0 &gt; pos       || pos &gt; limit)         ||
1233       (info.is_null() || limit &gt; info-&gt;length())) {
1234     // An index or something else went wrong; throw an error.
1235     // Since this is an internal API, we don&#39;t expect this,
1236     // so we don&#39;t bother to craft a nice message.
</pre>
<hr />
<pre>
1238   }
1239   // now we can loop safely
1240   int info_i = pos;
1241   for (int i = start_arg; i &lt; end_arg; i++) {
1242     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1243     oop arg_oop;
1244     if (must_resolve) {
1245       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1246     } else {
1247       bool found_it = false;
1248       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1249       if (!found_it)  arg_oop = if_not_available();
1250     }
1251     info-&gt;obj_at_put(info_i++, arg_oop);
1252   }
1253 }
1254 
1255 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1256   // If the string has already been interned, this entry will be non-null
1257   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
<span class="line-modified">1258   assert(!oopDesc::equals(str, Universe::the_null_sentinel()), &quot;&quot;);</span>
1259   if (str != NULL) return str;
1260   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1261   str = StringTable::intern(sym, CHECK_(NULL));
1262   this_cp-&gt;string_at_put(which, obj_index, str);
1263   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1264   return str;
1265 }
1266 
1267 
1268 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1269   // Names are interned, so we can compare Symbol*s directly
1270   Symbol* cp_name = klass_name_at(which);
1271   return (cp_name == k-&gt;name());
1272 }
1273 
1274 
1275 // Iterate over symbols and decrement ones which are Symbol*s
1276 // This is done during GC.
1277 // Only decrement the UTF8 symbols. Strings point to
1278 // these symbols but didn&#39;t increment the reference count.
</pre>
<hr />
<pre>
1830 
1831   if (!match) {
1832     return false;
1833   }
1834   int argc = operand_argument_count_at(idx1);
1835   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1836     for (int j = 0; j &lt; argc; j++) {
1837       k1 = operand_argument_index_at(idx1, j);
1838       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1839       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1840       if (!match) {
1841         return false;
1842       }
1843     }
1844     return true;           // got through loop; all elements equal
1845   }
1846   return false;
1847 } // end compare_operand_to()
1848 
1849 // Search constant pool search_cp for a bootstrap specifier that matches
<span class="line-modified">1850 // this constant pool&#39;s bootstrap specifier at pattern_i index.</span>
<span class="line-modified">1851 // Return the index of a matching bootstrap specifier or (-1) if there is no match.</span>
1852 int ConstantPool::find_matching_operand(int pattern_i,
1853                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1854   for (int i = 0; i &lt; search_len; i++) {
1855     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1856     if (found) {
1857       return i;
1858     }
1859   }
<span class="line-modified">1860   return -1;  // bootstrap specifier not found; return unused index (-1)</span>
1861 } // end find_matching_operand()
1862 
1863 
1864 #ifndef PRODUCT
1865 
1866 const char* ConstantPool::printable_name_at(int which) {
1867 
1868   constantTag tag = tag_at(which);
1869 
1870   if (tag.is_string()) {
1871     return string_at_noresolve(which);
1872   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1873     return klass_name_at(which)-&gt;as_C_string();
1874   } else if (tag.is_symbol()) {
1875     return symbol_at(which)-&gt;as_C_string();
1876   }
1877   return &quot;&quot;;
1878 }
1879 
1880 #endif // PRODUCT
</pre>
<hr />
<pre>
2460   st-&gt;cr();
2461 }
2462 
2463 void ConstantPool::print_value_on(outputStream* st) const {
2464   assert(is_constantPool(), &quot;must be constantPool&quot;);
2465   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2466   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2467   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2468   print_address_on(st);
2469   if (pool_holder() != NULL) {
2470     st-&gt;print(&quot; for &quot;);
2471     pool_holder()-&gt;print_value_on(st);
2472     bool extra = (pool_holder()-&gt;constants() != this);
2473     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2474   }
2475   if (cache() != NULL) {
2476     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2477   }
2478 }
2479 
<span class="line-removed">2480 #if INCLUDE_SERVICES</span>
<span class="line-removed">2481 // Size Statistics</span>
<span class="line-removed">2482 void ConstantPool::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">2483   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_bytes          = sz-&gt;count(this));</span>
<span class="line-removed">2484   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_tags_bytes     = sz-&gt;count_array(tags()));</span>
<span class="line-removed">2485   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_cache_bytes    = sz-&gt;count(cache()));</span>
<span class="line-removed">2486   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_operands_bytes = sz-&gt;count_array(operands()));</span>
<span class="line-removed">2487   sz-&gt;_cp_all_bytes += (sz-&gt;_cp_refmap_bytes   = sz-&gt;count_array(reference_map()));</span>
<span class="line-removed">2488 </span>
<span class="line-removed">2489   sz-&gt;_ro_bytes += sz-&gt;_cp_operands_bytes + sz-&gt;_cp_tags_bytes +</span>
<span class="line-removed">2490                    sz-&gt;_cp_refmap_bytes;</span>
<span class="line-removed">2491   sz-&gt;_rw_bytes += sz-&gt;_cp_bytes + sz-&gt;_cp_cache_bytes;</span>
<span class="line-removed">2492 }</span>
<span class="line-removed">2493 #endif // INCLUDE_SERVICES</span>
<span class="line-removed">2494 </span>
2495 // Verification
2496 
2497 void ConstantPool::verify_on(outputStream* st) {
2498   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2499   for (int i = 0; i&lt; length();  i++) {
2500     constantTag tag = tag_at(i);
2501     if (tag.is_klass() || tag.is_unresolved_klass()) {
2502       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2503     } else if (tag.is_symbol()) {
2504       CPSlot entry = slot_at(i);
2505       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2506     } else if (tag.is_string()) {
2507       CPSlot entry = slot_at(i);
2508       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2509     }
2510   }
2511   if (pool_holder() != NULL) {
2512     // Note: pool_holder() can be NULL in temporary constant pools
2513     // used during constant pool merging
2514     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
<span class="line-added">  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;</span>
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;

  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  42 #include &quot;memory/universe.hpp&quot;</span>
  43 #include &quot;oops/array.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-modified">  51 #include &quot;runtime/atomic.hpp&quot;</span>
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/init.hpp&quot;
  54 #include &quot;runtime/javaCalls.hpp&quot;
  55 #include &quot;runtime/signature.hpp&quot;
  56 #include &quot;runtime/thread.inline.hpp&quot;
  57 #include &quot;runtime/vframe.inline.hpp&quot;
  58 #include &quot;utilities/copy.hpp&quot;
  59 
  60 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  61   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  62   int size = ConstantPool::size(length);
  63   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  64 }
  65 
  66 #ifdef ASSERT
  67 
  68 // MetaspaceObj allocation invariant is calloc equivalent memory
  69 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  70 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  71   assert(tags != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 214       // All of these should have been reverted back to ClassIndex before calling
 215       // this function.
 216       ShouldNotReachHere();
 217 #endif
 218     }
 219   }
 220   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 221 }
 222 
 223 // Unsafe anonymous class support:
 224 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 225   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 226   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 227   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 228   *int_at_addr(class_index) =
 229     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 230 
 231   symbol_at_put(name_index, name);
 232   name-&gt;increment_refcount();
 233   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 234   Atomic::release_store(adr, k);</span>
 235 
 236   // The interpreter assumes when the tag is stored, the klass is resolved
 237   // and the Klass* non-NULL, so we need hardware store ordering here.
 238   if (k != NULL) {
 239     release_tag_at_put(class_index, JVM_CONSTANT_Class);
 240   } else {
 241     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);
 242   }
 243 }
 244 
 245 // Unsafe anonymous class support:
 246 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 247   assert(k != NULL, &quot;must be valid klass&quot;);
 248   CPKlassSlot kslot = klass_slot_at(class_index);
 249   int resolved_klass_index = kslot.resolved_klass_index();
 250   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 251   Atomic::release_store(adr, k);</span>
 252 
 253   // The interpreter assumes when the tag is stored, the klass is resolved
 254   // and the Klass* non-NULL, so we need hardware store ordering here.
 255   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 256 }
 257 
 258 #if INCLUDE_CDS_JAVA_HEAP
 259 // Archive the resolved references
 260 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 261   if (_cache == NULL) {
 262     return; // nothing to do
 263   }
 264 
 265   InstanceKlass *ik = pool_holder();
 266   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 267         ik-&gt;is_shared_app_class())) {
 268     // Archiving resolved references for classes from non-builtin loaders
 269     // is not yet supported.
 270     set_resolved_references(NULL);
 271     return;
 272   }
 273 
 274   objArrayOop rr = resolved_references();
 275   Array&lt;u2&gt;* ref_map = reference_map();
 276   if (rr != NULL) {
 277     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 278     int rr_len = rr-&gt;length();
 279     for (int i = 0; i &lt; rr_len; i++) {
 280       oop p = rr-&gt;obj_at(i);
 281       rr-&gt;obj_at_put(i, NULL);
 282       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 283         int index = object_to_cp_index(i);
<span class="line-modified"> 284         if (tag_at(index).is_string()) {</span>


 285           oop op = StringTable::create_archived_string(p, THREAD);
 286           // If the String object is not archived (possibly too large),
 287           // NULL is returned. Also set it in the array, so we won&#39;t
 288           // have a &#39;bad&#39; reference in the archived resolved_reference
 289           // array.
 290           rr-&gt;obj_at_put(i, op);
 291         }
 292       }
 293     }
 294 
 295     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 296     // If the resolved references array is not archived (too large),
 297     // the &#39;archived&#39; object is NULL. No need to explicitly check
 298     // the return value of archive_heap_object here. At runtime, the
 299     // resolved references will be created using the normal process
 300     // when there is no archived value.
 301     _cache-&gt;set_archived_references(archived);
 302     set_resolved_references(NULL);
 303   }
 304 }
</pre>
<hr />
<pre>
 353         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 354         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 355         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 356       }
 357     }
 358   }
 359 }
 360 
 361 void ConstantPool::remove_unshareable_info() {
 362   // Resolved references are not in the shared archive.
 363   // Save the length for restoration.  It is not necessarily the same length
 364   // as reference_map.length() if invokedynamic is saved. It is needed when
 365   // re-creating the resolved reference array if archived heap data cannot be map
 366   // at runtime.
 367   set_resolved_reference_length(
 368     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 369 
 370   // If archiving heap objects is not allowed, clear the resolved references.
 371   // Otherwise, it is cleared after the resolved references array is cached
 372   // (see archive_resolved_references()).
<span class="line-modified"> 373   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also</span>
<span class="line-added"> 374   // as java objects are not archived in the top layer.</span>
<span class="line-added"> 375   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {</span>
 376     set_resolved_references(NULL);
 377   }
 378 
 379   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 380   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 381   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 382   // we always set _on_stack to true to avoid having to change _flags during runtime.
 383   _flags |= (_on_stack | _is_shared);
 384   int num_klasses = 0;
 385   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
<span class="line-modified"> 386     if (!DynamicDumpSharedSpaces) {</span>
<span class="line-added"> 387       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);</span>
<span class="line-added"> 388     } else {</span>
<span class="line-added"> 389       if (tag_at(index).is_unresolved_klass_in_error() ||</span>
<span class="line-added"> 390           tag_at(index).is_method_handle_in_error()    ||</span>
<span class="line-added"> 391           tag_at(index).is_method_type_in_error()      ||</span>
<span class="line-added"> 392           tag_at(index).is_dynamic_constant_in_error()) {</span>
<span class="line-added"> 393         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);</span>
<span class="line-added"> 394       }</span>
<span class="line-added"> 395     }</span>
 396     if (tag_at(index).is_klass()) {
 397       // This class was resolved as a side effect of executing Java code
 398       // during dump time. We need to restore it back to an UnresolvedClass,
 399       // so that the proper class loading and initialization can happen
 400       // at runtime.
 401       CPKlassSlot kslot = klass_slot_at(index);
 402       int resolved_klass_index = kslot.resolved_klass_index();
 403       int name_index = kslot.name_index();
 404       assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 405       resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 406       tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 407       assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 408     }
 409   }
 410   if (cache() != NULL) {
 411     cache()-&gt;remove_unshareable_info();
 412   }
 413 }
 414 
 415 int ConstantPool::cp_to_object_index(int cp_index) {
</pre>
<hr />
<pre>
 507   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 508   if (HAS_PENDING_EXCEPTION) {
 509     if (save_resolution_error) {
 510       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 511       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 512       // some other thread has beaten us and has resolved the class.
 513       // To preserve old behavior, we return the resolved class.
 514       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 515       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 516       return klass;
 517     } else {
 518       return NULL;  // return the pending exception
 519     }
 520   }
 521 
 522   // logging for class+resolve.
 523   if (log_is_enabled(Debug, class, resolve)){
 524     trace_class_resolution(this_cp, k);
 525   }
 526   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
<span class="line-modified"> 527   Atomic::release_store(adr, k);</span>
 528   // The interpreter assumes when the tag is stored, the klass is resolved
 529   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 530   // hardware store ordering here.
 531   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);
 532   return k;
 533 }
 534 
 535 
 536 // Does not update ConstantPool* - to avoid any exception throwing. Used
 537 // by compiler and exception handling.  Also used to avoid classloads for
 538 // instanceof operations. Returns NULL if the class has not been loaded or
 539 // if the verification of constant pool failed
 540 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 541   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 542   int resolved_klass_index = kslot.resolved_klass_index();
 543   int name_index = kslot.name_index();
 544   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 545 
 546   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 547   if (k != NULL) {
 548     return k;
 549   } else {
 550     Thread *thread = Thread::current();
 551     Symbol* name = this_cp-&gt;symbol_at(name_index);
 552     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 553     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 554     Handle h_prot (thread, protection_domain);
 555     Handle h_loader (thread, loader);
 556     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 557 
<span class="line-modified"> 558     // Avoid constant pool verification at a safepoint, which takes the Module_lock.</span>
<span class="line-added"> 559     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {</span>
 560       // Make sure that resolving is legal
 561       EXCEPTION_MARK;
 562       // return NULL if verification fails
 563       verify_constant_pool_resolve(this_cp, k, THREAD);
 564       if (HAS_PENDING_EXCEPTION) {
 565         CLEAR_PENDING_EXCEPTION;
 566         return NULL;
 567       }
 568       return k;
 569     } else {
 570       return k;
 571     }
 572   }
 573 }
 574 
 575 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 576                                                    int which) {
 577   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 578   int cache_index = decode_cpcache_index(which, true);
 579   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
</pre>
<hr />
<pre>
 710 
 711 Symbol* ConstantPool::klass_name_at(int which) const {
 712   return symbol_at(klass_slot_at(which).name_index());
 713 }
 714 
 715 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 716   jint ref_index = klass_ref_index_at(which);
 717   return klass_at_noresolve(ref_index);
 718 }
 719 
 720 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 721   jint ref_index = uncached_klass_ref_index_at(which);
 722   return klass_at_noresolve(ref_index);
 723 }
 724 
 725 char* ConstantPool::string_at_noresolve(int which) {
 726   return unresolved_string_at(which)-&gt;as_C_string();
 727 }
 728 
 729 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
<span class="line-modified"> 730   return Signature::basic_type(symbol_at(which));</span>
 731 }
 732 
 733 
 734 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 735   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 736     if (this_cp-&gt;tag_at(index).is_string()) {
 737       this_cp-&gt;string_at(index, CHECK);
 738     }
 739   }
 740 }
 741 
 742 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 743   // Dig out the detailed message to reuse if possible
 744   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 745   if (message != NULL) {
 746     return message;
 747   }
 748 
 749   // Return specific message for the tag
 750   switch (tag.value()) {
 751   case JVM_CONSTANT_UnresolvedClass:
 752     // return the class name in the error message
 753     message = this_cp-&gt;klass_name_at(which);
 754     break;
 755   case JVM_CONSTANT_MethodHandle:
 756     // return the method handle name in the error message
 757     message = this_cp-&gt;method_handle_name_ref_at(which);
 758     break;
 759   case JVM_CONSTANT_MethodType:
 760     // return the method type signature in the error message
 761     message = this_cp-&gt;method_type_signature_at(which);
 762     break;
<span class="line-added"> 763   case JVM_CONSTANT_Dynamic:</span>
<span class="line-added"> 764     // return the name of the condy in the error message</span>
<span class="line-added"> 765     message = this_cp-&gt;uncached_name_ref_at(which);</span>
<span class="line-added"> 766     break;</span>
 767   default:
 768     ShouldNotReachHere();
 769   }
 770 
 771   return message;
 772 }
 773 
 774 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 775   Symbol* message = NULL;
 776   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 777   assert(error != NULL, &quot;checking&quot;);
 778   CLEAR_PENDING_EXCEPTION;
 779   if (message != NULL) {
 780     ResourceMark rm;
 781     THROW_MSG(error, message-&gt;as_C_string());
 782   } else {
 783     THROW(error);
 784   }
 785 }
 786 
</pre>
<hr />
<pre>
 790                                             constantTag tag, TRAPS) {
 791   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 792 
 793   int error_tag = tag.error_value();
 794 
 795   if (!PENDING_EXCEPTION-&gt;
 796     is_a(SystemDictionary::LinkageError_klass())) {
 797     // Just throw the exception and don&#39;t prevent these classes from
 798     // being loaded due to virtual machine errors like StackOverflow
 799     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 800     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 801   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 802     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 803     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 804     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 805     // If another thread resolved the reference, this is a race condition. This
 806     // thread may have had a security manager or something temporary.
 807     // This doesn&#39;t deterministically get an error.   So why do we save this?
 808     // We save this because jvmti can add classes to the bootclass path after
 809     // this error, so it needs to get the same error if the error is first.
<span class="line-modified"> 810     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),</span>
<span class="line-modified"> 811                                     (jbyte)tag.value(),</span>
<span class="line-added"> 812                                     (jbyte)error_tag);</span>
 813     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 814       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 815       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 816       // Forget the exception and use the resolved class.
 817       CLEAR_PENDING_EXCEPTION;
 818     }
 819   } else {
 820     // some other thread put this in error state
 821     throw_resolution_error(this_cp, which, CHECK);
 822   }
 823 }
 824 
 825 constantTag ConstantPool::constant_tag_at(int which) {
 826   constantTag tag = tag_at(which);
 827   if (tag.is_dynamic_constant() ||
 828       tag.is_dynamic_constant_in_error()) {
 829     BasicType bt = basic_type_for_constant_at(which);
 830     // dynamic constant could return an array, treat as object
 831     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 832   }
 833   return tag;
 834 }
 835 
 836 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 837   constantTag tag = tag_at(which);
 838   if (tag.is_dynamic_constant() ||
 839       tag.is_dynamic_constant_in_error()) {
 840     // have to look at the signature for this one
 841     Symbol* constant_type = uncached_signature_ref_at(which);
<span class="line-modified"> 842     return Signature::basic_type(constant_type);</span>
 843   }
 844   return tag.basic_type();
 845 }
 846 
 847 // Called to resolve constants in the constant pool and return an oop.
 848 // Some constant pool entries cache their resolved oop. This is also
 849 // called to create oops from constants to use in arguments for invokedynamic
 850 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 851                                            int index, int cache_index,
 852                                            bool* status_return, TRAPS) {
 853   oop result_oop = NULL;
 854   Handle throw_exception;
 855 
 856   if (cache_index == _possible_index_sentinel) {
 857     // It is possible that this constant is one which is cached in the objects.
 858     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 859     // FIXME: If bootstrap specifiers stress this code, consider putting in
 860     // a reverse index.  Binary search over a short array should do it.
 861     assert(index &gt; 0, &quot;valid index&quot;);
 862     cache_index = this_cp-&gt;cp_to_object_index(index);
 863   }
 864   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 865   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 866 
 867   if (cache_index &gt;= 0) {
 868     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 869     if (result_oop != NULL) {
<span class="line-modified"> 870       if (result_oop == Universe::the_null_sentinel()) {</span>
 871         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 872         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 873         result_oop = NULL;
 874       }
 875       if (status_return != NULL)  (*status_return) = true;
 876       return result_oop;
 877       // That was easy...
 878     }
 879     index = this_cp-&gt;object_to_cp_index(cache_index);
 880   }
 881 
 882   jvalue prim_value;  // temp used only in a few cases below
 883 
 884   constantTag tag = this_cp-&gt;tag_at(index);
 885 
 886   if (status_return != NULL) {
 887     // don&#39;t trigger resolution if the constant might need it
 888     switch (tag.value()) {
 889     case JVM_CONSTANT_Class:
 890     {
</pre>
<hr />
<pre>
 910     }
 911     // from now on there is either success or an OOME
 912     (*status_return) = true;
 913   }
 914 
 915   switch (tag.value()) {
 916 
 917   case JVM_CONSTANT_UnresolvedClass:
 918   case JVM_CONSTANT_UnresolvedClassInError:
 919   case JVM_CONSTANT_Class:
 920     {
 921       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 922       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 923       // ldc wants the java mirror.
 924       result_oop = resolved-&gt;java_mirror();
 925       break;
 926     }
 927 
 928   case JVM_CONSTANT_Dynamic:
 929     {
<span class="line-modified"> 930       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.</span>
<span class="line-modified"> 931       BootstrapInfo bootstrap_specifier(this_cp, index);</span>

 932 
 933       // The initial step in resolving an unresolved symbolic reference to a
 934       // dynamically-computed constant is to resolve the symbolic reference to a
 935       // method handle which will be the bootstrap method for the dynamically-computed
 936       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 937       // method fails, then a MethodHandleInError is stored at the corresponding
 938       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 939       // set a DynamicConstantInError here since any subsequent use of this
 940       // bootstrap method will encounter the resolution of MethodHandleInError.
<span class="line-modified"> 941       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,</span>
<span class="line-modified"> 942       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()</span>
<span class="line-modified"> 943       // for the bootstrap_specifier created above.</span>
<span class="line-modified"> 944       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);</span>










 945       Exceptions::wrap_dynamic_exception(THREAD);
 946       if (HAS_PENDING_EXCEPTION) {
 947         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 948         // will check for a LinkageError and store a DynamicConstantInError.
 949         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 950       }
<span class="line-modified"> 951       result_oop = bootstrap_specifier.resolved_value()();</span>
<span class="line-added"> 952       BasicType type = Signature::basic_type(bootstrap_specifier.signature());</span>
 953       if (!is_reference_type(type)) {
 954         // Make sure the primitive value is properly boxed.
 955         // This is a JDK responsibility.
 956         const char* fail = NULL;
 957         if (result_oop == NULL) {
 958           fail = &quot;null result instead of box&quot;;
 959         } else if (!is_java_primitive(type)) {
 960           // FIXME: support value types via unboxing
 961           fail = &quot;can only handle references and primitives&quot;;
 962         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 963           fail = &quot;primitive is not properly boxed&quot;;
 964         }
 965         if (fail != NULL) {
 966           // Since this exception is not a LinkageError, throw exception
 967           // but do not save a DynamicInError resolution result.
 968           // See section 5.4.3 of the VM spec.
 969           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 970         }
 971       }
<span class="line-added"> 972 </span>
<span class="line-added"> 973       if (TraceMethodHandles) {</span>
<span class="line-added"> 974         bootstrap_specifier.print_msg_on(tty, &quot;resolve_constant_at_impl&quot;);</span>
<span class="line-added"> 975       }</span>
 976       break;
 977     }
 978 
 979   case JVM_CONSTANT_String:
 980     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
 981     if (this_cp-&gt;is_pseudo_string_at(index)) {
 982       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
 983       break;
 984     }
 985     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
 986     break;
 987 
 988   case JVM_CONSTANT_DynamicInError:
 989   case JVM_CONSTANT_MethodHandleInError:
 990   case JVM_CONSTANT_MethodTypeInError:
 991     {
 992       throw_resolution_error(this_cp, index, CHECK_NULL);
 993       break;
 994     }
 995 
 996   case JVM_CONSTANT_MethodHandle:
 997     {
 998       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
 999       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1000       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1001       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1002       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1003       { ResourceMark rm(THREAD);
1004         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1005                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1006                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1007       }
1008 
1009       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1010 
1011       // Check constant pool method consistency
1012       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1013           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1014         ResourceMark rm(THREAD);
<span class="line-modified">1015         stringStream ss;</span>
<span class="line-modified">1016         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;</span>
<span class="line-modified">1017                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());</span>
<span class="line-modified">1018         signature-&gt;print_as_signature_external_return_type(&amp;ss);</span>
<span class="line-modified">1019         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());</span>
<span class="line-modified">1020         signature-&gt;print_as_signature_external_parameters(&amp;ss);</span>
<span class="line-modified">1021         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,</span>
<span class="line-modified">1022                  index,</span>
<span class="line-added">1023                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,</span>
<span class="line-added">1024                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);</span>
<span class="line-added">1025         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());</span>
1026       }
1027 
1028       Klass* klass = this_cp-&gt;pool_holder();
1029       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1030                                                                    callee, name, signature,
1031                                                                    THREAD);
1032       result_oop = value();
1033       if (HAS_PENDING_EXCEPTION) {
1034         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1035       }
1036       break;
1037     }
1038 
1039   case JVM_CONSTANT_MethodType:
1040     {
1041       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1042       { ResourceMark rm(THREAD);
1043         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1044                               index, this_cp-&gt;method_type_index_at(index),
1045                               signature-&gt;as_C_string());
</pre>
<hr />
<pre>
1080   default:
1081     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1082                               this_cp(), index, cache_index, tag.value()));
1083     assert(false, &quot;unexpected constant tag&quot;);
1084     break;
1085   }
1086 
1087   if (cache_index &gt;= 0) {
1088     // Benign race condition:  resolved_references may already be filled in.
1089     // The important thing here is that all threads pick up the same result.
1090     // It doesn&#39;t matter which racing thread wins, as long as only one
1091     // result is used by all threads, and all future queries.
1092     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1093     oop old_result = this_cp-&gt;resolved_references()
1094       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1095     if (old_result == NULL) {
1096       return result_oop;  // was installed
1097     } else {
1098       // Return the winning thread&#39;s result.  This can be different than
1099       // the result here for MethodHandles.
<span class="line-modified">1100       if (old_result == Universe::the_null_sentinel())</span>
1101         old_result = NULL;
1102       return old_result;
1103     }
1104   } else {
<span class="line-modified">1105     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);</span>
1106     return result_oop;
1107   }
1108 }
1109 
1110 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1111   Symbol* sym = unresolved_string_at(which);
1112   oop str = StringTable::intern(sym, CHECK_(NULL));
1113   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1114   return str;
1115 }
1116 

















































































































1117 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1118                                                     int start_arg, int end_arg,
1119                                                     objArrayHandle info, int pos,
1120                                                     bool must_resolve, Handle if_not_available,
1121                                                     TRAPS) {
1122   int argc;
1123   int limit = pos + end_arg - start_arg;
1124   // checks: index in range [0..this_cp-&gt;length),
1125   // tag at index, start..end in range [0..argc],
1126   // info array non-null, pos..limit in [0..info.length]
1127   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1128       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1129         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1130       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1131       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1132       (0 &gt; pos       || pos &gt; limit)         ||
1133       (info.is_null() || limit &gt; info-&gt;length())) {
1134     // An index or something else went wrong; throw an error.
1135     // Since this is an internal API, we don&#39;t expect this,
1136     // so we don&#39;t bother to craft a nice message.
</pre>
<hr />
<pre>
1138   }
1139   // now we can loop safely
1140   int info_i = pos;
1141   for (int i = start_arg; i &lt; end_arg; i++) {
1142     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1143     oop arg_oop;
1144     if (must_resolve) {
1145       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1146     } else {
1147       bool found_it = false;
1148       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1149       if (!found_it)  arg_oop = if_not_available();
1150     }
1151     info-&gt;obj_at_put(info_i++, arg_oop);
1152   }
1153 }
1154 
1155 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1156   // If the string has already been interned, this entry will be non-null
1157   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
<span class="line-modified">1158   assert(str != Universe::the_null_sentinel(), &quot;&quot;);</span>
1159   if (str != NULL) return str;
1160   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1161   str = StringTable::intern(sym, CHECK_(NULL));
1162   this_cp-&gt;string_at_put(which, obj_index, str);
1163   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1164   return str;
1165 }
1166 
1167 
1168 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1169   // Names are interned, so we can compare Symbol*s directly
1170   Symbol* cp_name = klass_name_at(which);
1171   return (cp_name == k-&gt;name());
1172 }
1173 
1174 
1175 // Iterate over symbols and decrement ones which are Symbol*s
1176 // This is done during GC.
1177 // Only decrement the UTF8 symbols. Strings point to
1178 // these symbols but didn&#39;t increment the reference count.
</pre>
<hr />
<pre>
1730 
1731   if (!match) {
1732     return false;
1733   }
1734   int argc = operand_argument_count_at(idx1);
1735   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1736     for (int j = 0; j &lt; argc; j++) {
1737       k1 = operand_argument_index_at(idx1, j);
1738       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1739       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1740       if (!match) {
1741         return false;
1742       }
1743     }
1744     return true;           // got through loop; all elements equal
1745   }
1746   return false;
1747 } // end compare_operand_to()
1748 
1749 // Search constant pool search_cp for a bootstrap specifier that matches
<span class="line-modified">1750 // this constant pool&#39;s bootstrap specifier data at pattern_i index.</span>
<span class="line-modified">1751 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.</span>
1752 int ConstantPool::find_matching_operand(int pattern_i,
1753                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1754   for (int i = 0; i &lt; search_len; i++) {
1755     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1756     if (found) {
1757       return i;
1758     }
1759   }
<span class="line-modified">1760   return -1;  // bootstrap specifier data not found; return unused index (-1)</span>
1761 } // end find_matching_operand()
1762 
1763 
1764 #ifndef PRODUCT
1765 
1766 const char* ConstantPool::printable_name_at(int which) {
1767 
1768   constantTag tag = tag_at(which);
1769 
1770   if (tag.is_string()) {
1771     return string_at_noresolve(which);
1772   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1773     return klass_name_at(which)-&gt;as_C_string();
1774   } else if (tag.is_symbol()) {
1775     return symbol_at(which)-&gt;as_C_string();
1776   }
1777   return &quot;&quot;;
1778 }
1779 
1780 #endif // PRODUCT
</pre>
<hr />
<pre>
2360   st-&gt;cr();
2361 }
2362 
2363 void ConstantPool::print_value_on(outputStream* st) const {
2364   assert(is_constantPool(), &quot;must be constantPool&quot;);
2365   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2366   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2367   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2368   print_address_on(st);
2369   if (pool_holder() != NULL) {
2370     st-&gt;print(&quot; for &quot;);
2371     pool_holder()-&gt;print_value_on(st);
2372     bool extra = (pool_holder()-&gt;constants() != this);
2373     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2374   }
2375   if (cache() != NULL) {
2376     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2377   }
2378 }
2379 















2380 // Verification
2381 
2382 void ConstantPool::verify_on(outputStream* st) {
2383   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2384   for (int i = 0; i&lt; length();  i++) {
2385     constantTag tag = tag_at(i);
2386     if (tag.is_klass() || tag.is_unresolved_klass()) {
2387       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2388     } else if (tag.is_symbol()) {
2389       CPSlot entry = slot_at(i);
2390       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2391     } else if (tag.is_string()) {
2392       CPSlot entry = slot_at(i);
2393       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2394     }
2395   }
2396   if (pool_holder() != NULL) {
2397     // Note: pool_holder() can be NULL in temporary constant pools
2398     // used during constant pool merging
2399     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="constMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
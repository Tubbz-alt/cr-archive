<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oopsHierarchy.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopsHierarchy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oopsHierarchy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOPSHIERARCHY_HPP
 26 #define SHARE_OOPS_OOPSHIERARCHY_HPP
 27 
 28 #include &quot;metaprogramming/integralConstant.hpp&quot;
 29 #include &quot;metaprogramming/primitiveConversions.hpp&quot;
<span class="line-removed"> 30 #include &quot;runtime/globals.hpp&quot;</span>
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 // OBJECT hierarchy
 34 // This hierarchy is a representation hierarchy, i.e. if A is a superclass
 35 // of B, A&#39;s representation is a prefix of B&#39;s representation.
 36 
 37 typedef juint narrowOop; // Offset instead of address for an oop within a java object
 38 
 39 // If compressed klass pointers then use narrowKlass.
 40 typedef juint  narrowKlass;
 41 
 42 typedef void* OopOrNarrowOopStar;
<span class="line-removed"> 43 typedef class   markOopDesc*                markOop;</span>
 44 
 45 #ifndef CHECK_UNHANDLED_OOPS
 46 
<span class="line-modified"> 47 typedef class oopDesc*                            oop;</span>
 48 typedef class   instanceOopDesc*            instanceOop;
<span class="line-modified"> 49 typedef class   arrayOopDesc*                    arrayOop;</span>
 50 typedef class     objArrayOopDesc*            objArrayOop;
<span class="line-modified"> 51 typedef class     typeArrayOopDesc*            typeArrayOop;</span>
 52 
 53 #else
 54 
 55 // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
 56 // carefully chosen set of constructors and conversion operators to go
 57 // to and from the underlying oopDesc pointer type.
 58 //
 59 // Because oop and its subclasses &lt;type&gt;Oop are class types, arbitrary
 60 // conversions are not accepted by the compiler.  Applying a cast to
 61 // an oop will cause the best matched conversion operator to be
 62 // invoked returning the underlying oopDesc* type if appropriate.
 63 // No copy constructors, explicit user conversions or operators of
 64 // numerical type should be defined within the oop class. Most C++
 65 // compilers will issue a compile time error concerning the overloading
 66 // ambiguity between operators of numerical and pointer types. If
 67 // a conversion to or from an oop to a numerical type is needed,
 68 // use the inline template methods, cast_*_oop, defined below.
 69 //
 70 // Converting NULL to oop to Handle implicit is no longer accepted by the
 71 // compiler because there are too many steps in the conversion.  Use Handle()
 72 // instead, which generates less code anyway.
 73 
 74 class Thread;
<span class="line-removed"> 75 class PromotedObject;</span>
 76 class oopDesc;
 77 


 78 class oop {
 79   oopDesc* _o;
 80 
 81   void register_oop();
 82   void unregister_oop();
 83 
<span class="line-removed"> 84   // friend class markOop;</span>
 85 public:
 86   void set_obj(const void* p)         {
 87     raw_set_obj(p);
 88     if (CheckUnhandledOops) register_oop();
 89   }
 90   void raw_set_obj(const void* p)     { _o = (oopDesc*)p; }
 91 
 92   oop()                               { set_obj(NULL); }
 93   oop(const oop&amp; o)                   { set_obj(o.obj()); }
 94   oop(const volatile oop&amp; o)          { set_obj(o.obj()); }
 95   oop(const void* p)                  { set_obj(p); }
 96   ~oop()                              {
 97     if (CheckUnhandledOops) unregister_oop();
 98   }
 99 
100   oopDesc* obj()  const volatile      { return _o; }
101 
102   // General access
103   oopDesc*  operator-&gt;() const        { return obj(); }
<span class="line-modified">104   bool operator==(const oop o) const;</span>
105   bool operator==(void *p) const      { return obj() == p; }
<span class="line-modified">106   bool operator!=(const volatile oop o) const;</span>
107   bool operator!=(void *p) const      { return obj() != p; }
108 
109   // Assignment
110   oop&amp; operator=(const oop&amp; o)                            { _o = o.obj(); return *this; }
111   volatile oop&amp; operator=(const oop&amp; o) volatile          { _o = o.obj(); return *this; }
112   volatile oop&amp; operator=(const volatile oop&amp; o) volatile { _o = o.obj(); return *this; }
113 
114   // Explict user conversions
<span class="line-removed">115   operator void* () const             { return (void *)obj(); }</span>
<span class="line-removed">116 #ifndef SOLARIS</span>
<span class="line-removed">117   operator void* () const volatile    { return (void *)obj(); }</span>
<span class="line-removed">118 #endif</span>
<span class="line-removed">119   operator HeapWord* () const         { return (HeapWord*)obj(); }</span>
120   operator oopDesc* () const volatile { return obj(); }
<span class="line-removed">121   operator intptr_t* () const         { return (intptr_t*)obj(); }</span>
<span class="line-removed">122   operator PromotedObject* () const   { return (PromotedObject*)obj(); }</span>
<span class="line-removed">123   operator markOop () const volatile  { return markOop(obj()); }</span>
<span class="line-removed">124   operator address   () const         { return (address)obj(); }</span>
<span class="line-removed">125 </span>
<span class="line-removed">126   // from javaCalls.cpp</span>
<span class="line-removed">127   operator jobject () const           { return (jobject)obj(); }</span>
<span class="line-removed">128 </span>
<span class="line-removed">129   // from parNewGeneration and other things that want to get to the end of</span>
<span class="line-removed">130   // an oop for stuff (like ObjArrayKlass.cpp)</span>
<span class="line-removed">131   operator oop* () const              { return (oop *)obj(); }</span>
132 };
133 
134 template&lt;&gt;
135 struct PrimitiveConversions::Translate&lt;oop&gt; : public TrueType {
136   typedef oop Value;
137   typedef oopDesc* Decayed;
138 
139   static Decayed decay(Value x) { return x.obj(); }
140   static Value recover(Decayed x) { return oop(x); }
141 };
142 
143 #define DEF_OOP(type)                                                      \
144    class type##OopDesc;                                                    \
145    class type##Oop : public oop {                                          \
146      public:                                                               \
147        type##Oop() : oop() {}                                              \
148        type##Oop(const oop&amp; o) : oop(o) {}                                 \
149        type##Oop(const volatile oop&amp; o) : oop(o) {}                        \
150        type##Oop(const void* p) : oop(p) {}                                \
151        operator type##OopDesc* () const { return (type##OopDesc*)obj(); }  \
</pre>
<hr />
<pre>
172      typedef type##OopDesc* Decayed;                                       \
173                                                                            \
174      static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \
175      static Value recover(Decayed x) { return type##Oop(x); }              \
176    };
177 
178 DEF_OOP(instance);
179 DEF_OOP(array);
180 DEF_OOP(objArray);
181 DEF_OOP(typeArray);
182 
183 #endif // CHECK_UNHANDLED_OOPS
184 
185 // For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop
186 // structure contain explicit user defined conversions of both numerical
187 // and pointer type. Define inline methods to provide the numerical conversions.
188 template &lt;class T&gt; inline oop cast_to_oop(T value) {
189   return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
190 }
191 template &lt;class T&gt; inline T cast_from_oop(oop o) {
<span class="line-modified">192   return (T)(CHECK_UNHANDLED_OOPS_ONLY((void*))o);</span>
<span class="line-removed">193 }</span>
<span class="line-removed">194 </span>
<span class="line-removed">195 inline bool check_obj_alignment(oop obj) {</span>
<span class="line-removed">196   return (cast_from_oop&lt;intptr_t&gt;(obj) &amp; MinObjAlignmentInBytesMask) == 0;</span>
197 }
198 
199 // The metadata hierarchy is separate from the oop hierarchy
200 
201 //      class MetaspaceObj
202 class   ConstMethod;
203 class   ConstantPoolCache;
204 class   MethodData;
205 //      class Metadata
206 class   Method;
207 class   ConstantPool;
208 //      class CHeapObj
209 class   CompiledICHolder;
210 
211 
212 // The klass hierarchy is separate from the oop hierarchy.
213 
214 class Klass;
215 class   InstanceKlass;
216 class     InstanceMirrorKlass;
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOPSHIERARCHY_HPP
 26 #define SHARE_OOPS_OOPSHIERARCHY_HPP
 27 
 28 #include &quot;metaprogramming/integralConstant.hpp&quot;
 29 #include &quot;metaprogramming/primitiveConversions.hpp&quot;

 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 // OBJECT hierarchy
 33 // This hierarchy is a representation hierarchy, i.e. if A is a superclass
 34 // of B, A&#39;s representation is a prefix of B&#39;s representation.
 35 
 36 typedef juint narrowOop; // Offset instead of address for an oop within a java object
 37 
 38 // If compressed klass pointers then use narrowKlass.
 39 typedef juint  narrowKlass;
 40 
 41 typedef void* OopOrNarrowOopStar;

 42 
 43 #ifndef CHECK_UNHANDLED_OOPS
 44 
<span class="line-modified"> 45 typedef class oopDesc*                    oop;</span>
 46 typedef class   instanceOopDesc*            instanceOop;
<span class="line-modified"> 47 typedef class   arrayOopDesc*               arrayOop;</span>
 48 typedef class     objArrayOopDesc*            objArrayOop;
<span class="line-modified"> 49 typedef class     typeArrayOopDesc*           typeArrayOop;</span>
 50 
 51 #else
 52 
 53 // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
 54 // carefully chosen set of constructors and conversion operators to go
 55 // to and from the underlying oopDesc pointer type.
 56 //
 57 // Because oop and its subclasses &lt;type&gt;Oop are class types, arbitrary
 58 // conversions are not accepted by the compiler.  Applying a cast to
 59 // an oop will cause the best matched conversion operator to be
 60 // invoked returning the underlying oopDesc* type if appropriate.
 61 // No copy constructors, explicit user conversions or operators of
 62 // numerical type should be defined within the oop class. Most C++
 63 // compilers will issue a compile time error concerning the overloading
 64 // ambiguity between operators of numerical and pointer types. If
 65 // a conversion to or from an oop to a numerical type is needed,
 66 // use the inline template methods, cast_*_oop, defined below.
 67 //
 68 // Converting NULL to oop to Handle implicit is no longer accepted by the
 69 // compiler because there are too many steps in the conversion.  Use Handle()
 70 // instead, which generates less code anyway.
 71 
 72 class Thread;

 73 class oopDesc;
 74 
<span class="line-added"> 75 extern &quot;C&quot; bool CheckUnhandledOops;</span>
<span class="line-added"> 76 </span>
 77 class oop {
 78   oopDesc* _o;
 79 
 80   void register_oop();
 81   void unregister_oop();
 82 

 83 public:
 84   void set_obj(const void* p)         {
 85     raw_set_obj(p);
 86     if (CheckUnhandledOops) register_oop();
 87   }
 88   void raw_set_obj(const void* p)     { _o = (oopDesc*)p; }
 89 
 90   oop()                               { set_obj(NULL); }
 91   oop(const oop&amp; o)                   { set_obj(o.obj()); }
 92   oop(const volatile oop&amp; o)          { set_obj(o.obj()); }
 93   oop(const void* p)                  { set_obj(p); }
 94   ~oop()                              {
 95     if (CheckUnhandledOops) unregister_oop();
 96   }
 97 
 98   oopDesc* obj()  const volatile      { return _o; }
 99 
100   // General access
101   oopDesc*  operator-&gt;() const        { return obj(); }
<span class="line-modified">102   bool operator==(const oop o) const  { return obj() == o.obj(); }</span>
103   bool operator==(void *p) const      { return obj() == p; }
<span class="line-modified">104   bool operator!=(const volatile oop o) const { return obj() != o.obj(); }</span>
105   bool operator!=(void *p) const      { return obj() != p; }
106 
107   // Assignment
108   oop&amp; operator=(const oop&amp; o)                            { _o = o.obj(); return *this; }
109   volatile oop&amp; operator=(const oop&amp; o) volatile          { _o = o.obj(); return *this; }
110   volatile oop&amp; operator=(const volatile oop&amp; o) volatile { _o = o.obj(); return *this; }
111 
112   // Explict user conversions





113   operator oopDesc* () const volatile { return obj(); }











114 };
115 
116 template&lt;&gt;
117 struct PrimitiveConversions::Translate&lt;oop&gt; : public TrueType {
118   typedef oop Value;
119   typedef oopDesc* Decayed;
120 
121   static Decayed decay(Value x) { return x.obj(); }
122   static Value recover(Decayed x) { return oop(x); }
123 };
124 
125 #define DEF_OOP(type)                                                      \
126    class type##OopDesc;                                                    \
127    class type##Oop : public oop {                                          \
128      public:                                                               \
129        type##Oop() : oop() {}                                              \
130        type##Oop(const oop&amp; o) : oop(o) {}                                 \
131        type##Oop(const volatile oop&amp; o) : oop(o) {}                        \
132        type##Oop(const void* p) : oop(p) {}                                \
133        operator type##OopDesc* () const { return (type##OopDesc*)obj(); }  \
</pre>
<hr />
<pre>
154      typedef type##OopDesc* Decayed;                                       \
155                                                                            \
156      static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \
157      static Value recover(Decayed x) { return type##Oop(x); }              \
158    };
159 
160 DEF_OOP(instance);
161 DEF_OOP(array);
162 DEF_OOP(objArray);
163 DEF_OOP(typeArray);
164 
165 #endif // CHECK_UNHANDLED_OOPS
166 
167 // For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop
168 // structure contain explicit user defined conversions of both numerical
169 // and pointer type. Define inline methods to provide the numerical conversions.
170 template &lt;class T&gt; inline oop cast_to_oop(T value) {
171   return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
172 }
173 template &lt;class T&gt; inline T cast_from_oop(oop o) {
<span class="line-modified">174   return (T)(CHECK_UNHANDLED_OOPS_ONLY((oopDesc*))o);</span>




175 }
176 
177 // The metadata hierarchy is separate from the oop hierarchy
178 
179 //      class MetaspaceObj
180 class   ConstMethod;
181 class   ConstantPoolCache;
182 class   MethodData;
183 //      class Metadata
184 class   Method;
185 class   ConstantPool;
186 //      class CHeapObj
187 class   CompiledICHolder;
188 
189 
190 // The klass hierarchy is separate from the oop hierarchy.
191 
192 class Klass;
193 class   InstanceKlass;
194 class     InstanceMirrorKlass;
</pre>
</td>
</tr>
</table>
<center><a href="oopsHierarchy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
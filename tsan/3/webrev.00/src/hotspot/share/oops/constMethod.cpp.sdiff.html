<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compressedOops.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-removed"> 27 #include &quot;memory/heapInspection.hpp&quot;</span>
 28 #include &quot;memory/metadataFactory.hpp&quot;
 29 #include &quot;memory/metaspaceClosure.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/constMethod.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;runtime/safepointVerifiers.hpp&quot;
 34 #include &quot;utilities/align.hpp&quot;
 35 
 36 // Static initialization
 37 const u2 ConstMethod::MAX_IDNUM   = 0xFFFE;
 38 const u2 ConstMethod::UNSET_IDNUM = 0xFFFF;
 39 
 40 ConstMethod* ConstMethod::allocate(ClassLoaderData* loader_data,
 41                                    int byte_code_size,
 42                                    InlineTableSizes* sizes,
 43                                    MethodType method_type,
 44                                    TRAPS) {
 45   int size = ConstMethod::size(byte_code_size, sizes);
 46   return new (loader_data, size, MetaspaceObj::ConstMethodType, THREAD) ConstMethod(
 47       byte_code_size, sizes, method_type, size);
</pre>
<hr />
<pre>
 51                          InlineTableSizes* sizes,
 52                          MethodType method_type,
 53                          int size) {
 54 
 55   NoSafepointVerifier no_safepoint;
 56   init_fingerprint();
 57   set_constants(NULL);
 58   set_stackmap_data(NULL);
 59   set_code_size(byte_code_size);
 60   set_constMethod_size(size);
 61   set_inlined_tables_length(sizes); // sets _flags
 62   set_method_type(method_type);
 63   assert(this-&gt;size() == size, &quot;wrong size for object&quot;);
 64   set_name_index(0);
 65   set_signature_index(0);
 66   set_constants(NULL);
 67   set_max_stack(0);
 68   set_max_locals(0);
 69   set_method_idnum(0);
 70   set_size_of_parameters(0);
<span class="line-modified"> 71   set_result_type(T_VOID);</span>
 72 }
 73 
 74 // Accessor that copies to metadata.
 75 void ConstMethod::copy_stackmap_data(ClassLoaderData* loader_data,
 76                                      u1* sd, int length, TRAPS) {
 77   _stackmap_data = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, CHECK);
 78   memcpy((void*)_stackmap_data-&gt;adr_at(0), (void*)sd, length);
 79 }
 80 
 81 // Deallocate metadata fields associated with ConstMethod*
 82 void ConstMethod::deallocate_contents(ClassLoaderData* loader_data) {
 83   if (stackmap_data() != NULL) {
 84     MetadataFactory::free_array&lt;u1&gt;(loader_data, stackmap_data());
 85   }
 86   set_stackmap_data(NULL);
 87 
 88   // deallocate annotation arrays
 89   if (has_method_annotations())
 90     MetadataFactory::free_array&lt;u1&gt;(loader_data, method_annotations());
 91   if (has_parameter_annotations())
</pre>
<hr />
<pre>
403   }
404 }
405 
406 void ConstMethod::metaspace_pointers_do(MetaspaceClosure* it) {
407   log_trace(cds)(&quot;Iter(ConstMethod): %p&quot;, this);
408 
409   it-&gt;push(&amp;_constants);
410   it-&gt;push(&amp;_stackmap_data);
411   if (has_method_annotations()) {
412     it-&gt;push(method_annotations_addr());
413   }
414   if (has_parameter_annotations()) {
415       it-&gt;push(parameter_annotations_addr());
416   }
417   if (has_type_annotations()) {
418       it-&gt;push(type_annotations_addr());
419   }
420   if (has_default_annotations()) {
421       it-&gt;push(default_annotations_addr());
422   }


423 }
424 
425 // Printing
426 
427 void ConstMethod::print_on(outputStream* st) const {
428   ResourceMark rm;
429   st-&gt;print_cr(&quot;%s&quot;, internal_name());
430   Method* m = method();
431   st-&gt;print(&quot; - method:       &quot; INTPTR_FORMAT &quot; &quot;, p2i((address)m));
432   if (m != NULL) {
433     m-&gt;print_value_on(st);
434   }
435   st-&gt;cr();
436   if (has_stackmap_table()) {
437     st-&gt;print(&quot; - stackmap data:       &quot;);
438     stackmap_data()-&gt;print_value_on(st);
439     st-&gt;cr();
440   }
441 }
442 
443 // Short version of printing ConstMethod* - just print the name of the
444 // method it belongs to.
445 void ConstMethod::print_value_on(outputStream* st) const {
446   st-&gt;print(&quot; const part of method &quot; );
447   Method* m = method();
448   if (m != NULL) {
449     m-&gt;print_value_on(st);
450   } else {
451     st-&gt;print(&quot;NULL&quot;);
452   }
453 }
454 
<span class="line-removed">455 #if INCLUDE_SERVICES</span>
<span class="line-removed">456 // Size Statistics</span>
<span class="line-removed">457 void ConstMethod::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="line-removed">458   int n1, n2, n3;</span>
<span class="line-removed">459   sz-&gt;_const_method_bytes += (n1 = sz-&gt;count(this));</span>
<span class="line-removed">460   sz-&gt;_bytecode_bytes     += (n2 = code_size());</span>
<span class="line-removed">461   sz-&gt;_stackmap_bytes     += (n3 = sz-&gt;count_array(stackmap_data()));</span>
<span class="line-removed">462 </span>
<span class="line-removed">463   // Count method annotations</span>
<span class="line-removed">464   int a1 = 0, a2 = 0, a3 = 0, a4 = 0;</span>
<span class="line-removed">465   if (has_method_annotations()) {</span>
<span class="line-removed">466     sz-&gt;_methods_annotations_bytes += (a1 = sz-&gt;count_array(method_annotations()));</span>
<span class="line-removed">467   }</span>
<span class="line-removed">468   if (has_parameter_annotations()) {</span>
<span class="line-removed">469     sz-&gt;_methods_parameter_annotations_bytes += (a2 = sz-&gt;count_array(parameter_annotations()));</span>
<span class="line-removed">470   }</span>
<span class="line-removed">471   if (has_type_annotations()) {</span>
<span class="line-removed">472     sz-&gt;_methods_type_annotations_bytes += (a3 = sz-&gt;count_array(type_annotations()));</span>
<span class="line-removed">473   }</span>
<span class="line-removed">474   if (has_default_annotations()) {</span>
<span class="line-removed">475     sz-&gt;_methods_default_annotations_bytes += (a4 = sz-&gt;count_array(default_annotations()));</span>
<span class="line-removed">476   }</span>
<span class="line-removed">477 </span>
<span class="line-removed">478   int size_annotations = a1 + a2 + a3 + a4;</span>
<span class="line-removed">479 </span>
<span class="line-removed">480   sz-&gt;_method_all_bytes += n1 + n3 + size_annotations; // note: n2 is part of n3</span>
<span class="line-removed">481   sz-&gt;_ro_bytes += n1 + n3 + size_annotations;</span>
<span class="line-removed">482 }</span>
<span class="line-removed">483 #endif // INCLUDE_SERVICES</span>
<span class="line-removed">484 </span>
485 // Verification
486 
487 void ConstMethod::verify_on(outputStream* st) {
488   // Verification can occur during oop construction before the method or
489   // other fields have been initialized.
490   guarantee(method() != NULL &amp;&amp; method()-&gt;is_method(), &quot;should be method&quot;);
491 
492   address m_end = (address)((intptr_t) this + size());
493   address compressed_table_start = code_end();
494   guarantee(compressed_table_start &lt;= m_end, &quot;invalid method layout&quot;);
495   address compressed_table_end = compressed_table_start;
496   // Verify line number table
497   if (has_linenumber_table()) {
498     CompressedLineNumberReadStream stream(compressed_linenumber_table());
499     while (stream.read_pair()) {
500       guarantee(stream.bci() &gt;= 0 &amp;&amp; stream.bci() &lt;= code_size(), &quot;invalid bci in line number table&quot;);
501     }
502     compressed_table_end += stream.position();
503   }
504   guarantee(compressed_table_end &lt;= m_end, &quot;invalid method layout&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;

 27 #include &quot;memory/metadataFactory.hpp&quot;
 28 #include &quot;memory/metaspaceClosure.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/constMethod.hpp&quot;
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;runtime/safepointVerifiers.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Static initialization
 36 const u2 ConstMethod::MAX_IDNUM   = 0xFFFE;
 37 const u2 ConstMethod::UNSET_IDNUM = 0xFFFF;
 38 
 39 ConstMethod* ConstMethod::allocate(ClassLoaderData* loader_data,
 40                                    int byte_code_size,
 41                                    InlineTableSizes* sizes,
 42                                    MethodType method_type,
 43                                    TRAPS) {
 44   int size = ConstMethod::size(byte_code_size, sizes);
 45   return new (loader_data, size, MetaspaceObj::ConstMethodType, THREAD) ConstMethod(
 46       byte_code_size, sizes, method_type, size);
</pre>
<hr />
<pre>
 50                          InlineTableSizes* sizes,
 51                          MethodType method_type,
 52                          int size) {
 53 
 54   NoSafepointVerifier no_safepoint;
 55   init_fingerprint();
 56   set_constants(NULL);
 57   set_stackmap_data(NULL);
 58   set_code_size(byte_code_size);
 59   set_constMethod_size(size);
 60   set_inlined_tables_length(sizes); // sets _flags
 61   set_method_type(method_type);
 62   assert(this-&gt;size() == size, &quot;wrong size for object&quot;);
 63   set_name_index(0);
 64   set_signature_index(0);
 65   set_constants(NULL);
 66   set_max_stack(0);
 67   set_max_locals(0);
 68   set_method_idnum(0);
 69   set_size_of_parameters(0);
<span class="line-modified"> 70   set_result_type((BasicType)0);</span>
 71 }
 72 
 73 // Accessor that copies to metadata.
 74 void ConstMethod::copy_stackmap_data(ClassLoaderData* loader_data,
 75                                      u1* sd, int length, TRAPS) {
 76   _stackmap_data = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, CHECK);
 77   memcpy((void*)_stackmap_data-&gt;adr_at(0), (void*)sd, length);
 78 }
 79 
 80 // Deallocate metadata fields associated with ConstMethod*
 81 void ConstMethod::deallocate_contents(ClassLoaderData* loader_data) {
 82   if (stackmap_data() != NULL) {
 83     MetadataFactory::free_array&lt;u1&gt;(loader_data, stackmap_data());
 84   }
 85   set_stackmap_data(NULL);
 86 
 87   // deallocate annotation arrays
 88   if (has_method_annotations())
 89     MetadataFactory::free_array&lt;u1&gt;(loader_data, method_annotations());
 90   if (has_parameter_annotations())
</pre>
<hr />
<pre>
402   }
403 }
404 
405 void ConstMethod::metaspace_pointers_do(MetaspaceClosure* it) {
406   log_trace(cds)(&quot;Iter(ConstMethod): %p&quot;, this);
407 
408   it-&gt;push(&amp;_constants);
409   it-&gt;push(&amp;_stackmap_data);
410   if (has_method_annotations()) {
411     it-&gt;push(method_annotations_addr());
412   }
413   if (has_parameter_annotations()) {
414       it-&gt;push(parameter_annotations_addr());
415   }
416   if (has_type_annotations()) {
417       it-&gt;push(type_annotations_addr());
418   }
419   if (has_default_annotations()) {
420       it-&gt;push(default_annotations_addr());
421   }
<span class="line-added">422   ConstMethod* this_ptr = this;</span>
<span class="line-added">423   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_adapter_trampoline);</span>
424 }
425 
426 // Printing
427 
428 void ConstMethod::print_on(outputStream* st) const {
429   ResourceMark rm;
430   st-&gt;print_cr(&quot;%s&quot;, internal_name());
431   Method* m = method();
432   st-&gt;print(&quot; - method:       &quot; INTPTR_FORMAT &quot; &quot;, p2i((address)m));
433   if (m != NULL) {
434     m-&gt;print_value_on(st);
435   }
436   st-&gt;cr();
437   if (has_stackmap_table()) {
438     st-&gt;print(&quot; - stackmap data:       &quot;);
439     stackmap_data()-&gt;print_value_on(st);
440     st-&gt;cr();
441   }
442 }
443 
444 // Short version of printing ConstMethod* - just print the name of the
445 // method it belongs to.
446 void ConstMethod::print_value_on(outputStream* st) const {
447   st-&gt;print(&quot; const part of method &quot; );
448   Method* m = method();
449   if (m != NULL) {
450     m-&gt;print_value_on(st);
451   } else {
452     st-&gt;print(&quot;NULL&quot;);
453   }
454 }
455 






























456 // Verification
457 
458 void ConstMethod::verify_on(outputStream* st) {
459   // Verification can occur during oop construction before the method or
460   // other fields have been initialized.
461   guarantee(method() != NULL &amp;&amp; method()-&gt;is_method(), &quot;should be method&quot;);
462 
463   address m_end = (address)((intptr_t) this + size());
464   address compressed_table_start = code_end();
465   guarantee(compressed_table_start &lt;= m_end, &quot;invalid method layout&quot;);
466   address compressed_table_end = compressed_table_start;
467   // Verify line number table
468   if (has_linenumber_table()) {
469     CompressedLineNumberReadStream stream(compressed_linenumber_table());
470     while (stream.read_pair()) {
471       guarantee(stream.bci() &gt;= 0 &amp;&amp; stream.bci() &lt;= code_size(), &quot;invalid bci in line number table&quot;);
472     }
473     compressed_table_end += stream.position();
474   }
475   guarantee(compressed_table_end &lt;= m_end, &quot;invalid method layout&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="compressedOops.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
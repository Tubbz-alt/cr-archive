<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/access.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_ACCESS_INLINE_HPP
 26 #define SHARE_OOPS_ACCESS_INLINE_HPP
 27 
 28 #include &quot;gc/shared/barrierSet.inline.hpp&quot;
 29 #include &quot;gc/shared/barrierSetConfig.inline.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
 31 #include &quot;oops/accessBackend.inline.hpp&quot;
 32 
 33 // This file outlines the last 2 steps of the template pipeline of accesses going through
 34 // the Access API.
 35 // * Step 5.a: Barrier resolution. This step is invoked the first time a runtime-dispatch
 36 //             happens for an access. The appropriate BarrierSet::AccessBarrier accessor
 37 //             is resolved, then the function pointer is updated to that accessor for
 38 //             future invocations.
 39 // * Step 5.b: Post-runtime dispatch. This step now casts previously unknown types such
 40 //             as the address type of an oop on the heap (is it oop* or narrowOop*) to
 41 //             the appropriate type. It also splits sufficiently orthogonal accesses into
 42 //             different functions, such as whether the access involves oops or primitives
 43 //             and whether the access is performed on the heap or outside. Then the
 44 //             appropriate BarrierSet::AccessBarrier is called to perform the access.
 45 
 46 namespace AccessInternal {
 47   // Step 5.b: Post-runtime dispatch.
 48   // This class is the last step before calling the BarrierSet::AccessBarrier.
 49   // Here we make sure to figure out types that were not known prior to the
 50   // runtime dispatch, such as whether an oop on the heap is oop or narrowOop.
 51   // We also split orthogonal barriers such as handling primitives vs oops
 52   // and on-heap vs off-heap into different calls to the barrier set.
 53   template &lt;class GCBarrierType, BarrierType type, DecoratorSet decorators&gt;
 54   struct PostRuntimeDispatch: public AllStatic { };
 55 
 56   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 57   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_STORE, decorators&gt;: public AllStatic {
 58     template &lt;typename T&gt;
 59     static void access_barrier(void* addr, T value) {
 60       GCBarrierType::store_in_heap(reinterpret_cast&lt;T*&gt;(addr), value);
 61     }
 62 
 63     static void oop_access_barrier(void* addr, oop value) {
 64       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 65       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 66         GCBarrierType::oop_store_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), value);
 67       } else {
 68         GCBarrierType::oop_store_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr), value);
 69       }
 70     }
 71   };
 72 
 73   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 74   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD, decorators&gt;: public AllStatic {
 75     template &lt;typename T&gt;
 76     static T access_barrier(void* addr) {
 77       return GCBarrierType::load_in_heap(reinterpret_cast&lt;T*&gt;(addr));
 78     }
 79 
 80     static oop oop_access_barrier(void* addr) {
 81       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 82       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
 83         return GCBarrierType::oop_load_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 84       } else {
 85         return GCBarrierType::oop_load_not_in_heap(reinterpret_cast&lt;OopType*&gt;(addr));
 86       }
 87     }
 88   };
 89 
 90   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
 91   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG, decorators&gt;: public AllStatic {
 92     template &lt;typename T&gt;
 93     static T access_barrier(T new_value, void* addr) {
 94       return GCBarrierType::atomic_xchg_in_heap(new_value, reinterpret_cast&lt;T*&gt;(addr));
 95     }
 96 
 97     static oop oop_access_barrier(oop new_value, void* addr) {
 98       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
 99       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
100         return GCBarrierType::oop_atomic_xchg_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr));
101       } else {
102         return GCBarrierType::oop_atomic_xchg_not_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr));
103       }
104     }
105   };
106 
107   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
108   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG, decorators&gt;: public AllStatic {
109     template &lt;typename T&gt;
110     static T access_barrier(T new_value, void* addr, T compare_value) {
111       return GCBarrierType::atomic_cmpxchg_in_heap(new_value, reinterpret_cast&lt;T*&gt;(addr), compare_value);
112     }
113 
114     static oop oop_access_barrier(oop new_value, void* addr, oop compare_value) {
115       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
116       if (HasDecorator&lt;decorators, IN_HEAP&gt;::value) {
117         return GCBarrierType::oop_atomic_cmpxchg_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr), compare_value);
118       } else {
119         return GCBarrierType::oop_atomic_cmpxchg_not_in_heap(new_value, reinterpret_cast&lt;OopType*&gt;(addr), compare_value);
120       }
121     }
122   };
123 
124   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
125   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ARRAYCOPY, decorators&gt;: public AllStatic {
126     template &lt;typename T&gt;
127     static bool access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
128                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
129                                size_t length) {
130       GCBarrierType::arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw,
131                                        dst_obj, dst_offset_in_bytes, dst_raw,
132                                        length);
133       return true;
134     }
135 
136     template &lt;typename T&gt;
137     static bool oop_access_barrier(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
138                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
139                                    size_t length) {
140       typedef typename HeapOopType&lt;decorators&gt;::type OopType;
141       return GCBarrierType::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, reinterpret_cast&lt;OopType*&gt;(src_raw),
142                                                   dst_obj, dst_offset_in_bytes, reinterpret_cast&lt;OopType*&gt;(dst_raw),
143                                                   length);
144     }
145   };
146 
147   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
148   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_STORE_AT, decorators&gt;: public AllStatic {
149     template &lt;typename T&gt;
150     static void access_barrier(oop base, ptrdiff_t offset, T value) {
151       GCBarrierType::store_in_heap_at(base, offset, value);
152     }
153 
154     static void oop_access_barrier(oop base, ptrdiff_t offset, oop value) {
155       GCBarrierType::oop_store_in_heap_at(base, offset, value);
156     }
157   };
158 
159   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
160   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_LOAD_AT, decorators&gt;: public AllStatic {
161     template &lt;typename T&gt;
162     static T access_barrier(oop base, ptrdiff_t offset) {
163       return GCBarrierType::template load_in_heap_at&lt;T&gt;(base, offset);
164     }
165 
166     static oop oop_access_barrier(oop base, ptrdiff_t offset) {
167       return GCBarrierType::oop_load_in_heap_at(base, offset);
168     }
169   };
170 
171   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
172   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_XCHG_AT, decorators&gt;: public AllStatic {
173     template &lt;typename T&gt;
174     static T access_barrier(T new_value, oop base, ptrdiff_t offset) {
175       return GCBarrierType::atomic_xchg_in_heap_at(new_value, base, offset);
176     }
177 
178     static oop oop_access_barrier(oop new_value, oop base, ptrdiff_t offset) {
179       return GCBarrierType::oop_atomic_xchg_in_heap_at(new_value, base, offset);
180     }
181   };
182 
183   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
184   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_ATOMIC_CMPXCHG_AT, decorators&gt;: public AllStatic {
185     template &lt;typename T&gt;
186     static T access_barrier(T new_value, oop base, ptrdiff_t offset, T compare_value) {
187       return GCBarrierType::atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);
188     }
189 
190     static oop oop_access_barrier(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {
191       return GCBarrierType::oop_atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);
192     }
193   };
194 
195   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
196   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_CLONE, decorators&gt;: public AllStatic {
197     static void access_barrier(oop src, oop dst, size_t size) {
198       GCBarrierType::clone_in_heap(src, dst, size);
199     }
200   };
201 
202   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
203   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_RESOLVE, decorators&gt;: public AllStatic {
204     static oop access_barrier(oop obj) {
205       return GCBarrierType::resolve(obj);
206     }
207   };
208 
209   template &lt;class GCBarrierType, DecoratorSet decorators&gt;
210   struct PostRuntimeDispatch&lt;GCBarrierType, BARRIER_EQUALS, decorators&gt;: public AllStatic {
211     static bool access_barrier(oop o1, oop o2) {
212       return GCBarrierType::equals(o1, o2);
213     }
214   };
215 
216   // Resolving accessors with barriers from the barrier set happens in two steps.
217   // 1. Expand paths with runtime-decorators, e.g. is UseCompressedOops on or off.
218   // 2. Expand paths for each BarrierSet available in the system.
219   template &lt;DecoratorSet decorators, typename FunctionPointerT, BarrierType barrier_type&gt;
220   struct BarrierResolver: public AllStatic {
221     template &lt;DecoratorSet ds&gt;
222     static typename EnableIf&lt;
223       HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
224       FunctionPointerT&gt;::type
225     resolve_barrier_gc() {
226       BarrierSet* bs = BarrierSet::barrier_set();
227       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
228       switch (bs-&gt;kind()) {
229 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
230         case BarrierSet::bs_name: {                                     \
231           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
232             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::oop_access_barrier; \
233         }                                                               \
234         break;
235         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
236 #undef BARRIER_SET_RESOLVE_BARRIER_CLOSURE
237 
238       default:
239         fatal(&quot;BarrierSet AccessBarrier resolving not implemented&quot;);
240         return NULL;
241       };
242     }
243 
244     template &lt;DecoratorSet ds&gt;
245     static typename EnableIf&lt;
246       !HasDecorator&lt;ds, INTERNAL_VALUE_IS_OOP&gt;::value,
247       FunctionPointerT&gt;::type
248     resolve_barrier_gc() {
249       BarrierSet* bs = BarrierSet::barrier_set();
250       assert(bs != NULL, &quot;GC barriers invoked before BarrierSet is set&quot;);
251       switch (bs-&gt;kind()) {
252 #define BARRIER_SET_RESOLVE_BARRIER_CLOSURE(bs_name)                    \
253         case BarrierSet::bs_name: {                                       \
254           return PostRuntimeDispatch&lt;typename BarrierSet::GetType&lt;BarrierSet::bs_name&gt;::type:: \
255             AccessBarrier&lt;ds&gt;, barrier_type, ds&gt;::access_barrier; \
256         }                                                                 \
257         break;
258         FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)
259 #undef BARRIER_SET_RESOLVE_BARRIER_CLOSURE
260 
261       default:
262         fatal(&quot;BarrierSet AccessBarrier resolving not implemented&quot;);
263         return NULL;
264       };
265     }
266 
267     static FunctionPointerT resolve_barrier_rt() {
268       if (UseCompressedOops) {
269         const DecoratorSet expanded_decorators = decorators | INTERNAL_RT_USE_COMPRESSED_OOPS;
270         return resolve_barrier_gc&lt;expanded_decorators&gt;();
271       } else {
272         return resolve_barrier_gc&lt;decorators&gt;();
273       }
274     }
275 
276     static FunctionPointerT resolve_barrier() {
277       return resolve_barrier_rt();
278     }
279   };
280 
281   // Step 5.a: Barrier resolution
282   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
283   // accessor. This is required when the access either depends on whether compressed oops
284   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
285   // barriers). The way it works is that a function pointer initially pointing to an
286   // accessor resolution function gets called for each access. Upon first invocation,
287   // it resolves which accessor to be used in future invocations and patches the
288   // function pointer to this new accessor.
289 
290   template &lt;DecoratorSet decorators, typename T&gt;
291   void RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store_init(void* addr, T value) {
292     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE&gt;::resolve_barrier();
293     _store_func = function;
294     function(addr, value);
295   }
296 
297   template &lt;DecoratorSet decorators, typename T&gt;
298   void RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at_init(oop base, ptrdiff_t offset, T value) {
299     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_STORE_AT&gt;::resolve_barrier();
300     _store_at_func = function;
301     function(base, offset, value);
302   }
303 
304   template &lt;DecoratorSet decorators, typename T&gt;
305   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load_init(void* addr) {
306     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD&gt;::resolve_barrier();
307     _load_func = function;
308     return function(addr);
309   }
310 
311   template &lt;DecoratorSet decorators, typename T&gt;
312   T RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at_init(oop base, ptrdiff_t offset) {
313     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_LOAD_AT&gt;::resolve_barrier();
314     _load_at_func = function;
315     return function(base, offset);
316   }
317 
318   template &lt;DecoratorSet decorators, typename T&gt;
319   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg_init(T new_value, void* addr, T compare_value) {
320     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG&gt;::resolve_barrier();
321     _atomic_cmpxchg_func = function;
322     return function(new_value, addr, compare_value);
323   }
324 
325   template &lt;DecoratorSet decorators, typename T&gt;
326   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value) {
327     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_CMPXCHG_AT&gt;::resolve_barrier();
328     _atomic_cmpxchg_at_func = function;
329     return function(new_value, base, offset, compare_value);
330   }
331 
332   template &lt;DecoratorSet decorators, typename T&gt;
333   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg_init(T new_value, void* addr) {
334     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG&gt;::resolve_barrier();
335     _atomic_xchg_func = function;
336     return function(new_value, addr);
337   }
338 
339   template &lt;DecoratorSet decorators, typename T&gt;
340   T RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset) {
341     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ATOMIC_XCHG_AT&gt;::resolve_barrier();
342     _atomic_xchg_at_func = function;
343     return function(new_value, base, offset);
344   }
345 
346   template &lt;DecoratorSet decorators, typename T&gt;
347   bool RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
348                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
349                                                                          size_t length) {
350     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_ARRAYCOPY&gt;::resolve_barrier();
351     _arraycopy_func = function;
352     return function(src_obj, src_offset_in_bytes, src_raw,
353                     dst_obj, dst_offset_in_bytes, dst_raw,
354                     length);
355   }
356 
357   template &lt;DecoratorSet decorators, typename T&gt;
358   void RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::clone_init(oop src, oop dst, size_t size) {
359     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_CLONE&gt;::resolve_barrier();
360     _clone_func = function;
361     function(src, dst, size);
362   }
363 
364   template &lt;DecoratorSet decorators, typename T&gt;
365   oop RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::resolve_init(oop obj) {
366     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_RESOLVE&gt;::resolve_barrier();
367     _resolve_func = function;
368     return function(obj);
369   }
370 
371   template &lt;DecoratorSet decorators, typename T&gt;
372   bool RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;::equals_init(oop o1, oop o2) {
373     func_t function = BarrierResolver&lt;decorators, func_t, BARRIER_EQUALS&gt;::resolve_barrier();
374     _equals_func = function;
375     return function(o1, o2);
376   }
377 }
378 
379 #endif // SHARE_OOPS_ACCESS_INLINE_HPP
    </pre>
  </body>
</html>
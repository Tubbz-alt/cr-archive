diff a/src/hotspot/share/oops/symbol.hpp b/src/hotspot/share/oops/symbol.hpp
--- a/src/hotspot/share/oops/symbol.hpp
+++ b/src/hotspot/share/oops/symbol.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,11 +26,10 @@
 #define SHARE_OOPS_SYMBOL_HPP
 
 #include "memory/allocation.hpp"
 #include "utilities/exceptions.hpp"
 #include "utilities/macros.hpp"
-#include "utilities/utf8.hpp"
 
 // A Symbol is a canonicalized string.
 // All Symbols reside in global SymbolTable and are reference counted.
 
 // Reference counting
@@ -131,12 +130,12 @@
     assert(index >=0 && index < length(), "symbol index overflow");
     _body[index] = value;
   }
 
   Symbol(const u1* name, int length, int refcount);
-  void* operator new(size_t size, int len, TRAPS) throw();
-  void* operator new(size_t size, int len, Arena* arena, TRAPS) throw();
+  void* operator new(size_t size, int len) throw();
+  void* operator new(size_t size, int len, Arena* arena) throw();
 
   void  operator delete(void* p);
 
   static int extract_length(uint32_t value)   { return value >> 16; }
   static int extract_refcount(uint32_t value) { return value & 0xffff; }
@@ -168,10 +167,11 @@
   void increment_refcount();
   void decrement_refcount();
   bool is_permanent() {
     return (refcount() == PERM_REFCOUNT);
   }
+  void set_permanent();
   void make_permanent();
 
   // Function char_at() returns the Symbol's selected u1 byte as a char type.
   //
   // Note that all multi-byte chars have the sign bit set on all their bytes.
@@ -187,24 +187,38 @@
 
   // Compares the symbol with a string.
   bool equals(const char* str, int len) const {
     int l = utf8_length();
     if (l != len) return false;
-    while (l-- > 0) {
-      if (str[l] != char_at(l))
-        return false;
-    }
-    assert(l == -1, "we should be at the beginning");
-    return true;
+    return contains_utf8_at(0, str, len);
   }
   bool equals(const char* str) const { return equals(str, (int) strlen(str)); }
 
   // Tests if the symbol starts with the given prefix.
-  bool starts_with(const char* prefix, int len) const;
+  bool starts_with(const char* prefix, int len) const {
+    return contains_utf8_at(0, prefix, len);
+  }
   bool starts_with(const char* prefix) const {
     return starts_with(prefix, (int) strlen(prefix));
   }
+  bool starts_with(int prefix_char) const {
+    return contains_byte_at(0, prefix_char);
+  }
+  // Tests if the symbol ends with the given suffix.
+  bool ends_with(const char* suffix, int len) const {
+    return contains_utf8_at(utf8_length() - len, suffix, len);
+  }
+  bool ends_with(const char* suffix) const {
+    return ends_with(suffix, (int) strlen(suffix));
+  }
+  bool ends_with(int suffix_char) const {
+    return contains_byte_at(utf8_length()-1, suffix_char);
+  }
+  // Tests if the symbol contains the given utf8 substring
+  // or byte at the given byte position.
+  bool contains_utf8_at(int position, const char* substring, int len) const;
+  bool contains_byte_at(int position, char code_byte) const;
 
   // Tests if the symbol starts with the given prefix.
   int index_of_at(int i, const char* str, int len) const;
 
   // Three-way compare for sorting; returns -1/0/1 if receiver is </==/> than arg
@@ -228,22 +242,31 @@
   // String is allocated in resource area if buffer is not provided.
   // See Klass::external_name()
   const char* as_klass_external_name() const;
   const char* as_klass_external_name(char* buf, int size) const;
 
+  // Treating the symbol as a signature, print the return
+  // type to the outputStream. Prints external names as 'double' or
+  // 'java.lang.Object[][]'.
+  void print_as_signature_external_return_type(outputStream *os);
+  // Treating the symbol as a signature, print the parameter types
+  // seperated by ', ' to the outputStream.  Prints external names as
+  //  'double' or 'java.lang.Object[][]'.
+  void print_as_signature_external_parameters(outputStream *os);
+
   void metaspace_pointers_do(MetaspaceClosure* it);
   MetaspaceObj::Type type() const { return SymbolType; }
 
   // Printing
   void print_symbol_on(outputStream* st = NULL) const;
   void print_utf8_on(outputStream* st) const;
   void print_on(outputStream* st) const;         // First level print
   void print_value_on(outputStream* st) const;   // Second level print.
 
   // printing on default output stream
-  void print()         { print_on(tty);       }
-  void print_value()   { print_value_on(tty); }
+  void print() const;
+  void print_value() const;
 
   static bool is_valid(Symbol* s);
 
 #ifndef PRODUCT
   // Empty constructor to create a dummy symbol object on stack

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessDecorators.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="accessBackend.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="annotations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessDecorators.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
159 const DecoratorSet AS_NORMAL               = UCONST64(1) &lt;&lt; 14;
160 const DecoratorSet AS_DECORATOR_MASK       = AS_RAW | AS_NO_KEEPALIVE | AS_NORMAL;
161 
162 // === Reference Strength Decorators ===
163 // These decorators only apply to accesses on oop-like types (oop/narrowOop).
164 // * ON_STRONG_OOP_REF: Memory access is performed on a strongly reachable reference.
165 // * ON_WEAK_OOP_REF: The memory access is performed on a weakly reachable reference.
166 // * ON_PHANTOM_OOP_REF: The memory access is performed on a phantomly reachable reference.
167 //   This is the same ring of strength as jweak and weak oops in the VM.
168 // * ON_UNKNOWN_OOP_REF: The memory access is performed on a reference of unknown strength.
169 //   This could for example come from the unsafe API.
170 // * Default (no explicit reference strength specified): ON_STRONG_OOP_REF
171 const DecoratorSet ON_STRONG_OOP_REF  = UCONST64(1) &lt;&lt; 15;
172 const DecoratorSet ON_WEAK_OOP_REF    = UCONST64(1) &lt;&lt; 16;
173 const DecoratorSet ON_PHANTOM_OOP_REF = UCONST64(1) &lt;&lt; 17;
174 const DecoratorSet ON_UNKNOWN_OOP_REF = UCONST64(1) &lt;&lt; 18;
175 const DecoratorSet ON_DECORATOR_MASK  = ON_STRONG_OOP_REF | ON_WEAK_OOP_REF |
176                                         ON_PHANTOM_OOP_REF | ON_UNKNOWN_OOP_REF;
177 
178 // === Access Location ===
<span class="line-modified">179 // Accesses can take place in, e.g. the heap, old or young generation and different native roots.</span>
180 // The location is important to the GC as it may imply different actions. The following decorators are used:
181 // * IN_HEAP: The access is performed in the heap. Many barriers such as card marking will
182 //   be omitted if this decorator is not set.
<span class="line-modified">183 // * IN_NATIVE: The access is performed in an off-heap data structure pointing into the Java heap.</span>
184 const DecoratorSet IN_HEAP            = UCONST64(1) &lt;&lt; 19;
185 const DecoratorSet IN_NATIVE          = UCONST64(1) &lt;&lt; 20;
186 const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE;
187 
188 // == Boolean Flag Decorators ==
189 // * IS_ARRAY: The access is performed on a heap allocated array. This is sometimes a special case
190 //   for some GCs.
191 // * IS_DEST_UNINITIALIZED: This property can be important to e.g. SATB barriers by
192 //   marking that the previous value is uninitialized nonsense rather than a real value.
193 // * IS_NOT_NULL: This property can make certain barriers faster such as compressing oops.
194 const DecoratorSet IS_ARRAY              = UCONST64(1) &lt;&lt; 21;
195 const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) &lt;&lt; 22;
196 const DecoratorSet IS_NOT_NULL           = UCONST64(1) &lt;&lt; 23;
197 
198 // == Arraycopy Decorators ==
199 // * ARRAYCOPY_CHECKCAST: This property means that the class of the objects in source
200 //   are not guaranteed to be subclasses of the class of the destination array. This requires
201 //   a check-cast barrier during the copying operation. If this is not set, it is assumed
202 //   that the array is covariant: (the source array type is-a destination array type)
203 // * ARRAYCOPY_DISJOINT: This property means that it is known that the two array ranges
</pre>
</td>
<td>
<hr />
<pre>
159 const DecoratorSet AS_NORMAL               = UCONST64(1) &lt;&lt; 14;
160 const DecoratorSet AS_DECORATOR_MASK       = AS_RAW | AS_NO_KEEPALIVE | AS_NORMAL;
161 
162 // === Reference Strength Decorators ===
163 // These decorators only apply to accesses on oop-like types (oop/narrowOop).
164 // * ON_STRONG_OOP_REF: Memory access is performed on a strongly reachable reference.
165 // * ON_WEAK_OOP_REF: The memory access is performed on a weakly reachable reference.
166 // * ON_PHANTOM_OOP_REF: The memory access is performed on a phantomly reachable reference.
167 //   This is the same ring of strength as jweak and weak oops in the VM.
168 // * ON_UNKNOWN_OOP_REF: The memory access is performed on a reference of unknown strength.
169 //   This could for example come from the unsafe API.
170 // * Default (no explicit reference strength specified): ON_STRONG_OOP_REF
171 const DecoratorSet ON_STRONG_OOP_REF  = UCONST64(1) &lt;&lt; 15;
172 const DecoratorSet ON_WEAK_OOP_REF    = UCONST64(1) &lt;&lt; 16;
173 const DecoratorSet ON_PHANTOM_OOP_REF = UCONST64(1) &lt;&lt; 17;
174 const DecoratorSet ON_UNKNOWN_OOP_REF = UCONST64(1) &lt;&lt; 18;
175 const DecoratorSet ON_DECORATOR_MASK  = ON_STRONG_OOP_REF | ON_WEAK_OOP_REF |
176                                         ON_PHANTOM_OOP_REF | ON_UNKNOWN_OOP_REF;
177 
178 // === Access Location ===
<span class="line-modified">179 // Accesses can take place in, e.g. the heap, old or young generation, different native roots, or native memory off the heap.</span>
180 // The location is important to the GC as it may imply different actions. The following decorators are used:
181 // * IN_HEAP: The access is performed in the heap. Many barriers such as card marking will
182 //   be omitted if this decorator is not set.
<span class="line-modified">183 // * IN_NATIVE: The access is performed in an off-heap data structure.</span>
184 const DecoratorSet IN_HEAP            = UCONST64(1) &lt;&lt; 19;
185 const DecoratorSet IN_NATIVE          = UCONST64(1) &lt;&lt; 20;
186 const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE;
187 
188 // == Boolean Flag Decorators ==
189 // * IS_ARRAY: The access is performed on a heap allocated array. This is sometimes a special case
190 //   for some GCs.
191 // * IS_DEST_UNINITIALIZED: This property can be important to e.g. SATB barriers by
192 //   marking that the previous value is uninitialized nonsense rather than a real value.
193 // * IS_NOT_NULL: This property can make certain barriers faster such as compressing oops.
194 const DecoratorSet IS_ARRAY              = UCONST64(1) &lt;&lt; 21;
195 const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) &lt;&lt; 22;
196 const DecoratorSet IS_NOT_NULL           = UCONST64(1) &lt;&lt; 23;
197 
198 // == Arraycopy Decorators ==
199 // * ARRAYCOPY_CHECKCAST: This property means that the class of the objects in source
200 //   are not guaranteed to be subclasses of the class of the destination array. This requires
201 //   a check-cast barrier during the copying operation. If this is not set, it is assumed
202 //   that the array is covariant: (the source array type is-a destination array type)
203 // * ARRAYCOPY_DISJOINT: This property means that it is known that the two array ranges
</pre>
</td>
</tr>
</table>
<center><a href="accessBackend.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="annotations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
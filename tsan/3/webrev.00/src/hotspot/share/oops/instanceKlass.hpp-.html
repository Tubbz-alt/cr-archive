<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/packageEntry.hpp&quot;
  32 #include &quot;memory/referenceType.hpp&quot;
  33 #include &quot;oops/annotations.hpp&quot;
  34 #include &quot;oops/constMethod.hpp&quot;
  35 #include &quot;oops/fieldInfo.hpp&quot;
  36 #include &quot;oops/instanceOop.hpp&quot;
  37 #include &quot;oops/klassVtable.hpp&quot;
  38 #include &quot;runtime/handles.hpp&quot;
  39 #include &quot;runtime/os.hpp&quot;
  40 #include &quot;utilities/accessFlags.hpp&quot;
  41 #include &quot;utilities/align.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 #if INCLUDE_JFR
  44 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  45 #endif
  46 
  47 
  48 // An InstanceKlass is the VM level representation of a Java class.
  49 // It contains all information needed for at class at execution runtime.
  50 
  51 //  InstanceKlass embedded field layout (after declared fields):
  52 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  53 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  54 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  55 //      indicating where oops are located in instances of this klass.
  56 //    [EMBEDDED implementor of the interface] only exist for interface
  57 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  58 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;
  66 class KlassDepChange;
  67 class DependencyContext;
  68 class fieldDescriptor;
  69 class jniIdMapBase;
  70 class JNIid;
  71 class JvmtiCachedClassFieldMap;
  72 class nmethodBucket;
  73 class SuperTypeClosure;
  74 class OopMapCache;
  75 class InterpreterOopMap;
  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
  93 #endif  // !PRODUCT
  94 
  95 // Describes where oops are located in instances of this klass.
  96 class OopMapBlock {
  97  public:
  98   // Byte offset of the first oop mapped by this block.
  99   int offset() const          { return _offset; }
 100   void set_offset(int offset) { _offset = offset; }
 101 
 102   // Number of oops in this block.
 103   uint count() const         { return _count; }
 104   void set_count(uint count) { _count = count; }
 105 
 106   // sizeof(OopMapBlock) in words.
 107   static const int size_in_words() {
 108     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 109       LogBytesPerWord;
 110   }
 111 
 112  private:
 113   int  _offset;
 114   uint _count;
 115 };
 116 
 117 struct JvmtiCachedClassFileData;
 118 
 119 class InstanceKlass: public Klass {
 120   friend class VMStructs;
 121   friend class JVMCIVMStructs;
 122   friend class ClassFileParser;
 123   friend class CompileReplay;
 124 
 125  public:
 126   static const KlassID ID = InstanceKlassID;
 127 
 128  protected:
 129   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 130 
 131  public:
 132   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 133 
 134   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 135   // of the class loading &amp; initialization procedure, and the use of the states.
 136   enum ClassState {
 137     allocated,                          // allocated (but not yet linked)
 138     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 139     linked,                             // successfully linked/verified (but not initialized yet)
 140     being_initialized,                  // currently running class initializer
 141     fully_initialized,                  // initialized (successfull final state)
 142     initialization_error                // error happened during initialization
 143   };
 144 
 145  private:
 146   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 147 
 148  protected:
 149   // If you add a new field that points to any metaspace object, you
 150   // must add this field to InstanceKlass::metaspace_pointers_do().
 151 
 152   // Annotations for this class
 153   Annotations*    _annotations;
 154   // Package this class is defined in
 155   PackageEntry*   _package_entry;
 156   // Array classes holding elements of this class.
 157   Klass* volatile _array_klasses;
 158   // Constant pool for this class.
 159   ConstantPool* _constants;
 160   // The InnerClasses attribute and EnclosingMethod attribute. The
 161   // _inner_classes is an array of shorts. If the class has InnerClasses
 162   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 163   // [inner_class_info_index, outer_class_info_index,
 164   // inner_name_index, inner_class_access_flags] for the InnerClasses
 165   // attribute. If the EnclosingMethod attribute exists, it occupies the
 166   // last two shorts [class_index, method_index] of the array. If only
 167   // the InnerClasses attribute exists, the _inner_classes array length is
 168   // number_of_inner_classes * 4. If the class has both InnerClasses
 169   // and EnclosingMethod attributes the _inner_classes array length is
 170   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 171   Array&lt;jushort&gt;* _inner_classes;
 172 
 173   // The NestMembers attribute. An array of shorts, where each is a
 174   // class info index for the class that is a nest member. This data
 175   // has not been validated.
 176   Array&lt;jushort&gt;* _nest_members;
 177 
 178   // The NestHost attribute. The class info index for the class
 179   // that is the nest-host of this class. This data has not been validated.
 180   jushort _nest_host_index;
 181 
 182   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 183   // By always being set it makes nest-member access checks simpler.
 184   InstanceKlass* _nest_host;
 185 
 186   // the source debug extension for this klass, NULL if not specified.
 187   // Specified as UTF-8 string without terminating zero byte in the classfile,
 188   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 189   const char*     _source_debug_extension;
 190   // Array name derived from this class which needs unreferencing
 191   // if this class is unloaded.
 192   Symbol*         _array_name;
 193 
 194   // Number of heapOopSize words used by non-static fields in this klass
 195   // (including inherited fields but after header_size()).
 196   int             _nonstatic_field_size;
 197   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 198   // Constant pool index to the utf8 entry of the Generic signature,
 199   // or 0 if none.
 200   u2              _generic_signature_index;
 201   // Constant pool index to the utf8 entry for the name of source file
 202   // containing this klass, 0 if not specified.
 203   u2              _source_file_name_index;
 204   u2              _static_oop_field_count;// number of static oop fields in this klass
 205   u2              _java_fields_count;    // The number of declared Java fields
 206   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 207 
 208   int             _itable_len;           // length of Java itable (in words)
 209   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 210   // _misc_flags.
 211   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 212   bool            _is_being_redefined;   // used for locking redefinition
 213 
 214   // The low two bits of _misc_flags contains the kind field.
 215   // This can be used to quickly discriminate among the four kinds of
 216   // InstanceKlass.
 217 
 218   static const unsigned _misc_kind_field_size = 2;
 219   static const unsigned _misc_kind_field_pos  = 0;
 220   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 221 
 222   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 223   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 224   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 225   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 226 
 227   // Start after _misc_kind field.
 228   enum {
 229     _misc_rewritten                           = 1 &lt;&lt; 2,  // methods rewritten.
 230     _misc_has_nonstatic_fields                = 1 &lt;&lt; 3,  // for sizing with UseCompressedOops
 231     _misc_should_verify_class                 = 1 &lt;&lt; 4,  // allow caching of preverification
 232     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 5,  // has embedded _unsafe_anonymous_host field
 233     _misc_is_contended                        = 1 &lt;&lt; 6,  // marked with contended annotation
 234     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 7,  // class/superclass/implemented interfaces has non-static, concrete methods
 235     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 8,  // directly declares non-static, concrete methods
 236     _misc_has_been_redefined                  = 1 &lt;&lt; 9,  // class has been redefined
 237     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 10, // when this class was loaded, the fingerprint computed from its
 238                                                          // code source was found to be matching the value recorded by AOT.
 239     _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class
 240     _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader
 241     _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader
 242     _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader
 243     _misc_has_resolved_methods                = 1 &lt;&lt; 15  // resolved methods table entries added for this class
 244   };
 245   u2 loader_type_bits() {
 246     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 247   }
 248   u2              _misc_flags;
 249   u2              _minor_version;        // minor version number of class file
 250   u2              _major_version;        // major version number of class file
 251   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)
 252   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 253   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 254   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 255   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 256   uint64_t        volatile _dep_context_last_cleaned;
 257   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 258 #if INCLUDE_JVMTI
 259   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 260   // Linked instanceKlasses of previous versions
 261   InstanceKlass* _previous_versions;
 262   // JVMTI fields can be moved to their own structure - see 6315920
 263   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 264   JvmtiCachedClassFileData* _cached_class_file;
 265 #endif
 266 
 267   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 268 
 269   // Class states are defined as ClassState (see above).
 270   // Place the _init_state here to utilize the unused 2-byte after
 271   // _idnum_allocated_count.
 272   u1              _init_state;                    // state of class
 273   u1              _reference_type;                // reference type
 274 
 275   u2              _this_class_index;              // constant pool entry
 276 #if INCLUDE_JVMTI
 277   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 278 #endif
 279 
 280   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 281 
 282   // Method array.
 283   Array&lt;Method*&gt;* _methods;
 284   // Default Method Array, concrete methods inherited from interfaces
 285   Array&lt;Method*&gt;* _default_methods;
 286   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 287   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 288   // Interfaces (InstanceKlass*s) this class implements transitively.
 289   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 290   // Int array containing the original order of method in the class file (for JVMTI).
 291   Array&lt;int&gt;*     _method_ordering;
 292   // Int array containing the vtable_indices for default_methods
 293   // offset matches _default_methods offset
 294   Array&lt;int&gt;*     _default_vtable_indices;
 295 
 296   // Instance and static variable information, starts with 6-tuples of shorts
 297   // [access, name index, sig index, initval index, low_offset, high_offset]
 298   // for all fields, followed by the generic signature data at the end of
 299   // the array. Only fields with generic signature attributes have the generic
 300   // signature data set in the array. The fields array looks like following:
 301   //
 302   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 303   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 304   //      ...
 305   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 306   //     [generic signature index]
 307   //     [generic signature index]
 308   //     ...
 309   Array&lt;u2&gt;*      _fields;
 310 
 311   // embedded Java vtable follows here
 312   // embedded Java itables follows here
 313   // embedded static fields follows here
 314   // embedded nonstatic oop-map blocks follows here
 315   // embedded implementor of this interface follows here
 316   //   The embedded implementor only exists if the current klass is an
 317   //   iterface. The possible values of the implementor fall into following
 318   //   three cases:
 319   //     NULL: no implementor.
 320   //     A Klass* that&#39;s not itself: one implementor.
 321   //     Itself: more than one implementors.
 322   // embedded unsafe_anonymous_host klass follows here
 323   //   The embedded host klass only exists in an unsafe anonymous class for
 324   //   dynamic language support (JSR 292 enabled). The host class grants
 325   //   its access privileges to this class also. The host class is either
 326   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 327   //   or an anonymous class loaded through normal classloading does not
 328   //   have this embedded field.
 329   //
 330 
 331   friend class SystemDictionary;
 332 
 333  public:
 334   u2 loader_type() {
 335     return _misc_flags &amp; loader_type_bits();
 336   }
 337 
 338   bool is_shared_boot_class() const {
 339     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 340   }
 341   bool is_shared_platform_class() const {
 342     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 343   }
 344   bool is_shared_app_class() const {
 345     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 346   }
 347 
 348   void clear_class_loader_type() {
 349     _misc_flags &amp;= ~loader_type_bits();
 350   }
 351 
 352   void set_class_loader_type(s2 loader_type) {
 353     switch (loader_type) {
 354     case ClassLoader::BOOT_LOADER:
 355       _misc_flags |= _misc_is_shared_boot_class;
 356        break;
 357     case ClassLoader::PLATFORM_LOADER:
 358       _misc_flags |= _misc_is_shared_platform_class;
 359       break;
 360     case ClassLoader::APP_LOADER:
 361       _misc_flags |= _misc_is_shared_app_class;
 362       break;
 363     default:
 364       ShouldNotReachHere();
 365       break;
 366     }
 367   }
 368 
 369   bool has_nonstatic_fields() const        {
 370     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 371   }
 372   void set_has_nonstatic_fields(bool b)    {
 373     if (b) {
 374       _misc_flags |= _misc_has_nonstatic_fields;
 375     } else {
 376       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 377     }
 378   }
 379 
 380   // field sizes
 381   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 382   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 383 
 384   int static_field_size() const            { return _static_field_size; }
 385   void set_static_field_size(int size)     { _static_field_size = size; }
 386 
 387   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 388   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 389 
 390   // Java itable
 391   int  itable_length() const               { return _itable_len; }
 392   void set_itable_length(int len)          { _itable_len = len; }
 393 
 394   // array klasses
 395   Klass* array_klasses() const             { return _array_klasses; }
 396   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 397   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 398   inline void release_set_array_klasses(Klass* k); // store with release semantics
 399 
 400   // methods
 401   Array&lt;Method*&gt;* methods() const          { return _methods; }
 402   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 403   Method* method_with_idnum(int idnum);
 404   Method* method_with_orig_idnum(int idnum);
 405   Method* method_with_orig_idnum(int idnum, int version);
 406 
 407   // method ordering
 408   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 409   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 410   void copy_method_ordering(const intArray* m, TRAPS);
 411 
 412   // default_methods
 413   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 414   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 415 
 416   // default method vtable_indices
 417   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 418   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 419   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 420 
 421   // interfaces
 422   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 423   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 424     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 425     _local_interfaces = a; }
 426 
 427   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 428   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 429     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 430     _transitive_interfaces = a;
 431   }
 432 
 433  private:
 434   friend class fieldDescriptor;
 435   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 436 
 437  public:
 438   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 439   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 440   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 441   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 442 
 443   // Number of Java declared fields
 444   int java_fields_count() const           { return (int)_java_fields_count; }
 445 
 446   Array&lt;u2&gt;* fields() const            { return _fields; }
 447   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 448     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 449     _fields = f;
 450     _java_fields_count = java_fields_count;
 451   }
 452 
 453   // inner classes
 454   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 455   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 456 
 457   // nest members
 458   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 459   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 460 
 461   // nest-host index
 462   jushort nest_host_index() const { return _nest_host_index; }
 463   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 464 
 465 private:
 466   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 467   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 468 public:
 469   // Returns nest-host class, resolving and validating it if needed
 470   // Returns NULL if an exception occurs during loading, or validation fails
 471   InstanceKlass* nest_host(Symbol* validationException, TRAPS);
 472   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 473   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 474 
 475   enum InnerClassAttributeOffset {
 476     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 477     inner_class_inner_class_info_offset = 0,
 478     inner_class_outer_class_info_offset = 1,
 479     inner_class_inner_name_offset = 2,
 480     inner_class_access_flags_offset = 3,
 481     inner_class_next_offset = 4
 482   };
 483 
 484   enum EnclosingMethodAttributeOffset {
 485     enclosing_method_class_index_offset = 0,
 486     enclosing_method_method_index_offset = 1,
 487     enclosing_method_attribute_size = 2
 488   };
 489 
 490   // method override check
 491   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 492 
 493   // package
 494   PackageEntry* package() const     { return _package_entry; }
 495   ModuleEntry* module() const;
 496   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 497   void set_package(PackageEntry* p) { _package_entry = p; }
 498   void set_package(ClassLoaderData* loader_data, TRAPS);
 499   bool is_same_class_package(const Klass* class2) const;
 500   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 501 
 502   // find an enclosing class
 503   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 504 
 505   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 506   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 507 
 508  private:
 509   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 510   static void check_prohibited_package(Symbol* class_name,
 511                                        ClassLoaderData* loader_data,
 512                                        TRAPS);
 513  public:
 514   // initialization state
 515   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 516   bool is_linked() const                   { return _init_state &gt;= linked; }
 517   bool is_initialized() const              { return _init_state == fully_initialized; }
 518   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 519   bool is_being_initialized() const        { return _init_state == being_initialized; }
 520   bool is_in_error_state() const           { return _init_state == initialization_error; }
 521   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 522   ClassState  init_state()                 { return (ClassState)_init_state; }
 523   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 524 
 525   // defineClass specified verification
 526   bool should_verify_class() const         {
 527     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 528   }
 529   void set_should_verify_class(bool value) {
 530     if (value) {
 531       _misc_flags |= _misc_should_verify_class;
 532     } else {
 533       _misc_flags &amp;= ~_misc_should_verify_class;
 534     }
 535   }
 536 
 537   // marking
 538   bool is_marked_dependent() const         { return _is_marked_dependent; }
 539   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 540 
 541   // initialization (virtuals from Klass)
 542   bool should_be_initialized() const;  // means that initialize should be called
 543   void initialize(TRAPS);
 544   void link_class(TRAPS);
 545   bool link_class_or_fail(TRAPS); // returns false on failure
 546   void rewrite_class(TRAPS);
 547   void link_methods(TRAPS);
 548   Method* class_initializer() const;
 549 
 550   // set the class to initialized if no static initializer is present
 551   void eager_initialize(Thread *thread);
 552 
 553   // reference type
 554   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 555   void set_reference_type(ReferenceType t) {
 556     assert(t == (u1)t, &quot;overflow&quot;);
 557     _reference_type = (u1)t;
 558   }
 559 
 560   // this class cp index
 561   u2 this_class_index() const             { return _this_class_index; }
 562   void set_this_class_index(u2 index)     { _this_class_index = index; }
 563 
 564   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 565 
 566   // find local field, returns true if found
 567   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 568   // find field in direct superinterfaces, returns the interface in which the field is defined
 569   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 570   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 571   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 572   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 573   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 574 
 575   // find a non-static or static field given its offset within the class.
 576   bool contains_field_offset(int offset) {
 577     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());
 578   }
 579 
 580   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 581   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 582 
 583   // find a local method (returns NULL if not found)
 584   Method* find_method(const Symbol* name, const Symbol* signature) const;
 585   static Method* find_method(const Array&lt;Method*&gt;* methods,
 586                              const Symbol* name,
 587                              const Symbol* signature);
 588 
 589   // find a local method, but skip static methods
 590   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 591                                PrivateLookupMode private_mode = find_private) const;
 592   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 593                                       const Symbol* name,
 594                                       const Symbol* signature,
 595                                       PrivateLookupMode private_mode = find_private);
 596 
 597   // find a local method (returns NULL if not found)
 598   Method* find_local_method(const Symbol* name,
 599                             const Symbol* signature,
 600                             OverpassLookupMode overpass_mode,
 601                             StaticLookupMode static_mode,
 602                             PrivateLookupMode private_mode) const;
 603 
 604   // find a local method from given methods array (returns NULL if not found)
 605   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 606                                    const Symbol* name,
 607                                    const Symbol* signature,
 608                                    OverpassLookupMode overpass_mode,
 609                                    StaticLookupMode static_mode,
 610                                    PrivateLookupMode private_mode);
 611 
 612   // find a local method index in methods or default_methods (returns -1 if not found)
 613   static int find_method_index(const Array&lt;Method*&gt;* methods,
 614                                const Symbol* name,
 615                                const Symbol* signature,
 616                                OverpassLookupMode overpass_mode,
 617                                StaticLookupMode static_mode,
 618                                PrivateLookupMode private_mode);
 619 
 620   // lookup operation (returns NULL if not found)
 621   Method* uncached_lookup_method(const Symbol* name,
 622                                  const Symbol* signature,
 623                                  OverpassLookupMode overpass_mode,
 624                                  PrivateLookupMode private_mode = find_private) const;
 625 
 626   // lookup a method in all the interfaces that this class implements
 627   // (returns NULL if not found)
 628   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 629 
 630   // lookup a method in local defaults then in all interfaces
 631   // (returns NULL if not found)
 632   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 633 
 634   // Find method indices by name.  If a method with the specified name is
 635   // found the index to the first method is returned, and &#39;end&#39; is filled in
 636   // with the index of first non-name-matching method.  If no method is found
 637   // -1 is returned.
 638   int find_method_by_name(const Symbol* name, int* end) const;
 639   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 640                                  const Symbol* name, int* end);
 641 
 642   // constant pool
 643   ConstantPool* constants() const        { return _constants; }
 644   void set_constants(ConstantPool* c)    { _constants = c; }
 645 
 646   // protection domain
 647   oop protection_domain() const;
 648 
 649   // signers
 650   objArrayOop signers() const;
 651 
 652   // host class
 653   InstanceKlass* unsafe_anonymous_host() const {
 654     InstanceKlass** hk = adr_unsafe_anonymous_host();
 655     if (hk == NULL) {
 656       assert(!is_unsafe_anonymous(), &quot;Unsafe anonymous classes have host klasses&quot;);
 657       return NULL;
 658     } else {
 659       assert(*hk != NULL, &quot;host klass should always be set if the address is not null&quot;);
 660       assert(is_unsafe_anonymous(), &quot;Only unsafe anonymous classes have host klasses&quot;);
 661       return *hk;
 662     }
 663   }
 664   void set_unsafe_anonymous_host(const InstanceKlass* host) {
 665     assert(is_unsafe_anonymous(), &quot;not unsafe anonymous&quot;);
 666     const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();
 667     assert(addr != NULL, &quot;no reversed space&quot;);
 668     if (addr != NULL) {
 669       *addr = host;
 670     }
 671   }
 672   bool is_unsafe_anonymous() const                {
 673     return (_misc_flags &amp; _misc_is_unsafe_anonymous) != 0;
 674   }
 675   void set_is_unsafe_anonymous(bool value)        {
 676     if (value) {
 677       _misc_flags |= _misc_is_unsafe_anonymous;
 678     } else {
 679       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 680     }
 681   }
 682 
 683   bool is_contended() const                {
 684     return (_misc_flags &amp; _misc_is_contended) != 0;
 685   }
 686   void set_is_contended(bool value)        {
 687     if (value) {
 688       _misc_flags |= _misc_is_contended;
 689     } else {
 690       _misc_flags &amp;= ~_misc_is_contended;
 691     }
 692   }
 693 
 694   // source file name
 695   Symbol* source_file_name() const               {
 696     return (_source_file_name_index == 0) ?
 697       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 698   }
 699   u2 source_file_name_index() const              {
 700     return _source_file_name_index;
 701   }
 702   void set_source_file_name_index(u2 sourcefile_index) {
 703     _source_file_name_index = sourcefile_index;
 704   }
 705 
 706   // minor and major version numbers of class file
 707   u2 minor_version() const                 { return _minor_version; }
 708   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 709   u2 major_version() const                 { return _major_version; }
 710   void set_major_version(u2 major_version) { _major_version = major_version; }
 711 
 712   // source debug extension
 713   const char* source_debug_extension() const { return _source_debug_extension; }
 714   void set_source_debug_extension(const char* array, int length);
 715 
 716   // symbol unloading support (refcount already added)
 717   Symbol* array_name()                     { return _array_name; }
 718   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }
 719 
 720   // nonstatic oop-map blocks
 721   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 722     return oop_map_count * OopMapBlock::size_in_words();
 723   }
 724   unsigned int nonstatic_oop_map_count() const {
 725     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 726   }
 727   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 728   void set_nonstatic_oop_map_size(int words) {
 729     _nonstatic_oop_map_size = words;
 730   }
 731 
 732 #if INCLUDE_JVMTI
 733   // Redefinition locking.  Class can only be redefined by one thread at a time.
 734   bool is_being_redefined() const          { return _is_being_redefined; }
 735   void set_is_being_redefined(bool value)  { _is_being_redefined = value; }
 736 
 737   // RedefineClasses() support for previous versions:
 738   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 739   void purge_previous_version_list();
 740 
 741   InstanceKlass* previous_versions() const { return _previous_versions; }
 742 #else
 743   InstanceKlass* previous_versions() const { return NULL; }
 744 #endif
 745 
 746   InstanceKlass* get_klass_version(int version) {
 747     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 748       if (ik-&gt;constants()-&gt;version() == version) {
 749         return ik;
 750       }
 751     }
 752     return NULL;
 753   }
 754 
 755   bool has_been_redefined() const {
 756     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 757   }
 758   void set_has_been_redefined() {
 759     _misc_flags |= _misc_has_been_redefined;
 760   }
 761 
 762   bool has_passed_fingerprint_check() const {
 763     return (_misc_flags &amp; _misc_has_passed_fingerprint_check) != 0;
 764   }
 765   void set_has_passed_fingerprint_check(bool b) {
 766     if (b) {
 767       _misc_flags |= _misc_has_passed_fingerprint_check;
 768     } else {
 769       _misc_flags &amp;= ~_misc_has_passed_fingerprint_check;
 770     }
 771   }
 772   bool supers_have_passed_fingerprint_checks();
 773 
 774   static bool should_store_fingerprint(bool is_unsafe_anonymous);
 775   bool should_store_fingerprint() const { return should_store_fingerprint(is_unsafe_anonymous()); }
 776   bool has_stored_fingerprint() const;
 777   uint64_t get_stored_fingerprint() const;
 778   void store_fingerprint(uint64_t fingerprint);
 779 
 780   bool is_scratch_class() const {
 781     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 782   }
 783 
 784   void set_is_scratch_class() {
 785     _misc_flags |= _misc_is_scratch_class;
 786   }
 787 
 788   bool has_resolved_methods() const {
 789     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 790   }
 791 
 792   void set_has_resolved_methods() {
 793     _misc_flags |= _misc_has_resolved_methods;
 794   }
 795 private:
 796 
 797   void set_kind(unsigned kind) {
 798     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 799     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 800     unsigned flags = _misc_flags &amp; ~fmask;
 801     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 802   }
 803 
 804   bool is_kind(unsigned desired) const {
 805     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 806     return kind == desired;
 807   }
 808 
 809 public:
 810 
 811   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 812   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 813   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 814   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 815   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
 816 
 817 #if INCLUDE_JVMTI
 818 
 819   void init_previous_versions() {
 820     _previous_versions = NULL;
 821   }
 822 
 823  private:
 824   static bool  _has_previous_versions;
 825  public:
 826   static void purge_previous_versions(InstanceKlass* ik) {
 827     if (ik-&gt;has_been_redefined()) {
 828       ik-&gt;purge_previous_version_list();
 829     }
 830   }
 831 
 832   static bool has_previous_versions_and_reset();
 833   static bool has_previous_versions() { return _has_previous_versions; }
 834 
 835   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 836   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 837     _cached_class_file = data;
 838   }
 839   JvmtiCachedClassFileData * get_cached_class_file();
 840   jint get_cached_class_file_len();
 841   unsigned char * get_cached_class_file_bytes();
 842 
 843   // JVMTI: Support for caching of field indices, types, and offsets
 844   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 845     _jvmti_cached_class_field_map = descriptor;
 846   }
 847   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 848     return _jvmti_cached_class_field_map;
 849   }
 850 #else // INCLUDE_JVMTI
 851 
 852   static void purge_previous_versions(InstanceKlass* ik) { return; };
 853   static bool has_previous_versions_and_reset() { return false; }
 854 
 855   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 856     assert(data == NULL, &quot;unexpected call with JVMTI disabled&quot;);
 857   }
 858   JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }
 859 
 860 #endif // INCLUDE_JVMTI
 861 
 862   bool has_nonstatic_concrete_methods() const {
 863     return (_misc_flags &amp; _misc_has_nonstatic_concrete_methods) != 0;
 864   }
 865   void set_has_nonstatic_concrete_methods(bool b) {
 866     if (b) {
 867       _misc_flags |= _misc_has_nonstatic_concrete_methods;
 868     } else {
 869       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
 870     }
 871   }
 872 
 873   bool declares_nonstatic_concrete_methods() const {
 874     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
 875   }
 876   void set_declares_nonstatic_concrete_methods(bool b) {
 877     if (b) {
 878       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
 879     } else {
 880       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
 881     }
 882   }
 883 
 884   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
 885   inline u2 next_method_idnum();
 886   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
 887 
 888   // generics support
 889   Symbol* generic_signature() const                   {
 890     return (_generic_signature_index == 0) ?
 891       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
 892   }
 893   u2 generic_signature_index() const                  {
 894     return _generic_signature_index;
 895   }
 896   void set_generic_signature_index(u2 sig_index)      {
 897     _generic_signature_index = sig_index;
 898   }
 899 
 900   u2 enclosing_method_data(int offset) const;
 901   u2 enclosing_method_class_index() const {
 902     return enclosing_method_data(enclosing_method_class_index_offset);
 903   }
 904   u2 enclosing_method_method_index() {
 905     return enclosing_method_data(enclosing_method_method_index_offset);
 906   }
 907   void set_enclosing_method_indices(u2 class_index,
 908                                     u2 method_index);
 909 
 910   // jmethodID support
 911   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
 912   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
 913                      jmethodID new_id, jmethodID* new_jmeths,
 914                      jmethodID* to_dealloc_id_p,
 915                      jmethodID** to_dealloc_jmeths_p);
 916   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
 917                 size_t *length_p, jmethodID* id_p);
 918   void ensure_space_for_methodids(int start_offset = 0);
 919   jmethodID jmethod_id_or_null(Method* method);
 920 
 921   // annotations support
 922   Annotations* annotations() const          { return _annotations; }
 923   void set_annotations(Annotations* anno)   { _annotations = anno; }
 924 
 925   AnnotationArray* class_annotations() const {
 926     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
 927   }
 928   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
 929     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
 930   }
 931   AnnotationArray* class_type_annotations() const {
 932     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
 933   }
 934   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
 935     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
 936   }
 937   // allocation
 938   instanceOop allocate_instance(TRAPS);
 939 
 940   // additional member function to return a handle
 941   instanceHandle allocate_instance_handle(TRAPS);
 942 
 943   objArrayOop allocate_objArray(int n, int length, TRAPS);
 944   // Helper function
 945   static instanceOop register_finalizer(instanceOop i, TRAPS);
 946 
 947   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
 948   // if not, throw either an Error or an Exception.
 949   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
 950 
 951   // initialization
 952   void call_class_initializer(TRAPS);
 953   void set_initialization_state_and_notify(ClassState state, TRAPS);
 954 
 955   // OopMapCache support
 956   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
 957   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
 958   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
 959 
 960   // JNI identifier support (for static fields - for jni performance)
 961   JNIid* jni_ids()                               { return _jni_ids; }
 962   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
 963   JNIid* jni_id_for(int offset);
 964 
 965   // maintenance of deoptimization dependencies
 966   inline DependencyContext dependencies();
 967   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
 968   void add_dependent_nmethod(nmethod* nm);
 969   void remove_dependent_nmethod(nmethod* nm);
 970   void clean_dependency_context();
 971 
 972   // On-stack replacement support
 973   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
 974   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
 975   void add_osr_nmethod(nmethod* n);
 976   bool remove_osr_nmethod(nmethod* n);
 977   int mark_osr_nmethods(const Method* m);
 978   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
 979 
 980 #if INCLUDE_JVMTI
 981   // Breakpoint support (see methods on Method* for details)
 982   BreakpointInfo* breakpoints() const       { return _breakpoints; };
 983   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
 984 #endif
 985 
 986   // support for stub routines
 987   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
 988   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
 989   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
 990 
 991   // subclass/subinterface checks
 992   bool implements_interface(Klass* k) const;
 993   bool is_same_or_direct_interface(Klass* k) const;
 994 
 995 #ifdef ASSERT
 996   // check whether this class or one of its superclasses was redefined
 997   bool has_redefined_this_or_super() const;
 998 #endif
 999 
1000   // Access to the implementor of an interface.
1001   Klass* implementor() const;
1002   void set_implementor(Klass* k);
1003   int  nof_implementors() const;
1004   void add_implementor(Klass* k);  // k is a new class that implements this interface
1005   void init_implementor();           // initialize
1006 
1007   // link this class into the implementors list of every interface it implements
1008   void process_interfaces(Thread *thread);
1009 
1010   // virtual operations from Klass
1011   bool is_leaf_class() const               { return _subklass == NULL; }
1012   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1013                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1014   bool can_be_primary_super_slow() const;
1015   int oop_size(oop obj)  const             { return size_helper(); }
1016   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1017   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1018   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1019 
1020   // Iterators
1021   void do_local_static_fields(FieldClosure* cl);
1022   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1023   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1024 
1025   void methods_do(void f(Method* method));
1026   void array_klasses_do(void f(Klass* k));
1027   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
1028   bool super_types_do(SuperTypeClosure* blk);
1029 
1030   static InstanceKlass* cast(Klass* k) {
1031     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1032   }
1033 
1034   static const InstanceKlass* cast(const Klass* k) {
1035     assert(k != NULL, &quot;k should not be null&quot;);
1036     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1037     return static_cast&lt;const InstanceKlass*&gt;(k);
1038   }
1039 
1040   virtual InstanceKlass* java_super() const {
1041     return (super() == NULL) ? NULL : cast(super());
1042   }
1043 
1044   // Sizing (in words)
1045   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1046 
1047   static int size(int vtable_length, int itable_length,
1048                   int nonstatic_oop_map_size,
1049                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {
1050     return align_metadata_size(header_size() +
1051            vtable_length +
1052            itable_length +
1053            nonstatic_oop_map_size +
1054            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1055            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1056            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));
1057   }
1058   int size() const                    { return size(vtable_length(),
1059                                                itable_length(),
1060                                                nonstatic_oop_map_size(),
1061                                                is_interface(),
1062                                                is_unsafe_anonymous(),
1063                                                has_stored_fingerprint());
1064   }
1065 #if INCLUDE_SERVICES
1066   virtual void collect_statistics(KlassSizeStats *sz) const;
1067 #endif
1068 
1069   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1070   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1071 
1072   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1073 
1074   oop static_field_base_raw() { return java_mirror(); }
1075 
1076   OopMapBlock* start_of_nonstatic_oop_maps() const {
1077     return (OopMapBlock*)(start_of_itable() + itable_length());
1078   }
1079 
1080   Klass** end_of_nonstatic_oop_maps() const {
1081     return (Klass**)(start_of_nonstatic_oop_maps() +
1082                      nonstatic_oop_map_count());
1083   }
1084 
1085   Klass* volatile* adr_implementor() const {
1086     if (is_interface()) {
1087       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1088     } else {
1089       return NULL;
1090     }
1091   };
1092 
1093   InstanceKlass** adr_unsafe_anonymous_host() const {
1094     if (is_unsafe_anonymous()) {
1095       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
1096       if (adr_impl != NULL) {
1097         return adr_impl + 1;
1098       } else {
1099         return (InstanceKlass **)end_of_nonstatic_oop_maps();
1100       }
1101     } else {
1102       return NULL;
1103     }
1104   }
1105 
1106   address adr_fingerprint() const {
1107     if (has_stored_fingerprint()) {
1108       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1109       if (adr_host != NULL) {
1110         return (address)(adr_host + 1);
1111       }
1112 
1113       Klass* volatile* adr_impl = adr_implementor();
1114       if (adr_impl != NULL) {
1115         return (address)(adr_impl + 1);
1116       }
1117 
1118       return (address)end_of_nonstatic_oop_maps();
1119     } else {
1120       return NULL;
1121     }
1122   }
1123 
1124   // Use this to return the size of an instance in heap words:
1125   int size_helper() const {
1126     return layout_helper_to_size_helper(layout_helper());
1127   }
1128 
1129   // This bit is initialized in classFileParser.cpp.
1130   // It is false under any of the following conditions:
1131   //  - the class is abstract (including any interface)
1132   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1133   //  - the class size is larger than FastAllocateSizeLimit
1134   //  - the class is java/lang/Class, which cannot be allocated directly
1135   bool can_be_fastpath_allocated() const {
1136     return !layout_helper_needs_slow_path(layout_helper());
1137   }
1138 
1139   // Java itable
1140   klassItable itable() const;        // return klassItable wrapper
1141   Method* method_at_itable(Klass* holder, int index, TRAPS);
1142 
1143 #if INCLUDE_JVMTI
1144   void adjust_default_methods(bool* trace_name_printed);
1145 #endif // INCLUDE_JVMTI
1146 
1147   void clean_weak_instanceklass_links();
1148  private:
1149   void clean_implementors_list();
1150   void clean_method_data();
1151 
1152  public:
1153   // Explicit metaspace deallocation of fields
1154   // For RedefineClasses and class file parsing errors, we need to deallocate
1155   // instanceKlasses and the metadata they point to.
1156   void deallocate_contents(ClassLoaderData* loader_data);
1157   static void deallocate_methods(ClassLoaderData* loader_data,
1158                                  Array&lt;Method*&gt;* methods);
1159   void static deallocate_interfaces(ClassLoaderData* loader_data,
1160                                     const Klass* super_klass,
1161                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1162                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1163 
1164   // The constant pool is on stack if any of the methods are executing or
1165   // referenced by handles.
1166   bool on_stack() const { return _constants-&gt;on_stack(); }
1167 
1168   // callbacks for actions during class unloading
1169   static void unload_class(InstanceKlass* ik);
1170   static void release_C_heap_structures(InstanceKlass* ik);
1171 
1172   // Naming
1173   const char* signature_name() const;
1174   static Symbol* package_from_name(const Symbol* name, TRAPS);
1175 
1176   // Oop fields (and metadata) iterators
1177   //
1178   // The InstanceKlass iterators also visits the Object&#39;s klass.
1179 
1180   // Forward iteration
1181  public:
1182   // Iterate over all oop fields in the oop maps.
1183   template &lt;typename T, class OopClosureType&gt;
1184   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1185 
1186   // Iterate over all oop fields and metadata.
1187   template &lt;typename T, class OopClosureType&gt;
1188   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1189 
1190   // Iterate over all oop fields in one oop map.
1191   template &lt;typename T, class OopClosureType&gt;
1192   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1193 
1194 
1195   // Reverse iteration
1196   // Iterate over all oop fields and metadata.
1197   template &lt;typename T, class OopClosureType&gt;
1198   inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1199 
1200  private:
1201   // Iterate over all oop fields in the oop maps.
1202   template &lt;typename T, class OopClosureType&gt;
1203   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1204 
1205   // Iterate over all oop fields in one oop map.
1206   template &lt;typename T, class OopClosureType&gt;
1207   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1208 
1209 
1210   // Bounded range iteration
1211  public:
1212   // Iterate over all oop fields in the oop maps.
1213   template &lt;typename T, class OopClosureType&gt;
1214   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1215 
1216   // Iterate over all oop fields and metadata.
1217   template &lt;typename T, class OopClosureType&gt;
1218   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1219 
1220  private:
1221   // Iterate over all oop fields in one oop map.
1222   template &lt;typename T, class OopClosureType&gt;
1223   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1224 
1225 
1226  public:
1227   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1228 
1229 public:
1230   void set_in_error_state() {
1231     assert(DumpSharedSpaces, &quot;only call this when dumping archive&quot;);
1232     _init_state = initialization_error;
1233   }
1234   bool check_sharing_error_state();
1235 
1236 private:
1237   // initialization state
1238   void set_init_state(ClassState state);
1239   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1240   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1241 
1242   // The RedefineClasses() API can cause new method idnums to be needed
1243   // which will cause the caches to grow. Safety requires different
1244   // cache management logic if the caches can grow instead of just
1245   // going from NULL to non-NULL.
1246   bool idnum_can_increment() const      { return has_been_redefined(); }
1247   inline jmethodID* methods_jmethod_ids_acquire() const;
1248   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1249 
1250   // Lock during initialization
1251 public:
1252   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1253   // Must be one per class and it has to be a VM internal object so java code
1254   // cannot lock it (like the mirror).
1255   // It has to be an object not a Mutex because it&#39;s held through java calls.
1256   oop init_lock() const;
1257 private:
1258   void fence_and_clear_init_lock();
1259 
1260   bool link_class_impl                           (TRAPS);
1261   bool verify_code                               (TRAPS);
1262   void initialize_impl                           (TRAPS);
1263   void initialize_super_interfaces               (TRAPS);
1264   void eager_initialize_impl                     ();
1265   /* jni_id_for_impl for jfieldID only */
1266   JNIid* jni_id_for_impl                         (int offset);
1267 
1268   // Returns the array class for the n&#39;th dimension
1269   Klass* array_klass_impl(bool or_null, int n, TRAPS);
1270 
1271   // Returns the array class with this class as element type
1272   Klass* array_klass_impl(bool or_null, TRAPS);
1273 
1274   // find a local method (returns NULL if not found)
1275   Method* find_method_impl(const Symbol* name,
1276                            const Symbol* signature,
1277                            OverpassLookupMode overpass_mode,
1278                            StaticLookupMode static_mode,
1279                            PrivateLookupMode private_mode) const;
1280 
1281   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1282                                   const Symbol* name,
1283                                   const Symbol* signature,
1284                                   OverpassLookupMode overpass_mode,
1285                                   StaticLookupMode static_mode,
1286                                   PrivateLookupMode private_mode);
1287 
1288   // Free CHeap allocated fields.
1289   void release_C_heap_structures();
1290 
1291 #if INCLUDE_JVMTI
1292   // RedefineClasses support
1293   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1294   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1295 #endif
1296 public:
1297   // CDS support - remove and restore oops from metadata. Oops are not shared.
1298   virtual void remove_unshareable_info();
1299   virtual void remove_java_mirror();
1300   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
1301 
1302   // jvm support
1303   jint compute_modifier_flags(TRAPS) const;
1304 
1305 public:
1306   // JVMTI support
1307   jint jvmti_class_status() const;
1308 
1309   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1310 
1311  public:
1312   // Printing
1313 #ifndef PRODUCT
1314   void print_on(outputStream* st) const;
1315 #endif
1316   void print_value_on(outputStream* st) const;
1317 
1318   void oop_print_value_on(oop obj, outputStream* st);
1319 
1320 #ifndef PRODUCT
1321   void oop_print_on      (oop obj, outputStream* st);
1322 
1323   void print_dependent_nmethods(bool verbose = false);
1324   bool is_dependent_nmethod(nmethod* nm);
1325   bool verify_itable_index(int index);
1326 #endif
1327 
1328   const char* internal_name() const;
1329 
1330   // Verification
1331   void verify_on(outputStream* st);
1332 
1333   void oop_verify_on(oop obj, outputStream* st);
1334 
1335   // Logging
1336   void print_class_load_logging(ClassLoaderData* loader_data,
1337                                 const char* module_name,
1338                                 const ClassFileStream* cfs) const;
1339 };
1340 
1341 // for adding methods
1342 // UNSET_IDNUM return means no more ids available
1343 inline u2 InstanceKlass::next_method_idnum() {
1344   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1345     return ConstMethod::UNSET_IDNUM; // no more ids available
1346   } else {
1347     return _idnum_allocated_count++;
1348   }
1349 }
1350 
1351 
1352 /* JNIid class for jfieldIDs only */
1353 class JNIid: public CHeapObj&lt;mtClass&gt; {
1354   friend class VMStructs;
1355  private:
1356   Klass*             _holder;
1357   JNIid*             _next;
1358   int                _offset;
1359 #ifdef ASSERT
1360   bool               _is_static_field_id;
1361 #endif
1362 
1363  public:
1364   // Accessors
1365   Klass* holder() const           { return _holder; }
1366   int offset() const              { return _offset; }
1367   JNIid* next()                   { return _next; }
1368   // Constructor
1369   JNIid(Klass* holder, int offset, JNIid* next);
1370   // Identifier lookup
1371   JNIid* find(int offset);
1372 
1373   bool find_local_field(fieldDescriptor* fd) {
1374     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1375   }
1376 
1377   static void deallocate(JNIid* id);
1378   // Debugging
1379 #ifdef ASSERT
1380   bool is_static_field_id() const { return _is_static_field_id; }
1381   void set_is_static_field_id()   { _is_static_field_id = true; }
1382 #endif
1383   void verify(Klass* holder);
1384 };
1385 
1386 // An iterator that&#39;s used to access the inner classes indices in the
1387 // InstanceKlass::_inner_classes array.
1388 class InnerClassesIterator : public StackObj {
1389  private:
1390   Array&lt;jushort&gt;* _inner_classes;
1391   int _length;
1392   int _idx;
1393  public:
1394 
1395   InnerClassesIterator(const InstanceKlass* k) {
1396     _inner_classes = k-&gt;inner_classes();
1397     if (k-&gt;inner_classes() != NULL) {
1398       _length = _inner_classes-&gt;length();
1399       // The inner class array&#39;s length should be the multiple of
1400       // inner_class_next_offset if it only contains the InnerClasses
1401       // attribute data, or it should be
1402       // n*inner_class_next_offset+enclosing_method_attribute_size
1403       // if it also contains the EnclosingMethod data.
1404       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1405               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1406              &quot;just checking&quot;);
1407       // Remove the enclosing_method portion if exists.
1408       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1409         _length -= InstanceKlass::enclosing_method_attribute_size;
1410       }
1411     } else {
1412       _length = 0;
1413     }
1414     _idx = 0;
1415   }
1416 
1417   int length() const {
1418     return _length;
1419   }
1420 
1421   void next() {
1422     _idx += InstanceKlass::inner_class_next_offset;
1423   }
1424 
1425   bool done() const {
1426     return (_idx &gt;= _length);
1427   }
1428 
1429   u2 inner_class_info_index() const {
1430     return _inner_classes-&gt;at(
1431                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1432   }
1433 
1434   void set_inner_class_info_index(u2 index) {
1435     _inner_classes-&gt;at_put(
1436                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1437   }
1438 
1439   u2 outer_class_info_index() const {
1440     return _inner_classes-&gt;at(
1441                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1442   }
1443 
1444   void set_outer_class_info_index(u2 index) {
1445     _inner_classes-&gt;at_put(
1446                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1447   }
1448 
1449   u2 inner_name_index() const {
1450     return _inner_classes-&gt;at(
1451                _idx + InstanceKlass::inner_class_inner_name_offset);
1452   }
1453 
1454   void set_inner_name_index(u2 index) {
1455     _inner_classes-&gt;at_put(
1456                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1457   }
1458 
1459   u2 inner_access_flags() const {
1460     return _inner_classes-&gt;at(
1461                _idx + InstanceKlass::inner_class_access_flags_offset);
1462   }
1463 };
1464 
1465 #endif // SHARE_OOPS_INSTANCEKLASS_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/symbol.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopsHierarchy.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,13 ***</span>
<span class="line-new-header">--- 29,15 ---</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  
  uint32_t Symbol::pack_length_and_refcount(int length, int refcount) {
    STATIC_ASSERT(max_symbol_length == ((1 &lt;&lt; 16) - 1));
    STATIC_ASSERT(PERM_REFCOUNT == ((1 &lt;&lt; 16) - 1));
    assert(length &gt;= 0, &quot;negative length&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,47 ***</span>
  }
  
  Symbol::Symbol(const u1* name, int length, int refcount) {
    _length_and_refcount =  pack_length_and_refcount(length, refcount);
    _identity_hash = (short)os::random();
    for (int i = 0; i &lt; length; i++) {
      byte_at_put(i, name[i]);
    }
  }
  
<span class="line-modified">! void* Symbol::operator new(size_t sz, int len, TRAPS) throw() {</span>
    int alloc_size = size(len)*wordSize;
    address res = (address) AllocateHeap(alloc_size, mtSymbol);
    return res;
  }
  
<span class="line-modified">! void* Symbol::operator new(size_t sz, int len, Arena* arena, TRAPS) throw() {</span>
    int alloc_size = size(len)*wordSize;
    address res = (address)arena-&gt;Amalloc_4(alloc_size);
    return res;
  }
  
  void Symbol::operator delete(void *p) {
    assert(((Symbol*)p)-&gt;refcount() == 0, &quot;should not call this&quot;);
    FreeHeap(p);
  }
  
  // ------------------------------------------------------------------
<span class="line-modified">! // Symbol::starts_with</span>
  //
<span class="line-modified">! // Tests if the symbol starts with the specified prefix of the given</span>
<span class="line-modified">! // length.</span>
<span class="line-modified">! bool Symbol::starts_with(const char* prefix, int len) const {</span>
<span class="line-modified">!   if (len &gt; utf8_length()) return false;</span>
<span class="line-modified">!   while (len-- &gt; 0) {</span>
<span class="line-removed">-     if (prefix[len] != char_at(len))</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(len == -1, &quot;we should be at the beginning&quot;);</span>
<span class="line-removed">-   return true;</span>
  }
  
  
  // ------------------------------------------------------------------
  // Symbol::index_of
  //
  // Finds if the given string is a substring of this symbol&#39;s utf8 bytes.
<span class="line-new-header">--- 50,66 ---</span>
  }
  
  Symbol::Symbol(const u1* name, int length, int refcount) {
    _length_and_refcount =  pack_length_and_refcount(length, refcount);
    _identity_hash = (short)os::random();
<span class="line-added">+   _body[0] = 0;  // in case length == 0</span>
    for (int i = 0; i &lt; length; i++) {
      byte_at_put(i, name[i]);
    }
  }
  
<span class="line-modified">! void* Symbol::operator new(size_t sz, int len) throw() {</span>
    int alloc_size = size(len)*wordSize;
    address res = (address) AllocateHeap(alloc_size, mtSymbol);
    return res;
  }
  
<span class="line-modified">! void* Symbol::operator new(size_t sz, int len, Arena* arena) throw() {</span>
    int alloc_size = size(len)*wordSize;
    address res = (address)arena-&gt;Amalloc_4(alloc_size);
    return res;
  }
  
  void Symbol::operator delete(void *p) {
    assert(((Symbol*)p)-&gt;refcount() == 0, &quot;should not call this&quot;);
    FreeHeap(p);
  }
  
<span class="line-added">+ void Symbol::set_permanent() {</span>
<span class="line-added">+   // This is called at a safepoint during dumping of a dynamic CDS archive.</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);</span>
<span class="line-added">+   _length_and_refcount =  pack_length_and_refcount(length(), PERM_REFCOUNT);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // ------------------------------------------------------------------
<span class="line-modified">! // Symbol::contains_byte_at</span>
  //
<span class="line-modified">! // Tests if the symbol contains the given byte at the given position.</span>
<span class="line-modified">! bool Symbol::contains_byte_at(int position, char code_byte) const {</span>
<span class="line-modified">!   if (position &lt; 0)  return false;  // can happen with ends_with</span>
<span class="line-modified">!   if (position &gt;= utf8_length()) return false;</span>
<span class="line-modified">!   return code_byte == char_at(position);</span>
  }
  
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Symbol::contains_utf8_at</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Tests if the symbol contains the given utf8 substring</span>
<span class="line-added">+ // at the given byte position.</span>
<span class="line-added">+ bool Symbol::contains_utf8_at(int position, const char* substring, int len) const {</span>
<span class="line-added">+   assert(len &gt;= 0 &amp;&amp; substring != NULL, &quot;substring must be valid&quot;);</span>
<span class="line-added">+   if (len &lt;= 1)</span>
<span class="line-added">+     return len == 0 || contains_byte_at(position, substring[0]);</span>
<span class="line-added">+   if (position &lt; 0)  return false;  // can happen with ends_with</span>
<span class="line-added">+   if (position + len &gt; utf8_length()) return false;</span>
<span class="line-added">+   if (memcmp((char*)base() + position, substring, len) == 0)</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   else</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
  
  // ------------------------------------------------------------------
  // Symbol::index_of
  //
  // Finds if the given string is a substring of this symbol&#39;s utf8 bytes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,12 ***</span>
    for (; scan &lt;= limit; scan++) {
      scan = (address) memchr(scan, first_char, (limit + 1 - scan));
      if (scan == NULL)
        return -1;  // not found
      assert(scan &gt;= bytes+i &amp;&amp; scan &lt;= limit, &quot;scan oob&quot;);
<span class="line-modified">!     if (memcmp(scan, str, len) == 0)</span>
        return (int)(scan - bytes);
    }
    return -1;
  }
  
  
<span class="line-new-header">--- 126,15 ---</span>
    for (; scan &lt;= limit; scan++) {
      scan = (address) memchr(scan, first_char, (limit + 1 - scan));
      if (scan == NULL)
        return -1;  // not found
      assert(scan &gt;= bytes+i &amp;&amp; scan &lt;= limit, &quot;scan oob&quot;);
<span class="line-modified">!     if (len &lt;= 2</span>
<span class="line-added">+         ? (char) scan[len-1] == str[len-1]</span>
<span class="line-added">+         : memcmp(scan+1, str+1, len-1) == 0) {</span>
        return (int)(scan - bytes);
<span class="line-added">+     }</span>
    }
    return -1;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,12 ***</span>
    if (size &gt; 0) {
      char* str    = as_C_string(buf, size);
      int   length = (int)strlen(str);
      // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
      for (int index = 0; index &lt; length; index++) {
<span class="line-modified">!       if (str[index] == &#39;/&#39;) {</span>
<span class="line-modified">!         str[index] = &#39;.&#39;;</span>
        }
      }
      return str;
    } else {
      return buf;
<span class="line-new-header">--- 199,12 ---</span>
    if (size &gt; 0) {
      char* str    = as_C_string(buf, size);
      int   length = (int)strlen(str);
      // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
      for (int index = 0; index &lt; length; index++) {
<span class="line-modified">!       if (str[index] == JVM_SIGNATURE_SLASH) {</span>
<span class="line-modified">!         str[index] = JVM_SIGNATURE_DOT;</span>
        }
      }
      return str;
    } else {
      return buf;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,17 ***</span>
  const char* Symbol::as_klass_external_name() const {
    char* str    = as_C_string();
    int   length = (int)strlen(str);
    // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
    for (int index = 0; index &lt; length; index++) {
<span class="line-modified">!     if (str[index] == &#39;/&#39;) {</span>
<span class="line-modified">!       str[index] = &#39;.&#39;;</span>
      }
    }
    return str;
  }
  
  // Increment refcount while checking for zero.  If the Symbol&#39;s refcount becomes zero
  // a thread could be concurrently removing the Symbol.  This is used during SymbolTable
  // lookup to avoid reviving a dead Symbol.
  bool Symbol::try_increment_refcount() {
    uint32_t found = _length_and_refcount;
<span class="line-new-header">--- 214,72 ---</span>
  const char* Symbol::as_klass_external_name() const {
    char* str    = as_C_string();
    int   length = (int)strlen(str);
    // Turn all &#39;/&#39;s into &#39;.&#39;s (also for array klasses)
    for (int index = 0; index &lt; length; index++) {
<span class="line-modified">!     if (str[index] == JVM_SIGNATURE_SLASH) {</span>
<span class="line-modified">!       str[index] = JVM_SIGNATURE_DOT;</span>
      }
    }
    return str;
  }
  
<span class="line-added">+ static void print_class(outputStream *os, const SignatureStream&amp; ss) {</span>
<span class="line-added">+   int sb = ss.raw_symbol_begin(), se = ss.raw_symbol_end();</span>
<span class="line-added">+   for (int i = sb; i &lt; se; ++i) {</span>
<span class="line-added">+     int ch = ss.raw_char_at(i);</span>
<span class="line-added">+     if (ch == JVM_SIGNATURE_SLASH) {</span>
<span class="line-added">+       os-&gt;put(JVM_SIGNATURE_DOT);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       os-&gt;put(ch);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void print_array(outputStream *os, SignatureStream&amp; ss) {</span>
<span class="line-added">+   int dimensions = ss.skip_array_prefix();</span>
<span class="line-added">+   assert(dimensions &gt; 0, &quot;&quot;);</span>
<span class="line-added">+   if (ss.is_reference()) {</span>
<span class="line-added">+     print_class(os, ss);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     os-&gt;print(&quot;%s&quot;, type2name(ss.type()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   for (int i = 0; i &lt; dimensions; ++i) {</span>
<span class="line-added">+     os-&gt;print(&quot;[]&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Symbol::print_as_signature_external_return_type(outputStream *os) {</span>
<span class="line-added">+   for (SignatureStream ss(this); !ss.is_done(); ss.next()) {</span>
<span class="line-added">+     if (ss.at_return_type()) {</span>
<span class="line-added">+       if (ss.is_array()) {</span>
<span class="line-added">+         print_array(os, ss);</span>
<span class="line-added">+       } else if (ss.is_reference()) {</span>
<span class="line-added">+         print_class(os, ss);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         os-&gt;print(&quot;%s&quot;, type2name(ss.type()));</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Symbol::print_as_signature_external_parameters(outputStream *os) {</span>
<span class="line-added">+   bool first = true;</span>
<span class="line-added">+   for (SignatureStream ss(this); !ss.is_done(); ss.next()) {</span>
<span class="line-added">+     if (ss.at_return_type()) break;</span>
<span class="line-added">+     if (!first) { os-&gt;print(&quot;, &quot;); }</span>
<span class="line-added">+     if (ss.is_array()) {</span>
<span class="line-added">+       print_array(os, ss);</span>
<span class="line-added">+     } else if (ss.is_reference()) {</span>
<span class="line-added">+       print_class(os, ss);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       os-&gt;print(&quot;%s&quot;, type2name(ss.type()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     first = false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Increment refcount while checking for zero.  If the Symbol&#39;s refcount becomes zero
  // a thread could be concurrently removing the Symbol.  This is used during SymbolTable
  // lookup to avoid reviving a dead Symbol.
  bool Symbol::try_increment_refcount() {
    uint32_t found = _length_and_refcount;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,11 ***</span>
      if (refc == PERM_REFCOUNT) {
        return true;  // sticky max or created permanent
      } else if (refc == 0) {
        return false; // dead, can&#39;t revive.
      } else {
<span class="line-modified">!       found = Atomic::cmpxchg(old_value + 1, &amp;_length_and_refcount, old_value);</span>
        if (found == old_value) {
          return true; // successfully updated.
        }
        // refcount changed, try again.
      }
<span class="line-new-header">--- 289,11 ---</span>
      if (refc == PERM_REFCOUNT) {
        return true;  // sticky max or created permanent
      } else if (refc == 0) {
        return false; // dead, can&#39;t revive.
      } else {
<span class="line-modified">!       found = Atomic::cmpxchg(&amp;_length_and_refcount, old_value, old_value + 1);</span>
        if (found == old_value) {
          return true; // successfully updated.
        }
        // refcount changed, try again.
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
        print();
        fatal(&quot;refcount underflow&quot;);
  #endif
        return;
      } else {
<span class="line-modified">!       found = Atomic::cmpxchg(old_value - 1, &amp;_length_and_refcount, old_value);</span>
        if (found == old_value) {
          return;  // successfully updated.
        }
        // refcount changed, try again.
      }
<span class="line-new-header">--- 332,11 ---</span>
        print();
        fatal(&quot;refcount underflow&quot;);
  #endif
        return;
      } else {
<span class="line-modified">!       found = Atomic::cmpxchg(&amp;_length_and_refcount, old_value, old_value - 1);</span>
        if (found == old_value) {
          return;  // successfully updated.
        }
        // refcount changed, try again.
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,11 ***</span>
        fatal(&quot;refcount underflow&quot;);
  #endif
        return;
      } else {
        int len = extract_length(old_value);
<span class="line-modified">!       found = Atomic::cmpxchg(pack_length_and_refcount(len, PERM_REFCOUNT), &amp;_length_and_refcount, old_value);</span>
        if (found == old_value) {
          return;  // successfully updated.
        }
        // refcount changed, try again.
      }
<span class="line-new-header">--- 356,11 ---</span>
        fatal(&quot;refcount underflow&quot;);
  #endif
        return;
      } else {
        int len = extract_length(old_value);
<span class="line-modified">!       found = Atomic::cmpxchg(&amp;_length_and_refcount, old_value, pack_length_and_refcount(len, PERM_REFCOUNT));</span>
        if (found == old_value) {
          return;  // successfully updated.
        }
        // refcount changed, try again.
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,28 ***</span>
    print_symbol_on(st);
    st-&gt;print(&quot;&#39;&quot;);
    st-&gt;print(&quot; count %d&quot;, refcount());
  }
  
  // The print_value functions are present in all builds, to support the
  // disassembler and error reporting.
  void Symbol::print_value_on(outputStream* st) const {
    st-&gt;print(&quot;&#39;&quot;);
    for (int i = 0; i &lt; utf8_length(); i++) {
      st-&gt;print(&quot;%c&quot;, char_at(i));
    }
    st-&gt;print(&quot;&#39;&quot;);
  }
  
  bool Symbol::is_valid(Symbol* s) {
    if (!is_aligned(s, sizeof(MetaWord))) return false;
    if ((size_t)s &lt; os::min_page_size()) return false;
  
    if (!os::is_readable_range(s, s + 1)) return false;
  
    // Symbols are not allocated in Java heap.
<span class="line-modified">!   if (Universe::heap()-&gt;is_in_reserved(s)) return false;</span>
  
    int len = s-&gt;utf8_length();
    if (len &lt; 0) return false;
  
    jbyte* bytes = (jbyte*) s-&gt;bytes();
<span class="line-new-header">--- 381,32 ---</span>
    print_symbol_on(st);
    st-&gt;print(&quot;&#39;&quot;);
    st-&gt;print(&quot; count %d&quot;, refcount());
  }
  
<span class="line-added">+ void Symbol::print() const { print_on(tty); }</span>
<span class="line-added">+ </span>
  // The print_value functions are present in all builds, to support the
  // disassembler and error reporting.
  void Symbol::print_value_on(outputStream* st) const {
    st-&gt;print(&quot;&#39;&quot;);
    for (int i = 0; i &lt; utf8_length(); i++) {
      st-&gt;print(&quot;%c&quot;, char_at(i));
    }
    st-&gt;print(&quot;&#39;&quot;);
  }
  
<span class="line-added">+ void Symbol::print_value() const { print_value_on(tty); }</span>
<span class="line-added">+ </span>
  bool Symbol::is_valid(Symbol* s) {
    if (!is_aligned(s, sizeof(MetaWord))) return false;
    if ((size_t)s &lt; os::min_page_size()) return false;
  
    if (!os::is_readable_range(s, s + 1)) return false;
  
    // Symbols are not allocated in Java heap.
<span class="line-modified">!   if (Universe::heap()-&gt;is_in(s)) return false;</span>
  
    int len = s-&gt;utf8_length();
    if (len &lt; 0) return false;
  
    jbyte* bytes = (jbyte*) s-&gt;bytes();
</pre>
<center><a href="oopsHierarchy.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
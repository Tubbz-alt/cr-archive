<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;

  41 #include &quot;utilities/debug.hpp&quot;
  42 #include &quot;utilities/globalDefinitions.hpp&quot;
  43 
  44 
  45 // This metafunction returns either oop or narrowOop depending on whether
  46 // an access needs to use compressed oops or not.
  47 template &lt;DecoratorSet decorators&gt;
  48 struct HeapOopType: AllStatic {
  49   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  50                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  51   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  52 };
  53 
  54 namespace AccessInternal {
  55   enum BarrierType {
  56     BARRIER_STORE,
  57     BARRIER_STORE_AT,
  58     BARRIER_LOAD,
  59     BARRIER_LOAD_AT,
  60     BARRIER_ATOMIC_CMPXCHG,
  61     BARRIER_ATOMIC_CMPXCHG_AT,
  62     BARRIER_ATOMIC_XCHG,
  63     BARRIER_ATOMIC_XCHG_AT,
  64     BARRIER_ARRAYCOPY,
  65     BARRIER_CLONE,
<span class="line-modified">  66     BARRIER_RESOLVE,</span>
<span class="line-removed">  67     BARRIER_EQUALS</span>
  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
  87   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  88     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  89              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  90   }
  91 
  92   // This metafunction returns whether it is possible for a type T to require
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<span class="line-modified"> 105     typedef T (*atomic_cmpxchg_at_func_t)(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
<span class="line-modified"> 106     typedef T (*atomic_xchg_at_func_t)(T new_value, oop base, ptrdiff_t offset);</span>
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
<span class="line-modified"> 110     typedef T (*atomic_cmpxchg_func_t)(T new_value, void* addr, T compare_value);</span>
<span class="line-modified"> 111     typedef T (*atomic_xchg_func_t)(T new_value, void* addr);</span>
 112 
 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
 117     typedef oop (*resolve_func_t)(oop obj);
<span class="line-removed"> 118     typedef bool (*equals_func_t)(oop o1, oop o2);</span>
 119   };
 120 
 121   template &lt;DecoratorSet decorators&gt;
 122   struct AccessFunctionTypes&lt;decorators, void&gt; {
 123     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
 124                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 125                                      size_t length);
 126   };
 127 
 128   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 129 
 130 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 131   template &lt;DecoratorSet decorators, typename T&gt;                    \
 132   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 133     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 134   }
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
 145   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
<span class="line-removed"> 146   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_EQUALS, equals_func_t);</span>
 147 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 148 
 149   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 150   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 151 
 152   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 153   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 154 
 155   class AccessLocker {
 156   public:
 157     AccessLocker();
 158     ~AccessLocker();
 159   };
 160   bool wide_atomic_needs_locking();
 161 
 162   void* field_addr(oop base, ptrdiff_t offset);
 163 
 164   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 165   // faster build times, given how frequently included access is.
 166   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
</pre>
<hr />
<pre>
 278     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 279   store_internal(void* addr, T value);
 280 
 281   template &lt;DecoratorSet ds, typename T&gt;
 282   static inline typename EnableIf&lt;
 283     HasDecorator&lt;ds, MO_VOLATILE&gt;::value&gt;::type
 284   store_internal(void* addr, T value) {
 285     (void)const_cast&lt;T&amp;&gt;(*reinterpret_cast&lt;volatile T*&gt;(addr) = value);
 286   }
 287 
 288   template &lt;DecoratorSet ds, typename T&gt;
 289   static inline typename EnableIf&lt;
 290     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 291   store_internal(void* addr, T value) {
 292     *reinterpret_cast&lt;T*&gt;(addr) = value;
 293   }
 294 
 295   template &lt;DecoratorSet ds, typename T&gt;
 296   static typename EnableIf&lt;
 297     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified"> 298   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
 299 
 300   template &lt;DecoratorSet ds, typename T&gt;
 301   static typename EnableIf&lt;
 302     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified"> 303   atomic_cmpxchg_internal(T new_value, void* addr, T compare_value);</span>
 304 
 305   template &lt;DecoratorSet ds, typename T&gt;
 306   static typename EnableIf&lt;
 307     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified"> 308   atomic_xchg_internal(T new_value, void* addr);</span>
 309 
 310   // The following *_locked mechanisms serve the purpose of handling atomic operations
 311   // that are larger than a machine can handle, and then possibly opt for using
 312   // a slower path using a mutex to perform the operation.
 313 
 314   template &lt;DecoratorSet ds, typename T&gt;
 315   static inline typename EnableIf&lt;
 316     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 317   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 318     return atomic_cmpxchg_internal&lt;ds&gt;(new_value, addr, compare_value);</span>
 319   }
 320 
 321   template &lt;DecoratorSet ds, typename T&gt;
 322   static typename EnableIf&lt;
 323     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 324   atomic_cmpxchg_maybe_locked(T new_value, void* addr, T compare_value);</span>
 325 
 326   template &lt;DecoratorSet ds, typename T&gt;
 327   static inline typename EnableIf&lt;
 328     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 329   atomic_xchg_maybe_locked(T new_value, void* addr) {</span>
<span class="line-modified"> 330     return atomic_xchg_internal&lt;ds&gt;(new_value, addr);</span>
 331   }
 332 
 333   template &lt;DecoratorSet ds, typename T&gt;
 334   static typename EnableIf&lt;
 335     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 336   atomic_xchg_maybe_locked(T new_value, void* addr);</span>
 337 
 338 public:
 339   template &lt;typename T&gt;
 340   static inline void store(void* addr, T value) {
 341     store_internal&lt;decorators&gt;(addr, value);
 342   }
 343 
 344   template &lt;typename T&gt;
 345   static inline T load(void* addr) {
 346     return load_internal&lt;decorators, T&gt;(addr);
 347   }
 348 
 349   template &lt;typename T&gt;
<span class="line-modified"> 350   static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 351     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(new_value, addr, compare_value);</span>
 352   }
 353 
 354   template &lt;typename T&gt;
<span class="line-modified"> 355   static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified"> 356     return atomic_xchg_maybe_locked&lt;decorators&gt;(new_value, addr);</span>
 357   }
 358 
 359   template &lt;typename T&gt;
 360   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 361                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 362                         size_t length);
 363 
 364   template &lt;typename T&gt;
 365   static void oop_store(void* addr, T value);
 366   template &lt;typename T&gt;
 367   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 368 
 369   template &lt;typename T&gt;
 370   static T oop_load(void* addr);
 371   template &lt;typename T&gt;
 372   static T oop_load_at(oop base, ptrdiff_t offset);
 373 
 374   template &lt;typename T&gt;
<span class="line-modified"> 375   static T oop_atomic_cmpxchg(T new_value, void* addr, T compare_value);</span>
 376   template &lt;typename T&gt;
<span class="line-modified"> 377   static T oop_atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
 378 
 379   template &lt;typename T&gt;
<span class="line-modified"> 380   static T oop_atomic_xchg(T new_value, void* addr);</span>
 381   template &lt;typename T&gt;
<span class="line-modified"> 382   static T oop_atomic_xchg_at(T new_value, oop base, ptrdiff_t offset);</span>
 383 
 384   template &lt;typename T&gt;
 385   static void store_at(oop base, ptrdiff_t offset, T value) {
 386     store(field_addr(base, offset), value);
 387   }
 388 
 389   template &lt;typename T&gt;
 390   static T load_at(oop base, ptrdiff_t offset) {
 391     return load&lt;T&gt;(field_addr(base, offset));
 392   }
 393 
 394   template &lt;typename T&gt;
<span class="line-modified"> 395   static T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 396     return atomic_cmpxchg(new_value, field_addr(base, offset), compare_value);</span>
 397   }
 398 
 399   template &lt;typename T&gt;
<span class="line-modified"> 400   static T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 401     return atomic_xchg(new_value, field_addr(base, offset));</span>
 402   }
 403 
 404   template &lt;typename T&gt;
 405   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 406                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 407                             size_t length);
 408 
 409   static void clone(oop src, oop dst, size_t size);
 410 
 411   static oop resolve(oop obj) { return obj; }
<span class="line-removed"> 412 </span>
<span class="line-removed"> 413   static bool equals(oop o1, oop o2) { return (void*)o1 == (void*)o2; }</span>
 414 };
 415 
 416 // Below is the implementation of the first 4 steps of the template pipeline:
 417 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 418 //           and sets default decorators to sensible values.
 419 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 420 //           multiple types. The P type of the address and T type of the value must
 421 //           match.
 422 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 423 //           avoided, and in that case avoids it (calling raw accesses or
 424 //           primitive accesses in a build that does not require primitive GC barriers)
 425 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 426 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 427 //           to the access.
 428 
 429 namespace AccessInternal {
 430   template &lt;typename T&gt;
 431   struct OopOrNarrowOopInternal: AllStatic {
 432     typedef oop type;
 433   };
</pre>
<hr />
<pre>
 502     }
 503   };
 504 
 505   template &lt;DecoratorSet decorators, typename T&gt;
 506   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 507     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 508     static func_t _load_at_func;
 509 
 510     static T load_at_init(oop base, ptrdiff_t offset);
 511 
 512     static inline T load_at(oop base, ptrdiff_t offset) {
 513       return _load_at_func(base, offset);
 514     }
 515   };
 516 
 517   template &lt;DecoratorSet decorators, typename T&gt;
 518   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 519     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 520     static func_t _atomic_cmpxchg_func;
 521 
<span class="line-modified"> 522     static T atomic_cmpxchg_init(T new_value, void* addr, T compare_value);</span>
 523 
<span class="line-modified"> 524     static inline T atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
<span class="line-modified"> 525       return _atomic_cmpxchg_func(new_value, addr, compare_value);</span>
 526     }
 527   };
 528 
 529   template &lt;DecoratorSet decorators, typename T&gt;
 530   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 531     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 532     static func_t _atomic_cmpxchg_at_func;
 533 
<span class="line-modified"> 534     static T atomic_cmpxchg_at_init(T new_value, oop base, ptrdiff_t offset, T compare_value);</span>
 535 
<span class="line-modified"> 536     static inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 537       return _atomic_cmpxchg_at_func(new_value, base, offset, compare_value);</span>
 538     }
 539   };
 540 
 541   template &lt;DecoratorSet decorators, typename T&gt;
 542   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 543     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 544     static func_t _atomic_xchg_func;
 545 
<span class="line-modified"> 546     static T atomic_xchg_init(T new_value, void* addr);</span>
 547 
<span class="line-modified"> 548     static inline T atomic_xchg(T new_value, void* addr) {</span>
<span class="line-modified"> 549       return _atomic_xchg_func(new_value, addr);</span>
 550     }
 551   };
 552 
 553   template &lt;DecoratorSet decorators, typename T&gt;
 554   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 555     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 556     static func_t _atomic_xchg_at_func;
 557 
<span class="line-modified"> 558     static T atomic_xchg_at_init(T new_value, oop base, ptrdiff_t offset);</span>
 559 
<span class="line-modified"> 560     static inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 561       return _atomic_xchg_at_func(new_value, base, offset);</span>
 562     }
 563   };
 564 
 565   template &lt;DecoratorSet decorators, typename T&gt;
 566   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 567     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 568     static func_t _arraycopy_func;
 569 
 570     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 571                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 572                                size_t length);
 573 
 574     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 575                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 576                                  size_t length) {
 577       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 578                              dst_obj, dst_offset_in_bytes, dst_raw,
 579                              length);
 580     }
 581   };
</pre>
<hr />
<pre>
 587 
 588     static void clone_init(oop src, oop dst, size_t size);
 589 
 590     static inline void clone(oop src, oop dst, size_t size) {
 591       _clone_func(src, dst, size);
 592     }
 593   };
 594 
 595   template &lt;DecoratorSet decorators, typename T&gt;
 596   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 597     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 598     static func_t _resolve_func;
 599 
 600     static oop resolve_init(oop obj);
 601 
 602     static inline oop resolve(oop obj) {
 603       return _resolve_func(obj);
 604     }
 605   };
 606 
<span class="line-removed"> 607   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed"> 608   struct RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;: AllStatic {</span>
<span class="line-removed"> 609     typedef typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type func_t;</span>
<span class="line-removed"> 610     static func_t _equals_func;</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612     static bool equals_init(oop o1, oop o2);</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614     static inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed"> 615       return _equals_func(o1, o2);</span>
<span class="line-removed"> 616     }</span>
<span class="line-removed"> 617   };</span>
<span class="line-removed"> 618 </span>
 619   // Initialize the function pointers to point to the resolving function.
 620   template &lt;DecoratorSet decorators, typename T&gt;
 621   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 622   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 623 
 624   template &lt;DecoratorSet decorators, typename T&gt;
 625   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 626   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 627 
 628   template &lt;DecoratorSet decorators, typename T&gt;
 629   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 630   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 631 
 632   template &lt;DecoratorSet decorators, typename T&gt;
 633   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 634   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 635 
 636   template &lt;DecoratorSet decorators, typename T&gt;
 637   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 638   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
</pre>
<hr />
<pre>
 644   template &lt;DecoratorSet decorators, typename T&gt;
 645   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 646   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 647 
 648   template &lt;DecoratorSet decorators, typename T&gt;
 649   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 650   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 651 
 652   template &lt;DecoratorSet decorators, typename T&gt;
 653   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 654   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 655 
 656   template &lt;DecoratorSet decorators, typename T&gt;
 657   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 658   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 659 
 660   template &lt;DecoratorSet decorators, typename T&gt;
 661   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 662   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 663 
<span class="line-removed"> 664   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-removed"> 665   typename AccessFunction&lt;decorators, T, BARRIER_EQUALS&gt;::type</span>
<span class="line-removed"> 666   RuntimeDispatch&lt;decorators, T, BARRIER_EQUALS&gt;::_equals_func = &amp;equals_init;</span>
<span class="line-removed"> 667 </span>
 668   // Step 3: Pre-runtime dispatching.
 669   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 670   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 671   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 672   // not possible.
 673   struct PreRuntimeDispatch: AllStatic {
 674     template&lt;DecoratorSet decorators&gt;
 675     struct CanHardwireRaw: public IntegralConstant&lt;
 676       bool,
 677       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 678       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 679       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 680     {};
 681 
 682     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 683 
 684     template&lt;DecoratorSet decorators&gt;
 685     static bool is_hardwired_primitive() {
 686       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 687              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
</pre>
<hr />
<pre>
 785       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 786     load_at(oop base, ptrdiff_t offset) {
 787       return load&lt;decorators, T&gt;(field_addr(base, offset));
 788     }
 789 
 790     template &lt;DecoratorSet decorators, typename T&gt;
 791     inline static typename EnableIf&lt;
 792       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 793     load_at(oop base, ptrdiff_t offset) {
 794       if (is_hardwired_primitive&lt;decorators&gt;()) {
 795         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 796         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 797       } else {
 798         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 799       }
 800     }
 801 
 802     template &lt;DecoratorSet decorators, typename T&gt;
 803     inline static typename EnableIf&lt;
 804       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 805     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 806       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 807       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 808         return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
 809       } else {
<span class="line-modified"> 810         return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
 811       }
 812     }
 813 
 814     template &lt;DecoratorSet decorators, typename T&gt;
 815     inline static typename EnableIf&lt;
 816       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 817     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 818       if (UseCompressedOops) {
 819         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 820         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 821       } else {
 822         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 823         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 824       }
 825     }
 826 
 827     template &lt;DecoratorSet decorators, typename T&gt;
 828     inline static typename EnableIf&lt;
 829       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 830     atomic_cmpxchg(T new_value, void* addr, T compare_value) {</span>
 831       if (is_hardwired_primitive&lt;decorators&gt;()) {
 832         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 833         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
 834       } else {
<span class="line-modified"> 835         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(new_value, addr, compare_value);</span>
 836       }
 837     }
 838 
 839     template &lt;DecoratorSet decorators, typename T&gt;
 840     inline static typename EnableIf&lt;
 841       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 842     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified"> 843       return atomic_cmpxchg&lt;decorators&gt;(new_value, field_addr(base, offset), compare_value);</span>
 844     }
 845 
 846     template &lt;DecoratorSet decorators, typename T&gt;
 847     inline static typename EnableIf&lt;
 848       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 849     atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
 850       if (is_hardwired_primitive&lt;decorators&gt;()) {
 851         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 852         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(new_value, base, offset, compare_value);</span>
 853       } else {
<span class="line-modified"> 854         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
 855       }
 856     }
 857 
 858     template &lt;DecoratorSet decorators, typename T&gt;
 859     inline static typename EnableIf&lt;
 860       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 861     atomic_xchg(T new_value, void* addr) {</span>
 862       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 863       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 864         return Raw::oop_atomic_xchg(new_value, addr);</span>
 865       } else {
<span class="line-modified"> 866         return Raw::atomic_xchg(new_value, addr);</span>
 867       }
 868     }
 869 
 870     template &lt;DecoratorSet decorators, typename T&gt;
 871     inline static typename EnableIf&lt;
 872       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 873     atomic_xchg(T new_value, void* addr) {</span>
 874       if (UseCompressedOops) {
 875         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 876         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 877       } else {
 878         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 879         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 880       }
 881     }
 882 
 883     template &lt;DecoratorSet decorators, typename T&gt;
 884     inline static typename EnableIf&lt;
 885       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 886     atomic_xchg(T new_value, void* addr) {</span>
 887       if (is_hardwired_primitive&lt;decorators&gt;()) {
 888         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 889         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
 890       } else {
<span class="line-modified"> 891         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(new_value, addr);</span>
 892       }
 893     }
 894 
 895     template &lt;DecoratorSet decorators, typename T&gt;
 896     inline static typename EnableIf&lt;
 897       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 898     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified"> 899       return atomic_xchg&lt;decorators&gt;(new_value, field_addr(base, offset));</span>
 900     }
 901 
 902     template &lt;DecoratorSet decorators, typename T&gt;
 903     inline static typename EnableIf&lt;
 904       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 905     atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
 906       if (is_hardwired_primitive&lt;decorators&gt;()) {
 907         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 908         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, base, offset);</span>
 909       } else {
<span class="line-modified"> 910         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(new_value, base, offset);</span>
 911       }
 912     }
 913 
 914     template &lt;DecoratorSet decorators, typename T&gt;
 915     inline static typename EnableIf&lt;
 916       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 917     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 918               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 919               size_t length) {
 920       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 921       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 922         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,
 923                                   dst_obj, dst_offset_in_bytes, dst_raw,
 924                                   length);
 925       } else {
 926         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 927                               dst_obj, dst_offset_in_bytes, dst_raw,
 928                               length);
 929       }
 930     }
</pre>
<hr />
<pre>
 978     inline static typename EnableIf&lt;
 979       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 980     clone(oop src, oop dst, size_t size) {
 981       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 982     }
 983 
 984     template &lt;DecoratorSet decorators&gt;
 985     inline static typename EnableIf&lt;
 986       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 987     resolve(oop obj) {
 988       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 989       return Raw::resolve(obj);
 990     }
 991 
 992     template &lt;DecoratorSet decorators&gt;
 993     inline static typename EnableIf&lt;
 994       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 995     resolve(oop obj) {
 996       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 997     }
<span class="line-removed"> 998 </span>
<span class="line-removed"> 999     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1000     inline static typename EnableIf&lt;</span>
<span class="line-removed">1001       HasDecorator&lt;decorators, AS_RAW&gt;::value || HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">1002     equals(oop o1, oop o2) {</span>
<span class="line-removed">1003       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;</span>
<span class="line-removed">1004       return Raw::equals(o1, o2);</span>
<span class="line-removed">1005     }</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1008     inline static typename EnableIf&lt;</span>
<span class="line-removed">1009       !HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, bool&gt;::type</span>
<span class="line-removed">1010     equals(oop o1, oop o2) {</span>
<span class="line-removed">1011       return RuntimeDispatch&lt;decorators, oop, BARRIER_EQUALS&gt;::equals(o1, o2);</span>
<span class="line-removed">1012     }</span>
1013   };
1014 
1015   // Step 2: Reduce types.
1016   // Enforce that for non-oop types, T and P have to be strictly the same.
1017   // P is the type of the address and T is the type of the values.
1018   // As for oop types, it is allow to send T in {narrowOop, oop} and
1019   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
1020   // the subsequent table. (columns are P, rows are T)
1021   // |           | HeapWord  |   oop   | narrowOop |
1022   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
1023   // | narrowOop |     x     |    x    |  hw-none  |
1024   //
1025   // x means not allowed
1026   // rt-comp means it must be checked at runtime whether the oop is compressed.
1027   // hw-none means it is statically known the oop will not be compressed.
1028   // hw-comp means it is statically known the oop will be compressed.
1029 
1030   template &lt;DecoratorSet decorators, typename T&gt;
1031   inline void store_reduce_types(T* addr, T value) {
1032     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
</pre>
<hr />
<pre>
1036   inline void store_reduce_types(narrowOop* addr, oop value) {
1037     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1038                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1039     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1040   }
1041 
1042   template &lt;DecoratorSet decorators&gt;
1043   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
1044     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1045                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1046     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1047   }
1048 
1049   template &lt;DecoratorSet decorators&gt;
1050   inline void store_reduce_types(HeapWord* addr, oop value) {
1051     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1052     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1053   }
1054 
1055   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1056   inline T atomic_cmpxchg_reduce_types(T new_value, T* addr, T compare_value) {</span>
<span class="line-modified">1057     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(new_value, addr, compare_value);</span>
1058   }
1059 
1060   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1061   inline oop atomic_cmpxchg_reduce_types(oop new_value, narrowOop* addr, oop compare_value) {</span>
1062     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1063                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1064     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1065   }
1066 
1067   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1068   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop new_value, narrowOop* addr, narrowOop compare_value) {</span>
1069     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1070                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1071     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1072   }
1073 
1074   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1075   inline oop atomic_cmpxchg_reduce_types(oop new_value,</span>
<span class="line-modified">1076                                          HeapWord* addr,</span>
<span class="line-modified">1077                                          oop compare_value) {</span>
1078     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1079     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(new_value, addr, compare_value);</span>
1080   }
1081 
1082   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1083   inline T atomic_xchg_reduce_types(T new_value, T* addr) {</span>
1084     const DecoratorSet expanded_decorators = decorators;
<span class="line-modified">1085     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1086   }
1087 
1088   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1089   inline oop atomic_xchg_reduce_types(oop new_value, narrowOop* addr) {</span>
1090     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1091                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1092     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1093   }
1094 
1095   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1096   inline narrowOop atomic_xchg_reduce_types(narrowOop new_value, narrowOop* addr) {</span>
1097     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1098                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1099     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1100   }
1101 
1102   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1103   inline oop atomic_xchg_reduce_types(oop new_value, HeapWord* addr) {</span>
1104     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1105     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(new_value, addr);</span>
1106   }
1107 
1108   template &lt;DecoratorSet decorators, typename T&gt;
1109   inline T load_reduce_types(T* addr) {
1110     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1111   }
1112 
1113   template &lt;DecoratorSet decorators, typename T&gt;
1114   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1115     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1116                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1117     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1118   }
1119 
1120   template &lt;DecoratorSet decorators, typename T&gt;
1121   inline oop load_reduce_types(HeapWord* addr) {
1122     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1123     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1124   }
1125 
</pre>
<hr />
<pre>
1209       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1210       (MO_VOLATILE | decorators) : decorators&gt;::value;
1211     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1212   }
1213 
1214   template &lt;DecoratorSet decorators, typename T&gt;
1215   inline T load_at(oop base, ptrdiff_t offset) {
1216     verify_types&lt;decorators, T&gt;();
1217     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1218                                  typename OopOrNarrowOop&lt;T&gt;::type,
1219                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1220     // Expand the decorators (figure out sensible defaults)
1221     // Potentially remember if we need compressed oop awareness
1222     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1223                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1224                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1225     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1226   }
1227 
1228   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">1229   inline T atomic_cmpxchg(T new_value, P* addr, T compare_value) {</span>
1230     verify_types&lt;decorators, T&gt;();
1231     typedef typename Decay&lt;P&gt;::type DecayedP;
1232     typedef typename Decay&lt;T&gt;::type DecayedT;
1233     DecayedT new_decayed_value = new_value;
1234     DecayedT compare_decayed_value = compare_value;
1235     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1236       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1237       (MO_SEQ_CST | decorators) : decorators&gt;::value;
<span class="line-modified">1238     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">1239                                                             const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1240                                                             compare_decayed_value);</span>
1241   }
1242 
1243   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1244   inline T atomic_cmpxchg_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
1245     verify_types&lt;decorators, T&gt;();
1246     typedef typename Decay&lt;T&gt;::type DecayedT;
1247     DecayedT new_decayed_value = new_value;
1248     DecayedT compare_decayed_value = compare_value;
1249     // Determine default memory ordering
1250     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1251       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1252       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1253     // Potentially remember that we need compressed oop awareness
1254     const DecoratorSet final_decorators = expanded_decorators |
1255                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1256                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<span class="line-modified">1257     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(new_decayed_value, base,</span>
<span class="line-modified">1258                                                                    offset, compare_decayed_value);</span>
1259   }
1260 
1261   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">1262   inline T atomic_xchg(T new_value, P* addr) {</span>
1263     verify_types&lt;decorators, T&gt;();
1264     typedef typename Decay&lt;P&gt;::type DecayedP;
1265     typedef typename Decay&lt;T&gt;::type DecayedT;
1266     DecayedT new_decayed_value = new_value;
1267     // atomic_xchg is only available in SEQ_CST flavour.
1268     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<span class="line-modified">1269     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(new_decayed_value,</span>
<span class="line-modified">1270                                                          const_cast&lt;DecayedP*&gt;(addr));</span>
1271   }
1272 
1273   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1274   inline T atomic_xchg_at(T new_value, oop base, ptrdiff_t offset) {</span>
1275     verify_types&lt;decorators, T&gt;();
1276     typedef typename Decay&lt;T&gt;::type DecayedT;
1277     DecayedT new_decayed_value = new_value;
1278     // atomic_xchg is only available in SEQ_CST flavour.
1279     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1280                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1281                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<span class="line-modified">1282     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(new_decayed_value, base, offset);</span>
1283   }
1284 
1285   template &lt;DecoratorSet decorators, typename T&gt;
1286   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
1287                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1288                         size_t length) {
1289     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1290                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1291                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1292     typedef typename Decay&lt;T&gt;::type DecayedT;
1293     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
1294     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),
1295                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),
1296                                                        length);
1297   }
1298 
1299   template &lt;DecoratorSet decorators&gt;
1300   inline void clone(oop src, oop dst, size_t size) {
1301     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1302     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1303   }
1304 
1305   template &lt;DecoratorSet decorators&gt;
1306   inline oop resolve(oop obj) {
1307     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1308     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1309   }
1310 
<span class="line-removed">1311   template &lt;DecoratorSet decorators&gt;</span>
<span class="line-removed">1312   inline bool equals(oop o1, oop o2) {</span>
<span class="line-removed">1313     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;</span>
<span class="line-removed">1314     return PreRuntimeDispatch::equals&lt;expanded_decorators&gt;(o1, o2);</span>
<span class="line-removed">1315   }</span>
<span class="line-removed">1316 </span>
1317   // Infer the type that should be returned from an Access::oop_load.
1318   template &lt;typename P, DecoratorSet decorators&gt;
1319   class OopLoadProxy: public StackObj {
1320   private:
1321     P *const _addr;
1322   public:
1323     OopLoadProxy(P* addr) : _addr(addr) {}
1324 
1325     inline operator oop() {
1326       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1327     }
1328 
1329     inline operator narrowOop() {
1330       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1331     }
1332 
1333     template &lt;typename T&gt;
1334     inline bool operator ==(const T&amp; other) const {
1335       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1336     }
</pre>
</td>
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-added">  41 #include &quot;runtime/globals.hpp&quot;</span>
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 
  55 namespace AccessInternal {
  56   enum BarrierType {
  57     BARRIER_STORE,
  58     BARRIER_STORE_AT,
  59     BARRIER_LOAD,
  60     BARRIER_LOAD_AT,
  61     BARRIER_ATOMIC_CMPXCHG,
  62     BARRIER_ATOMIC_CMPXCHG_AT,
  63     BARRIER_ATOMIC_XCHG,
  64     BARRIER_ATOMIC_XCHG_AT,
  65     BARRIER_ARRAYCOPY,
  66     BARRIER_CLONE,
<span class="line-modified">  67     BARRIER_RESOLVE</span>

  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
  87   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  88     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  89              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  90   }
  91 
  92   // This metafunction returns whether it is possible for a type T to require
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
<span class="line-modified"> 105     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
<span class="line-modified"> 106     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);</span>
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
<span class="line-modified"> 110     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);</span>
<span class="line-modified"> 111     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);</span>
 112 
 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
 117     typedef oop (*resolve_func_t)(oop obj);

 118   };
 119 
 120   template &lt;DecoratorSet decorators&gt;
 121   struct AccessFunctionTypes&lt;decorators, void&gt; {
 122     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 124                                      size_t length);
 125   };
 126 
 127   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 128 
 129 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 130   template &lt;DecoratorSet decorators, typename T&gt;                    \
 131   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 132     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 133   }
 134   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);

 145 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 146 
 147   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 148   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 149 
 150   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 151   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 152 
 153   class AccessLocker {
 154   public:
 155     AccessLocker();
 156     ~AccessLocker();
 157   };
 158   bool wide_atomic_needs_locking();
 159 
 160   void* field_addr(oop base, ptrdiff_t offset);
 161 
 162   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 163   // faster build times, given how frequently included access is.
 164   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
</pre>
<hr />
<pre>
 276     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 277   store_internal(void* addr, T value);
 278 
 279   template &lt;DecoratorSet ds, typename T&gt;
 280   static inline typename EnableIf&lt;
 281     HasDecorator&lt;ds, MO_VOLATILE&gt;::value&gt;::type
 282   store_internal(void* addr, T value) {
 283     (void)const_cast&lt;T&amp;&gt;(*reinterpret_cast&lt;volatile T*&gt;(addr) = value);
 284   }
 285 
 286   template &lt;DecoratorSet ds, typename T&gt;
 287   static inline typename EnableIf&lt;
 288     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 289   store_internal(void* addr, T value) {
 290     *reinterpret_cast&lt;T*&gt;(addr) = value;
 291   }
 292 
 293   template &lt;DecoratorSet ds, typename T&gt;
 294   static typename EnableIf&lt;
 295     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified"> 296   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
 297 
 298   template &lt;DecoratorSet ds, typename T&gt;
 299   static typename EnableIf&lt;
 300     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
<span class="line-modified"> 301   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);</span>
 302 
 303   template &lt;DecoratorSet ds, typename T&gt;
 304   static typename EnableIf&lt;
 305     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
<span class="line-modified"> 306   atomic_xchg_internal(void* addr, T new_value);</span>
 307 
 308   // The following *_locked mechanisms serve the purpose of handling atomic operations
 309   // that are larger than a machine can handle, and then possibly opt for using
 310   // a slower path using a mutex to perform the operation.
 311 
 312   template &lt;DecoratorSet ds, typename T&gt;
 313   static inline typename EnableIf&lt;
 314     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 315   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 316     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);</span>
 317   }
 318 
 319   template &lt;DecoratorSet ds, typename T&gt;
 320   static typename EnableIf&lt;
 321     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 322   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);</span>
 323 
 324   template &lt;DecoratorSet ds, typename T&gt;
 325   static inline typename EnableIf&lt;
 326     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 327   atomic_xchg_maybe_locked(void* addr, T new_value) {</span>
<span class="line-modified"> 328     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);</span>
 329   }
 330 
 331   template &lt;DecoratorSet ds, typename T&gt;
 332   static typename EnableIf&lt;
 333     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
<span class="line-modified"> 334   atomic_xchg_maybe_locked(void* addr, T new_value);</span>
 335 
 336 public:
 337   template &lt;typename T&gt;
 338   static inline void store(void* addr, T value) {
 339     store_internal&lt;decorators&gt;(addr, value);
 340   }
 341 
 342   template &lt;typename T&gt;
 343   static inline T load(void* addr) {
 344     return load_internal&lt;decorators, T&gt;(addr);
 345   }
 346 
 347   template &lt;typename T&gt;
<span class="line-modified"> 348   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 349     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);</span>
 350   }
 351 
 352   template &lt;typename T&gt;
<span class="line-modified"> 353   static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified"> 354     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);</span>
 355   }
 356 
 357   template &lt;typename T&gt;
 358   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 359                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 360                         size_t length);
 361 
 362   template &lt;typename T&gt;
 363   static void oop_store(void* addr, T value);
 364   template &lt;typename T&gt;
 365   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 366 
 367   template &lt;typename T&gt;
 368   static T oop_load(void* addr);
 369   template &lt;typename T&gt;
 370   static T oop_load_at(oop base, ptrdiff_t offset);
 371 
 372   template &lt;typename T&gt;
<span class="line-modified"> 373   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);</span>
 374   template &lt;typename T&gt;
<span class="line-modified"> 375   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
 376 
 377   template &lt;typename T&gt;
<span class="line-modified"> 378   static T oop_atomic_xchg(void* addr, T new_value);</span>
 379   template &lt;typename T&gt;
<span class="line-modified"> 380   static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);</span>
 381 
 382   template &lt;typename T&gt;
 383   static void store_at(oop base, ptrdiff_t offset, T value) {
 384     store(field_addr(base, offset), value);
 385   }
 386 
 387   template &lt;typename T&gt;
 388   static T load_at(oop base, ptrdiff_t offset) {
 389     return load&lt;T&gt;(field_addr(base, offset));
 390   }
 391 
 392   template &lt;typename T&gt;
<span class="line-modified"> 393   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 394     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);</span>
 395   }
 396 
 397   template &lt;typename T&gt;
<span class="line-modified"> 398   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 399     return atomic_xchg(field_addr(base, offset), new_value);</span>
 400   }
 401 
 402   template &lt;typename T&gt;
 403   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 404                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 405                             size_t length);
 406 
 407   static void clone(oop src, oop dst, size_t size);
 408 
 409   static oop resolve(oop obj) { return obj; }


 410 };
 411 
 412 // Below is the implementation of the first 4 steps of the template pipeline:
 413 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 414 //           and sets default decorators to sensible values.
 415 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 416 //           multiple types. The P type of the address and T type of the value must
 417 //           match.
 418 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 419 //           avoided, and in that case avoids it (calling raw accesses or
 420 //           primitive accesses in a build that does not require primitive GC barriers)
 421 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 422 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 423 //           to the access.
 424 
 425 namespace AccessInternal {
 426   template &lt;typename T&gt;
 427   struct OopOrNarrowOopInternal: AllStatic {
 428     typedef oop type;
 429   };
</pre>
<hr />
<pre>
 498     }
 499   };
 500 
 501   template &lt;DecoratorSet decorators, typename T&gt;
 502   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 503     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 504     static func_t _load_at_func;
 505 
 506     static T load_at_init(oop base, ptrdiff_t offset);
 507 
 508     static inline T load_at(oop base, ptrdiff_t offset) {
 509       return _load_at_func(base, offset);
 510     }
 511   };
 512 
 513   template &lt;DecoratorSet decorators, typename T&gt;
 514   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 515     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 516     static func_t _atomic_cmpxchg_func;
 517 
<span class="line-modified"> 518     static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);</span>
 519 
<span class="line-modified"> 520     static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
<span class="line-modified"> 521       return _atomic_cmpxchg_func(addr, compare_value, new_value);</span>
 522     }
 523   };
 524 
 525   template &lt;DecoratorSet decorators, typename T&gt;
 526   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 527     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 528     static func_t _atomic_cmpxchg_at_func;
 529 
<span class="line-modified"> 530     static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);</span>
 531 
<span class="line-modified"> 532     static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 533       return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);</span>
 534     }
 535   };
 536 
 537   template &lt;DecoratorSet decorators, typename T&gt;
 538   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 539     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 540     static func_t _atomic_xchg_func;
 541 
<span class="line-modified"> 542     static T atomic_xchg_init(void* addr, T new_value);</span>
 543 
<span class="line-modified"> 544     static inline T atomic_xchg(void* addr, T new_value) {</span>
<span class="line-modified"> 545       return _atomic_xchg_func(addr, new_value);</span>
 546     }
 547   };
 548 
 549   template &lt;DecoratorSet decorators, typename T&gt;
 550   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 551     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 552     static func_t _atomic_xchg_at_func;
 553 
<span class="line-modified"> 554     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);</span>
 555 
<span class="line-modified"> 556     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 557       return _atomic_xchg_at_func(base, offset, new_value);</span>
 558     }
 559   };
 560 
 561   template &lt;DecoratorSet decorators, typename T&gt;
 562   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 563     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 564     static func_t _arraycopy_func;
 565 
 566     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 567                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 568                                size_t length);
 569 
 570     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 571                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 572                                  size_t length) {
 573       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 574                              dst_obj, dst_offset_in_bytes, dst_raw,
 575                              length);
 576     }
 577   };
</pre>
<hr />
<pre>
 583 
 584     static void clone_init(oop src, oop dst, size_t size);
 585 
 586     static inline void clone(oop src, oop dst, size_t size) {
 587       _clone_func(src, dst, size);
 588     }
 589   };
 590 
 591   template &lt;DecoratorSet decorators, typename T&gt;
 592   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 593     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 594     static func_t _resolve_func;
 595 
 596     static oop resolve_init(oop obj);
 597 
 598     static inline oop resolve(oop obj) {
 599       return _resolve_func(obj);
 600     }
 601   };
 602 












 603   // Initialize the function pointers to point to the resolving function.
 604   template &lt;DecoratorSet decorators, typename T&gt;
 605   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 606   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 607 
 608   template &lt;DecoratorSet decorators, typename T&gt;
 609   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 610   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 611 
 612   template &lt;DecoratorSet decorators, typename T&gt;
 613   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 614   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 615 
 616   template &lt;DecoratorSet decorators, typename T&gt;
 617   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 618   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 619 
 620   template &lt;DecoratorSet decorators, typename T&gt;
 621   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 622   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
</pre>
<hr />
<pre>
 628   template &lt;DecoratorSet decorators, typename T&gt;
 629   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 630   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 631 
 632   template &lt;DecoratorSet decorators, typename T&gt;
 633   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 634   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 635 
 636   template &lt;DecoratorSet decorators, typename T&gt;
 637   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 638   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 639 
 640   template &lt;DecoratorSet decorators, typename T&gt;
 641   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 642   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 643 
 644   template &lt;DecoratorSet decorators, typename T&gt;
 645   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 646   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 647 




 648   // Step 3: Pre-runtime dispatching.
 649   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 650   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 651   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 652   // not possible.
 653   struct PreRuntimeDispatch: AllStatic {
 654     template&lt;DecoratorSet decorators&gt;
 655     struct CanHardwireRaw: public IntegralConstant&lt;
 656       bool,
 657       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 658       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 659       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 660     {};
 661 
 662     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 663 
 664     template&lt;DecoratorSet decorators&gt;
 665     static bool is_hardwired_primitive() {
 666       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 667              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
</pre>
<hr />
<pre>
 765       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 766     load_at(oop base, ptrdiff_t offset) {
 767       return load&lt;decorators, T&gt;(field_addr(base, offset));
 768     }
 769 
 770     template &lt;DecoratorSet decorators, typename T&gt;
 771     inline static typename EnableIf&lt;
 772       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 773     load_at(oop base, ptrdiff_t offset) {
 774       if (is_hardwired_primitive&lt;decorators&gt;()) {
 775         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 776         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 777       } else {
 778         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 779       }
 780     }
 781 
 782     template &lt;DecoratorSet decorators, typename T&gt;
 783     inline static typename EnableIf&lt;
 784       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 785     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 786       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 787       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 788         return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
 789       } else {
<span class="line-modified"> 790         return Raw::atomic_cmpxchg(addr, compare_value, new_value);</span>
 791       }
 792     }
 793 
 794     template &lt;DecoratorSet decorators, typename T&gt;
 795     inline static typename EnableIf&lt;
 796       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 797     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 798       if (UseCompressedOops) {
 799         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 800         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 801       } else {
 802         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 803         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 804       }
 805     }
 806 
 807     template &lt;DecoratorSet decorators, typename T&gt;
 808     inline static typename EnableIf&lt;
 809       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 810     atomic_cmpxchg(void* addr, T compare_value, T new_value) {</span>
 811       if (is_hardwired_primitive&lt;decorators&gt;()) {
 812         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 813         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
 814       } else {
<span class="line-modified"> 815         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(addr, compare_value, new_value);</span>
 816       }
 817     }
 818 
 819     template &lt;DecoratorSet decorators, typename T&gt;
 820     inline static typename EnableIf&lt;
 821       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 822     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified"> 823       return atomic_cmpxchg&lt;decorators&gt;(field_addr(base, offset), compare_value, new_value);</span>
 824     }
 825 
 826     template &lt;DecoratorSet decorators, typename T&gt;
 827     inline static typename EnableIf&lt;
 828       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 829     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
 830       if (is_hardwired_primitive&lt;decorators&gt;()) {
 831         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 832         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(base, offset, compare_value, new_value);</span>
 833       } else {
<span class="line-modified"> 834         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(base, offset, compare_value, new_value);</span>
 835       }
 836     }
 837 
 838     template &lt;DecoratorSet decorators, typename T&gt;
 839     inline static typename EnableIf&lt;
 840       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 841     atomic_xchg(void* addr, T new_value) {</span>
 842       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 843       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 844         return Raw::oop_atomic_xchg(addr, new_value);</span>
 845       } else {
<span class="line-modified"> 846         return Raw::atomic_xchg(addr, new_value);</span>
 847       }
 848     }
 849 
 850     template &lt;DecoratorSet decorators, typename T&gt;
 851     inline static typename EnableIf&lt;
 852       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
<span class="line-modified"> 853     atomic_xchg(void* addr, T new_value) {</span>
 854       if (UseCompressedOops) {
 855         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 856         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 857       } else {
 858         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 859         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 860       }
 861     }
 862 
 863     template &lt;DecoratorSet decorators, typename T&gt;
 864     inline static typename EnableIf&lt;
 865       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 866     atomic_xchg(void* addr, T new_value) {</span>
 867       if (is_hardwired_primitive&lt;decorators&gt;()) {
 868         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 869         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
 870       } else {
<span class="line-modified"> 871         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(addr, new_value);</span>
 872       }
 873     }
 874 
 875     template &lt;DecoratorSet decorators, typename T&gt;
 876     inline static typename EnableIf&lt;
 877       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 878     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified"> 879       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);</span>
 880     }
 881 
 882     template &lt;DecoratorSet decorators, typename T&gt;
 883     inline static typename EnableIf&lt;
 884       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
<span class="line-modified"> 885     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
 886       if (is_hardwired_primitive&lt;decorators&gt;()) {
 887         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 888         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);</span>
 889       } else {
<span class="line-modified"> 890         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);</span>
 891       }
 892     }
 893 
 894     template &lt;DecoratorSet decorators, typename T&gt;
 895     inline static typename EnableIf&lt;
 896       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type
 897     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 898               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 899               size_t length) {
 900       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 901       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 902         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,
 903                                   dst_obj, dst_offset_in_bytes, dst_raw,
 904                                   length);
 905       } else {
 906         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 907                               dst_obj, dst_offset_in_bytes, dst_raw,
 908                               length);
 909       }
 910     }
</pre>
<hr />
<pre>
 958     inline static typename EnableIf&lt;
 959       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 960     clone(oop src, oop dst, size_t size) {
 961       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 962     }
 963 
 964     template &lt;DecoratorSet decorators&gt;
 965     inline static typename EnableIf&lt;
 966       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 967     resolve(oop obj) {
 968       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 969       return Raw::resolve(obj);
 970     }
 971 
 972     template &lt;DecoratorSet decorators&gt;
 973     inline static typename EnableIf&lt;
 974       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 975     resolve(oop obj) {
 976       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 977     }















 978   };
 979 
 980   // Step 2: Reduce types.
 981   // Enforce that for non-oop types, T and P have to be strictly the same.
 982   // P is the type of the address and T is the type of the values.
 983   // As for oop types, it is allow to send T in {narrowOop, oop} and
 984   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
 985   // the subsequent table. (columns are P, rows are T)
 986   // |           | HeapWord  |   oop   | narrowOop |
 987   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
 988   // | narrowOop |     x     |    x    |  hw-none  |
 989   //
 990   // x means not allowed
 991   // rt-comp means it must be checked at runtime whether the oop is compressed.
 992   // hw-none means it is statically known the oop will not be compressed.
 993   // hw-comp means it is statically known the oop will be compressed.
 994 
 995   template &lt;DecoratorSet decorators, typename T&gt;
 996   inline void store_reduce_types(T* addr, T value) {
 997     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
</pre>
<hr />
<pre>
1001   inline void store_reduce_types(narrowOop* addr, oop value) {
1002     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1003                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1004     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1005   }
1006 
1007   template &lt;DecoratorSet decorators&gt;
1008   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
1009     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1010                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1011     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1012   }
1013 
1014   template &lt;DecoratorSet decorators&gt;
1015   inline void store_reduce_types(HeapWord* addr, oop value) {
1016     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1017     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1018   }
1019 
1020   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1021   inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {</span>
<span class="line-modified">1022     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);</span>
1023   }
1024 
1025   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1026   inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {</span>
1027     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1028                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1029     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1030   }
1031 
1032   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1033   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {</span>
1034     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1035                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1036     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1037   }
1038 
1039   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1040   inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,</span>
<span class="line-modified">1041                                          oop compare_value,</span>
<span class="line-modified">1042                                          oop new_value) {</span>
1043     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1044     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);</span>
1045   }
1046 
1047   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1048   inline T atomic_xchg_reduce_types(T* addr, T new_value) {</span>
1049     const DecoratorSet expanded_decorators = decorators;
<span class="line-modified">1050     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1051   }
1052 
1053   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1054   inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {</span>
1055     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1056                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1057     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1058   }
1059 
1060   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1061   inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {</span>
1062     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1063                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1064     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1065   }
1066 
1067   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1068   inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {</span>
1069     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1070     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);</span>
1071   }
1072 
1073   template &lt;DecoratorSet decorators, typename T&gt;
1074   inline T load_reduce_types(T* addr) {
1075     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1076   }
1077 
1078   template &lt;DecoratorSet decorators, typename T&gt;
1079   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1080     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1081                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1082     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1083   }
1084 
1085   template &lt;DecoratorSet decorators, typename T&gt;
1086   inline oop load_reduce_types(HeapWord* addr) {
1087     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1088     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1089   }
1090 
</pre>
<hr />
<pre>
1174       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1175       (MO_VOLATILE | decorators) : decorators&gt;::value;
1176     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1177   }
1178 
1179   template &lt;DecoratorSet decorators, typename T&gt;
1180   inline T load_at(oop base, ptrdiff_t offset) {
1181     verify_types&lt;decorators, T&gt;();
1182     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1183                                  typename OopOrNarrowOop&lt;T&gt;::type,
1184                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1185     // Expand the decorators (figure out sensible defaults)
1186     // Potentially remember if we need compressed oop awareness
1187     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1188                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1189                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1190     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1191   }
1192 
1193   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">1194   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {</span>
1195     verify_types&lt;decorators, T&gt;();
1196     typedef typename Decay&lt;P&gt;::type DecayedP;
1197     typedef typename Decay&lt;T&gt;::type DecayedT;
1198     DecayedT new_decayed_value = new_value;
1199     DecayedT compare_decayed_value = compare_value;
1200     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1201       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1202       (MO_SEQ_CST | decorators) : decorators&gt;::value;
<span class="line-modified">1203     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1204                                                             compare_decayed_value,</span>
<span class="line-modified">1205                                                             new_decayed_value);</span>
1206   }
1207 
1208   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1209   inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
1210     verify_types&lt;decorators, T&gt;();
1211     typedef typename Decay&lt;T&gt;::type DecayedT;
1212     DecayedT new_decayed_value = new_value;
1213     DecayedT compare_decayed_value = compare_value;
1214     // Determine default memory ordering
1215     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1216       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1217       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1218     // Potentially remember that we need compressed oop awareness
1219     const DecoratorSet final_decorators = expanded_decorators |
1220                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1221                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
<span class="line-modified">1222     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(base, offset, compare_decayed_value,</span>
<span class="line-modified">1223                                                                    new_decayed_value);</span>
1224   }
1225 
1226   template &lt;DecoratorSet decorators, typename P, typename T&gt;
<span class="line-modified">1227   inline T atomic_xchg(P* addr, T new_value) {</span>
1228     verify_types&lt;decorators, T&gt;();
1229     typedef typename Decay&lt;P&gt;::type DecayedP;
1230     typedef typename Decay&lt;T&gt;::type DecayedT;
1231     DecayedT new_decayed_value = new_value;
1232     // atomic_xchg is only available in SEQ_CST flavour.
1233     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
<span class="line-modified">1234     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),</span>
<span class="line-modified">1235                                                          new_decayed_value);</span>
1236   }
1237 
1238   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1239   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {</span>
1240     verify_types&lt;decorators, T&gt;();
1241     typedef typename Decay&lt;T&gt;::type DecayedT;
1242     DecayedT new_decayed_value = new_value;
1243     // atomic_xchg is only available in SEQ_CST flavour.
1244     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1245                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1246                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
<span class="line-modified">1247     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);</span>
1248   }
1249 
1250   template &lt;DecoratorSet decorators, typename T&gt;
1251   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
1252                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1253                         size_t length) {
1254     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1255                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1256                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1257     typedef typename Decay&lt;T&gt;::type DecayedT;
1258     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
1259     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),
1260                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),
1261                                                        length);
1262   }
1263 
1264   template &lt;DecoratorSet decorators&gt;
1265   inline void clone(oop src, oop dst, size_t size) {
1266     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1267     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1268   }
1269 
1270   template &lt;DecoratorSet decorators&gt;
1271   inline oop resolve(oop obj) {
1272     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1273     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1274   }
1275 






1276   // Infer the type that should be returned from an Access::oop_load.
1277   template &lt;typename P, DecoratorSet decorators&gt;
1278   class OopLoadProxy: public StackObj {
1279   private:
1280     P *const _addr;
1281   public:
1282     OopLoadProxy(P* addr) : _addr(addr) {}
1283 
1284     inline operator oop() {
1285       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1286     }
1287 
1288     inline operator narrowOop() {
1289       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1290     }
1291 
1292     template &lt;typename T&gt;
1293     inline bool operator ==(const T&amp; other) const {
1294       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1295     }
</pre>
</td>
</tr>
</table>
<center><a href="access.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
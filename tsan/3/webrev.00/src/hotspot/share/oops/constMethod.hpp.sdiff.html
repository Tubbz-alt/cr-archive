<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CONSTMETHOD_HPP
 26 #define SHARE_OOPS_CONSTMETHOD_HPP
 27 
 28 #include &quot;oops/oop.hpp&quot;

 29 #include &quot;utilities/align.hpp&quot;
 30 
 31 // An ConstMethod represents portions of a Java method which are not written to after
 32 // the classfile is parsed(*see below).  This part of the method can be shared across
 33 // processes in a read-only section with Class Data Sharing (CDS).  It&#39;s important
 34 // that this class doesn&#39;t have virtual functions because the vptr cannot be shared
 35 // with CDS.
 36 //
 37 // Note that most applications load thousands of methods, so keeping the size of this
 38 // structure small has a big impact on footprint.
 39 
 40 // The actual bytecodes are inlined after the end of the ConstMethod struct.
 41 //
 42 // The line number table is compressed and inlined following the byte codes. It is
 43 // found as the first byte following the byte codes.  Note that accessing the line
 44 // number and local variable tables is not performance critical at all.
 45 //
 46 // The checked exceptions table and the local variable table are inlined after the
 47 // line number table, and indexed from the end of the method. We do not compress the
 48 // checked exceptions table since the average length is less than 2, and it is used
</pre>
<hr />
<pre>
104   u2 signature_cp_index;
105   u2 slot;
106 };
107 
108 // Utility class describing elements in exception table
109 class ExceptionTableElement {
110  public:
111   u2 start_pc;
112   u2 end_pc;
113   u2 handler_pc;
114   u2 catch_type_index;
115 };
116 
117 // Utility class describing elements in method parameters
118 class MethodParametersElement {
119  public:
120   u2 name_cp_index;
121   u2 flags;
122 };
123 
<span class="line-removed">124 class KlassSizeStats;</span>
125 class AdapterHandlerEntry;
126 
127 // Class to collect the sizes of ConstMethod inline tables
128 #define INLINE_TABLES_DO(do_element)            \
129   do_element(localvariable_table_length)        \
130   do_element(compressed_linenumber_size)        \
131   do_element(exception_table_length)            \
132   do_element(checked_exceptions_length)         \
133   do_element(method_parameters_length)          \
134   do_element(generic_signature_index)           \
135   do_element(method_annotations_length)         \
136   do_element(parameter_annotations_length)      \
137   do_element(type_annotations_length)           \
138   do_element(default_annotations_length)
139 
140 #define INLINE_TABLE_DECLARE(sym)    int _##sym;
141 #define INLINE_TABLE_PARAM(sym)      int sym,
142 #define INLINE_TABLE_INIT(sym)       _##sym(sym),
143 #define INLINE_TABLE_NULL(sym)       _##sym(0),
144 #define INLINE_TABLE_ACCESSOR(sym)   int sym() const { return _##sym; }
</pre>
<hr />
<pre>
271       _flags &amp;= ~(_is_overpass);
272     } else {
273       _flags |= _is_overpass;
274     }
275   }
276 
277   // constant pool
278   ConstantPool* constants() const        { return _constants; }
279   void set_constants(ConstantPool* c)    { _constants = c; }
280 
281   Method* method() const;
282 
283   // stackmap table data
284   Array&lt;u1&gt;* stackmap_data() const { return _stackmap_data; }
285   void set_stackmap_data(Array&lt;u1&gt;* sd) { _stackmap_data = sd; }
286   void copy_stackmap_data(ClassLoaderData* loader_data, u1* sd, int length, TRAPS);
287   bool has_stackmap_table() const { return _stackmap_data != NULL; }
288 
289   // adapter
290   void set_adapter_entry(AdapterHandlerEntry* adapter) {
<span class="line-modified">291     assert(!is_shared(), &quot;shared methods have fixed adapter_trampoline&quot;);</span>

292     _adapter = adapter;
293   }
294   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
<span class="line-modified">295     assert(DumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-modified">296     assert(*trampoline == NULL, &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>



297     _adapter_trampoline = trampoline;
298   }
299   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
300     assert(is_shared(), &quot;must be&quot;);
301     *_adapter_trampoline = adapter;
302     assert(this-&gt;adapter() == adapter, &quot;must be&quot;);
303   }
304   AdapterHandlerEntry* adapter() {
305     if (is_shared()) {
306       return *_adapter_trampoline;
307     } else {
308       return _adapter;
309     }
310   }
311 
312   void init_fingerprint() {
313     const uint64_t initval = UCONST64(0x8000000000000000);
314     _fingerprint = initval;
315   }
316 
</pre>
<hr />
<pre>
357   void set_generic_signature_index(u2 index)    {
358     assert(has_generic_signature(), &quot;&quot;);
359     u2* addr = generic_signature_index_addr();
360     *addr = index;
361   }
362 
363   // Sizing
364   static int header_size() {
365     return align_up((int)sizeof(ConstMethod), wordSize) / wordSize;
366   }
367 
368   // Size needed
369   static int size(int code_size, InlineTableSizes* sizes);
370 
371   int size() const                    { return _constMethod_size;}
372   void set_constMethod_size(int size)     { _constMethod_size = size; }
373 
374   // ConstMethods should be stored in the read-only region of CDS archive.
375   static bool is_read_only_by_default() { return true; }
376 
<span class="line-removed">377 #if INCLUDE_SERVICES</span>
<span class="line-removed">378   void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">379 #endif</span>
<span class="line-removed">380 </span>
381   // code size
382   int code_size() const                          { return _code_size; }
383   void set_code_size(int size) {
384     assert(max_method_code_size &lt; (1 &lt;&lt; 16),
385            &quot;u2 is too small to hold method code size in general&quot;);
386     assert(0 &lt;= size &amp;&amp; size &lt;= max_method_code_size, &quot;invalid code size&quot;);
387     _code_size = size;
388   }
389 
390   // linenumber table - note that length is unknown until decompression,
391   // see class CompressedLineNumberReadStream.
392   u_char* compressed_linenumber_table() const;         // not preserved by gc
393   u2* generic_signature_index_addr() const;
394   u2* checked_exceptions_length_addr() const;
395   u2* localvariable_table_length_addr() const;
396   u2* exception_table_length_addr() const;
397   u2* method_parameters_length_addr() const;
398 
399   // checked exceptions
400   int checked_exceptions_length() const;
</pre>
<hr />
<pre>
510   static const u2 MAX_IDNUM;
511   static const u2 UNSET_IDNUM;
512   u2 method_idnum() const                        { return _method_idnum; }
513   void set_method_idnum(u2 idnum)                { _method_idnum = idnum; }
514 
515   u2 orig_method_idnum() const                   { return _orig_method_idnum; }
516   void set_orig_method_idnum(u2 idnum)           { _orig_method_idnum = idnum; }
517 
518   // max stack
519   int  max_stack() const                         { return _max_stack; }
520   void set_max_stack(int size)                   { _max_stack = size; }
521 
522   // max locals
523   int  max_locals() const                        { return _max_locals; }
524   void set_max_locals(int size)                  { _max_locals = size; }
525 
526   // size of parameters
527   int  size_of_parameters() const                { return _size_of_parameters; }
528   void set_size_of_parameters(int size)          { _size_of_parameters = size; }
529 




530   void set_result_type(BasicType rt)             { assert(rt &lt; 16, &quot;result type too large&quot;);
531                                                    _result_type = (u1)rt; }
532   // Deallocation for RedefineClasses
533   void deallocate_contents(ClassLoaderData* loader_data);
534   bool is_klass() const { return false; }
535   DEBUG_ONLY(bool on_stack() { return false; })
536 
537   void metaspace_pointers_do(MetaspaceClosure* it);
538   MetaspaceObj::Type type() const { return ConstMethodType; }
539 private:
540   // Since the size of the compressed line number table is unknown, the
541   // offsets of the other variable sized sections are computed backwards
542   // from the end of the ConstMethod*.
543 
544   // First byte after ConstMethod*
545   address constMethod_end() const
546                           { return (address)((intptr_t*)this + _constMethod_size); }
547 
548   // Last short in ConstMethod*
549   u2* last_u2_element() const;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_CONSTMETHOD_HPP
 26 #define SHARE_OOPS_CONSTMETHOD_HPP
 27 
 28 #include &quot;oops/oop.hpp&quot;
<span class="line-added"> 29 #include &quot;runtime/arguments.hpp&quot;</span>
 30 #include &quot;utilities/align.hpp&quot;
 31 
 32 // An ConstMethod represents portions of a Java method which are not written to after
 33 // the classfile is parsed(*see below).  This part of the method can be shared across
 34 // processes in a read-only section with Class Data Sharing (CDS).  It&#39;s important
 35 // that this class doesn&#39;t have virtual functions because the vptr cannot be shared
 36 // with CDS.
 37 //
 38 // Note that most applications load thousands of methods, so keeping the size of this
 39 // structure small has a big impact on footprint.
 40 
 41 // The actual bytecodes are inlined after the end of the ConstMethod struct.
 42 //
 43 // The line number table is compressed and inlined following the byte codes. It is
 44 // found as the first byte following the byte codes.  Note that accessing the line
 45 // number and local variable tables is not performance critical at all.
 46 //
 47 // The checked exceptions table and the local variable table are inlined after the
 48 // line number table, and indexed from the end of the method. We do not compress the
 49 // checked exceptions table since the average length is less than 2, and it is used
</pre>
<hr />
<pre>
105   u2 signature_cp_index;
106   u2 slot;
107 };
108 
109 // Utility class describing elements in exception table
110 class ExceptionTableElement {
111  public:
112   u2 start_pc;
113   u2 end_pc;
114   u2 handler_pc;
115   u2 catch_type_index;
116 };
117 
118 // Utility class describing elements in method parameters
119 class MethodParametersElement {
120  public:
121   u2 name_cp_index;
122   u2 flags;
123 };
124 

125 class AdapterHandlerEntry;
126 
127 // Class to collect the sizes of ConstMethod inline tables
128 #define INLINE_TABLES_DO(do_element)            \
129   do_element(localvariable_table_length)        \
130   do_element(compressed_linenumber_size)        \
131   do_element(exception_table_length)            \
132   do_element(checked_exceptions_length)         \
133   do_element(method_parameters_length)          \
134   do_element(generic_signature_index)           \
135   do_element(method_annotations_length)         \
136   do_element(parameter_annotations_length)      \
137   do_element(type_annotations_length)           \
138   do_element(default_annotations_length)
139 
140 #define INLINE_TABLE_DECLARE(sym)    int _##sym;
141 #define INLINE_TABLE_PARAM(sym)      int sym,
142 #define INLINE_TABLE_INIT(sym)       _##sym(sym),
143 #define INLINE_TABLE_NULL(sym)       _##sym(0),
144 #define INLINE_TABLE_ACCESSOR(sym)   int sym() const { return _##sym; }
</pre>
<hr />
<pre>
271       _flags &amp;= ~(_is_overpass);
272     } else {
273       _flags |= _is_overpass;
274     }
275   }
276 
277   // constant pool
278   ConstantPool* constants() const        { return _constants; }
279   void set_constants(ConstantPool* c)    { _constants = c; }
280 
281   Method* method() const;
282 
283   // stackmap table data
284   Array&lt;u1&gt;* stackmap_data() const { return _stackmap_data; }
285   void set_stackmap_data(Array&lt;u1&gt;* sd) { _stackmap_data = sd; }
286   void copy_stackmap_data(ClassLoaderData* loader_data, u1* sd, int length, TRAPS);
287   bool has_stackmap_table() const { return _stackmap_data != NULL; }
288 
289   // adapter
290   void set_adapter_entry(AdapterHandlerEntry* adapter) {
<span class="line-modified">291     assert(!is_shared(),</span>
<span class="line-added">292            &quot;shared methods in archive have fixed adapter_trampoline&quot;);</span>
293     _adapter = adapter;
294   }
295   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
<span class="line-modified">296     Arguments::assert_is_dumping_archive();</span>
<span class="line-modified">297     if (DumpSharedSpaces) {</span>
<span class="line-added">298       assert(*trampoline == NULL,</span>
<span class="line-added">299              &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">300     }</span>
301     _adapter_trampoline = trampoline;
302   }
303   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
304     assert(is_shared(), &quot;must be&quot;);
305     *_adapter_trampoline = adapter;
306     assert(this-&gt;adapter() == adapter, &quot;must be&quot;);
307   }
308   AdapterHandlerEntry* adapter() {
309     if (is_shared()) {
310       return *_adapter_trampoline;
311     } else {
312       return _adapter;
313     }
314   }
315 
316   void init_fingerprint() {
317     const uint64_t initval = UCONST64(0x8000000000000000);
318     _fingerprint = initval;
319   }
320 
</pre>
<hr />
<pre>
361   void set_generic_signature_index(u2 index)    {
362     assert(has_generic_signature(), &quot;&quot;);
363     u2* addr = generic_signature_index_addr();
364     *addr = index;
365   }
366 
367   // Sizing
368   static int header_size() {
369     return align_up((int)sizeof(ConstMethod), wordSize) / wordSize;
370   }
371 
372   // Size needed
373   static int size(int code_size, InlineTableSizes* sizes);
374 
375   int size() const                    { return _constMethod_size;}
376   void set_constMethod_size(int size)     { _constMethod_size = size; }
377 
378   // ConstMethods should be stored in the read-only region of CDS archive.
379   static bool is_read_only_by_default() { return true; }
380 




381   // code size
382   int code_size() const                          { return _code_size; }
383   void set_code_size(int size) {
384     assert(max_method_code_size &lt; (1 &lt;&lt; 16),
385            &quot;u2 is too small to hold method code size in general&quot;);
386     assert(0 &lt;= size &amp;&amp; size &lt;= max_method_code_size, &quot;invalid code size&quot;);
387     _code_size = size;
388   }
389 
390   // linenumber table - note that length is unknown until decompression,
391   // see class CompressedLineNumberReadStream.
392   u_char* compressed_linenumber_table() const;         // not preserved by gc
393   u2* generic_signature_index_addr() const;
394   u2* checked_exceptions_length_addr() const;
395   u2* localvariable_table_length_addr() const;
396   u2* exception_table_length_addr() const;
397   u2* method_parameters_length_addr() const;
398 
399   // checked exceptions
400   int checked_exceptions_length() const;
</pre>
<hr />
<pre>
510   static const u2 MAX_IDNUM;
511   static const u2 UNSET_IDNUM;
512   u2 method_idnum() const                        { return _method_idnum; }
513   void set_method_idnum(u2 idnum)                { _method_idnum = idnum; }
514 
515   u2 orig_method_idnum() const                   { return _orig_method_idnum; }
516   void set_orig_method_idnum(u2 idnum)           { _orig_method_idnum = idnum; }
517 
518   // max stack
519   int  max_stack() const                         { return _max_stack; }
520   void set_max_stack(int size)                   { _max_stack = size; }
521 
522   // max locals
523   int  max_locals() const                        { return _max_locals; }
524   void set_max_locals(int size)                  { _max_locals = size; }
525 
526   // size of parameters
527   int  size_of_parameters() const                { return _size_of_parameters; }
528   void set_size_of_parameters(int size)          { _size_of_parameters = size; }
529 
<span class="line-added">530   // result type (basic type of return value)</span>
<span class="line-added">531   BasicType result_type() const                  { assert(_result_type &gt;= T_BOOLEAN, &quot;Must be set&quot;);</span>
<span class="line-added">532                                                    return (BasicType)_result_type; }</span>
<span class="line-added">533 </span>
534   void set_result_type(BasicType rt)             { assert(rt &lt; 16, &quot;result type too large&quot;);
535                                                    _result_type = (u1)rt; }
536   // Deallocation for RedefineClasses
537   void deallocate_contents(ClassLoaderData* loader_data);
538   bool is_klass() const { return false; }
539   DEBUG_ONLY(bool on_stack() { return false; })
540 
541   void metaspace_pointers_do(MetaspaceClosure* it);
542   MetaspaceObj::Type type() const { return ConstMethodType; }
543 private:
544   // Since the size of the compressed line number table is unknown, the
545   // offsets of the other variable sized sections are computed backwards
546   // from the end of the ConstMethod*.
547 
548   // First byte after ConstMethod*
549   address constMethod_end() const
550                           { return (address)((intptr_t*)this + _constMethod_size); }
551 
552   // Last short in ConstMethod*
553   u2* last_u2_element() const;
</pre>
</td>
</tr>
</table>
<center><a href="constMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
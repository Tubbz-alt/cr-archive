diff a/src/hotspot/share/oops/constMethod.hpp b/src/hotspot/share/oops/constMethod.hpp
--- a/src/hotspot/share/oops/constMethod.hpp
+++ b/src/hotspot/share/oops/constMethod.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,10 +24,11 @@
 
 #ifndef SHARE_OOPS_CONSTMETHOD_HPP
 #define SHARE_OOPS_CONSTMETHOD_HPP
 
 #include "oops/oop.hpp"
+#include "runtime/arguments.hpp"
 #include "utilities/align.hpp"
 
 // An ConstMethod represents portions of a Java method which are not written to after
 // the classfile is parsed(*see below).  This part of the method can be shared across
 // processes in a read-only section with Class Data Sharing (CDS).  It's important
@@ -119,11 +120,10 @@
  public:
   u2 name_cp_index;
   u2 flags;
 };
 
-class KlassSizeStats;
 class AdapterHandlerEntry;
 
 // Class to collect the sizes of ConstMethod inline tables
 #define INLINE_TABLES_DO(do_element)            \
   do_element(localvariable_table_length)        \
@@ -286,16 +286,20 @@
   void copy_stackmap_data(ClassLoaderData* loader_data, u1* sd, int length, TRAPS);
   bool has_stackmap_table() const { return _stackmap_data != NULL; }
 
   // adapter
   void set_adapter_entry(AdapterHandlerEntry* adapter) {
-    assert(!is_shared(), "shared methods have fixed adapter_trampoline");
+    assert(!is_shared(),
+           "shared methods in archive have fixed adapter_trampoline");
     _adapter = adapter;
   }
   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
-    assert(DumpSharedSpaces, "must be");
-    assert(*trampoline == NULL, "must be NULL during dump time, to be initialized at run time");
+    Arguments::assert_is_dumping_archive();
+    if (DumpSharedSpaces) {
+      assert(*trampoline == NULL,
+             "must be NULL during dump time, to be initialized at run time");
+    }
     _adapter_trampoline = trampoline;
   }
   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
     assert(is_shared(), "must be");
     *_adapter_trampoline = adapter;
@@ -372,14 +376,10 @@
   void set_constMethod_size(int size)     { _constMethod_size = size; }
 
   // ConstMethods should be stored in the read-only region of CDS archive.
   static bool is_read_only_by_default() { return true; }
 
-#if INCLUDE_SERVICES
-  void collect_statistics(KlassSizeStats *sz) const;
-#endif
-
   // code size
   int code_size() const                          { return _code_size; }
   void set_code_size(int size) {
     assert(max_method_code_size < (1 << 16),
            "u2 is too small to hold method code size in general");
@@ -525,10 +525,14 @@
 
   // size of parameters
   int  size_of_parameters() const                { return _size_of_parameters; }
   void set_size_of_parameters(int size)          { _size_of_parameters = size; }
 
+  // result type (basic type of return value)
+  BasicType result_type() const                  { assert(_result_type >= T_BOOLEAN, "Must be set");
+                                                   return (BasicType)_result_type; }
+
   void set_result_type(BasicType rt)             { assert(rt < 16, "result type too large");
                                                    _result_type = (u1)rt; }
   // Deallocation for RedefineClasses
   void deallocate_contents(ClassLoaderData* loader_data);
   bool is_klass() const { return false; }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
<a name="2" id="anc2"></a>
  29 #include &quot;oops/metadata.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;oops/oop.hpp&quot;
  32 #include &quot;runtime/atomic.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
<a name="3" id="anc3"></a>


  34 
  35 class BytecodeStream;
<a name="4" id="anc4"></a>
  36 
  37 // The MethodData object collects counts and other profile information
  38 // during zeroth-tier (interpretive) and first-tier execution.
  39 // The profile is used later by compilation heuristics.  Some heuristics
  40 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  41 // optimization often has a down-side, a corner case that it handles
  42 // poorly, but which is thought to be rare.  The profile provides
  43 // evidence of this rarity for a given method or even BCI.  It allows
  44 // the compiler to back out of the optimization at places where it
  45 // has historically been a poor choice.  Other heuristics try to use
  46 // specific information gathered about types observed at a given site.
  47 //
  48 // All data in the profile is approximate.  It is expected to be accurate
  49 // on the whole, but the system expects occasional inaccuraces, due to
  50 // counter overflow, multiprocessor races during data collection, space
  51 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  52 // optimization quality but will not affect correctness.  Also, each MDO
  53 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  54 // to assess the quality (&quot;maturity&quot;) of its data.
  55 //
  56 // Short (&lt;32-bit) counters are designed to overflow to a known &quot;saturated&quot;
  57 // state.  Also, certain recorded per-BCI events are given one-bit counters
  58 // which overflow to a saturated state which applied to all counters at
  59 // that BCI.  In other words, there is a small lattice which approximates
  60 // the ideal of an infinite-precision counter for each event at each BCI,
  61 // and the lattice quickly &quot;bottoms out&quot; in a state where all counters
  62 // are taken to be indefinitely large.
  63 //
  64 // The reader will find many data races in profile gathering code, starting
  65 // with invocation counter incrementation.  None of these races harm correct
  66 // execution of the compiled code.
  67 
  68 // forward decl
  69 class ProfileData;
  70 
  71 // DataLayout
  72 //
  73 // Overlay for generic profiling data.
  74 class DataLayout {
  75   friend class VMStructs;
  76   friend class JVMCIVMStructs;
  77 
  78 private:
  79   // Every data layout begins with a header.  This header
  80   // contains a tag, which is used to indicate the size/layout
  81   // of the data, 8 bits of flags, which can be used in any way,
  82   // 32 bits of trap history (none/one reason/many reasons),
  83   // and a bci, which is used to tie this piece of data to a
  84   // specific bci in the bytecodes.
  85   union {
  86     u8 _bits;
  87     struct {
  88       u1 _tag;
  89       u1 _flags;
  90       u2 _bci;
  91       u4 _traps;
  92     } _struct;
  93   } _header;
  94 
  95   // The data layout has an arbitrary number of cells, each sized
  96   // to accomodate a pointer or an integer.
  97   intptr_t _cells[1];
  98 
  99   // Some types of data layouts need a length field.
 100   static bool needs_array_len(u1 tag);
 101 
 102 public:
 103   enum {
 104     counter_increment = 1
 105   };
 106 
 107   enum {
 108     cell_size = sizeof(intptr_t)
 109   };
 110 
 111   // Tag values
 112   enum {
 113     no_tag,
 114     bit_data_tag,
 115     counter_data_tag,
 116     jump_data_tag,
 117     receiver_type_data_tag,
 118     virtual_call_data_tag,
 119     ret_data_tag,
 120     branch_data_tag,
 121     multi_branch_data_tag,
 122     arg_info_data_tag,
 123     call_type_data_tag,
 124     virtual_call_type_data_tag,
 125     parameters_type_data_tag,
 126     speculative_trap_data_tag
 127   };
 128 
 129   enum {
 130     // The trap state breaks down as [recompile:1 | reason:31].
 131     // This further breakdown is defined in deoptimization.cpp.
 132     // See Deoptimization::trap_state_reason for an assert that
 133     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 134     //
 135     // The trap_state is collected only if ProfileTraps is true.
 136     trap_bits = 1+31,  // 31: enough to distinguish [0..Reason_RECORDED_LIMIT].
 137     trap_mask = -1,
 138     first_flag = 0
 139   };
 140 
 141   // Size computation
 142   static int header_size_in_bytes() {
 143     return header_size_in_cells() * cell_size;
 144   }
 145   static int header_size_in_cells() {
 146     return LP64_ONLY(1) NOT_LP64(2);
 147   }
 148 
 149   static int compute_size_in_bytes(int cell_count) {
 150     return header_size_in_bytes() + cell_count * cell_size;
 151   }
 152 
 153   // Initialization
 154   void initialize(u1 tag, u2 bci, int cell_count);
 155 
 156   // Accessors
 157   u1 tag() {
 158     return _header._struct._tag;
 159   }
 160 
 161   // Return 32 bits of trap state.
 162   // The state tells if traps with zero, one, or many reasons have occurred.
 163   // It also tells whether zero or many recompilations have occurred.
 164   // The associated trap histogram in the MDO itself tells whether
 165   // traps are common or not.  If a BCI shows that a trap X has
 166   // occurred, and the MDO shows N occurrences of X, we make the
 167   // simplifying assumption that all N occurrences can be blamed
 168   // on that BCI.
 169   uint trap_state() const {
 170     return _header._struct._traps;
 171   }
 172 
 173   void set_trap_state(uint new_state) {
 174     assert(ProfileTraps, &quot;used only under +ProfileTraps&quot;);
 175     uint old_flags = _header._struct._traps;
 176     _header._struct._traps = new_state | old_flags;
 177   }
 178 
 179   u1 flags() const {
 180     return _header._struct._flags;
 181   }
 182 
 183   u2 bci() const {
 184     return _header._struct._bci;
 185   }
 186 
 187   void set_header(u8 value) {
 188     _header._bits = value;
 189   }
 190   u8 header() {
 191     return _header._bits;
 192   }
 193   void set_cell_at(int index, intptr_t value) {
 194     _cells[index] = value;
 195   }
 196   void release_set_cell_at(int index, intptr_t value);
 197   intptr_t cell_at(int index) const {
 198     return _cells[index];
 199   }
 200 
 201   void set_flag_at(u1 flag_number) {
 202     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 203   }
 204   bool flag_at(u1 flag_number) const {
 205     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 206   }
 207 
 208   // Low-level support for code generation.
 209   static ByteSize header_offset() {
 210     return byte_offset_of(DataLayout, _header);
 211   }
 212   static ByteSize tag_offset() {
 213     return byte_offset_of(DataLayout, _header._struct._tag);
 214   }
 215   static ByteSize flags_offset() {
 216     return byte_offset_of(DataLayout, _header._struct._flags);
 217   }
 218   static ByteSize bci_offset() {
 219     return byte_offset_of(DataLayout, _header._struct._bci);
 220   }
 221   static ByteSize cell_offset(int index) {
 222     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 223   }
 224   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 225   static u1 flag_number_to_constant(u1 flag_number) {
 226     DataLayout temp; temp.set_header(0);
 227     temp.set_flag_at(flag_number);
 228     return temp._header._struct._flags;
 229   }
 230   // Return a value which, when or-ed as a word into _header, sets the flag.
 231   static u8 flag_mask_to_header_mask(uint byte_constant) {
 232     DataLayout temp; temp.set_header(0);
 233     temp._header._struct._flags = byte_constant;
 234     return temp._header._bits;
 235   }
 236 
 237   ProfileData* data_in();
 238 
 239   // GC support
 240   void clean_weak_klass_links(bool always_clean);
 241 
 242   // Redefinition support
 243   void clean_weak_method_links();
 244   DEBUG_ONLY(void verify_clean_weak_method_links();)
 245 };
 246 
 247 
 248 // ProfileData class hierarchy
 249 class ProfileData;
 250 class   BitData;
 251 class     CounterData;
 252 class       ReceiverTypeData;
 253 class         VirtualCallData;
 254 class           VirtualCallTypeData;
 255 class       RetData;
 256 class       CallTypeData;
 257 class   JumpData;
 258 class     BranchData;
 259 class   ArrayData;
 260 class     MultiBranchData;
 261 class     ArgInfoData;
 262 class     ParametersTypeData;
 263 class   SpeculativeTrapData;
 264 
 265 // ProfileData
 266 //
 267 // A ProfileData object is created to refer to a section of profiling
 268 // data in a structured way.
 269 class ProfileData : public ResourceObj {
 270   friend class TypeEntries;
 271   friend class ReturnTypeEntry;
 272   friend class TypeStackSlotEntries;
 273 private:
 274   enum {
 275     tab_width_one = 16,
 276     tab_width_two = 36
 277   };
 278 
 279   // This is a pointer to a section of profiling data.
 280   DataLayout* _data;
 281 
 282   char* print_data_on_helper(const MethodData* md) const;
 283 
 284 protected:
 285   DataLayout* data() { return _data; }
 286   const DataLayout* data() const { return _data; }
 287 
 288   enum {
 289     cell_size = DataLayout::cell_size
 290   };
 291 
 292 public:
 293   // How many cells are in this?
 294   virtual int cell_count() const {
 295     ShouldNotReachHere();
 296     return -1;
 297   }
 298 
 299   // Return the size of this data.
 300   int size_in_bytes() {
 301     return DataLayout::compute_size_in_bytes(cell_count());
 302   }
 303 
 304 protected:
 305   // Low-level accessors for underlying data
 306   void set_intptr_at(int index, intptr_t value) {
 307     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 308     data()-&gt;set_cell_at(index, value);
 309   }
 310   void release_set_intptr_at(int index, intptr_t value);
 311   intptr_t intptr_at(int index) const {
 312     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 313     return data()-&gt;cell_at(index);
 314   }
 315   void set_uint_at(int index, uint value) {
 316     set_intptr_at(index, (intptr_t) value);
 317   }
 318   void release_set_uint_at(int index, uint value);
 319   uint uint_at(int index) const {
 320     return (uint)intptr_at(index);
 321   }
 322   void set_int_at(int index, int value) {
 323     set_intptr_at(index, (intptr_t) value);
 324   }
 325   void release_set_int_at(int index, int value);
 326   int int_at(int index) const {
 327     return (int)intptr_at(index);
 328   }
 329   int int_at_unchecked(int index) const {
 330     return (int)data()-&gt;cell_at(index);
 331   }
 332   void set_oop_at(int index, oop value) {
 333     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 334   }
 335   oop oop_at(int index) const {
 336     return cast_to_oop(intptr_at(index));
 337   }
 338 
 339   void set_flag_at(int flag_number) {
 340     data()-&gt;set_flag_at(flag_number);
 341   }
 342   bool flag_at(int flag_number) const {
 343     return data()-&gt;flag_at(flag_number);
 344   }
 345 
 346   // two convenient imports for use by subclasses:
 347   static ByteSize cell_offset(int index) {
 348     return DataLayout::cell_offset(index);
 349   }
 350   static int flag_number_to_constant(int flag_number) {
 351     return DataLayout::flag_number_to_constant(flag_number);
 352   }
 353 
 354   ProfileData(DataLayout* data) {
 355     _data = data;
 356   }
 357 
 358 public:
 359   // Constructor for invalid ProfileData.
 360   ProfileData();
 361 
 362   u2 bci() const {
 363     return data()-&gt;bci();
 364   }
 365 
 366   address dp() {
 367     return (address)_data;
 368   }
 369 
 370   int trap_state() const {
 371     return data()-&gt;trap_state();
 372   }
 373   void set_trap_state(int new_state) {
 374     data()-&gt;set_trap_state(new_state);
 375   }
 376 
 377   // Type checking
 378   virtual bool is_BitData()         const { return false; }
 379   virtual bool is_CounterData()     const { return false; }
 380   virtual bool is_JumpData()        const { return false; }
 381   virtual bool is_ReceiverTypeData()const { return false; }
 382   virtual bool is_VirtualCallData() const { return false; }
 383   virtual bool is_RetData()         const { return false; }
 384   virtual bool is_BranchData()      const { return false; }
 385   virtual bool is_ArrayData()       const { return false; }
 386   virtual bool is_MultiBranchData() const { return false; }
 387   virtual bool is_ArgInfoData()     const { return false; }
 388   virtual bool is_CallTypeData()    const { return false; }
 389   virtual bool is_VirtualCallTypeData()const { return false; }
 390   virtual bool is_ParametersTypeData() const { return false; }
 391   virtual bool is_SpeculativeTrapData()const { return false; }
 392 
 393 
 394   BitData* as_BitData() const {
 395     assert(is_BitData(), &quot;wrong type&quot;);
 396     return is_BitData()         ? (BitData*)        this : NULL;
 397   }
 398   CounterData* as_CounterData() const {
 399     assert(is_CounterData(), &quot;wrong type&quot;);
 400     return is_CounterData()     ? (CounterData*)    this : NULL;
 401   }
 402   JumpData* as_JumpData() const {
 403     assert(is_JumpData(), &quot;wrong type&quot;);
 404     return is_JumpData()        ? (JumpData*)       this : NULL;
 405   }
 406   ReceiverTypeData* as_ReceiverTypeData() const {
 407     assert(is_ReceiverTypeData(), &quot;wrong type&quot;);
 408     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 409   }
 410   VirtualCallData* as_VirtualCallData() const {
 411     assert(is_VirtualCallData(), &quot;wrong type&quot;);
 412     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 413   }
 414   RetData* as_RetData() const {
 415     assert(is_RetData(), &quot;wrong type&quot;);
 416     return is_RetData()         ? (RetData*)        this : NULL;
 417   }
 418   BranchData* as_BranchData() const {
 419     assert(is_BranchData(), &quot;wrong type&quot;);
 420     return is_BranchData()      ? (BranchData*)     this : NULL;
 421   }
 422   ArrayData* as_ArrayData() const {
 423     assert(is_ArrayData(), &quot;wrong type&quot;);
 424     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 425   }
 426   MultiBranchData* as_MultiBranchData() const {
 427     assert(is_MultiBranchData(), &quot;wrong type&quot;);
 428     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 429   }
 430   ArgInfoData* as_ArgInfoData() const {
 431     assert(is_ArgInfoData(), &quot;wrong type&quot;);
 432     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 433   }
 434   CallTypeData* as_CallTypeData() const {
 435     assert(is_CallTypeData(), &quot;wrong type&quot;);
 436     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 437   }
 438   VirtualCallTypeData* as_VirtualCallTypeData() const {
 439     assert(is_VirtualCallTypeData(), &quot;wrong type&quot;);
 440     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 441   }
 442   ParametersTypeData* as_ParametersTypeData() const {
 443     assert(is_ParametersTypeData(), &quot;wrong type&quot;);
 444     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 445   }
 446   SpeculativeTrapData* as_SpeculativeTrapData() const {
 447     assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
 448     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 449   }
 450 
 451 
 452   // Subclass specific initialization
 453   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 454 
 455   // GC support
 456   virtual void clean_weak_klass_links(bool always_clean) {}
 457 
 458   // Redefinition support
 459   virtual void clean_weak_method_links() {}
 460   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 461 
 462   // CI translation: ProfileData can represent both MethodDataOop data
 463   // as well as CIMethodData data. This function is provided for translating
 464   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 465   // most ProfileData don&#39;t require any translation, so we provide the null
 466   // translation here, and the required translators are in the ci subclasses.
 467   virtual void translate_from(const ProfileData* data) {}
 468 
 469   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 470     ShouldNotReachHere();
 471   }
 472 
 473   void print_data_on(outputStream* st, const MethodData* md) const;
 474 
 475   void print_shared(outputStream* st, const char* name, const char* extra) const;
 476   void tab(outputStream* st, bool first = false) const;
 477 };
 478 
 479 // BitData
 480 //
 481 // A BitData holds a flag or two in its header.
 482 class BitData : public ProfileData {
 483   friend class VMStructs;
 484   friend class JVMCIVMStructs;
 485 protected:
 486   enum {
 487     // null_seen:
 488     //  saw a null operand (cast/aastore/instanceof)
 489       null_seen_flag              = DataLayout::first_flag + 0
 490 #if INCLUDE_JVMCI
 491     // bytecode threw any exception
 492     , exception_seen_flag         = null_seen_flag + 1
 493 #endif
 494   };
 495   enum { bit_cell_count = 0 };  // no additional data fields needed.
 496 public:
 497   BitData(DataLayout* layout) : ProfileData(layout) {
 498   }
 499 
 500   virtual bool is_BitData() const { return true; }
 501 
 502   static int static_cell_count() {
 503     return bit_cell_count;
 504   }
 505 
 506   virtual int cell_count() const {
 507     return static_cell_count();
 508   }
 509 
 510   // Accessor
 511 
 512   // The null_seen flag bit is specially known to the interpreter.
 513   // Consulting it allows the compiler to avoid setting up null_check traps.
 514   bool null_seen()     { return flag_at(null_seen_flag); }
 515   void set_null_seen()    { set_flag_at(null_seen_flag); }
 516 
 517 #if INCLUDE_JVMCI
 518   // true if an exception was thrown at the specific BCI
 519   bool exception_seen() { return flag_at(exception_seen_flag); }
 520   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 521 #endif
 522 
 523   // Code generation support
 524   static int null_seen_byte_constant() {
 525     return flag_number_to_constant(null_seen_flag);
 526   }
 527 
 528   static ByteSize bit_data_size() {
 529     return cell_offset(bit_cell_count);
 530   }
 531 
 532   void print_data_on(outputStream* st, const char* extra = NULL) const;
 533 };
 534 
 535 // CounterData
 536 //
 537 // A CounterData corresponds to a simple counter.
 538 class CounterData : public BitData {
 539   friend class VMStructs;
 540   friend class JVMCIVMStructs;
 541 protected:
 542   enum {
 543     count_off,
 544     counter_cell_count
 545   };
 546 public:
 547   CounterData(DataLayout* layout) : BitData(layout) {}
 548 
 549   virtual bool is_CounterData() const { return true; }
 550 
 551   static int static_cell_count() {
 552     return counter_cell_count;
 553   }
 554 
 555   virtual int cell_count() const {
 556     return static_cell_count();
 557   }
 558 
 559   // Direct accessor
<a name="5" id="anc5"></a><span class="line-modified"> 560   int count() const {</span>
<span class="line-modified"> 561     intptr_t raw_data = intptr_at(count_off);</span>
<span class="line-added"> 562     if (raw_data &gt; max_jint) {</span>
<span class="line-added"> 563       raw_data = max_jint;</span>
<span class="line-added"> 564     } else if (raw_data &lt; min_jint) {</span>
<span class="line-added"> 565       raw_data = min_jint;</span>
<span class="line-added"> 566     }</span>
<span class="line-added"> 567     return int(raw_data);</span>
 568   }
 569 
 570   // Code generation support
 571   static ByteSize count_offset() {
 572     return cell_offset(count_off);
 573   }
 574   static ByteSize counter_data_size() {
 575     return cell_offset(counter_cell_count);
 576   }
 577 
<a name="6" id="anc6"></a><span class="line-modified"> 578   void set_count(int count) {</span>
<span class="line-modified"> 579     set_int_at(count_off, count);</span>
 580   }
 581 
 582   void print_data_on(outputStream* st, const char* extra = NULL) const;
 583 };
 584 
 585 // JumpData
 586 //
 587 // A JumpData is used to access profiling information for a direct
 588 // branch.  It is a counter, used for counting the number of branches,
 589 // plus a data displacement, used for realigning the data pointer to
 590 // the corresponding target bci.
 591 class JumpData : public ProfileData {
 592   friend class VMStructs;
 593   friend class JVMCIVMStructs;
 594 protected:
 595   enum {
 596     taken_off_set,
 597     displacement_off_set,
 598     jump_cell_count
 599   };
 600 
 601   void set_displacement(int displacement) {
 602     set_int_at(displacement_off_set, displacement);
 603   }
 604 
 605 public:
 606   JumpData(DataLayout* layout) : ProfileData(layout) {
 607     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 608       layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
 609   }
 610 
 611   virtual bool is_JumpData() const { return true; }
 612 
 613   static int static_cell_count() {
 614     return jump_cell_count;
 615   }
 616 
 617   virtual int cell_count() const {
 618     return static_cell_count();
 619   }
 620 
 621   // Direct accessor
 622   uint taken() const {
 623     return uint_at(taken_off_set);
 624   }
 625 
 626   void set_taken(uint cnt) {
 627     set_uint_at(taken_off_set, cnt);
 628   }
 629 
 630   // Saturating counter
 631   uint inc_taken() {
 632     uint cnt = taken() + 1;
 633     // Did we wrap? Will compiler screw us??
 634     if (cnt == 0) cnt--;
 635     set_uint_at(taken_off_set, cnt);
 636     return cnt;
 637   }
 638 
 639   int displacement() const {
 640     return int_at(displacement_off_set);
 641   }
 642 
 643   // Code generation support
 644   static ByteSize taken_offset() {
 645     return cell_offset(taken_off_set);
 646   }
 647 
 648   static ByteSize displacement_offset() {
 649     return cell_offset(displacement_off_set);
 650   }
 651 
 652   // Specific initialization.
 653   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 654 
 655   void print_data_on(outputStream* st, const char* extra = NULL) const;
 656 };
 657 
 658 // Entries in a ProfileData object to record types: it can either be
 659 // none (no profile), unknown (conflicting profile data) or a klass if
 660 // a single one is seen. Whether a null reference was seen is also
 661 // recorded. No counter is associated with the type and a single type
 662 // is tracked (unlike VirtualCallData).
 663 class TypeEntries {
 664 
 665 public:
 666 
 667   // A single cell is used to record information for a type:
 668   // - the cell is initialized to 0
 669   // - when a type is discovered it is stored in the cell
 670   // - bit zero of the cell is used to record whether a null reference
 671   // was encountered or not
 672   // - bit 1 is set to record a conflict in the type information
 673 
 674   enum {
 675     null_seen = 1,
 676     type_mask = ~null_seen,
 677     type_unknown = 2,
 678     status_bits = null_seen | type_unknown,
 679     type_klass_mask = ~status_bits
 680   };
 681 
 682   // what to initialize a cell to
 683   static intptr_t type_none() {
 684     return 0;
 685   }
 686 
 687   // null seen = bit 0 set?
 688   static bool was_null_seen(intptr_t v) {
 689     return (v &amp; null_seen) != 0;
 690   }
 691 
 692   // conflicting type information = bit 1 set?
 693   static bool is_type_unknown(intptr_t v) {
 694     return (v &amp; type_unknown) != 0;
 695   }
 696 
 697   // not type information yet = all bits cleared, ignoring bit 0?
 698   static bool is_type_none(intptr_t v) {
 699     return (v &amp; type_mask) == 0;
 700   }
 701 
 702   // recorded type: cell without bit 0 and 1
 703   static intptr_t klass_part(intptr_t v) {
 704     intptr_t r = v &amp; type_klass_mask;
 705     return r;
 706   }
 707 
 708   // type recorded
 709   static Klass* valid_klass(intptr_t k) {
 710     if (!is_type_none(k) &amp;&amp;
 711         !is_type_unknown(k)) {
 712       Klass* res = (Klass*)klass_part(k);
 713       assert(res != NULL, &quot;invalid&quot;);
 714       return res;
 715     } else {
 716       return NULL;
 717     }
 718   }
 719 
 720   static intptr_t with_status(intptr_t k, intptr_t in) {
 721     return k | (in &amp; status_bits);
 722   }
 723 
 724   static intptr_t with_status(Klass* k, intptr_t in) {
 725     return with_status((intptr_t)k, in);
 726   }
 727 
 728   static void print_klass(outputStream* st, intptr_t k);
 729 
 730 protected:
 731   // ProfileData object these entries are part of
 732   ProfileData* _pd;
 733   // offset within the ProfileData object where the entries start
 734   const int _base_off;
 735 
 736   TypeEntries(int base_off)
 737     : _pd(NULL), _base_off(base_off) {}
 738 
 739   void set_intptr_at(int index, intptr_t value) {
 740     _pd-&gt;set_intptr_at(index, value);
 741   }
 742 
 743   intptr_t intptr_at(int index) const {
 744     return _pd-&gt;intptr_at(index);
 745   }
 746 
 747 public:
 748   void set_profile_data(ProfileData* pd) {
 749     _pd = pd;
 750   }
 751 };
 752 
 753 // Type entries used for arguments passed at a call and parameters on
 754 // method entry. 2 cells per entry: one for the type encoded as in
 755 // TypeEntries and one initialized with the stack slot where the
 756 // profiled object is to be found so that the interpreter can locate
 757 // it quickly.
 758 class TypeStackSlotEntries : public TypeEntries {
 759 
 760 private:
 761   enum {
 762     stack_slot_entry,
 763     type_entry,
 764     per_arg_cell_count
 765   };
 766 
 767   // offset of cell for stack slot for entry i within ProfileData object
 768   int stack_slot_offset(int i) const {
 769     return _base_off + stack_slot_local_offset(i);
 770   }
 771 
 772   const int _number_of_entries;
 773 
 774   // offset of cell for type for entry i within ProfileData object
 775   int type_offset_in_cells(int i) const {
 776     return _base_off + type_local_offset(i);
 777   }
 778 
 779 public:
 780 
 781   TypeStackSlotEntries(int base_off, int nb_entries)
 782     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 783 
 784   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 785 
 786   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 787 
 788   int number_of_entries() const { return _number_of_entries; }
 789 
 790   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 791   static int stack_slot_local_offset(int i) {
 792     return i * per_arg_cell_count + stack_slot_entry;
 793   }
 794 
 795   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 796   static int type_local_offset(int i) {
 797     return i * per_arg_cell_count + type_entry;
 798   }
 799 
 800   // stack slot for entry i
 801   uint stack_slot(int i) const {
 802     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 803     return _pd-&gt;uint_at(stack_slot_offset(i));
 804   }
 805 
 806   // set stack slot for entry i
 807   void set_stack_slot(int i, uint num) {
 808     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 809     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 810   }
 811 
 812   // type for entry i
 813   intptr_t type(int i) const {
 814     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 815     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 816   }
 817 
 818   // set type for entry i
 819   void set_type(int i, intptr_t k) {
 820     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 821     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 822   }
 823 
 824   static ByteSize per_arg_size() {
 825     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 826   }
 827 
 828   static int per_arg_count() {
 829     return per_arg_cell_count;
 830   }
 831 
 832   ByteSize type_offset(int i) const {
 833     return DataLayout::cell_offset(type_offset_in_cells(i));
 834   }
 835 
 836   // GC support
 837   void clean_weak_klass_links(bool always_clean);
 838 
 839   void print_data_on(outputStream* st) const;
 840 };
 841 
 842 // Type entry used for return from a call. A single cell to record the
 843 // type.
 844 class ReturnTypeEntry : public TypeEntries {
 845 
 846 private:
 847   enum {
 848     cell_count = 1
 849   };
 850 
 851 public:
 852   ReturnTypeEntry(int base_off)
 853     : TypeEntries(base_off) {}
 854 
 855   void post_initialize() {
 856     set_type(type_none());
 857   }
 858 
 859   intptr_t type() const {
 860     return _pd-&gt;intptr_at(_base_off);
 861   }
 862 
 863   void set_type(intptr_t k) {
 864     _pd-&gt;set_intptr_at(_base_off, k);
 865   }
 866 
 867   static int static_cell_count() {
 868     return cell_count;
 869   }
 870 
 871   static ByteSize size() {
 872     return in_ByteSize(cell_count * DataLayout::cell_size);
 873   }
 874 
 875   ByteSize type_offset() {
 876     return DataLayout::cell_offset(_base_off);
 877   }
 878 
 879   // GC support
 880   void clean_weak_klass_links(bool always_clean);
 881 
 882   void print_data_on(outputStream* st) const;
 883 };
 884 
 885 // Entries to collect type information at a call: contains arguments
 886 // (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a
 887 // number of cells. Because the number of cells for the return type is
 888 // smaller than the number of cells for the type of an arguments, the
 889 // number of cells is used to tell how many arguments are profiled and
 890 // whether a return value is profiled. See has_arguments() and
 891 // has_return().
 892 class TypeEntriesAtCall {
 893 private:
 894   static int stack_slot_local_offset(int i) {
 895     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 896   }
 897 
 898   static int argument_type_local_offset(int i) {
 899     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
 900   }
 901 
 902 public:
 903 
 904   static int header_cell_count() {
 905     return 1;
 906   }
 907 
 908   static int cell_count_local_offset() {
 909     return 0;
 910   }
 911 
 912   static int compute_cell_count(BytecodeStream* stream);
 913 
 914   static void initialize(DataLayout* dl, int base, int cell_count) {
 915     int off = base + cell_count_local_offset();
 916     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
 917   }
 918 
 919   static bool arguments_profiling_enabled();
 920   static bool return_profiling_enabled();
 921 
 922   // Code generation support
 923   static ByteSize cell_count_offset() {
 924     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
 925   }
 926 
 927   static ByteSize args_data_offset() {
 928     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
 929   }
 930 
 931   static ByteSize stack_slot_offset(int i) {
 932     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
 933   }
 934 
 935   static ByteSize argument_type_offset(int i) {
 936     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
 937   }
 938 
 939   static ByteSize return_only_size() {
 940     return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
 941   }
 942 
 943 };
 944 
 945 // CallTypeData
 946 //
 947 // A CallTypeData is used to access profiling information about a non
 948 // virtual call for which we collect type information about arguments
 949 // and return value.
 950 class CallTypeData : public CounterData {
 951 private:
 952   // entries for arguments if any
 953   TypeStackSlotEntries _args;
 954   // entry for return type if any
 955   ReturnTypeEntry _ret;
 956 
 957   int cell_count_global_offset() const {
 958     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
 959   }
 960 
 961   // number of cells not counting the header
 962   int cell_count_no_header() const {
 963     return uint_at(cell_count_global_offset());
 964   }
 965 
 966   void check_number_of_arguments(int total) {
 967     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
 968   }
 969 
 970 public:
 971   CallTypeData(DataLayout* layout) :
 972     CounterData(layout),
 973     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
 974     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
 975   {
 976     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
 977     // Some compilers (VC++) don&#39;t want this passed in member initialization list
 978     _args.set_profile_data(this);
 979     _ret.set_profile_data(this);
 980   }
 981 
 982   const TypeStackSlotEntries* args() const {
 983     assert(has_arguments(), &quot;no profiling of arguments&quot;);
 984     return &amp;_args;
 985   }
 986 
 987   const ReturnTypeEntry* ret() const {
 988     assert(has_return(), &quot;no profiling of return value&quot;);
 989     return &amp;_ret;
 990   }
 991 
 992   virtual bool is_CallTypeData() const { return true; }
 993 
 994   static int static_cell_count() {
 995     return -1;
 996   }
 997 
 998   static int compute_cell_count(BytecodeStream* stream) {
 999     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1000   }
1001 
1002   static void initialize(DataLayout* dl, int cell_count) {
1003     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1004   }
1005 
1006   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1007 
1008   virtual int cell_count() const {
1009     return CounterData::static_cell_count() +
1010       TypeEntriesAtCall::header_cell_count() +
1011       int_at_unchecked(cell_count_global_offset());
1012   }
1013 
1014   int number_of_arguments() const {
1015     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1016   }
1017 
1018   void set_argument_type(int i, Klass* k) {
1019     assert(has_arguments(), &quot;no arguments!&quot;);
1020     intptr_t current = _args.type(i);
1021     _args.set_type(i, TypeEntries::with_status(k, current));
1022   }
1023 
1024   void set_return_type(Klass* k) {
1025     assert(has_return(), &quot;no return!&quot;);
1026     intptr_t current = _ret.type();
1027     _ret.set_type(TypeEntries::with_status(k, current));
1028   }
1029 
1030   // An entry for a return value takes less space than an entry for an
1031   // argument so if the number of cells exceeds the number of cells
1032   // needed for an argument, this object contains type information for
1033   // at least one argument.
1034   bool has_arguments() const {
1035     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1036     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1037     return res;
1038   }
1039 
1040   // An entry for a return value takes less space than an entry for an
1041   // argument, so if the remainder of the number of cells divided by
1042   // the number of cells for an argument is not null, a return value
1043   // is profiled in this object.
1044   bool has_return() const {
1045     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1046     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1047     return res;
1048   }
1049 
1050   // Code generation support
1051   static ByteSize args_data_offset() {
1052     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1053   }
1054 
1055   ByteSize argument_type_offset(int i) {
1056     return _args.type_offset(i);
1057   }
1058 
1059   ByteSize return_type_offset() {
1060     return _ret.type_offset();
1061   }
1062 
1063   // GC support
1064   virtual void clean_weak_klass_links(bool always_clean) {
1065     if (has_arguments()) {
1066       _args.clean_weak_klass_links(always_clean);
1067     }
1068     if (has_return()) {
1069       _ret.clean_weak_klass_links(always_clean);
1070     }
1071   }
1072 
1073   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1074 };
1075 
1076 // ReceiverTypeData
1077 //
1078 // A ReceiverTypeData is used to access profiling information about a
1079 // dynamic type check.  It consists of a counter which counts the total times
1080 // that the check is reached, and a series of (Klass*, count) pairs
1081 // which are used to store a type profile for the receiver of the check.
1082 class ReceiverTypeData : public CounterData {
1083   friend class VMStructs;
1084   friend class JVMCIVMStructs;
1085 protected:
1086   enum {
1087 #if INCLUDE_JVMCI
1088     // Description of the different counters
1089     // ReceiverTypeData for instanceof/checkcast/aastore:
1090     //   count is decremented for failed type checks
1091     //   JVMCI only: nonprofiled_count is incremented on type overflow
1092     // VirtualCallData for invokevirtual/invokeinterface:
1093     //   count is incremented on type overflow
1094     //   JVMCI only: nonprofiled_count is incremented on method overflow
1095 
1096     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1097     nonprofiled_count_off_set = counter_cell_count,
1098     receiver0_offset,
1099 #else
1100     receiver0_offset = counter_cell_count,
1101 #endif
1102     count0_offset,
1103     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1104   };
1105 
1106 public:
1107   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1108     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1109            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1110            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1111   }
1112 
1113   virtual bool is_ReceiverTypeData() const { return true; }
1114 
1115   static int static_cell_count() {
1116     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1117   }
1118 
1119   virtual int cell_count() const {
1120     return static_cell_count();
1121   }
1122 
1123   // Direct accessors
1124   static uint row_limit() {
1125     return TypeProfileWidth;
1126   }
1127   static int receiver_cell_index(uint row) {
1128     return receiver0_offset + row * receiver_type_row_cell_count;
1129   }
1130   static int receiver_count_cell_index(uint row) {
1131     return count0_offset + row * receiver_type_row_cell_count;
1132   }
1133 
1134   Klass* receiver(uint row) const {
1135     assert(row &lt; row_limit(), &quot;oob&quot;);
1136 
1137     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1138     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
1139     return recv;
1140   }
1141 
1142   void set_receiver(uint row, Klass* k) {
1143     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1144     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1145   }
1146 
1147   uint receiver_count(uint row) const {
1148     assert(row &lt; row_limit(), &quot;oob&quot;);
1149     return uint_at(receiver_count_cell_index(row));
1150   }
1151 
1152   void set_receiver_count(uint row, uint count) {
1153     assert(row &lt; row_limit(), &quot;oob&quot;);
1154     set_uint_at(receiver_count_cell_index(row), count);
1155   }
1156 
1157   void clear_row(uint row) {
1158     assert(row &lt; row_limit(), &quot;oob&quot;);
1159     // Clear total count - indicator of polymorphic call site.
1160     // The site may look like as monomorphic after that but
1161     // it allow to have more accurate profiling information because
1162     // there was execution phase change since klasses were unloaded.
1163     // If the site is still polymorphic then MDO will be updated
1164     // to reflect it. But it could be the case that the site becomes
1165     // only bimorphic. Then keeping total count not 0 will be wrong.
1166     // Even if we use monomorphic (when it is not) for compilation
1167     // we will only have trap, deoptimization and recompile again
1168     // with updated MDO after executing method in Interpreter.
1169     // An additional receiver will be recorded in the cleaned row
1170     // during next call execution.
1171     //
1172     // Note: our profiling logic works with empty rows in any slot.
1173     // We do sorting a profiling info (ciCallProfile) for compilation.
1174     //
1175     set_count(0);
1176     set_receiver(row, NULL);
1177     set_receiver_count(row, 0);
1178 #if INCLUDE_JVMCI
1179     if (!this-&gt;is_VirtualCallData()) {
1180       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1181       // must also be reset (see &quot;Description of the different counters&quot; above)
1182       set_nonprofiled_count(0);
1183     }
1184 #endif
1185   }
1186 
1187   // Code generation support
1188   static ByteSize receiver_offset(uint row) {
1189     return cell_offset(receiver_cell_index(row));
1190   }
1191   static ByteSize receiver_count_offset(uint row) {
1192     return cell_offset(receiver_count_cell_index(row));
1193   }
1194 #if INCLUDE_JVMCI
1195   static ByteSize nonprofiled_receiver_count_offset() {
1196     return cell_offset(nonprofiled_count_off_set);
1197   }
1198   uint nonprofiled_count() const {
1199     return uint_at(nonprofiled_count_off_set);
1200   }
1201   void set_nonprofiled_count(uint count) {
1202     set_uint_at(nonprofiled_count_off_set, count);
1203   }
1204 #endif // INCLUDE_JVMCI
1205   static ByteSize receiver_type_data_size() {
1206     return cell_offset(static_cell_count());
1207   }
1208 
1209   // GC support
1210   virtual void clean_weak_klass_links(bool always_clean);
1211 
1212   void print_receiver_data_on(outputStream* st) const;
1213   void print_data_on(outputStream* st, const char* extra = NULL) const;
1214 };
1215 
1216 // VirtualCallData
1217 //
1218 // A VirtualCallData is used to access profiling information about a
1219 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1220 class VirtualCallData : public ReceiverTypeData {
1221 public:
1222   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1223     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1224            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1225   }
1226 
1227   virtual bool is_VirtualCallData() const { return true; }
1228 
1229   static int static_cell_count() {
1230     // At this point we could add more profile state, e.g., for arguments.
1231     // But for now it&#39;s the same size as the base record type.
1232     return ReceiverTypeData::static_cell_count() JVMCI_ONLY(+ (uint) MethodProfileWidth * receiver_type_row_cell_count);
1233   }
1234 
1235   virtual int cell_count() const {
1236     return static_cell_count();
1237   }
1238 
1239   // Direct accessors
1240   static ByteSize virtual_call_data_size() {
1241     return cell_offset(static_cell_count());
1242   }
1243 
1244 #if INCLUDE_JVMCI
1245   static ByteSize method_offset(uint row) {
1246     return cell_offset(method_cell_index(row));
1247   }
1248   static ByteSize method_count_offset(uint row) {
1249     return cell_offset(method_count_cell_index(row));
1250   }
1251   static int method_cell_index(uint row) {
1252     return receiver0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1253   }
1254   static int method_count_cell_index(uint row) {
1255     return count0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;
1256   }
1257   static uint method_row_limit() {
1258     return MethodProfileWidth;
1259   }
1260 
1261   Method* method(uint row) const {
1262     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1263 
1264     Method* method = (Method*)intptr_at(method_cell_index(row));
1265     assert(method == NULL || method-&gt;is_method(), &quot;must be&quot;);
1266     return method;
1267   }
1268 
1269   uint method_count(uint row) const {
1270     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1271     return uint_at(method_count_cell_index(row));
1272   }
1273 
1274   void set_method(uint row, Method* m) {
1275     assert((uint)row &lt; method_row_limit(), &quot;oob&quot;);
1276     set_intptr_at(method_cell_index(row), (uintptr_t)m);
1277   }
1278 
1279   void set_method_count(uint row, uint count) {
1280     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1281     set_uint_at(method_count_cell_index(row), count);
1282   }
1283 
1284   void clear_method_row(uint row) {
1285     assert(row &lt; method_row_limit(), &quot;oob&quot;);
1286     // Clear total count - indicator of polymorphic call site (see comment for clear_row() in ReceiverTypeData).
1287     set_nonprofiled_count(0);
1288     set_method(row, NULL);
1289     set_method_count(row, 0);
1290   }
1291 
1292   // GC support
1293   virtual void clean_weak_klass_links(bool always_clean);
1294 
1295   // Redefinition support
1296   virtual void clean_weak_method_links();
1297 #endif // INCLUDE_JVMCI
1298 
1299   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1300   void print_data_on(outputStream* st, const char* extra = NULL) const;
1301 };
1302 
1303 // VirtualCallTypeData
1304 //
1305 // A VirtualCallTypeData is used to access profiling information about
1306 // a virtual call for which we collect type information about
1307 // arguments and return value.
1308 class VirtualCallTypeData : public VirtualCallData {
1309 private:
1310   // entries for arguments if any
1311   TypeStackSlotEntries _args;
1312   // entry for return type if any
1313   ReturnTypeEntry _ret;
1314 
1315   int cell_count_global_offset() const {
1316     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1317   }
1318 
1319   // number of cells not counting the header
1320   int cell_count_no_header() const {
1321     return uint_at(cell_count_global_offset());
1322   }
1323 
1324   void check_number_of_arguments(int total) {
1325     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
1326   }
1327 
1328 public:
1329   VirtualCallTypeData(DataLayout* layout) :
1330     VirtualCallData(layout),
1331     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1332     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
1333   {
1334     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1335     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1336     _args.set_profile_data(this);
1337     _ret.set_profile_data(this);
1338   }
1339 
1340   const TypeStackSlotEntries* args() const {
1341     assert(has_arguments(), &quot;no profiling of arguments&quot;);
1342     return &amp;_args;
1343   }
1344 
1345   const ReturnTypeEntry* ret() const {
1346     assert(has_return(), &quot;no profiling of return value&quot;);
1347     return &amp;_ret;
1348   }
1349 
1350   virtual bool is_VirtualCallTypeData() const { return true; }
1351 
1352   static int static_cell_count() {
1353     return -1;
1354   }
1355 
1356   static int compute_cell_count(BytecodeStream* stream) {
1357     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1358   }
1359 
1360   static void initialize(DataLayout* dl, int cell_count) {
1361     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1362   }
1363 
1364   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1365 
1366   virtual int cell_count() const {
1367     return VirtualCallData::static_cell_count() +
1368       TypeEntriesAtCall::header_cell_count() +
1369       int_at_unchecked(cell_count_global_offset());
1370   }
1371 
1372   int number_of_arguments() const {
1373     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1374   }
1375 
1376   void set_argument_type(int i, Klass* k) {
1377     assert(has_arguments(), &quot;no arguments!&quot;);
1378     intptr_t current = _args.type(i);
1379     _args.set_type(i, TypeEntries::with_status(k, current));
1380   }
1381 
1382   void set_return_type(Klass* k) {
1383     assert(has_return(), &quot;no return!&quot;);
1384     intptr_t current = _ret.type();
1385     _ret.set_type(TypeEntries::with_status(k, current));
1386   }
1387 
1388   // An entry for a return value takes less space than an entry for an
1389   // argument, so if the remainder of the number of cells divided by
1390   // the number of cells for an argument is not null, a return value
1391   // is profiled in this object.
1392   bool has_return() const {
1393     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1394     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1395     return res;
1396   }
1397 
1398   // An entry for a return value takes less space than an entry for an
1399   // argument so if the number of cells exceeds the number of cells
1400   // needed for an argument, this object contains type information for
1401   // at least one argument.
1402   bool has_arguments() const {
1403     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1404     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1405     return res;
1406   }
1407 
1408   // Code generation support
1409   static ByteSize args_data_offset() {
1410     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1411   }
1412 
1413   ByteSize argument_type_offset(int i) {
1414     return _args.type_offset(i);
1415   }
1416 
1417   ByteSize return_type_offset() {
1418     return _ret.type_offset();
1419   }
1420 
1421   // GC support
1422   virtual void clean_weak_klass_links(bool always_clean) {
1423     ReceiverTypeData::clean_weak_klass_links(always_clean);
1424     if (has_arguments()) {
1425       _args.clean_weak_klass_links(always_clean);
1426     }
1427     if (has_return()) {
1428       _ret.clean_weak_klass_links(always_clean);
1429     }
1430   }
1431 
1432   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1433 };
1434 
1435 // RetData
1436 //
1437 // A RetData is used to access profiling information for a ret bytecode.
1438 // It is composed of a count of the number of times that the ret has
1439 // been executed, followed by a series of triples of the form
1440 // (bci, count, di) which count the number of times that some bci was the
1441 // target of the ret and cache a corresponding data displacement.
1442 class RetData : public CounterData {
1443 protected:
1444   enum {
1445     bci0_offset = counter_cell_count,
1446     count0_offset,
1447     displacement0_offset,
1448     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1449   };
1450 
1451   void set_bci(uint row, int bci) {
1452     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1453     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1454   }
1455   void release_set_bci(uint row, int bci);
1456   void set_bci_count(uint row, uint count) {
1457     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1458     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1459   }
1460   void set_bci_displacement(uint row, int disp) {
1461     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1462   }
1463 
1464 public:
1465   RetData(DataLayout* layout) : CounterData(layout) {
1466     assert(layout-&gt;tag() == DataLayout::ret_data_tag, &quot;wrong type&quot;);
1467   }
1468 
1469   virtual bool is_RetData() const { return true; }
1470 
1471   enum {
1472     no_bci = -1 // value of bci when bci1/2 are not in use.
1473   };
1474 
1475   static int static_cell_count() {
1476     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1477   }
1478 
1479   virtual int cell_count() const {
1480     return static_cell_count();
1481   }
1482 
1483   static uint row_limit() {
1484     return BciProfileWidth;
1485   }
1486   static int bci_cell_index(uint row) {
1487     return bci0_offset + row * ret_row_cell_count;
1488   }
1489   static int bci_count_cell_index(uint row) {
1490     return count0_offset + row * ret_row_cell_count;
1491   }
1492   static int bci_displacement_cell_index(uint row) {
1493     return displacement0_offset + row * ret_row_cell_count;
1494   }
1495 
1496   // Direct accessors
1497   int bci(uint row) const {
1498     return int_at(bci_cell_index(row));
1499   }
1500   uint bci_count(uint row) const {
1501     return uint_at(bci_count_cell_index(row));
1502   }
1503   int bci_displacement(uint row) const {
1504     return int_at(bci_displacement_cell_index(row));
1505   }
1506 
1507   // Interpreter Runtime support
1508   address fixup_ret(int return_bci, MethodData* mdo);
1509 
1510   // Code generation support
1511   static ByteSize bci_offset(uint row) {
1512     return cell_offset(bci_cell_index(row));
1513   }
1514   static ByteSize bci_count_offset(uint row) {
1515     return cell_offset(bci_count_cell_index(row));
1516   }
1517   static ByteSize bci_displacement_offset(uint row) {
1518     return cell_offset(bci_displacement_cell_index(row));
1519   }
1520 
1521   // Specific initialization.
1522   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1523 
1524   void print_data_on(outputStream* st, const char* extra = NULL) const;
1525 };
1526 
1527 // BranchData
1528 //
1529 // A BranchData is used to access profiling data for a two-way branch.
1530 // It consists of taken and not_taken counts as well as a data displacement
1531 // for the taken case.
1532 class BranchData : public JumpData {
1533   friend class VMStructs;
1534   friend class JVMCIVMStructs;
1535 protected:
1536   enum {
1537     not_taken_off_set = jump_cell_count,
1538     branch_cell_count
1539   };
1540 
1541   void set_displacement(int displacement) {
1542     set_int_at(displacement_off_set, displacement);
1543   }
1544 
1545 public:
1546   BranchData(DataLayout* layout) : JumpData(layout) {
1547     assert(layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
1548   }
1549 
1550   virtual bool is_BranchData() const { return true; }
1551 
1552   static int static_cell_count() {
1553     return branch_cell_count;
1554   }
1555 
1556   virtual int cell_count() const {
1557     return static_cell_count();
1558   }
1559 
1560   // Direct accessor
1561   uint not_taken() const {
1562     return uint_at(not_taken_off_set);
1563   }
1564 
1565   void set_not_taken(uint cnt) {
1566     set_uint_at(not_taken_off_set, cnt);
1567   }
1568 
1569   uint inc_not_taken() {
1570     uint cnt = not_taken() + 1;
1571     // Did we wrap? Will compiler screw us??
1572     if (cnt == 0) cnt--;
1573     set_uint_at(not_taken_off_set, cnt);
1574     return cnt;
1575   }
1576 
1577   // Code generation support
1578   static ByteSize not_taken_offset() {
1579     return cell_offset(not_taken_off_set);
1580   }
1581   static ByteSize branch_data_size() {
1582     return cell_offset(branch_cell_count);
1583   }
1584 
1585   // Specific initialization.
1586   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1587 
1588   void print_data_on(outputStream* st, const char* extra = NULL) const;
1589 };
1590 
1591 // ArrayData
1592 //
1593 // A ArrayData is a base class for accessing profiling data which does
1594 // not have a statically known size.  It consists of an array length
1595 // and an array start.
1596 class ArrayData : public ProfileData {
1597   friend class VMStructs;
1598   friend class JVMCIVMStructs;
1599 protected:
1600   friend class DataLayout;
1601 
1602   enum {
1603     array_len_off_set,
1604     array_start_off_set
1605   };
1606 
1607   uint array_uint_at(int index) const {
1608     int aindex = index + array_start_off_set;
1609     return uint_at(aindex);
1610   }
1611   int array_int_at(int index) const {
1612     int aindex = index + array_start_off_set;
1613     return int_at(aindex);
1614   }
1615   oop array_oop_at(int index) const {
1616     int aindex = index + array_start_off_set;
1617     return oop_at(aindex);
1618   }
1619   void array_set_int_at(int index, int value) {
1620     int aindex = index + array_start_off_set;
1621     set_int_at(aindex, value);
1622   }
1623 
1624   // Code generation support for subclasses.
1625   static ByteSize array_element_offset(int index) {
1626     return cell_offset(array_start_off_set + index);
1627   }
1628 
1629 public:
1630   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1631 
1632   virtual bool is_ArrayData() const { return true; }
1633 
1634   static int static_cell_count() {
1635     return -1;
1636   }
1637 
1638   int array_len() const {
1639     return int_at_unchecked(array_len_off_set);
1640   }
1641 
1642   virtual int cell_count() const {
1643     return array_len() + 1;
1644   }
1645 
1646   // Code generation support
1647   static ByteSize array_len_offset() {
1648     return cell_offset(array_len_off_set);
1649   }
1650   static ByteSize array_start_offset() {
1651     return cell_offset(array_start_off_set);
1652   }
1653 };
1654 
1655 // MultiBranchData
1656 //
1657 // A MultiBranchData is used to access profiling information for
1658 // a multi-way branch (*switch bytecodes).  It consists of a series
1659 // of (count, displacement) pairs, which count the number of times each
1660 // case was taken and specify the data displacment for each branch target.
1661 class MultiBranchData : public ArrayData {
1662   friend class VMStructs;
1663   friend class JVMCIVMStructs;
1664 protected:
1665   enum {
1666     default_count_off_set,
1667     default_disaplacement_off_set,
1668     case_array_start
1669   };
1670   enum {
1671     relative_count_off_set,
1672     relative_displacement_off_set,
1673     per_case_cell_count
1674   };
1675 
1676   void set_default_displacement(int displacement) {
1677     array_set_int_at(default_disaplacement_off_set, displacement);
1678   }
1679   void set_displacement_at(int index, int displacement) {
1680     array_set_int_at(case_array_start +
1681                      index * per_case_cell_count +
1682                      relative_displacement_off_set,
1683                      displacement);
1684   }
1685 
1686 public:
1687   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1688     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, &quot;wrong type&quot;);
1689   }
1690 
1691   virtual bool is_MultiBranchData() const { return true; }
1692 
1693   static int compute_cell_count(BytecodeStream* stream);
1694 
1695   int number_of_cases() const {
1696     int alen = array_len() - 2; // get rid of default case here.
1697     assert(alen % per_case_cell_count == 0, &quot;must be even&quot;);
1698     return (alen / per_case_cell_count);
1699   }
1700 
1701   uint default_count() const {
1702     return array_uint_at(default_count_off_set);
1703   }
1704   int default_displacement() const {
1705     return array_int_at(default_disaplacement_off_set);
1706   }
1707 
1708   uint count_at(int index) const {
1709     return array_uint_at(case_array_start +
1710                          index * per_case_cell_count +
1711                          relative_count_off_set);
1712   }
1713   int displacement_at(int index) const {
1714     return array_int_at(case_array_start +
1715                         index * per_case_cell_count +
1716                         relative_displacement_off_set);
1717   }
1718 
1719   // Code generation support
1720   static ByteSize default_count_offset() {
1721     return array_element_offset(default_count_off_set);
1722   }
1723   static ByteSize default_displacement_offset() {
1724     return array_element_offset(default_disaplacement_off_set);
1725   }
1726   static ByteSize case_count_offset(int index) {
1727     return case_array_offset() +
1728            (per_case_size() * index) +
1729            relative_count_offset();
1730   }
1731   static ByteSize case_array_offset() {
1732     return array_element_offset(case_array_start);
1733   }
1734   static ByteSize per_case_size() {
1735     return in_ByteSize(per_case_cell_count) * cell_size;
1736   }
1737   static ByteSize relative_count_offset() {
1738     return in_ByteSize(relative_count_off_set) * cell_size;
1739   }
1740   static ByteSize relative_displacement_offset() {
1741     return in_ByteSize(relative_displacement_off_set) * cell_size;
1742   }
1743 
1744   // Specific initialization.
1745   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1746 
1747   void print_data_on(outputStream* st, const char* extra = NULL) const;
1748 };
1749 
1750 class ArgInfoData : public ArrayData {
1751 
1752 public:
1753   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1754     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, &quot;wrong type&quot;);
1755   }
1756 
1757   virtual bool is_ArgInfoData() const { return true; }
1758 
1759 
1760   int number_of_args() const {
1761     return array_len();
1762   }
1763 
1764   uint arg_modified(int arg) const {
1765     return array_uint_at(arg);
1766   }
1767 
1768   void set_arg_modified(int arg, uint val) {
1769     array_set_int_at(arg, val);
1770   }
1771 
1772   void print_data_on(outputStream* st, const char* extra = NULL) const;
1773 };
1774 
1775 // ParametersTypeData
1776 //
1777 // A ParametersTypeData is used to access profiling information about
1778 // types of parameters to a method
1779 class ParametersTypeData : public ArrayData {
1780 
1781 private:
1782   TypeStackSlotEntries _parameters;
1783 
1784   static int stack_slot_local_offset(int i) {
1785     assert_profiling_enabled();
1786     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1787   }
1788 
1789   static int type_local_offset(int i) {
1790     assert_profiling_enabled();
1791     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
1792   }
1793 
1794   static bool profiling_enabled();
1795   static void assert_profiling_enabled() {
1796     assert(profiling_enabled(), &quot;method parameters profiling should be on&quot;);
1797   }
1798 
1799 public:
1800   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
1801     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, &quot;wrong type&quot;);
1802     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1803     _parameters.set_profile_data(this);
1804   }
1805 
1806   static int compute_cell_count(Method* m);
1807 
1808   virtual bool is_ParametersTypeData() const { return true; }
1809 
1810   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1811 
1812   int number_of_parameters() const {
1813     return array_len() / TypeStackSlotEntries::per_arg_count();
1814   }
1815 
1816   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
1817 
1818   uint stack_slot(int i) const {
1819     return _parameters.stack_slot(i);
1820   }
1821 
1822   void set_type(int i, Klass* k) {
1823     intptr_t current = _parameters.type(i);
1824     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
1825   }
1826 
1827   virtual void clean_weak_klass_links(bool always_clean) {
1828     _parameters.clean_weak_klass_links(always_clean);
1829   }
1830 
1831   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1832 
1833   static ByteSize stack_slot_offset(int i) {
1834     return cell_offset(stack_slot_local_offset(i));
1835   }
1836 
1837   static ByteSize type_offset(int i) {
1838     return cell_offset(type_local_offset(i));
1839   }
1840 };
1841 
1842 // SpeculativeTrapData
1843 //
1844 // A SpeculativeTrapData is used to record traps due to type
1845 // speculation. It records the root of the compilation: that type
1846 // speculation is wrong in the context of one compilation (for
1847 // method1) doesn&#39;t mean it&#39;s wrong in the context of another one (for
1848 // method2). Type speculation could have more/different data in the
1849 // context of the compilation of method2 and it&#39;s worthwhile to try an
1850 // optimization that failed for compilation of method1 in the context
1851 // of compilation of method2.
1852 // Space for SpeculativeTrapData entries is allocated from the extra
1853 // data space in the MDO. If we run out of space, the trap data for
1854 // the ProfileData at that bci is updated.
1855 class SpeculativeTrapData : public ProfileData {
1856 protected:
1857   enum {
1858     speculative_trap_method,
1859 #ifndef _LP64
1860     // The size of the area for traps is a multiple of the header
1861     // size, 2 cells on 32 bits. Packed at the end of this area are
1862     // argument info entries (with tag
1863     // DataLayout::arg_info_data_tag). The logic in
1864     // MethodData::bci_to_extra_data() that guarantees traps don&#39;t
1865     // overflow over argument info entries assumes the size of a
1866     // SpeculativeTrapData is twice the header size. On 32 bits, a
1867     // SpeculativeTrapData must be 4 cells.
1868     padding,
1869 #endif
1870     speculative_trap_cell_count
1871   };
1872 public:
1873   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
1874     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, &quot;wrong type&quot;);
1875   }
1876 
1877   virtual bool is_SpeculativeTrapData() const { return true; }
1878 
1879   static int static_cell_count() {
1880     return speculative_trap_cell_count;
1881   }
1882 
1883   virtual int cell_count() const {
1884     return static_cell_count();
1885   }
1886 
1887   // Direct accessor
1888   Method* method() const {
1889     return (Method*)intptr_at(speculative_trap_method);
1890   }
1891 
1892   void set_method(Method* m) {
1893     assert(!m-&gt;is_old(), &quot;cannot add old methods&quot;);
1894     set_intptr_at(speculative_trap_method, (intptr_t)m);
1895   }
1896 
1897   static ByteSize method_offset() {
1898     return cell_offset(speculative_trap_method);
1899   }
1900 
1901   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1902 };
1903 
1904 // MethodData*
1905 //
1906 // A MethodData* holds information which has been collected about
1907 // a method.  Its layout looks like this:
1908 //
1909 // -----------------------------
1910 // | header                    |
1911 // | klass                     |
1912 // -----------------------------
1913 // | method                    |
1914 // | size of the MethodData* |
1915 // -----------------------------
1916 // | Data entries...           |
1917 // |   (variable size)         |
1918 // |                           |
1919 // .                           .
1920 // .                           .
1921 // .                           .
1922 // |                           |
1923 // -----------------------------
1924 //
1925 // The data entry area is a heterogeneous array of DataLayouts. Each
1926 // DataLayout in the array corresponds to a specific bytecode in the
1927 // method.  The entries in the array are sorted by the corresponding
1928 // bytecode.  Access to the data is via resource-allocated ProfileData,
1929 // which point to the underlying blocks of DataLayout structures.
1930 //
1931 // During interpretation, if profiling in enabled, the interpreter
1932 // maintains a method data pointer (mdp), which points at the entry
1933 // in the array corresponding to the current bci.  In the course of
1934 // intepretation, when a bytecode is encountered that has profile data
1935 // associated with it, the entry pointed to by mdp is updated, then the
1936 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1937 // is NULL to begin with, the interpreter assumes that the current method
1938 // is not (yet) being profiled.
1939 //
1940 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1941 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1942 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1943 // in certain ProfileData objects that indicate the amount the mdp must be
1944 // adjusted in the event of a change in control flow.
1945 //
1946 
1947 class CleanExtraDataClosure : public StackObj {
1948 public:
1949   virtual bool is_live(Method* m) = 0;
1950 };
1951 
1952 
<a name="7" id="anc7"></a><span class="line-added">1953 #if INCLUDE_JVMCI</span>
<span class="line-added">1954 // Encapsulates an encoded speculation reason. These are linked together in</span>
<span class="line-added">1955 // a list that is atomically appended to during deoptimization. Entries are</span>
<span class="line-added">1956 // never removed from the list.</span>
<span class="line-added">1957 // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding</span>
<span class="line-added">1958 class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="line-added">1959  private:</span>
<span class="line-added">1960   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself</span>
<span class="line-added">1961   // is an array embedded at the end of this object.</span>
<span class="line-added">1962   int   _data_len;</span>
<span class="line-added">1963 </span>
<span class="line-added">1964   // Next entry in a linked list.</span>
<span class="line-added">1965   FailedSpeculation* _next;</span>
<span class="line-added">1966 </span>
<span class="line-added">1967   FailedSpeculation(address data, int data_len);</span>
<span class="line-added">1968 </span>
<span class="line-added">1969   FailedSpeculation** next_adr() { return &amp;_next; }</span>
<span class="line-added">1970 </span>
<span class="line-added">1971   // Placement new operator for inlining the speculation data into</span>
<span class="line-added">1972   // the FailedSpeculation object.</span>
<span class="line-added">1973   void* operator new(size_t size, size_t fs_size) throw();</span>
<span class="line-added">1974 </span>
<span class="line-added">1975  public:</span>
<span class="line-added">1976   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }</span>
<span class="line-added">1977   int data_len() const { return _data_len; }</span>
<span class="line-added">1978   FailedSpeculation* next() const { return _next; }</span>
<span class="line-added">1979 </span>
<span class="line-added">1980   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).</span>
<span class="line-added">1981   // Returns false if the FailedSpeculation object could not be allocated.</span>
<span class="line-added">1982   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);</span>
<span class="line-added">1983 </span>
<span class="line-added">1984   // Frees all entries in the linked list whose head is at (*failed_speculations_address).</span>
<span class="line-added">1985   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);</span>
<span class="line-added">1986 };</span>
<span class="line-added">1987 #endif</span>
<span class="line-added">1988 </span>
1989 class MethodData : public Metadata {
1990   friend class VMStructs;
1991   friend class JVMCIVMStructs;
1992 private:
1993   friend class ProfileData;
1994   friend class TypeEntriesAtCall;
1995 
1996   // If you add a new field that points to any metaspace object, you
1997   // must add this field to MethodData::metaspace_pointers_do().
1998 
1999   // Back pointer to the Method*
2000   Method* _method;
2001 
2002   // Size of this oop in bytes
2003   int _size;
2004 
2005   // Cached hint for bci_to_dp and bci_to_data
2006   int _hint_di;
2007 
2008   Mutex _extra_data_lock;
2009 
2010   MethodData(const methodHandle&amp; method, int size, TRAPS);
2011 public:
2012   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
<a name="8" id="anc8"></a><span class="line-modified">2013   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData</span>
2014 
2015   bool is_methodData() const volatile { return true; }
2016   void initialize();
2017 
2018   // Whole-method sticky bits and flags
2019   enum {
<a name="9" id="anc9"></a><span class="line-modified">2020     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT</span>
2021     _trap_hist_mask     = max_jubyte,
2022     _extra_data_count   = 4     // extra DataLayout headers, for trap history
2023   }; // Public flag values
2024 private:
2025   uint _nof_decompiles;             // count of all nmethod removals
2026   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
2027   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
2028   union {
2029     intptr_t _align;
2030     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
2031   } _trap_hist;
2032 
2033   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2034   intx              _eflags;          // flags on escape information
2035   intx              _arg_local;       // bit set of non-escaping arguments
2036   intx              _arg_stack;       // bit set of stack-allocatable arguments
2037   intx              _arg_returned;    // bit set of returned arguments
2038 
2039   int _creation_mileage;              // method mileage at MDO creation
2040 
2041   // How many invocations has this MDO seen?
2042   // These counters are used to determine the exact age of MDO.
2043   // We need those because in tiered a method can be concurrently
2044   // executed at different levels.
2045   InvocationCounter _invocation_counter;
2046   // Same for backedges.
2047   InvocationCounter _backedge_counter;
2048   // Counter values at the time profiling started.
2049   int               _invocation_counter_start;
2050   int               _backedge_counter_start;
2051   uint              _tenure_traps;
2052   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2053   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2054 
2055 #if INCLUDE_RTM_OPT
2056   // State of RTM code generation during compilation of the method
2057   int               _rtm_state;
2058 #endif
2059 
2060   // Number of loops and blocks is computed when compiling the first
2061   // time with C1. It is used to determine if method is trivial.
2062   short             _num_loops;
2063   short             _num_blocks;
2064   // Does this method contain anything worth profiling?
2065   enum WouldProfile {unknown, no_profile, profile};
2066   WouldProfile      _would_profile;
2067 
2068 #if INCLUDE_JVMCI
2069   // Support for HotSpotMethodData.setCompiledIRSize(int)
<a name="10" id="anc10"></a><span class="line-modified">2070   int                _jvmci_ir_size;</span>
<span class="line-added">2071   FailedSpeculation* _failed_speculations;</span>
2072 #endif
2073 
2074   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2075   int _data_size;
2076 
2077   // data index for the area dedicated to parameters. -1 if no
2078   // parameter profiling.
2079   enum { no_parameters = -2, parameters_uninitialized = -1 };
2080   int _parameters_type_data_di;
<a name="11" id="anc11"></a>



2081 
2082   // Beginning of the data entries
2083   intptr_t _data[1];
2084 
2085   // Helper for size computation
2086   static int compute_data_size(BytecodeStream* stream);
2087   static int bytecode_cell_count(Bytecodes::Code code);
2088   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2089   enum { no_profile_data = -1, variable_cell_count = -2 };
2090 
2091   // Helper for initialization
2092   DataLayout* data_layout_at(int data_index) const {
2093     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2094     return (DataLayout*) (((address)_data) + data_index);
2095   }
2096 
2097   // Initialize an individual data segment.  Returns the size of
2098   // the segment in bytes.
2099   int initialize_data(BytecodeStream* stream, int data_index);
2100 
2101   // Helper for data_at
2102   DataLayout* limit_data_position() const {
2103     return data_layout_at(_data_size);
2104   }
2105   bool out_of_bounds(int data_index) const {
2106     return data_index &gt;= data_size();
2107   }
2108 
2109   // Give each of the data entries a chance to perform specific
2110   // data initialization.
2111   void post_initialize(BytecodeStream* stream);
2112 
2113   // hint accessors
2114   int      hint_di() const  { return _hint_di; }
2115   void set_hint_di(int di)  {
2116     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
2117     _hint_di = di;
2118   }
2119   ProfileData* data_before(int bci) {
2120     // avoid SEGV on this edge case
2121     if (data_size() == 0)
2122       return NULL;
2123     int hint = hint_di();
2124     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2125       return data_at(hint);
2126     return first_data();
2127   }
2128 
2129   // What is the index of the first data entry?
2130   int first_di() const { return 0; }
2131 
2132   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2133   // Find or create an extra ProfileData:
2134   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2135 
2136   // return the argument info cell
2137   ArgInfoData *arg_info();
2138 
2139   enum {
2140     no_type_profile = 0,
2141     type_profile_jsr292 = 1,
2142     type_profile_all = 2
2143   };
2144 
2145   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2146   static bool profile_unsafe(const methodHandle&amp; m, int bci);
2147   static int profile_arguments_flag();
2148   static bool profile_all_arguments();
2149   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2150   static int profile_return_flag();
2151   static bool profile_all_return();
2152   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2153   static int profile_parameters_flag();
2154   static bool profile_parameters_jsr292_only();
2155   static bool profile_all_parameters();
2156 
2157   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2158   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2159 
2160 public:
2161   void clean_extra_data(CleanExtraDataClosure* cl);
2162 
2163   static int header_size() {
2164     return sizeof(MethodData)/wordSize;
2165   }
2166 
2167   // Compute the size of a MethodData* before it is created.
2168   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2169   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2170   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2171 
2172   // Determine if a given bytecode can have profile information.
2173   static bool bytecode_has_profile(Bytecodes::Code code) {
2174     return bytecode_cell_count(code) != no_profile_data;
2175   }
2176 
2177   // reset into original state
2178   void init();
2179 
2180   // My size
2181   int size_in_bytes() const { return _size; }
2182   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
<a name="12" id="anc12"></a>


2183 
2184   int      creation_mileage() const  { return _creation_mileage; }
2185   void set_creation_mileage(int x)   { _creation_mileage = x; }
2186 
2187   int invocation_count() {
2188     if (invocation_counter()-&gt;carry()) {
2189       return InvocationCounter::count_limit;
2190     }
2191     return invocation_counter()-&gt;count();
2192   }
2193   int backedge_count() {
2194     if (backedge_counter()-&gt;carry()) {
2195       return InvocationCounter::count_limit;
2196     }
2197     return backedge_counter()-&gt;count();
2198   }
2199 
2200   int invocation_count_start() {
2201     if (invocation_counter()-&gt;carry()) {
2202       return 0;
2203     }
2204     return _invocation_counter_start;
2205   }
2206 
2207   int backedge_count_start() {
2208     if (backedge_counter()-&gt;carry()) {
2209       return 0;
2210     }
2211     return _backedge_counter_start;
2212   }
2213 
2214   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2215   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2216 
2217   void reset_start_counters() {
2218     _invocation_counter_start = invocation_count();
2219     _backedge_counter_start = backedge_count();
2220   }
2221 
2222   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2223   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2224 
<a name="13" id="anc13"></a><span class="line-added">2225 #if INCLUDE_JVMCI</span>
<span class="line-added">2226   FailedSpeculation** get_failed_speculations_address() {</span>
<span class="line-added">2227     return &amp;_failed_speculations;</span>
<span class="line-added">2228   }</span>
<span class="line-added">2229 #endif</span>
<span class="line-added">2230 </span>
2231 #if INCLUDE_RTM_OPT
2232   int rtm_state() const {
2233     return _rtm_state;
2234   }
2235   void set_rtm_state(RTMState rstate) {
2236     _rtm_state = (int)rstate;
2237   }
2238   void atomic_set_rtm_state(RTMState rstate) {
<a name="14" id="anc14"></a><span class="line-modified">2239     Atomic::store(&amp;_rtm_state, (int)rstate);</span>
2240   }
2241 
2242   static int rtm_state_offset_in_bytes() {
2243     return offset_of(MethodData, _rtm_state);
2244   }
2245 #endif
2246 
2247   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2248   bool would_profile() const                  { return _would_profile != no_profile; }
2249 
2250   int num_loops() const                       { return _num_loops;  }
2251   void set_num_loops(int n)                   { _num_loops = n;     }
2252   int num_blocks() const                      { return _num_blocks; }
2253   void set_num_blocks(int n)                  { _num_blocks = n;    }
2254 
2255   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2256   static int mileage_of(Method* m);
2257 
2258   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2259   enum EscapeFlag {
2260     estimated    = 1 &lt;&lt; 0,
2261     return_local = 1 &lt;&lt; 1,
2262     return_allocated = 1 &lt;&lt; 2,
2263     allocated_escapes = 1 &lt;&lt; 3,
2264     unknown_modified = 1 &lt;&lt; 4
2265   };
2266 
2267   intx eflags()                                  { return _eflags; }
2268   intx arg_local()                               { return _arg_local; }
2269   intx arg_stack()                               { return _arg_stack; }
2270   intx arg_returned()                            { return _arg_returned; }
2271   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2272                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2273                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2274                                                    return aid-&gt;arg_modified(a); }
2275 
2276   void set_eflags(intx v)                        { _eflags = v; }
2277   void set_arg_local(intx v)                     { _arg_local = v; }
2278   void set_arg_stack(intx v)                     { _arg_stack = v; }
2279   void set_arg_returned(intx v)                  { _arg_returned = v; }
2280   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2281                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2282                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2283                                                    aid-&gt;set_arg_modified(a, v); }
2284 
2285   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2286 
2287   // Location and size of data area
2288   address data_base() const {
2289     return (address) _data;
2290   }
2291   int data_size() const {
2292     return _data_size;
2293   }
2294 
<a name="15" id="anc15"></a><span class="line-added">2295   int parameters_size_in_bytes() const {</span>
<span class="line-added">2296     ParametersTypeData* param = parameters_type_data();</span>
<span class="line-added">2297     return param == NULL ? 0 : param-&gt;size_in_bytes();</span>
<span class="line-added">2298   }</span>
<span class="line-added">2299 </span>
2300   // Accessors
2301   Method* method() const { return _method; }
2302 
2303   // Get the data at an arbitrary (sort of) data index.
2304   ProfileData* data_at(int data_index) const;
2305 
2306   // Walk through the data in order.
2307   ProfileData* first_data() const { return data_at(first_di()); }
2308   ProfileData* next_data(ProfileData* current) const;
2309   bool is_valid(ProfileData* current) const { return current != NULL; }
2310 
2311   // Convert a dp (data pointer) to a di (data index).
2312   int dp_to_di(address dp) const {
2313     return dp - ((address)_data);
2314   }
2315 
2316   // bci to di/dp conversion.
2317   address bci_to_dp(int bci);
2318   int bci_to_di(int bci) {
2319     return dp_to_di(bci_to_dp(bci));
2320   }
2321 
2322   // Get the data at an arbitrary bci, or NULL if there is none.
2323   ProfileData* bci_to_data(int bci);
2324 
2325   // Same, but try to create an extra_data record if one is needed:
2326   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2327     ProfileData* data = NULL;
2328     // If m not NULL, try to allocate a SpeculativeTrapData entry
2329     if (m == NULL) {
2330       data = bci_to_data(bci);
2331     }
2332     if (data != NULL) {
2333       return data;
2334     }
2335     data = bci_to_extra_data(bci, m, true);
2336     if (data != NULL) {
2337       return data;
2338     }
2339     // If SpeculativeTrapData allocation fails try to allocate a
2340     // regular entry
2341     data = bci_to_data(bci);
2342     if (data != NULL) {
2343       return data;
2344     }
2345     return bci_to_extra_data(bci, NULL, true);
2346   }
2347 
2348   // Add a handful of extra data records, for trap tracking.
2349   DataLayout* extra_data_base() const  { return limit_data_position(); }
2350   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2351   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2352                                                               parameters_size_in_bytes()); }
2353   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2354   static DataLayout* next_extra(DataLayout* dp);
2355 
2356   // Return (uint)-1 for overflow.
2357   uint trap_count(int reason) const {
2358     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2359     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2360   }
2361   // For loops:
2362   static uint trap_reason_limit() { return _trap_hist_limit; }
2363   static uint trap_count_limit()  { return _trap_hist_mask; }
2364   uint inc_trap_count(int reason) {
2365     // Count another trap, anywhere in this method.
2366     assert(reason &gt;= 0, &quot;must be single trap&quot;);
2367     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2368     uint cnt1 = 1 + _trap_hist._array[reason];
2369     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2370       _trap_hist._array[reason] = cnt1;
2371       return cnt1;
2372     } else {
2373       return _trap_hist_mask + (++_nof_overflow_traps);
2374     }
2375   }
2376 
2377   uint overflow_trap_count() const {
2378     return _nof_overflow_traps;
2379   }
2380   uint overflow_recompile_count() const {
2381     return _nof_overflow_recompiles;
2382   }
2383   void inc_overflow_recompile_count() {
2384     _nof_overflow_recompiles += 1;
2385   }
2386   uint decompile_count() const {
2387     return _nof_decompiles;
2388   }
2389   void inc_decompile_count() {
2390     _nof_decompiles += 1;
2391     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
<a name="16" id="anc16"></a><span class="line-modified">2392       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);</span>
2393     }
2394   }
2395   uint tenure_traps() const {
2396     return _tenure_traps;
2397   }
2398   void inc_tenure_traps() {
2399     _tenure_traps += 1;
2400   }
2401 
2402   // Return pointer to area dedicated to parameters in MDO
2403   ParametersTypeData* parameters_type_data() const {
2404     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2405     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2406   }
2407 
2408   int parameters_type_data_di() const {
2409     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2410     return _parameters_type_data_di;
2411   }
2412 
2413   // Support for code generation
2414   static ByteSize data_offset() {
2415     return byte_offset_of(MethodData, _data[0]);
2416   }
2417 
2418   static ByteSize trap_history_offset() {
2419     return byte_offset_of(MethodData, _trap_hist._array);
2420   }
2421 
2422   static ByteSize invocation_counter_offset() {
2423     return byte_offset_of(MethodData, _invocation_counter);
2424   }
2425 
2426   static ByteSize backedge_counter_offset() {
2427     return byte_offset_of(MethodData, _backedge_counter);
2428   }
2429 
2430   static ByteSize invoke_mask_offset() {
2431     return byte_offset_of(MethodData, _invoke_mask);
2432   }
2433 
2434   static ByteSize backedge_mask_offset() {
2435     return byte_offset_of(MethodData, _backedge_mask);
2436   }
2437 
2438   static ByteSize parameters_type_data_di_offset() {
2439     return byte_offset_of(MethodData, _parameters_type_data_di);
2440   }
2441 
2442   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2443   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2444 
<a name="17" id="anc17"></a><span class="line-modified">2445   // Deallocation support - no metaspace pointer fields to deallocate</span>
2446   void deallocate_contents(ClassLoaderData* loader_data) {}
2447 
2448   // GC support
2449   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2450 
2451   // Printing
2452   void print_on      (outputStream* st) const;
2453   void print_value_on(outputStream* st) const;
2454 
2455   // printing support for method data
2456   void print_data_on(outputStream* st) const;
2457 
2458   const char* internal_name() const { return &quot;{method data}&quot;; }
2459 
2460   // verification
2461   void verify_on(outputStream* st);
2462   void verify_data_on(outputStream* st);
2463 
2464   static bool profile_parameters_for_method(const methodHandle&amp; m);
2465   static bool profile_arguments();
2466   static bool profile_arguments_jsr292_only();
2467   static bool profile_return();
2468   static bool profile_parameters();
2469   static bool profile_return_jsr292_only();
2470 
2471   void clean_method_data(bool always_clean);
2472   void clean_weak_method_links();
2473   DEBUG_ONLY(void verify_clean_weak_method_links();)
2474   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2475 };
2476 
2477 #endif // SHARE_OOPS_METHODDATA_HPP
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
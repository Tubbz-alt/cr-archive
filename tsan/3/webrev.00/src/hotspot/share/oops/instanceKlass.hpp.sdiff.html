<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
<span class="line-removed">  28 #include &quot;classfile/classLoader.hpp&quot;</span>
  29 #include &quot;classfile/classLoaderData.hpp&quot;
<span class="line-removed">  30 #include &quot;classfile/moduleEntry.hpp&quot;</span>
<span class="line-removed">  31 #include &quot;classfile/packageEntry.hpp&quot;</span>
  32 #include &quot;memory/referenceType.hpp&quot;
  33 #include &quot;oops/annotations.hpp&quot;
  34 #include &quot;oops/constMethod.hpp&quot;
  35 #include &quot;oops/fieldInfo.hpp&quot;
  36 #include &quot;oops/instanceOop.hpp&quot;
  37 #include &quot;oops/klassVtable.hpp&quot;
  38 #include &quot;runtime/handles.hpp&quot;
  39 #include &quot;runtime/os.hpp&quot;
  40 #include &quot;utilities/accessFlags.hpp&quot;
  41 #include &quot;utilities/align.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 #if INCLUDE_JFR
  44 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  45 #endif
  46 

  47 
  48 // An InstanceKlass is the VM level representation of a Java class.
  49 // It contains all information needed for at class at execution runtime.
  50 
  51 //  InstanceKlass embedded field layout (after declared fields):
  52 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  53 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  54 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  55 //      indicating where oops are located in instances of this klass.
  56 //    [EMBEDDED implementor of the interface] only exist for interface
  57 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  58 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;

  66 class KlassDepChange;
  67 class DependencyContext;
  68 class fieldDescriptor;
  69 class jniIdMapBase;
  70 class JNIid;
  71 class JvmtiCachedClassFieldMap;
  72 class nmethodBucket;
<span class="line-removed">  73 class SuperTypeClosure;</span>
  74 class OopMapCache;
  75 class InterpreterOopMap;


  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
  93 #endif  // !PRODUCT
  94 
  95 // Describes where oops are located in instances of this klass.
  96 class OopMapBlock {
  97  public:
  98   // Byte offset of the first oop mapped by this block.
  99   int offset() const          { return _offset; }
 100   void set_offset(int offset) { _offset = offset; }
 101 
 102   // Number of oops in this block.
 103   uint count() const         { return _count; }
 104   void set_count(uint count) { _count = count; }
 105 












 106   // sizeof(OopMapBlock) in words.
 107   static const int size_in_words() {
 108     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 109       LogBytesPerWord;
 110   }
 111 




 112  private:
 113   int  _offset;
 114   uint _count;
 115 };
 116 
 117 struct JvmtiCachedClassFileData;
 118 
 119 class InstanceKlass: public Klass {
 120   friend class VMStructs;
 121   friend class JVMCIVMStructs;
 122   friend class ClassFileParser;
 123   friend class CompileReplay;
 124 
 125  public:
 126   static const KlassID ID = InstanceKlassID;
 127 
 128  protected:
 129   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 130 
 131  public:
</pre>
<hr />
<pre>
 166   // last two shorts [class_index, method_index] of the array. If only
 167   // the InnerClasses attribute exists, the _inner_classes array length is
 168   // number_of_inner_classes * 4. If the class has both InnerClasses
 169   // and EnclosingMethod attributes the _inner_classes array length is
 170   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 171   Array&lt;jushort&gt;* _inner_classes;
 172 
 173   // The NestMembers attribute. An array of shorts, where each is a
 174   // class info index for the class that is a nest member. This data
 175   // has not been validated.
 176   Array&lt;jushort&gt;* _nest_members;
 177 
 178   // The NestHost attribute. The class info index for the class
 179   // that is the nest-host of this class. This data has not been validated.
 180   jushort _nest_host_index;
 181 
 182   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 183   // By always being set it makes nest-member access checks simpler.
 184   InstanceKlass* _nest_host;
 185 



 186   // the source debug extension for this klass, NULL if not specified.
 187   // Specified as UTF-8 string without terminating zero byte in the classfile,
 188   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 189   const char*     _source_debug_extension;
 190   // Array name derived from this class which needs unreferencing
 191   // if this class is unloaded.
 192   Symbol*         _array_name;
 193 
 194   // Number of heapOopSize words used by non-static fields in this klass
 195   // (including inherited fields but after header_size()).
 196   int             _nonstatic_field_size;
 197   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 198   // Constant pool index to the utf8 entry of the Generic signature,
 199   // or 0 if none.
 200   u2              _generic_signature_index;
 201   // Constant pool index to the utf8 entry for the name of source file
 202   // containing this klass, 0 if not specified.
 203   u2              _source_file_name_index;
 204   u2              _static_oop_field_count;// number of static oop fields in this klass
 205   u2              _java_fields_count;    // The number of declared Java fields
 206   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 207 
 208   int             _itable_len;           // length of Java itable (in words)
 209   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 210   // _misc_flags.
 211   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
<span class="line-removed"> 212   bool            _is_being_redefined;   // used for locking redefinition</span>
 213 
 214   // The low two bits of _misc_flags contains the kind field.
 215   // This can be used to quickly discriminate among the four kinds of
 216   // InstanceKlass.
 217 
 218   static const unsigned _misc_kind_field_size = 2;
 219   static const unsigned _misc_kind_field_pos  = 0;
 220   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 221 
 222   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 223   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 224   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 225   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 226 
 227   // Start after _misc_kind field.
 228   enum {
 229     _misc_rewritten                           = 1 &lt;&lt; 2,  // methods rewritten.
 230     _misc_has_nonstatic_fields                = 1 &lt;&lt; 3,  // for sizing with UseCompressedOops
 231     _misc_should_verify_class                 = 1 &lt;&lt; 4,  // allow caching of preverification
 232     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 5,  // has embedded _unsafe_anonymous_host field
 233     _misc_is_contended                        = 1 &lt;&lt; 6,  // marked with contended annotation
 234     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 7,  // class/superclass/implemented interfaces has non-static, concrete methods
 235     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 8,  // directly declares non-static, concrete methods
 236     _misc_has_been_redefined                  = 1 &lt;&lt; 9,  // class has been redefined
 237     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 10, // when this class was loaded, the fingerprint computed from its
 238                                                          // code source was found to be matching the value recorded by AOT.
 239     _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class
 240     _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader
 241     _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader
 242     _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader
<span class="line-modified"> 243     _misc_has_resolved_methods                = 1 &lt;&lt; 15  // resolved methods table entries added for this class</span>


 244   };
 245   u2 loader_type_bits() {
 246     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 247   }
<span class="line-modified"> 248   u2              _misc_flags;</span>
 249   u2              _minor_version;        // minor version number of class file
 250   u2              _major_version;        // major version number of class file
<span class="line-modified"> 251   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)</span>
 252   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 253   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 254   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 255   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 256   uint64_t        volatile _dep_context_last_cleaned;
 257   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 258 #if INCLUDE_JVMTI
 259   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 260   // Linked instanceKlasses of previous versions
 261   InstanceKlass* _previous_versions;
 262   // JVMTI fields can be moved to their own structure - see 6315920
 263   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 264   JvmtiCachedClassFileData* _cached_class_file;
 265 #endif
 266 
 267   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 268 
 269   // Class states are defined as ClassState (see above).
 270   // Place the _init_state here to utilize the unused 2-byte after
 271   // _idnum_allocated_count.
</pre>
<hr />
<pre>
 313   // embedded static fields follows here
 314   // embedded nonstatic oop-map blocks follows here
 315   // embedded implementor of this interface follows here
 316   //   The embedded implementor only exists if the current klass is an
 317   //   iterface. The possible values of the implementor fall into following
 318   //   three cases:
 319   //     NULL: no implementor.
 320   //     A Klass* that&#39;s not itself: one implementor.
 321   //     Itself: more than one implementors.
 322   // embedded unsafe_anonymous_host klass follows here
 323   //   The embedded host klass only exists in an unsafe anonymous class for
 324   //   dynamic language support (JSR 292 enabled). The host class grants
 325   //   its access privileges to this class also. The host class is either
 326   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 327   //   or an anonymous class loaded through normal classloading does not
 328   //   have this embedded field.
 329   //
 330 
 331   friend class SystemDictionary;
 332 


 333  public:
 334   u2 loader_type() {
 335     return _misc_flags &amp; loader_type_bits();
 336   }
 337 
 338   bool is_shared_boot_class() const {
 339     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 340   }
 341   bool is_shared_platform_class() const {
 342     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 343   }
 344   bool is_shared_app_class() const {
 345     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 346   }
 347 
 348   void clear_class_loader_type() {
 349     _misc_flags &amp;= ~loader_type_bits();
 350   }
 351 
<span class="line-modified"> 352   void set_class_loader_type(s2 loader_type) {</span>
<span class="line-removed"> 353     switch (loader_type) {</span>
<span class="line-removed"> 354     case ClassLoader::BOOT_LOADER:</span>
<span class="line-removed"> 355       _misc_flags |= _misc_is_shared_boot_class;</span>
<span class="line-removed"> 356        break;</span>
<span class="line-removed"> 357     case ClassLoader::PLATFORM_LOADER:</span>
<span class="line-removed"> 358       _misc_flags |= _misc_is_shared_platform_class;</span>
<span class="line-removed"> 359       break;</span>
<span class="line-removed"> 360     case ClassLoader::APP_LOADER:</span>
<span class="line-removed"> 361       _misc_flags |= _misc_is_shared_app_class;</span>
<span class="line-removed"> 362       break;</span>
<span class="line-removed"> 363     default:</span>
<span class="line-removed"> 364       ShouldNotReachHere();</span>
<span class="line-removed"> 365       break;</span>
<span class="line-removed"> 366     }</span>
<span class="line-removed"> 367   }</span>
 368 
 369   bool has_nonstatic_fields() const        {
 370     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 371   }
 372   void set_has_nonstatic_fields(bool b)    {
 373     if (b) {
 374       _misc_flags |= _misc_has_nonstatic_fields;
 375     } else {
 376       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 377     }
 378   }
 379 
 380   // field sizes
 381   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 382   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 383 
 384   int static_field_size() const            { return _static_field_size; }
 385   void set_static_field_size(int size)     { _static_field_size = size; }
 386 
 387   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
</pre>
<hr />
<pre>
 445 
 446   Array&lt;u2&gt;* fields() const            { return _fields; }
 447   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 448     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 449     _fields = f;
 450     _java_fields_count = java_fields_count;
 451   }
 452 
 453   // inner classes
 454   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 455   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 456 
 457   // nest members
 458   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 459   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 460 
 461   // nest-host index
 462   jushort nest_host_index() const { return _nest_host_index; }
 463   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 464 







 465 private:
 466   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 467   bool has_nest_member(InstanceKlass* k, TRAPS) const;

 468 public:
 469   // Returns nest-host class, resolving and validating it if needed
 470   // Returns NULL if an exception occurs during loading, or validation fails
 471   InstanceKlass* nest_host(Symbol* validationException, TRAPS);
 472   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 473   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 474 
 475   enum InnerClassAttributeOffset {
 476     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 477     inner_class_inner_class_info_offset = 0,
 478     inner_class_outer_class_info_offset = 1,
 479     inner_class_inner_name_offset = 2,
 480     inner_class_access_flags_offset = 3,
 481     inner_class_next_offset = 4
 482   };
 483 
 484   enum EnclosingMethodAttributeOffset {
 485     enclosing_method_class_index_offset = 0,
 486     enclosing_method_method_index_offset = 1,
 487     enclosing_method_attribute_size = 2
</pre>
<hr />
<pre>
 556     assert(t == (u1)t, &quot;overflow&quot;);
 557     _reference_type = (u1)t;
 558   }
 559 
 560   // this class cp index
 561   u2 this_class_index() const             { return _this_class_index; }
 562   void set_this_class_index(u2 index)     { _this_class_index = index; }
 563 
 564   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 565 
 566   // find local field, returns true if found
 567   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 568   // find field in direct superinterfaces, returns the interface in which the field is defined
 569   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 570   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 571   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 572   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 573   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 574 
 575   // find a non-static or static field given its offset within the class.
<span class="line-modified"> 576   bool contains_field_offset(int offset) {</span>
<span class="line-removed"> 577     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());</span>
<span class="line-removed"> 578   }</span>
 579 
 580   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 581   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 582 








 583   // find a local method (returns NULL if not found)
 584   Method* find_method(const Symbol* name, const Symbol* signature) const;
 585   static Method* find_method(const Array&lt;Method*&gt;* methods,
 586                              const Symbol* name,
 587                              const Symbol* signature);
 588 
 589   // find a local method, but skip static methods
 590   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 591                                PrivateLookupMode private_mode = find_private) const;
 592   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 593                                       const Symbol* name,
 594                                       const Symbol* signature,
 595                                       PrivateLookupMode private_mode = find_private);
 596 
 597   // find a local method (returns NULL if not found)
 598   Method* find_local_method(const Symbol* name,
 599                             const Symbol* signature,
 600                             OverpassLookupMode overpass_mode,
 601                             StaticLookupMode static_mode,
 602                             PrivateLookupMode private_mode) const;
</pre>
<hr />
<pre>
 712   // source debug extension
 713   const char* source_debug_extension() const { return _source_debug_extension; }
 714   void set_source_debug_extension(const char* array, int length);
 715 
 716   // symbol unloading support (refcount already added)
 717   Symbol* array_name()                     { return _array_name; }
 718   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }
 719 
 720   // nonstatic oop-map blocks
 721   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 722     return oop_map_count * OopMapBlock::size_in_words();
 723   }
 724   unsigned int nonstatic_oop_map_count() const {
 725     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 726   }
 727   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 728   void set_nonstatic_oop_map_size(int words) {
 729     _nonstatic_oop_map_size = words;
 730   }
 731 











 732 #if INCLUDE_JVMTI
 733   // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-modified"> 734   bool is_being_redefined() const          { return _is_being_redefined; }</span>
<span class="line-modified"> 735   void set_is_being_redefined(bool value)  { _is_being_redefined = value; }</span>








 736 
 737   // RedefineClasses() support for previous versions:
 738   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 739   void purge_previous_version_list();
 740 
 741   InstanceKlass* previous_versions() const { return _previous_versions; }
 742 #else
 743   InstanceKlass* previous_versions() const { return NULL; }
 744 #endif
 745 
 746   InstanceKlass* get_klass_version(int version) {
 747     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 748       if (ik-&gt;constants()-&gt;version() == version) {
 749         return ik;
 750       }
 751     }
 752     return NULL;
 753   }
 754 
 755   bool has_been_redefined() const {
</pre>
<hr />
<pre>
 991   // subclass/subinterface checks
 992   bool implements_interface(Klass* k) const;
 993   bool is_same_or_direct_interface(Klass* k) const;
 994 
 995 #ifdef ASSERT
 996   // check whether this class or one of its superclasses was redefined
 997   bool has_redefined_this_or_super() const;
 998 #endif
 999 
1000   // Access to the implementor of an interface.
1001   Klass* implementor() const;
1002   void set_implementor(Klass* k);
1003   int  nof_implementors() const;
1004   void add_implementor(Klass* k);  // k is a new class that implements this interface
1005   void init_implementor();           // initialize
1006 
1007   // link this class into the implementors list of every interface it implements
1008   void process_interfaces(Thread *thread);
1009 
1010   // virtual operations from Klass
<span class="line-removed">1011   bool is_leaf_class() const               { return _subklass == NULL; }</span>
1012   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1013                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1014   bool can_be_primary_super_slow() const;
1015   int oop_size(oop obj)  const             { return size_helper(); }
1016   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1017   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1018   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1019 
1020   // Iterators
1021   void do_local_static_fields(FieldClosure* cl);
1022   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1023   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1024 
1025   void methods_do(void f(Method* method));
1026   void array_klasses_do(void f(Klass* k));
1027   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
<span class="line-removed">1028   bool super_types_do(SuperTypeClosure* blk);</span>
1029 
1030   static InstanceKlass* cast(Klass* k) {
1031     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1032   }
1033 
1034   static const InstanceKlass* cast(const Klass* k) {
1035     assert(k != NULL, &quot;k should not be null&quot;);
1036     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1037     return static_cast&lt;const InstanceKlass*&gt;(k);
1038   }
1039 
1040   virtual InstanceKlass* java_super() const {
1041     return (super() == NULL) ? NULL : cast(super());
1042   }
1043 
1044   // Sizing (in words)
1045   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1046 
1047   static int size(int vtable_length, int itable_length,
1048                   int nonstatic_oop_map_size,
1049                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {
1050     return align_metadata_size(header_size() +
1051            vtable_length +
1052            itable_length +
1053            nonstatic_oop_map_size +
1054            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1055            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1056            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));
1057   }
1058   int size() const                    { return size(vtable_length(),
1059                                                itable_length(),
1060                                                nonstatic_oop_map_size(),
1061                                                is_interface(),
1062                                                is_unsafe_anonymous(),
1063                                                has_stored_fingerprint());
1064   }
<span class="line-removed">1065 #if INCLUDE_SERVICES</span>
<span class="line-removed">1066   virtual void collect_statistics(KlassSizeStats *sz) const;</span>
<span class="line-removed">1067 #endif</span>
1068 
1069   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1070   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1071 
1072   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1073 
1074   oop static_field_base_raw() { return java_mirror(); }
1075 
1076   OopMapBlock* start_of_nonstatic_oop_maps() const {
1077     return (OopMapBlock*)(start_of_itable() + itable_length());
1078   }
1079 
1080   Klass** end_of_nonstatic_oop_maps() const {
1081     return (Klass**)(start_of_nonstatic_oop_maps() +
1082                      nonstatic_oop_map_count());
1083   }
1084 
1085   Klass* volatile* adr_implementor() const {
1086     if (is_interface()) {
1087       return (Klass* volatile*)end_of_nonstatic_oop_maps();
</pre>
<hr />
<pre>
1143 #if INCLUDE_JVMTI
1144   void adjust_default_methods(bool* trace_name_printed);
1145 #endif // INCLUDE_JVMTI
1146 
1147   void clean_weak_instanceklass_links();
1148  private:
1149   void clean_implementors_list();
1150   void clean_method_data();
1151 
1152  public:
1153   // Explicit metaspace deallocation of fields
1154   // For RedefineClasses and class file parsing errors, we need to deallocate
1155   // instanceKlasses and the metadata they point to.
1156   void deallocate_contents(ClassLoaderData* loader_data);
1157   static void deallocate_methods(ClassLoaderData* loader_data,
1158                                  Array&lt;Method*&gt;* methods);
1159   void static deallocate_interfaces(ClassLoaderData* loader_data,
1160                                     const Klass* super_klass,
1161                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1162                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);


1163 
1164   // The constant pool is on stack if any of the methods are executing or
1165   // referenced by handles.
1166   bool on_stack() const { return _constants-&gt;on_stack(); }
1167 
1168   // callbacks for actions during class unloading
1169   static void unload_class(InstanceKlass* ik);
1170   static void release_C_heap_structures(InstanceKlass* ik);
1171 
1172   // Naming
1173   const char* signature_name() const;
1174   static Symbol* package_from_name(const Symbol* name, TRAPS);
1175 
1176   // Oop fields (and metadata) iterators
1177   //
1178   // The InstanceKlass iterators also visits the Object&#39;s klass.
1179 
1180   // Forward iteration
1181  public:
1182   // Iterate over all oop fields in the oop maps.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 

  28 #include &quot;classfile/classLoaderData.hpp&quot;


  29 #include &quot;memory/referenceType.hpp&quot;
  30 #include &quot;oops/annotations.hpp&quot;
  31 #include &quot;oops/constMethod.hpp&quot;
  32 #include &quot;oops/fieldInfo.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/klassVtable.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;utilities/accessFlags.hpp&quot;
  38 #include &quot;utilities/align.hpp&quot;
  39 #include &quot;utilities/macros.hpp&quot;
  40 #if INCLUDE_JFR
  41 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  42 #endif
  43 
<span class="line-added">  44 class RecordComponent;</span>
  45 
  46 // An InstanceKlass is the VM level representation of a Java class.
  47 // It contains all information needed for at class at execution runtime.
  48 
  49 //  InstanceKlass embedded field layout (after declared fields):
  50 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  51 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  52 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  53 //      indicating where oops are located in instances of this klass.
  54 //    [EMBEDDED implementor of the interface] only exist for interface
  55 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  56 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  57 
  58 
  59 // forward declaration for class -- see below for definition
  60 #if INCLUDE_JVMTI
  61 class BreakpointInfo;
  62 #endif
  63 class ClassFileParser;
<span class="line-added">  64 class ClassFileStream;</span>
  65 class KlassDepChange;
  66 class DependencyContext;
  67 class fieldDescriptor;
  68 class jniIdMapBase;
  69 class JNIid;
  70 class JvmtiCachedClassFieldMap;
  71 class nmethodBucket;

  72 class OopMapCache;
  73 class InterpreterOopMap;
<span class="line-added">  74 class PackageEntry;</span>
<span class="line-added">  75 class ModuleEntry;</span>
  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
  93 #endif  // !PRODUCT
  94 
  95 // Describes where oops are located in instances of this klass.
  96 class OopMapBlock {
  97  public:
  98   // Byte offset of the first oop mapped by this block.
  99   int offset() const          { return _offset; }
 100   void set_offset(int offset) { _offset = offset; }
 101 
 102   // Number of oops in this block.
 103   uint count() const         { return _count; }
 104   void set_count(uint count) { _count = count; }
 105 
<span class="line-added"> 106   void increment_count(int diff) { _count += diff; }</span>
<span class="line-added"> 107 </span>
<span class="line-added"> 108   int offset_span() const { return _count * heapOopSize; }</span>
<span class="line-added"> 109 </span>
<span class="line-added"> 110   int end_offset() const {</span>
<span class="line-added"> 111     return offset() + offset_span();</span>
<span class="line-added"> 112   }</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114   bool is_contiguous(int another_offset) const {</span>
<span class="line-added"> 115     return another_offset == end_offset();</span>
<span class="line-added"> 116   }</span>
<span class="line-added"> 117 </span>
 118   // sizeof(OopMapBlock) in words.
 119   static const int size_in_words() {
 120     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 121       LogBytesPerWord;
 122   }
 123 
<span class="line-added"> 124   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {</span>
<span class="line-added"> 125     return a-&gt;offset() - b-&gt;offset();</span>
<span class="line-added"> 126   }</span>
<span class="line-added"> 127 </span>
 128  private:
 129   int  _offset;
 130   uint _count;
 131 };
 132 
 133 struct JvmtiCachedClassFileData;
 134 
 135 class InstanceKlass: public Klass {
 136   friend class VMStructs;
 137   friend class JVMCIVMStructs;
 138   friend class ClassFileParser;
 139   friend class CompileReplay;
 140 
 141  public:
 142   static const KlassID ID = InstanceKlassID;
 143 
 144  protected:
 145   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 146 
 147  public:
</pre>
<hr />
<pre>
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // The NestHost attribute. The class info index for the class
 195   // that is the nest-host of this class. This data has not been validated.
 196   jushort _nest_host_index;
 197 
 198   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 199   // By always being set it makes nest-member access checks simpler.
 200   InstanceKlass* _nest_host;
 201 
<span class="line-added"> 202   // The contents of the Record attribute.</span>
<span class="line-added"> 203   Array&lt;RecordComponent*&gt;* _record_components;</span>
<span class="line-added"> 204 </span>
 205   // the source debug extension for this klass, NULL if not specified.
 206   // Specified as UTF-8 string without terminating zero byte in the classfile,
 207   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 208   const char*     _source_debug_extension;
 209   // Array name derived from this class which needs unreferencing
 210   // if this class is unloaded.
 211   Symbol*         _array_name;
 212 
 213   // Number of heapOopSize words used by non-static fields in this klass
 214   // (including inherited fields but after header_size()).
 215   int             _nonstatic_field_size;
 216   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 217   // Constant pool index to the utf8 entry of the Generic signature,
 218   // or 0 if none.
 219   u2              _generic_signature_index;
 220   // Constant pool index to the utf8 entry for the name of source file
 221   // containing this klass, 0 if not specified.
 222   u2              _source_file_name_index;
 223   u2              _static_oop_field_count;// number of static oop fields in this klass
 224   u2              _java_fields_count;    // The number of declared Java fields
 225   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 226 
 227   int             _itable_len;           // length of Java itable (in words)
 228   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 229   // _misc_flags.
 230   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization

 231 
 232   // The low two bits of _misc_flags contains the kind field.
 233   // This can be used to quickly discriminate among the four kinds of
 234   // InstanceKlass.
 235 
 236   static const unsigned _misc_kind_field_size = 2;
 237   static const unsigned _misc_kind_field_pos  = 0;
 238   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 239 
 240   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 241   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 242   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 243   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 244 
 245   // Start after _misc_kind field.
 246   enum {
 247     _misc_rewritten                           = 1 &lt;&lt; 2,  // methods rewritten.
 248     _misc_has_nonstatic_fields                = 1 &lt;&lt; 3,  // for sizing with UseCompressedOops
 249     _misc_should_verify_class                 = 1 &lt;&lt; 4,  // allow caching of preverification
 250     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 5,  // has embedded _unsafe_anonymous_host field
 251     _misc_is_contended                        = 1 &lt;&lt; 6,  // marked with contended annotation
 252     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 7,  // class/superclass/implemented interfaces has non-static, concrete methods
 253     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 8,  // directly declares non-static, concrete methods
 254     _misc_has_been_redefined                  = 1 &lt;&lt; 9,  // class has been redefined
 255     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 10, // when this class was loaded, the fingerprint computed from its
 256                                                          // code source was found to be matching the value recorded by AOT.
 257     _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class
 258     _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader
 259     _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader
 260     _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader
<span class="line-modified"> 261     _misc_has_resolved_methods                = 1 &lt;&lt; 15, // resolved methods table entries added for this class</span>
<span class="line-added"> 262     _misc_is_being_redefined                  = 1 &lt;&lt; 16, // used for locking redefinition</span>
<span class="line-added"> 263     _misc_has_contended_annotations           = 1 &lt;&lt; 17  // has @Contended annotation</span>
 264   };
 265   u2 loader_type_bits() {
 266     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 267   }
<span class="line-modified"> 268   u4              _misc_flags;</span>
 269   u2              _minor_version;        // minor version number of class file
 270   u2              _major_version;        // major version number of class file
<span class="line-modified"> 271   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)</span>
 272   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 273   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 274   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 275   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 276   uint64_t        volatile _dep_context_last_cleaned;
 277   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 278 #if INCLUDE_JVMTI
 279   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 280   // Linked instanceKlasses of previous versions
 281   InstanceKlass* _previous_versions;
 282   // JVMTI fields can be moved to their own structure - see 6315920
 283   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 284   JvmtiCachedClassFileData* _cached_class_file;
 285 #endif
 286 
 287   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 288 
 289   // Class states are defined as ClassState (see above).
 290   // Place the _init_state here to utilize the unused 2-byte after
 291   // _idnum_allocated_count.
</pre>
<hr />
<pre>
 333   // embedded static fields follows here
 334   // embedded nonstatic oop-map blocks follows here
 335   // embedded implementor of this interface follows here
 336   //   The embedded implementor only exists if the current klass is an
 337   //   iterface. The possible values of the implementor fall into following
 338   //   three cases:
 339   //     NULL: no implementor.
 340   //     A Klass* that&#39;s not itself: one implementor.
 341   //     Itself: more than one implementors.
 342   // embedded unsafe_anonymous_host klass follows here
 343   //   The embedded host klass only exists in an unsafe anonymous class for
 344   //   dynamic language support (JSR 292 enabled). The host class grants
 345   //   its access privileges to this class also. The host class is either
 346   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 347   //   or an anonymous class loaded through normal classloading does not
 348   //   have this embedded field.
 349   //
 350 
 351   friend class SystemDictionary;
 352 
<span class="line-added"> 353   static bool _disable_method_binary_search;</span>
<span class="line-added"> 354 </span>
 355  public:
 356   u2 loader_type() {
 357     return _misc_flags &amp; loader_type_bits();
 358   }
 359 
 360   bool is_shared_boot_class() const {
 361     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 362   }
 363   bool is_shared_platform_class() const {
 364     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 365   }
 366   bool is_shared_app_class() const {
 367     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 368   }
 369 
 370   void clear_class_loader_type() {
 371     _misc_flags &amp;= ~loader_type_bits();
 372   }
 373 
<span class="line-modified"> 374   void set_class_loader_type(s2 loader_type);</span>















 375 
 376   bool has_nonstatic_fields() const        {
 377     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 378   }
 379   void set_has_nonstatic_fields(bool b)    {
 380     if (b) {
 381       _misc_flags |= _misc_has_nonstatic_fields;
 382     } else {
 383       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 384     }
 385   }
 386 
 387   // field sizes
 388   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 389   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 390 
 391   int static_field_size() const            { return _static_field_size; }
 392   void set_static_field_size(int size)     { _static_field_size = size; }
 393 
 394   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
</pre>
<hr />
<pre>
 452 
 453   Array&lt;u2&gt;* fields() const            { return _fields; }
 454   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 455     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 456     _fields = f;
 457     _java_fields_count = java_fields_count;
 458   }
 459 
 460   // inner classes
 461   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 462   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 463 
 464   // nest members
 465   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 466   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 467 
 468   // nest-host index
 469   jushort nest_host_index() const { return _nest_host_index; }
 470   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 471 
<span class="line-added"> 472   // record components</span>
<span class="line-added"> 473   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }</span>
<span class="line-added"> 474   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {</span>
<span class="line-added"> 475     _record_components = record_components;</span>
<span class="line-added"> 476   }</span>
<span class="line-added"> 477   bool is_record() const { return _record_components != NULL; }</span>
<span class="line-added"> 478 </span>
 479 private:
 480   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 481   bool has_nest_member(InstanceKlass* k, TRAPS) const;
<span class="line-added"> 482 </span>
 483 public:
 484   // Returns nest-host class, resolving and validating it if needed
 485   // Returns NULL if an exception occurs during loading, or validation fails
 486   InstanceKlass* nest_host(Symbol* validationException, TRAPS);
 487   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 488   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 489 
 490   enum InnerClassAttributeOffset {
 491     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 492     inner_class_inner_class_info_offset = 0,
 493     inner_class_outer_class_info_offset = 1,
 494     inner_class_inner_name_offset = 2,
 495     inner_class_access_flags_offset = 3,
 496     inner_class_next_offset = 4
 497   };
 498 
 499   enum EnclosingMethodAttributeOffset {
 500     enclosing_method_class_index_offset = 0,
 501     enclosing_method_method_index_offset = 1,
 502     enclosing_method_attribute_size = 2
</pre>
<hr />
<pre>
 571     assert(t == (u1)t, &quot;overflow&quot;);
 572     _reference_type = (u1)t;
 573   }
 574 
 575   // this class cp index
 576   u2 this_class_index() const             { return _this_class_index; }
 577   void set_this_class_index(u2 index)     { _this_class_index = index; }
 578 
 579   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 580 
 581   // find local field, returns true if found
 582   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 583   // find field in direct superinterfaces, returns the interface in which the field is defined
 584   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 585   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 586   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 587   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 588   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 589 
 590   // find a non-static or static field given its offset within the class.
<span class="line-modified"> 591   bool contains_field_offset(int offset);</span>


 592 
 593   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 594   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 595 
<span class="line-added"> 596  private:</span>
<span class="line-added"> 597   inline static int quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name);</span>
<span class="line-added"> 598 </span>
<span class="line-added"> 599  public:</span>
<span class="line-added"> 600   static void disable_method_binary_search() {</span>
<span class="line-added"> 601     _disable_method_binary_search = true;</span>
<span class="line-added"> 602   }</span>
<span class="line-added"> 603 </span>
 604   // find a local method (returns NULL if not found)
 605   Method* find_method(const Symbol* name, const Symbol* signature) const;
 606   static Method* find_method(const Array&lt;Method*&gt;* methods,
 607                              const Symbol* name,
 608                              const Symbol* signature);
 609 
 610   // find a local method, but skip static methods
 611   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 612                                PrivateLookupMode private_mode = find_private) const;
 613   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 614                                       const Symbol* name,
 615                                       const Symbol* signature,
 616                                       PrivateLookupMode private_mode = find_private);
 617 
 618   // find a local method (returns NULL if not found)
 619   Method* find_local_method(const Symbol* name,
 620                             const Symbol* signature,
 621                             OverpassLookupMode overpass_mode,
 622                             StaticLookupMode static_mode,
 623                             PrivateLookupMode private_mode) const;
</pre>
<hr />
<pre>
 733   // source debug extension
 734   const char* source_debug_extension() const { return _source_debug_extension; }
 735   void set_source_debug_extension(const char* array, int length);
 736 
 737   // symbol unloading support (refcount already added)
 738   Symbol* array_name()                     { return _array_name; }
 739   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }
 740 
 741   // nonstatic oop-map blocks
 742   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 743     return oop_map_count * OopMapBlock::size_in_words();
 744   }
 745   unsigned int nonstatic_oop_map_count() const {
 746     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 747   }
 748   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 749   void set_nonstatic_oop_map_size(int words) {
 750     _nonstatic_oop_map_size = words;
 751   }
 752 
<span class="line-added"> 753   bool has_contended_annotations() const {</span>
<span class="line-added"> 754     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);</span>
<span class="line-added"> 755   }</span>
<span class="line-added"> 756   void set_has_contended_annotations(bool value)  {</span>
<span class="line-added"> 757     if (value) {</span>
<span class="line-added"> 758       _misc_flags |= _misc_has_contended_annotations;</span>
<span class="line-added"> 759     } else {</span>
<span class="line-added"> 760       _misc_flags &amp;= ~_misc_has_contended_annotations;</span>
<span class="line-added"> 761     }</span>
<span class="line-added"> 762   }</span>
<span class="line-added"> 763 </span>
 764 #if INCLUDE_JVMTI
 765   // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-modified"> 766   bool is_being_redefined() const          {</span>
<span class="line-modified"> 767     return ((_misc_flags &amp; _misc_is_being_redefined) != 0);</span>
<span class="line-added"> 768   }</span>
<span class="line-added"> 769   void set_is_being_redefined(bool value)  {</span>
<span class="line-added"> 770     if (value) {</span>
<span class="line-added"> 771       _misc_flags |= _misc_is_being_redefined;</span>
<span class="line-added"> 772     } else {</span>
<span class="line-added"> 773       _misc_flags &amp;= ~_misc_is_being_redefined;</span>
<span class="line-added"> 774     }</span>
<span class="line-added"> 775   }</span>
 776 
 777   // RedefineClasses() support for previous versions:
 778   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 779   void purge_previous_version_list();
 780 
 781   InstanceKlass* previous_versions() const { return _previous_versions; }
 782 #else
 783   InstanceKlass* previous_versions() const { return NULL; }
 784 #endif
 785 
 786   InstanceKlass* get_klass_version(int version) {
 787     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 788       if (ik-&gt;constants()-&gt;version() == version) {
 789         return ik;
 790       }
 791     }
 792     return NULL;
 793   }
 794 
 795   bool has_been_redefined() const {
</pre>
<hr />
<pre>
1031   // subclass/subinterface checks
1032   bool implements_interface(Klass* k) const;
1033   bool is_same_or_direct_interface(Klass* k) const;
1034 
1035 #ifdef ASSERT
1036   // check whether this class or one of its superclasses was redefined
1037   bool has_redefined_this_or_super() const;
1038 #endif
1039 
1040   // Access to the implementor of an interface.
1041   Klass* implementor() const;
1042   void set_implementor(Klass* k);
1043   int  nof_implementors() const;
1044   void add_implementor(Klass* k);  // k is a new class that implements this interface
1045   void init_implementor();           // initialize
1046 
1047   // link this class into the implementors list of every interface it implements
1048   void process_interfaces(Thread *thread);
1049 
1050   // virtual operations from Klass

1051   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1052                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1053   bool can_be_primary_super_slow() const;
1054   int oop_size(oop obj)  const             { return size_helper(); }
1055   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1056   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1057   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1058 
1059   // Iterators
1060   void do_local_static_fields(FieldClosure* cl);
1061   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1062   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1063 
1064   void methods_do(void f(Method* method));
1065   void array_klasses_do(void f(Klass* k));
1066   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);

1067 
1068   static InstanceKlass* cast(Klass* k) {
1069     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1070   }
1071 
1072   static const InstanceKlass* cast(const Klass* k) {
1073     assert(k != NULL, &quot;k should not be null&quot;);
1074     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1075     return static_cast&lt;const InstanceKlass*&gt;(k);
1076   }
1077 
1078   virtual InstanceKlass* java_super() const {
1079     return (super() == NULL) ? NULL : cast(super());
1080   }
1081 
1082   // Sizing (in words)
1083   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1084 
1085   static int size(int vtable_length, int itable_length,
1086                   int nonstatic_oop_map_size,
1087                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {
1088     return align_metadata_size(header_size() +
1089            vtable_length +
1090            itable_length +
1091            nonstatic_oop_map_size +
1092            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1093            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1094            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));
1095   }
1096   int size() const                    { return size(vtable_length(),
1097                                                itable_length(),
1098                                                nonstatic_oop_map_size(),
1099                                                is_interface(),
1100                                                is_unsafe_anonymous(),
1101                                                has_stored_fingerprint());
1102   }



1103 
1104   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1105   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1106 
1107   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1108 
1109   oop static_field_base_raw() { return java_mirror(); }
1110 
1111   OopMapBlock* start_of_nonstatic_oop_maps() const {
1112     return (OopMapBlock*)(start_of_itable() + itable_length());
1113   }
1114 
1115   Klass** end_of_nonstatic_oop_maps() const {
1116     return (Klass**)(start_of_nonstatic_oop_maps() +
1117                      nonstatic_oop_map_count());
1118   }
1119 
1120   Klass* volatile* adr_implementor() const {
1121     if (is_interface()) {
1122       return (Klass* volatile*)end_of_nonstatic_oop_maps();
</pre>
<hr />
<pre>
1178 #if INCLUDE_JVMTI
1179   void adjust_default_methods(bool* trace_name_printed);
1180 #endif // INCLUDE_JVMTI
1181 
1182   void clean_weak_instanceklass_links();
1183  private:
1184   void clean_implementors_list();
1185   void clean_method_data();
1186 
1187  public:
1188   // Explicit metaspace deallocation of fields
1189   // For RedefineClasses and class file parsing errors, we need to deallocate
1190   // instanceKlasses and the metadata they point to.
1191   void deallocate_contents(ClassLoaderData* loader_data);
1192   static void deallocate_methods(ClassLoaderData* loader_data,
1193                                  Array&lt;Method*&gt;* methods);
1194   void static deallocate_interfaces(ClassLoaderData* loader_data,
1195                                     const Klass* super_klass,
1196                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1197                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
<span class="line-added">1198   void static deallocate_record_components(ClassLoaderData* loader_data,</span>
<span class="line-added">1199                                            Array&lt;RecordComponent*&gt;* record_component);</span>
1200 
1201   // The constant pool is on stack if any of the methods are executing or
1202   // referenced by handles.
1203   bool on_stack() const { return _constants-&gt;on_stack(); }
1204 
1205   // callbacks for actions during class unloading
1206   static void unload_class(InstanceKlass* ik);
1207   static void release_C_heap_structures(InstanceKlass* ik);
1208 
1209   // Naming
1210   const char* signature_name() const;
1211   static Symbol* package_from_name(const Symbol* name, TRAPS);
1212 
1213   // Oop fields (and metadata) iterators
1214   //
1215   // The InstanceKlass iterators also visits the Object&#39;s klass.
1216 
1217   // Forward iteration
1218  public:
1219   // Iterate over all oop fields in the oop maps.
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/klass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceRefKlass.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,42 +25,39 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  #include &quot;classfile/dictionary.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/moduleEntry.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/heapInspection.hpp&quot;</span>
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/oopHandle.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/stack.inline.hpp&quot;
  
  void Klass::set_java_mirror(Handle m) {
    assert(!m.is_null(), &quot;New mirror should never be null.&quot;);
    assert(_java_mirror.resolve() == NULL, &quot;should only be used to initialize mirror&quot;);
    _java_mirror = class_loader_data()-&gt;add_handle(m);
  }
  
<span class="udiff-line-removed">- oop Klass::java_mirror() const {</span>
<span class="udiff-line-removed">-   return _java_mirror.resolve();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  oop Klass::java_mirror_no_keepalive() const {
    return _java_mirror.peek();
  }
  
  bool Klass::is_cloneable() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -191,11 +188,11 @@</span>
  // which doesn&#39;t zero out the memory before calling the constructor.
  // Need to set the _java_mirror field explicitly to not hit an assert that the field
  // should be NULL before setting it.
  Klass::Klass(KlassID id) : _id(id),
                             _java_mirror(NULL),
<span class="udiff-line-modified-removed">-                            _prototype_header(markOopDesc::prototype()),</span>
<span class="udiff-line-modified-added">+                            _prototype_header(markWord::prototype()),</span>
                             _shared_class_path_index(-1) {
    CDS_ONLY(_shared_class_flags = 0;)
    CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)
    _primary_supers[0] = this;
    set_super_check_offset(in_bytes(primary_supers_offset()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -362,11 +359,11 @@</span>
  // May be cleaned concurrently, so must use the Compile_lock.
  // The log parameter is for clean_weak_klass_links to report unlinked classes.
  Klass* Klass::subklass(bool log) const {
    // Need load_acquire on the _subklass, because it races with inserts that
    // publishes freshly initialized data.
<span class="udiff-line-modified-removed">-   for (Klass* chain = OrderAccess::load_acquire(&amp;_subklass);</span>
<span class="udiff-line-modified-added">+   for (Klass* chain = Atomic::load_acquire(&amp;_subklass);</span>
         chain != NULL;
         // Do not need load_acquire on _next_sibling, because inserts never
         // create _next_sibling edges to dead data.
         chain = Atomic::load(&amp;chain-&gt;_next_sibling))
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,19 +399,19 @@</span>
    return NULL;
  }
  
  void Klass::set_subklass(Klass* s) {
    assert(s != this, &quot;sanity check&quot;);
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(&amp;_subklass, s);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(&amp;_subklass, s);</span>
  }
  
  void Klass::set_next_sibling(Klass* s) {
    assert(s != this, &quot;sanity check&quot;);
    // Does not need release semantics. If used by cleanup, it will link to
    // already safely published data, and if used by inserts, will be published
    // safely using cmpxchg.
<span class="udiff-line-modified-removed">-   Atomic::store(s, &amp;_next_sibling);</span>
<span class="udiff-line-modified-added">+   Atomic::store(&amp;_next_sibling, s);</span>
  }
  
  void Klass::append_to_sibling_list() {
    assert_locked_or_safepoint(Compile_lock);
    debug_only(verify();)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -427,35 +424,35 @@</span>
  
    // Make sure there is no stale subklass head
    super-&gt;clean_subklass();
  
    for (;;) {
<span class="udiff-line-modified-removed">-     Klass* prev_first_subklass = OrderAccess::load_acquire(&amp;_super-&gt;_subklass);</span>
<span class="udiff-line-modified-added">+     Klass* prev_first_subklass = Atomic::load_acquire(&amp;_super-&gt;_subklass);</span>
      if (prev_first_subklass != NULL) {
        // set our sibling to be the superklass&#39; previous first subklass
        assert(prev_first_subklass-&gt;is_loader_alive(), &quot;May not attach not alive klasses&quot;);
        set_next_sibling(prev_first_subklass);
      }
      // Note that the prev_first_subklass is always alive, meaning no sibling_next links
      // are ever created to not alive klasses. This is an important invariant of the lock-free
      // cleaning protocol, that allows us to safely unlink dead klasses from the sibling list.
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(this, &amp;super-&gt;_subklass, prev_first_subklass) == prev_first_subklass) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;super-&gt;_subklass, prev_first_subklass, this) == prev_first_subklass) {</span>
        return;
      }
    }
    debug_only(verify();)
  }
  
  void Klass::clean_subklass() {
    for (;;) {
      // Need load_acquire, due to contending with concurrent inserts
<span class="udiff-line-modified-removed">-     Klass* subklass = OrderAccess::load_acquire(&amp;_subklass);</span>
<span class="udiff-line-modified-added">+     Klass* subklass = Atomic::load_acquire(&amp;_subklass);</span>
      if (subklass == NULL || subklass-&gt;is_loader_alive()) {
        return;
      }
      // Try to fix _subklass until it points at something not dead.
<span class="udiff-line-modified-removed">-     Atomic::cmpxchg(subklass-&gt;next_sibling(), &amp;_subklass, subklass);</span>
<span class="udiff-line-modified-added">+     Atomic::cmpxchg(&amp;_subklass, subklass, subklass-&gt;next_sibling());</span>
    }
  }
  
  void Klass::clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses) {
    if (!ClassUnloading || !unloading_occurred) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -521,11 +518,12 @@</span>
      it-&gt;push(vt[i].method_addr());
    }
  }
  
  void Klass::remove_unshareable_info() {
<span class="udiff-line-modified-removed">-   assert (DumpSharedSpaces, &quot;only called for DumpSharedSpaces&quot;);</span>
<span class="udiff-line-modified-added">+   assert (Arguments::is_dumping_archive(),</span>
<span class="udiff-line-added">+           &quot;only called during CDS dump time&quot;);</span>
    JFR_ONLY(REMOVE_ID(this);)
    if (log_is_enabled(Trace, cds, unshareable)) {
      ResourceMark rm;
      log_trace(cds, unshareable)(&quot;remove: %s&quot;, external_name());
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -538,11 +536,11 @@</span>
    set_class_loader_data(NULL);
    set_is_shared();
  }
  
  void Klass::remove_java_mirror() {
<span class="udiff-line-modified-removed">-   assert (DumpSharedSpaces, &quot;only called for DumpSharedSpaces&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
    if (log_is_enabled(Trace, cds, unshareable)) {
      ResourceMark rm;
      log_trace(cds, unshareable)(&quot;remove java_mirror: %s&quot;, external_name());
    }
    // Just null out the mirror.  The class_loader_data() no longer exists.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,11 +550,11 @@</span>
  void Klass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
    assert(is_klass(), &quot;ensure C++ vtable is restored&quot;);
    assert(is_shared(), &quot;must be set&quot;);
    JFR_ONLY(RESTORE_ID(this);)
    if (log_is_enabled(Trace, cds, unshareable)) {
<span class="udiff-line-modified-removed">-     ResourceMark rm;</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
      log_trace(cds, unshareable)(&quot;restore: %s&quot;, external_name());
    }
  
    // If an exception happened during CDS restore, some of these fields may already be
    // set.  We leave the class on the CLD list, even if incomplete so that we don&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -585,11 +583,11 @@</span>
    }
    // Obtain java.lang.Module, if available
    Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL));
  
    if (this-&gt;has_raw_archived_mirror()) {
<span class="udiff-line-modified-removed">-     ResourceMark rm;</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
      log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
      if (HeapShared::open_archive_heap_region_mapped()) {
        bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
                                                                protection_domain,
                                                                CHECK);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -670,12 +668,10 @@</span>
    } else if (length &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
    }
  }
  
<span class="udiff-line-removed">- oop Klass::class_loader() const { return class_loader_data()-&gt;class_loader(); }</span>
<span class="udiff-line-removed">- </span>
  // In product mode, this function doesn&#39;t have virtual function calls so
  // there might be some performance advantage to handling InstanceKlass here.
  const char* Klass::external_name() const {
    if (is_instance_klass()) {
      const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -711,11 +707,11 @@</span>
  jint Klass::compute_modifier_flags(TRAPS) const {
    return 0;
  }
  
  int Klass::atomic_incr_biased_lock_revocation_count() {
<span class="udiff-line-modified-removed">-   return (int) Atomic::add(1, &amp;_biased_lock_revocation_count);</span>
<span class="udiff-line-modified-added">+   return (int) Atomic::add(&amp;_biased_lock_revocation_count, 1);</span>
  }
  
  // Unless overridden, jvmti_class_status has no flags set.
  jint Klass::jvmti_class_status() const {
    return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -730,23 +726,27 @@</span>
    st-&gt;print(&quot;%s&quot;, internal_name());
    print_address_on(st);
    st-&gt;cr();
  }
  
<span class="udiff-line-added">+ #define BULLET  &quot; - &quot;</span>
<span class="udiff-line-added">+ </span>
  void Klass::oop_print_on(oop obj, outputStream* st) {
<span class="udiff-line-removed">-   ResourceMark rm;</span>
    // print title
    st-&gt;print_cr(&quot;%s &quot;, internal_name());
    obj-&gt;print_address_on(st);
  
    if (WizardMode) {
       // print header
<span class="udiff-line-modified-removed">-      obj-&gt;mark()-&gt;print_on(st);</span>
<span class="udiff-line-modified-added">+      obj-&gt;mark().print_on(st);</span>
<span class="udiff-line-added">+      st-&gt;cr();</span>
<span class="udiff-line-added">+      st-&gt;print(BULLET&quot;prototype_header: &quot; INTPTR_FORMAT, _prototype_header.value());</span>
<span class="udiff-line-added">+      st-&gt;cr();</span>
    }
  
    // print class
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot; - klass: &quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;klass: &quot;);</span>
    obj-&gt;klass()-&gt;print_value_on(st);
    st-&gt;cr();
  }
  
  void Klass::oop_print_value_on(oop obj, outputStream* st) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -754,22 +754,10 @@</span>
    ResourceMark rm;              // Cannot print in debug mode without this
    st-&gt;print(&quot;%s&quot;, internal_name());
    obj-&gt;print_address_on(st);
  }
  
<span class="udiff-line-removed">- #if INCLUDE_SERVICES</span>
<span class="udiff-line-removed">- // Size Statistics</span>
<span class="udiff-line-removed">- void Klass::collect_statistics(KlassSizeStats *sz) const {</span>
<span class="udiff-line-removed">-   sz-&gt;_klass_bytes = sz-&gt;count(this);</span>
<span class="udiff-line-removed">-   sz-&gt;_mirror_bytes = sz-&gt;count(java_mirror());</span>
<span class="udiff-line-removed">-   sz-&gt;_secondary_supers_bytes = sz-&gt;count_array(secondary_supers());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   sz-&gt;_ro_bytes += sz-&gt;_secondary_supers_bytes;</span>
<span class="udiff-line-removed">-   sz-&gt;_rw_bytes += sz-&gt;_klass_bytes + sz-&gt;_mirror_bytes;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_SERVICES</span>
<span class="udiff-line-removed">- </span>
  // Verification
  
  void Klass::verify_on(outputStream* st) {
  
    // This can be expensive, but it is worth checking that this klass is actually
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -800,47 +788,31 @@</span>
  void Klass::oop_verify_on(oop obj, outputStream* st) {
    guarantee(oopDesc::is_oop(obj),  &quot;should be oop&quot;);
    guarantee(obj-&gt;klass()-&gt;is_klass(), &quot;klass field is not a klass&quot;);
  }
  
<span class="udiff-line-removed">- Klass* Klass::decode_klass_raw(narrowKlass narrow_klass) {</span>
<span class="udiff-line-removed">-   return (Klass*)(void*)( (uintptr_t)Universe::narrow_klass_base() +</span>
<span class="udiff-line-removed">-                          ((uintptr_t)narrow_klass &lt;&lt; Universe::narrow_klass_shift()));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool Klass::is_valid(Klass* k) {
    if (!is_aligned(k, sizeof(MetaWord))) return false;
    if ((size_t)k &lt; os::min_page_size()) return false;
  
    if (!os::is_readable_range(k, k + 1)) return false;
<span class="udiff-line-modified-removed">-   if (!MetaspaceUtils::is_range_in_committed(k, k + 1)) return false;</span>
<span class="udiff-line-modified-added">+   if (!Metaspace::contains(k)) return false;</span>
  
    if (!Symbol::is_valid(k-&gt;name())) return false;
    return ClassLoaderDataGraph::is_valid(k-&gt;class_loader_data());
  }
  
<span class="udiff-line-removed">- klassVtable Klass::vtable() const {</span>
<span class="udiff-line-removed">-   return klassVtable(const_cast&lt;Klass*&gt;(this), start_of_vtable(), vtable_length() / vtableEntry::size());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- vtableEntry* Klass::start_of_vtable() const {</span>
<span class="udiff-line-removed">-   return (vtableEntry*) ((address)this + in_bytes(vtable_start_offset()));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  Method* Klass::method_at_vtable(int index)  {
  #ifndef PRODUCT
    assert(index &gt;= 0, &quot;valid vtable index&quot;);
    if (DebugVtables) {
      verify_vtable_index(index);
    }
  #endif
    return start_of_vtable()[index].method();
  }
  
<span class="udiff-line-removed">- ByteSize Klass::vtable_start_offset() {</span>
<span class="udiff-line-removed">-   return in_ByteSize(InstanceKlass::header_size() * wordSize);</span>
<span class="udiff-line-removed">- }</span>
  
  #ifndef PRODUCT
  
  bool Klass::verify_vtable_index(int i) {
    int limit = vtable_length()/vtableEntry::size();
</pre>
<center><a href="instanceRefKlass.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
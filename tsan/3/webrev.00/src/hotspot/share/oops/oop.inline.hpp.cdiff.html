<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,94 ***</span>
  
  #ifndef SHARE_OOPS_OOP_INLINE_HPP
  #define SHARE_OOPS_OOP_INLINE_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/arrayKlass.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.inline.hpp&quot;</span>
  #include &quot;oops/oop.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // Implementation of all inlined member functions defined in oop.hpp
  // We need a separate file to avoid circular references
  
<span class="line-modified">! markOop  oopDesc::mark()      const {</span>
<span class="line-modified">!   return HeapAccess&lt;MO_VOLATILE&gt;::load_at(as_oop(), mark_offset_in_bytes());</span>
  }
  
<span class="line-modified">! markOop  oopDesc::mark_raw()  const {</span>
<span class="line-modified">!   return _mark;</span>
  }
  
<span class="line-modified">! markOop* oopDesc::mark_addr_raw() const {</span>
<span class="line-modified">!   return (markOop*) &amp;_mark;</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark(volatile markOop m) {</span>
<span class="line-modified">!   HeapAccess&lt;MO_VOLATILE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m);</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark_raw(volatile markOop m) {</span>
<span class="line-modified">!   _mark = m;</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark_raw(HeapWord* mem, markOop m) {</span>
<span class="line-modified">!   *(markOop*)(((char*)mem) + mark_offset_in_bytes()) = m;</span>
  }
  
<span class="line-modified">! void oopDesc::release_set_mark(markOop m) {</span>
<span class="line-modified">!   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m);</span>
  }
  
<span class="line-modified">! markOop oopDesc::cas_set_mark(markOop new_mark, markOop old_mark) {</span>
<span class="line-modified">!   return HeapAccess&lt;&gt;::atomic_cmpxchg_at(new_mark, as_oop(), mark_offset_in_bytes(), old_mark);</span>
  }
  
<span class="line-modified">! markOop oopDesc::cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order) {</span>
<span class="line-modified">!   return Atomic::cmpxchg(new_mark, &amp;_mark, old_mark, order);</span>
  }
  
  void oopDesc::init_mark() {
<span class="line-modified">!   set_mark(markOopDesc::prototype_for_object(this));</span>
  }
  
  void oopDesc::init_mark_raw() {
<span class="line-modified">!   set_mark_raw(markOopDesc::prototype_for_object(this));</span>
  }
  
  Klass* oopDesc::klass() const {
    if (UseCompressedClassPointers) {
<span class="line-modified">!     return Klass::decode_klass_not_null(_metadata._compressed_klass);</span>
    } else {
      return _metadata._klass;
    }
  }
  
  Klass* oopDesc::klass_or_null() const volatile {
    if (UseCompressedClassPointers) {
<span class="line-modified">!     return Klass::decode_klass(_metadata._compressed_klass);</span>
    } else {
      return _metadata._klass;
    }
  }
  
  Klass* oopDesc::klass_or_null_acquire() const volatile {
    if (UseCompressedClassPointers) {
      // Workaround for non-const load_acquire parameter.
      const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
      volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">!     return Klass::decode_klass(OrderAccess::load_acquire(xaddr));</span>
    } else {
<span class="line-modified">!     return OrderAccess::load_acquire(&amp;_metadata._klass);</span>
    }
  }
  
  Klass** oopDesc::klass_addr(HeapWord* mem) {
    // Only used internally and with CMS and will not work with
<span class="line-new-header">--- 24,96 ---</span>
  
  #ifndef SHARE_OOPS_OOP_INLINE_HPP
  #define SHARE_OOPS_OOP_INLINE_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/arrayKlass.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/markWord.inline.hpp&quot;</span>
  #include &quot;oops/oop.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // Implementation of all inlined member functions defined in oop.hpp
  // We need a separate file to avoid circular references
  
<span class="line-modified">! markWord oopDesc::mark() const {</span>
<span class="line-modified">!   uintptr_t v = HeapAccess&lt;MO_VOLATILE&gt;::load_at(as_oop(), mark_offset_in_bytes());</span>
<span class="line-added">+   return markWord(v);</span>
  }
  
<span class="line-modified">! markWord oopDesc::mark_raw() const {</span>
<span class="line-modified">!   return Atomic::load(&amp;_mark);</span>
  }
  
<span class="line-modified">! markWord* oopDesc::mark_addr_raw() const {</span>
<span class="line-modified">!   return (markWord*) &amp;_mark;</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark(markWord m) {</span>
<span class="line-modified">!   HeapAccess&lt;MO_VOLATILE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark_raw(markWord m) {</span>
<span class="line-modified">!   Atomic::store(&amp;_mark, m);</span>
  }
  
<span class="line-modified">! void oopDesc::set_mark_raw(HeapWord* mem, markWord m) {</span>
<span class="line-modified">!   *(markWord*)(((char*)mem) + mark_offset_in_bytes()) = m;</span>
  }
  
<span class="line-modified">! void oopDesc::release_set_mark(markWord m) {</span>
<span class="line-modified">!   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());</span>
  }
  
<span class="line-modified">! markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {</span>
<span class="line-modified">!   uintptr_t v = HeapAccess&lt;&gt;::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());</span>
<span class="line-added">+   return markWord(v);</span>
  }
  
<span class="line-modified">! markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {</span>
<span class="line-modified">!   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);</span>
  }
  
  void oopDesc::init_mark() {
<span class="line-modified">!   set_mark(markWord::prototype_for_klass(klass()));</span>
  }
  
  void oopDesc::init_mark_raw() {
<span class="line-modified">!   set_mark_raw(markWord::prototype_for_klass(klass()));</span>
  }
  
  Klass* oopDesc::klass() const {
    if (UseCompressedClassPointers) {
<span class="line-modified">!     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);</span>
    } else {
      return _metadata._klass;
    }
  }
  
  Klass* oopDesc::klass_or_null() const volatile {
    if (UseCompressedClassPointers) {
<span class="line-modified">!     return CompressedKlassPointers::decode(_metadata._compressed_klass);</span>
    } else {
      return _metadata._klass;
    }
  }
  
  Klass* oopDesc::klass_or_null_acquire() const volatile {
    if (UseCompressedClassPointers) {
      // Workaround for non-const load_acquire parameter.
      const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
      volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">!     return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));</span>
    } else {
<span class="line-modified">!     return Atomic::load_acquire(&amp;_metadata._klass);</span>
    }
  }
  
  Klass** oopDesc::klass_addr(HeapWord* mem) {
    // Only used internally and with CMS and will not work with
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,23 ***</span>
    } while (0)
  
  void oopDesc::set_klass(Klass* k) {
    CHECK_SET_KLASS(k);
    if (UseCompressedClassPointers) {
<span class="line-modified">!     *compressed_klass_addr() = Klass::encode_klass_not_null(k);</span>
    } else {
      *klass_addr() = k;
    }
  }
  
  void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
    CHECK_SET_KLASS(klass);
    if (UseCompressedClassPointers) {
<span class="line-modified">!     OrderAccess::release_store(compressed_klass_addr(mem),</span>
<span class="line-modified">!                                Klass::encode_klass_not_null(klass));</span>
    } else {
<span class="line-modified">!     OrderAccess::release_store(klass_addr(mem), klass);</span>
    }
  }
  
  #undef CHECK_SET_KLASS
  
<span class="line-new-header">--- 144,23 ---</span>
    } while (0)
  
  void oopDesc::set_klass(Klass* k) {
    CHECK_SET_KLASS(k);
    if (UseCompressedClassPointers) {
<span class="line-modified">!     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);</span>
    } else {
      *klass_addr() = k;
    }
  }
  
  void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
    CHECK_SET_KLASS(klass);
    if (UseCompressedClassPointers) {
<span class="line-modified">!     Atomic::release_store(compressed_klass_addr(mem),</span>
<span class="line-modified">!                           CompressedKlassPointers::encode_not_null(klass));</span>
    } else {
<span class="line-modified">!     Atomic::release_store(klass_addr(mem), klass);</span>
    }
  }
  
  #undef CHECK_SET_KLASS
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,30 ***</span>
  
  void oopDesc::set_klass_gap(int v) {
    set_klass_gap((HeapWord*)this, v);
  }
  
<span class="line-removed">- void oopDesc::set_klass_to_list_ptr(oop k) {</span>
<span class="line-removed">-   // This is only to be used during GC, for from-space objects, so no</span>
<span class="line-removed">-   // barrier is needed.</span>
<span class="line-removed">-   if (UseCompressedClassPointers) {</span>
<span class="line-removed">-     _metadata._compressed_klass = (narrowKlass)CompressedOops::encode(k);  // may be null (parnew overflow handling)</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _metadata._klass = (Klass*)(address)k;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- oop oopDesc::list_ptr_from_klass() {</span>
<span class="line-removed">-   // This is only to be used during GC, for from-space objects.</span>
<span class="line-removed">-   if (UseCompressedClassPointers) {</span>
<span class="line-removed">-     return CompressedOops::decode((narrowOop)_metadata._compressed_klass);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // Special case for GC</span>
<span class="line-removed">-     return (oop)(address)_metadata._klass;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool oopDesc::is_a(Klass* k) const {
    return klass()-&gt;is_subtype_of(k);
  }
  
  int oopDesc::size()  {
<span class="line-new-header">--- 176,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,29 ***</span>
        // This code could be simplified, but by keeping array_header_in_bytes
        // in units of bytes and doing it this way we can round up just once,
        // skipping the intermediate round to HeapWordSize.
        s = (int)(align_up(size_in_bytes, MinObjAlignmentInBytes) / HeapWordSize);
  
<span class="line-modified">!       // ParNew (used by CMS), UseParallelGC and UseG1GC can change the length field</span>
        // of an &quot;old copy&quot; of an object array in the young gen so it indicates
        // the grey portion of an already copied array. This will cause the first
        // disjunct below to fail if the two comparands are computed across such
        // a concurrent change.
<span class="line-removed">-       // ParNew also runs with promotion labs (which look like int</span>
<span class="line-removed">-       // filler arrays) which are subject to changing their declared size</span>
<span class="line-removed">-       // when finally retiring a PLAB; this also can cause the first disjunct</span>
<span class="line-removed">-       // to fail for another worker thread that is concurrently walking the block</span>
<span class="line-removed">-       // offset table. Both these invariant failures are benign for their</span>
<span class="line-removed">-       // current uses; we relax the assertion checking to cover these two cases below:</span>
<span class="line-removed">-       //     is_objArray() &amp;&amp; is_forwarded()   // covers first scenario above</span>
<span class="line-removed">-       //  || is_typeArray()                    // covers second scenario above</span>
<span class="line-removed">-       // If and when UseParallelGC uses the same obj array oop stealing/chunking</span>
<span class="line-removed">-       // technique, we will need to suitably modify the assertion.</span>
        assert((s == klass-&gt;oop_size(this)) ||
<span class="line-modified">!              (Universe::heap()-&gt;is_gc_active() &amp;&amp;</span>
<span class="line-removed">-               ((is_typeArray() &amp;&amp; UseConcMarkSweepGC) ||</span>
<span class="line-removed">-                (is_objArray()  &amp;&amp; is_forwarded() &amp;&amp; (UseConcMarkSweepGC || UseParallelGC || UseG1GC)))),</span>
               &quot;wrong array object size&quot;);
      } else {
        // Must be zero, so bite the bullet and take the virtual call.
        s = klass-&gt;oop_size(this);
      }
<span class="line-new-header">--- 221,17 ---</span>
        // This code could be simplified, but by keeping array_header_in_bytes
        // in units of bytes and doing it this way we can round up just once,
        // skipping the intermediate round to HeapWordSize.
        s = (int)(align_up(size_in_bytes, MinObjAlignmentInBytes) / HeapWordSize);
  
<span class="line-modified">!       // UseParallelGC and UseG1GC can change the length field</span>
        // of an &quot;old copy&quot; of an object array in the young gen so it indicates
        // the grey portion of an already copied array. This will cause the first
        // disjunct below to fail if the two comparands are computed across such
        // a concurrent change.
        assert((s == klass-&gt;oop_size(this)) ||
<span class="line-modified">!              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),</span>
               &quot;wrong array object size&quot;);
      } else {
        // Must be zero, so bite the bullet and take the virtual call.
        s = klass-&gt;oop_size(this);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,13 ***</span>
  inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
<span class="line-modified">! inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);                }</span>
  inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }
<span class="line-modified">! </span>
  inline jshort oopDesc::short_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  inline jint oopDesc::int_field(int offset) const                    { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline jint oopDesc::int_field_raw(int offset) const                { return RawAccess&lt;&gt;::load_at(as_oop(), offset);   }
<span class="line-new-header">--- 266,14 ---</span>
  inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
<span class="line-modified">! inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess&lt;&gt;::load_at(as_oop(), offset); }</span>
  inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }
<span class="line-modified">! inline jboolean oopDesc::bool_field_volatile(int offset) const      { return HeapAccess&lt;MO_SEQ_CST&gt;::load_at(as_oop(), offset); }</span>
<span class="line-added">+ inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { HeapAccess&lt;MO_SEQ_CST&gt;::store_at(as_oop(), offset, jboolean(value &amp; 1)); }</span>
  inline jshort oopDesc::short_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  inline jint oopDesc::int_field(int offset) const                    { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline jint oopDesc::int_field_raw(int offset) const                { return RawAccess&lt;&gt;::load_at(as_oop(), offset);   }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,110 ***</span>
  
  inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  bool oopDesc::is_locked() const {
<span class="line-modified">!   return mark()-&gt;is_locked();</span>
  }
  
  bool oopDesc::is_unlocked() const {
<span class="line-modified">!   return mark()-&gt;is_unlocked();</span>
  }
  
  bool oopDesc::has_bias_pattern() const {
<span class="line-modified">!   return mark()-&gt;has_bias_pattern();</span>
  }
  
  bool oopDesc::has_bias_pattern_raw() const {
<span class="line-modified">!   return mark_raw()-&gt;has_bias_pattern();</span>
  }
  
  // Used only for markSweep, scavenging
  bool oopDesc::is_gc_marked() const {
<span class="line-modified">!   return mark_raw()-&gt;is_marked();</span>
  }
  
  // Used by scavengers
  bool oopDesc::is_forwarded() const {
    // The extra heap check is needed since the obj might be locked, in which case the
    // mark would point to a stack location and have the sentinel bit cleared
<span class="line-modified">!   return mark_raw()-&gt;is_marked();</span>
  }
  
  // Used by scavengers
  void oopDesc::forward_to(oop p) {
<span class="line-modified">!   assert(check_obj_alignment(p),</span>
<span class="line-modified">!          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">-          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">-   assert(!is_archived_object(oop(this)) &amp;&amp;</span>
<span class="line-removed">-          !is_archived_object(p),</span>
<span class="line-removed">-          &quot;forwarding archive object&quot;);</span>
<span class="line-removed">-   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">-   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
    set_mark_raw(m);
  }
  
  // Used by parallel scavengers
<span class="line-modified">! bool oopDesc::cas_forward_to(oop p, markOop compare, atomic_memory_order order) {</span>
<span class="line-modified">!   assert(check_obj_alignment(p),</span>
<span class="line-modified">!          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">-          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">-   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">-   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
    return cas_set_mark_raw(m, compare, order) == compare;
  }
  
<span class="line-modified">! oop oopDesc::forward_to_atomic(oop p, markOop compare, atomic_memory_order order) {</span>
<span class="line-modified">!   // CMS forwards some non-heap value into the mark oop to reserve oops during</span>
<span class="line-modified">!   // promotion, so the next two asserts do not hold.</span>
<span class="line-modified">!   assert(UseConcMarkSweepGC || check_obj_alignment(p),</span>
<span class="line-modified">!          &quot;forwarding to something not aligned&quot;);</span>
<span class="line-removed">-   assert(UseConcMarkSweepGC || Universe::heap()-&gt;is_in_reserved(p),</span>
<span class="line-removed">-          &quot;forwarding to something not in heap&quot;);</span>
<span class="line-removed">-   markOop m = markOopDesc::encode_pointer_as_mark(p);</span>
<span class="line-removed">-   assert(m-&gt;decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
<span class="line-removed">-   markOop old_mark = cas_set_mark_raw(m, compare, order);</span>
    if (old_mark == compare) {
      return NULL;
    } else {
<span class="line-modified">!     return (oop)old_mark-&gt;decode_pointer();</span>
    }
  }
  
  // Note that the forwardee is not the same thing as the displaced_mark.
  // The forwardee is used when copying during scavenge and mark-sweep.
  // It does need to clear the low two locking- and GC-related bits.
  oop oopDesc::forwardee() const {
<span class="line-modified">!   return (oop) mark_raw()-&gt;decode_pointer();</span>
  }
  
  // Note that the forwardee is not the same thing as the displaced_mark.
  // The forwardee is used when copying during scavenge and mark-sweep.
  // It does need to clear the low two locking- and GC-related bits.
  oop oopDesc::forwardee_acquire() const {
<span class="line-modified">!   markOop m = OrderAccess::load_acquire(&amp;_mark);</span>
<span class="line-removed">-   return (oop) m-&gt;decode_pointer();</span>
  }
  
  // The following method needs to be MT safe.
  uint oopDesc::age() const {
    assert(!is_forwarded(), &quot;Attempt to read age from forwarded mark&quot;);
    if (has_displaced_mark_raw()) {
<span class="line-modified">!     return displaced_mark_raw()-&gt;age();</span>
    } else {
<span class="line-modified">!     return mark_raw()-&gt;age();</span>
    }
  }
  
  void oopDesc::incr_age() {
    assert(!is_forwarded(), &quot;Attempt to increment age of forwarded mark&quot;);
    if (has_displaced_mark_raw()) {
<span class="line-modified">!     set_displaced_mark_raw(displaced_mark_raw()-&gt;incr_age());</span>
    } else {
<span class="line-modified">!     set_mark_raw(mark_raw()-&gt;incr_age());</span>
    }
  }
  
  template &lt;typename OopClosureType&gt;
  void oopDesc::oop_iterate(OopClosureType* cl) {
<span class="line-new-header">--- 287,95 ---</span>
  
  inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
  inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
  
  bool oopDesc::is_locked() const {
<span class="line-modified">!   return mark().is_locked();</span>
  }
  
  bool oopDesc::is_unlocked() const {
<span class="line-modified">!   return mark().is_unlocked();</span>
  }
  
  bool oopDesc::has_bias_pattern() const {
<span class="line-modified">!   return mark().has_bias_pattern();</span>
  }
  
  bool oopDesc::has_bias_pattern_raw() const {
<span class="line-modified">!   return mark_raw().has_bias_pattern();</span>
  }
  
  // Used only for markSweep, scavenging
  bool oopDesc::is_gc_marked() const {
<span class="line-modified">!   return mark_raw().is_marked();</span>
  }
  
  // Used by scavengers
  bool oopDesc::is_forwarded() const {
    // The extra heap check is needed since the obj might be locked, in which case the
    // mark would point to a stack location and have the sentinel bit cleared
<span class="line-modified">!   return mark_raw().is_marked();</span>
  }
  
  // Used by scavengers
  void oopDesc::forward_to(oop p) {
<span class="line-modified">!   verify_forwardee(p);</span>
<span class="line-modified">!   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">!   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
    set_mark_raw(m);
  }
  
  // Used by parallel scavengers
<span class="line-modified">! bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {</span>
<span class="line-modified">!   verify_forwardee(p);</span>
<span class="line-modified">!   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">!   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
    return cas_set_mark_raw(m, compare, order) == compare;
  }
  
<span class="line-modified">! oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {</span>
<span class="line-modified">!   verify_forwardee(p);</span>
<span class="line-modified">!   markWord m = markWord::encode_pointer_as_mark(p);</span>
<span class="line-modified">!   assert(m.decode_pointer() == p, &quot;encoding must be reversable&quot;);</span>
<span class="line-modified">!   markWord old_mark = cas_set_mark_raw(m, compare, order);</span>
    if (old_mark == compare) {
      return NULL;
    } else {
<span class="line-modified">!     return (oop)old_mark.decode_pointer();</span>
    }
  }
  
  // Note that the forwardee is not the same thing as the displaced_mark.
  // The forwardee is used when copying during scavenge and mark-sweep.
  // It does need to clear the low two locking- and GC-related bits.
  oop oopDesc::forwardee() const {
<span class="line-modified">!   return (oop) mark_raw().decode_pointer();</span>
  }
  
  // Note that the forwardee is not the same thing as the displaced_mark.
  // The forwardee is used when copying during scavenge and mark-sweep.
  // It does need to clear the low two locking- and GC-related bits.
  oop oopDesc::forwardee_acquire() const {
<span class="line-modified">!   return (oop) Atomic::load_acquire(&amp;_mark).decode_pointer();</span>
  }
  
  // The following method needs to be MT safe.
  uint oopDesc::age() const {
    assert(!is_forwarded(), &quot;Attempt to read age from forwarded mark&quot;);
    if (has_displaced_mark_raw()) {
<span class="line-modified">!     return displaced_mark_raw().age();</span>
    } else {
<span class="line-modified">!     return mark_raw().age();</span>
    }
  }
  
  void oopDesc::incr_age() {
    assert(!is_forwarded(), &quot;Attempt to increment age of forwarded mark&quot;);
    if (has_displaced_mark_raw()) {
<span class="line-modified">!     set_displaced_mark_raw(displaced_mark_raw().incr_age());</span>
    } else {
<span class="line-modified">!     set_mark_raw(mark_raw().incr_age());</span>
    }
  }
  
  template &lt;typename OopClosureType&gt;
  void oopDesc::oop_iterate(OopClosureType* cl) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,28 ***</span>
  }
  
  intptr_t oopDesc::identity_hash() {
    // Fast case; if the object is unlocked and the hash value is set, no locking is needed
    // Note: The mark must be read into local variable to avoid concurrent updates.
<span class="line-modified">!   markOop mrk = mark();</span>
<span class="line-modified">!   if (mrk-&gt;is_unlocked() &amp;&amp; !mrk-&gt;has_no_hash()) {</span>
<span class="line-modified">!     return mrk-&gt;hash();</span>
<span class="line-modified">!   } else if (mrk-&gt;is_marked()) {</span>
<span class="line-modified">!     return mrk-&gt;hash();</span>
    } else {
      return slow_identity_hash();
    }
  }
  
  bool oopDesc::has_displaced_mark_raw() const {
<span class="line-modified">!   return mark_raw()-&gt;has_displaced_mark_helper();</span>
  }
  
<span class="line-modified">! markOop oopDesc::displaced_mark_raw() const {</span>
<span class="line-modified">!   return mark_raw()-&gt;displaced_mark_helper();</span>
  }
  
<span class="line-modified">! void oopDesc::set_displaced_mark_raw(markOop m) {</span>
<span class="line-modified">!   mark_raw()-&gt;set_displaced_mark_helper(m);</span>
  }
  
  #endif // SHARE_OOPS_OOP_INLINE_HPP
<span class="line-new-header">--- 413,58 ---</span>
  }
  
  intptr_t oopDesc::identity_hash() {
    // Fast case; if the object is unlocked and the hash value is set, no locking is needed
    // Note: The mark must be read into local variable to avoid concurrent updates.
<span class="line-modified">!   markWord mrk = mark();</span>
<span class="line-modified">!   if (mrk.is_unlocked() &amp;&amp; !mrk.has_no_hash()) {</span>
<span class="line-modified">!     return mrk.hash();</span>
<span class="line-modified">!   } else if (mrk.is_marked()) {</span>
<span class="line-modified">!     return mrk.hash();</span>
    } else {
      return slow_identity_hash();
    }
  }
  
  bool oopDesc::has_displaced_mark_raw() const {
<span class="line-modified">!   return mark_raw().has_displaced_mark_helper();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ markWord oopDesc::displaced_mark_raw() const {</span>
<span class="line-added">+   return mark_raw().displaced_mark_helper();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void oopDesc::set_displaced_mark_raw(markWord m) {</span>
<span class="line-added">+   mark_raw().set_displaced_mark_helper(m);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Supports deferred calling of obj-&gt;klass().</span>
<span class="line-added">+ class DeferredObjectToKlass {</span>
<span class="line-added">+   const oopDesc* _obj;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   DeferredObjectToKlass(const oopDesc* obj) : _obj(obj) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Implicitly convertible to const Klass*.</span>
<span class="line-added">+   operator const Klass*() const {</span>
<span class="line-added">+     return _obj-&gt;klass();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool oopDesc::mark_must_be_preserved() const {</span>
<span class="line-added">+   return mark_must_be_preserved(mark_raw());</span>
  }
  
<span class="line-modified">! bool oopDesc::mark_must_be_preserved(markWord m) const {</span>
<span class="line-modified">!   // There&#39;s a circular dependency between oop.inline.hpp and</span>
<span class="line-added">+   // markWord.inline.hpp because markWord::must_be_preserved wants to call</span>
<span class="line-added">+   // oopDesc::klass(). This could be solved by calling klass() here. However,</span>
<span class="line-added">+   // not all paths inside must_be_preserved calls klass(). Defer the call until</span>
<span class="line-added">+   // the klass is actually needed.</span>
<span class="line-added">+   return m.must_be_preserved(DeferredObjectToKlass(this));</span>
  }
  
<span class="line-modified">! bool oopDesc::mark_must_be_preserved_for_promotion_failure(markWord m) const {</span>
<span class="line-modified">!   return m.must_be_preserved_for_promotion_failure(DeferredObjectToKlass(this));</span>
  }
  
  #endif // SHARE_OOPS_OOP_INLINE_HPP
</pre>
<center><a href="oop.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
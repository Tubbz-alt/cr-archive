diff a/src/hotspot/share/oops/constantPool.inline.hpp b/src/hotspot/share/oops/constantPool.inline.hpp
--- a/src/hotspot/share/oops/constantPool.inline.hpp
+++ b/src/hotspot/share/oops/constantPool.inline.hpp
@@ -25,17 +25,17 @@
 #ifndef SHARE_OOPS_CONSTANTPOOL_INLINE_HPP
 #define SHARE_OOPS_CONSTANTPOOL_INLINE_HPP
 
 #include "oops/constantPool.hpp"
 #include "oops/cpCache.inline.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 
 inline CPSlot ConstantPool::slot_at(int which) const {
   assert(is_within_bounds(which), "index out of bounds");
   assert(!tag_at(which).is_unresolved_klass() && !tag_at(which).is_unresolved_klass_in_error(), "Corrupted constant pool");
   // Uses volatile because the klass slot changes without a lock.
-  intptr_t adr = OrderAccess::load_acquire(obj_at_addr(which));
+  intptr_t adr = Atomic::load_acquire(obj_at_addr(which));
   assert(adr != 0 || which == 0, "cp entry for klass should not be zero");
   return CPSlot(adr);
 }
 
 inline Klass* ConstantPool::resolved_klass_at(int which) const {  // Used by Compiler
@@ -44,11 +44,11 @@
   // behind our back, lest we later load stale values thru the oop.
   CPKlassSlot kslot = klass_slot_at(which);
   assert(tag_at(kslot.name_index()).is_symbol(), "sanity");
 
   Klass** adr = resolved_klasses()->adr_at(kslot.resolved_klass_index());
-  return OrderAccess::load_acquire(adr);
+  return Atomic::load_acquire(adr);
 }
 
 inline bool ConstantPool::is_pseudo_string_at(int which) {
   assert(tag_at(which).is_string(), "Corrupted constant pool");
   return slot_at(which).is_pseudo_string();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/fieldStreams.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="generateOopMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/fieldStreams.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 #include &quot;runtime/fieldDescriptor.hpp&quot;
 31 
 32 // The is the base class for iteration over the fields array
 33 // describing the declared fields in the class.  Several subclasses
 34 // are provided depending on the kind of iteration required.  The
 35 // JavaFieldStream is for iterating over regular Java fields and it
 36 // generally the preferred iterator.  InternalFieldStream only
 37 // iterates over fields that have been injected by the JVM.
 38 // AllFieldStream exposes all fields and should only be used in rare
 39 // cases.
 40 class FieldStreamBase : public StackObj {
 41  protected:
 42   Array&lt;u2&gt;*          _fields;
 43   constantPoolHandle  _constants;
 44   int                 _index;
 45   int                 _limit;
 46   int                 _generic_signature_slot;
 47   fieldDescriptor     _fd_buf;
 48 
 49   FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }
<span class="line-removed"> 50   InstanceKlass* field_holder() const { return _constants-&gt;pool_holder(); }</span>
 51 
 52   int init_generic_signature_start_slot() {
 53     int length = _fields-&gt;length();
 54     int num_fields = _index;
 55     int skipped_generic_signature_slots = 0;
 56     FieldInfo* fi;
 57     AccessFlags flags;
 58     /* Scan from 0 to the current _index. Count the number of generic
 59        signature slots for field[0] to field[_index - 1]. */
 60     for (int i = 0; i &lt; _index; i++) {
 61       fi = FieldInfo::from_field_array(_fields, i);
 62       flags.set_flags(fi-&gt;access_flags());
 63       if (flags.field_has_generic_signature()) {
 64         length --;
 65         skipped_generic_signature_slots ++;
 66       }
 67     }
 68     /* Scan from the current _index. */
 69     for (int i = _index; i*FieldInfo::field_slots &lt; length; i++) {
 70       fi = FieldInfo::from_field_array(_fields, i);
 71       flags.set_flags(fi-&gt;access_flags());
 72       if (flags.field_has_generic_signature()) {
 73         length --;
 74       }
 75       num_fields ++;
 76     }
 77     _generic_signature_slot = length + skipped_generic_signature_slots;
 78     assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
 79     return num_fields;
 80   }
 81 
<span class="line-modified"> 82   FieldStreamBase(Array&lt;u2&gt;* fields, const constantPoolHandle&amp; constants, int start, int limit) {</span>
<span class="line-removed"> 83     _fields = fields;</span>
<span class="line-removed"> 84     _constants = constants;</span>
<span class="line-removed"> 85     _index = start;</span>
<span class="line-removed"> 86     int num_fields = init_generic_signature_start_slot();</span>
<span class="line-removed"> 87     if (limit &lt; start) {</span>
<span class="line-removed"> 88       _limit = num_fields;</span>
<span class="line-removed"> 89     } else {</span>
<span class="line-removed"> 90       _limit = limit;</span>
<span class="line-removed"> 91     }</span>
<span class="line-removed"> 92   }</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94   FieldStreamBase(Array&lt;u2&gt;* fields, const constantPoolHandle&amp; constants) {</span>
<span class="line-removed"> 95     _fields = fields;</span>
<span class="line-removed"> 96     _constants = constants;</span>
<span class="line-removed"> 97     _index = 0;</span>
<span class="line-removed"> 98     _limit = init_generic_signature_start_slot();</span>
<span class="line-removed"> 99   }</span>
100 

101  public:
<span class="line-modified">102   FieldStreamBase(InstanceKlass* klass) {</span>
<span class="line-removed">103     _fields = klass-&gt;fields();</span>
<span class="line-removed">104     _constants = klass-&gt;constants();</span>
<span class="line-removed">105     _index = 0;</span>
<span class="line-removed">106     _limit = klass-&gt;java_fields_count();</span>
<span class="line-removed">107     init_generic_signature_start_slot();</span>
<span class="line-removed">108     assert(klass == field_holder(), &quot;&quot;);</span>
<span class="line-removed">109   }</span>
110 
111   // accessors
112   int index() const                 { return _index; }

113 
114   void next() {
115     if (access_flags().field_has_generic_signature()) {
116       _generic_signature_slot ++;
117       assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
118     }
119     _index += 1;
120   }
121   bool done() const { return _index &gt;= _limit; }
122 
123   // Accessors for current field
124   AccessFlags access_flags() const {
125     AccessFlags flags;
126     flags.set_flags(field()-&gt;access_flags());
127     return flags;
128   }
129 
130   void set_access_flags(u2 flags) const {
131     field()-&gt;set_access_flags(flags);
132   }
133 
134   void set_access_flags(AccessFlags flags) const {
135     set_access_flags(flags.as_short());
136   }
137 
138   Symbol* name() const {
<span class="line-modified">139     return field()-&gt;name(_constants);</span>
140   }
141 
142   Symbol* signature() const {
<span class="line-modified">143     return field()-&gt;signature(_constants);</span>
144   }
145 
146   Symbol* generic_signature() const {
147     if (access_flags().field_has_generic_signature()) {
148       assert(_generic_signature_slot &lt; _fields-&gt;length(), &quot;out of bounds&quot;);
149       int index = _fields-&gt;at(_generic_signature_slot);
150       return _constants-&gt;symbol_at(index);
151     } else {
152       return NULL;
153     }
154   }
155 
156   int offset() const {
157     return field()-&gt;offset();
158   }
159 
160   int allocation_type() const {
161     return field()-&gt;allocation_type();
162   }
163 
</pre>
<hr />
<pre>
225   int initval_index() const {
226     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
227     return field()-&gt;initval_index();
228   }
229   void set_initval_index(int index) {
230     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
231     return field()-&gt;set_initval_index(index);
232   }
233 };
234 
235 
236 // Iterate over only the internal fields
237 class InternalFieldStream : public FieldStreamBase {
238  public:
239   InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants(), k-&gt;java_fields_count(), 0) {}
240 };
241 
242 
243 class AllFieldStream : public FieldStreamBase {
244  public:
<span class="line-modified">245   AllFieldStream(Array&lt;u2&gt;* fields, const constantPoolHandle&amp; constants): FieldStreamBase(fields, constants) {}</span>
246   AllFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants()) {}
247 };
248 
249 #endif // SHARE_OOPS_FIELDSTREAMS_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 #include &quot;runtime/fieldDescriptor.hpp&quot;
 31 
 32 // The is the base class for iteration over the fields array
 33 // describing the declared fields in the class.  Several subclasses
 34 // are provided depending on the kind of iteration required.  The
 35 // JavaFieldStream is for iterating over regular Java fields and it
 36 // generally the preferred iterator.  InternalFieldStream only
 37 // iterates over fields that have been injected by the JVM.
 38 // AllFieldStream exposes all fields and should only be used in rare
 39 // cases.
 40 class FieldStreamBase : public StackObj {
 41  protected:
 42   Array&lt;u2&gt;*          _fields;
 43   constantPoolHandle  _constants;
 44   int                 _index;
 45   int                 _limit;
 46   int                 _generic_signature_slot;
 47   fieldDescriptor     _fd_buf;
 48 
 49   FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }

 50 
 51   int init_generic_signature_start_slot() {
 52     int length = _fields-&gt;length();
 53     int num_fields = _index;
 54     int skipped_generic_signature_slots = 0;
 55     FieldInfo* fi;
 56     AccessFlags flags;
 57     /* Scan from 0 to the current _index. Count the number of generic
 58        signature slots for field[0] to field[_index - 1]. */
 59     for (int i = 0; i &lt; _index; i++) {
 60       fi = FieldInfo::from_field_array(_fields, i);
 61       flags.set_flags(fi-&gt;access_flags());
 62       if (flags.field_has_generic_signature()) {
 63         length --;
 64         skipped_generic_signature_slots ++;
 65       }
 66     }
 67     /* Scan from the current _index. */
 68     for (int i = _index; i*FieldInfo::field_slots &lt; length; i++) {
 69       fi = FieldInfo::from_field_array(_fields, i);
 70       flags.set_flags(fi-&gt;access_flags());
 71       if (flags.field_has_generic_signature()) {
 72         length --;
 73       }
 74       num_fields ++;
 75     }
 76     _generic_signature_slot = length + skipped_generic_signature_slots;
 77     assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
 78     return num_fields;
 79   }
 80 
<span class="line-modified"> 81   inline FieldStreamBase(Array&lt;u2&gt;* fields, ConstantPool* constants, int start, int limit);</span>

















 82 
<span class="line-added"> 83   inline FieldStreamBase(Array&lt;u2&gt;* fields, ConstantPool* constants);</span>
 84  public:
<span class="line-modified"> 85   inline FieldStreamBase(InstanceKlass* klass);</span>







 86 
 87   // accessors
 88   int index() const                 { return _index; }
<span class="line-added"> 89   InstanceKlass* field_holder() const { return _constants-&gt;pool_holder(); }</span>
 90 
 91   void next() {
 92     if (access_flags().field_has_generic_signature()) {
 93       _generic_signature_slot ++;
 94       assert(_generic_signature_slot &lt;= _fields-&gt;length(), &quot;&quot;);
 95     }
 96     _index += 1;
 97   }
 98   bool done() const { return _index &gt;= _limit; }
 99 
100   // Accessors for current field
101   AccessFlags access_flags() const {
102     AccessFlags flags;
103     flags.set_flags(field()-&gt;access_flags());
104     return flags;
105   }
106 
107   void set_access_flags(u2 flags) const {
108     field()-&gt;set_access_flags(flags);
109   }
110 
111   void set_access_flags(AccessFlags flags) const {
112     set_access_flags(flags.as_short());
113   }
114 
115   Symbol* name() const {
<span class="line-modified">116     return field()-&gt;name(_constants());</span>
117   }
118 
119   Symbol* signature() const {
<span class="line-modified">120     return field()-&gt;signature(_constants());</span>
121   }
122 
123   Symbol* generic_signature() const {
124     if (access_flags().field_has_generic_signature()) {
125       assert(_generic_signature_slot &lt; _fields-&gt;length(), &quot;out of bounds&quot;);
126       int index = _fields-&gt;at(_generic_signature_slot);
127       return _constants-&gt;symbol_at(index);
128     } else {
129       return NULL;
130     }
131   }
132 
133   int offset() const {
134     return field()-&gt;offset();
135   }
136 
137   int allocation_type() const {
138     return field()-&gt;allocation_type();
139   }
140 
</pre>
<hr />
<pre>
202   int initval_index() const {
203     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
204     return field()-&gt;initval_index();
205   }
206   void set_initval_index(int index) {
207     assert(!field()-&gt;is_internal(), &quot;regular only&quot;);
208     return field()-&gt;set_initval_index(index);
209   }
210 };
211 
212 
213 // Iterate over only the internal fields
214 class InternalFieldStream : public FieldStreamBase {
215  public:
216   InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants(), k-&gt;java_fields_count(), 0) {}
217 };
218 
219 
220 class AllFieldStream : public FieldStreamBase {
221  public:
<span class="line-modified">222   AllFieldStream(Array&lt;u2&gt;* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}</span>
223   AllFieldStream(InstanceKlass* k):      FieldStreamBase(k-&gt;fields(), k-&gt;constants()) {}
224 };
225 
226 #endif // SHARE_OOPS_FIELDSTREAMS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="fieldInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="generateOopMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
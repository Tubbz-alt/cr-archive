<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/klassVtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klassVtable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metadata.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -46,17 +46,10 @@</span>
    int          _length;           // length of vtable (number of entries)
  #ifndef PRODUCT
    int          _verify_count;     // to make verify faster
  #endif
  
<span class="udiff-line-removed">-   // Ordering important, so greater_than (&gt;) can be used as an merge operator.</span>
<span class="udiff-line-removed">-   enum AccessType {</span>
<span class="udiff-line-removed">-     acc_private         = 0,</span>
<span class="udiff-line-removed">-     acc_package_private = 1,</span>
<span class="udiff-line-removed">-     acc_publicprotected = 2</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">- </span>
   public:
    klassVtable(Klass* klass, void* base, int length) : _klass(klass) {
      _tableOffset = (address)base - (address)klass; _length = length;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -64,26 +57,16 @@</span>
    vtableEntry* table() const      { return (vtableEntry*)(address(_klass) + _tableOffset); }
    Klass* klass() const            { return _klass;  }
    int length() const              { return _length; }
    inline Method* method_at(int i) const;
    inline Method* unchecked_method_at(int i) const;
<span class="udiff-line-removed">-   inline Method** adr_method_at(int i) const;</span>
  
    // searching; all methods return -1 if not found
<span class="udiff-line-removed">-   int index_of(Method* m) const                         { return index_of(m, _length); }</span>
    int index_of_miranda(Symbol* name, Symbol* signature);
  
    void initialize_vtable(bool checkconstraints, TRAPS);   // initialize vtable of a new klass
  
<span class="udiff-line-removed">-   // CDS/RedefineClasses support - clear vtables so they can be reinitialized</span>
<span class="udiff-line-removed">-   // at dump time.  Clearing gives us an easy way to tell if the vtable has</span>
<span class="udiff-line-removed">-   // already been reinitialized at dump time (see dump.cpp).  Vtables can</span>
<span class="udiff-line-removed">-   // be initialized at run time by RedefineClasses so dumping the right order</span>
<span class="udiff-line-removed">-   // is necessary.</span>
<span class="udiff-line-removed">-   void clear_vtable();</span>
<span class="udiff-line-removed">-   bool is_initialized();</span>
<span class="udiff-line-removed">- </span>
    // computes vtable length (in words) and the number of miranda methods
    static void compute_vtable_size_and_num_mirandas(int* vtable_length,
                                                     int* num_new_mirandas,
                                                     GrowableArray&lt;Method*&gt;* all_mirandas,
                                                     const Klass* super,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,11 +106,10 @@</span>
    enum { VTABLE_TRANSITIVE_OVERRIDE_VERSION = 51 } ;
  
   private:
    void copy_vtable_to(vtableEntry* start);
    int  initialize_from_super(Klass* super);
<span class="udiff-line-removed">-   int  index_of(Method* m, int len) const; // same as index_of, but search only up to len</span>
    void put_method_at(Method* m, int index);
    static bool needs_new_vtable_entry(const methodHandle&amp; m,
                                       const Klass* super,
                                       Handle classloader,
                                       Symbol* classname,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,16 +203,10 @@</span>
  inline Method* klassVtable::unchecked_method_at(int i) const {
    assert(i &gt;= 0 &amp;&amp; i &lt; _length, &quot;index out of bounds&quot;);
    return table()[i].method();
  }
  
<span class="udiff-line-removed">- inline Method** klassVtable::adr_method_at(int i) const {</span>
<span class="udiff-line-removed">-   // Allow one past the last entry to be referenced; useful for loop bounds.</span>
<span class="udiff-line-removed">-   assert(i &gt;= 0 &amp;&amp; i &lt;= _length, &quot;index out of bounds&quot;);</span>
<span class="udiff-line-removed">-   return (Method**)(address(table() + i) + vtableEntry::method_offset_in_bytes());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // --------------------------------------------------------------------------------
  class klassItable;
  class itableMethodEntry;
  
  class itableOffsetEntry {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -331,13 +307,10 @@</span>
    static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);
    static int method_count_for_interface(InstanceKlass* klass);
    static int compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces);
    static void setup_itable_offset_table(InstanceKlass* klass);
  
<span class="udiff-line-removed">-   // Resolving of method to index</span>
<span class="udiff-line-removed">-   static Method* method_for_itable_index(InstanceKlass* klass, int itable_index);</span>
<span class="udiff-line-removed">- </span>
    // Debugging/Statistics
    static void print_statistics() PRODUCT_RETURN;
   private:
    intptr_t* vtable_start() const { return ((intptr_t*)_klass) + _table_offset; }
    intptr_t* method_start() const { return vtable_start() + _size_offset_table * itableOffsetEntry::size(); }
</pre>
<center><a href="klassVtable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metadata.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
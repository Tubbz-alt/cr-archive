<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/moduleEntry.hpp&quot;
 27 #include &quot;classfile/packageEntry.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;memory/metadataFactory.hpp&quot;
 34 #include &quot;memory/metaspaceClosure.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;oops/arrayKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceKlass.hpp&quot;
 39 #include &quot;oops/klass.inline.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/objArrayOop.inline.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/symbol.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
 48 ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {
 49   assert(ObjArrayKlass::header_size() &lt;= InstanceKlass::header_size(),
 50       &quot;array klasses must be same size as InstanceKlass&quot;);
 51 
 52   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 53 
 54   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 55 }
 56 
 57 Klass* ObjArrayKlass::allocate_objArray_klass(ClassLoaderData* loader_data,
 58                                                 int n, Klass* element_klass, TRAPS) {
 59 
 60   // Eagerly allocate the direct array supertype.
 61   Klass* super_klass = NULL;
 62   if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
 63     Klass* element_super = element_klass-&gt;super();
 64     if (element_super != NULL) {
 65       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 66       super_klass = element_super-&gt;array_klass_or_null();
 67       bool supers_exist = super_klass != NULL;
 68       // Also, see if the element has secondary supertypes.
 69       // We need an array type for each.
 70       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 71       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 72         Klass* elem_super = element_supers-&gt;at(i);
 73         if (elem_super-&gt;array_klass_or_null() == NULL) {
 74           supers_exist = false;
 75           break;
 76         }
 77       }
 78       if (!supers_exist) {
 79         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 80         Klass* ek = NULL;
 81         {
 82           MutexUnlocker mu(MultiArray_lock);
 83           super_klass = element_super-&gt;array_klass(CHECK_0);
 84           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 85             Klass* elem_super = element_supers-&gt;at(i);
 86             elem_super-&gt;array_klass(CHECK_0);
 87           }
 88           // Now retry from the beginning
 89           ek = element_klass-&gt;array_klass(n, CHECK_0);
 90         }  // re-lock
 91         return ek;
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
100   Symbol* name = NULL;
101   if (!element_klass-&gt;is_instance_klass() ||
102       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {
103 
104     ResourceMark rm(THREAD);
105     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
106     int len = element_klass-&gt;name()-&gt;utf8_length();
107     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
108     int idx = 0;
<a name="2" id="anc2"></a><span class="line-modified">109     new_str[idx++] = &#39;[&#39;;</span>
110     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
<a name="3" id="anc3"></a><span class="line-modified">111       new_str[idx++] = &#39;L&#39;;</span>
112     }
113     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
114     idx += len;
115     if (element_klass-&gt;is_instance_klass()) {
<a name="4" id="anc4"></a><span class="line-modified">116       new_str[idx++] = &#39;;&#39;;</span>
117     }
118     new_str[idx++] = &#39;\0&#39;;
<a name="5" id="anc5"></a><span class="line-modified">119     name = SymbolTable::new_permanent_symbol(new_str, CHECK_0);</span>
120     if (element_klass-&gt;is_instance_klass()) {
121       InstanceKlass* ik = InstanceKlass::cast(element_klass);
122       ik-&gt;set_array_name(name);
123     }
124   }
125 
126   // Initialize instance variables
127   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_0);
128 
<a name="6" id="anc6"></a><span class="line-removed">129   // Add all classes to our internal class loader list here,</span>
<span class="line-removed">130   // including classes in the bootstrap (NULL) class loader.</span>
<span class="line-removed">131   // GC walks these as strong roots.</span>
<span class="line-removed">132   loader_data-&gt;add_class(oak);</span>
<span class="line-removed">133 </span>
134   ModuleEntry* module = oak-&gt;module();
135   assert(module != NULL, &quot;No module entry for array&quot;);
136 
137   // Call complete_create_array_klass after all instance variables has been initialized.
138   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_0);
139 
<a name="7" id="anc7"></a>






140   return oak;
141 }
142 
143 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
144   this-&gt;set_dimension(n);
145   this-&gt;set_element_klass(element_klass);
146   // decrement refcount because object arrays are not explicitly freed.  The
147   // InstanceKlass array_name() keeps the name counted while the klass is
148   // loaded.
149   name-&gt;decrement_refcount();
150 
151   Klass* bk;
152   if (element_klass-&gt;is_objArray_klass()) {
153     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
154   } else {
155     bk = element_klass;
156   }
157   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
158   this-&gt;set_bottom_klass(bk);
159   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
160 
161   this-&gt;set_layout_helper(array_layout_helper(T_OBJECT));
162   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
163   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
164 }
165 
166 int ObjArrayKlass::oop_size(oop obj) const {
167   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
168   return objArrayOop(obj)-&gt;object_size();
169 }
170 
171 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
172   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_0);
173   int size = objArrayOopDesc::object_size(length);
174   return (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
175                                                        /* do_zero */ true, THREAD);
176 }
177 
178 static int multi_alloc_counter = 0;
179 
180 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
181   int length = *sizes;
182   // Call to lower_dimension uses this pointer, so most be called before a
183   // possible GC
184   Klass* ld_klass = lower_dimension();
185   // If length &lt; 0 allocate will throw an exception.
186   objArrayOop array = allocate(length, CHECK_NULL);
187   objArrayHandle h_array (THREAD, array);
188   if (rank &gt; 1) {
189     if (length != 0) {
190       for (int index = 0; index &lt; length; index++) {
191         ArrayKlass* ak = ArrayKlass::cast(ld_klass);
192         oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);
193         h_array-&gt;obj_at_put(index, sub_array);
194       }
195     } else {
196       // Since this array dimension has zero length, nothing will be
197       // allocated, however the lower dimension values must be checked
198       // for illegal values.
199       for (int i = 0; i &lt; rank - 1; ++i) {
200         sizes += 1;
201         if (*sizes &lt; 0) {
202           THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));
203         }
204       }
205     }
206   }
207   return h_array();
208 }
209 
210 // Either oop or narrowOop depending on UseCompressedOops.
211 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
212                             arrayOop d, size_t dst_offset, int length, TRAPS) {
<a name="8" id="anc8"></a><span class="line-modified">213   if (oopDesc::equals(s, d)) {</span>
214     // since source and destination are equal we do not need conversion checks.
215     assert(length &gt; 0, &quot;sanity check&quot;);
216     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
217   } else {
218     // We have to make sure all elements conform to the destination array
219     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
220     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
221     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
222       // elements are guaranteed to be subtypes, so no check necessary
223       ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
224     } else {
225       // slow case: need individual subtype checks
226       // note: don&#39;t use obj_at_put below because it includes a redundant store check
227       if (!ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length)) {
228         ResourceMark rm(THREAD);
229         stringStream ss;
230         if (!bound-&gt;is_subtype_of(stype)) {
231           ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into %s[]&quot;,
232                    stype-&gt;external_name(), bound-&gt;external_name());
233         } else {
234           // oop_arraycopy should return the index in the source array that
235           // contains the problematic oop.
236           ss.print(&quot;arraycopy: element type mismatch: can not cast one of the elements&quot;
237                    &quot; of %s[] to the type of the destination array, %s&quot;,
238                    stype-&gt;external_name(), bound-&gt;external_name());
239         }
240         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
241       }
242     }
243   }
244 }
245 
246 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
247                                int dst_pos, int length, TRAPS) {
248   assert(s-&gt;is_objArray(), &quot;must be obj array&quot;);
249 
250   if (!d-&gt;is_objArray()) {
251     ResourceMark rm(THREAD);
252     stringStream ss;
253     if (d-&gt;is_typeArray()) {
254       ss.print(&quot;arraycopy: type mismatch: can not copy object array[] into %s[]&quot;,
255                type2name_tab[ArrayKlass::cast(d-&gt;klass())-&gt;element_type()]);
256     } else {
257       ss.print(&quot;arraycopy: destination type %s is not an array&quot;, d-&gt;klass()-&gt;external_name());
258     }
259     THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
260   }
261 
262   // Check is all offsets and lengths are non negative
263   if (src_pos &lt; 0 || dst_pos &lt; 0 || length &lt; 0) {
264     // Pass specific exception reason.
265     ResourceMark rm(THREAD);
266     stringStream ss;
267     if (src_pos &lt; 0) {
268       ss.print(&quot;arraycopy: source index %d out of bounds for object array[%d]&quot;,
269                src_pos, s-&gt;length());
270     } else if (dst_pos &lt; 0) {
271       ss.print(&quot;arraycopy: destination index %d out of bounds for object array[%d]&quot;,
272                dst_pos, d-&gt;length());
273     } else {
274       ss.print(&quot;arraycopy: length %d is negative&quot;, length);
275     }
276     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
277   }
278   // Check if the ranges are valid
279   if ((((unsigned int) length + (unsigned int) src_pos) &gt; (unsigned int) s-&gt;length()) ||
280       (((unsigned int) length + (unsigned int) dst_pos) &gt; (unsigned int) d-&gt;length())) {
281     // Pass specific exception reason.
282     ResourceMark rm(THREAD);
283     stringStream ss;
284     if (((unsigned int) length + (unsigned int) src_pos) &gt; (unsigned int) s-&gt;length()) {
285       ss.print(&quot;arraycopy: last source index %u out of bounds for object array[%d]&quot;,
286                (unsigned int) length + (unsigned int) src_pos, s-&gt;length());
287     } else {
288       ss.print(&quot;arraycopy: last destination index %u out of bounds for object array[%d]&quot;,
289                (unsigned int) length + (unsigned int) dst_pos, d-&gt;length());
290     }
291     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
292   }
293 
294   // Special case. Boundary cases must be checked first
295   // This allows the following call: copy_array(s, s.length(), d.length(), 0).
296   // This is correct, since the position is supposed to be an &#39;in between point&#39;, i.e., s.length(),
297   // points to the right of the last element.
298   if (length==0) {
299     return;
300   }
301   if (UseCompressedOops) {
302     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(src_pos);
303     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(dst_pos);
304     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(s, src_offset, NULL) ==
305            objArrayOop(s)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(src_pos), &quot;sanity&quot;);
306     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(d, dst_offset, NULL) ==
307            objArrayOop(d)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(dst_pos), &quot;sanity&quot;);
308     do_copy(s, src_offset, d, dst_offset, length, CHECK);
309   } else {
310     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(src_pos);
311     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(dst_pos);
312     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(s, src_offset, NULL) ==
313            objArrayOop(s)-&gt;obj_at_addr_raw&lt;oop&gt;(src_pos), &quot;sanity&quot;);
314     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(d, dst_offset, NULL) ==
315            objArrayOop(d)-&gt;obj_at_addr_raw&lt;oop&gt;(dst_pos), &quot;sanity&quot;);
316     do_copy(s, src_offset, d, dst_offset, length, CHECK);
317   }
318 }
319 
320 
321 Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
322 
323   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
324   int dim = dimension();
325   if (dim == n) return this;
326 
327   // lock-free read needs acquire semantics
328   if (higher_dimension_acquire() == NULL) {
<a name="9" id="anc9"></a><span class="line-modified">329     if (or_null)  return NULL;</span>
330 
331     ResourceMark rm;
332     JavaThread *jt = (JavaThread *)THREAD;
333     {
334       // Ensure atomic creation of higher dimensions
<a name="10" id="anc10"></a><span class="line-modified">335       MutexLocker mu(MultiArray_lock, THREAD);</span>
336 
337       // Check if another thread beat us
338       if (higher_dimension() == NULL) {
339 
340         // Create multi-dim klass object and link them together
341         Klass* k =
342           ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
343         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
344         ak-&gt;set_lower_dimension(this);
345         // use &#39;release&#39; to pair with lock-free load
346         release_set_higher_dimension(ak);
347         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
348       }
349     }
<a name="11" id="anc11"></a><span class="line-removed">350   } else {</span>
<span class="line-removed">351     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
352   }
353 
354   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
355   if (or_null) {
356     return ak-&gt;array_klass_or_null(n);
357   }
<a name="12" id="anc12"></a>
358   return ak-&gt;array_klass(n, THREAD);
359 }
360 
361 Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
362   return array_klass_impl(or_null, dimension() +  1, THREAD);
363 }
364 
365 bool ObjArrayKlass::can_be_primary_super_slow() const {
366   if (!bottom_klass()-&gt;can_be_primary_super())
367     // array of interfaces
368     return false;
369   else
370     return Klass::can_be_primary_super_slow();
371 }
372 
373 GrowableArray&lt;Klass*&gt;* ObjArrayKlass::compute_secondary_supers(int num_extra_slots,
374                                                                Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
375   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
376   // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
377   const Array&lt;Klass*&gt;* elem_supers = element_klass()-&gt;secondary_supers();
378   int num_elem_supers = elem_supers == NULL ? 0 : elem_supers-&gt;length();
379   int num_secondaries = num_extra_slots + 2 + num_elem_supers;
380   if (num_secondaries == 2) {
381     // Must share this for correct bootstrapping!
382     set_secondary_supers(Universe::the_array_interfaces_array());
383     return NULL;
384   } else {
385     GrowableArray&lt;Klass*&gt;* secondaries = new GrowableArray&lt;Klass*&gt;(num_elem_supers+2);
386     secondaries-&gt;push(SystemDictionary::Cloneable_klass());
387     secondaries-&gt;push(SystemDictionary::Serializable_klass());
388     for (int i = 0; i &lt; num_elem_supers; i++) {
389       Klass* elem_super = elem_supers-&gt;at(i);
390       Klass* array_super = elem_super-&gt;array_klass_or_null();
391       assert(array_super != NULL, &quot;must already have been created&quot;);
392       secondaries-&gt;push(array_super);
393     }
394     return secondaries;
395   }
396 }
397 
398 void ObjArrayKlass::initialize(TRAPS) {
399   bottom_klass()-&gt;initialize(THREAD);  // dispatches to either InstanceKlass or TypeArrayKlass
400 }
401 
402 void ObjArrayKlass::metaspace_pointers_do(MetaspaceClosure* it) {
403   ArrayKlass::metaspace_pointers_do(it);
404   it-&gt;push(&amp;_element_klass);
405   it-&gt;push(&amp;_bottom_klass);
406 }
407 
408 // JVM support
409 
410 jint ObjArrayKlass::compute_modifier_flags(TRAPS) const {
411   // The modifier for an objectArray is the same as its element
412   if (element_klass() == NULL) {
413     assert(Universe::is_bootstrapping(), &quot;partial objArray only at startup&quot;);
414     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
415   }
416   // Return the flags of the bottom element type.
417   jint element_flags = bottom_klass()-&gt;compute_modifier_flags(CHECK_0);
418 
419   return (element_flags &amp; (JVM_ACC_PUBLIC | JVM_ACC_PRIVATE | JVM_ACC_PROTECTED))
420                         | (JVM_ACC_ABSTRACT | JVM_ACC_FINAL);
421 }
422 
423 ModuleEntry* ObjArrayKlass::module() const {
424   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
425   // The array is defined in the module of its bottom class
426   return bottom_klass()-&gt;module();
427 }
428 
429 PackageEntry* ObjArrayKlass::package() const {
430   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
431   return bottom_klass()-&gt;package();
432 }
433 
434 // Printing
435 
436 void ObjArrayKlass::print_on(outputStream* st) const {
437 #ifndef PRODUCT
438   Klass::print_on(st);
439   st-&gt;print(&quot; - instance klass: &quot;);
440   element_klass()-&gt;print_value_on(st);
441   st-&gt;cr();
442 #endif //PRODUCT
443 }
444 
445 void ObjArrayKlass::print_value_on(outputStream* st) const {
446   assert(is_klass(), &quot;must be klass&quot;);
447 
448   element_klass()-&gt;print_value_on(st);
449   st-&gt;print(&quot;[]&quot;);
450 }
451 
452 #ifndef PRODUCT
453 
454 void ObjArrayKlass::oop_print_on(oop obj, outputStream* st) {
455   ArrayKlass::oop_print_on(obj, st);
456   assert(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
457   objArrayOop oa = objArrayOop(obj);
458   int print_len = MIN2((intx) oa-&gt;length(), MaxElementPrintSize);
459   for(int index = 0; index &lt; print_len; index++) {
460     st-&gt;print(&quot; - %3d : &quot;, index);
461     if (oa-&gt;obj_at(index) != NULL) {
462       oa-&gt;obj_at(index)-&gt;print_value_on(st);
463       st-&gt;cr();
464     } else {
465       st-&gt;print_cr(&quot;NULL&quot;);
466     }
467   }
468   int remaining = oa-&gt;length() - print_len;
469   if (remaining &gt; 0) {
470     st-&gt;print_cr(&quot; - &lt;%d more elements, increase MaxElementPrintSize to print&gt;&quot;, remaining);
471   }
472 }
473 
474 #endif //PRODUCT
475 
476 void ObjArrayKlass::oop_print_value_on(oop obj, outputStream* st) {
477   assert(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
478   st-&gt;print(&quot;a &quot;);
479   element_klass()-&gt;print_value_on(st);
480   int len = objArrayOop(obj)-&gt;length();
481   st-&gt;print(&quot;[%d] &quot;, len);
482   if (obj != NULL) {
483     obj-&gt;print_address_on(st);
484   } else {
485     st-&gt;print_cr(&quot;NULL&quot;);
486   }
487 }
488 
489 const char* ObjArrayKlass::internal_name() const {
490   return external_name();
491 }
492 
493 
494 // Verification
495 
496 void ObjArrayKlass::verify_on(outputStream* st) {
497   ArrayKlass::verify_on(st);
498   guarantee(element_klass()-&gt;is_klass(), &quot;should be klass&quot;);
499   guarantee(bottom_klass()-&gt;is_klass(), &quot;should be klass&quot;);
500   Klass* bk = bottom_klass();
501   guarantee(bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass(),  &quot;invalid bottom klass&quot;);
502 }
503 
504 void ObjArrayKlass::oop_verify_on(oop obj, outputStream* st) {
505   ArrayKlass::oop_verify_on(obj, st);
506   guarantee(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
507   objArrayOop oa = objArrayOop(obj);
508   for(int index = 0; index &lt; oa-&gt;length(); index++) {
509     guarantee(oopDesc::is_oop_or_null(oa-&gt;obj_at(index)), &quot;should be oop&quot;);
510   }
511 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/asm/assembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aot/aotLoader.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/assembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 30 #include &quot;runtime/atomic.hpp&quot;</span>

 31 #include &quot;runtime/icache.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 
 36 // Implementation of AbstractAssembler
 37 //
 38 // The AbstractAssembler is generating code into a CodeBuffer. To make code generation faster,
 39 // the assembler keeps a copy of the code buffers boundaries &amp; modifies them when
 40 // emitting bytes rather than using the code buffers accessor functions all the time.
 41 // The code buffer is updated via set_code_end(...) after emitting a whole instruction.
 42 
 43 AbstractAssembler::AbstractAssembler(CodeBuffer* code) {
 44   if (code == NULL)  return;
 45   CodeSection* cs = code-&gt;insts();
 46   cs-&gt;clear_mark();   // new assembler kills old mark
 47   if (cs-&gt;start() == NULL)  {
 48     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;CodeCache: no room for %s&quot;, code-&gt;name());
 49   }
 50   _code_section = cs;
</pre>
<hr />
<pre>
199     }
200 
201 #ifdef ASSERT
202     // Cross-section branches only work if the
203     // intermediate section boundaries are frozen.
204     if (target_sect != branch_sect) {
205       for (int n = MIN2(target_sect, branch_sect),
206                nlimit = (target_sect + branch_sect) - n;
207            n &lt; nlimit; n++) {
208         CodeSection* cs = cb-&gt;code_section(n);
209         assert(cs-&gt;is_frozen(), &quot;cross-section branch needs stable offsets&quot;);
210       }
211     }
212 #endif //ASSERT
213 
214     // Push the target offset into the branch instruction.
215     masm-&gt;pd_patch_instruction(branch, target, file, line);
216   }
217 }
218 
<span class="line-removed">219 struct DelayedConstant {</span>
<span class="line-removed">220   typedef void (*value_fn_t)();</span>
<span class="line-removed">221   BasicType type;</span>
<span class="line-removed">222   intptr_t value;</span>
<span class="line-removed">223   value_fn_t value_fn;</span>
<span class="line-removed">224   // This limit of 20 is generous for initial uses.</span>
<span class="line-removed">225   // The limit needs to be large enough to store the field offsets</span>
<span class="line-removed">226   // into classes which do not have statically fixed layouts.</span>
<span class="line-removed">227   // (Initial use is for method handle object offsets.)</span>
<span class="line-removed">228   // Look for uses of &quot;delayed_value&quot; in the source code</span>
<span class="line-removed">229   // and make sure this number is generous enough to handle all of them.</span>
<span class="line-removed">230   enum { DC_LIMIT = 20 };</span>
<span class="line-removed">231   static DelayedConstant delayed_constants[DC_LIMIT];</span>
<span class="line-removed">232   static DelayedConstant* add(BasicType type, value_fn_t value_fn);</span>
<span class="line-removed">233   bool match(BasicType t, value_fn_t cfn) {</span>
<span class="line-removed">234     return type == t &amp;&amp; value_fn == cfn;</span>
<span class="line-removed">235   }</span>
<span class="line-removed">236   static void update_all();</span>
<span class="line-removed">237 };</span>
<span class="line-removed">238 </span>
<span class="line-removed">239 DelayedConstant DelayedConstant::delayed_constants[DC_LIMIT];</span>
<span class="line-removed">240 // Default C structure initialization rules have the following effect here:</span>
<span class="line-removed">241 // = { { (BasicType)0, (intptr_t)NULL }, ... };</span>
<span class="line-removed">242 </span>
<span class="line-removed">243 DelayedConstant* DelayedConstant::add(BasicType type,</span>
<span class="line-removed">244                                       DelayedConstant::value_fn_t cfn) {</span>
<span class="line-removed">245   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">246     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">247     if (dcon-&gt;match(type, cfn))</span>
<span class="line-removed">248       return dcon;</span>
<span class="line-removed">249     if (dcon-&gt;value_fn == NULL) {</span>
<span class="line-removed">250         dcon-&gt;value_fn = cfn;</span>
<span class="line-removed">251         dcon-&gt;type = type;</span>
<span class="line-removed">252         return dcon;</span>
<span class="line-removed">253     }</span>
<span class="line-removed">254   }</span>
<span class="line-removed">255   // If this assert is hit (in pre-integration testing!) then re-evaluate</span>
<span class="line-removed">256   // the comment on the definition of DC_LIMIT.</span>
<span class="line-removed">257   guarantee(false, &quot;too many delayed constants&quot;);</span>
<span class="line-removed">258   return NULL;</span>
<span class="line-removed">259 }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261 void DelayedConstant::update_all() {</span>
<span class="line-removed">262   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">263     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">264     if (dcon-&gt;value_fn != NULL &amp;&amp; dcon-&gt;value == 0) {</span>
<span class="line-removed">265       typedef int     (*int_fn_t)();</span>
<span class="line-removed">266       typedef address (*address_fn_t)();</span>
<span class="line-removed">267       switch (dcon-&gt;type) {</span>
<span class="line-removed">268       case T_INT:     dcon-&gt;value = (intptr_t) ((int_fn_t)    dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">269       case T_ADDRESS: dcon-&gt;value = (intptr_t) ((address_fn_t)dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">270       default:        break;</span>
<span class="line-removed">271       }</span>
<span class="line-removed">272     }</span>
<span class="line-removed">273   }</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 RegisterOrConstant AbstractAssembler::delayed_value(int(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">277   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">278   if (val != 0)  return val + offset;</span>
<span class="line-removed">279   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">280 }</span>
<span class="line-removed">281 RegisterOrConstant AbstractAssembler::delayed_value(address(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">282   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">283   if (val != 0)  return val + offset;</span>
<span class="line-removed">284   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">285 }</span>
<span class="line-removed">286 intptr_t* AbstractAssembler::delayed_value_addr(int(*value_fn)()) {</span>
<span class="line-removed">287   DelayedConstant* dcon = DelayedConstant::add(T_INT, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">288   return &amp;dcon-&gt;value;</span>
<span class="line-removed">289 }</span>
<span class="line-removed">290 intptr_t* AbstractAssembler::delayed_value_addr(address(*value_fn)()) {</span>
<span class="line-removed">291   DelayedConstant* dcon = DelayedConstant::add(T_ADDRESS, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">292   return &amp;dcon-&gt;value;</span>
<span class="line-removed">293 }</span>
<span class="line-removed">294 void AbstractAssembler::update_delayed_values() {</span>
<span class="line-removed">295   DelayedConstant::update_all();</span>
<span class="line-removed">296 }</span>
<span class="line-removed">297 </span>
298 void AbstractAssembler::block_comment(const char* comment) {
299   if (sect() == CodeBuffer::SECT_INSTS) {
300     code_section()-&gt;outer()-&gt;block_comment(offset(), comment);
301   }
302 }
303 
304 const char* AbstractAssembler::code_string(const char* str) {
305   if (sect() == CodeBuffer::SECT_INSTS || sect() == CodeBuffer::SECT_STUBS) {
306     return code_section()-&gt;outer()-&gt;code_string(str);
307   }
308   return NULL;
309 }
310 
311 bool MacroAssembler::uses_implicit_null_check(void* address) {
312   // Exception handler checks the nmethod&#39;s implicit null checks table
313   // only when this method returns false.
<span class="line-modified">314   intptr_t int_address = reinterpret_cast&lt;intptr_t&gt;(address);</span>
<span class="line-modified">315   intptr_t cell_header_size = Universe::heap()-&gt;cell_header_size();</span>
<span class="line-removed">316   size_t region_size = os::vm_page_size() + cell_header_size;</span>
317 #ifdef _LP64
<span class="line-modified">318   if (UseCompressedOops &amp;&amp; Universe::narrow_oop_base() != NULL) {</span>
319     // A SEGV can legitimately happen in C2 code at address
320     // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
321     // is configured to allow narrow oops field loads to be implicitly
322     // null checked
<span class="line-modified">323     intptr_t start = ((intptr_t)Universe::narrow_oop_base()) - cell_header_size;</span>
<span class="line-modified">324     intptr_t end = start + region_size;</span>
<span class="line-modified">325     if (int_address &gt;= start &amp;&amp; int_address &lt; end) {</span>
326       return true;
327     }
328   }
329 #endif
<span class="line-modified">330   intptr_t start = -cell_header_size;</span>
<span class="line-removed">331   intptr_t end = start + region_size;</span>
<span class="line-removed">332   return int_address &gt;= start &amp;&amp; int_address &lt; end;</span>
333 }
334 
335 bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
336   // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
337   // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
338   // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
339   // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
340   // for offsets to be patched in later. The -1 there means the offset is not yet known
341   // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
<span class="line-modified">342   // an explicit null check for -1, even if it may otherwise be in the range</span>
<span class="line-removed">343   // [-cell_header_size, os::vm_page_size).</span>
<span class="line-removed">344   // TODO: Find and replace all relevant uses of -1 with a reasonably named constant.</span>
<span class="line-removed">345   if (offset == -1) return true;</span>
346 
<span class="line-modified">347   // Check if offset is outside of [-cell_header_size, os::vm_page_size)</span>
<span class="line-modified">348   return offset &lt; -Universe::heap()-&gt;cell_header_size() ||</span>
<span class="line-removed">349          offset &gt;= os::vm_page_size();</span>
350 }
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 30 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;oops/compressedOops.hpp&quot;</span>
 32 #include &quot;runtime/icache.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 
 36 
 37 // Implementation of AbstractAssembler
 38 //
 39 // The AbstractAssembler is generating code into a CodeBuffer. To make code generation faster,
 40 // the assembler keeps a copy of the code buffers boundaries &amp; modifies them when
 41 // emitting bytes rather than using the code buffers accessor functions all the time.
 42 // The code buffer is updated via set_code_end(...) after emitting a whole instruction.
 43 
 44 AbstractAssembler::AbstractAssembler(CodeBuffer* code) {
 45   if (code == NULL)  return;
 46   CodeSection* cs = code-&gt;insts();
 47   cs-&gt;clear_mark();   // new assembler kills old mark
 48   if (cs-&gt;start() == NULL)  {
 49     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;CodeCache: no room for %s&quot;, code-&gt;name());
 50   }
 51   _code_section = cs;
</pre>
<hr />
<pre>
200     }
201 
202 #ifdef ASSERT
203     // Cross-section branches only work if the
204     // intermediate section boundaries are frozen.
205     if (target_sect != branch_sect) {
206       for (int n = MIN2(target_sect, branch_sect),
207                nlimit = (target_sect + branch_sect) - n;
208            n &lt; nlimit; n++) {
209         CodeSection* cs = cb-&gt;code_section(n);
210         assert(cs-&gt;is_frozen(), &quot;cross-section branch needs stable offsets&quot;);
211       }
212     }
213 #endif //ASSERT
214 
215     // Push the target offset into the branch instruction.
216     masm-&gt;pd_patch_instruction(branch, target, file, line);
217   }
218 }
219 















































































220 void AbstractAssembler::block_comment(const char* comment) {
221   if (sect() == CodeBuffer::SECT_INSTS) {
222     code_section()-&gt;outer()-&gt;block_comment(offset(), comment);
223   }
224 }
225 
226 const char* AbstractAssembler::code_string(const char* str) {
227   if (sect() == CodeBuffer::SECT_INSTS || sect() == CodeBuffer::SECT_STUBS) {
228     return code_section()-&gt;outer()-&gt;code_string(str);
229   }
230   return NULL;
231 }
232 
233 bool MacroAssembler::uses_implicit_null_check(void* address) {
234   // Exception handler checks the nmethod&#39;s implicit null checks table
235   // only when this method returns false.
<span class="line-modified">236   uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-modified">237   uintptr_t page_size = (uintptr_t)os::vm_page_size();</span>

238 #ifdef _LP64
<span class="line-modified">239   if (UseCompressedOops &amp;&amp; CompressedOops::base() != NULL) {</span>
240     // A SEGV can legitimately happen in C2 code at address
241     // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
242     // is configured to allow narrow oops field loads to be implicitly
243     // null checked
<span class="line-modified">244     uintptr_t start = (uintptr_t)CompressedOops::base();</span>
<span class="line-modified">245     uintptr_t end = start + page_size;</span>
<span class="line-modified">246     if (addr &gt;= start &amp;&amp; addr &lt; end) {</span>
247       return true;
248     }
249   }
250 #endif
<span class="line-modified">251   return addr &lt; page_size;</span>


252 }
253 
254 bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
255   // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
256   // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
257   // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
258   // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
259   // for offsets to be patched in later. The -1 there means the offset is not yet known
260   // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
<span class="line-modified">261   // an explicit null check for -1.</span>



262 
<span class="line-modified">263   // Check if offset is outside of [0, os::vm_page_size()]</span>
<span class="line-modified">264   return offset &lt; 0 || offset &gt;= os::vm_page_size();</span>

265 }
</pre>
</td>
</tr>
</table>
<center><a href="../aot/aotLoader.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
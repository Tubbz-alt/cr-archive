<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/asm/codeBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_ASM_CODEBUFFER_HPP
 26 #define SHARE_ASM_CODEBUFFER_HPP
 27 
 28 #include &quot;code/oopRecorder.hpp&quot;
 29 #include &quot;code/relocInfo.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 class CodeStrings;
 35 class PhaseCFG;
 36 class Compile;
 37 class BufferBlob;
 38 class CodeBuffer;
 39 class Label;
 40 
 41 class CodeOffsets: public StackObj {
 42 public:
 43   enum Entries { Entry,
 44                  Verified_Entry,
 45                  Frame_Complete, // Offset in the code where the frame setup is (for forte stackwalks) is complete
 46                  OSR_Entry,
 47                  Exceptions,     // Offset where exception handler lives
 48                  Deopt,          // Offset where deopt handler lives
 49                  DeoptMH,        // Offset where MethodHandle deopt handler lives
 50                  UnwindHandler,  // Offset to default unwind handler
 51                  max_Entries };
 52 
 53   // special value to note codeBlobs where profile (forte) stack walking is
 54   // always dangerous and suspect.
 55 
 56   enum { frame_never_safe = -1 };
 57 
 58 private:
 59   int _values[max_Entries];
 60 
 61 public:
 62   CodeOffsets() {
 63     _values[Entry         ] = 0;
 64     _values[Verified_Entry] = 0;
 65     _values[Frame_Complete] = frame_never_safe;
 66     _values[OSR_Entry     ] = 0;
 67     _values[Exceptions    ] = -1;
 68     _values[Deopt         ] = -1;
 69     _values[DeoptMH       ] = -1;
 70     _values[UnwindHandler ] = -1;
 71   }
 72 
 73   int value(Entries e) { return _values[e]; }
 74   void set_value(Entries e, int val) { _values[e] = val; }
 75 };
 76 
 77 // This class represents a stream of code and associated relocations.
 78 // There are a few in each CodeBuffer.
 79 // They are filled concurrently, and concatenated at the end.
 80 class CodeSection {
 81   friend class CodeBuffer;
 82  public:
 83   typedef int csize_t;  // code size type; would be size_t except for history
 84 
 85  private:
 86   address     _start;           // first byte of contents (instructions)
 87   address     _mark;            // user mark, usually an instruction beginning
 88   address     _end;             // current end address
 89   address     _limit;           // last possible (allocated) end address
 90   relocInfo*  _locs_start;      // first byte of relocation information
 91   relocInfo*  _locs_end;        // first byte after relocation information
 92   relocInfo*  _locs_limit;      // first byte after relocation information buf
 93   address     _locs_point;      // last relocated position (grows upward)
 94   bool        _locs_own;        // did I allocate the locs myself?
 95   bool        _frozen;          // no more expansion of this section
 96   bool        _scratch_emit;    // Buffer is used for scratch emit, don&#39;t relocate.
 97   char        _index;           // my section number (SECT_INST, etc.)
 98   CodeBuffer* _outer;           // enclosing CodeBuffer
 99 
100   // (Note:  _locs_point used to be called _last_reloc_offset.)
101 
102   CodeSection() {
103     _start         = NULL;
104     _mark          = NULL;
105     _end           = NULL;
106     _limit         = NULL;
107     _locs_start    = NULL;
108     _locs_end      = NULL;
109     _locs_limit    = NULL;
110     _locs_point    = NULL;
111     _locs_own      = false;
112     _frozen        = false;
113     _scratch_emit  = false;
114     debug_only(_index = (char)-1);
115     debug_only(_outer = (CodeBuffer*)badAddress);
116   }
117 
118   void initialize_outer(CodeBuffer* outer, int index) {
119     _outer = outer;
120     _index = index;
121   }
122 
123   void initialize(address start, csize_t size = 0) {
124     assert(_start == NULL, &quot;only one init step, please&quot;);
125     _start         = start;
126     _mark          = NULL;
127     _end           = start;
128 
129     _limit         = start + size;
130     _locs_point    = start;
131   }
132 
133   void initialize_locs(int locs_capacity);
134   void expand_locs(int new_capacity);
135   void initialize_locs_from(const CodeSection* source_cs);
136 
137   // helper for CodeBuffer::expand()
138   void take_over_code_from(CodeSection* cs) {
139     _start      = cs-&gt;_start;
140     _mark       = cs-&gt;_mark;
141     _end        = cs-&gt;_end;
142     _limit      = cs-&gt;_limit;
143     _locs_point = cs-&gt;_locs_point;
144   }
145 
146  public:
147   address     start() const         { return _start; }
148   address     mark() const          { return _mark; }
149   address     end() const           { return _end; }
150   address     limit() const         { return _limit; }
151   csize_t     size() const          { return (csize_t)(_end - _start); }
152   csize_t     mark_off() const      { assert(_mark != NULL, &quot;not an offset&quot;);
153                                       return (csize_t)(_mark - _start); }
154   csize_t     capacity() const      { return (csize_t)(_limit - _start); }
155   csize_t     remaining() const     { return (csize_t)(_limit - _end); }
156 
157   relocInfo*  locs_start() const    { return _locs_start; }
158   relocInfo*  locs_end() const      { return _locs_end; }
159   int         locs_count() const    { return (int)(_locs_end - _locs_start); }
160   relocInfo*  locs_limit() const    { return _locs_limit; }
161   address     locs_point() const    { return _locs_point; }
162   csize_t     locs_point_off() const{ return (csize_t)(_locs_point - _start); }
163   csize_t     locs_capacity() const { return (csize_t)(_locs_limit - _locs_start); }
164   csize_t     locs_remaining()const { return (csize_t)(_locs_limit - _locs_end); }
165 
166   int         index() const         { return _index; }
167   bool        is_allocated() const  { return _start != NULL; }
168   bool        is_empty() const      { return _start == _end; }
169   bool        is_frozen() const     { return _frozen; }
170   bool        has_locs() const      { return _locs_end != NULL; }
171 
172   // Mark scratch buffer.
173   void        set_scratch_emit()    { _scratch_emit = true; }
174   bool        scratch_emit()        { return _scratch_emit; }
175 
176   CodeBuffer* outer() const         { return _outer; }
177 
178   // is a given address in this section?  (2nd version is end-inclusive)
179   bool contains(address pc) const   { return pc &gt;= _start &amp;&amp; pc &lt;  _end; }
180   bool contains2(address pc) const  { return pc &gt;= _start &amp;&amp; pc &lt;= _end; }
181   bool allocates(address pc) const  { return pc &gt;= _start &amp;&amp; pc &lt;  _limit; }
182   bool allocates2(address pc) const { return pc &gt;= _start &amp;&amp; pc &lt;= _limit; }
183 
184   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
185   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
186                                       _mark = pc; }
187   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
188                                       _mark = offset + _start; }
189   void    set_mark()                { _mark = _end; }
190   void    clear_mark()              { _mark = NULL; }
191 
192   void    set_locs_end(relocInfo* p) {
193     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
194     _locs_end = p;
195   }
196   void    set_locs_point(address pc) {
197     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
198     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
199     _locs_point = pc;
200   }
201 
202   // Code emission
203   void emit_int8 ( int8_t  x)  { *((int8_t*)  end()) = x; set_end(end() + sizeof(int8_t)); }
204   void emit_int16( int16_t x)  { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }
205   void emit_int32( int32_t x)  { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }
206   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
207 
208   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
209   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
210   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
211 
212   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
213   void initialize_shared_locs(relocInfo* buf, int length);
214 
215   // Manage labels and their addresses.
216   address target(Label&amp; L, address branch_pc);
217 
218   // Emit a relocation.
219   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
220   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
221 
222   // alignment requirement for starting offset
223   // Requirements are that the instruction area and the
224   // stubs area must start on CodeEntryAlignment, and
225   // the ctable on sizeof(jdouble)
226   int alignment() const             { return MAX2((int)sizeof(jdouble), (int)CodeEntryAlignment); }
227 
228   // Slop between sections, used only when allocating temporary BufferBlob buffers.
229   static csize_t end_slop()         { return MAX2((int)sizeof(jdouble), (int)CodeEntryAlignment); }
230 
231   csize_t align_at_start(csize_t off) const { return (csize_t) align_up(off, alignment()); }
232 
233   // Mark a section frozen.  Assign its remaining space to
234   // the following section.  It will never expand after this point.
235   inline void freeze();         //  { _outer-&gt;freeze_section(this); }
236 
237   // Ensure there&#39;s enough space left in the current section.
238   // Return true if there was an expansion.
239   bool maybe_expand_to_ensure_remaining(csize_t amount);
240 
241 #ifndef PRODUCT
242   void decode();
243   void print(const char* name);
244 #endif //PRODUCT
245 };
246 
247 class CodeString;
248 class CodeStrings {
249 private:
250 #ifndef PRODUCT
251   CodeString* _strings;
<a name="1" id="anc1"></a>
252 #ifdef ASSERT
253   // Becomes true after copy-out, forbids further use.
254   bool _defunct; // Zero bit pattern is &quot;valid&quot;, see memset call in decode_env::decode_env
255 #endif
256   static const char* _prefix; // defaults to &quot; ;; &quot;
257 #endif
258 
259   CodeString* find(intptr_t offset) const;
260   CodeString* find_last(intptr_t offset) const;
261 
262   void set_null_and_invalidate() {
263 #ifndef PRODUCT
264     _strings = NULL;
<a name="2" id="anc2"></a>
265 #ifdef ASSERT
266     _defunct = true;
267 #endif
268 #endif
269   }
270 
271 public:
272   CodeStrings() {
273 #ifndef PRODUCT
274     _strings = NULL;
<a name="3" id="anc3"></a>
275 #ifdef ASSERT
276     _defunct = false;
277 #endif
278 #endif
279   }
280 
281   bool is_null() {
282 #ifdef ASSERT
283     return _strings == NULL;
284 #else
285     return true;
286 #endif
287   }
288 
289   const char* add_string(const char * string) PRODUCT_RETURN_(return NULL;);
290 
291   void add_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
<a name="4" id="anc4"></a>
292   void print_block_comment(outputStream* stream, intptr_t offset) const PRODUCT_RETURN;
293   // MOVE strings from other to this; invalidate other.
294   void assign(CodeStrings&amp; other)  PRODUCT_RETURN;
295   // COPY strings from other to this; leave other valid.
296   void copy(CodeStrings&amp; other)  PRODUCT_RETURN;
297   // FREE strings; invalidate this.
298   void free() PRODUCT_RETURN;
<a name="5" id="anc5"></a>
299   // Guarantee that _strings are used at most once; assign and free invalidate a buffer.
300   inline void check_valid() const {
301 #ifdef ASSERT
302     assert(!_defunct, &quot;Use of invalid CodeStrings&quot;);
303 #endif
304   }
305 
306   static void set_prefix(const char *prefix) {
307 #ifndef PRODUCT
308     _prefix = prefix;
309 #endif
310   }
311 };
312 
313 // A CodeBuffer describes a memory space into which assembly
314 // code is generated.  This memory space usually occupies the
315 // interior of a single BufferBlob, but in some cases it may be
316 // an arbitrary span of memory, even outside the code cache.
317 //
318 // A code buffer comes in two variants:
319 //
320 // (1) A CodeBuffer referring to an already allocated piece of memory:
321 //     This is used to direct &#39;static&#39; code generation (e.g. for interpreter
322 //     or stubroutine generation, etc.).  This code comes with NO relocation
323 //     information.
324 //
325 // (2) A CodeBuffer referring to a piece of memory allocated when the
326 //     CodeBuffer is allocated.  This is used for nmethod generation.
327 //
328 // The memory can be divided up into several parts called sections.
329 // Each section independently accumulates code (or data) an relocations.
330 // Sections can grow (at the expense of a reallocation of the BufferBlob
331 // and recopying of all active sections).  When the buffered code is finally
332 // written to an nmethod (or other CodeBlob), the contents (code, data,
333 // and relocations) of the sections are padded to an alignment and concatenated.
334 // Instructions and data in one section can contain relocatable references to
335 // addresses in a sibling section.
336 
337 class CodeBuffer: public StackObj {
338   friend class CodeSection;
339   friend class StubCodeGenerator;
340 
341  private:
342   // CodeBuffers must be allocated on the stack except for a single
343   // special case during expansion which is handled internally.  This
344   // is done to guarantee proper cleanup of resources.
345   void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }
346   void  operator delete(void* p)          { ShouldNotCallThis(); }
347 
348  public:
349   typedef int csize_t;  // code size type; would be size_t except for history
350   enum {
351     // Here is the list of all possible sections.  The order reflects
352     // the final layout.
353     SECT_FIRST = 0,
354     SECT_CONSTS = SECT_FIRST, // Non-instruction data:  Floats, jump tables, etc.
355     SECT_INSTS,               // Executable instructions.
356     SECT_STUBS,               // Outbound trampolines for supporting call sites.
357     SECT_LIMIT, SECT_NONE = -1
358   };
359 
360  private:
361   enum {
362     sect_bits = 2,      // assert (SECT_LIMIT &lt;= (1&lt;&lt;sect_bits))
363     sect_mask = (1&lt;&lt;sect_bits)-1
364   };
365 
366   const char*  _name;
367 
368   CodeSection  _consts;             // constants, jump tables
369   CodeSection  _insts;              // instructions (the main section)
370   CodeSection  _stubs;              // stubs (call site support), deopt, exception handling
371 
372   CodeBuffer*  _before_expand;  // dead buffer, from before the last expansion
373 
374   BufferBlob*  _blob;           // optional buffer in CodeCache for generated code
375   address      _total_start;    // first address of combined memory buffer
376   csize_t      _total_size;     // size in bytes of combined memory buffer
377 
378   OopRecorder* _oop_recorder;
379   CodeStrings  _code_strings;
<a name="6" id="anc6"></a>
380   OopRecorder  _default_oop_recorder;  // override with initialize_oop_recorder
381   Arena*       _overflow_arena;
382 
383   address      _last_insn;      // used to merge consecutive memory barriers, loads or stores.
384 
385 #if INCLUDE_AOT
386   bool         _immutable_PIC;
387 #endif
388 
389   address      _decode_begin;   // start address for decode
390   address      decode_begin();
391 
392   void initialize_misc(const char * name) {
393     // all pointers other than code_start/end and those inside the sections
394     assert(name != NULL, &quot;must have a name&quot;);
395     _name            = name;
396     _before_expand   = NULL;
397     _blob            = NULL;
398     _oop_recorder    = NULL;
399     _decode_begin    = NULL;
400     _overflow_arena  = NULL;
401     _code_strings    = CodeStrings();
402     _last_insn       = NULL;
403 #if INCLUDE_AOT
404     _immutable_PIC   = false;
405 #endif
<a name="7" id="anc7"></a>








406   }
407 
408   void initialize(address code_start, csize_t code_size) {
409     _consts.initialize_outer(this,  SECT_CONSTS);
410     _insts.initialize_outer(this,   SECT_INSTS);
411     _stubs.initialize_outer(this,   SECT_STUBS);
412     _total_start = code_start;
413     _total_size  = code_size;
414     // Initialize the main section:
415     _insts.initialize(code_start, code_size);
416     assert(!_stubs.is_allocated(),  &quot;no garbage here&quot;);
417     assert(!_consts.is_allocated(), &quot;no garbage here&quot;);
418     _oop_recorder = &amp;_default_oop_recorder;
419   }
420 
421   void initialize_section_size(CodeSection* cs, csize_t size);
422 
423   void freeze_section(CodeSection* cs);
424 
425   // helper for CodeBuffer::expand()
426   void take_over_code_from(CodeBuffer* cs);
427 
428   // ensure sections are disjoint, ordered, and contained in the blob
429   void verify_section_allocation();
430 
431   // copies combined relocations to the blob, returns bytes copied
432   // (if target is null, it is a dry run only, just for sizing)
433   csize_t copy_relocations_to(CodeBlob* blob) const;
434 
435   // copies combined code to the blob (assumes relocs are already in there)
436   void copy_code_to(CodeBlob* blob);
437 
438   // moves code sections to new buffer (assumes relocs are already in there)
439   void relocate_code_to(CodeBuffer* cb) const;
440 
441   // set up a model of the final layout of my contents
442   void compute_final_layout(CodeBuffer* dest) const;
443 
444   // Expand the given section so at least &#39;amount&#39; is remaining.
445   // Creates a new, larger BufferBlob, and rewrites the code &amp; relocs.
446   void expand(CodeSection* which_cs, csize_t amount);
447 
448   // Helper for expand.
449   csize_t figure_expanded_capacities(CodeSection* which_cs, csize_t amount, csize_t* new_capacity);
450 
451  public:
452   // (1) code buffer referring to pre-allocated instruction memory
453   CodeBuffer(address code_start, csize_t code_size) {
454     assert(code_start != NULL, &quot;sanity&quot;);
455     initialize_misc(&quot;static buffer&quot;);
456     initialize(code_start, code_size);
457     verify_section_allocation();
458   }
459 
460   // (2) CodeBuffer referring to pre-allocated CodeBlob.
461   CodeBuffer(CodeBlob* blob);
462 
463   // (3) code buffer allocating codeBlob memory for code &amp; relocation
464   // info but with lazy initialization.  The name must be something
465   // informative.
466   CodeBuffer(const char* name) {
467     initialize_misc(name);
468   }
469 
470   // (4) code buffer allocating codeBlob memory for code &amp; relocation
471   // info.  The name must be something informative and code_size must
472   // include both code and stubs sizes.
473   CodeBuffer(const char* name, csize_t code_size, csize_t locs_size) {
474     initialize_misc(name);
475     initialize(code_size, locs_size);
476   }
477 
478   ~CodeBuffer();
479 
480   // Initialize a CodeBuffer constructed using constructor 3.  Using
481   // constructor 4 is equivalent to calling constructor 3 and then
482   // calling this method.  It&#39;s been factored out for convenience of
483   // construction.
484   void initialize(csize_t code_size, csize_t locs_size);
485 
486   CodeSection* consts() { return &amp;_consts; }
487   CodeSection* insts() { return &amp;_insts; }
488   CodeSection* stubs() { return &amp;_stubs; }
489 
490   const CodeSection* insts() const { return &amp;_insts; }
491 
492   // present sections in order; return NULL at end; consts is #0, etc.
493   CodeSection* code_section(int n) {
494     // This makes the slightly questionable but portable assumption
495     // that the various members (_consts, _insts, _stubs, etc.) are
496     // adjacent in the layout of CodeBuffer.
497     CodeSection* cs = &amp;_consts + n;
498     assert(cs-&gt;index() == n || !cs-&gt;is_allocated(), &quot;sanity&quot;);
499     return cs;
500   }
501   const CodeSection* code_section(int n) const {  // yucky const stuff
502     return ((CodeBuffer*)this)-&gt;code_section(n);
503   }
504   static const char* code_section_name(int n);
505   int section_index_of(address addr) const;
506   bool contains(address addr) const {
507     // handy for debugging
508     return section_index_of(addr) &gt; SECT_NONE;
509   }
510 
511   // A stable mapping between &#39;locators&#39; (small ints) and addresses.
512   static int locator_pos(int locator)   { return locator &gt;&gt; sect_bits; }
513   static int locator_sect(int locator)  { return locator &amp;  sect_mask; }
514   static int locator(int pos, int sect) { return (pos &lt;&lt; sect_bits) | sect; }
515   int        locator(address addr) const;
516   address    locator_address(int locator) const;
517 
518   // Heuristic for pre-packing the taken/not-taken bit of a predicted branch.
519   bool is_backward_branch(Label&amp; L);
520 
521   // Properties
522   const char* name() const                  { return _name; }
523   void set_name(const char* name)           { _name = name; }
524   CodeBuffer* before_expand() const         { return _before_expand; }
525   BufferBlob* blob() const                  { return _blob; }
526   void    set_blob(BufferBlob* blob);
527   void   free_blob();                       // Free the blob, if we own one.
528 
529   // Properties relative to the insts section:
530   address       insts_begin() const      { return _insts.start();      }
531   address       insts_end() const        { return _insts.end();        }
532   void      set_insts_end(address end)   {        _insts.set_end(end); }
533   address       insts_limit() const      { return _insts.limit();      }
534   address       insts_mark() const       { return _insts.mark();       }
535   void      set_insts_mark()             {        _insts.set_mark();   }
536   void    clear_insts_mark()             {        _insts.clear_mark(); }
537 
538   // is there anything in the buffer other than the current section?
539   bool    is_pure() const                { return insts_size() == total_content_size(); }
540 
541   // size in bytes of output so far in the insts sections
542   csize_t insts_size() const             { return _insts.size(); }
543 
544   // same as insts_size(), except that it asserts there is no non-code here
545   csize_t pure_insts_size() const        { assert(is_pure(), &quot;no non-code&quot;);
546                                            return insts_size(); }
547   // capacity in bytes of the insts sections
548   csize_t insts_capacity() const         { return _insts.capacity(); }
549 
550   // number of bytes remaining in the insts section
551   csize_t insts_remaining() const        { return _insts.remaining(); }
552 
553   // is a given address in the insts section?  (2nd version is end-inclusive)
554   bool insts_contains(address pc) const  { return _insts.contains(pc); }
555   bool insts_contains2(address pc) const { return _insts.contains2(pc); }
556 
557   // Record any extra oops required to keep embedded metadata alive
558   void finalize_oop_references(const methodHandle&amp; method);
559 
560   // Allocated size in all sections, when aligned and concatenated
561   // (this is the eventual state of the content in its final
562   // CodeBlob).
563   csize_t total_content_size() const;
564 
565   // Combined offset (relative to start of first section) of given
566   // section, as eventually found in the final CodeBlob.
567   csize_t total_offset_of(const CodeSection* cs) const;
568 
569   // allocated size of all relocation data, including index, rounded up
570   csize_t total_relocation_size() const;
571 
572   csize_t copy_relocations_to(address buf, csize_t buf_limit, bool only_inst) const;
573 
574   // allocated size of any and all recorded oops
575   csize_t total_oop_size() const {
576     OopRecorder* recorder = oop_recorder();
577     return (recorder == NULL)? 0: recorder-&gt;oop_size();
578   }
579 
580   // allocated size of any and all recorded metadata
581   csize_t total_metadata_size() const {
582     OopRecorder* recorder = oop_recorder();
583     return (recorder == NULL)? 0: recorder-&gt;metadata_size();
584   }
585 
586   // Configuration functions, called immediately after the CB is constructed.
587   // The section sizes are subtracted from the original insts section.
588   // Note:  Call them in reverse section order, because each steals from insts.
589   void initialize_consts_size(csize_t size)            { initialize_section_size(&amp;_consts,  size); }
590   void initialize_stubs_size(csize_t size)             { initialize_section_size(&amp;_stubs,   size); }
591   // Override default oop recorder.
592   void initialize_oop_recorder(OopRecorder* r);
593 
594   OopRecorder* oop_recorder() const   { return _oop_recorder; }
595   CodeStrings&amp; strings()              { return _code_strings; }
596 
597   address last_insn() const { return _last_insn; }
598   void set_last_insn(address a) { _last_insn = a; }
599   void clear_last_insn() { set_last_insn(NULL); }
600 
601   void free_strings() {
602     if (!_code_strings.is_null()) {
603       _code_strings.free(); // sets _strings Null as a side-effect.
604     }
605   }
606 
<a name="8" id="anc8"></a>
















607   // Code generation
608   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0) {
609     _insts.relocate(at, rspec, format);
610   }
611   void relocate(address at,    relocInfo::relocType rtype, int format = 0) {
612     _insts.relocate(at, rtype, format);
613   }
614 
615   // Management of overflow storage for binding of Labels.
616   GrowableArray&lt;int&gt;* create_patch_overflow();
617 
618   // NMethod generation
619   void copy_code_and_locs_to(CodeBlob* blob) {
620     assert(blob != NULL, &quot;sane&quot;);
621     copy_relocations_to(blob);
622     copy_code_to(blob);
623   }
624   void copy_values_to(nmethod* nm) {
625     if (!oop_recorder()-&gt;is_unused()) {
626       oop_recorder()-&gt;copy_values_to(nm);
627     }
628   }
629 
630   // Transform an address from the code in this code buffer to a specified code buffer
631   address transform_address(const CodeBuffer &amp;cb, address addr) const;
632 
633   void block_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
634   const char* code_string(const char* str) PRODUCT_RETURN_(return NULL;);
635 
636   // Log a little info about section usage in the CodeBuffer
637   void log_section_sizes(const char* name);
638 
639 #if INCLUDE_AOT
640   // True if this is a code buffer used for immutable PIC, i.e. AOT
641   // compilation.
642   bool immutable_PIC() { return _immutable_PIC; }
643   void set_immutable_PIC(bool pic) { _immutable_PIC = pic; }
644 #endif
645 
646 #ifndef PRODUCT
647  public:
648   // Printing / Decoding
649   // decodes from decode_begin() to code_end() and sets decode_begin to end
650   void    decode();
651   void    print();
652 #endif
<a name="9" id="anc9"></a><span class="line-modified">653 </span>

654 
655   // The following header contains architecture-specific implementations
656 #include CPU_HEADER(codeBuffer)
657 
658 };
659 
660 
661 inline void CodeSection::freeze() {
662   _outer-&gt;freeze_section(this);
663 }
664 
665 inline bool CodeSection::maybe_expand_to_ensure_remaining(csize_t amount) {
666   if (remaining() &lt; amount) { _outer-&gt;expand(this, amount); return true; }
667   return false;
668 }
669 
670 #endif // SHARE_ASM_CODEBUFFER_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
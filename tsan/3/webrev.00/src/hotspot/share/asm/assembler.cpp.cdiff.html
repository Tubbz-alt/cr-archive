<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/asm/assembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aot/aotLoader.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/assembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/codeBuffer.hpp&quot;
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  
  
<span class="line-new-header">--- 25,12 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/codeBuffer.hpp&quot;
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,89 ***</span>
      // Push the target offset into the branch instruction.
      masm-&gt;pd_patch_instruction(branch, target, file, line);
    }
  }
  
<span class="line-removed">- struct DelayedConstant {</span>
<span class="line-removed">-   typedef void (*value_fn_t)();</span>
<span class="line-removed">-   BasicType type;</span>
<span class="line-removed">-   intptr_t value;</span>
<span class="line-removed">-   value_fn_t value_fn;</span>
<span class="line-removed">-   // This limit of 20 is generous for initial uses.</span>
<span class="line-removed">-   // The limit needs to be large enough to store the field offsets</span>
<span class="line-removed">-   // into classes which do not have statically fixed layouts.</span>
<span class="line-removed">-   // (Initial use is for method handle object offsets.)</span>
<span class="line-removed">-   // Look for uses of &quot;delayed_value&quot; in the source code</span>
<span class="line-removed">-   // and make sure this number is generous enough to handle all of them.</span>
<span class="line-removed">-   enum { DC_LIMIT = 20 };</span>
<span class="line-removed">-   static DelayedConstant delayed_constants[DC_LIMIT];</span>
<span class="line-removed">-   static DelayedConstant* add(BasicType type, value_fn_t value_fn);</span>
<span class="line-removed">-   bool match(BasicType t, value_fn_t cfn) {</span>
<span class="line-removed">-     return type == t &amp;&amp; value_fn == cfn;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   static void update_all();</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- DelayedConstant DelayedConstant::delayed_constants[DC_LIMIT];</span>
<span class="line-removed">- // Default C structure initialization rules have the following effect here:</span>
<span class="line-removed">- // = { { (BasicType)0, (intptr_t)NULL }, ... };</span>
<span class="line-removed">- </span>
<span class="line-removed">- DelayedConstant* DelayedConstant::add(BasicType type,</span>
<span class="line-removed">-                                       DelayedConstant::value_fn_t cfn) {</span>
<span class="line-removed">-   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">-     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">-     if (dcon-&gt;match(type, cfn))</span>
<span class="line-removed">-       return dcon;</span>
<span class="line-removed">-     if (dcon-&gt;value_fn == NULL) {</span>
<span class="line-removed">-         dcon-&gt;value_fn = cfn;</span>
<span class="line-removed">-         dcon-&gt;type = type;</span>
<span class="line-removed">-         return dcon;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // If this assert is hit (in pre-integration testing!) then re-evaluate</span>
<span class="line-removed">-   // the comment on the definition of DC_LIMIT.</span>
<span class="line-removed">-   guarantee(false, &quot;too many delayed constants&quot;);</span>
<span class="line-removed">-   return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void DelayedConstant::update_all() {</span>
<span class="line-removed">-   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">-     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">-     if (dcon-&gt;value_fn != NULL &amp;&amp; dcon-&gt;value == 0) {</span>
<span class="line-removed">-       typedef int     (*int_fn_t)();</span>
<span class="line-removed">-       typedef address (*address_fn_t)();</span>
<span class="line-removed">-       switch (dcon-&gt;type) {</span>
<span class="line-removed">-       case T_INT:     dcon-&gt;value = (intptr_t) ((int_fn_t)    dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">-       case T_ADDRESS: dcon-&gt;value = (intptr_t) ((address_fn_t)dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">-       default:        break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RegisterOrConstant AbstractAssembler::delayed_value(int(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">-   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">-   if (val != 0)  return val + offset;</span>
<span class="line-removed">-   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- RegisterOrConstant AbstractAssembler::delayed_value(address(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">-   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">-   if (val != 0)  return val + offset;</span>
<span class="line-removed">-   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- intptr_t* AbstractAssembler::delayed_value_addr(int(*value_fn)()) {</span>
<span class="line-removed">-   DelayedConstant* dcon = DelayedConstant::add(T_INT, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">-   return &amp;dcon-&gt;value;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- intptr_t* AbstractAssembler::delayed_value_addr(address(*value_fn)()) {</span>
<span class="line-removed">-   DelayedConstant* dcon = DelayedConstant::add(T_ADDRESS, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">-   return &amp;dcon-&gt;value;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- void AbstractAssembler::update_delayed_values() {</span>
<span class="line-removed">-   DelayedConstant::update_all();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void AbstractAssembler::block_comment(const char* comment) {
    if (sect() == CodeBuffer::SECT_INSTS) {
      code_section()-&gt;outer()-&gt;block_comment(offset(), comment);
    }
  }
<span class="line-new-header">--- 215,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,42 ***</span>
  }
  
  bool MacroAssembler::uses_implicit_null_check(void* address) {
    // Exception handler checks the nmethod&#39;s implicit null checks table
    // only when this method returns false.
<span class="line-modified">!   intptr_t int_address = reinterpret_cast&lt;intptr_t&gt;(address);</span>
<span class="line-modified">!   intptr_t cell_header_size = Universe::heap()-&gt;cell_header_size();</span>
<span class="line-removed">-   size_t region_size = os::vm_page_size() + cell_header_size;</span>
  #ifdef _LP64
<span class="line-modified">!   if (UseCompressedOops &amp;&amp; Universe::narrow_oop_base() != NULL) {</span>
      // A SEGV can legitimately happen in C2 code at address
      // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
      // is configured to allow narrow oops field loads to be implicitly
      // null checked
<span class="line-modified">!     intptr_t start = ((intptr_t)Universe::narrow_oop_base()) - cell_header_size;</span>
<span class="line-modified">!     intptr_t end = start + region_size;</span>
<span class="line-modified">!     if (int_address &gt;= start &amp;&amp; int_address &lt; end) {</span>
        return true;
      }
    }
  #endif
<span class="line-modified">!   intptr_t start = -cell_header_size;</span>
<span class="line-removed">-   intptr_t end = start + region_size;</span>
<span class="line-removed">-   return int_address &gt;= start &amp;&amp; int_address &lt; end;</span>
  }
  
  bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
    // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
    // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
    // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
    // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
    // for offsets to be patched in later. The -1 there means the offset is not yet known
    // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
<span class="line-modified">!   // an explicit null check for -1, even if it may otherwise be in the range</span>
<span class="line-removed">-   // [-cell_header_size, os::vm_page_size).</span>
<span class="line-removed">-   // TODO: Find and replace all relevant uses of -1 with a reasonably named constant.</span>
<span class="line-removed">-   if (offset == -1) return true;</span>
  
<span class="line-modified">!   // Check if offset is outside of [-cell_header_size, os::vm_page_size)</span>
<span class="line-modified">!   return offset &lt; -Universe::heap()-&gt;cell_header_size() ||</span>
<span class="line-removed">-          offset &gt;= os::vm_page_size();</span>
  }
<span class="line-new-header">--- 231,35 ---</span>
  }
  
  bool MacroAssembler::uses_implicit_null_check(void* address) {
    // Exception handler checks the nmethod&#39;s implicit null checks table
    // only when this method returns false.
<span class="line-modified">!   uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-modified">!   uintptr_t page_size = (uintptr_t)os::vm_page_size();</span>
  #ifdef _LP64
<span class="line-modified">!   if (UseCompressedOops &amp;&amp; CompressedOops::base() != NULL) {</span>
      // A SEGV can legitimately happen in C2 code at address
      // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
      // is configured to allow narrow oops field loads to be implicitly
      // null checked
<span class="line-modified">!     uintptr_t start = (uintptr_t)CompressedOops::base();</span>
<span class="line-modified">!     uintptr_t end = start + page_size;</span>
<span class="line-modified">!     if (addr &gt;= start &amp;&amp; addr &lt; end) {</span>
        return true;
      }
    }
  #endif
<span class="line-modified">!   return addr &lt; page_size;</span>
  }
  
  bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
    // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
    // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
    // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
    // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
    // for offsets to be patched in later. The -1 there means the offset is not yet known
    // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
<span class="line-modified">!   // an explicit null check for -1.</span>
  
<span class="line-modified">!   // Check if offset is outside of [0, os::vm_page_size()]</span>
<span class="line-modified">!   return offset &lt; 0 || offset &gt;= os::vm_page_size();</span>
  }
</pre>
<center><a href="../aot/aotLoader.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/asm/assembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;runtime/atomic.hpp&quot;</span>

 31 #include &quot;runtime/icache.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 
 36 // Implementation of AbstractAssembler
 37 //
 38 // The AbstractAssembler is generating code into a CodeBuffer. To make code generation faster,
 39 // the assembler keeps a copy of the code buffers boundaries &amp; modifies them when
 40 // emitting bytes rather than using the code buffers accessor functions all the time.
 41 // The code buffer is updated via set_code_end(...) after emitting a whole instruction.
 42 
 43 AbstractAssembler::AbstractAssembler(CodeBuffer* code) {
 44   if (code == NULL)  return;
 45   CodeSection* cs = code-&gt;insts();
 46   cs-&gt;clear_mark();   // new assembler kills old mark
 47   if (cs-&gt;start() == NULL)  {
 48     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;CodeCache: no room for %s&quot;, code-&gt;name());
 49   }
 50   _code_section = cs;
 51   _oop_recorder= code-&gt;oop_recorder();
 52   DEBUG_ONLY( _short_branch_delta = 0; )
 53 }
 54 
 55 void AbstractAssembler::set_code_section(CodeSection* cs) {
 56   assert(cs-&gt;outer() == code_section()-&gt;outer(), &quot;sanity&quot;);
 57   assert(cs-&gt;is_allocated(), &quot;need to pre-allocate this section&quot;);
 58   cs-&gt;clear_mark();  // new assembly into this section kills old mark
 59   _code_section = cs;
 60 }
 61 
 62 // Inform CodeBuffer that incoming code and relocation will be for stubs
 63 address AbstractAssembler::start_a_stub(int required_space) {
 64   CodeBuffer*  cb = code();
 65   CodeSection* cs = cb-&gt;stubs();
 66   assert(_code_section == cb-&gt;insts(), &quot;not in insts?&quot;);
 67   if (cs-&gt;maybe_expand_to_ensure_remaining(required_space)
 68       &amp;&amp; cb-&gt;blob() == NULL) {
 69     return NULL;
 70   }
 71   set_code_section(cs);
 72   return pc();
 73 }
 74 
 75 // Inform CodeBuffer that incoming code and relocation will be code
 76 // Should not be called if start_a_stub() returned NULL
 77 void AbstractAssembler::end_a_stub() {
 78   assert(_code_section == code()-&gt;stubs(), &quot;not in stubs?&quot;);
 79   set_code_section(code()-&gt;insts());
 80 }
 81 
 82 // Inform CodeBuffer that incoming code and relocation will be for stubs
 83 address AbstractAssembler::start_a_const(int required_space, int required_align) {
 84   CodeBuffer*  cb = code();
 85   CodeSection* cs = cb-&gt;consts();
 86   assert(_code_section == cb-&gt;insts() || _code_section == cb-&gt;stubs(), &quot;not in insts/stubs?&quot;);
 87   address end = cs-&gt;end();
 88   int pad = -(intptr_t)end &amp; (required_align-1);
 89   if (cs-&gt;maybe_expand_to_ensure_remaining(pad + required_space)) {
 90     if (cb-&gt;blob() == NULL)  return NULL;
 91     end = cs-&gt;end();  // refresh pointer
 92   }
 93   if (pad &gt; 0) {
 94     while (--pad &gt;= 0) { *end++ = 0; }
 95     cs-&gt;set_end(end);
 96   }
 97   set_code_section(cs);
 98   return end;
 99 }
100 
101 // Inform CodeBuffer that incoming code and relocation will be code
102 // in section cs (insts or stubs).
103 void AbstractAssembler::end_a_const(CodeSection* cs) {
104   assert(_code_section == code()-&gt;consts(), &quot;not in consts?&quot;);
105   set_code_section(cs);
106 }
107 
108 void AbstractAssembler::flush() {
109   ICache::invalidate_range(addr_at(0), offset());
110 }
111 
112 void AbstractAssembler::bind(Label&amp; L) {
113   if (L.is_bound()) {
114     // Assembler can bind a label more than once to the same place.
115     guarantee(L.loc() == locator(), &quot;attempt to redefine label&quot;);
116     return;
117   }
118   L.bind_loc(locator());
119   L.patch_instructions((MacroAssembler*)this);
120 }
121 
122 void AbstractAssembler::generate_stack_overflow_check(int frame_size_in_bytes) {
123   if (UseStackBanging) {
124     // Each code entry causes one stack bang n pages down the stack where n
125     // is configurable by StackShadowPages.  The setting depends on the maximum
126     // depth of VM call stack or native before going back into java code,
127     // since only java code can raise a stack overflow exception using the
128     // stack banging mechanism.  The VM and native code does not detect stack
129     // overflow.
130     // The code in JavaCalls::call() checks that there is at least n pages
131     // available, so all entry code needs to do is bang once for the end of
132     // this shadow zone.
133     // The entry code may need to bang additional pages if the framesize
134     // is greater than a page.
135 
136     const int page_size = os::vm_page_size();
137     int bang_end = (int)JavaThread::stack_shadow_zone_size();
138 
139     // This is how far the previous frame&#39;s stack banging extended.
140     const int bang_end_safe = bang_end;
141 
142     if (frame_size_in_bytes &gt; page_size) {
143       bang_end += frame_size_in_bytes;
144     }
145 
146     int bang_offset = bang_end_safe;
147     while (bang_offset &lt;= bang_end) {
148       // Need at least one stack bang at end of shadow zone.
149       bang_stack_with_offset(bang_offset);
150       bang_offset += page_size;
151     }
152   } // end (UseStackBanging)
153 }
154 
155 void Label::add_patch_at(CodeBuffer* cb, int branch_loc, const char* file, int line) {
156   assert(_loc == -1, &quot;Label is unbound&quot;);
157   // Don&#39;t add patch locations during scratch emit.
158   if (cb-&gt;insts()-&gt;scratch_emit()) { return; }
159   if (_patch_index &lt; PatchCacheSize) {
160     _patches[_patch_index] = branch_loc;
161 #ifdef ASSERT
162     _lines[_patch_index] = line;
163     _files[_patch_index] = file;
164 #endif
165   } else {
166     if (_patch_overflow == NULL) {
167       _patch_overflow = cb-&gt;create_patch_overflow();
168     }
169     _patch_overflow-&gt;push(branch_loc);
170   }
171   ++_patch_index;
172 }
173 
174 void Label::patch_instructions(MacroAssembler* masm) {
175   assert(is_bound(), &quot;Label is bound&quot;);
176   CodeBuffer* cb = masm-&gt;code();
177   int target_sect = CodeBuffer::locator_sect(loc());
178   address target = cb-&gt;locator_address(loc());
179   while (_patch_index &gt; 0) {
180     --_patch_index;
181     int branch_loc;
182     int line = 0;
183     const char* file = NULL;
184     if (_patch_index &gt;= PatchCacheSize) {
185       branch_loc = _patch_overflow-&gt;pop();
186     } else {
187       branch_loc = _patches[_patch_index];
188 #ifdef ASSERT
189       line = _lines[_patch_index];
190       file = _files[_patch_index];
191 #endif
192     }
193     int branch_sect = CodeBuffer::locator_sect(branch_loc);
194     address branch = cb-&gt;locator_address(branch_loc);
195     if (branch_sect == CodeBuffer::SECT_CONSTS) {
196       // The thing to patch is a constant word.
197       *(address*)branch = target;
198       continue;
199     }
200 
201 #ifdef ASSERT
202     // Cross-section branches only work if the
203     // intermediate section boundaries are frozen.
204     if (target_sect != branch_sect) {
205       for (int n = MIN2(target_sect, branch_sect),
206                nlimit = (target_sect + branch_sect) - n;
207            n &lt; nlimit; n++) {
208         CodeSection* cs = cb-&gt;code_section(n);
209         assert(cs-&gt;is_frozen(), &quot;cross-section branch needs stable offsets&quot;);
210       }
211     }
212 #endif //ASSERT
213 
214     // Push the target offset into the branch instruction.
215     masm-&gt;pd_patch_instruction(branch, target, file, line);
216   }
217 }
218 
<a name="2" id="anc2"></a><span class="line-removed">219 struct DelayedConstant {</span>
<span class="line-removed">220   typedef void (*value_fn_t)();</span>
<span class="line-removed">221   BasicType type;</span>
<span class="line-removed">222   intptr_t value;</span>
<span class="line-removed">223   value_fn_t value_fn;</span>
<span class="line-removed">224   // This limit of 20 is generous for initial uses.</span>
<span class="line-removed">225   // The limit needs to be large enough to store the field offsets</span>
<span class="line-removed">226   // into classes which do not have statically fixed layouts.</span>
<span class="line-removed">227   // (Initial use is for method handle object offsets.)</span>
<span class="line-removed">228   // Look for uses of &quot;delayed_value&quot; in the source code</span>
<span class="line-removed">229   // and make sure this number is generous enough to handle all of them.</span>
<span class="line-removed">230   enum { DC_LIMIT = 20 };</span>
<span class="line-removed">231   static DelayedConstant delayed_constants[DC_LIMIT];</span>
<span class="line-removed">232   static DelayedConstant* add(BasicType type, value_fn_t value_fn);</span>
<span class="line-removed">233   bool match(BasicType t, value_fn_t cfn) {</span>
<span class="line-removed">234     return type == t &amp;&amp; value_fn == cfn;</span>
<span class="line-removed">235   }</span>
<span class="line-removed">236   static void update_all();</span>
<span class="line-removed">237 };</span>
<span class="line-removed">238 </span>
<span class="line-removed">239 DelayedConstant DelayedConstant::delayed_constants[DC_LIMIT];</span>
<span class="line-removed">240 // Default C structure initialization rules have the following effect here:</span>
<span class="line-removed">241 // = { { (BasicType)0, (intptr_t)NULL }, ... };</span>
<span class="line-removed">242 </span>
<span class="line-removed">243 DelayedConstant* DelayedConstant::add(BasicType type,</span>
<span class="line-removed">244                                       DelayedConstant::value_fn_t cfn) {</span>
<span class="line-removed">245   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">246     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">247     if (dcon-&gt;match(type, cfn))</span>
<span class="line-removed">248       return dcon;</span>
<span class="line-removed">249     if (dcon-&gt;value_fn == NULL) {</span>
<span class="line-removed">250         dcon-&gt;value_fn = cfn;</span>
<span class="line-removed">251         dcon-&gt;type = type;</span>
<span class="line-removed">252         return dcon;</span>
<span class="line-removed">253     }</span>
<span class="line-removed">254   }</span>
<span class="line-removed">255   // If this assert is hit (in pre-integration testing!) then re-evaluate</span>
<span class="line-removed">256   // the comment on the definition of DC_LIMIT.</span>
<span class="line-removed">257   guarantee(false, &quot;too many delayed constants&quot;);</span>
<span class="line-removed">258   return NULL;</span>
<span class="line-removed">259 }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261 void DelayedConstant::update_all() {</span>
<span class="line-removed">262   for (int i = 0; i &lt; DC_LIMIT; i++) {</span>
<span class="line-removed">263     DelayedConstant* dcon = &amp;delayed_constants[i];</span>
<span class="line-removed">264     if (dcon-&gt;value_fn != NULL &amp;&amp; dcon-&gt;value == 0) {</span>
<span class="line-removed">265       typedef int     (*int_fn_t)();</span>
<span class="line-removed">266       typedef address (*address_fn_t)();</span>
<span class="line-removed">267       switch (dcon-&gt;type) {</span>
<span class="line-removed">268       case T_INT:     dcon-&gt;value = (intptr_t) ((int_fn_t)    dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">269       case T_ADDRESS: dcon-&gt;value = (intptr_t) ((address_fn_t)dcon-&gt;value_fn)(); break;</span>
<span class="line-removed">270       default:        break;</span>
<span class="line-removed">271       }</span>
<span class="line-removed">272     }</span>
<span class="line-removed">273   }</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 RegisterOrConstant AbstractAssembler::delayed_value(int(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">277   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">278   if (val != 0)  return val + offset;</span>
<span class="line-removed">279   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">280 }</span>
<span class="line-removed">281 RegisterOrConstant AbstractAssembler::delayed_value(address(*value_fn)(), Register tmp, int offset) {</span>
<span class="line-removed">282   intptr_t val = (intptr_t) (*value_fn)();</span>
<span class="line-removed">283   if (val != 0)  return val + offset;</span>
<span class="line-removed">284   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);</span>
<span class="line-removed">285 }</span>
<span class="line-removed">286 intptr_t* AbstractAssembler::delayed_value_addr(int(*value_fn)()) {</span>
<span class="line-removed">287   DelayedConstant* dcon = DelayedConstant::add(T_INT, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">288   return &amp;dcon-&gt;value;</span>
<span class="line-removed">289 }</span>
<span class="line-removed">290 intptr_t* AbstractAssembler::delayed_value_addr(address(*value_fn)()) {</span>
<span class="line-removed">291   DelayedConstant* dcon = DelayedConstant::add(T_ADDRESS, (DelayedConstant::value_fn_t) value_fn);</span>
<span class="line-removed">292   return &amp;dcon-&gt;value;</span>
<span class="line-removed">293 }</span>
<span class="line-removed">294 void AbstractAssembler::update_delayed_values() {</span>
<span class="line-removed">295   DelayedConstant::update_all();</span>
<span class="line-removed">296 }</span>
<span class="line-removed">297 </span>
298 void AbstractAssembler::block_comment(const char* comment) {
299   if (sect() == CodeBuffer::SECT_INSTS) {
300     code_section()-&gt;outer()-&gt;block_comment(offset(), comment);
301   }
302 }
303 
304 const char* AbstractAssembler::code_string(const char* str) {
305   if (sect() == CodeBuffer::SECT_INSTS || sect() == CodeBuffer::SECT_STUBS) {
306     return code_section()-&gt;outer()-&gt;code_string(str);
307   }
308   return NULL;
309 }
310 
311 bool MacroAssembler::uses_implicit_null_check(void* address) {
312   // Exception handler checks the nmethod&#39;s implicit null checks table
313   // only when this method returns false.
<a name="3" id="anc3"></a><span class="line-modified">314   intptr_t int_address = reinterpret_cast&lt;intptr_t&gt;(address);</span>
<span class="line-modified">315   intptr_t cell_header_size = Universe::heap()-&gt;cell_header_size();</span>
<span class="line-removed">316   size_t region_size = os::vm_page_size() + cell_header_size;</span>
317 #ifdef _LP64
<a name="4" id="anc4"></a><span class="line-modified">318   if (UseCompressedOops &amp;&amp; Universe::narrow_oop_base() != NULL) {</span>
319     // A SEGV can legitimately happen in C2 code at address
320     // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
321     // is configured to allow narrow oops field loads to be implicitly
322     // null checked
<a name="5" id="anc5"></a><span class="line-modified">323     intptr_t start = ((intptr_t)Universe::narrow_oop_base()) - cell_header_size;</span>
<span class="line-modified">324     intptr_t end = start + region_size;</span>
<span class="line-modified">325     if (int_address &gt;= start &amp;&amp; int_address &lt; end) {</span>
326       return true;
327     }
328   }
329 #endif
<a name="6" id="anc6"></a><span class="line-modified">330   intptr_t start = -cell_header_size;</span>
<span class="line-removed">331   intptr_t end = start + region_size;</span>
<span class="line-removed">332   return int_address &gt;= start &amp;&amp; int_address &lt; end;</span>
333 }
334 
335 bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
336   // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
337   // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
338   // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
339   // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
340   // for offsets to be patched in later. The -1 there means the offset is not yet known
341   // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
<a name="7" id="anc7"></a><span class="line-modified">342   // an explicit null check for -1, even if it may otherwise be in the range</span>
<span class="line-removed">343   // [-cell_header_size, os::vm_page_size).</span>
<span class="line-removed">344   // TODO: Find and replace all relevant uses of -1 with a reasonably named constant.</span>
<span class="line-removed">345   if (offset == -1) return true;</span>
346 
<a name="8" id="anc8"></a><span class="line-modified">347   // Check if offset is outside of [-cell_header_size, os::vm_page_size)</span>
<span class="line-modified">348   return offset &lt; -Universe::heap()-&gt;cell_header_size() ||</span>
<span class="line-removed">349          offset &gt;= os::vm_page_size();</span>
350 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
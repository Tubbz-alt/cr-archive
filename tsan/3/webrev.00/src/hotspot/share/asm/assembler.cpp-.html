<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/asm/assembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/icache.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 
 36 // Implementation of AbstractAssembler
 37 //
 38 // The AbstractAssembler is generating code into a CodeBuffer. To make code generation faster,
 39 // the assembler keeps a copy of the code buffers boundaries &amp; modifies them when
 40 // emitting bytes rather than using the code buffers accessor functions all the time.
 41 // The code buffer is updated via set_code_end(...) after emitting a whole instruction.
 42 
 43 AbstractAssembler::AbstractAssembler(CodeBuffer* code) {
 44   if (code == NULL)  return;
 45   CodeSection* cs = code-&gt;insts();
 46   cs-&gt;clear_mark();   // new assembler kills old mark
 47   if (cs-&gt;start() == NULL)  {
 48     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;CodeCache: no room for %s&quot;, code-&gt;name());
 49   }
 50   _code_section = cs;
 51   _oop_recorder= code-&gt;oop_recorder();
 52   DEBUG_ONLY( _short_branch_delta = 0; )
 53 }
 54 
 55 void AbstractAssembler::set_code_section(CodeSection* cs) {
 56   assert(cs-&gt;outer() == code_section()-&gt;outer(), &quot;sanity&quot;);
 57   assert(cs-&gt;is_allocated(), &quot;need to pre-allocate this section&quot;);
 58   cs-&gt;clear_mark();  // new assembly into this section kills old mark
 59   _code_section = cs;
 60 }
 61 
 62 // Inform CodeBuffer that incoming code and relocation will be for stubs
 63 address AbstractAssembler::start_a_stub(int required_space) {
 64   CodeBuffer*  cb = code();
 65   CodeSection* cs = cb-&gt;stubs();
 66   assert(_code_section == cb-&gt;insts(), &quot;not in insts?&quot;);
 67   if (cs-&gt;maybe_expand_to_ensure_remaining(required_space)
 68       &amp;&amp; cb-&gt;blob() == NULL) {
 69     return NULL;
 70   }
 71   set_code_section(cs);
 72   return pc();
 73 }
 74 
 75 // Inform CodeBuffer that incoming code and relocation will be code
 76 // Should not be called if start_a_stub() returned NULL
 77 void AbstractAssembler::end_a_stub() {
 78   assert(_code_section == code()-&gt;stubs(), &quot;not in stubs?&quot;);
 79   set_code_section(code()-&gt;insts());
 80 }
 81 
 82 // Inform CodeBuffer that incoming code and relocation will be for stubs
 83 address AbstractAssembler::start_a_const(int required_space, int required_align) {
 84   CodeBuffer*  cb = code();
 85   CodeSection* cs = cb-&gt;consts();
 86   assert(_code_section == cb-&gt;insts() || _code_section == cb-&gt;stubs(), &quot;not in insts/stubs?&quot;);
 87   address end = cs-&gt;end();
 88   int pad = -(intptr_t)end &amp; (required_align-1);
 89   if (cs-&gt;maybe_expand_to_ensure_remaining(pad + required_space)) {
 90     if (cb-&gt;blob() == NULL)  return NULL;
 91     end = cs-&gt;end();  // refresh pointer
 92   }
 93   if (pad &gt; 0) {
 94     while (--pad &gt;= 0) { *end++ = 0; }
 95     cs-&gt;set_end(end);
 96   }
 97   set_code_section(cs);
 98   return end;
 99 }
100 
101 // Inform CodeBuffer that incoming code and relocation will be code
102 // in section cs (insts or stubs).
103 void AbstractAssembler::end_a_const(CodeSection* cs) {
104   assert(_code_section == code()-&gt;consts(), &quot;not in consts?&quot;);
105   set_code_section(cs);
106 }
107 
108 void AbstractAssembler::flush() {
109   ICache::invalidate_range(addr_at(0), offset());
110 }
111 
112 void AbstractAssembler::bind(Label&amp; L) {
113   if (L.is_bound()) {
114     // Assembler can bind a label more than once to the same place.
115     guarantee(L.loc() == locator(), &quot;attempt to redefine label&quot;);
116     return;
117   }
118   L.bind_loc(locator());
119   L.patch_instructions((MacroAssembler*)this);
120 }
121 
122 void AbstractAssembler::generate_stack_overflow_check(int frame_size_in_bytes) {
123   if (UseStackBanging) {
124     // Each code entry causes one stack bang n pages down the stack where n
125     // is configurable by StackShadowPages.  The setting depends on the maximum
126     // depth of VM call stack or native before going back into java code,
127     // since only java code can raise a stack overflow exception using the
128     // stack banging mechanism.  The VM and native code does not detect stack
129     // overflow.
130     // The code in JavaCalls::call() checks that there is at least n pages
131     // available, so all entry code needs to do is bang once for the end of
132     // this shadow zone.
133     // The entry code may need to bang additional pages if the framesize
134     // is greater than a page.
135 
136     const int page_size = os::vm_page_size();
137     int bang_end = (int)JavaThread::stack_shadow_zone_size();
138 
139     // This is how far the previous frame&#39;s stack banging extended.
140     const int bang_end_safe = bang_end;
141 
142     if (frame_size_in_bytes &gt; page_size) {
143       bang_end += frame_size_in_bytes;
144     }
145 
146     int bang_offset = bang_end_safe;
147     while (bang_offset &lt;= bang_end) {
148       // Need at least one stack bang at end of shadow zone.
149       bang_stack_with_offset(bang_offset);
150       bang_offset += page_size;
151     }
152   } // end (UseStackBanging)
153 }
154 
155 void Label::add_patch_at(CodeBuffer* cb, int branch_loc, const char* file, int line) {
156   assert(_loc == -1, &quot;Label is unbound&quot;);
157   // Don&#39;t add patch locations during scratch emit.
158   if (cb-&gt;insts()-&gt;scratch_emit()) { return; }
159   if (_patch_index &lt; PatchCacheSize) {
160     _patches[_patch_index] = branch_loc;
161 #ifdef ASSERT
162     _lines[_patch_index] = line;
163     _files[_patch_index] = file;
164 #endif
165   } else {
166     if (_patch_overflow == NULL) {
167       _patch_overflow = cb-&gt;create_patch_overflow();
168     }
169     _patch_overflow-&gt;push(branch_loc);
170   }
171   ++_patch_index;
172 }
173 
174 void Label::patch_instructions(MacroAssembler* masm) {
175   assert(is_bound(), &quot;Label is bound&quot;);
176   CodeBuffer* cb = masm-&gt;code();
177   int target_sect = CodeBuffer::locator_sect(loc());
178   address target = cb-&gt;locator_address(loc());
179   while (_patch_index &gt; 0) {
180     --_patch_index;
181     int branch_loc;
182     int line = 0;
183     const char* file = NULL;
184     if (_patch_index &gt;= PatchCacheSize) {
185       branch_loc = _patch_overflow-&gt;pop();
186     } else {
187       branch_loc = _patches[_patch_index];
188 #ifdef ASSERT
189       line = _lines[_patch_index];
190       file = _files[_patch_index];
191 #endif
192     }
193     int branch_sect = CodeBuffer::locator_sect(branch_loc);
194     address branch = cb-&gt;locator_address(branch_loc);
195     if (branch_sect == CodeBuffer::SECT_CONSTS) {
196       // The thing to patch is a constant word.
197       *(address*)branch = target;
198       continue;
199     }
200 
201 #ifdef ASSERT
202     // Cross-section branches only work if the
203     // intermediate section boundaries are frozen.
204     if (target_sect != branch_sect) {
205       for (int n = MIN2(target_sect, branch_sect),
206                nlimit = (target_sect + branch_sect) - n;
207            n &lt; nlimit; n++) {
208         CodeSection* cs = cb-&gt;code_section(n);
209         assert(cs-&gt;is_frozen(), &quot;cross-section branch needs stable offsets&quot;);
210       }
211     }
212 #endif //ASSERT
213 
214     // Push the target offset into the branch instruction.
215     masm-&gt;pd_patch_instruction(branch, target, file, line);
216   }
217 }
218 
219 struct DelayedConstant {
220   typedef void (*value_fn_t)();
221   BasicType type;
222   intptr_t value;
223   value_fn_t value_fn;
224   // This limit of 20 is generous for initial uses.
225   // The limit needs to be large enough to store the field offsets
226   // into classes which do not have statically fixed layouts.
227   // (Initial use is for method handle object offsets.)
228   // Look for uses of &quot;delayed_value&quot; in the source code
229   // and make sure this number is generous enough to handle all of them.
230   enum { DC_LIMIT = 20 };
231   static DelayedConstant delayed_constants[DC_LIMIT];
232   static DelayedConstant* add(BasicType type, value_fn_t value_fn);
233   bool match(BasicType t, value_fn_t cfn) {
234     return type == t &amp;&amp; value_fn == cfn;
235   }
236   static void update_all();
237 };
238 
239 DelayedConstant DelayedConstant::delayed_constants[DC_LIMIT];
240 // Default C structure initialization rules have the following effect here:
241 // = { { (BasicType)0, (intptr_t)NULL }, ... };
242 
243 DelayedConstant* DelayedConstant::add(BasicType type,
244                                       DelayedConstant::value_fn_t cfn) {
245   for (int i = 0; i &lt; DC_LIMIT; i++) {
246     DelayedConstant* dcon = &amp;delayed_constants[i];
247     if (dcon-&gt;match(type, cfn))
248       return dcon;
249     if (dcon-&gt;value_fn == NULL) {
250         dcon-&gt;value_fn = cfn;
251         dcon-&gt;type = type;
252         return dcon;
253     }
254   }
255   // If this assert is hit (in pre-integration testing!) then re-evaluate
256   // the comment on the definition of DC_LIMIT.
257   guarantee(false, &quot;too many delayed constants&quot;);
258   return NULL;
259 }
260 
261 void DelayedConstant::update_all() {
262   for (int i = 0; i &lt; DC_LIMIT; i++) {
263     DelayedConstant* dcon = &amp;delayed_constants[i];
264     if (dcon-&gt;value_fn != NULL &amp;&amp; dcon-&gt;value == 0) {
265       typedef int     (*int_fn_t)();
266       typedef address (*address_fn_t)();
267       switch (dcon-&gt;type) {
268       case T_INT:     dcon-&gt;value = (intptr_t) ((int_fn_t)    dcon-&gt;value_fn)(); break;
269       case T_ADDRESS: dcon-&gt;value = (intptr_t) ((address_fn_t)dcon-&gt;value_fn)(); break;
270       default:        break;
271       }
272     }
273   }
274 }
275 
276 RegisterOrConstant AbstractAssembler::delayed_value(int(*value_fn)(), Register tmp, int offset) {
277   intptr_t val = (intptr_t) (*value_fn)();
278   if (val != 0)  return val + offset;
279   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);
280 }
281 RegisterOrConstant AbstractAssembler::delayed_value(address(*value_fn)(), Register tmp, int offset) {
282   intptr_t val = (intptr_t) (*value_fn)();
283   if (val != 0)  return val + offset;
284   return delayed_value_impl(delayed_value_addr(value_fn), tmp, offset);
285 }
286 intptr_t* AbstractAssembler::delayed_value_addr(int(*value_fn)()) {
287   DelayedConstant* dcon = DelayedConstant::add(T_INT, (DelayedConstant::value_fn_t) value_fn);
288   return &amp;dcon-&gt;value;
289 }
290 intptr_t* AbstractAssembler::delayed_value_addr(address(*value_fn)()) {
291   DelayedConstant* dcon = DelayedConstant::add(T_ADDRESS, (DelayedConstant::value_fn_t) value_fn);
292   return &amp;dcon-&gt;value;
293 }
294 void AbstractAssembler::update_delayed_values() {
295   DelayedConstant::update_all();
296 }
297 
298 void AbstractAssembler::block_comment(const char* comment) {
299   if (sect() == CodeBuffer::SECT_INSTS) {
300     code_section()-&gt;outer()-&gt;block_comment(offset(), comment);
301   }
302 }
303 
304 const char* AbstractAssembler::code_string(const char* str) {
305   if (sect() == CodeBuffer::SECT_INSTS || sect() == CodeBuffer::SECT_STUBS) {
306     return code_section()-&gt;outer()-&gt;code_string(str);
307   }
308   return NULL;
309 }
310 
311 bool MacroAssembler::uses_implicit_null_check(void* address) {
312   // Exception handler checks the nmethod&#39;s implicit null checks table
313   // only when this method returns false.
314   intptr_t int_address = reinterpret_cast&lt;intptr_t&gt;(address);
315   intptr_t cell_header_size = Universe::heap()-&gt;cell_header_size();
316   size_t region_size = os::vm_page_size() + cell_header_size;
317 #ifdef _LP64
318   if (UseCompressedOops &amp;&amp; Universe::narrow_oop_base() != NULL) {
319     // A SEGV can legitimately happen in C2 code at address
320     // (heap_base + offset) if  Matcher::narrow_oop_use_complex_address
321     // is configured to allow narrow oops field loads to be implicitly
322     // null checked
323     intptr_t start = ((intptr_t)Universe::narrow_oop_base()) - cell_header_size;
324     intptr_t end = start + region_size;
325     if (int_address &gt;= start &amp;&amp; int_address &lt; end) {
326       return true;
327     }
328   }
329 #endif
330   intptr_t start = -cell_header_size;
331   intptr_t end = start + region_size;
332   return int_address &gt;= start &amp;&amp; int_address &lt; end;
333 }
334 
335 bool MacroAssembler::needs_explicit_null_check(intptr_t offset) {
336   // The offset -1 is used (hardcoded) in a number of places in C1 and MacroAssembler
337   // to indicate an unknown offset. For example, TemplateTable::pop_and_check_object(Register r)
338   // calls MacroAssembler::null_check(Register reg, int offset = -1) which gets here
339   // with -1. Another example is GraphBuilder::access_field(...) which uses -1 as placeholder
340   // for offsets to be patched in later. The -1 there means the offset is not yet known
341   // and may lie outside of the zero-trapping page, and thus we need to ensure we&#39;re forcing
342   // an explicit null check for -1, even if it may otherwise be in the range
343   // [-cell_header_size, os::vm_page_size).
344   // TODO: Find and replace all relevant uses of -1 with a reasonably named constant.
345   if (offset == -1) return true;
346 
347   // Check if offset is outside of [-cell_header_size, os::vm_page_size)
348   return offset &lt; -Universe::heap()-&gt;cell_header_size() ||
349          offset &gt;= os::vm_page_size();
350 }
    </pre>
  </body>
</html>
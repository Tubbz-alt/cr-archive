<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/asm/codeBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/codeBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/codeBuffer.hpp&quot;

  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;oops/methodData.hpp&quot;
  29 #include &quot;oops/oop.inline.hpp&quot;
  30 #include &quot;runtime/icache.hpp&quot;
  31 #include &quot;runtime/safepointVerifiers.hpp&quot;
  32 #include &quot;utilities/align.hpp&quot;
  33 #include &quot;utilities/copy.hpp&quot;

  34 #include &quot;utilities/xmlstream.hpp&quot;
  35 
  36 // The structure of a CodeSection:
  37 //
  38 //    _start -&gt;           +----------------+
  39 //                        | machine code...|
  40 //    _end -&gt;             |----------------|
  41 //                        |                |
  42 //                        |    (empty)     |
  43 //                        |                |
  44 //                        |                |
  45 //                        +----------------+
  46 //    _limit -&gt;           |                |
  47 //
  48 //    _locs_start -&gt;      +----------------+
  49 //                        |reloc records...|
  50 //                        |----------------|
  51 //    _locs_end -&gt;        |                |
  52 //                        |                |
  53 //                        |    (empty)     |
</pre>
<hr />
<pre>
  68 //    _stubs._start -&gt;              |----------------|
  69 //                                  |                |
  70 //                                  |    Stubs       | (also handlers for deopt/exception)
  71 //                                  |                |
  72 //    _consts._start -&gt;             |----------------|
  73 //                                  |                |
  74 //                                  |   Constants    |
  75 //                                  |                |
  76 //                                  +----------------+
  77 //    + _total_size -&gt;              |                |
  78 //
  79 // When the code and relocations are copied to the code cache,
  80 // the empty parts of each section are removed, and everything
  81 // is copied into contiguous locations.
  82 
  83 typedef CodeBuffer::csize_t csize_t;  // file-local definition
  84 
  85 // External buffer, in a predefined CodeBlob.
  86 // Important: The code_start must be taken exactly, and not realigned.
  87 CodeBuffer::CodeBuffer(CodeBlob* blob) {
<span class="line-modified">  88   initialize_misc(&quot;static buffer&quot;);</span>

  89   initialize(blob-&gt;content_begin(), blob-&gt;content_size());
  90   verify_section_allocation();
  91 }
  92 
  93 void CodeBuffer::initialize(csize_t code_size, csize_t locs_size) {
  94   // Compute maximal alignment.
  95   int align = _insts.alignment();
  96   // Always allow for empty slop around each section.
  97   int slop = (int) CodeSection::end_slop();
  98 
  99   assert(blob() == NULL, &quot;only once&quot;);
 100   set_blob(BufferBlob::create(_name, code_size + (align+slop) * (SECT_LIMIT+1)));
 101   if (blob() == NULL) {
 102     // The assembler constructor will throw a fatal on an empty CodeBuffer.
 103     return;  // caller must test this
 104   }
 105 
 106   // Set up various pointers into the blob.
 107   initialize(_total_start, _total_size);
 108 
</pre>
<hr />
<pre>
1017     ttyLocker ttyl;
1018     // log info about buffer usage
1019     xtty-&gt;print_cr(&quot;&lt;blob name=&#39;%s&#39; size=&#39;%d&#39;&gt;&quot;, name, _total_size);
1020     for (int n = (int) CodeBuffer::SECT_FIRST; n &lt; (int) CodeBuffer::SECT_LIMIT; n++) {
1021       CodeSection* sect = code_section(n);
1022       if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
1023       xtty-&gt;print_cr(&quot;&lt;sect index=&#39;%d&#39; size=&#39;&quot; SIZE_FORMAT &quot;&#39; free=&#39;&quot; SIZE_FORMAT &quot;&#39;/&gt;&quot;,
1024                      n, sect-&gt;limit() - sect-&gt;start(), sect-&gt;limit() - sect-&gt;end());
1025     }
1026     xtty-&gt;print_cr(&quot;&lt;/blob&gt;&quot;);
1027   }
1028 }
1029 
1030 #ifndef PRODUCT
1031 
1032 void CodeSection::decode() {
1033   Disassembler::decode(start(), end());
1034 }
1035 
1036 void CodeBuffer::block_comment(intptr_t offset, const char * comment) {
<span class="line-modified">1037   _code_strings.add_comment(offset, comment);</span>


1038 }
1039 
1040 const char* CodeBuffer::code_string(const char* str) {
1041   return _code_strings.add_string(str);
1042 }
1043 
1044 class CodeString: public CHeapObj&lt;mtCode&gt; {
1045  private:
1046   friend class CodeStrings;
1047   const char * _string;
1048   CodeString*  _next;

1049   intptr_t     _offset;
1050 
1051   ~CodeString() {
<span class="line-modified">1052     assert(_next == NULL, &quot;wrong interface for freeing list&quot;);</span>
1053     os::free((void*)_string);
1054   }
1055 
1056   bool is_comment() const { return _offset &gt;= 0; }
1057 
1058  public:
1059   CodeString(const char * string, intptr_t offset = -1)
<span class="line-modified">1060     : _next(NULL), _offset(offset) {</span>
1061     _string = os::strdup(string, mtCode);
1062   }
1063 
1064   const char * string() const { return _string; }
1065   intptr_t     offset() const { assert(_offset &gt;= 0, &quot;offset for non comment?&quot;); return _offset;  }
1066   CodeString* next()    const { return _next; }
1067 
<span class="line-modified">1068   void set_next(CodeString* next) { _next = next; }</span>





1069 
1070   CodeString* first_comment() {
1071     if (is_comment()) {
1072       return this;
1073     } else {
1074       return next_comment();
1075     }
1076   }
1077   CodeString* next_comment() const {
1078     CodeString* s = _next;
1079     while (s != NULL &amp;&amp; !s-&gt;is_comment()) {
1080       s = s-&gt;_next;
1081     }
1082     return s;
1083   }
1084 };
1085 
1086 CodeString* CodeStrings::find(intptr_t offset) const {
1087   CodeString* a = _strings-&gt;first_comment();
1088   while (a != NULL &amp;&amp; a-&gt;offset() != offset) {
1089     a = a-&gt;next_comment();
1090   }
1091   return a;
1092 }
1093 
1094 // Convenience for add_comment.
1095 CodeString* CodeStrings::find_last(intptr_t offset) const {
<span class="line-modified">1096   CodeString* a = find(offset);</span>
<span class="line-modified">1097   if (a != NULL) {</span>
<span class="line-modified">1098     CodeString* c = NULL;</span>
<span class="line-removed">1099     while (((c = a-&gt;next_comment()) != NULL) &amp;&amp; (c-&gt;offset() == offset)) {</span>
<span class="line-removed">1100       a = c;</span>
<span class="line-removed">1101     }</span>
1102   }
1103   return a;
1104 }
1105 
1106 void CodeStrings::add_comment(intptr_t offset, const char * comment) {
1107   check_valid();
1108   CodeString* c      = new CodeString(comment, offset);
1109   CodeString* inspos = (_strings == NULL) ? NULL : find_last(offset);
1110 
1111   if (inspos) {
1112     // insert after already existing comments with same offset
1113     c-&gt;set_next(inspos-&gt;next());
1114     inspos-&gt;set_next(c);
1115   } else {
1116     // no comments with such offset, yet. Insert before anything else.
1117     c-&gt;set_next(_strings);
1118     _strings = c;
1119   }



1120 }
1121 
1122 void CodeStrings::assign(CodeStrings&amp; other) {
1123   other.check_valid();
1124   assert(is_null(), &quot;Cannot assign onto non-empty CodeStrings&quot;);
1125   _strings = other._strings;

1126 #ifdef ASSERT
1127   _defunct = false;
1128 #endif
1129   other.set_null_and_invalidate();
1130 }
1131 
1132 // Deep copy of CodeStrings for consistent memory management.
1133 // Only used for actual disassembly so this is cheaper than reference counting
1134 // for the &quot;normal&quot; fastdebug case.
1135 void CodeStrings::copy(CodeStrings&amp; other) {
1136   other.check_valid();
1137   check_valid();
1138   assert(is_null(), &quot;Cannot copy onto non-empty CodeStrings&quot;);
1139   CodeString* n = other._strings;
1140   CodeString** ps = &amp;_strings;

1141   while (n != NULL) {
1142     *ps = new CodeString(n-&gt;string(),n-&gt;offset());


1143     ps = &amp;((*ps)-&gt;_next);
1144     n = n-&gt;next();
1145   }
1146 }
1147 
1148 const char* CodeStrings::_prefix = &quot; ;; &quot;;  // default: can be changed via set_prefix
1149 







1150 void CodeStrings::print_block_comment(outputStream* stream, intptr_t offset) const {
<span class="line-modified">1151     check_valid();</span>
<span class="line-modified">1152     if (_strings != NULL) {</span>
1153     CodeString* c = find(offset);
1154     while (c &amp;&amp; c-&gt;offset() == offset) {
1155       stream-&gt;bol();
1156       stream-&gt;print(&quot;%s&quot;, _prefix);
1157       // Don&#39;t interpret as format strings since it could contain %
<span class="line-modified">1158       stream-&gt;print_raw_cr(c-&gt;string());</span>

1159       c = c-&gt;next_comment();
1160     }
1161   }
1162 }
1163 
1164 // Also sets isNull()
1165 void CodeStrings::free() {
1166   CodeString* n = _strings;
1167   while (n) {
1168     // unlink the node from the list saving a pointer to the next
1169     CodeString* p = n-&gt;next();
1170     n-&gt;set_next(NULL);




1171     delete n;
1172     n = p;
1173   }
1174   set_null_and_invalidate();
1175 }
1176 
1177 const char* CodeStrings::add_string(const char * string) {
1178   check_valid();
1179   CodeString* s = new CodeString(string);
1180   s-&gt;set_next(_strings);



1181   _strings = s;
1182   assert(s-&gt;string() != NULL, &quot;should have a string&quot;);
1183   return s-&gt;string();
1184 }
1185 
1186 void CodeBuffer::decode() {
1187   ttyLocker ttyl;
<span class="line-modified">1188   Disassembler::decode(decode_begin(), insts_end());</span>
1189   _decode_begin = insts_end();
1190 }
1191 
1192 void CodeSection::print(const char* name) {
1193   csize_t locs_size = locs_end() - locs_start();
1194   tty-&gt;print_cr(&quot; %7s.code = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d)%s&quot;,
1195                 name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity(),
1196                 is_frozen()? &quot; [frozen]&quot;: &quot;&quot;);
1197   tty-&gt;print_cr(&quot; %7s.locs = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d) point=%d&quot;,
1198                 name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());
1199   if (PrintRelocations) {
1200     RelocIterator iter(this);
1201     iter.print();
1202   }
1203 }
1204 
1205 void CodeBuffer::print() {
1206   if (this == NULL) {
1207     tty-&gt;print_cr(&quot;NULL CodeBuffer pointer&quot;);
1208     return;
1209   }
1210 
1211   tty-&gt;print_cr(&quot;CodeBuffer:&quot;);
1212   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
1213     // print each section
1214     CodeSection* cs = code_section(n);
1215     cs-&gt;print(code_section_name(n));
1216   }
1217 }
1218 






1219 #endif // PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/codeBuffer.hpp&quot;
<span class="line-added">  27 #include &quot;code/oopRecorder.inline.hpp&quot;</span>
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;oops/methodData.hpp&quot;
  30 #include &quot;oops/oop.inline.hpp&quot;
  31 #include &quot;runtime/icache.hpp&quot;
  32 #include &quot;runtime/safepointVerifiers.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/copy.hpp&quot;
<span class="line-added">  35 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  36 #include &quot;utilities/xmlstream.hpp&quot;
  37 
  38 // The structure of a CodeSection:
  39 //
  40 //    _start -&gt;           +----------------+
  41 //                        | machine code...|
  42 //    _end -&gt;             |----------------|
  43 //                        |                |
  44 //                        |    (empty)     |
  45 //                        |                |
  46 //                        |                |
  47 //                        +----------------+
  48 //    _limit -&gt;           |                |
  49 //
  50 //    _locs_start -&gt;      +----------------+
  51 //                        |reloc records...|
  52 //                        |----------------|
  53 //    _locs_end -&gt;        |                |
  54 //                        |                |
  55 //                        |    (empty)     |
</pre>
<hr />
<pre>
  70 //    _stubs._start -&gt;              |----------------|
  71 //                                  |                |
  72 //                                  |    Stubs       | (also handlers for deopt/exception)
  73 //                                  |                |
  74 //    _consts._start -&gt;             |----------------|
  75 //                                  |                |
  76 //                                  |   Constants    |
  77 //                                  |                |
  78 //                                  +----------------+
  79 //    + _total_size -&gt;              |                |
  80 //
  81 // When the code and relocations are copied to the code cache,
  82 // the empty parts of each section are removed, and everything
  83 // is copied into contiguous locations.
  84 
  85 typedef CodeBuffer::csize_t csize_t;  // file-local definition
  86 
  87 // External buffer, in a predefined CodeBlob.
  88 // Important: The code_start must be taken exactly, and not realigned.
  89 CodeBuffer::CodeBuffer(CodeBlob* blob) {
<span class="line-modified">  90   // Provide code buffer with meaningful name</span>
<span class="line-added">  91   initialize_misc(blob-&gt;name());</span>
  92   initialize(blob-&gt;content_begin(), blob-&gt;content_size());
  93   verify_section_allocation();
  94 }
  95 
  96 void CodeBuffer::initialize(csize_t code_size, csize_t locs_size) {
  97   // Compute maximal alignment.
  98   int align = _insts.alignment();
  99   // Always allow for empty slop around each section.
 100   int slop = (int) CodeSection::end_slop();
 101 
 102   assert(blob() == NULL, &quot;only once&quot;);
 103   set_blob(BufferBlob::create(_name, code_size + (align+slop) * (SECT_LIMIT+1)));
 104   if (blob() == NULL) {
 105     // The assembler constructor will throw a fatal on an empty CodeBuffer.
 106     return;  // caller must test this
 107   }
 108 
 109   // Set up various pointers into the blob.
 110   initialize(_total_start, _total_size);
 111 
</pre>
<hr />
<pre>
1020     ttyLocker ttyl;
1021     // log info about buffer usage
1022     xtty-&gt;print_cr(&quot;&lt;blob name=&#39;%s&#39; size=&#39;%d&#39;&gt;&quot;, name, _total_size);
1023     for (int n = (int) CodeBuffer::SECT_FIRST; n &lt; (int) CodeBuffer::SECT_LIMIT; n++) {
1024       CodeSection* sect = code_section(n);
1025       if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
1026       xtty-&gt;print_cr(&quot;&lt;sect index=&#39;%d&#39; size=&#39;&quot; SIZE_FORMAT &quot;&#39; free=&#39;&quot; SIZE_FORMAT &quot;&#39;/&gt;&quot;,
1027                      n, sect-&gt;limit() - sect-&gt;start(), sect-&gt;limit() - sect-&gt;end());
1028     }
1029     xtty-&gt;print_cr(&quot;&lt;/blob&gt;&quot;);
1030   }
1031 }
1032 
1033 #ifndef PRODUCT
1034 
1035 void CodeSection::decode() {
1036   Disassembler::decode(start(), end());
1037 }
1038 
1039 void CodeBuffer::block_comment(intptr_t offset, const char * comment) {
<span class="line-modified">1040   if (_collect_comments) {</span>
<span class="line-added">1041     _code_strings.add_comment(offset, comment);</span>
<span class="line-added">1042   }</span>
1043 }
1044 
1045 const char* CodeBuffer::code_string(const char* str) {
1046   return _code_strings.add_string(str);
1047 }
1048 
1049 class CodeString: public CHeapObj&lt;mtCode&gt; {
1050  private:
1051   friend class CodeStrings;
1052   const char * _string;
1053   CodeString*  _next;
<span class="line-added">1054   CodeString*  _prev;</span>
1055   intptr_t     _offset;
1056 
1057   ~CodeString() {
<span class="line-modified">1058     assert(_next == NULL &amp;&amp; _prev == NULL, &quot;wrong interface for freeing list&quot;);</span>
1059     os::free((void*)_string);
1060   }
1061 
1062   bool is_comment() const { return _offset &gt;= 0; }
1063 
1064  public:
1065   CodeString(const char * string, intptr_t offset = -1)
<span class="line-modified">1066     : _next(NULL), _prev(NULL), _offset(offset) {</span>
1067     _string = os::strdup(string, mtCode);
1068   }
1069 
1070   const char * string() const { return _string; }
1071   intptr_t     offset() const { assert(_offset &gt;= 0, &quot;offset for non comment?&quot;); return _offset;  }
1072   CodeString* next()    const { return _next; }
1073 
<span class="line-modified">1074   void set_next(CodeString* next) {</span>
<span class="line-added">1075     _next = next;</span>
<span class="line-added">1076     if (next != NULL) {</span>
<span class="line-added">1077       next-&gt;_prev = this;</span>
<span class="line-added">1078     }</span>
<span class="line-added">1079   }</span>
1080 
1081   CodeString* first_comment() {
1082     if (is_comment()) {
1083       return this;
1084     } else {
1085       return next_comment();
1086     }
1087   }
1088   CodeString* next_comment() const {
1089     CodeString* s = _next;
1090     while (s != NULL &amp;&amp; !s-&gt;is_comment()) {
1091       s = s-&gt;_next;
1092     }
1093     return s;
1094   }
1095 };
1096 
1097 CodeString* CodeStrings::find(intptr_t offset) const {
1098   CodeString* a = _strings-&gt;first_comment();
1099   while (a != NULL &amp;&amp; a-&gt;offset() != offset) {
1100     a = a-&gt;next_comment();
1101   }
1102   return a;
1103 }
1104 
1105 // Convenience for add_comment.
1106 CodeString* CodeStrings::find_last(intptr_t offset) const {
<span class="line-modified">1107   CodeString* a = _strings_last;</span>
<span class="line-modified">1108   while (a != NULL &amp;&amp; !(a-&gt;is_comment() &amp;&amp; a-&gt;offset() == offset)) {</span>
<span class="line-modified">1109     a = a-&gt;_prev;</span>



1110   }
1111   return a;
1112 }
1113 
1114 void CodeStrings::add_comment(intptr_t offset, const char * comment) {
1115   check_valid();
1116   CodeString* c      = new CodeString(comment, offset);
1117   CodeString* inspos = (_strings == NULL) ? NULL : find_last(offset);
1118 
1119   if (inspos) {
1120     // insert after already existing comments with same offset
1121     c-&gt;set_next(inspos-&gt;next());
1122     inspos-&gt;set_next(c);
1123   } else {
1124     // no comments with such offset, yet. Insert before anything else.
1125     c-&gt;set_next(_strings);
1126     _strings = c;
1127   }
<span class="line-added">1128   if (c-&gt;next() == NULL) {</span>
<span class="line-added">1129     _strings_last = c;</span>
<span class="line-added">1130   }</span>
1131 }
1132 
1133 void CodeStrings::assign(CodeStrings&amp; other) {
1134   other.check_valid();
1135   assert(is_null(), &quot;Cannot assign onto non-empty CodeStrings&quot;);
1136   _strings = other._strings;
<span class="line-added">1137   _strings_last = other._strings_last;</span>
1138 #ifdef ASSERT
1139   _defunct = false;
1140 #endif
1141   other.set_null_and_invalidate();
1142 }
1143 
1144 // Deep copy of CodeStrings for consistent memory management.
1145 // Only used for actual disassembly so this is cheaper than reference counting
1146 // for the &quot;normal&quot; fastdebug case.
1147 void CodeStrings::copy(CodeStrings&amp; other) {
1148   other.check_valid();
1149   check_valid();
1150   assert(is_null(), &quot;Cannot copy onto non-empty CodeStrings&quot;);
1151   CodeString* n = other._strings;
1152   CodeString** ps = &amp;_strings;
<span class="line-added">1153   CodeString* prev = NULL;</span>
1154   while (n != NULL) {
1155     *ps = new CodeString(n-&gt;string(),n-&gt;offset());
<span class="line-added">1156     (*ps)-&gt;_prev = prev;</span>
<span class="line-added">1157     prev = *ps;</span>
1158     ps = &amp;((*ps)-&gt;_next);
1159     n = n-&gt;next();
1160   }
1161 }
1162 
1163 const char* CodeStrings::_prefix = &quot; ;; &quot;;  // default: can be changed via set_prefix
1164 
<span class="line-added">1165 // Check if any block comments are pending for the given offset.</span>
<span class="line-added">1166 bool CodeStrings::has_block_comment(intptr_t offset) const {</span>
<span class="line-added">1167   if (_strings == NULL) return false;</span>
<span class="line-added">1168   CodeString* c = find(offset);</span>
<span class="line-added">1169   return c != NULL;</span>
<span class="line-added">1170 }</span>
<span class="line-added">1171 </span>
1172 void CodeStrings::print_block_comment(outputStream* stream, intptr_t offset) const {
<span class="line-modified">1173   check_valid();</span>
<span class="line-modified">1174   if (_strings != NULL) {</span>
1175     CodeString* c = find(offset);
1176     while (c &amp;&amp; c-&gt;offset() == offset) {
1177       stream-&gt;bol();
1178       stream-&gt;print(&quot;%s&quot;, _prefix);
1179       // Don&#39;t interpret as format strings since it could contain %
<span class="line-modified">1180       stream-&gt;print_raw(c-&gt;string());</span>
<span class="line-added">1181       stream-&gt;bol(); // advance to next line only if string didn&#39;t contain a cr() at the end.</span>
1182       c = c-&gt;next_comment();
1183     }
1184   }
1185 }
1186 
1187 // Also sets isNull()
1188 void CodeStrings::free() {
1189   CodeString* n = _strings;
1190   while (n) {
1191     // unlink the node from the list saving a pointer to the next
1192     CodeString* p = n-&gt;next();
1193     n-&gt;set_next(NULL);
<span class="line-added">1194     if (p != NULL) {</span>
<span class="line-added">1195       assert(p-&gt;_prev == n, &quot;missing prev link&quot;);</span>
<span class="line-added">1196       p-&gt;_prev = NULL;</span>
<span class="line-added">1197     }</span>
1198     delete n;
1199     n = p;
1200   }
1201   set_null_and_invalidate();
1202 }
1203 
1204 const char* CodeStrings::add_string(const char * string) {
1205   check_valid();
1206   CodeString* s = new CodeString(string);
1207   s-&gt;set_next(_strings);
<span class="line-added">1208   if (_strings == NULL) {</span>
<span class="line-added">1209     _strings_last = s;</span>
<span class="line-added">1210   }</span>
1211   _strings = s;
1212   assert(s-&gt;string() != NULL, &quot;should have a string&quot;);
1213   return s-&gt;string();
1214 }
1215 
1216 void CodeBuffer::decode() {
1217   ttyLocker ttyl;
<span class="line-modified">1218   Disassembler::decode(decode_begin(), insts_end(), tty);</span>
1219   _decode_begin = insts_end();
1220 }
1221 
1222 void CodeSection::print(const char* name) {
1223   csize_t locs_size = locs_end() - locs_start();
1224   tty-&gt;print_cr(&quot; %7s.code = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d)%s&quot;,
1225                 name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity(),
1226                 is_frozen()? &quot; [frozen]&quot;: &quot;&quot;);
1227   tty-&gt;print_cr(&quot; %7s.locs = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d) point=%d&quot;,
1228                 name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());
1229   if (PrintRelocations) {
1230     RelocIterator iter(this);
1231     iter.print();
1232   }
1233 }
1234 
1235 void CodeBuffer::print() {
1236   if (this == NULL) {
1237     tty-&gt;print_cr(&quot;NULL CodeBuffer pointer&quot;);
1238     return;
1239   }
1240 
1241   tty-&gt;print_cr(&quot;CodeBuffer:&quot;);
1242   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
1243     // print each section
1244     CodeSection* cs = code_section(n);
1245     cs-&gt;print(code_section_name(n));
1246   }
1247 }
1248 
<span class="line-added">1249 // Directly disassemble code buffer.</span>
<span class="line-added">1250 void CodeBuffer::decode(address start, address end) {</span>
<span class="line-added">1251   ttyLocker ttyl;</span>
<span class="line-added">1252   Disassembler::decode(this, start, end, tty);</span>
<span class="line-added">1253 }</span>
<span class="line-added">1254 </span>
1255 #endif // PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="assembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/asm/codeBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_Canonicalizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/codeBuffer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
232 
233   // Mark a section frozen.  Assign its remaining space to
234   // the following section.  It will never expand after this point.
235   inline void freeze();         //  { _outer-&gt;freeze_section(this); }
236 
237   // Ensure there&#39;s enough space left in the current section.
238   // Return true if there was an expansion.
239   bool maybe_expand_to_ensure_remaining(csize_t amount);
240 
241 #ifndef PRODUCT
242   void decode();
243   void print(const char* name);
244 #endif //PRODUCT
245 };
246 
247 class CodeString;
248 class CodeStrings {
249 private:
250 #ifndef PRODUCT
251   CodeString* _strings;

252 #ifdef ASSERT
253   // Becomes true after copy-out, forbids further use.
254   bool _defunct; // Zero bit pattern is &quot;valid&quot;, see memset call in decode_env::decode_env
255 #endif
256   static const char* _prefix; // defaults to &quot; ;; &quot;
257 #endif
258 
259   CodeString* find(intptr_t offset) const;
260   CodeString* find_last(intptr_t offset) const;
261 
262   void set_null_and_invalidate() {
263 #ifndef PRODUCT
264     _strings = NULL;

265 #ifdef ASSERT
266     _defunct = true;
267 #endif
268 #endif
269   }
270 
271 public:
272   CodeStrings() {
273 #ifndef PRODUCT
274     _strings = NULL;

275 #ifdef ASSERT
276     _defunct = false;
277 #endif
278 #endif
279   }
280 
281   bool is_null() {
282 #ifdef ASSERT
283     return _strings == NULL;
284 #else
285     return true;
286 #endif
287   }
288 
289   const char* add_string(const char * string) PRODUCT_RETURN_(return NULL;);
290 
291   void add_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;

292   void print_block_comment(outputStream* stream, intptr_t offset) const PRODUCT_RETURN;
293   // MOVE strings from other to this; invalidate other.
294   void assign(CodeStrings&amp; other)  PRODUCT_RETURN;
295   // COPY strings from other to this; leave other valid.
296   void copy(CodeStrings&amp; other)  PRODUCT_RETURN;
297   // FREE strings; invalidate this.
298   void free() PRODUCT_RETURN;

299   // Guarantee that _strings are used at most once; assign and free invalidate a buffer.
300   inline void check_valid() const {
301 #ifdef ASSERT
302     assert(!_defunct, &quot;Use of invalid CodeStrings&quot;);
303 #endif
304   }
305 
306   static void set_prefix(const char *prefix) {
307 #ifndef PRODUCT
308     _prefix = prefix;
309 #endif
310   }
311 };
312 
313 // A CodeBuffer describes a memory space into which assembly
314 // code is generated.  This memory space usually occupies the
315 // interior of a single BufferBlob, but in some cases it may be
316 // an arbitrary span of memory, even outside the code cache.
317 //
318 // A code buffer comes in two variants:
</pre>
<hr />
<pre>
360  private:
361   enum {
362     sect_bits = 2,      // assert (SECT_LIMIT &lt;= (1&lt;&lt;sect_bits))
363     sect_mask = (1&lt;&lt;sect_bits)-1
364   };
365 
366   const char*  _name;
367 
368   CodeSection  _consts;             // constants, jump tables
369   CodeSection  _insts;              // instructions (the main section)
370   CodeSection  _stubs;              // stubs (call site support), deopt, exception handling
371 
372   CodeBuffer*  _before_expand;  // dead buffer, from before the last expansion
373 
374   BufferBlob*  _blob;           // optional buffer in CodeCache for generated code
375   address      _total_start;    // first address of combined memory buffer
376   csize_t      _total_size;     // size in bytes of combined memory buffer
377 
378   OopRecorder* _oop_recorder;
379   CodeStrings  _code_strings;

380   OopRecorder  _default_oop_recorder;  // override with initialize_oop_recorder
381   Arena*       _overflow_arena;
382 
383   address      _last_insn;      // used to merge consecutive memory barriers, loads or stores.
384 
385 #if INCLUDE_AOT
386   bool         _immutable_PIC;
387 #endif
388 
389   address      _decode_begin;   // start address for decode
390   address      decode_begin();
391 
392   void initialize_misc(const char * name) {
393     // all pointers other than code_start/end and those inside the sections
394     assert(name != NULL, &quot;must have a name&quot;);
395     _name            = name;
396     _before_expand   = NULL;
397     _blob            = NULL;
398     _oop_recorder    = NULL;
399     _decode_begin    = NULL;
400     _overflow_arena  = NULL;
401     _code_strings    = CodeStrings();
402     _last_insn       = NULL;
403 #if INCLUDE_AOT
404     _immutable_PIC   = false;
405 #endif









406   }
407 
408   void initialize(address code_start, csize_t code_size) {
409     _consts.initialize_outer(this,  SECT_CONSTS);
410     _insts.initialize_outer(this,   SECT_INSTS);
411     _stubs.initialize_outer(this,   SECT_STUBS);
412     _total_start = code_start;
413     _total_size  = code_size;
414     // Initialize the main section:
415     _insts.initialize(code_start, code_size);
416     assert(!_stubs.is_allocated(),  &quot;no garbage here&quot;);
417     assert(!_consts.is_allocated(), &quot;no garbage here&quot;);
418     _oop_recorder = &amp;_default_oop_recorder;
419   }
420 
421   void initialize_section_size(CodeSection* cs, csize_t size);
422 
423   void freeze_section(CodeSection* cs);
424 
425   // helper for CodeBuffer::expand()
</pre>
<hr />
<pre>
587   // The section sizes are subtracted from the original insts section.
588   // Note:  Call them in reverse section order, because each steals from insts.
589   void initialize_consts_size(csize_t size)            { initialize_section_size(&amp;_consts,  size); }
590   void initialize_stubs_size(csize_t size)             { initialize_section_size(&amp;_stubs,   size); }
591   // Override default oop recorder.
592   void initialize_oop_recorder(OopRecorder* r);
593 
594   OopRecorder* oop_recorder() const   { return _oop_recorder; }
595   CodeStrings&amp; strings()              { return _code_strings; }
596 
597   address last_insn() const { return _last_insn; }
598   void set_last_insn(address a) { _last_insn = a; }
599   void clear_last_insn() { set_last_insn(NULL); }
600 
601   void free_strings() {
602     if (!_code_strings.is_null()) {
603       _code_strings.free(); // sets _strings Null as a side-effect.
604     }
605   }
606 

















607   // Code generation
608   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0) {
609     _insts.relocate(at, rspec, format);
610   }
611   void relocate(address at,    relocInfo::relocType rtype, int format = 0) {
612     _insts.relocate(at, rtype, format);
613   }
614 
615   // Management of overflow storage for binding of Labels.
616   GrowableArray&lt;int&gt;* create_patch_overflow();
617 
618   // NMethod generation
619   void copy_code_and_locs_to(CodeBlob* blob) {
620     assert(blob != NULL, &quot;sane&quot;);
621     copy_relocations_to(blob);
622     copy_code_to(blob);
623   }
624   void copy_values_to(nmethod* nm) {
625     if (!oop_recorder()-&gt;is_unused()) {
626       oop_recorder()-&gt;copy_values_to(nm);
</pre>
<hr />
<pre>
633   void block_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
634   const char* code_string(const char* str) PRODUCT_RETURN_(return NULL;);
635 
636   // Log a little info about section usage in the CodeBuffer
637   void log_section_sizes(const char* name);
638 
639 #if INCLUDE_AOT
640   // True if this is a code buffer used for immutable PIC, i.e. AOT
641   // compilation.
642   bool immutable_PIC() { return _immutable_PIC; }
643   void set_immutable_PIC(bool pic) { _immutable_PIC = pic; }
644 #endif
645 
646 #ifndef PRODUCT
647  public:
648   // Printing / Decoding
649   // decodes from decode_begin() to code_end() and sets decode_begin to end
650   void    decode();
651   void    print();
652 #endif
<span class="line-modified">653 </span>

654 
655   // The following header contains architecture-specific implementations
656 #include CPU_HEADER(codeBuffer)
657 
658 };
659 
660 
661 inline void CodeSection::freeze() {
662   _outer-&gt;freeze_section(this);
663 }
664 
665 inline bool CodeSection::maybe_expand_to_ensure_remaining(csize_t amount) {
666   if (remaining() &lt; amount) { _outer-&gt;expand(this, amount); return true; }
667   return false;
668 }
669 
670 #endif // SHARE_ASM_CODEBUFFER_HPP
</pre>
</td>
<td>
<hr />
<pre>
232 
233   // Mark a section frozen.  Assign its remaining space to
234   // the following section.  It will never expand after this point.
235   inline void freeze();         //  { _outer-&gt;freeze_section(this); }
236 
237   // Ensure there&#39;s enough space left in the current section.
238   // Return true if there was an expansion.
239   bool maybe_expand_to_ensure_remaining(csize_t amount);
240 
241 #ifndef PRODUCT
242   void decode();
243   void print(const char* name);
244 #endif //PRODUCT
245 };
246 
247 class CodeString;
248 class CodeStrings {
249 private:
250 #ifndef PRODUCT
251   CodeString* _strings;
<span class="line-added">252   CodeString* _strings_last;</span>
253 #ifdef ASSERT
254   // Becomes true after copy-out, forbids further use.
255   bool _defunct; // Zero bit pattern is &quot;valid&quot;, see memset call in decode_env::decode_env
256 #endif
257   static const char* _prefix; // defaults to &quot; ;; &quot;
258 #endif
259 
260   CodeString* find(intptr_t offset) const;
261   CodeString* find_last(intptr_t offset) const;
262 
263   void set_null_and_invalidate() {
264 #ifndef PRODUCT
265     _strings = NULL;
<span class="line-added">266     _strings_last = NULL;</span>
267 #ifdef ASSERT
268     _defunct = true;
269 #endif
270 #endif
271   }
272 
273 public:
274   CodeStrings() {
275 #ifndef PRODUCT
276     _strings = NULL;
<span class="line-added">277     _strings_last = NULL;</span>
278 #ifdef ASSERT
279     _defunct = false;
280 #endif
281 #endif
282   }
283 
284   bool is_null() {
285 #ifdef ASSERT
286     return _strings == NULL;
287 #else
288     return true;
289 #endif
290   }
291 
292   const char* add_string(const char * string) PRODUCT_RETURN_(return NULL;);
293 
294   void add_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
<span class="line-added">295   bool has_block_comment(intptr_t offset) const;</span>
296   void print_block_comment(outputStream* stream, intptr_t offset) const PRODUCT_RETURN;
297   // MOVE strings from other to this; invalidate other.
298   void assign(CodeStrings&amp; other)  PRODUCT_RETURN;
299   // COPY strings from other to this; leave other valid.
300   void copy(CodeStrings&amp; other)  PRODUCT_RETURN;
301   // FREE strings; invalidate this.
302   void free() PRODUCT_RETURN;
<span class="line-added">303 </span>
304   // Guarantee that _strings are used at most once; assign and free invalidate a buffer.
305   inline void check_valid() const {
306 #ifdef ASSERT
307     assert(!_defunct, &quot;Use of invalid CodeStrings&quot;);
308 #endif
309   }
310 
311   static void set_prefix(const char *prefix) {
312 #ifndef PRODUCT
313     _prefix = prefix;
314 #endif
315   }
316 };
317 
318 // A CodeBuffer describes a memory space into which assembly
319 // code is generated.  This memory space usually occupies the
320 // interior of a single BufferBlob, but in some cases it may be
321 // an arbitrary span of memory, even outside the code cache.
322 //
323 // A code buffer comes in two variants:
</pre>
<hr />
<pre>
365  private:
366   enum {
367     sect_bits = 2,      // assert (SECT_LIMIT &lt;= (1&lt;&lt;sect_bits))
368     sect_mask = (1&lt;&lt;sect_bits)-1
369   };
370 
371   const char*  _name;
372 
373   CodeSection  _consts;             // constants, jump tables
374   CodeSection  _insts;              // instructions (the main section)
375   CodeSection  _stubs;              // stubs (call site support), deopt, exception handling
376 
377   CodeBuffer*  _before_expand;  // dead buffer, from before the last expansion
378 
379   BufferBlob*  _blob;           // optional buffer in CodeCache for generated code
380   address      _total_start;    // first address of combined memory buffer
381   csize_t      _total_size;     // size in bytes of combined memory buffer
382 
383   OopRecorder* _oop_recorder;
384   CodeStrings  _code_strings;
<span class="line-added">385   bool         _collect_comments;      // Indicate if we need to collect block comments at all.</span>
386   OopRecorder  _default_oop_recorder;  // override with initialize_oop_recorder
387   Arena*       _overflow_arena;
388 
389   address      _last_insn;      // used to merge consecutive memory barriers, loads or stores.
390 
391 #if INCLUDE_AOT
392   bool         _immutable_PIC;
393 #endif
394 
395   address      _decode_begin;   // start address for decode
396   address      decode_begin();
397 
398   void initialize_misc(const char * name) {
399     // all pointers other than code_start/end and those inside the sections
400     assert(name != NULL, &quot;must have a name&quot;);
401     _name            = name;
402     _before_expand   = NULL;
403     _blob            = NULL;
404     _oop_recorder    = NULL;
405     _decode_begin    = NULL;
406     _overflow_arena  = NULL;
407     _code_strings    = CodeStrings();
408     _last_insn       = NULL;
409 #if INCLUDE_AOT
410     _immutable_PIC   = false;
411 #endif
<span class="line-added">412 </span>
<span class="line-added">413     // Collect block comments, but restrict collection to cases where a disassembly is output.</span>
<span class="line-added">414     _collect_comments = ( PrintAssembly</span>
<span class="line-added">415                        || PrintStubCode</span>
<span class="line-added">416                        || PrintMethodHandleStubs</span>
<span class="line-added">417                        || PrintInterpreter</span>
<span class="line-added">418                        || PrintSignatureHandlers</span>
<span class="line-added">419                        || UnlockDiagnosticVMOptions</span>
<span class="line-added">420                         );</span>
421   }
422 
423   void initialize(address code_start, csize_t code_size) {
424     _consts.initialize_outer(this,  SECT_CONSTS);
425     _insts.initialize_outer(this,   SECT_INSTS);
426     _stubs.initialize_outer(this,   SECT_STUBS);
427     _total_start = code_start;
428     _total_size  = code_size;
429     // Initialize the main section:
430     _insts.initialize(code_start, code_size);
431     assert(!_stubs.is_allocated(),  &quot;no garbage here&quot;);
432     assert(!_consts.is_allocated(), &quot;no garbage here&quot;);
433     _oop_recorder = &amp;_default_oop_recorder;
434   }
435 
436   void initialize_section_size(CodeSection* cs, csize_t size);
437 
438   void freeze_section(CodeSection* cs);
439 
440   // helper for CodeBuffer::expand()
</pre>
<hr />
<pre>
602   // The section sizes are subtracted from the original insts section.
603   // Note:  Call them in reverse section order, because each steals from insts.
604   void initialize_consts_size(csize_t size)            { initialize_section_size(&amp;_consts,  size); }
605   void initialize_stubs_size(csize_t size)             { initialize_section_size(&amp;_stubs,   size); }
606   // Override default oop recorder.
607   void initialize_oop_recorder(OopRecorder* r);
608 
609   OopRecorder* oop_recorder() const   { return _oop_recorder; }
610   CodeStrings&amp; strings()              { return _code_strings; }
611 
612   address last_insn() const { return _last_insn; }
613   void set_last_insn(address a) { _last_insn = a; }
614   void clear_last_insn() { set_last_insn(NULL); }
615 
616   void free_strings() {
617     if (!_code_strings.is_null()) {
618       _code_strings.free(); // sets _strings Null as a side-effect.
619     }
620   }
621 
<span class="line-added">622   // Directly disassemble code buffer.</span>
<span class="line-added">623   // Print the comment associated with offset on stream, if there is one.</span>
<span class="line-added">624   virtual void print_block_comment(outputStream* stream, address block_begin) {</span>
<span class="line-added">625 #ifndef PRODUCT</span>
<span class="line-added">626     intptr_t offset = (intptr_t)(block_begin - _total_start);  // I assume total_start is not correct for all code sections.</span>
<span class="line-added">627     _code_strings.print_block_comment(stream, offset);</span>
<span class="line-added">628 #endif</span>
<span class="line-added">629   }</span>
<span class="line-added">630   bool has_block_comment(address block_begin) {</span>
<span class="line-added">631 #ifndef PRODUCT</span>
<span class="line-added">632     intptr_t offset = (intptr_t)(block_begin - _total_start);  // I assume total_start is not correct for all code sections.</span>
<span class="line-added">633     return _code_strings.has_block_comment(offset);</span>
<span class="line-added">634 #else</span>
<span class="line-added">635     return false;</span>
<span class="line-added">636 #endif</span>
<span class="line-added">637   }</span>
<span class="line-added">638 </span>
639   // Code generation
640   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0) {
641     _insts.relocate(at, rspec, format);
642   }
643   void relocate(address at,    relocInfo::relocType rtype, int format = 0) {
644     _insts.relocate(at, rtype, format);
645   }
646 
647   // Management of overflow storage for binding of Labels.
648   GrowableArray&lt;int&gt;* create_patch_overflow();
649 
650   // NMethod generation
651   void copy_code_and_locs_to(CodeBlob* blob) {
652     assert(blob != NULL, &quot;sane&quot;);
653     copy_relocations_to(blob);
654     copy_code_to(blob);
655   }
656   void copy_values_to(nmethod* nm) {
657     if (!oop_recorder()-&gt;is_unused()) {
658       oop_recorder()-&gt;copy_values_to(nm);
</pre>
<hr />
<pre>
665   void block_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
666   const char* code_string(const char* str) PRODUCT_RETURN_(return NULL;);
667 
668   // Log a little info about section usage in the CodeBuffer
669   void log_section_sizes(const char* name);
670 
671 #if INCLUDE_AOT
672   // True if this is a code buffer used for immutable PIC, i.e. AOT
673   // compilation.
674   bool immutable_PIC() { return _immutable_PIC; }
675   void set_immutable_PIC(bool pic) { _immutable_PIC = pic; }
676 #endif
677 
678 #ifndef PRODUCT
679  public:
680   // Printing / Decoding
681   // decodes from decode_begin() to code_end() and sets decode_begin to end
682   void    decode();
683   void    print();
684 #endif
<span class="line-modified">685   // Directly disassemble code buffer.</span>
<span class="line-added">686   void    decode(address start, address end);</span>
687 
688   // The following header contains architecture-specific implementations
689 #include CPU_HEADER(codeBuffer)
690 
691 };
692 
693 
694 inline void CodeSection::freeze() {
695   _outer-&gt;freeze_section(this);
696 }
697 
698 inline bool CodeSection::maybe_expand_to_ensure_remaining(csize_t amount) {
699   if (remaining() &lt; amount) { _outer-&gt;expand(this, amount); return true; }
700   return false;
701 }
702 
703 #endif // SHARE_ASM_CODEBUFFER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="codeBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_Canonicalizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
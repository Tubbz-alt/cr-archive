<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/asm/codeBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/codeBuffer.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;oops/methodData.hpp&quot;
  29 #include &quot;oops/oop.inline.hpp&quot;
  30 #include &quot;runtime/icache.hpp&quot;
  31 #include &quot;runtime/safepointVerifiers.hpp&quot;
  32 #include &quot;utilities/align.hpp&quot;
  33 #include &quot;utilities/copy.hpp&quot;
  34 #include &quot;utilities/xmlstream.hpp&quot;
  35 
  36 // The structure of a CodeSection:
  37 //
  38 //    _start -&gt;           +----------------+
  39 //                        | machine code...|
  40 //    _end -&gt;             |----------------|
  41 //                        |                |
  42 //                        |    (empty)     |
  43 //                        |                |
  44 //                        |                |
  45 //                        +----------------+
  46 //    _limit -&gt;           |                |
  47 //
  48 //    _locs_start -&gt;      +----------------+
  49 //                        |reloc records...|
  50 //                        |----------------|
  51 //    _locs_end -&gt;        |                |
  52 //                        |                |
  53 //                        |    (empty)     |
  54 //                        |                |
  55 //                        |                |
  56 //                        +----------------+
  57 //    _locs_limit -&gt;      |                |
  58 // The _end (resp. _limit) pointer refers to the first
  59 // unused (resp. unallocated) byte.
  60 
  61 // The structure of the CodeBuffer while code is being accumulated:
  62 //
  63 //    _total_start -&gt;    \
  64 //    _insts._start -&gt;              +----------------+
  65 //                                  |                |
  66 //                                  |     Code       |
  67 //                                  |                |
  68 //    _stubs._start -&gt;              |----------------|
  69 //                                  |                |
  70 //                                  |    Stubs       | (also handlers for deopt/exception)
  71 //                                  |                |
  72 //    _consts._start -&gt;             |----------------|
  73 //                                  |                |
  74 //                                  |   Constants    |
  75 //                                  |                |
  76 //                                  +----------------+
  77 //    + _total_size -&gt;              |                |
  78 //
  79 // When the code and relocations are copied to the code cache,
  80 // the empty parts of each section are removed, and everything
  81 // is copied into contiguous locations.
  82 
  83 typedef CodeBuffer::csize_t csize_t;  // file-local definition
  84 
  85 // External buffer, in a predefined CodeBlob.
  86 // Important: The code_start must be taken exactly, and not realigned.
  87 CodeBuffer::CodeBuffer(CodeBlob* blob) {
  88   initialize_misc(&quot;static buffer&quot;);
  89   initialize(blob-&gt;content_begin(), blob-&gt;content_size());
  90   verify_section_allocation();
  91 }
  92 
  93 void CodeBuffer::initialize(csize_t code_size, csize_t locs_size) {
  94   // Compute maximal alignment.
  95   int align = _insts.alignment();
  96   // Always allow for empty slop around each section.
  97   int slop = (int) CodeSection::end_slop();
  98 
  99   assert(blob() == NULL, &quot;only once&quot;);
 100   set_blob(BufferBlob::create(_name, code_size + (align+slop) * (SECT_LIMIT+1)));
 101   if (blob() == NULL) {
 102     // The assembler constructor will throw a fatal on an empty CodeBuffer.
 103     return;  // caller must test this
 104   }
 105 
 106   // Set up various pointers into the blob.
 107   initialize(_total_start, _total_size);
 108 
 109   assert((uintptr_t)insts_begin() % CodeEntryAlignment == 0, &quot;instruction start not code entry aligned&quot;);
 110 
 111   pd_initialize();
 112 
 113   if (locs_size != 0) {
 114     _insts.initialize_locs(locs_size / sizeof(relocInfo));
 115   }
 116 
 117   verify_section_allocation();
 118 }
 119 
 120 
 121 CodeBuffer::~CodeBuffer() {
 122   verify_section_allocation();
 123 
 124   // If we allocate our code buffer from the CodeCache
 125   // via a BufferBlob, and it&#39;s not permanent, then
 126   // free the BufferBlob.
 127   // The rest of the memory will be freed when the ResourceObj
 128   // is released.
 129   for (CodeBuffer* cb = this; cb != NULL; cb = cb-&gt;before_expand()) {
 130     // Previous incarnations of this buffer are held live, so that internal
 131     // addresses constructed before expansions will not be confused.
 132     cb-&gt;free_blob();
 133   }
 134 
 135   // free any overflow storage
 136   delete _overflow_arena;
 137 
 138   // Claim is that stack allocation ensures resources are cleaned up.
 139   // This is resource clean up, let&#39;s hope that all were properly copied out.
 140   free_strings();
 141 
 142 #ifdef ASSERT
 143   // Save allocation type to execute assert in ~ResourceObj()
 144   // which is called after this destructor.
 145   assert(_default_oop_recorder.allocated_on_stack(), &quot;should be embedded object&quot;);
 146   ResourceObj::allocation_type at = _default_oop_recorder.get_allocation_type();
 147   Copy::fill_to_bytes(this, sizeof(*this), badResourceValue);
 148   ResourceObj::set_allocation_type((address)(&amp;_default_oop_recorder), at);
 149 #endif
 150 }
 151 
 152 void CodeBuffer::initialize_oop_recorder(OopRecorder* r) {
 153   assert(_oop_recorder == &amp;_default_oop_recorder &amp;&amp; _default_oop_recorder.is_unused(), &quot;do this once&quot;);
 154   DEBUG_ONLY(_default_oop_recorder.freeze());  // force unused OR to be frozen
 155   _oop_recorder = r;
 156 }
 157 
 158 void CodeBuffer::initialize_section_size(CodeSection* cs, csize_t size) {
 159   assert(cs != &amp;_insts, &quot;insts is the memory provider, not the consumer&quot;);
 160   csize_t slop = CodeSection::end_slop();  // margin between sections
 161   int align = cs-&gt;alignment();
 162   assert(is_power_of_2(align), &quot;sanity&quot;);
 163   address start  = _insts._start;
 164   address limit  = _insts._limit;
 165   address middle = limit - size;
 166   middle -= (intptr_t)middle &amp; (align-1);  // align the division point downward
 167   guarantee(middle - slop &gt; start, &quot;need enough space to divide up&quot;);
 168   _insts._limit = middle - slop;  // subtract desired space, plus slop
 169   cs-&gt;initialize(middle, limit - middle);
 170   assert(cs-&gt;start() == middle, &quot;sanity&quot;);
 171   assert(cs-&gt;limit() == limit,  &quot;sanity&quot;);
 172   // give it some relocations to start with, if the main section has them
 173   if (_insts.has_locs())  cs-&gt;initialize_locs(1);
 174 }
 175 
 176 void CodeBuffer::freeze_section(CodeSection* cs) {
 177   CodeSection* next_cs = (cs == consts())? NULL: code_section(cs-&gt;index()+1);
 178   csize_t frozen_size = cs-&gt;size();
 179   if (next_cs != NULL) {
 180     frozen_size = next_cs-&gt;align_at_start(frozen_size);
 181   }
 182   address old_limit = cs-&gt;limit();
 183   address new_limit = cs-&gt;start() + frozen_size;
 184   relocInfo* old_locs_limit = cs-&gt;locs_limit();
 185   relocInfo* new_locs_limit = cs-&gt;locs_end();
 186   // Patch the limits.
 187   cs-&gt;_limit = new_limit;
 188   cs-&gt;_locs_limit = new_locs_limit;
 189   cs-&gt;_frozen = true;
 190   if (next_cs != NULL &amp;&amp; !next_cs-&gt;is_allocated() &amp;&amp; !next_cs-&gt;is_frozen()) {
 191     // Give remaining buffer space to the following section.
 192     next_cs-&gt;initialize(new_limit, old_limit - new_limit);
 193     next_cs-&gt;initialize_shared_locs(new_locs_limit,
 194                                     old_locs_limit - new_locs_limit);
 195   }
 196 }
 197 
 198 void CodeBuffer::set_blob(BufferBlob* blob) {
 199   _blob = blob;
 200   if (blob != NULL) {
 201     address start = blob-&gt;content_begin();
 202     address end   = blob-&gt;content_end();
 203     // Round up the starting address.
 204     int align = _insts.alignment();
 205     start += (-(intptr_t)start) &amp; (align-1);
 206     _total_start = start;
 207     _total_size  = end - start;
 208   } else {
 209 #ifdef ASSERT
 210     // Clean out dangling pointers.
 211     _total_start    = badAddress;
 212     _consts._start  = _consts._end  = badAddress;
 213     _insts._start   = _insts._end   = badAddress;
 214     _stubs._start   = _stubs._end   = badAddress;
 215 #endif //ASSERT
 216   }
 217 }
 218 
 219 void CodeBuffer::free_blob() {
 220   if (_blob != NULL) {
 221     BufferBlob::free(_blob);
 222     set_blob(NULL);
 223   }
 224 }
 225 
 226 const char* CodeBuffer::code_section_name(int n) {
 227 #ifdef PRODUCT
 228   return NULL;
 229 #else //PRODUCT
 230   switch (n) {
 231   case SECT_CONSTS:            return &quot;consts&quot;;
 232   case SECT_INSTS:             return &quot;insts&quot;;
 233   case SECT_STUBS:             return &quot;stubs&quot;;
 234   default:                     return NULL;
 235   }
 236 #endif //PRODUCT
 237 }
 238 
 239 int CodeBuffer::section_index_of(address addr) const {
 240   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 241     const CodeSection* cs = code_section(n);
 242     if (cs-&gt;allocates(addr))  return n;
 243   }
 244   return SECT_NONE;
 245 }
 246 
 247 int CodeBuffer::locator(address addr) const {
 248   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 249     const CodeSection* cs = code_section(n);
 250     if (cs-&gt;allocates(addr)) {
 251       return locator(addr - cs-&gt;start(), n);
 252     }
 253   }
 254   return -1;
 255 }
 256 
 257 address CodeBuffer::locator_address(int locator) const {
 258   if (locator &lt; 0)  return NULL;
 259   address start = code_section(locator_sect(locator))-&gt;start();
 260   return start + locator_pos(locator);
 261 }
 262 
 263 bool CodeBuffer::is_backward_branch(Label&amp; L) {
 264   return L.is_bound() &amp;&amp; insts_end() &lt;= locator_address(L.loc());
 265 }
 266 
 267 address CodeBuffer::decode_begin() {
 268   address begin = _insts.start();
 269   if (_decode_begin != NULL &amp;&amp; _decode_begin &gt; begin)
 270     begin = _decode_begin;
 271   return begin;
 272 }
 273 
 274 
 275 GrowableArray&lt;int&gt;* CodeBuffer::create_patch_overflow() {
 276   if (_overflow_arena == NULL) {
 277     _overflow_arena = new (mtCode) Arena(mtCode);
 278   }
 279   return new (_overflow_arena) GrowableArray&lt;int&gt;(_overflow_arena, 8, 0, 0);
 280 }
 281 
 282 
 283 // Helper function for managing labels and their target addresses.
 284 // Returns a sensible address, and if it is not the label&#39;s final
 285 // address, notes the dependency (at &#39;branch_pc&#39;) on the label.
 286 address CodeSection::target(Label&amp; L, address branch_pc) {
 287   if (L.is_bound()) {
 288     int loc = L.loc();
 289     if (index() == CodeBuffer::locator_sect(loc)) {
 290       return start() + CodeBuffer::locator_pos(loc);
 291     } else {
 292       return outer()-&gt;locator_address(loc);
 293     }
 294   } else {
 295     assert(allocates2(branch_pc), &quot;sanity&quot;);
 296     address base = start();
 297     int patch_loc = CodeBuffer::locator(branch_pc - base, index());
 298     L.add_patch_at(outer(), patch_loc);
 299 
 300     // Need to return a pc, doesn&#39;t matter what it is since it will be
 301     // replaced during resolution later.
 302     // Don&#39;t return NULL or badAddress, since branches shouldn&#39;t overflow.
 303     // Don&#39;t return base either because that could overflow displacements
 304     // for shorter branches.  It will get checked when bound.
 305     return branch_pc;
 306   }
 307 }
 308 
 309 void CodeSection::relocate(address at, relocInfo::relocType rtype, int format, jint method_index) {
 310   RelocationHolder rh;
 311   switch (rtype) {
 312     case relocInfo::none: return;
 313     case relocInfo::opt_virtual_call_type: {
 314       rh = opt_virtual_call_Relocation::spec(method_index);
 315       break;
 316     }
 317     case relocInfo::static_call_type: {
 318       rh = static_call_Relocation::spec(method_index);
 319       break;
 320     }
 321     case relocInfo::virtual_call_type: {
 322       assert(method_index == 0, &quot;resolved method overriding is not supported&quot;);
 323       rh = Relocation::spec_simple(rtype);
 324       break;
 325     }
 326     default: {
 327       rh = Relocation::spec_simple(rtype);
 328       break;
 329     }
 330   }
 331   relocate(at, rh, format);
 332 }
 333 
 334 void CodeSection::relocate(address at, RelocationHolder const&amp; spec, int format) {
 335   // Do not relocate in scratch buffers.
 336   if (scratch_emit()) { return; }
 337   Relocation* reloc = spec.reloc();
 338   relocInfo::relocType rtype = (relocInfo::relocType) reloc-&gt;type();
 339   if (rtype == relocInfo::none)  return;
 340 
 341   // The assertion below has been adjusted, to also work for
 342   // relocation for fixup.  Sometimes we want to put relocation
 343   // information for the next instruction, since it will be patched
 344   // with a call.
 345   assert(start() &lt;= at &amp;&amp; at &lt;= end()+1,
 346          &quot;cannot relocate data outside code boundaries&quot;);
 347 
 348   if (!has_locs()) {
 349     // no space for relocation information provided =&gt; code cannot be
 350     // relocated.  Make sure that relocate is only called with rtypes
 351     // that can be ignored for this kind of code.
 352     assert(rtype == relocInfo::none              ||
 353            rtype == relocInfo::runtime_call_type ||
 354            rtype == relocInfo::internal_word_type||
 355            rtype == relocInfo::section_word_type ||
 356            rtype == relocInfo::external_word_type,
 357            &quot;code needs relocation information&quot;);
 358     // leave behind an indication that we attempted a relocation
 359     DEBUG_ONLY(_locs_start = _locs_limit = (relocInfo*)badAddress);
 360     return;
 361   }
 362 
 363   // Advance the point, noting the offset we&#39;ll have to record.
 364   csize_t offset = at - locs_point();
 365   set_locs_point(at);
 366 
 367   // Test for a couple of overflow conditions; maybe expand the buffer.
 368   relocInfo* end = locs_end();
 369   relocInfo* req = end + relocInfo::length_limit;
 370   // Check for (potential) overflow
 371   if (req &gt;= locs_limit() || offset &gt;= relocInfo::offset_limit()) {
 372     req += (uint)offset / (uint)relocInfo::offset_limit();
 373     if (req &gt;= locs_limit()) {
 374       // Allocate or reallocate.
 375       expand_locs(locs_count() + (req - end));
 376       // reload pointer
 377       end = locs_end();
 378     }
 379   }
 380 
 381   // If the offset is giant, emit filler relocs, of type &#39;none&#39;, but
 382   // each carrying the largest possible offset, to advance the locs_point.
 383   while (offset &gt;= relocInfo::offset_limit()) {
 384     assert(end &lt; locs_limit(), &quot;adjust previous paragraph of code&quot;);
 385     *end++ = filler_relocInfo();
 386     offset -= filler_relocInfo().addr_offset();
 387   }
 388 
 389   // If it&#39;s a simple reloc with no data, we&#39;ll just write (rtype | offset).
 390   (*end) = relocInfo(rtype, offset, format);
 391 
 392   // If it has data, insert the prefix, as (data_prefix_tag | data1), data2.
 393   end-&gt;initialize(this, reloc);
 394 }
 395 
 396 void CodeSection::initialize_locs(int locs_capacity) {
 397   assert(_locs_start == NULL, &quot;only one locs init step, please&quot;);
 398   // Apply a priori lower limits to relocation size:
 399   csize_t min_locs = MAX2(size() / 16, (csize_t)4);
 400   if (locs_capacity &lt; min_locs)  locs_capacity = min_locs;
 401   relocInfo* locs_start = NEW_RESOURCE_ARRAY(relocInfo, locs_capacity);
 402   _locs_start    = locs_start;
 403   _locs_end      = locs_start;
 404   _locs_limit    = locs_start + locs_capacity;
 405   _locs_own      = true;
 406 }
 407 
 408 void CodeSection::initialize_shared_locs(relocInfo* buf, int length) {
 409   assert(_locs_start == NULL, &quot;do this before locs are allocated&quot;);
 410   // Internal invariant:  locs buf must be fully aligned.
 411   // See copy_relocations_to() below.
 412   while ((uintptr_t)buf % HeapWordSize != 0 &amp;&amp; length &gt; 0) {
 413     ++buf; --length;
 414   }
 415   if (length &gt; 0) {
 416     _locs_start = buf;
 417     _locs_end   = buf;
 418     _locs_limit = buf + length;
 419     _locs_own   = false;
 420   }
 421 }
 422 
 423 void CodeSection::initialize_locs_from(const CodeSection* source_cs) {
 424   int lcount = source_cs-&gt;locs_count();
 425   if (lcount != 0) {
 426     initialize_shared_locs(source_cs-&gt;locs_start(), lcount);
 427     _locs_end = _locs_limit = _locs_start + lcount;
 428     assert(is_allocated(), &quot;must have copied code already&quot;);
 429     set_locs_point(start() + source_cs-&gt;locs_point_off());
 430   }
 431   assert(this-&gt;locs_count() == source_cs-&gt;locs_count(), &quot;sanity&quot;);
 432 }
 433 
 434 void CodeSection::expand_locs(int new_capacity) {
 435   if (_locs_start == NULL) {
 436     initialize_locs(new_capacity);
 437     return;
 438   } else {
 439     int old_count    = locs_count();
 440     int old_capacity = locs_capacity();
 441     if (new_capacity &lt; old_capacity * 2)
 442       new_capacity = old_capacity * 2;
 443     relocInfo* locs_start;
 444     if (_locs_own) {
 445       locs_start = REALLOC_RESOURCE_ARRAY(relocInfo, _locs_start, old_capacity, new_capacity);
 446     } else {
 447       locs_start = NEW_RESOURCE_ARRAY(relocInfo, new_capacity);
 448       Copy::conjoint_jbytes(_locs_start, locs_start, old_capacity * sizeof(relocInfo));
 449       _locs_own = true;
 450     }
 451     _locs_start    = locs_start;
 452     _locs_end      = locs_start + old_count;
 453     _locs_limit    = locs_start + new_capacity;
 454   }
 455 }
 456 
 457 
 458 /// Support for emitting the code to its final location.
 459 /// The pattern is the same for all functions.
 460 /// We iterate over all the sections, padding each to alignment.
 461 
 462 csize_t CodeBuffer::total_content_size() const {
 463   csize_t size_so_far = 0;
 464   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 465     const CodeSection* cs = code_section(n);
 466     if (cs-&gt;is_empty())  continue;  // skip trivial section
 467     size_so_far = cs-&gt;align_at_start(size_so_far);
 468     size_so_far += cs-&gt;size();
 469   }
 470   return size_so_far;
 471 }
 472 
 473 void CodeBuffer::compute_final_layout(CodeBuffer* dest) const {
 474   address buf = dest-&gt;_total_start;
 475   csize_t buf_offset = 0;
 476   assert(dest-&gt;_total_size &gt;= total_content_size(), &quot;must be big enough&quot;);
 477 
 478   {
 479     // not sure why this is here, but why not...
 480     int alignSize = MAX2((intx) sizeof(jdouble), CodeEntryAlignment);
 481     assert( (dest-&gt;_total_start - _insts.start()) % alignSize == 0, &quot;copy must preserve alignment&quot;);
 482   }
 483 
 484   const CodeSection* prev_cs      = NULL;
 485   CodeSection*       prev_dest_cs = NULL;
 486 
 487   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 488     // figure compact layout of each section
 489     const CodeSection* cs = code_section(n);
 490     csize_t csize = cs-&gt;size();
 491 
 492     CodeSection* dest_cs = dest-&gt;code_section(n);
 493     if (!cs-&gt;is_empty()) {
 494       // Compute initial padding; assign it to the previous non-empty guy.
 495       // Cf. figure_expanded_capacities.
 496       csize_t padding = cs-&gt;align_at_start(buf_offset) - buf_offset;
 497       if (prev_dest_cs != NULL) {
 498         if (padding != 0) {
 499           buf_offset += padding;
 500           prev_dest_cs-&gt;_limit += padding;
 501         }
 502       } else {
 503         guarantee(padding == 0, &quot;In first iteration no padding should be needed.&quot;);
 504       }
 505       #ifdef ASSERT
 506       if (prev_cs != NULL &amp;&amp; prev_cs-&gt;is_frozen() &amp;&amp; n &lt; (SECT_LIMIT - 1)) {
 507         // Make sure the ends still match up.
 508         // This is important because a branch in a frozen section
 509         // might target code in a following section, via a Label,
 510         // and without a relocation record.  See Label::patch_instructions.
 511         address dest_start = buf+buf_offset;
 512         csize_t start2start = cs-&gt;start() - prev_cs-&gt;start();
 513         csize_t dest_start2start = dest_start - prev_dest_cs-&gt;start();
 514         assert(start2start == dest_start2start, &quot;cannot stretch frozen sect&quot;);
 515       }
 516       #endif //ASSERT
 517       prev_dest_cs = dest_cs;
 518       prev_cs      = cs;
 519     }
 520 
 521     debug_only(dest_cs-&gt;_start = NULL);  // defeat double-initialization assert
 522     dest_cs-&gt;initialize(buf+buf_offset, csize);
 523     dest_cs-&gt;set_end(buf+buf_offset+csize);
 524     assert(dest_cs-&gt;is_allocated(), &quot;must always be allocated&quot;);
 525     assert(cs-&gt;is_empty() == dest_cs-&gt;is_empty(), &quot;sanity&quot;);
 526 
 527     buf_offset += csize;
 528   }
 529 
 530   // Done calculating sections; did it come out to the right end?
 531   assert(buf_offset == total_content_size(), &quot;sanity&quot;);
 532   dest-&gt;verify_section_allocation();
 533 }
 534 
 535 // Append an oop reference that keeps the class alive.
 536 static void append_oop_references(GrowableArray&lt;oop&gt;* oops, Klass* k) {
 537   oop cl = k-&gt;klass_holder();
 538   if (cl != NULL &amp;&amp; !oops-&gt;contains(cl)) {
 539     oops-&gt;append(cl);
 540   }
 541 }
 542 
 543 void CodeBuffer::finalize_oop_references(const methodHandle&amp; mh) {
 544   NoSafepointVerifier nsv;
 545 
 546   GrowableArray&lt;oop&gt; oops;
 547 
 548   // Make sure that immediate metadata records something in the OopRecorder
 549   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 550     // pull code out of each section
 551     CodeSection* cs = code_section(n);
 552     if (cs-&gt;is_empty())  continue;  // skip trivial section
 553     RelocIterator iter(cs);
 554     while (iter.next()) {
 555       if (iter.type() == relocInfo::metadata_type) {
 556         metadata_Relocation* md = iter.metadata_reloc();
 557         if (md-&gt;metadata_is_immediate()) {
 558           Metadata* m = md-&gt;metadata_value();
 559           if (oop_recorder()-&gt;is_real(m)) {
 560             if (m-&gt;is_methodData()) {
 561               m = ((MethodData*)m)-&gt;method();
 562             }
 563             if (m-&gt;is_method()) {
 564               m = ((Method*)m)-&gt;method_holder();
 565             }
 566             if (m-&gt;is_klass()) {
 567               append_oop_references(&amp;oops, (Klass*)m);
 568             } else {
 569               // XXX This will currently occur for MDO which don&#39;t
 570               // have a backpointer.  This has to be fixed later.
 571               m-&gt;print();
 572               ShouldNotReachHere();
 573             }
 574           }
 575         }
 576       }
 577     }
 578   }
 579 
 580   if (!oop_recorder()-&gt;is_unused()) {
 581     for (int i = 0; i &lt; oop_recorder()-&gt;metadata_count(); i++) {
 582       Metadata* m = oop_recorder()-&gt;metadata_at(i);
 583       if (oop_recorder()-&gt;is_real(m)) {
 584         if (m-&gt;is_methodData()) {
 585           m = ((MethodData*)m)-&gt;method();
 586         }
 587         if (m-&gt;is_method()) {
 588           m = ((Method*)m)-&gt;method_holder();
 589         }
 590         if (m-&gt;is_klass()) {
 591           append_oop_references(&amp;oops, (Klass*)m);
 592         } else {
 593           m-&gt;print();
 594           ShouldNotReachHere();
 595         }
 596       }
 597     }
 598 
 599   }
 600 
 601   // Add the class loader of Method* for the nmethod itself
 602   append_oop_references(&amp;oops, mh-&gt;method_holder());
 603 
 604   // Add any oops that we&#39;ve found
 605   Thread* thread = Thread::current();
 606   for (int i = 0; i &lt; oops.length(); i++) {
 607     oop_recorder()-&gt;find_index((jobject)thread-&gt;handle_area()-&gt;allocate_handle(oops.at(i)));
 608   }
 609 }
 610 
 611 
 612 
 613 csize_t CodeBuffer::total_offset_of(const CodeSection* cs) const {
 614   csize_t size_so_far = 0;
 615   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 616     const CodeSection* cur_cs = code_section(n);
 617     if (!cur_cs-&gt;is_empty()) {
 618       size_so_far = cur_cs-&gt;align_at_start(size_so_far);
 619     }
 620     if (cur_cs-&gt;index() == cs-&gt;index()) {
 621       return size_so_far;
 622     }
 623     size_so_far += cur_cs-&gt;size();
 624   }
 625   ShouldNotReachHere();
 626   return -1;
 627 }
 628 
 629 csize_t CodeBuffer::total_relocation_size() const {
 630   csize_t total = copy_relocations_to(NULL);  // dry run only
 631   return (csize_t) align_up(total, HeapWordSize);
 632 }
 633 
 634 csize_t CodeBuffer::copy_relocations_to(address buf, csize_t buf_limit, bool only_inst) const {
 635   csize_t buf_offset = 0;
 636   csize_t code_end_so_far = 0;
 637   csize_t code_point_so_far = 0;
 638 
 639   assert((uintptr_t)buf % HeapWordSize == 0, &quot;buf must be fully aligned&quot;);
 640   assert(buf_limit % HeapWordSize == 0, &quot;buf must be evenly sized&quot;);
 641 
 642   for (int n = (int) SECT_FIRST; n &lt; (int)SECT_LIMIT; n++) {
 643     if (only_inst &amp;&amp; (n != (int)SECT_INSTS)) {
 644       // Need only relocation info for code.
 645       continue;
 646     }
 647     // pull relocs out of each section
 648     const CodeSection* cs = code_section(n);
 649     assert(!(cs-&gt;is_empty() &amp;&amp; cs-&gt;locs_count() &gt; 0), &quot;sanity&quot;);
 650     if (cs-&gt;is_empty())  continue;  // skip trivial section
 651     relocInfo* lstart = cs-&gt;locs_start();
 652     relocInfo* lend   = cs-&gt;locs_end();
 653     csize_t    lsize  = (csize_t)( (address)lend - (address)lstart );
 654     csize_t    csize  = cs-&gt;size();
 655     code_end_so_far = cs-&gt;align_at_start(code_end_so_far);
 656 
 657     if (lsize &gt; 0) {
 658       // Figure out how to advance the combined relocation point
 659       // first to the beginning of this section.
 660       // We&#39;ll insert one or more filler relocs to span that gap.
 661       // (Don&#39;t bother to improve this by editing the first reloc&#39;s offset.)
 662       csize_t new_code_point = code_end_so_far;
 663       for (csize_t jump;
 664            code_point_so_far &lt; new_code_point;
 665            code_point_so_far += jump) {
 666         jump = new_code_point - code_point_so_far;
 667         relocInfo filler = filler_relocInfo();
 668         if (jump &gt;= filler.addr_offset()) {
 669           jump = filler.addr_offset();
 670         } else {  // else shrink the filler to fit
 671           filler = relocInfo(relocInfo::none, jump);
 672         }
 673         if (buf != NULL) {
 674           assert(buf_offset + (csize_t)sizeof(filler) &lt;= buf_limit, &quot;filler in bounds&quot;);
 675           *(relocInfo*)(buf+buf_offset) = filler;
 676         }
 677         buf_offset += sizeof(filler);
 678       }
 679 
 680       // Update code point and end to skip past this section:
 681       csize_t last_code_point = code_end_so_far + cs-&gt;locs_point_off();
 682       assert(code_point_so_far &lt;= last_code_point, &quot;sanity&quot;);
 683       code_point_so_far = last_code_point; // advance past this guy&#39;s relocs
 684     }
 685     code_end_so_far += csize;  // advance past this guy&#39;s instructions too
 686 
 687     // Done with filler; emit the real relocations:
 688     if (buf != NULL &amp;&amp; lsize != 0) {
 689       assert(buf_offset + lsize &lt;= buf_limit, &quot;target in bounds&quot;);
 690       assert((uintptr_t)lstart % HeapWordSize == 0, &quot;sane start&quot;);
 691       if (buf_offset % HeapWordSize == 0) {
 692         // Use wordwise copies if possible:
 693         Copy::disjoint_words((HeapWord*)lstart,
 694                              (HeapWord*)(buf+buf_offset),
 695                              (lsize + HeapWordSize-1) / HeapWordSize);
 696       } else {
 697         Copy::conjoint_jbytes(lstart, buf+buf_offset, lsize);
 698       }
 699     }
 700     buf_offset += lsize;
 701   }
 702 
 703   // Align end of relocation info in target.
 704   while (buf_offset % HeapWordSize != 0) {
 705     if (buf != NULL) {
 706       relocInfo padding = relocInfo(relocInfo::none, 0);
 707       assert(buf_offset + (csize_t)sizeof(padding) &lt;= buf_limit, &quot;padding in bounds&quot;);
 708       *(relocInfo*)(buf+buf_offset) = padding;
 709     }
 710     buf_offset += sizeof(relocInfo);
 711   }
 712 
 713   assert(only_inst || code_end_so_far == total_content_size(), &quot;sanity&quot;);
 714 
 715   return buf_offset;
 716 }
 717 
 718 csize_t CodeBuffer::copy_relocations_to(CodeBlob* dest) const {
 719   address buf = NULL;
 720   csize_t buf_offset = 0;
 721   csize_t buf_limit = 0;
 722 
 723   if (dest != NULL) {
 724     buf = (address)dest-&gt;relocation_begin();
 725     buf_limit = (address)dest-&gt;relocation_end() - buf;
 726   }
 727   // if dest == NULL, this is just the sizing pass
 728   //
 729   buf_offset = copy_relocations_to(buf, buf_limit, false);
 730 
 731   return buf_offset;
 732 }
 733 
 734 void CodeBuffer::copy_code_to(CodeBlob* dest_blob) {
 735 #ifndef PRODUCT
 736   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 737     tty-&gt;print(&quot;done with CodeBuffer:&quot;);
 738     ((CodeBuffer*)this)-&gt;print();
 739   }
 740 #endif //PRODUCT
 741 
 742   CodeBuffer dest(dest_blob);
 743   assert(dest_blob-&gt;content_size() &gt;= total_content_size(), &quot;good sizing&quot;);
 744   this-&gt;compute_final_layout(&amp;dest);
 745 
 746   // Set beginning of constant table before relocating.
 747   dest_blob-&gt;set_ctable_begin(dest.consts()-&gt;start());
 748 
 749   relocate_code_to(&amp;dest);
 750 
 751   // transfer strings and comments from buffer to blob
 752   dest_blob-&gt;set_strings(_code_strings);
 753 
 754   // Done moving code bytes; were they the right size?
 755   assert((int)align_up(dest.total_content_size(), oopSize) == dest_blob-&gt;content_size(), &quot;sanity&quot;);
 756 
 757   // Flush generated code
 758   ICache::invalidate_range(dest_blob-&gt;code_begin(), dest_blob-&gt;code_size());
 759 }
 760 
 761 // Move all my code into another code buffer.  Consult applicable
 762 // relocs to repair embedded addresses.  The layout in the destination
 763 // CodeBuffer is different to the source CodeBuffer: the destination
 764 // CodeBuffer gets the final layout (consts, insts, stubs in order of
 765 // ascending address).
 766 void CodeBuffer::relocate_code_to(CodeBuffer* dest) const {
 767   address dest_end = dest-&gt;_total_start + dest-&gt;_total_size;
 768   address dest_filled = NULL;
 769   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 770     // pull code out of each section
 771     const CodeSection* cs = code_section(n);
 772     if (cs-&gt;is_empty())  continue;  // skip trivial section
 773     CodeSection* dest_cs = dest-&gt;code_section(n);
 774     assert(cs-&gt;size() == dest_cs-&gt;size(), &quot;sanity&quot;);
 775     csize_t usize = dest_cs-&gt;size();
 776     csize_t wsize = align_up(usize, HeapWordSize);
 777     assert(dest_cs-&gt;start() + wsize &lt;= dest_end, &quot;no overflow&quot;);
 778     // Copy the code as aligned machine words.
 779     // This may also include an uninitialized partial word at the end.
 780     Copy::disjoint_words((HeapWord*)cs-&gt;start(),
 781                          (HeapWord*)dest_cs-&gt;start(),
 782                          wsize / HeapWordSize);
 783 
 784     if (dest-&gt;blob() == NULL) {
 785       // Destination is a final resting place, not just another buffer.
 786       // Normalize uninitialized bytes in the final padding.
 787       Copy::fill_to_bytes(dest_cs-&gt;end(), dest_cs-&gt;remaining(),
 788                           Assembler::code_fill_byte());
 789     }
 790     // Keep track of the highest filled address
 791     dest_filled = MAX2(dest_filled, dest_cs-&gt;end() + dest_cs-&gt;remaining());
 792 
 793     assert(cs-&gt;locs_start() != (relocInfo*)badAddress,
 794            &quot;this section carries no reloc storage, but reloc was attempted&quot;);
 795 
 796     // Make the new code copy use the old copy&#39;s relocations:
 797     dest_cs-&gt;initialize_locs_from(cs);
 798   }
 799 
 800   // Do relocation after all sections are copied.
 801   // This is necessary if the code uses constants in stubs, which are
 802   // relocated when the corresponding instruction in the code (e.g., a
 803   // call) is relocated. Stubs are placed behind the main code
 804   // section, so that section has to be copied before relocating.
 805   for (int n = (int) SECT_FIRST; n &lt; (int)SECT_LIMIT; n++) {
 806     // pull code out of each section
 807     const CodeSection* cs = code_section(n);
 808     if (cs-&gt;is_empty()) continue;  // skip trivial section
 809     CodeSection* dest_cs = dest-&gt;code_section(n);
 810     { // Repair the pc relative information in the code after the move
 811       RelocIterator iter(dest_cs);
 812       while (iter.next()) {
 813         iter.reloc()-&gt;fix_relocation_after_move(this, dest);
 814       }
 815     }
 816   }
 817 
 818   if (dest-&gt;blob() == NULL &amp;&amp; dest_filled != NULL) {
 819     // Destination is a final resting place, not just another buffer.
 820     // Normalize uninitialized bytes in the final padding.
 821     Copy::fill_to_bytes(dest_filled, dest_end - dest_filled,
 822                         Assembler::code_fill_byte());
 823 
 824   }
 825 }
 826 
 827 csize_t CodeBuffer::figure_expanded_capacities(CodeSection* which_cs,
 828                                                csize_t amount,
 829                                                csize_t* new_capacity) {
 830   csize_t new_total_cap = 0;
 831 
 832   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 833     const CodeSection* sect = code_section(n);
 834 
 835     if (!sect-&gt;is_empty()) {
 836       // Compute initial padding; assign it to the previous section,
 837       // even if it&#39;s empty (e.g. consts section can be empty).
 838       // Cf. compute_final_layout
 839       csize_t padding = sect-&gt;align_at_start(new_total_cap) - new_total_cap;
 840       if (padding != 0) {
 841         new_total_cap += padding;
 842         assert(n - 1 &gt;= SECT_FIRST, &quot;sanity&quot;);
 843         new_capacity[n - 1] += padding;
 844       }
 845     }
 846 
 847     csize_t exp = sect-&gt;size();  // 100% increase
 848     if ((uint)exp &lt; 4*K)  exp = 4*K;       // minimum initial increase
 849     if (sect == which_cs) {
 850       if (exp &lt; amount)  exp = amount;
 851       if (StressCodeBuffers)  exp = amount;  // expand only slightly
 852     } else if (n == SECT_INSTS) {
 853       // scale down inst increases to a more modest 25%
 854       exp = 4*K + ((exp - 4*K) &gt;&gt; 2);
 855       if (StressCodeBuffers)  exp = amount / 2;  // expand only slightly
 856     } else if (sect-&gt;is_empty()) {
 857       // do not grow an empty secondary section
 858       exp = 0;
 859     }
 860     // Allow for inter-section slop:
 861     exp += CodeSection::end_slop();
 862     csize_t new_cap = sect-&gt;size() + exp;
 863     if (new_cap &lt; sect-&gt;capacity()) {
 864       // No need to expand after all.
 865       new_cap = sect-&gt;capacity();
 866     }
 867     new_capacity[n] = new_cap;
 868     new_total_cap += new_cap;
 869   }
 870 
 871   return new_total_cap;
 872 }
 873 
 874 void CodeBuffer::expand(CodeSection* which_cs, csize_t amount) {
 875 #ifndef PRODUCT
 876   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 877     tty-&gt;print(&quot;expanding CodeBuffer:&quot;);
 878     this-&gt;print();
 879   }
 880 
 881   if (StressCodeBuffers &amp;&amp; blob() != NULL) {
 882     static int expand_count = 0;
 883     if (expand_count &gt;= 0)  expand_count += 1;
 884     if (expand_count &gt; 100 &amp;&amp; is_power_of_2(expand_count)) {
 885       tty-&gt;print_cr(&quot;StressCodeBuffers: have expanded %d times&quot;, expand_count);
 886       // simulate an occasional allocation failure:
 887       free_blob();
 888     }
 889   }
 890 #endif //PRODUCT
 891 
 892   // Resizing must be allowed
 893   {
 894     if (blob() == NULL)  return;  // caller must check for blob == NULL
 895     for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 896       guarantee(!code_section(n)-&gt;is_frozen(), &quot;resizing not allowed when frozen&quot;);
 897     }
 898   }
 899 
 900   // Figure new capacity for each section.
 901   csize_t new_capacity[SECT_LIMIT];
 902   memset(new_capacity, 0, sizeof(csize_t) * SECT_LIMIT);
 903   csize_t new_total_cap
 904     = figure_expanded_capacities(which_cs, amount, new_capacity);
 905 
 906   // Create a new (temporary) code buffer to hold all the new data
 907   CodeBuffer cb(name(), new_total_cap, 0);
 908   if (cb.blob() == NULL) {
 909     // Failed to allocate in code cache.
 910     free_blob();
 911     return;
 912   }
 913 
 914   // Create an old code buffer to remember which addresses used to go where.
 915   // This will be useful when we do final assembly into the code cache,
 916   // because we will need to know how to warp any internal address that
 917   // has been created at any time in this CodeBuffer&#39;s past.
 918   CodeBuffer* bxp = new CodeBuffer(_total_start, _total_size);
 919   bxp-&gt;take_over_code_from(this);  // remember the old undersized blob
 920   DEBUG_ONLY(this-&gt;_blob = NULL);  // silence a later assert
 921   bxp-&gt;_before_expand = this-&gt;_before_expand;
 922   this-&gt;_before_expand = bxp;
 923 
 924   // Give each section its required (expanded) capacity.
 925   for (int n = (int)SECT_LIMIT-1; n &gt;= SECT_FIRST; n--) {
 926     CodeSection* cb_sect   = cb.code_section(n);
 927     CodeSection* this_sect = code_section(n);
 928     if (new_capacity[n] == 0)  continue;  // already nulled out
 929     if (n != SECT_INSTS) {
 930       cb.initialize_section_size(cb_sect, new_capacity[n]);
 931     }
 932     assert(cb_sect-&gt;capacity() &gt;= new_capacity[n], &quot;big enough&quot;);
 933     address cb_start = cb_sect-&gt;start();
 934     cb_sect-&gt;set_end(cb_start + this_sect-&gt;size());
 935     if (this_sect-&gt;mark() == NULL) {
 936       cb_sect-&gt;clear_mark();
 937     } else {
 938       cb_sect-&gt;set_mark(cb_start + this_sect-&gt;mark_off());
 939     }
 940   }
 941 
 942   // Needs to be initialized when calling fix_relocation_after_move.
 943   cb.blob()-&gt;set_ctable_begin(cb.consts()-&gt;start());
 944 
 945   // Move all the code and relocations to the new blob:
 946   relocate_code_to(&amp;cb);
 947 
 948   // Copy the temporary code buffer into the current code buffer.
 949   // Basically, do {*this = cb}, except for some control information.
 950   this-&gt;take_over_code_from(&amp;cb);
 951   cb.set_blob(NULL);
 952 
 953   // Zap the old code buffer contents, to avoid mistakenly using them.
 954   debug_only(Copy::fill_to_bytes(bxp-&gt;_total_start, bxp-&gt;_total_size,
 955                                  badCodeHeapFreeVal));
 956 
 957   _decode_begin = NULL;  // sanity
 958 
 959   // Make certain that the new sections are all snugly inside the new blob.
 960   verify_section_allocation();
 961 
 962 #ifndef PRODUCT
 963   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 964     tty-&gt;print(&quot;expanded CodeBuffer:&quot;);
 965     this-&gt;print();
 966   }
 967 #endif //PRODUCT
 968 }
 969 
 970 void CodeBuffer::take_over_code_from(CodeBuffer* cb) {
 971   // Must already have disposed of the old blob somehow.
 972   assert(blob() == NULL, &quot;must be empty&quot;);
 973   // Take the new blob away from cb.
 974   set_blob(cb-&gt;blob());
 975   // Take over all the section pointers.
 976   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 977     CodeSection* cb_sect   = cb-&gt;code_section(n);
 978     CodeSection* this_sect = code_section(n);
 979     this_sect-&gt;take_over_code_from(cb_sect);
 980   }
 981   _overflow_arena = cb-&gt;_overflow_arena;
 982   // Make sure the old cb won&#39;t try to use it or free it.
 983   DEBUG_ONLY(cb-&gt;_blob = (BufferBlob*)badAddress);
 984 }
 985 
 986 void CodeBuffer::verify_section_allocation() {
 987   address tstart = _total_start;
 988   if (tstart == badAddress)  return;  // smashed by set_blob(NULL)
 989   address tend   = tstart + _total_size;
 990   if (_blob != NULL) {
 991 
 992     guarantee(tstart &gt;= _blob-&gt;content_begin(), &quot;sanity&quot;);
 993     guarantee(tend   &lt;= _blob-&gt;content_end(),   &quot;sanity&quot;);
 994   }
 995   // Verify disjointness.
 996   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 997     CodeSection* sect = code_section(n);
 998     if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
 999     guarantee((intptr_t)sect-&gt;start() % sect-&gt;alignment() == 0
1000            || sect-&gt;is_empty() || _blob == NULL,
1001            &quot;start is aligned&quot;);
1002     for (int m = (int) SECT_FIRST; m &lt; (int) SECT_LIMIT; m++) {
1003       CodeSection* other = code_section(m);
1004       if (!other-&gt;is_allocated() || other == sect)  continue;
1005       guarantee(!other-&gt;contains(sect-&gt;start()    ), &quot;sanity&quot;);
1006       // limit is an exclusive address and can be the start of another
1007       // section.
1008       guarantee(!other-&gt;contains(sect-&gt;limit() - 1), &quot;sanity&quot;);
1009     }
1010     guarantee(sect-&gt;end() &lt;= tend, &quot;sanity&quot;);
1011     guarantee(sect-&gt;end() &lt;= sect-&gt;limit(), &quot;sanity&quot;);
1012   }
1013 }
1014 
1015 void CodeBuffer::log_section_sizes(const char* name) {
1016   if (xtty != NULL) {
1017     ttyLocker ttyl;
1018     // log info about buffer usage
1019     xtty-&gt;print_cr(&quot;&lt;blob name=&#39;%s&#39; size=&#39;%d&#39;&gt;&quot;, name, _total_size);
1020     for (int n = (int) CodeBuffer::SECT_FIRST; n &lt; (int) CodeBuffer::SECT_LIMIT; n++) {
1021       CodeSection* sect = code_section(n);
1022       if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
1023       xtty-&gt;print_cr(&quot;&lt;sect index=&#39;%d&#39; size=&#39;&quot; SIZE_FORMAT &quot;&#39; free=&#39;&quot; SIZE_FORMAT &quot;&#39;/&gt;&quot;,
1024                      n, sect-&gt;limit() - sect-&gt;start(), sect-&gt;limit() - sect-&gt;end());
1025     }
1026     xtty-&gt;print_cr(&quot;&lt;/blob&gt;&quot;);
1027   }
1028 }
1029 
1030 #ifndef PRODUCT
1031 
1032 void CodeSection::decode() {
1033   Disassembler::decode(start(), end());
1034 }
1035 
1036 void CodeBuffer::block_comment(intptr_t offset, const char * comment) {
1037   _code_strings.add_comment(offset, comment);
1038 }
1039 
1040 const char* CodeBuffer::code_string(const char* str) {
1041   return _code_strings.add_string(str);
1042 }
1043 
1044 class CodeString: public CHeapObj&lt;mtCode&gt; {
1045  private:
1046   friend class CodeStrings;
1047   const char * _string;
1048   CodeString*  _next;
1049   intptr_t     _offset;
1050 
1051   ~CodeString() {
1052     assert(_next == NULL, &quot;wrong interface for freeing list&quot;);
1053     os::free((void*)_string);
1054   }
1055 
1056   bool is_comment() const { return _offset &gt;= 0; }
1057 
1058  public:
1059   CodeString(const char * string, intptr_t offset = -1)
1060     : _next(NULL), _offset(offset) {
1061     _string = os::strdup(string, mtCode);
1062   }
1063 
1064   const char * string() const { return _string; }
1065   intptr_t     offset() const { assert(_offset &gt;= 0, &quot;offset for non comment?&quot;); return _offset;  }
1066   CodeString* next()    const { return _next; }
1067 
1068   void set_next(CodeString* next) { _next = next; }
1069 
1070   CodeString* first_comment() {
1071     if (is_comment()) {
1072       return this;
1073     } else {
1074       return next_comment();
1075     }
1076   }
1077   CodeString* next_comment() const {
1078     CodeString* s = _next;
1079     while (s != NULL &amp;&amp; !s-&gt;is_comment()) {
1080       s = s-&gt;_next;
1081     }
1082     return s;
1083   }
1084 };
1085 
1086 CodeString* CodeStrings::find(intptr_t offset) const {
1087   CodeString* a = _strings-&gt;first_comment();
1088   while (a != NULL &amp;&amp; a-&gt;offset() != offset) {
1089     a = a-&gt;next_comment();
1090   }
1091   return a;
1092 }
1093 
1094 // Convenience for add_comment.
1095 CodeString* CodeStrings::find_last(intptr_t offset) const {
1096   CodeString* a = find(offset);
1097   if (a != NULL) {
1098     CodeString* c = NULL;
1099     while (((c = a-&gt;next_comment()) != NULL) &amp;&amp; (c-&gt;offset() == offset)) {
1100       a = c;
1101     }
1102   }
1103   return a;
1104 }
1105 
1106 void CodeStrings::add_comment(intptr_t offset, const char * comment) {
1107   check_valid();
1108   CodeString* c      = new CodeString(comment, offset);
1109   CodeString* inspos = (_strings == NULL) ? NULL : find_last(offset);
1110 
1111   if (inspos) {
1112     // insert after already existing comments with same offset
1113     c-&gt;set_next(inspos-&gt;next());
1114     inspos-&gt;set_next(c);
1115   } else {
1116     // no comments with such offset, yet. Insert before anything else.
1117     c-&gt;set_next(_strings);
1118     _strings = c;
1119   }
1120 }
1121 
1122 void CodeStrings::assign(CodeStrings&amp; other) {
1123   other.check_valid();
1124   assert(is_null(), &quot;Cannot assign onto non-empty CodeStrings&quot;);
1125   _strings = other._strings;
1126 #ifdef ASSERT
1127   _defunct = false;
1128 #endif
1129   other.set_null_and_invalidate();
1130 }
1131 
1132 // Deep copy of CodeStrings for consistent memory management.
1133 // Only used for actual disassembly so this is cheaper than reference counting
1134 // for the &quot;normal&quot; fastdebug case.
1135 void CodeStrings::copy(CodeStrings&amp; other) {
1136   other.check_valid();
1137   check_valid();
1138   assert(is_null(), &quot;Cannot copy onto non-empty CodeStrings&quot;);
1139   CodeString* n = other._strings;
1140   CodeString** ps = &amp;_strings;
1141   while (n != NULL) {
1142     *ps = new CodeString(n-&gt;string(),n-&gt;offset());
1143     ps = &amp;((*ps)-&gt;_next);
1144     n = n-&gt;next();
1145   }
1146 }
1147 
1148 const char* CodeStrings::_prefix = &quot; ;; &quot;;  // default: can be changed via set_prefix
1149 
1150 void CodeStrings::print_block_comment(outputStream* stream, intptr_t offset) const {
1151     check_valid();
1152     if (_strings != NULL) {
1153     CodeString* c = find(offset);
1154     while (c &amp;&amp; c-&gt;offset() == offset) {
1155       stream-&gt;bol();
1156       stream-&gt;print(&quot;%s&quot;, _prefix);
1157       // Don&#39;t interpret as format strings since it could contain %
1158       stream-&gt;print_raw_cr(c-&gt;string());
1159       c = c-&gt;next_comment();
1160     }
1161   }
1162 }
1163 
1164 // Also sets isNull()
1165 void CodeStrings::free() {
1166   CodeString* n = _strings;
1167   while (n) {
1168     // unlink the node from the list saving a pointer to the next
1169     CodeString* p = n-&gt;next();
1170     n-&gt;set_next(NULL);
1171     delete n;
1172     n = p;
1173   }
1174   set_null_and_invalidate();
1175 }
1176 
1177 const char* CodeStrings::add_string(const char * string) {
1178   check_valid();
1179   CodeString* s = new CodeString(string);
1180   s-&gt;set_next(_strings);
1181   _strings = s;
1182   assert(s-&gt;string() != NULL, &quot;should have a string&quot;);
1183   return s-&gt;string();
1184 }
1185 
1186 void CodeBuffer::decode() {
1187   ttyLocker ttyl;
1188   Disassembler::decode(decode_begin(), insts_end());
1189   _decode_begin = insts_end();
1190 }
1191 
1192 void CodeSection::print(const char* name) {
1193   csize_t locs_size = locs_end() - locs_start();
1194   tty-&gt;print_cr(&quot; %7s.code = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d)%s&quot;,
1195                 name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity(),
1196                 is_frozen()? &quot; [frozen]&quot;: &quot;&quot;);
1197   tty-&gt;print_cr(&quot; %7s.locs = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d) point=%d&quot;,
1198                 name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());
1199   if (PrintRelocations) {
1200     RelocIterator iter(this);
1201     iter.print();
1202   }
1203 }
1204 
1205 void CodeBuffer::print() {
1206   if (this == NULL) {
1207     tty-&gt;print_cr(&quot;NULL CodeBuffer pointer&quot;);
1208     return;
1209   }
1210 
1211   tty-&gt;print_cr(&quot;CodeBuffer:&quot;);
1212   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
1213     // print each section
1214     CodeSection* cs = code_section(n);
1215     cs-&gt;print(code_section_name(n));
1216   }
1217 }
1218 
1219 #endif // PRODUCT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcNotifier.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapDumper.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/heapDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcVMOperations.hpp&quot;
<span class="line-added">+ #include &quot;jfr/jfrEvents.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,27 ***</span>
  // Supports I/O operations on a dump file
  
  class DumpWriter : public StackObj {
   private:
    enum {
<span class="line-modified">!     io_buffer_size  = 8*M</span>
    };
  
    int _fd;              // file descriptor (-1 if dump file not open)
    julong _bytes_written; // number of byte written to dump file
  
    char* _buffer;    // internal buffer
    size_t _size;
    size_t _pos;
  
<span class="line-modified">!   jlong _dump_start;</span>
  
    char* _error;   // error message when I/O fails
  
    void set_file_descriptor(int fd)              { _fd = fd; }
    int file_descriptor() const                   { return _fd; }
  
    char* buffer() const                          { return _buffer; }
    size_t buffer_size() const                    { return _size; }
    size_t position() const                       { return _pos; }
    void set_position(size_t pos)                 { _pos = pos; }
  
<span class="line-new-header">--- 380,35 ---</span>
  // Supports I/O operations on a dump file
  
  class DumpWriter : public StackObj {
   private:
    enum {
<span class="line-modified">!     io_buffer_max_size = 8*M,</span>
<span class="line-added">+     io_buffer_min_size = 64*K,</span>
<span class="line-added">+     dump_segment_header_size = 9</span>
    };
  
    int _fd;              // file descriptor (-1 if dump file not open)
    julong _bytes_written; // number of byte written to dump file
  
    char* _buffer;    // internal buffer
    size_t _size;
    size_t _pos;
  
<span class="line-modified">!   bool _in_dump_segment; // Are we currently in a dump segment?</span>
<span class="line-added">+   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?</span>
<span class="line-added">+   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.</span>
<span class="line-added">+   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().</span>
  
    char* _error;   // error message when I/O fails
  
    void set_file_descriptor(int fd)              { _fd = fd; }
    int file_descriptor() const                   { return _fd; }
  
<span class="line-added">+   bool is_open() const                          { return file_descriptor() &gt;= 0; }</span>
<span class="line-added">+   void flush();</span>
<span class="line-added">+ </span>
    char* buffer() const                          { return _buffer; }
    size_t buffer_size() const                    { return _size; }
    size_t position() const                       { return _pos; }
    void set_position(size_t pos)                 { _pos = pos; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,74 ***</span>
   public:
    DumpWriter(const char* path);
    ~DumpWriter();
  
    void close();
<span class="line-removed">-   bool is_open() const                  { return file_descriptor() &gt;= 0; }</span>
<span class="line-removed">-   void flush();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   jlong dump_start() const                      { return _dump_start; }</span>
<span class="line-removed">-   void set_dump_start(jlong pos);</span>
<span class="line-removed">-   julong current_record_length();</span>
  
    // total number of bytes written to the disk
    julong bytes_written() const          { return _bytes_written; }
  
<span class="line-removed">-   // adjust the number of bytes written to disk (used to keep the count</span>
<span class="line-removed">-   // of the number of bytes written in case of rewrites)</span>
<span class="line-removed">-   void adjust_bytes_written(jlong n)    { _bytes_written += n; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // number of (buffered) bytes as yet unwritten to the dump file</span>
<span class="line-removed">-   size_t bytes_unwritten() const        { return position(); }</span>
<span class="line-removed">- </span>
    char* error() const                   { return _error; }
  
<span class="line-removed">-   jlong current_offset();</span>
<span class="line-removed">-   void seek_to_offset(jlong pos);</span>
<span class="line-removed">- </span>
    // writer functions
    void write_raw(void* s, size_t len);
    void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
    void write_u2(u2 x);
    void write_u4(u4 x);
    void write_u8(u8 x);
    void write_objectID(oop o);
    void write_symbolID(Symbol* o);
    void write_classID(Klass* k);
    void write_id(u4 x);
  };
  
<span class="line-modified">! DumpWriter::DumpWriter(const char* path) {</span>
    // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
    // sufficient memory then reduce size until we can allocate something.
<span class="line-modified">!   _size = io_buffer_size;</span>
    do {
      _buffer = (char*)os::malloc(_size, mtInternal);
      if (_buffer == NULL) {
        _size = _size &gt;&gt; 1;
      }
<span class="line-modified">!   } while (_buffer == NULL &amp;&amp; _size &gt; 0);</span>
<span class="line-modified">!   assert((_size &gt; 0 &amp;&amp; _buffer != NULL) || (_size == 0 &amp;&amp; _buffer == NULL), &quot;sanity check&quot;);</span>
<span class="line-modified">!   _pos = 0;</span>
<span class="line-modified">!   _error = NULL;</span>
<span class="line-modified">!   _bytes_written = 0L;</span>
<span class="line-modified">!   _dump_start = (jlong)-1;</span>
<span class="line-modified">!   _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // if the open failed we record the error</span>
<span class="line-modified">!   if (_fd &lt; 0) {</span>
<span class="line-modified">!     _error = (char*)os::strdup(os::strerror(errno));</span>
    }
  }
  
  DumpWriter::~DumpWriter() {
<span class="line-modified">!   // flush and close dump file</span>
<span class="line-modified">!   if (is_open()) {</span>
<span class="line-modified">!     close();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (_buffer != NULL) os::free(_buffer);</span>
<span class="line-removed">-   if (_error != NULL) os::free(_error);</span>
  }
  
  // closes dump file (if open)
  void DumpWriter::close() {
    // flush and close dump file
<span class="line-new-header">--- 420,63 ---</span>
   public:
    DumpWriter(const char* path);
    ~DumpWriter();
  
    void close();
  
    // total number of bytes written to the disk
    julong bytes_written() const          { return _bytes_written; }
  
    char* error() const                   { return _error; }
  
    // writer functions
    void write_raw(void* s, size_t len);
    void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
    void write_u2(u2 x);
    void write_u4(u4 x);
    void write_u8(u8 x);
    void write_objectID(oop o);
    void write_symbolID(Symbol* o);
    void write_classID(Klass* k);
    void write_id(u4 x);
<span class="line-added">+ </span>
<span class="line-added">+   // Start a new sub-record. Starts a new heap dump segment if needed.</span>
<span class="line-added">+   void start_sub_record(u1 tag, u4 len);</span>
<span class="line-added">+   // Ends the current sub-record.</span>
<span class="line-added">+   void end_sub_record();</span>
<span class="line-added">+   // Finishes the current dump segment if not already finished.</span>
<span class="line-added">+   void finish_dump_segment();</span>
  };
  
<span class="line-modified">! DumpWriter::DumpWriter(const char* path) : _fd(-1), _bytes_written(0), _pos(0),</span>
<span class="line-added">+                                            _in_dump_segment(false), _error(NULL) {</span>
    // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
    // sufficient memory then reduce size until we can allocate something.
<span class="line-modified">!   _size = io_buffer_max_size;</span>
    do {
      _buffer = (char*)os::malloc(_size, mtInternal);
      if (_buffer == NULL) {
        _size = _size &gt;&gt; 1;
      }
<span class="line-modified">!   } while (_buffer == NULL &amp;&amp; _size &gt;= io_buffer_min_size);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (_buffer == NULL) {</span>
<span class="line-modified">!     set_error(&quot;Could not allocate buffer memory for heap dump&quot;);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // if the open failed we record the error</span>
<span class="line-modified">!     if (_fd &lt; 0) {</span>
<span class="line-modified">!       set_error(os::strerror(errno));</span>
<span class="line-modified">!     }</span>
    }
  }
  
  DumpWriter::~DumpWriter() {
<span class="line-modified">!   close();</span>
<span class="line-modified">!   os::free(_buffer);</span>
<span class="line-modified">!   os::free(_error);</span>
  }
  
  // closes dump file (if open)
  void DumpWriter::close() {
    // flush and close dump file
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,33 ***</span>
      os::close(file_descriptor());
      set_file_descriptor(-1);
    }
  }
  
<span class="line-removed">- // sets the dump starting position</span>
<span class="line-removed">- void DumpWriter::set_dump_start(jlong pos) {</span>
<span class="line-removed">-   _dump_start = pos;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- julong DumpWriter::current_record_length() {</span>
<span class="line-removed">-   if (is_open()) {</span>
<span class="line-removed">-     // calculate the size of the dump record</span>
<span class="line-removed">-     julong dump_end = bytes_written() + bytes_unwritten();</span>
<span class="line-removed">-     assert(dump_end == (size_t)current_offset(), &quot;checking&quot;);</span>
<span class="line-removed">-     julong dump_len = dump_end - dump_start() - 4;</span>
<span class="line-removed">-     return dump_len;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // write directly to the file
  void DumpWriter::write_internal(void* s, size_t len) {
    if (is_open()) {
      const char* pos = (char*)s;
      ssize_t n = 0;
      while (len &gt; 0) {
<span class="line-modified">!       uint tmp = (uint)MIN2(len, (size_t)UINT_MAX);</span>
        n = os::write(file_descriptor(), pos, tmp);
  
        if (n &lt; 0) {
          // EINTR cannot happen here, os::write will take care of that
          set_error(os::strerror(errno));
<span class="line-new-header">--- 485,17 ---</span>
      os::close(file_descriptor());
      set_file_descriptor(-1);
    }
  }
  
  // write directly to the file
  void DumpWriter::write_internal(void* s, size_t len) {
    if (is_open()) {
      const char* pos = (char*)s;
      ssize_t n = 0;
      while (len &gt; 0) {
<span class="line-modified">!       uint tmp = (uint)MIN2(len, (size_t)INT_MAX);</span>
        n = os::write(file_descriptor(), pos, tmp);
  
        if (n &lt; 0) {
          // EINTR cannot happen here, os::write will take care of that
          set_error(os::strerror(errno));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,57 ***</span>
    }
  }
  
  // write raw bytes
  void DumpWriter::write_raw(void* s, size_t len) {
<span class="line-modified">!   if (is_open()) {</span>
<span class="line-modified">!     // flush buffer to make room</span>
<span class="line-removed">-     if ((position() + len) &gt;= buffer_size()) {</span>
<span class="line-removed">-       flush();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // buffer not available or too big to buffer it</span>
<span class="line-modified">!     if ((buffer() == NULL) || (len &gt;= buffer_size())) {</span>
        write_internal(s, len);
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       // Should optimize this for u1/u2/u4/u8 sizes.</span>
<span class="line-removed">-       memcpy(buffer() + position(), s, len);</span>
<span class="line-removed">-       set_position(position() + len);</span>
      }
    }
  }
  
  // flush any buffered bytes to the file
  void DumpWriter::flush() {
<span class="line-modified">!   if (is_open() &amp;&amp; position() &gt; 0) {</span>
<span class="line-modified">!     write_internal(buffer(), position());</span>
<span class="line-removed">-     set_position(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- jlong DumpWriter::current_offset() {</span>
<span class="line-removed">-   if (is_open()) {</span>
<span class="line-removed">-     // the offset is the file offset plus whatever we have buffered</span>
<span class="line-removed">-     jlong offset = os::current_file_offset(file_descriptor());</span>
<span class="line-removed">-     assert(offset &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed">-     return offset + position();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return (jlong)-1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void DumpWriter::seek_to_offset(jlong off) {</span>
<span class="line-removed">-   assert(off &gt;= 0, &quot;bad offset&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // need to flush before seeking</span>
<span class="line-removed">-   flush();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // may be closed due to I/O error</span>
<span class="line-removed">-   if (is_open()) {</span>
<span class="line-removed">-     jlong n = os::seek_to_file_offset(file_descriptor(), off);</span>
<span class="line-removed">-     assert(n &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed">-   }</span>
  }
  
  void DumpWriter::write_u2(u2 x) {
    u2 v;
    Bytes::put_Java_u2((address)&amp;v, x);
<span class="line-new-header">--- 511,34 ---</span>
    }
  }
  
  // write raw bytes
  void DumpWriter::write_raw(void* s, size_t len) {
<span class="line-modified">!   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);</span>
<span class="line-modified">!   debug_only(_sub_record_left -= len);</span>
  
<span class="line-modified">!   // flush buffer to make room</span>
<span class="line-modified">!   if (len &gt; buffer_size() - position()) {</span>
<span class="line-added">+     assert(!_in_dump_segment || _is_huge_sub_record, &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
<span class="line-added">+     flush();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If larger than the buffer, just write it directly.</span>
<span class="line-added">+     if (len &gt; buffer_size()) {</span>
        write_internal(s, len);
<span class="line-modified">! </span>
<span class="line-modified">!       return;</span>
      }
    }
<span class="line-added">+ </span>
<span class="line-added">+   memcpy(buffer() + position(), s, len);</span>
<span class="line-added">+   set_position(position() + len);</span>
  }
  
  // flush any buffered bytes to the file
  void DumpWriter::flush() {
<span class="line-modified">!   write_internal(buffer(), position());</span>
<span class="line-modified">!   set_position(0);</span>
  }
  
  void DumpWriter::write_u2(u2 x) {
    u2 v;
    Bytes::put_Java_u2((address)&amp;v, x);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,11 ***</span>
    Bytes::put_Java_u8((address)&amp;v, x);
    write_raw((void*)&amp;v, 8);
  }
  
  void DumpWriter::write_objectID(oop o) {
<span class="line-modified">!   address a = (address)o;</span>
  #ifdef _LP64
    write_u8((u8)a);
  #else
    write_u4((u4)a);
  #endif
<span class="line-new-header">--- 556,11 ---</span>
    Bytes::put_Java_u8((address)&amp;v, x);
    write_raw((void*)&amp;v, 8);
  }
  
  void DumpWriter::write_objectID(oop o) {
<span class="line-modified">!   address a = cast_from_oop&lt;address&gt;(o);</span>
  #ifdef _LP64
    write_u8((u8)a);
  #else
    write_u4((u4)a);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,11 ***</span>
<span class="line-new-header">--- 586,62 ---</span>
  // We use java mirror as the class ID
  void DumpWriter::write_classID(Klass* k) {
    write_objectID(k-&gt;java_mirror());
  }
  
<span class="line-added">+ void DumpWriter::finish_dump_segment() {</span>
<span class="line-added">+   if (_in_dump_segment) {</span>
<span class="line-added">+     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);</span>
<span class="line-added">+     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last</span>
<span class="line-added">+     // (in which case the segment length was already set to the correct value initially).</span>
<span class="line-added">+     if (!_is_huge_sub_record) {</span>
<span class="line-added">+       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);</span>
<span class="line-added">+       Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     flush();</span>
<span class="line-added">+     _in_dump_segment = false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DumpWriter::start_sub_record(u1 tag, u4 len) {</span>
<span class="line-added">+   if (!_in_dump_segment) {</span>
<span class="line-added">+     if (position() &gt; 0) {</span>
<span class="line-added">+       flush();</span>
<span class="line-added">+       assert(position() == 0, &quot;Must be at the start&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-added">+     write_u4(0); // timestamp</span>
<span class="line-added">+     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,</span>
<span class="line-added">+     // this is already the correct length, since we don&#39;t add more sub-records.</span>
<span class="line-added">+     write_u4(len);</span>
<span class="line-added">+     _in_dump_segment = true;</span>
<span class="line-added">+     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;</span>
<span class="line-added">+   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {</span>
<span class="line-added">+     // This object will not fit in completely or the last sub-record was huge.</span>
<span class="line-added">+     // Finish the current segement and try again.</span>
<span class="line-added">+     finish_dump_segment();</span>
<span class="line-added">+     start_sub_record(tag, len);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   debug_only(_sub_record_left = len);</span>
<span class="line-added">+   debug_only(_sub_record_ended = false);</span>
<span class="line-added">+ </span>
<span class="line-added">+   write_u1(tag);</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ void DumpWriter::end_sub_record() {</span>
<span class="line-added">+   assert(_in_dump_segment, &quot;must be in dump segment&quot;);</span>
<span class="line-added">+   assert(_sub_record_left == 0, &quot;sub-record not written completely&quot;);</span>
<span class="line-added">+   assert(!_sub_record_ended, &quot;Must not have ended yet&quot;);</span>
<span class="line-added">+   debug_only(_sub_record_ended = true);</span>
<span class="line-added">+ }</span>
  
  // Support class with a collection of functions used when dumping the heap
  
  class DumperSupport : AllStatic {
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,24 ***</span>
<span class="line-new-header">--- 651,30 ---</span>
  
    // returns hprof tag for the given type signature
    static hprofTag sig2tag(Symbol* sig);
    // returns hprof tag for the given basic type
    static hprofTag type2tag(BasicType type);
<span class="line-added">+   // Returns the size of the data to write.</span>
<span class="line-added">+   static u4 sig2size(Symbol* sig);</span>
  
    // returns the size of the instance of the given class
    static u4 instance_size(Klass* k);
  
    // dump a jfloat
    static void dump_float(DumpWriter* writer, jfloat f);
    // dump a jdouble
    static void dump_double(DumpWriter* writer, jdouble d);
    // dumps the raw value of the given field
    static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
<span class="line-added">+   // returns the size of the static fields; also counts the static fields</span>
<span class="line-added">+   static u4 get_static_fields_size(InstanceKlass* ik, u2&amp; field_count);</span>
    // dumps static fields of the given class
    static void dump_static_fields(DumpWriter* writer, Klass* k);
    // dump the raw values of the instance fields of the given object
    static void dump_instance_fields(DumpWriter* writer, oop o);
<span class="line-added">+   // get the count of the instance fields for a given class</span>
<span class="line-added">+   static u2 get_instance_fields_count(InstanceKlass* ik);</span>
    // dumps the definition of the instance fields for a given class
    static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
    // creates HPROF_GC_INSTANCE_DUMP record for the given object
    static void dump_instance(DumpWriter* writer, oop o);
    // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,18 ***</span>
    static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
  
    // check if we need to truncate an array
    static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
  
<span class="line-removed">-   // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed">-   static void write_dump_header(DumpWriter* writer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // fixes up the length of the current dump record</span>
<span class="line-removed">-   static void write_current_dump_record_length(DumpWriter* writer);</span>
<span class="line-removed">- </span>
    // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
    static void end_of_dump(DumpWriter* writer);
  };
  
  // write a header of the given type
  void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
    writer-&gt;write_u1((u1)tag);
<span class="line-new-header">--- 692,22 ---</span>
    static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
  
    // check if we need to truncate an array
    static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
  
    // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
    static void end_of_dump(DumpWriter* writer);
<span class="line-added">+ </span>
<span class="line-added">+   static oop mask_dormant_archived_object(oop o) {</span>
<span class="line-added">+     if (o != NULL &amp;&amp; o-&gt;klass()-&gt;java_mirror() == NULL) {</span>
<span class="line-added">+       // Ignore this object since the corresponding java mirror is not loaded.</span>
<span class="line-added">+       // Might be a dormant archive object.</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       return o;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  };
  
  // write a header of the given type
  void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
    writer-&gt;write_u1((u1)tag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 724,10 ***</span>
<span class="line-new-header">--- 744,26 ---</span>
      case T_BOOLEAN  : return HPROF_BOOLEAN;
      default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
    }
  }
  
<span class="line-added">+ u4 DumperSupport::sig2size(Symbol* sig) {</span>
<span class="line-added">+   switch (sig-&gt;char_at(0)) {</span>
<span class="line-added">+     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">+     case JVM_SIGNATURE_ARRAY: return sizeof(address);</span>
<span class="line-added">+     case JVM_SIGNATURE_BOOLEAN:</span>
<span class="line-added">+     case JVM_SIGNATURE_BYTE: return 1;</span>
<span class="line-added">+     case JVM_SIGNATURE_SHORT:</span>
<span class="line-added">+     case JVM_SIGNATURE_CHAR: return 2;</span>
<span class="line-added">+     case JVM_SIGNATURE_INT:</span>
<span class="line-added">+     case JVM_SIGNATURE_FLOAT: return 4;</span>
<span class="line-added">+     case JVM_SIGNATURE_LONG:</span>
<span class="line-added">+     case JVM_SIGNATURE_DOUBLE: return 8;</span>
<span class="line-added">+     default: ShouldNotReachHere(); /* to shut up compiler */ return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // dump a jfloat
  void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
    if (g_isnan(f)) {
      writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,11 ***</span>
  // dumps the raw value of the given field
  void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
    switch (type) {
      case JVM_SIGNATURE_CLASS :
      case JVM_SIGNATURE_ARRAY : {
<span class="line-modified">!       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF&gt;(offset);</span>
        assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
        writer-&gt;write_objectID(o);
        break;
      }
      case JVM_SIGNATURE_BYTE : {
<span class="line-new-header">--- 794,18 ---</span>
  // dumps the raw value of the given field
  void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
    switch (type) {
      case JVM_SIGNATURE_CLASS :
      case JVM_SIGNATURE_ARRAY : {
<span class="line-modified">!       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;(offset);</span>
<span class="line-added">+       if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">+         ResourceMark rm;</span>
<span class="line-added">+         log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added">+                              p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">+                              p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       o = mask_dormant_archived_object(o);</span>
        assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
        writer-&gt;write_objectID(o);
        break;
      }
      case JVM_SIGNATURE_BYTE : {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 814,76 ***</span>
  
  // returns the size of the instance of the given class
  u4 DumperSupport::instance_size(Klass* k) {
    HandleMark hm;
    InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-removed">- </span>
    u4 size = 0;
  
    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
      if (!fld.access_flags().is_static()) {
<span class="line-modified">!       Symbol* sig = fld.signature();</span>
<span class="line-removed">-       switch (sig-&gt;char_at(0)) {</span>
<span class="line-removed">-         case JVM_SIGNATURE_CLASS   :</span>
<span class="line-removed">-         case JVM_SIGNATURE_ARRAY   : size += oopSize; break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         case JVM_SIGNATURE_BYTE    :</span>
<span class="line-removed">-         case JVM_SIGNATURE_BOOLEAN : size += 1; break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         case JVM_SIGNATURE_CHAR    :</span>
<span class="line-removed">-         case JVM_SIGNATURE_SHORT   : size += 2; break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         case JVM_SIGNATURE_INT     :</span>
<span class="line-removed">-         case JVM_SIGNATURE_FLOAT   : size += 4; break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         case JVM_SIGNATURE_LONG    :</span>
<span class="line-removed">-         case JVM_SIGNATURE_DOUBLE  : size += 8; break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         default : ShouldNotReachHere();</span>
<span class="line-removed">-       }</span>
      }
    }
    return size;
  }
  
<span class="line-modified">! // dumps static fields of the given class</span>
<span class="line-removed">- void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
    HandleMark hm;
<span class="line-modified">!   InstanceKlass* ik = InstanceKlass::cast(k);</span>
  
<span class="line-removed">-   // pass 1 - count the static fields</span>
<span class="line-removed">-   u2 field_count = 0;</span>
    for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<span class="line-modified">!     if (fldc.access_flags().is_static()) field_count++;</span>
    }
  
    // Add in resolved_references which is referenced by the cpCache
    // The resolved_references is an array per InstanceKlass holding the
    // strings and other oops resolved from the constant pool.
    oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
    if (resolved_references != NULL) {
      field_count++;
  
      // Add in the resolved_references of the used previous versions of the class
      // in the case of RedefineClasses
      InstanceKlass* prev = ik-&gt;previous_versions();
      while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
        field_count++;
        prev = prev-&gt;previous_versions();
      }
    }
  
    // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
    // arrays.
    oop init_lock = ik-&gt;init_lock();
    if (init_lock != NULL) {
      field_count++;
    }
  
<span class="line-modified">!   writer-&gt;write_u2(field_count);</span>
  
<span class="line-modified">!   // pass 2 - dump the field descriptors and raw values</span>
    for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
      if (fld.access_flags().is_static()) {
        Symbol* sig = fld.signature();
  
        writer-&gt;write_symbolID(fld.name());   // name
<span class="line-new-header">--- 857,68 ---</span>
  
  // returns the size of the instance of the given class
  u4 DumperSupport::instance_size(Klass* k) {
    HandleMark hm;
    InstanceKlass* ik = InstanceKlass::cast(k);
    u4 size = 0;
  
    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
      if (!fld.access_flags().is_static()) {
<span class="line-modified">!       size += sig2size(fld.signature());</span>
      }
    }
    return size;
  }
  
<span class="line-modified">! u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2&amp; field_count) {</span>
    HandleMark hm;
<span class="line-modified">!   field_count = 0;</span>
<span class="line-added">+   u4 size = 0;</span>
  
    for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<span class="line-modified">!     if (fldc.access_flags().is_static()) {</span>
<span class="line-added">+       field_count++;</span>
<span class="line-added">+       size += sig2size(fldc.signature());</span>
<span class="line-added">+     }</span>
    }
  
    // Add in resolved_references which is referenced by the cpCache
    // The resolved_references is an array per InstanceKlass holding the
    // strings and other oops resolved from the constant pool.
    oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
    if (resolved_references != NULL) {
      field_count++;
<span class="line-added">+     size += sizeof(address);</span>
  
      // Add in the resolved_references of the used previous versions of the class
      // in the case of RedefineClasses
      InstanceKlass* prev = ik-&gt;previous_versions();
      while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
        field_count++;
<span class="line-added">+       size += sizeof(address);</span>
        prev = prev-&gt;previous_versions();
      }
    }
  
    // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
    // arrays.
    oop init_lock = ik-&gt;init_lock();
    if (init_lock != NULL) {
      field_count++;
<span class="line-added">+     size += sizeof(address);</span>
    }
  
<span class="line-modified">!   // We write the value itself plus a name and a one byte type tag per field.</span>
<span class="line-added">+   return size + field_count * (sizeof(address) + 1);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! // dumps static fields of the given class</span>
<span class="line-added">+ void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
<span class="line-added">+   HandleMark hm;</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // dump the field descriptors and raw values</span>
    for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
      if (fld.access_flags().is_static()) {
        Symbol* sig = fld.signature();
  
        writer-&gt;write_symbolID(fld.name());   // name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,10 ***</span>
<span class="line-new-header">--- 928,11 ---</span>
        dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
      }
    }
  
    // Add resolved_references for each class that has them
<span class="line-added">+   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();</span>
    if (resolved_references != NULL) {
      writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
      writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
      writer-&gt;write_objectID(resolved_references);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 909,10 ***</span>
<span class="line-new-header">--- 945,11 ---</span>
        prev = prev-&gt;previous_versions();
      }
    }
  
    // Add init lock to the end if the class is not yet initialized
<span class="line-added">+   oop init_lock = ik-&gt;init_lock();</span>
    if (init_lock != NULL) {
      writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
      writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
      writer-&gt;write_objectID(init_lock);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 930,23 ***</span>
      }
    }
  }
  
  // dumps the definition of the instance fields for a given class
<span class="line-modified">! void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
    HandleMark hm;
<span class="line-removed">-   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // pass 1 - count the instance fields</span>
    u2 field_count = 0;
    for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
      if (!fldc.access_flags().is_static()) field_count++;
    }
  
<span class="line-modified">!   writer-&gt;write_u2(field_count);</span>
  
<span class="line-modified">!   // pass 2 - dump the field descriptors</span>
    for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
      if (!fld.access_flags().is_static()) {
        Symbol* sig = fld.signature();
  
        writer-&gt;write_symbolID(fld.name());   // name
<span class="line-new-header">--- 967,27 ---</span>
      }
    }
  }
  
  // dumps the definition of the instance fields for a given class
<span class="line-modified">! u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {</span>
    HandleMark hm;
    u2 field_count = 0;
<span class="line-added">+ </span>
    for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
      if (!fldc.access_flags().is_static()) field_count++;
    }
  
<span class="line-modified">!   return field_count;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // dumps the definition of the instance fields for a given class</span>
<span class="line-added">+ void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
<span class="line-added">+   HandleMark hm;</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(k);</span>
  
<span class="line-modified">!   // dump the field descriptors</span>
    for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
      if (!fld.access_flags().is_static()) {
        Symbol* sig = fld.signature();
  
        writer-&gt;write_symbolID(fld.name());   // name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,24 ***</span>
    }
  }
  
  // creates HPROF_GC_INSTANCE_DUMP record for the given object
  void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<span class="line-modified">!   Klass* k = o-&gt;klass();</span>
  
<span class="line-modified">!   writer-&gt;write_u1(HPROF_GC_INSTANCE_DUMP);</span>
    writer-&gt;write_objectID(o);
    writer-&gt;write_u4(STACK_TRACE_ID);
  
    // class ID
<span class="line-modified">!   writer-&gt;write_classID(k);</span>
  
    // number of bytes that follow
<span class="line-modified">!   writer-&gt;write_u4(instance_size(k) );</span>
  
    // field values
    dump_instance_fields(writer, o);
  }
  
  // creates HPROF_GC_CLASS_DUMP record for the given class and each of
  // its array classes
  void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
<span class="line-new-header">--- 996,28 ---</span>
    }
  }
  
  // creates HPROF_GC_INSTANCE_DUMP record for the given object
  void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<span class="line-modified">!   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());</span>
<span class="line-added">+   u4 is = instance_size(ik);</span>
<span class="line-added">+   u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;</span>
  
<span class="line-modified">!   writer-&gt;start_sub_record(HPROF_GC_INSTANCE_DUMP, size);</span>
    writer-&gt;write_objectID(o);
    writer-&gt;write_u4(STACK_TRACE_ID);
  
    // class ID
<span class="line-modified">!   writer-&gt;write_classID(ik);</span>
  
    // number of bytes that follow
<span class="line-modified">!   writer-&gt;write_u4(is);</span>
  
    // field values
    dump_instance_fields(writer, o);
<span class="line-added">+ </span>
<span class="line-added">+   writer-&gt;end_sub_record();</span>
  }
  
  // creates HPROF_GC_CLASS_DUMP record for the given class and each of
  // its array classes
  void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,11 ***</span>
    // that the class is at least loaded, to avoid crash from a null mirror.
    if (!ik-&gt;is_loaded()) {
      return;
    }
  
<span class="line-modified">!   writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>
  
    // class ID
    writer-&gt;write_classID(ik);
    writer-&gt;write_u4(STACK_TRACE_ID);
  
<span class="line-new-header">--- 1028,17 ---</span>
    // that the class is at least loaded, to avoid crash from a null mirror.
    if (!ik-&gt;is_loaded()) {
      return;
    }
  
<span class="line-modified">!   u2 static_fields_count = 0;</span>
<span class="line-added">+   u4 static_size = get_static_fields_size(ik, static_fields_count);</span>
<span class="line-added">+   u2 instance_fields_count = get_instance_fields_count(ik);</span>
<span class="line-added">+   u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);</span>
<span class="line-added">+   u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
  
    // class ID
    writer-&gt;write_classID(ik);
    writer-&gt;write_u4(STACK_TRACE_ID);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,33 ***</span>
    // reserved
    writer-&gt;write_objectID(oop(NULL));
    writer-&gt;write_objectID(oop(NULL));
  
    // instance size
<span class="line-modified">!   writer-&gt;write_u4(DumperSupport::instance_size(k));</span>
  
    // size of constant pool - ignored by HAT 1.1
    writer-&gt;write_u2(0);
  
<span class="line-modified">!   // number of static fields</span>
<span class="line-modified">!   dump_static_fields(writer, k);</span>
  
    // description of instance fields
<span class="line-modified">!   dump_instance_field_descriptors(writer, k);</span>
  
    // array classes
<span class="line-modified">!   k = k-&gt;array_klass_or_null();</span>
    while (k != NULL) {
<span class="line-modified">!     Klass* klass = k;</span>
<span class="line-removed">-     assert(klass-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>
  
<span class="line-modified">!     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>
<span class="line-modified">!     writer-&gt;write_classID(klass);</span>
      writer-&gt;write_u4(STACK_TRACE_ID);
  
      // super class of array classes is java.lang.Object
<span class="line-modified">!     java_super = klass-&gt;java_super();</span>
      assert(java_super != NULL, &quot;checking&quot;);
      writer-&gt;write_classID(java_super);
  
      writer-&gt;write_objectID(ik-&gt;class_loader());
      writer-&gt;write_objectID(ik-&gt;signers());
<span class="line-new-header">--- 1057,37 ---</span>
    // reserved
    writer-&gt;write_objectID(oop(NULL));
    writer-&gt;write_objectID(oop(NULL));
  
    // instance size
<span class="line-modified">!   writer-&gt;write_u4(DumperSupport::instance_size(ik));</span>
  
    // size of constant pool - ignored by HAT 1.1
    writer-&gt;write_u2(0);
  
<span class="line-modified">!   // static fields</span>
<span class="line-modified">!   writer-&gt;write_u2(static_fields_count);</span>
<span class="line-added">+   dump_static_fields(writer, ik);</span>
  
    // description of instance fields
<span class="line-modified">!   writer-&gt;write_u2(instance_fields_count);</span>
<span class="line-added">+   dump_instance_field_descriptors(writer, ik);</span>
<span class="line-added">+ </span>
<span class="line-added">+   writer-&gt;end_sub_record();</span>
  
    // array classes
<span class="line-modified">!   k = ik-&gt;array_klass_or_null();</span>
    while (k != NULL) {
<span class="line-modified">!     assert(k-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>
  
<span class="line-modified">!     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-modified">!     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
<span class="line-added">+     writer-&gt;write_classID(k);</span>
      writer-&gt;write_u4(STACK_TRACE_ID);
  
      // super class of array classes is java.lang.Object
<span class="line-modified">!     java_super = k-&gt;java_super();</span>
      assert(java_super != NULL, &quot;checking&quot;);
      writer-&gt;write_classID(java_super);
  
      writer-&gt;write_objectID(ik-&gt;class_loader());
      writer-&gt;write_objectID(ik-&gt;signers());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,23 ***</span>
      writer-&gt;write_u4(0);             // instance size
      writer-&gt;write_u2(0);             // constant pool
      writer-&gt;write_u2(0);             // static fields
      writer-&gt;write_u2(0);             // instance fields
  
      // get the array class for the next rank
<span class="line-modified">!     k = klass-&gt;array_klass_or_null();</span>
    }
  }
  
  // creates HPROF_GC_CLASS_DUMP record for a given primitive array
  // class (and each multi-dimensional array class too)
  void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
   // array classes
   while (k != NULL) {
      Klass* klass = k;
  
<span class="line-modified">!     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>
      writer-&gt;write_classID(klass);
      writer-&gt;write_u4(STACK_TRACE_ID);
  
      // super class of array classes is java.lang.Object
      InstanceKlass* java_super = klass-&gt;java_super();
<span class="line-new-header">--- 1098,26 ---</span>
      writer-&gt;write_u4(0);             // instance size
      writer-&gt;write_u2(0);             // constant pool
      writer-&gt;write_u2(0);             // static fields
      writer-&gt;write_u2(0);             // instance fields
  
<span class="line-added">+     writer-&gt;end_sub_record();</span>
<span class="line-added">+ </span>
      // get the array class for the next rank
<span class="line-modified">!     k = k-&gt;array_klass_or_null();</span>
    }
  }
  
  // creates HPROF_GC_CLASS_DUMP record for a given primitive array
  // class (and each multi-dimensional array class too)
  void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
   // array classes
   while (k != NULL) {
      Klass* klass = k;
  
<span class="line-modified">!     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-added">+     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
      writer-&gt;write_classID(klass);
      writer-&gt;write_u4(STACK_TRACE_ID);
  
      // super class of array classes is java.lang.Object
      InstanceKlass* java_super = klass-&gt;java_super();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1075,10 ***</span>
<span class="line-new-header">--- 1133,12 ---</span>
      writer-&gt;write_u4(0);             // instance size
      writer-&gt;write_u2(0);             // constant pool
      writer-&gt;write_u2(0);             // static fields
      writer-&gt;write_u2(0);             // instance fields
  
<span class="line-added">+     writer-&gt;end_sub_record();</span>
<span class="line-added">+ </span>
      // get the array class for the next rank
      k = klass-&gt;array_klass_or_null();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,27 ***</span>
    } else {
      type_size = type2aelembytes(type);
    }
  
    size_t length_in_bytes = (size_t)length * type_size;
  
<span class="line-removed">-   // Create a new record if the current record is non-empty and the array can&#39;t fit.</span>
<span class="line-removed">-   julong current_record_length = writer-&gt;current_record_length();</span>
<span class="line-removed">-   if (current_record_length &gt; 0 &amp;&amp;</span>
<span class="line-removed">-       (current_record_length + header_size + length_in_bytes) &gt; max_juint) {</span>
<span class="line-removed">-     write_current_dump_record_length(writer);</span>
<span class="line-removed">-     write_dump_header(writer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We now have an empty record.</span>
<span class="line-removed">-     current_record_length = 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Calculate max bytes we can use.</span>
<span class="line-removed">-   uint max_bytes = max_juint - (header_size + current_record_length);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Array too long for the record?</span>
<span class="line-removed">-   // Calculate max length and return it.</span>
    if (length_in_bytes &gt; max_bytes) {
      length = max_bytes / type_size;
      length_in_bytes = (size_t)length * type_size;
  
      warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
<span class="line-new-header">--- 1156,12 ---</span>
    } else {
      type_size = type2aelembytes(type);
    }
  
    size_t length_in_bytes = (size_t)length * type_size;
<span class="line-added">+   uint max_bytes = max_juint - header_size;</span>
  
    if (length_in_bytes &gt; max_bytes) {
      length = max_bytes / type_size;
      length_in_bytes = (size_t)length * type_size;
  
      warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1127,26 ***</span>
  
  // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
  void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
    // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
    short header_size = 1 + 2 * 4 + 2 * sizeof(address);
<span class="line-removed">- </span>
    int length = calculate_array_max_length(writer, array, header_size);
  
<span class="line-modified">!   writer-&gt;write_u1(HPROF_GC_OBJ_ARRAY_DUMP);</span>
    writer-&gt;write_objectID(array);
    writer-&gt;write_u4(STACK_TRACE_ID);
    writer-&gt;write_u4(length);
  
    // array class ID
    writer-&gt;write_classID(array-&gt;klass());
  
    // [id]* elements
    for (int index = 0; index &lt; length; index++) {
      oop o = array-&gt;obj_at(index);
      writer-&gt;write_objectID(o);
    }
  }
  
  #define WRITE_ARRAY(Array, Type, Size, Length) \
    for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
  
<span class="line-new-header">--- 1172,35 ---</span>
  
  // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
  void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
    // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
    short header_size = 1 + 2 * 4 + 2 * sizeof(address);
    int length = calculate_array_max_length(writer, array, header_size);
<span class="line-added">+   u4 size = header_size + length * sizeof(address);</span>
  
<span class="line-modified">!   writer-&gt;start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);</span>
    writer-&gt;write_objectID(array);
    writer-&gt;write_u4(STACK_TRACE_ID);
    writer-&gt;write_u4(length);
  
    // array class ID
    writer-&gt;write_classID(array-&gt;klass());
  
    // [id]* elements
    for (int index = 0; index &lt; length; index++) {
      oop o = array-&gt;obj_at(index);
<span class="line-added">+     if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">+       ResourceMark rm;</span>
<span class="line-added">+       log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added">+                            p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">+                            p2i(array), array-&gt;klass()-&gt;external_name());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     o = mask_dormant_archived_object(o);</span>
      writer-&gt;write_objectID(o);
    }
<span class="line-added">+ </span>
<span class="line-added">+   writer-&gt;end_sub_record();</span>
  }
  
  #define WRITE_ARRAY(Array, Type, Size, Length) \
    for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1158,19 ***</span>
    short header_size = 2 * 1 + 2 * 4 + sizeof(address);
  
    int length = calculate_array_max_length(writer, array, header_size);
    int type_size = type2aelembytes(type);
    u4 length_in_bytes = (u4)length * type_size;
  
<span class="line-modified">!   writer-&gt;write_u1(HPROF_GC_PRIM_ARRAY_DUMP);</span>
    writer-&gt;write_objectID(array);
    writer-&gt;write_u4(STACK_TRACE_ID);
    writer-&gt;write_u4(length);
    writer-&gt;write_u1(type2tag(type));
  
    // nothing to copy
    if (length == 0) {
      return;
    }
  
    // If the byte ordering is big endian then we can copy most types directly
  
<span class="line-new-header">--- 1212,21 ---</span>
    short header_size = 2 * 1 + 2 * 4 + sizeof(address);
  
    int length = calculate_array_max_length(writer, array, header_size);
    int type_size = type2aelembytes(type);
    u4 length_in_bytes = (u4)length * type_size;
<span class="line-added">+   u4 size = header_size + length_in_bytes;</span>
  
<span class="line-modified">!   writer-&gt;start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);</span>
    writer-&gt;write_objectID(array);
    writer-&gt;write_u4(STACK_TRACE_ID);
    writer-&gt;write_u4(length);
    writer-&gt;write_u1(type2tag(type));
  
    // nothing to copy
    if (length == 0) {
<span class="line-added">+     writer-&gt;end_sub_record();</span>
      return;
    }
  
    // If the byte ordering is big endian then we can copy most types directly
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,10 ***</span>
<span class="line-new-header">--- 1292,12 ---</span>
        }
        break;
      }
      default : ShouldNotReachHere();
    }
<span class="line-added">+ </span>
<span class="line-added">+   writer-&gt;end_sub_record();</span>
  }
  
  // create a HPROF_FRAME record of the given Method* and bci
  void DumperSupport::dump_stack_frame(DumpWriter* writer,
                                       int frame_serial_num,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,14 ***</span>
  
  void JNILocalsDumper::do_oop(oop* obj_p) {
    // ignore null handles
    oop o = *obj_p;
    if (o != NULL) {
<span class="line-modified">!     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_LOCAL);</span>
      writer()-&gt;write_objectID(o);
      writer()-&gt;write_u4(_thread_serial_num);
      writer()-&gt;write_u4((u4)_frame_num);
    }
  }
  
  
  // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
<span class="line-new-header">--- 1369,16 ---</span>
  
  void JNILocalsDumper::do_oop(oop* obj_p) {
    // ignore null handles
    oop o = *obj_p;
    if (o != NULL) {
<span class="line-modified">!     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">+     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);</span>
      writer()-&gt;write_objectID(o);
      writer()-&gt;write_u4(_thread_serial_num);
      writer()-&gt;write_u4((u4)_frame_num);
<span class="line-added">+     writer()-&gt;end_sub_record();</span>
    }
  }
  
  
  // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1342,13 ***</span>
    // ignore these
    if (o == NULL) return;
  
    // we ignore global ref to symbols and other internal objects
    if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<span class="line-modified">!     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_GLOBAL);</span>
      writer()-&gt;write_objectID(o);
      writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
    }
  };
  
  
  // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
<span class="line-new-header">--- 1402,15 ---</span>
    // ignore these
    if (o == NULL) return;
  
    // we ignore global ref to symbols and other internal objects
    if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<span class="line-modified">!     u4 size = 1 + 2 * sizeof(address);</span>
<span class="line-added">+     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);</span>
      writer()-&gt;write_objectID(o);
      writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
<span class="line-added">+     writer()-&gt;end_sub_record();</span>
    }
  };
  
  
  // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1360,12 ***</span>
   public:
    MonitorUsedDumper(DumpWriter* writer) {
      _writer = writer;
    }
    void do_oop(oop* obj_p) {
<span class="line-modified">!     writer()-&gt;write_u1(HPROF_GC_ROOT_MONITOR_USED);</span>
      writer()-&gt;write_objectID(*obj_p);
    }
    void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
  };
  
  
<span class="line-new-header">--- 1422,14 ---</span>
   public:
    MonitorUsedDumper(DumpWriter* writer) {
      _writer = writer;
    }
    void do_oop(oop* obj_p) {
<span class="line-modified">!     u4 size = 1 + sizeof(address);</span>
<span class="line-added">+     writer()-&gt;start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);</span>
      writer()-&gt;write_objectID(*obj_p);
<span class="line-added">+     writer()-&gt;end_sub_record();</span>
    }
    void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
  };
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1380,14 ***</span>
      _writer = writer;
    }
    void do_klass(Klass* k) {
      if (k-&gt;is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!         writer()-&gt;write_u1(HPROF_GC_ROOT_STICKY_CLASS);</span>
<span class="line-modified">!         writer()-&gt;write_classID(ik);</span>
<span class="line-modified">!       }</span>
      }
  };
  
  
  class VM_HeapDumper;
  
<span class="line-new-header">--- 1444,16 ---</span>
      _writer = writer;
    }
    void do_klass(Klass* k) {
      if (k-&gt;is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!       u4 size = 1 + sizeof(address);</span>
<span class="line-modified">!       writer()-&gt;start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);</span>
<span class="line-modified">!       writer()-&gt;write_classID(ik);</span>
<span class="line-added">+       writer()-&gt;end_sub_record();</span>
      }
<span class="line-added">+   }</span>
  };
  
  
  class VM_HeapDumper;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1399,13 ***</span>
    DumpWriter* _writer;
  
    VM_HeapDumper* dumper()               { return _dumper; }
    DumpWriter* writer()                  { return _writer; }
  
<span class="line-removed">-   // used to indicate that a record has been writen</span>
<span class="line-removed">-   void mark_end_of_record();</span>
<span class="line-removed">- </span>
   public:
    HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
      _dumper = dumper;
      _writer = writer;
    }
<span class="line-new-header">--- 1465,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1420,22 ***</span>
      if (!java_lang_Class::is_primitive(o)) {
        return;
      }
    }
  
    if (o-&gt;is_instance()) {
      // create a HPROF_GC_INSTANCE record for each object
      DumperSupport::dump_instance(writer(), o);
<span class="line-removed">-     mark_end_of_record();</span>
    } else if (o-&gt;is_objArray()) {
      // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
      DumperSupport::dump_object_array(writer(), objArrayOop(o));
<span class="line-removed">-     mark_end_of_record();</span>
    } else if (o-&gt;is_typeArray()) {
      // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
      DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
<span class="line-removed">-     mark_end_of_record();</span>
    }
  }
  
  // The VM operation that performs the heap dump
  class VM_HeapDumper : public VM_GC_Operation {
<span class="line-new-header">--- 1483,24 ---</span>
      if (!java_lang_Class::is_primitive(o)) {
        return;
      }
    }
  
<span class="line-added">+   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">+     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (o-&gt;is_instance()) {
      // create a HPROF_GC_INSTANCE record for each object
      DumperSupport::dump_instance(writer(), o);
    } else if (o-&gt;is_objArray()) {
      // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
      DumperSupport::dump_object_array(writer(), objArrayOop(o));
    } else if (o-&gt;is_typeArray()) {
      // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
      DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
    }
  }
  
  // The VM operation that performs the heap dump
  class VM_HeapDumper : public VM_GC_Operation {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1522,88 ***</span>
      }
      delete _klass_map;
    }
  
    VMOp_Type type() const { return VMOp_HeapDumper; }
<span class="line-removed">-   // used to mark sub-record boundary</span>
<span class="line-removed">-   void check_segment_length();</span>
    void doit();
  };
  
  VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
  DumpWriter*    VM_HeapDumper::_global_writer = NULL;
  
  bool VM_HeapDumper::skip_operation() const {
    return false;
  }
  
<span class="line-removed">-  // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed">- void DumperSupport::write_dump_header(DumpWriter* writer) {</span>
<span class="line-removed">-   if (writer-&gt;is_open()) {</span>
<span class="line-removed">-     writer-&gt;write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-removed">-     writer-&gt;write_u4(0); // current ticks</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // record the starting position for the dump (its length will be fixed up later)</span>
<span class="line-removed">-     writer-&gt;set_dump_start(writer-&gt;current_offset());</span>
<span class="line-removed">-     writer-&gt;write_u4(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // fixes up the length of the current dump record</span>
<span class="line-removed">- void DumperSupport::write_current_dump_record_length(DumpWriter* writer) {</span>
<span class="line-removed">-   if (writer-&gt;is_open()) {</span>
<span class="line-removed">-     julong dump_end = writer-&gt;bytes_written() + writer-&gt;bytes_unwritten();</span>
<span class="line-removed">-     julong dump_len = writer-&gt;current_record_length();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // record length must fit in a u4</span>
<span class="line-removed">-     if (dump_len &gt; max_juint) {</span>
<span class="line-removed">-       warning(&quot;record is too large&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // seek to the dump start and fix-up the length</span>
<span class="line-removed">-     assert(writer-&gt;dump_start() &gt;= 0, &quot;no dump start recorded&quot;);</span>
<span class="line-removed">-     writer-&gt;seek_to_offset(writer-&gt;dump_start());</span>
<span class="line-removed">-     writer-&gt;write_u4((u4)dump_len);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // adjust the total size written to keep the bytes written correct.</span>
<span class="line-removed">-     writer-&gt;adjust_bytes_written(-((jlong) sizeof(u4)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // seek to dump end so we can continue</span>
<span class="line-removed">-     writer-&gt;seek_to_offset(dump_end);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // no current dump record</span>
<span class="line-removed">-     writer-&gt;set_dump_start((jlong)-1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // used on a sub-record boundary to check if we need to start a</span>
<span class="line-removed">- // new segment.</span>
<span class="line-removed">- void VM_HeapDumper::check_segment_length() {</span>
<span class="line-removed">-   if (writer()-&gt;is_open()) {</span>
<span class="line-removed">-     julong dump_len = writer()-&gt;current_record_length();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (dump_len &gt; 2UL*G) {</span>
<span class="line-removed">-       DumperSupport::write_current_dump_record_length(writer());</span>
<span class="line-removed">-       DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
  void DumperSupport::end_of_dump(DumpWriter* writer) {
<span class="line-modified">!   if (writer-&gt;is_open()) {</span>
<span class="line-removed">-     write_current_dump_record_length(writer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-removed">-     writer-&gt;write_u4(0);</span>
<span class="line-removed">-     writer-&gt;write_u4(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! // marks sub-record boundary</span>
<span class="line-modified">! void HeapObjectDumper::mark_end_of_record() {</span>
<span class="line-modified">!   dumper()-&gt;check_segment_length();</span>
  }
  
  // writes a HPROF_LOAD_CLASS record for the class (and each of its
  // array classes)
  void VM_HeapDumper::do_load_class(Klass* k) {
<span class="line-new-header">--- 1587,27 ---</span>
      }
      delete _klass_map;
    }
  
    VMOp_Type type() const { return VMOp_HeapDumper; }
    void doit();
  };
  
  VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
  DumpWriter*    VM_HeapDumper::_global_writer = NULL;
  
  bool VM_HeapDumper::skip_operation() const {
    return false;
  }
  
  // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
  void DumperSupport::end_of_dump(DumpWriter* writer) {
<span class="line-modified">!   writer-&gt;finish_dump_segment();</span>
  
<span class="line-modified">!   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-modified">!   writer-&gt;write_u4(0);</span>
<span class="line-modified">!   writer-&gt;write_u4(0);</span>
  }
  
  // writes a HPROF_LOAD_CLASS record for the class (and each of its
  // array classes)
  void VM_HeapDumper::do_load_class(Klass* k) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1689,26 ***</span>
            for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
              if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
                oop o = locals-&gt;obj_at(slot)();
  
                if (o != NULL) {
<span class="line-modified">!                 writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>
                  writer()-&gt;write_objectID(o);
                  writer()-&gt;write_u4(thread_serial_num);
                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
                }
              }
            }
            StackValueCollection *exprs = jvf-&gt;expressions();
            for(int index = 0; index &lt; exprs-&gt;size(); index++) {
              if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
                 oop o = exprs-&gt;obj_at(index)();
                 if (o != NULL) {
<span class="line-modified">!                  writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>
                   writer()-&gt;write_objectID(o);
                   writer()-&gt;write_u4(thread_serial_num);
                   writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
                 }
               }
            }
          } else {
            // native frame
<span class="line-new-header">--- 1693,30 ---</span>
            for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
              if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
                oop o = locals-&gt;obj_at(slot)();
  
                if (o != NULL) {
<span class="line-modified">!                 u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">+                 writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
                  writer()-&gt;write_objectID(o);
                  writer()-&gt;write_u4(thread_serial_num);
                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<span class="line-added">+                 writer()-&gt;end_sub_record();</span>
                }
              }
            }
            StackValueCollection *exprs = jvf-&gt;expressions();
            for(int index = 0; index &lt; exprs-&gt;size(); index++) {
              if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
                 oop o = exprs-&gt;obj_at(index)();
                 if (o != NULL) {
<span class="line-modified">!                  u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">+                  writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
                   writer()-&gt;write_objectID(o);
                   writer()-&gt;write_u4(thread_serial_num);
                   writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<span class="line-added">+                  writer()-&gt;end_sub_record();</span>
                 }
               }
            }
          } else {
            // native frame
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1752,14 ***</span>
    for (int i=0; i &lt; _num_threads; i++) {
      JavaThread* thread = _stack_traces[i]-&gt;thread();
      oop threadObj = thread-&gt;threadObj();
      u4 thread_serial_num = i+1;
      u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<span class="line-modified">!     writer()-&gt;write_u1(HPROF_GC_ROOT_THREAD_OBJ);</span>
      writer()-&gt;write_objectID(threadObj);
      writer()-&gt;write_u4(thread_serial_num);  // thread number
      writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
      int num_frames = do_thread(thread, thread_serial_num);
      assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
             &quot;total number of Java frames not matched&quot;);
    }
  }
<span class="line-new-header">--- 1760,16 ---</span>
    for (int i=0; i &lt; _num_threads; i++) {
      JavaThread* thread = _stack_traces[i]-&gt;thread();
      oop threadObj = thread-&gt;threadObj();
      u4 thread_serial_num = i+1;
      u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<span class="line-modified">!     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">+     writer()-&gt;start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);</span>
      writer()-&gt;write_objectID(threadObj);
      writer()-&gt;write_u4(thread_serial_num);  // thread number
      writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
<span class="line-added">+     writer()-&gt;end_sub_record();</span>
      int num_frames = do_thread(thread, thread_serial_num);
      assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
             &quot;total number of Java frames not matched&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1816,10 ***</span>
<span class="line-new-header">--- 1826,11 ---</span>
  
    // header is few bytes long - no chance to overflow int
    writer()-&gt;write_raw((void*)header, (int)strlen(header));
    writer()-&gt;write_u1(0); // terminator
    writer()-&gt;write_u4(oopSize);
<span class="line-added">+   // timestamp is current time in ms</span>
    writer()-&gt;write_u8(os::javaTimeMillis());
  
    // HPROF_UTF8 records
    SymbolTableDumper sym_dumper(writer());
    SymbolTable::symbols_do(&amp;sym_dumper);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1833,53 ***</span>
  
    // write HPROF_FRAME and HPROF_TRACE records
    // this must be called after _klass_map is built when iterating the classes above.
    dump_stack_traces();
  
<span class="line-removed">-   // write HPROF_HEAP_DUMP_SEGMENT</span>
<span class="line-removed">-   DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">- </span>
    // Writes HPROF_GC_CLASS_DUMP records
    {
      LockedClassesDo locked_dump_class(&amp;do_class_dump);
      ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
    }
    Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
<span class="line-removed">-   check_segment_length();</span>
  
    // writes HPROF_GC_INSTANCE_DUMP records.
    // After each sub-record is written check_segment_length will be invoked
    // to check if the current segment exceeds a threshold. If so, a new
    // segment is started.
    // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
    // of the heap dump.
    HeapObjectDumper obj_dumper(this, writer());
<span class="line-modified">!   Universe::heap()-&gt;safe_object_iterate(&amp;obj_dumper);</span>
  
    // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
    do_threads();
<span class="line-removed">-   check_segment_length();</span>
  
    // HPROF_GC_ROOT_MONITOR_USED
    MonitorUsedDumper mon_dumper(writer());
    ObjectSynchronizer::oops_do(&amp;mon_dumper);
<span class="line-removed">-   check_segment_length();</span>
  
    // HPROF_GC_ROOT_JNI_GLOBAL
    JNIGlobalsDumper jni_dumper(writer());
    JNIHandles::oops_do(&amp;jni_dumper);
    Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
                                     // for things like preallocated throwable backtraces
<span class="line-removed">-   check_segment_length();</span>
  
    // HPROF_GC_ROOT_STICKY_CLASS
    // These should be classes in the NULL class loader data, and not all classes
    // if !ClassUnloading
    StickyClassDumper class_dumper(writer());
    ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
  
<span class="line-modified">!   // fixes up the length of the dump record and writes the HPROF_HEAP_DUMP_END record.</span>
    DumperSupport::end_of_dump(writer());
  
    // Now we clear the global variables, so that a future dumper might run.
    clear_global_dumper();
    clear_global_writer();
<span class="line-new-header">--- 1844,46 ---</span>
  
    // write HPROF_FRAME and HPROF_TRACE records
    // this must be called after _klass_map is built when iterating the classes above.
    dump_stack_traces();
  
    // Writes HPROF_GC_CLASS_DUMP records
    {
      LockedClassesDo locked_dump_class(&amp;do_class_dump);
      ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
    }
    Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
  
    // writes HPROF_GC_INSTANCE_DUMP records.
    // After each sub-record is written check_segment_length will be invoked
    // to check if the current segment exceeds a threshold. If so, a new
    // segment is started.
    // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
    // of the heap dump.
    HeapObjectDumper obj_dumper(this, writer());
<span class="line-modified">!   Universe::heap()-&gt;object_iterate(&amp;obj_dumper);</span>
  
    // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
    do_threads();
  
    // HPROF_GC_ROOT_MONITOR_USED
    MonitorUsedDumper mon_dumper(writer());
    ObjectSynchronizer::oops_do(&amp;mon_dumper);
  
    // HPROF_GC_ROOT_JNI_GLOBAL
    JNIGlobalsDumper jni_dumper(writer());
    JNIHandles::oops_do(&amp;jni_dumper);
    Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
                                     // for things like preallocated throwable backtraces
  
    // HPROF_GC_ROOT_STICKY_CLASS
    // These should be classes in the NULL class loader data, and not all classes
    // if !ClassUnloading
    StickyClassDumper class_dumper(writer());
    ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
  
<span class="line-modified">!   // Writes the HPROF_HEAP_DUMP_END record.</span>
    DumperSupport::end_of_dump(writer());
  
    // Now we clear the global variables, so that a future dumper might run.
    clear_global_dumper();
    clear_global_writer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1938,25 ***</span>
      }
    }
  }
  
  // dump the heap to given path.
<span class="line-modified">! int HeapDumper::dump(const char* path) {</span>
    assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
  
    // print message in interactive case
<span class="line-modified">!   if (print_to_tty()) {</span>
<span class="line-modified">!     tty-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
      timer()-&gt;start();
    }
  
    // create the dump writer. If the file can be opened then bail
    DumpWriter writer(path);
<span class="line-modified">!   if (!writer.is_open()) {</span>
      set_error(writer.error());
<span class="line-modified">!     if (print_to_tty()) {</span>
<span class="line-modified">!       tty-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
          (error() != NULL) ? error() : &quot;reason unknown&quot;);
      }
      return -1;
    }
  
<span class="line-new-header">--- 1942,28 ---</span>
      }
    }
  }
  
  // dump the heap to given path.
<span class="line-modified">! int HeapDumper::dump(const char* path, outputStream* out) {</span>
    assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
  
    // print message in interactive case
<span class="line-modified">!   if (out != NULL) {</span>
<span class="line-modified">!     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
      timer()-&gt;start();
    }
  
<span class="line-added">+   // create JFR event</span>
<span class="line-added">+   EventHeapDump event;</span>
<span class="line-added">+ </span>
    // create the dump writer. If the file can be opened then bail
    DumpWriter writer(path);
<span class="line-modified">!   if (writer.error() != NULL) {</span>
      set_error(writer.error());
<span class="line-modified">!     if (out != NULL) {</span>
<span class="line-modified">!       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
          (error() != NULL) ? error() : &quot;reason unknown&quot;);
      }
      return -1;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1971,18 ***</span>
  
    // close dump file and record any error that the writer may have encountered
    writer.close();
    set_error(writer.error());
  
    // print message in interactive case
<span class="line-modified">!   if (print_to_tty()) {</span>
      timer()-&gt;stop();
      if (error() == NULL) {
<span class="line-modified">!       tty-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
                      writer.bytes_written(), timer()-&gt;seconds());
      } else {
<span class="line-modified">!       tty-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
      }
    }
  
    return (writer.error() == NULL) ? 0 : -1;
  }
<span class="line-new-header">--- 1978,27 ---</span>
  
    // close dump file and record any error that the writer may have encountered
    writer.close();
    set_error(writer.error());
  
<span class="line-added">+   // emit JFR event</span>
<span class="line-added">+   if (error() == NULL) {</span>
<span class="line-added">+     event.set_destination(path);</span>
<span class="line-added">+     event.set_gcBeforeDump(_gc_before_heap_dump);</span>
<span class="line-added">+     event.set_size(writer.bytes_written());</span>
<span class="line-added">+     event.set_onOutOfMemoryError(_oome);</span>
<span class="line-added">+     event.commit();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // print message in interactive case
<span class="line-modified">!   if (out != NULL) {</span>
      timer()-&gt;stop();
      if (error() == NULL) {
<span class="line-modified">!       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
                      writer.bytes_written(), timer()-&gt;seconds());
      } else {
<span class="line-modified">!       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
      }
    }
  
    return (writer.error() == NULL) ? 0 : -1;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,10 ***</span>
      jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
    }
    dump_file_seq++;   // increment seq number for next time we dump
  
    HeapDumper dumper(false /* no GC before heap dump */,
<span class="line-removed">-                     true  /* send to tty */,</span>
                      oome  /* pass along out-of-memory-error flag */);
<span class="line-modified">!   dumper.dump(my_path);</span>
    os::free(my_path);
  }
<span class="line-new-header">--- 2122,9 ---</span>
      jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
    }
    dump_file_seq++;   // increment seq number for next time we dump
  
    HeapDumper dumper(false /* no GC before heap dump */,
                      oome  /* pass along out-of-memory-error flag */);
<span class="line-modified">!   dumper.dump(my_path, tty);</span>
    os::free(my_path);
  }
</pre>
<center><a href="gcNotifier.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapDumper.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
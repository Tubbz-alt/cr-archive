<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/services/memTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memReporter.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memTracker.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,17 +22,19 @@</span>
   *
   */
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;services/memBaseline.hpp&quot;
  #include &quot;services/memReporter.hpp&quot;
  #include &quot;services/mallocTracker.inline.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
<span class="udiff-line-added">+ #include &quot;services/threadStackTracker.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  
  #ifdef _WINDOWS
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,11 +92,12 @@</span>
  }
  
  void MemTracker::init() {
    NMT_TrackingLevel level = tracking_level();
    if (level &gt;= NMT_summary) {
<span class="udiff-line-modified-removed">-     if (!VirtualMemoryTracker::late_initialize(level)) {</span>
<span class="udiff-line-modified-added">+     if (!VirtualMemoryTracker::late_initialize(level) ||</span>
<span class="udiff-line-added">+         !ThreadStackTracker::late_initialize(level)) {</span>
        shutdown();
        return;
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,11 +146,11 @@</span>
  
  
  // Shutdown can only be issued via JCmd, and NMT JCmd is serialized by lock
  void MemTracker::shutdown() {
    // We can only shutdown NMT to minimal tracking level if it is ever on.
<span class="udiff-line-modified-removed">-   if (tracking_level () &gt; NMT_minimal) {</span>
<span class="udiff-line-modified-added">+   if (tracking_level() &gt; NMT_minimal) {</span>
      transition_to(NMT_minimal);
    }
  }
  
  bool MemTracker::transition_to(NMT_TrackingLevel level) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,18 +165,35 @@</span>
      _tracking_level = level;
      // Make _tracking_level visible immediately.
      OrderAccess::fence();
      VirtualMemoryTracker::transition(current_level, level);
      MallocTracker::transition(current_level, level);
<span class="udiff-line-added">+     ThreadStackTracker::transition(current_level, level);</span>
    } else {
      // Upgrading tracking level is not supported and has never been supported.
      // Allocating and deallocating malloc tracking structures is not thread safe and
      // leads to inconsistencies unless a lot coarser locks are added.
    }
    return true;
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static volatile bool g_final_report_did_run = false;</span>
<span class="udiff-line-added">+ void MemTracker::final_report(outputStream* output) {</span>
<span class="udiff-line-added">+   // This function is called during both error reporting and normal VM exit.</span>
<span class="udiff-line-added">+   // However, it should only ever run once.  E.g. if the VM crashes after</span>
<span class="udiff-line-added">+   // printing the final report during normal VM exit, it should not print</span>
<span class="udiff-line-added">+   // the final report again. In addition, it should be guarded from</span>
<span class="udiff-line-added">+   // recursive calls in case NMT reporting itself crashes.</span>
<span class="udiff-line-added">+   if (Atomic::cmpxchg(&amp;g_final_report_did_run, false, true) == false) {</span>
<span class="udiff-line-added">+     NMT_TrackingLevel level = tracking_level();</span>
<span class="udiff-line-added">+     if (level &gt;= NMT_summary) {</span>
<span class="udiff-line-added">+       report(level == NMT_summary, output);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MemTracker::report(bool summary_only, outputStream* output) {
   assert(output != NULL, &quot;No output stream&quot;);
    MemBaseline baseline;
    if (baseline.baseline(summary_only)) {
      if (summary_only) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -181,16 +201,13 @@</span>
        rpt.report();
      } else {
        MemDetailReporter rpt(baseline, output);
        rpt.report();
        output-&gt;print(&quot;Metaspace:&quot;);
<span class="udiff-line-modified-removed">-       // Metadata reporting requires a safepoint, so avoid it if VM is not in good state.</span>
<span class="udiff-line-modified-removed">-       assert(!VMError::fatal_error_in_progress(), &quot;Do not report metadata in error report&quot;);</span>
<span class="udiff-line-modified-removed">-       VM_PrintMetadata vmop(output, K,</span>
<span class="udiff-line-removed">-           MetaspaceUtils::rf_show_loaders |</span>
<span class="udiff-line-removed">-           MetaspaceUtils::rf_break_down_by_spacetype);</span>
<span class="udiff-line-removed">-       VMThread::execute(&amp;vmop);</span>
<span class="udiff-line-modified-added">+       // The basic metaspace report avoids any locking and should be safe to</span>
<span class="udiff-line-modified-added">+       // be called at any time.</span>
<span class="udiff-line-modified-added">+       MetaspaceUtils::print_basic_report(output, K);</span>
      }
    }
  }
  
  // This is a walker to gather malloc site hashtable statistics,
</pre>
<center><a href="memReporter.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memTracker.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
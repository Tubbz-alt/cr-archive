<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/dtraceAttacher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;runtime/deoptimization.hpp&quot;
 29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 30 #include &quot;runtime/vmThread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;services/dtraceAttacher.hpp&quot;
 33 
 34 #ifdef SOLARIS
 35 
<a name="2" id="anc2"></a><span class="line-modified"> 36 class VM_DeoptimizeTheWorld : public VM_Operation {</span>
<span class="line-modified"> 37  public:</span>
<span class="line-modified"> 38   VMOp_Type type() const {</span>
<span class="line-removed"> 39     return VMOp_DeoptimizeTheWorld;</span>
<span class="line-removed"> 40   }</span>
<span class="line-removed"> 41   void doit() {</span>
<span class="line-removed"> 42     CodeCache::mark_all_nmethods_for_deoptimization();</span>
<span class="line-removed"> 43     ResourceMark rm;</span>
<span class="line-removed"> 44     DeoptimizationMarker dm;</span>
<span class="line-removed"> 45     // Deoptimize all activations depending on marked methods</span>
<span class="line-removed"> 46     Deoptimization::deoptimize_dependents();</span>
<span class="line-removed"> 47 </span>
<span class="line-removed"> 48     // Mark the dependent methods non entrant</span>
<span class="line-removed"> 49     CodeCache::make_marked_nmethods_not_entrant();</span>
<span class="line-removed"> 50   }</span>
<span class="line-removed"> 51 };</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 static void set_bool_flag(const char* flag, bool value) {</span>
<span class="line-removed"> 54   JVMFlag::boolAtPut((char*)flag, strlen(flag), &amp;value,</span>
<span class="line-removed"> 55                               JVMFlag::ATTACH_ON_DEMAND);</span>
 56 }
 57 
 58 // Enable only the &quot;fine grained&quot; flags. Do *not* touch
 59 // the overall &quot;ExtendedDTraceProbes&quot; flag.
 60 void DTrace::enable_dprobes(int probes) {
 61   bool changed = false;
 62   if (!DTraceAllocProbes &amp;&amp; (probes &amp; DTRACE_ALLOC_PROBES)) {
 63     set_bool_flag(&quot;DTraceAllocProbes&quot;, true);
 64     changed = true;
 65   }
 66   if (!DTraceMethodProbes &amp;&amp; (probes &amp; DTRACE_METHOD_PROBES)) {
 67     set_bool_flag(&quot;DTraceMethodProbes&quot;, true);
 68     changed = true;
 69   }
 70   if (!DTraceMonitorProbes &amp;&amp; (probes &amp; DTRACE_MONITOR_PROBES)) {
 71     set_bool_flag(&quot;DTraceMonitorProbes&quot;, true);
 72     changed = true;
 73   }
 74 
 75   if (changed) {
 76     // one or more flags changed, need to deoptimize
<a name="3" id="anc3"></a><span class="line-modified"> 77     VM_DeoptimizeTheWorld op;</span>
<span class="line-modified"> 78     VMThread::execute(&amp;op);</span>
 79   }
 80 }
 81 
 82 // Disable only the &quot;fine grained&quot; flags. Do *not* touch
 83 // the overall &quot;ExtendedDTraceProbes&quot; flag.
 84 void DTrace::disable_dprobes(int probes) {
 85   bool changed = false;
 86   if (DTraceAllocProbes &amp;&amp; (probes &amp; DTRACE_ALLOC_PROBES)) {
 87     set_bool_flag(&quot;DTraceAllocProbes&quot;, false);
 88     changed = true;
 89   }
 90   if (DTraceMethodProbes &amp;&amp; (probes &amp; DTRACE_METHOD_PROBES)) {
 91     set_bool_flag(&quot;DTraceMethodProbes&quot;, false);
 92     changed = true;
 93   }
 94   if (DTraceMonitorProbes &amp;&amp; (probes &amp; DTRACE_MONITOR_PROBES)) {
 95     set_bool_flag(&quot;DTraceMonitorProbes&quot;, false);
 96     changed = true;
 97   }
 98   if (changed) {
 99     // one or more flags changed, need to deoptimize
<a name="4" id="anc4"></a><span class="line-modified">100     VM_DeoptimizeTheWorld op;</span>
<span class="line-modified">101     VMThread::execute(&amp;op);</span>
102   }
103 }
104 
105 // Do clean-up on &quot;all door clients detached&quot; event.
106 void DTrace::detach_all_clients() {
107   /*
108    * We restore the state of the fine grained flags
109    * to be consistent with overall ExtendedDTraceProbes.
110    * This way, we will honour command line setting or the
111    * last explicit modification of ExtendedDTraceProbes by
112    * a call to set_extended_dprobes.
113    */
114   if (ExtendedDTraceProbes) {
115     enable_dprobes(DTRACE_ALL_PROBES);
116   } else {
117     disable_dprobes(DTRACE_ALL_PROBES);
118   }
119 }
120 
121 void DTrace::set_extended_dprobes(bool flag) {
122   // explicit setting of ExtendedDTraceProbes flag
123   set_bool_flag(&quot;ExtendedDTraceProbes&quot;, flag);
124 
125   // make sure that the fine grained flags reflect the change.
126   if (flag) {
127     enable_dprobes(DTRACE_ALL_PROBES);
128   } else {
129     /*
130      * FIXME: Revisit this: currently all-client-detach detection
131      * does not work and hence disabled. The following scheme does
132      * not work. So, we have to disable fine-grained flags here.
133      *
134      * disable_dprobes call has to be delayed till next &quot;detach all &quot;event.
135      * This is to be  done so that concurrent DTrace clients that may
136      * have enabled one or more fine grained dprobes and may be running
137      * still. On &quot;detach all&quot; clients event, we would sync ExtendedDTraceProbes
138      * with  fine grained flags which would take care of disabling fine grained flags.
139      */
140     disable_dprobes(DTRACE_ALL_PROBES);
141   }
142 }
143 
144 void DTrace::set_monitor_dprobes(bool flag) {
145   // explicit setting of DTraceMonitorProbes flag
146   set_bool_flag(&quot;DTraceMonitorProbes&quot;, flag);
147 }
148 
149 #endif /* SOLARIS */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
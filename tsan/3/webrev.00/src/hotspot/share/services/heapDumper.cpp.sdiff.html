<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcNotifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapDumper.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/heapDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;

  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;memory/universe.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/objArrayOop.inline.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/javaCalls.hpp&quot;
  45 #include &quot;runtime/jniHandles.hpp&quot;
  46 #include &quot;runtime/os.inline.hpp&quot;
  47 #include &quot;runtime/reflectionUtils.hpp&quot;
  48 #include &quot;runtime/thread.inline.hpp&quot;
  49 #include &quot;runtime/threadSMR.hpp&quot;
  50 #include &quot;runtime/vframe.hpp&quot;
  51 #include &quot;runtime/vmThread.hpp&quot;
  52 #include &quot;runtime/vmOperations.hpp&quot;
  53 #include &quot;services/heapDumper.hpp&quot;
  54 #include &quot;services/threadService.hpp&quot;
</pre>
<hr />
<pre>
 364   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 365   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 366   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 367   HPROF_GC_CLASS_DUMP           = 0x20,
 368   HPROF_GC_INSTANCE_DUMP        = 0x21,
 369   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 370   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 371 } hprofTag;
 372 
 373 // Default stack trace ID (used for dummy HPROF_TRACE record)
 374 enum {
 375   STACK_TRACE_ID = 1,
 376   INITIAL_CLASS_COUNT = 200
 377 };
 378 
 379 // Supports I/O operations on a dump file
 380 
 381 class DumpWriter : public StackObj {
 382  private:
 383   enum {
<span class="line-modified"> 384     io_buffer_size  = 8*M</span>


 385   };
 386 
 387   int _fd;              // file descriptor (-1 if dump file not open)
 388   julong _bytes_written; // number of byte written to dump file
 389 
 390   char* _buffer;    // internal buffer
 391   size_t _size;
 392   size_t _pos;
 393 
<span class="line-modified"> 394   jlong _dump_start;</span>



 395 
 396   char* _error;   // error message when I/O fails
 397 
 398   void set_file_descriptor(int fd)              { _fd = fd; }
 399   int file_descriptor() const                   { return _fd; }
 400 



 401   char* buffer() const                          { return _buffer; }
 402   size_t buffer_size() const                    { return _size; }
 403   size_t position() const                       { return _pos; }
 404   void set_position(size_t pos)                 { _pos = pos; }
 405 
 406   void set_error(const char* error)             { _error = (char*)os::strdup(error); }
 407 
 408   // all I/O go through this function
 409   void write_internal(void* s, size_t len);
 410 
 411  public:
 412   DumpWriter(const char* path);
 413   ~DumpWriter();
 414 
 415   void close();
<span class="line-removed"> 416   bool is_open() const                  { return file_descriptor() &gt;= 0; }</span>
<span class="line-removed"> 417   void flush();</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419   jlong dump_start() const                      { return _dump_start; }</span>
<span class="line-removed"> 420   void set_dump_start(jlong pos);</span>
<span class="line-removed"> 421   julong current_record_length();</span>
 422 
 423   // total number of bytes written to the disk
 424   julong bytes_written() const          { return _bytes_written; }
 425 
<span class="line-removed"> 426   // adjust the number of bytes written to disk (used to keep the count</span>
<span class="line-removed"> 427   // of the number of bytes written in case of rewrites)</span>
<span class="line-removed"> 428   void adjust_bytes_written(jlong n)    { _bytes_written += n; }</span>
<span class="line-removed"> 429 </span>
<span class="line-removed"> 430   // number of (buffered) bytes as yet unwritten to the dump file</span>
<span class="line-removed"> 431   size_t bytes_unwritten() const        { return position(); }</span>
<span class="line-removed"> 432 </span>
 433   char* error() const                   { return _error; }
 434 
<span class="line-removed"> 435   jlong current_offset();</span>
<span class="line-removed"> 436   void seek_to_offset(jlong pos);</span>
<span class="line-removed"> 437 </span>
 438   // writer functions
 439   void write_raw(void* s, size_t len);
 440   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
 441   void write_u2(u2 x);
 442   void write_u4(u4 x);
 443   void write_u8(u8 x);
 444   void write_objectID(oop o);
 445   void write_symbolID(Symbol* o);
 446   void write_classID(Klass* k);
 447   void write_id(u4 x);







 448 };
 449 
<span class="line-modified"> 450 DumpWriter::DumpWriter(const char* path) {</span>

 451   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
 452   // sufficient memory then reduce size until we can allocate something.
<span class="line-modified"> 453   _size = io_buffer_size;</span>
 454   do {
 455     _buffer = (char*)os::malloc(_size, mtInternal);
 456     if (_buffer == NULL) {
 457       _size = _size &gt;&gt; 1;
 458     }
<span class="line-modified"> 459   } while (_buffer == NULL &amp;&amp; _size &gt; 0);</span>
<span class="line-modified"> 460   assert((_size &gt; 0 &amp;&amp; _buffer != NULL) || (_size == 0 &amp;&amp; _buffer == NULL), &quot;sanity check&quot;);</span>
<span class="line-modified"> 461   _pos = 0;</span>
<span class="line-modified"> 462   _error = NULL;</span>
<span class="line-modified"> 463   _bytes_written = 0L;</span>
<span class="line-modified"> 464   _dump_start = (jlong)-1;</span>
<span class="line-modified"> 465   _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467   // if the open failed we record the error</span>
<span class="line-modified"> 468   if (_fd &lt; 0) {</span>
<span class="line-modified"> 469     _error = (char*)os::strdup(os::strerror(errno));</span>
 470   }
 471 }
 472 
 473 DumpWriter::~DumpWriter() {
<span class="line-modified"> 474   // flush and close dump file</span>
<span class="line-modified"> 475   if (is_open()) {</span>
<span class="line-modified"> 476     close();</span>
<span class="line-removed"> 477   }</span>
<span class="line-removed"> 478   if (_buffer != NULL) os::free(_buffer);</span>
<span class="line-removed"> 479   if (_error != NULL) os::free(_error);</span>
 480 }
 481 
 482 // closes dump file (if open)
 483 void DumpWriter::close() {
 484   // flush and close dump file
 485   if (is_open()) {
 486     flush();
 487     os::close(file_descriptor());
 488     set_file_descriptor(-1);
 489   }
 490 }
 491 
<span class="line-removed"> 492 // sets the dump starting position</span>
<span class="line-removed"> 493 void DumpWriter::set_dump_start(jlong pos) {</span>
<span class="line-removed"> 494   _dump_start = pos;</span>
<span class="line-removed"> 495 }</span>
<span class="line-removed"> 496 </span>
<span class="line-removed"> 497 julong DumpWriter::current_record_length() {</span>
<span class="line-removed"> 498   if (is_open()) {</span>
<span class="line-removed"> 499     // calculate the size of the dump record</span>
<span class="line-removed"> 500     julong dump_end = bytes_written() + bytes_unwritten();</span>
<span class="line-removed"> 501     assert(dump_end == (size_t)current_offset(), &quot;checking&quot;);</span>
<span class="line-removed"> 502     julong dump_len = dump_end - dump_start() - 4;</span>
<span class="line-removed"> 503     return dump_len;</span>
<span class="line-removed"> 504   }</span>
<span class="line-removed"> 505   return 0;</span>
<span class="line-removed"> 506 }</span>
<span class="line-removed"> 507 </span>
 508 // write directly to the file
 509 void DumpWriter::write_internal(void* s, size_t len) {
 510   if (is_open()) {
 511     const char* pos = (char*)s;
 512     ssize_t n = 0;
 513     while (len &gt; 0) {
<span class="line-modified"> 514       uint tmp = (uint)MIN2(len, (size_t)UINT_MAX);</span>
 515       n = os::write(file_descriptor(), pos, tmp);
 516 
 517       if (n &lt; 0) {
 518         // EINTR cannot happen here, os::write will take care of that
 519         set_error(os::strerror(errno));
 520         os::close(file_descriptor());
 521         set_file_descriptor(-1);
 522         return;
 523       }
 524 
 525       _bytes_written += n;
 526       pos += n;
 527       len -= n;
 528     }
 529   }
 530 }
 531 
 532 // write raw bytes
 533 void DumpWriter::write_raw(void* s, size_t len) {
<span class="line-modified"> 534   if (is_open()) {</span>
<span class="line-modified"> 535     // flush buffer to make room</span>
<span class="line-removed"> 536     if ((position() + len) &gt;= buffer_size()) {</span>
<span class="line-removed"> 537       flush();</span>
<span class="line-removed"> 538     }</span>
 539 
<span class="line-modified"> 540     // buffer not available or too big to buffer it</span>
<span class="line-modified"> 541     if ((buffer() == NULL) || (len &gt;= buffer_size())) {</span>





 542       write_internal(s, len);
<span class="line-modified"> 543     } else {</span>
<span class="line-modified"> 544       // Should optimize this for u1/u2/u4/u8 sizes.</span>
<span class="line-removed"> 545       memcpy(buffer() + position(), s, len);</span>
<span class="line-removed"> 546       set_position(position() + len);</span>
 547     }
 548   }



 549 }
 550 
 551 // flush any buffered bytes to the file
 552 void DumpWriter::flush() {
<span class="line-modified"> 553   if (is_open() &amp;&amp; position() &gt; 0) {</span>
<span class="line-modified"> 554     write_internal(buffer(), position());</span>
<span class="line-removed"> 555     set_position(0);</span>
<span class="line-removed"> 556   }</span>
<span class="line-removed"> 557 }</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559 jlong DumpWriter::current_offset() {</span>
<span class="line-removed"> 560   if (is_open()) {</span>
<span class="line-removed"> 561     // the offset is the file offset plus whatever we have buffered</span>
<span class="line-removed"> 562     jlong offset = os::current_file_offset(file_descriptor());</span>
<span class="line-removed"> 563     assert(offset &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed"> 564     return offset + position();</span>
<span class="line-removed"> 565   } else {</span>
<span class="line-removed"> 566     return (jlong)-1;</span>
<span class="line-removed"> 567   }</span>
<span class="line-removed"> 568 }</span>
<span class="line-removed"> 569 </span>
<span class="line-removed"> 570 void DumpWriter::seek_to_offset(jlong off) {</span>
<span class="line-removed"> 571   assert(off &gt;= 0, &quot;bad offset&quot;);</span>
<span class="line-removed"> 572 </span>
<span class="line-removed"> 573   // need to flush before seeking</span>
<span class="line-removed"> 574   flush();</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576   // may be closed due to I/O error</span>
<span class="line-removed"> 577   if (is_open()) {</span>
<span class="line-removed"> 578     jlong n = os::seek_to_file_offset(file_descriptor(), off);</span>
<span class="line-removed"> 579     assert(n &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed"> 580   }</span>
 581 }
 582 
 583 void DumpWriter::write_u2(u2 x) {
 584   u2 v;
 585   Bytes::put_Java_u2((address)&amp;v, x);
 586   write_raw((void*)&amp;v, 2);
 587 }
 588 
 589 void DumpWriter::write_u4(u4 x) {
 590   u4 v;
 591   Bytes::put_Java_u4((address)&amp;v, x);
 592   write_raw((void*)&amp;v, 4);
 593 }
 594 
 595 void DumpWriter::write_u8(u8 x) {
 596   u8 v;
 597   Bytes::put_Java_u8((address)&amp;v, x);
 598   write_raw((void*)&amp;v, 8);
 599 }
 600 
 601 void DumpWriter::write_objectID(oop o) {
<span class="line-modified"> 602   address a = (address)o;</span>
 603 #ifdef _LP64
 604   write_u8((u8)a);
 605 #else
 606   write_u4((u4)a);
 607 #endif
 608 }
 609 
 610 void DumpWriter::write_symbolID(Symbol* s) {
 611   address a = (address)((uintptr_t)s);
 612 #ifdef _LP64
 613   write_u8((u8)a);
 614 #else
 615   write_u4((u4)a);
 616 #endif
 617 }
 618 
 619 void DumpWriter::write_id(u4 x) {
 620 #ifdef _LP64
 621   write_u8((u8) x);
 622 #else
 623   write_u4(x);
 624 #endif
 625 }
 626 
 627 // We use java mirror as the class ID
 628 void DumpWriter::write_classID(Klass* k) {
 629   write_objectID(k-&gt;java_mirror());
 630 }
 631 













































 632 






 633 
 634 // Support class with a collection of functions used when dumping the heap
 635 
 636 class DumperSupport : AllStatic {
 637  public:
 638 
 639   // write a header of the given type
 640   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 641 
 642   // returns hprof tag for the given type signature
 643   static hprofTag sig2tag(Symbol* sig);
 644   // returns hprof tag for the given basic type
 645   static hprofTag type2tag(BasicType type);


 646 
 647   // returns the size of the instance of the given class
 648   static u4 instance_size(Klass* k);
 649 
 650   // dump a jfloat
 651   static void dump_float(DumpWriter* writer, jfloat f);
 652   // dump a jdouble
 653   static void dump_double(DumpWriter* writer, jdouble d);
 654   // dumps the raw value of the given field
 655   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);


 656   // dumps static fields of the given class
 657   static void dump_static_fields(DumpWriter* writer, Klass* k);
 658   // dump the raw values of the instance fields of the given object
 659   static void dump_instance_fields(DumpWriter* writer, oop o);


 660   // dumps the definition of the instance fields for a given class
 661   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 662   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 663   static void dump_instance(DumpWriter* writer, oop o);
 664   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 665   // array classes
 666   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 667   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 668   // class (and each multi-dimensional array class too)
 669   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 670 
 671   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 672   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 673   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 674   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 675   // create HPROF_FRAME record for the given method and bci
 676   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 677 
 678   // check if we need to truncate an array
 679   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 680 
<span class="line-removed"> 681   // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed"> 682   static void write_dump_header(DumpWriter* writer);</span>
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684   // fixes up the length of the current dump record</span>
<span class="line-removed"> 685   static void write_current_dump_record_length(DumpWriter* writer);</span>
<span class="line-removed"> 686 </span>
 687   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 688   static void end_of_dump(DumpWriter* writer);










 689 };
 690 
 691 // write a header of the given type
 692 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 693   writer-&gt;write_u1((u1)tag);
 694   writer-&gt;write_u4(0);                  // current ticks
 695   writer-&gt;write_u4(len);
 696 }
 697 
 698 // returns hprof tag for the given type signature
 699 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 700   switch (sig-&gt;char_at(0)) {
 701     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 702     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 703     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 704     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 705     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 706     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 707     case JVM_SIGNATURE_INT      : return HPROF_INT;
 708     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 709     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 710     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 711     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 712   }
 713 }
 714 
 715 hprofTag DumperSupport::type2tag(BasicType type) {
 716   switch (type) {
 717     case T_BYTE     : return HPROF_BYTE;
 718     case T_CHAR     : return HPROF_CHAR;
 719     case T_FLOAT    : return HPROF_FLOAT;
 720     case T_DOUBLE   : return HPROF_DOUBLE;
 721     case T_INT      : return HPROF_INT;
 722     case T_LONG     : return HPROF_LONG;
 723     case T_SHORT    : return HPROF_SHORT;
 724     case T_BOOLEAN  : return HPROF_BOOLEAN;
 725     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 726   }
 727 }
 728 
















 729 // dump a jfloat
 730 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 731   if (g_isnan(f)) {
 732     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 733   } else {
 734     union {
 735       int i;
 736       float f;
 737     } u;
 738     u.f = (float)f;
 739     writer-&gt;write_u4((u4)u.i);
 740   }
 741 }
 742 
 743 // dump a jdouble
 744 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 745   union {
 746     jlong l;
 747     double d;
 748   } u;
 749   if (g_isnan(d)) {                 // collapsing NaNs
 750     u.l = (jlong)(0x7ff80000);
 751     u.l = (u.l &lt;&lt; 32);
 752   } else {
 753     u.d = (double)d;
 754   }
 755   writer-&gt;write_u8((u8)u.l);
 756 }
 757 
 758 // dumps the raw value of the given field
 759 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 760   switch (type) {
 761     case JVM_SIGNATURE_CLASS :
 762     case JVM_SIGNATURE_ARRAY : {
<span class="line-modified"> 763       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF&gt;(offset);</span>







 764       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 765       writer-&gt;write_objectID(o);
 766       break;
 767     }
 768     case JVM_SIGNATURE_BYTE : {
 769       jbyte b = obj-&gt;byte_field(offset);
 770       writer-&gt;write_u1((u1)b);
 771       break;
 772     }
 773     case JVM_SIGNATURE_CHAR : {
 774       jchar c = obj-&gt;char_field(offset);
 775       writer-&gt;write_u2((u2)c);
 776       break;
 777     }
 778     case JVM_SIGNATURE_SHORT : {
 779       jshort s = obj-&gt;short_field(offset);
 780       writer-&gt;write_u2((u2)s);
 781       break;
 782     }
 783     case JVM_SIGNATURE_FLOAT : {
</pre>
<hr />
<pre>
 799       jlong l = obj-&gt;long_field(offset);
 800       writer-&gt;write_u8((u8)l);
 801       break;
 802     }
 803     case JVM_SIGNATURE_BOOLEAN : {
 804       jboolean b = obj-&gt;bool_field(offset);
 805       writer-&gt;write_u1((u1)b);
 806       break;
 807     }
 808     default : {
 809       ShouldNotReachHere();
 810       break;
 811     }
 812   }
 813 }
 814 
 815 // returns the size of the instance of the given class
 816 u4 DumperSupport::instance_size(Klass* k) {
 817   HandleMark hm;
 818   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-removed"> 819 </span>
 820   u4 size = 0;
 821 
 822   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 823     if (!fld.access_flags().is_static()) {
<span class="line-modified"> 824       Symbol* sig = fld.signature();</span>
<span class="line-removed"> 825       switch (sig-&gt;char_at(0)) {</span>
<span class="line-removed"> 826         case JVM_SIGNATURE_CLASS   :</span>
<span class="line-removed"> 827         case JVM_SIGNATURE_ARRAY   : size += oopSize; break;</span>
<span class="line-removed"> 828 </span>
<span class="line-removed"> 829         case JVM_SIGNATURE_BYTE    :</span>
<span class="line-removed"> 830         case JVM_SIGNATURE_BOOLEAN : size += 1; break;</span>
<span class="line-removed"> 831 </span>
<span class="line-removed"> 832         case JVM_SIGNATURE_CHAR    :</span>
<span class="line-removed"> 833         case JVM_SIGNATURE_SHORT   : size += 2; break;</span>
<span class="line-removed"> 834 </span>
<span class="line-removed"> 835         case JVM_SIGNATURE_INT     :</span>
<span class="line-removed"> 836         case JVM_SIGNATURE_FLOAT   : size += 4; break;</span>
<span class="line-removed"> 837 </span>
<span class="line-removed"> 838         case JVM_SIGNATURE_LONG    :</span>
<span class="line-removed"> 839         case JVM_SIGNATURE_DOUBLE  : size += 8; break;</span>
<span class="line-removed"> 840 </span>
<span class="line-removed"> 841         default : ShouldNotReachHere();</span>
<span class="line-removed"> 842       }</span>
 843     }
 844   }
 845   return size;
 846 }
 847 
<span class="line-modified"> 848 // dumps static fields of the given class</span>
<span class="line-removed"> 849 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
 850   HandleMark hm;
<span class="line-modified"> 851   InstanceKlass* ik = InstanceKlass::cast(k);</span>

 852 
<span class="line-removed"> 853   // pass 1 - count the static fields</span>
<span class="line-removed"> 854   u2 field_count = 0;</span>
 855   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<span class="line-modified"> 856     if (fldc.access_flags().is_static()) field_count++;</span>



 857   }
 858 
 859   // Add in resolved_references which is referenced by the cpCache
 860   // The resolved_references is an array per InstanceKlass holding the
 861   // strings and other oops resolved from the constant pool.
 862   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 863   if (resolved_references != NULL) {
 864     field_count++;

 865 
 866     // Add in the resolved_references of the used previous versions of the class
 867     // in the case of RedefineClasses
 868     InstanceKlass* prev = ik-&gt;previous_versions();
 869     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 870       field_count++;

 871       prev = prev-&gt;previous_versions();
 872     }
 873   }
 874 
 875   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 876   // arrays.
 877   oop init_lock = ik-&gt;init_lock();
 878   if (init_lock != NULL) {
 879     field_count++;

 880   }
 881 
<span class="line-modified"> 882   writer-&gt;write_u2(field_count);</span>


 883 
<span class="line-modified"> 884   // pass 2 - dump the field descriptors and raw values</span>





 885   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 886     if (fld.access_flags().is_static()) {
 887       Symbol* sig = fld.signature();
 888 
 889       writer-&gt;write_symbolID(fld.name());   // name
 890       writer-&gt;write_u1(sig2tag(sig));       // type
 891 
 892       // value
 893       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 894     }
 895   }
 896 
 897   // Add resolved_references for each class that has them

 898   if (resolved_references != NULL) {
 899     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 900     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 901     writer-&gt;write_objectID(resolved_references);
 902 
 903     // Also write any previous versions
 904     InstanceKlass* prev = ik-&gt;previous_versions();
 905     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 906       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 907       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 908       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 909       prev = prev-&gt;previous_versions();
 910     }
 911   }
 912 
 913   // Add init lock to the end if the class is not yet initialized

 914   if (init_lock != NULL) {
 915     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 916     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 917     writer-&gt;write_objectID(init_lock);
 918   }
 919 }
 920 
 921 // dump the raw values of the instance fields of the given object
 922 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
 923   HandleMark hm;
 924   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 925 
 926   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 927     if (!fld.access_flags().is_static()) {
 928       Symbol* sig = fld.signature();
 929       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 930     }
 931   }
 932 }
 933 
 934 // dumps the definition of the instance fields for a given class
<span class="line-modified"> 935 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
 936   HandleMark hm;
<span class="line-removed"> 937   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-removed"> 938 </span>
<span class="line-removed"> 939   // pass 1 - count the instance fields</span>
 940   u2 field_count = 0;

 941   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 942     if (!fldc.access_flags().is_static()) field_count++;
 943   }
 944 
<span class="line-modified"> 945   writer-&gt;write_u2(field_count);</span>






 946 
<span class="line-modified"> 947   // pass 2 - dump the field descriptors</span>
 948   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 949     if (!fld.access_flags().is_static()) {
 950       Symbol* sig = fld.signature();
 951 
 952       writer-&gt;write_symbolID(fld.name());   // name
 953       writer-&gt;write_u1(sig2tag(sig));       // type
 954     }
 955   }
 956 }
 957 
 958 // creates HPROF_GC_INSTANCE_DUMP record for the given object
 959 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<span class="line-modified"> 960   Klass* k = o-&gt;klass();</span>


 961 
<span class="line-modified"> 962   writer-&gt;write_u1(HPROF_GC_INSTANCE_DUMP);</span>
 963   writer-&gt;write_objectID(o);
 964   writer-&gt;write_u4(STACK_TRACE_ID);
 965 
 966   // class ID
<span class="line-modified"> 967   writer-&gt;write_classID(k);</span>
 968 
 969   // number of bytes that follow
<span class="line-modified"> 970   writer-&gt;write_u4(instance_size(k) );</span>
 971 
 972   // field values
 973   dump_instance_fields(writer, o);


 974 }
 975 
 976 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
 977 // its array classes
 978 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
 979   InstanceKlass* ik = InstanceKlass::cast(k);
 980 
 981   // We can safepoint and do a heap dump at a point where we have a Klass,
 982   // but no java mirror class has been setup for it. So we need to check
 983   // that the class is at least loaded, to avoid crash from a null mirror.
 984   if (!ik-&gt;is_loaded()) {
 985     return;
 986   }
 987 
<span class="line-modified"> 988   writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>






 989 
 990   // class ID
 991   writer-&gt;write_classID(ik);
 992   writer-&gt;write_u4(STACK_TRACE_ID);
 993 
 994   // super class ID
 995   InstanceKlass* java_super = ik-&gt;java_super();
 996   if (java_super == NULL) {
 997     writer-&gt;write_objectID(oop(NULL));
 998   } else {
 999     writer-&gt;write_classID(java_super);
1000   }
1001 
1002   writer-&gt;write_objectID(ik-&gt;class_loader());
1003   writer-&gt;write_objectID(ik-&gt;signers());
1004   writer-&gt;write_objectID(ik-&gt;protection_domain());
1005 
1006   // reserved
1007   writer-&gt;write_objectID(oop(NULL));
1008   writer-&gt;write_objectID(oop(NULL));
1009 
1010   // instance size
<span class="line-modified">1011   writer-&gt;write_u4(DumperSupport::instance_size(k));</span>
1012 
1013   // size of constant pool - ignored by HAT 1.1
1014   writer-&gt;write_u2(0);
1015 
<span class="line-modified">1016   // number of static fields</span>
<span class="line-modified">1017   dump_static_fields(writer, k);</span>

1018 
1019   // description of instance fields
<span class="line-modified">1020   dump_instance_field_descriptors(writer, k);</span>



1021 
1022   // array classes
<span class="line-modified">1023   k = k-&gt;array_klass_or_null();</span>
1024   while (k != NULL) {
<span class="line-modified">1025     Klass* klass = k;</span>
<span class="line-removed">1026     assert(klass-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>
1027 
<span class="line-modified">1028     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>
<span class="line-modified">1029     writer-&gt;write_classID(klass);</span>

1030     writer-&gt;write_u4(STACK_TRACE_ID);
1031 
1032     // super class of array classes is java.lang.Object
<span class="line-modified">1033     java_super = klass-&gt;java_super();</span>
1034     assert(java_super != NULL, &quot;checking&quot;);
1035     writer-&gt;write_classID(java_super);
1036 
1037     writer-&gt;write_objectID(ik-&gt;class_loader());
1038     writer-&gt;write_objectID(ik-&gt;signers());
1039     writer-&gt;write_objectID(ik-&gt;protection_domain());
1040 
1041     writer-&gt;write_objectID(oop(NULL));    // reserved
1042     writer-&gt;write_objectID(oop(NULL));
1043     writer-&gt;write_u4(0);             // instance size
1044     writer-&gt;write_u2(0);             // constant pool
1045     writer-&gt;write_u2(0);             // static fields
1046     writer-&gt;write_u2(0);             // instance fields
1047 


1048     // get the array class for the next rank
<span class="line-modified">1049     k = klass-&gt;array_klass_or_null();</span>
1050   }
1051 }
1052 
1053 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1054 // class (and each multi-dimensional array class too)
1055 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1056  // array classes
1057  while (k != NULL) {
1058     Klass* klass = k;
1059 
<span class="line-modified">1060     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>

1061     writer-&gt;write_classID(klass);
1062     writer-&gt;write_u4(STACK_TRACE_ID);
1063 
1064     // super class of array classes is java.lang.Object
1065     InstanceKlass* java_super = klass-&gt;java_super();
1066     assert(java_super != NULL, &quot;checking&quot;);
1067     writer-&gt;write_classID(java_super);
1068 
1069     writer-&gt;write_objectID(oop(NULL));    // loader
1070     writer-&gt;write_objectID(oop(NULL));    // signers
1071     writer-&gt;write_objectID(oop(NULL));    // protection domain
1072 
1073     writer-&gt;write_objectID(oop(NULL));    // reserved
1074     writer-&gt;write_objectID(oop(NULL));
1075     writer-&gt;write_u4(0);             // instance size
1076     writer-&gt;write_u2(0);             // constant pool
1077     writer-&gt;write_u2(0);             // static fields
1078     writer-&gt;write_u2(0);             // instance fields
1079 


1080     // get the array class for the next rank
1081     k = klass-&gt;array_klass_or_null();
1082   }
1083 }
1084 
1085 // Hprof uses an u4 as record length field,
1086 // which means we need to truncate arrays that are too long.
1087 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1088   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1089   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1090 
1091   int length = array-&gt;length();
1092 
1093   int type_size;
1094   if (type == T_OBJECT) {
1095     type_size = sizeof(address);
1096   } else {
1097     type_size = type2aelembytes(type);
1098   }
1099 
1100   size_t length_in_bytes = (size_t)length * type_size;

1101 
<span class="line-removed">1102   // Create a new record if the current record is non-empty and the array can&#39;t fit.</span>
<span class="line-removed">1103   julong current_record_length = writer-&gt;current_record_length();</span>
<span class="line-removed">1104   if (current_record_length &gt; 0 &amp;&amp;</span>
<span class="line-removed">1105       (current_record_length + header_size + length_in_bytes) &gt; max_juint) {</span>
<span class="line-removed">1106     write_current_dump_record_length(writer);</span>
<span class="line-removed">1107     write_dump_header(writer);</span>
<span class="line-removed">1108 </span>
<span class="line-removed">1109     // We now have an empty record.</span>
<span class="line-removed">1110     current_record_length = 0;</span>
<span class="line-removed">1111   }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113   // Calculate max bytes we can use.</span>
<span class="line-removed">1114   uint max_bytes = max_juint - (header_size + current_record_length);</span>
<span class="line-removed">1115 </span>
<span class="line-removed">1116   // Array too long for the record?</span>
<span class="line-removed">1117   // Calculate max length and return it.</span>
1118   if (length_in_bytes &gt; max_bytes) {
1119     length = max_bytes / type_size;
1120     length_in_bytes = (size_t)length * type_size;
1121 
1122     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1123             type2name_tab[type], array-&gt;length(), length);
1124   }
1125   return length;
1126 }
1127 
1128 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1129 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1130   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1131   short header_size = 1 + 2 * 4 + 2 * sizeof(address);
<span class="line-removed">1132 </span>
1133   int length = calculate_array_max_length(writer, array, header_size);

1134 
<span class="line-modified">1135   writer-&gt;write_u1(HPROF_GC_OBJ_ARRAY_DUMP);</span>
1136   writer-&gt;write_objectID(array);
1137   writer-&gt;write_u4(STACK_TRACE_ID);
1138   writer-&gt;write_u4(length);
1139 
1140   // array class ID
1141   writer-&gt;write_classID(array-&gt;klass());
1142 
1143   // [id]* elements
1144   for (int index = 0; index &lt; length; index++) {
1145     oop o = array-&gt;obj_at(index);







1146     writer-&gt;write_objectID(o);
1147   }


1148 }
1149 
1150 #define WRITE_ARRAY(Array, Type, Size, Length) \
1151   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1152 
1153 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1154 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1155   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1156 
1157   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1158   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1159 
1160   int length = calculate_array_max_length(writer, array, header_size);
1161   int type_size = type2aelembytes(type);
1162   u4 length_in_bytes = (u4)length * type_size;

1163 
<span class="line-modified">1164   writer-&gt;write_u1(HPROF_GC_PRIM_ARRAY_DUMP);</span>
1165   writer-&gt;write_objectID(array);
1166   writer-&gt;write_u4(STACK_TRACE_ID);
1167   writer-&gt;write_u4(length);
1168   writer-&gt;write_u1(type2tag(type));
1169 
1170   // nothing to copy
1171   if (length == 0) {

1172     return;
1173   }
1174 
1175   // If the byte ordering is big endian then we can copy most types directly
1176 
1177   switch (type) {
1178     case T_INT : {
1179       if (Endian::is_Java_byte_ordering_different()) {
1180         WRITE_ARRAY(array, int, u4, length);
1181       } else {
1182         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1183       }
1184       break;
1185     }
1186     case T_BYTE : {
1187       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1188       break;
1189     }
1190     case T_CHAR : {
1191       if (Endian::is_Java_byte_ordering_different()) {
</pre>
<hr />
<pre>
1221     }
1222 
1223     // handle float/doubles in a special value to ensure than NaNs are
1224     // written correctly. TO DO: Check if we can avoid this on processors that
1225     // use IEEE 754.
1226 
1227     case T_FLOAT : {
1228       for (int i = 0; i &lt; length; i++) {
1229         dump_float(writer, array-&gt;float_at(i));
1230       }
1231       break;
1232     }
1233     case T_DOUBLE : {
1234       for (int i = 0; i &lt; length; i++) {
1235         dump_double(writer, array-&gt;double_at(i));
1236       }
1237       break;
1238     }
1239     default : ShouldNotReachHere();
1240   }


1241 }
1242 
1243 // create a HPROF_FRAME record of the given Method* and bci
1244 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1245                                      int frame_serial_num,
1246                                      int class_serial_num,
1247                                      Method* m,
1248                                      int bci) {
1249   int line_number;
1250   if (m-&gt;is_native()) {
1251     line_number = -3;  // native frame
1252   } else {
1253     line_number = m-&gt;line_number_from_bci(bci);
1254   }
1255 
1256   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1257   writer-&gt;write_id(frame_serial_num);               // frame serial number
1258   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1259   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1260 
</pre>
<hr />
<pre>
1296   DumpWriter* _writer;
1297   u4 _thread_serial_num;
1298   int _frame_num;
1299   DumpWriter* writer() const                { return _writer; }
1300  public:
1301   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1302     _writer = writer;
1303     _thread_serial_num = thread_serial_num;
1304     _frame_num = -1;  // default - empty stack
1305   }
1306   void set_frame_number(int n) { _frame_num = n; }
1307   void do_oop(oop* obj_p);
1308   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1309 };
1310 
1311 
1312 void JNILocalsDumper::do_oop(oop* obj_p) {
1313   // ignore null handles
1314   oop o = *obj_p;
1315   if (o != NULL) {
<span class="line-modified">1316     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_LOCAL);</span>

1317     writer()-&gt;write_objectID(o);
1318     writer()-&gt;write_u4(_thread_serial_num);
1319     writer()-&gt;write_u4((u4)_frame_num);

1320   }
1321 }
1322 
1323 
1324 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1325 
1326 class JNIGlobalsDumper : public OopClosure {
1327  private:
1328   DumpWriter* _writer;
1329   DumpWriter* writer() const                { return _writer; }
1330 
1331  public:
1332   JNIGlobalsDumper(DumpWriter* writer) {
1333     _writer = writer;
1334   }
1335   void do_oop(oop* obj_p);
1336   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1337 };
1338 
1339 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1340   oop o = *obj_p;
1341 
1342   // ignore these
1343   if (o == NULL) return;
1344 
1345   // we ignore global ref to symbols and other internal objects
1346   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<span class="line-modified">1347     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_GLOBAL);</span>

1348     writer()-&gt;write_objectID(o);
1349     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID

1350   }
1351 };
1352 
1353 
1354 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1355 
1356 class MonitorUsedDumper : public OopClosure {
1357  private:
1358   DumpWriter* _writer;
1359   DumpWriter* writer() const                { return _writer; }
1360  public:
1361   MonitorUsedDumper(DumpWriter* writer) {
1362     _writer = writer;
1363   }
1364   void do_oop(oop* obj_p) {
<span class="line-modified">1365     writer()-&gt;write_u1(HPROF_GC_ROOT_MONITOR_USED);</span>

1366     writer()-&gt;write_objectID(*obj_p);

1367   }
1368   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1369 };
1370 
1371 
1372 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1373 
1374 class StickyClassDumper : public KlassClosure {
1375  private:
1376   DumpWriter* _writer;
1377   DumpWriter* writer() const                { return _writer; }
1378  public:
1379   StickyClassDumper(DumpWriter* writer) {
1380     _writer = writer;
1381   }
1382   void do_klass(Klass* k) {
1383     if (k-&gt;is_instance_klass()) {
1384       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1385         writer()-&gt;write_u1(HPROF_GC_ROOT_STICKY_CLASS);</span>
<span class="line-modified">1386         writer()-&gt;write_classID(ik);</span>
<span class="line-modified">1387       }</span>

1388     }

1389 };
1390 
1391 
1392 class VM_HeapDumper;
1393 
1394 // Support class using when iterating over the heap.
1395 
1396 class HeapObjectDumper : public ObjectClosure {
1397  private:
1398   VM_HeapDumper* _dumper;
1399   DumpWriter* _writer;
1400 
1401   VM_HeapDumper* dumper()               { return _dumper; }
1402   DumpWriter* writer()                  { return _writer; }
1403 
<span class="line-removed">1404   // used to indicate that a record has been writen</span>
<span class="line-removed">1405   void mark_end_of_record();</span>
<span class="line-removed">1406 </span>
1407  public:
1408   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1409     _dumper = dumper;
1410     _writer = writer;
1411   }
1412 
1413   // called for each object in the heap
1414   void do_object(oop o);
1415 };
1416 
1417 void HeapObjectDumper::do_object(oop o) {
1418   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1419   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1420     if (!java_lang_Class::is_primitive(o)) {
1421       return;
1422     }
1423   }
1424 





1425   if (o-&gt;is_instance()) {
1426     // create a HPROF_GC_INSTANCE record for each object
1427     DumperSupport::dump_instance(writer(), o);
<span class="line-removed">1428     mark_end_of_record();</span>
1429   } else if (o-&gt;is_objArray()) {
1430     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1431     DumperSupport::dump_object_array(writer(), objArrayOop(o));
<span class="line-removed">1432     mark_end_of_record();</span>
1433   } else if (o-&gt;is_typeArray()) {
1434     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1435     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
<span class="line-removed">1436     mark_end_of_record();</span>
1437   }
1438 }
1439 
1440 // The VM operation that performs the heap dump
1441 class VM_HeapDumper : public VM_GC_Operation {
1442  private:
1443   static VM_HeapDumper* _global_dumper;
1444   static DumpWriter*    _global_writer;
1445   DumpWriter*           _local_writer;
1446   JavaThread*           _oome_thread;
1447   Method*               _oome_constructor;
1448   bool _gc_before_heap_dump;
1449   GrowableArray&lt;Klass*&gt;* _klass_map;
1450   ThreadStackTrace** _stack_traces;
1451   int _num_threads;
1452 
1453   // accessors and setters
1454   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1455   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1456   void set_global_dumper() {
</pre>
<hr />
<pre>
1507       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1508                                                           vmSymbols::void_method_signature());
1509       // get thread throwing OOME when generating the heap dump at OOME
1510       _oome_thread = JavaThread::current();
1511     } else {
1512       _oome_thread = NULL;
1513       _oome_constructor = NULL;
1514     }
1515   }
1516   ~VM_HeapDumper() {
1517     if (_stack_traces != NULL) {
1518       for (int i=0; i &lt; _num_threads; i++) {
1519         delete _stack_traces[i];
1520       }
1521       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1522     }
1523     delete _klass_map;
1524   }
1525 
1526   VMOp_Type type() const { return VMOp_HeapDumper; }
<span class="line-removed">1527   // used to mark sub-record boundary</span>
<span class="line-removed">1528   void check_segment_length();</span>
1529   void doit();
1530 };
1531 
1532 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1533 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1534 
1535 bool VM_HeapDumper::skip_operation() const {
1536   return false;
1537 }
1538 
<span class="line-removed">1539  // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed">1540 void DumperSupport::write_dump_header(DumpWriter* writer) {</span>
<span class="line-removed">1541   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1542     writer-&gt;write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-removed">1543     writer-&gt;write_u4(0); // current ticks</span>
<span class="line-removed">1544 </span>
<span class="line-removed">1545     // record the starting position for the dump (its length will be fixed up later)</span>
<span class="line-removed">1546     writer-&gt;set_dump_start(writer-&gt;current_offset());</span>
<span class="line-removed">1547     writer-&gt;write_u4(0);</span>
<span class="line-removed">1548   }</span>
<span class="line-removed">1549 }</span>
<span class="line-removed">1550 </span>
<span class="line-removed">1551 // fixes up the length of the current dump record</span>
<span class="line-removed">1552 void DumperSupport::write_current_dump_record_length(DumpWriter* writer) {</span>
<span class="line-removed">1553   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1554     julong dump_end = writer-&gt;bytes_written() + writer-&gt;bytes_unwritten();</span>
<span class="line-removed">1555     julong dump_len = writer-&gt;current_record_length();</span>
<span class="line-removed">1556 </span>
<span class="line-removed">1557     // record length must fit in a u4</span>
<span class="line-removed">1558     if (dump_len &gt; max_juint) {</span>
<span class="line-removed">1559       warning(&quot;record is too large&quot;);</span>
<span class="line-removed">1560     }</span>
<span class="line-removed">1561 </span>
<span class="line-removed">1562     // seek to the dump start and fix-up the length</span>
<span class="line-removed">1563     assert(writer-&gt;dump_start() &gt;= 0, &quot;no dump start recorded&quot;);</span>
<span class="line-removed">1564     writer-&gt;seek_to_offset(writer-&gt;dump_start());</span>
<span class="line-removed">1565     writer-&gt;write_u4((u4)dump_len);</span>
<span class="line-removed">1566 </span>
<span class="line-removed">1567     // adjust the total size written to keep the bytes written correct.</span>
<span class="line-removed">1568     writer-&gt;adjust_bytes_written(-((jlong) sizeof(u4)));</span>
<span class="line-removed">1569 </span>
<span class="line-removed">1570     // seek to dump end so we can continue</span>
<span class="line-removed">1571     writer-&gt;seek_to_offset(dump_end);</span>
<span class="line-removed">1572 </span>
<span class="line-removed">1573     // no current dump record</span>
<span class="line-removed">1574     writer-&gt;set_dump_start((jlong)-1);</span>
<span class="line-removed">1575   }</span>
<span class="line-removed">1576 }</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578 // used on a sub-record boundary to check if we need to start a</span>
<span class="line-removed">1579 // new segment.</span>
<span class="line-removed">1580 void VM_HeapDumper::check_segment_length() {</span>
<span class="line-removed">1581   if (writer()-&gt;is_open()) {</span>
<span class="line-removed">1582     julong dump_len = writer()-&gt;current_record_length();</span>
<span class="line-removed">1583 </span>
<span class="line-removed">1584     if (dump_len &gt; 2UL*G) {</span>
<span class="line-removed">1585       DumperSupport::write_current_dump_record_length(writer());</span>
<span class="line-removed">1586       DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">1587     }</span>
<span class="line-removed">1588   }</span>
<span class="line-removed">1589 }</span>
<span class="line-removed">1590 </span>
1591 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1592 void DumperSupport::end_of_dump(DumpWriter* writer) {
<span class="line-modified">1593   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1594     write_current_dump_record_length(writer);</span>
<span class="line-removed">1595 </span>
<span class="line-removed">1596     writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-removed">1597     writer-&gt;write_u4(0);</span>
<span class="line-removed">1598     writer-&gt;write_u4(0);</span>
<span class="line-removed">1599   }</span>
<span class="line-removed">1600 }</span>
1601 
<span class="line-modified">1602 // marks sub-record boundary</span>
<span class="line-modified">1603 void HeapObjectDumper::mark_end_of_record() {</span>
<span class="line-modified">1604   dumper()-&gt;check_segment_length();</span>
1605 }
1606 
1607 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1608 // array classes)
1609 void VM_HeapDumper::do_load_class(Klass* k) {
1610   static u4 class_serial_num = 0;
1611 
1612   // len of HPROF_LOAD_CLASS record
1613   u4 remaining = 2*oopSize + 2*sizeof(u4);
1614 
1615   // write a HPROF_LOAD_CLASS for the class and each array class
1616   do {
1617     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1618 
1619     // class serial number is just a number
1620     writer()-&gt;write_u4(++class_serial_num);
1621 
1622     // class ID
1623     Klass* klass = k;
1624     writer()-&gt;write_classID(klass);
</pre>
<hr />
<pre>
1674     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1675     frame* last_entry_frame = NULL;
1676     int extra_frames = 0;
1677 
1678     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1679       extra_frames++;
1680     }
1681     while (vf != NULL) {
1682       blk.set_frame_number(stack_depth);
1683       if (vf-&gt;is_java_frame()) {
1684 
1685         // java frame (interpreted, compiled, ...)
1686         javaVFrame *jvf = javaVFrame::cast(vf);
1687         if (!(jvf-&gt;method()-&gt;is_native())) {
1688           StackValueCollection* locals = jvf-&gt;locals();
1689           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1690             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1691               oop o = locals-&gt;obj_at(slot)();
1692 
1693               if (o != NULL) {
<span class="line-modified">1694                 writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>

1695                 writer()-&gt;write_objectID(o);
1696                 writer()-&gt;write_u4(thread_serial_num);
1697                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));

1698               }
1699             }
1700           }
1701           StackValueCollection *exprs = jvf-&gt;expressions();
1702           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1703             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1704                oop o = exprs-&gt;obj_at(index)();
1705                if (o != NULL) {
<span class="line-modified">1706                  writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>

1707                  writer()-&gt;write_objectID(o);
1708                  writer()-&gt;write_u4(thread_serial_num);
1709                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));

1710                }
1711              }
1712           }
1713         } else {
1714           // native frame
1715           if (stack_depth == 0) {
1716             // JNI locals for the top frame.
1717             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1718           } else {
1719             if (last_entry_frame != NULL) {
1720               // JNI locals for the entry frame
1721               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1722               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1723             }
1724           }
1725         }
1726         // increment only for Java frames
1727         stack_depth++;
1728         last_entry_frame = NULL;
1729 
</pre>
<hr />
<pre>
1737         }
1738       }
1739       vf = vf-&gt;sender();
1740     }
1741   } else {
1742     // no last java frame but there may be JNI locals
1743     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1744   }
1745   return stack_depth;
1746 }
1747 
1748 
1749 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1750 // the stack so that locals and JNI locals are dumped.
1751 void VM_HeapDumper::do_threads() {
1752   for (int i=0; i &lt; _num_threads; i++) {
1753     JavaThread* thread = _stack_traces[i]-&gt;thread();
1754     oop threadObj = thread-&gt;threadObj();
1755     u4 thread_serial_num = i+1;
1756     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<span class="line-modified">1757     writer()-&gt;write_u1(HPROF_GC_ROOT_THREAD_OBJ);</span>

1758     writer()-&gt;write_objectID(threadObj);
1759     writer()-&gt;write_u4(thread_serial_num);  // thread number
1760     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number

1761     int num_frames = do_thread(thread, thread_serial_num);
1762     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1763            &quot;total number of Java frames not matched&quot;);
1764   }
1765 }
1766 
1767 
1768 // The VM operation that dumps the heap. The dump consists of the following
1769 // records:
1770 //
1771 //  HPROF_HEADER
1772 //  [HPROF_UTF8]*
1773 //  [HPROF_LOAD_CLASS]*
1774 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1775 //  [HPROF_GC_CLASS_DUMP]*
1776 //  [HPROF_HEAP_DUMP_SEGMENT]*
1777 //  HPROF_HEAP_DUMP_END
1778 //
1779 // The HPROF_TRACE records represent the stack traces where the heap dump
1780 // is generated and a &quot;dummy trace&quot; record which does not include
</pre>
<hr />
<pre>
1801     if (GCLocker::is_active()) {
1802       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1803     } else {
1804       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1805     }
1806   }
1807 
1808   // At this point we should be the only dumper active, so
1809   // the following should be safe.
1810   set_global_dumper();
1811   set_global_writer();
1812 
1813   // Write the file header - we always use 1.0.2
1814   size_t used = ch-&gt;used();
1815   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1816 
1817   // header is few bytes long - no chance to overflow int
1818   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1819   writer()-&gt;write_u1(0); // terminator
1820   writer()-&gt;write_u4(oopSize);

1821   writer()-&gt;write_u8(os::javaTimeMillis());
1822 
1823   // HPROF_UTF8 records
1824   SymbolTableDumper sym_dumper(writer());
1825   SymbolTable::symbols_do(&amp;sym_dumper);
1826 
1827   // write HPROF_LOAD_CLASS records
1828   {
1829     LockedClassesDo locked_load_classes(&amp;do_load_class);
1830     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1831   }
1832   Universe::basic_type_classes_do(&amp;do_load_class);
1833 
1834   // write HPROF_FRAME and HPROF_TRACE records
1835   // this must be called after _klass_map is built when iterating the classes above.
1836   dump_stack_traces();
1837 
<span class="line-removed">1838   // write HPROF_HEAP_DUMP_SEGMENT</span>
<span class="line-removed">1839   DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">1840 </span>
1841   // Writes HPROF_GC_CLASS_DUMP records
1842   {
1843     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1844     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1845   }
1846   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
<span class="line-removed">1847   check_segment_length();</span>
1848 
1849   // writes HPROF_GC_INSTANCE_DUMP records.
1850   // After each sub-record is written check_segment_length will be invoked
1851   // to check if the current segment exceeds a threshold. If so, a new
1852   // segment is started.
1853   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1854   // of the heap dump.
1855   HeapObjectDumper obj_dumper(this, writer());
<span class="line-modified">1856   Universe::heap()-&gt;safe_object_iterate(&amp;obj_dumper);</span>
1857 
1858   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1859   do_threads();
<span class="line-removed">1860   check_segment_length();</span>
1861 
1862   // HPROF_GC_ROOT_MONITOR_USED
1863   MonitorUsedDumper mon_dumper(writer());
1864   ObjectSynchronizer::oops_do(&amp;mon_dumper);
<span class="line-removed">1865   check_segment_length();</span>
1866 
1867   // HPROF_GC_ROOT_JNI_GLOBAL
1868   JNIGlobalsDumper jni_dumper(writer());
1869   JNIHandles::oops_do(&amp;jni_dumper);
1870   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1871                                    // for things like preallocated throwable backtraces
<span class="line-removed">1872   check_segment_length();</span>
1873 
1874   // HPROF_GC_ROOT_STICKY_CLASS
1875   // These should be classes in the NULL class loader data, and not all classes
1876   // if !ClassUnloading
1877   StickyClassDumper class_dumper(writer());
1878   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1879 
<span class="line-modified">1880   // fixes up the length of the dump record and writes the HPROF_HEAP_DUMP_END record.</span>
1881   DumperSupport::end_of_dump(writer());
1882 
1883   // Now we clear the global variables, so that a future dumper might run.
1884   clear_global_dumper();
1885   clear_global_writer();
1886 }
1887 
1888 void VM_HeapDumper::dump_stack_traces() {
1889   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1890   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1891   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1892   writer()-&gt;write_u4(0);                    // thread number
1893   writer()-&gt;write_u4(0);                    // frame count
1894 
1895   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1896   int frame_serial_num = 0;
1897   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1898     oop threadObj = thread-&gt;threadObj();
1899     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1900       // dump thread stack trace
</pre>
<hr />
<pre>
1923         // the class serial number starts from 1
1924         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1925         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1926       }
1927       depth += extra_frames;
1928 
1929       // write HPROF_TRACE record for one thread
1930       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1931       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1932       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1933       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1934       writer()-&gt;write_u4(depth);                 // frame count
1935       for (int j=1; j &lt;= depth; j++) {
1936         writer()-&gt;write_id(thread_frame_start + j);
1937       }
1938     }
1939   }
1940 }
1941 
1942 // dump the heap to given path.
<span class="line-modified">1943 int HeapDumper::dump(const char* path) {</span>
1944   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1945 
1946   // print message in interactive case
<span class="line-modified">1947   if (print_to_tty()) {</span>
<span class="line-modified">1948     tty-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
1949     timer()-&gt;start();
1950   }
1951 



1952   // create the dump writer. If the file can be opened then bail
1953   DumpWriter writer(path);
<span class="line-modified">1954   if (!writer.is_open()) {</span>
1955     set_error(writer.error());
<span class="line-modified">1956     if (print_to_tty()) {</span>
<span class="line-modified">1957       tty-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
1958         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1959     }
1960     return -1;
1961   }
1962 
1963   // generate the dump
1964   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1965   if (Thread::current()-&gt;is_VM_thread()) {
1966     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1967     dumper.doit();
1968   } else {
1969     VMThread::execute(&amp;dumper);
1970   }
1971 
1972   // close dump file and record any error that the writer may have encountered
1973   writer.close();
1974   set_error(writer.error());
1975 









1976   // print message in interactive case
<span class="line-modified">1977   if (print_to_tty()) {</span>
1978     timer()-&gt;stop();
1979     if (error() == NULL) {
<span class="line-modified">1980       tty-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
1981                     writer.bytes_written(), timer()-&gt;seconds());
1982     } else {
<span class="line-modified">1983       tty-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
1984     }
1985   }
1986 
1987   return (writer.error() == NULL) ? 0 : -1;
1988 }
1989 
1990 // stop timer (if still active), and free any error string we might be holding
1991 HeapDumper::~HeapDumper() {
1992   if (timer()-&gt;is_active()) {
1993     timer()-&gt;stop();
1994   }
1995   set_error(NULL);
1996 }
1997 
1998 
1999 // returns the error string (resource allocated), or NULL
2000 char* HeapDumper::error_as_C_string() const {
2001   if (error() != NULL) {
2002     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2003     strcpy(str, error());
</pre>
<hr />
<pre>
2091     const size_t len = strlen(base_path) + 1;
2092     my_path = (char*)os::malloc(len, mtInternal);
2093     if (my_path == NULL) {
2094       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2095       return;
2096     }
2097     strncpy(my_path, base_path, len);
2098   } else {
2099     // Append a sequence number id for dumps following the first
2100     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2101     my_path = (char*)os::malloc(len, mtInternal);
2102     if (my_path == NULL) {
2103       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2104       return;
2105     }
2106     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2107   }
2108   dump_file_seq++;   // increment seq number for next time we dump
2109 
2110   HeapDumper dumper(false /* no GC before heap dump */,
<span class="line-removed">2111                     true  /* send to tty */,</span>
2112                     oome  /* pass along out-of-memory-error flag */);
<span class="line-modified">2113   dumper.dump(my_path);</span>
2114   os::free(my_path);
2115 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
<span class="line-added">  35 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/handles.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.hpp&quot;
  47 #include &quot;runtime/os.inline.hpp&quot;
  48 #include &quot;runtime/reflectionUtils.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;runtime/vframe.hpp&quot;
  52 #include &quot;runtime/vmThread.hpp&quot;
  53 #include &quot;runtime/vmOperations.hpp&quot;
  54 #include &quot;services/heapDumper.hpp&quot;
  55 #include &quot;services/threadService.hpp&quot;
</pre>
<hr />
<pre>
 365   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 366   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 367   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 368   HPROF_GC_CLASS_DUMP           = 0x20,
 369   HPROF_GC_INSTANCE_DUMP        = 0x21,
 370   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 371   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 372 } hprofTag;
 373 
 374 // Default stack trace ID (used for dummy HPROF_TRACE record)
 375 enum {
 376   STACK_TRACE_ID = 1,
 377   INITIAL_CLASS_COUNT = 200
 378 };
 379 
 380 // Supports I/O operations on a dump file
 381 
 382 class DumpWriter : public StackObj {
 383  private:
 384   enum {
<span class="line-modified"> 385     io_buffer_max_size = 8*M,</span>
<span class="line-added"> 386     io_buffer_min_size = 64*K,</span>
<span class="line-added"> 387     dump_segment_header_size = 9</span>
 388   };
 389 
 390   int _fd;              // file descriptor (-1 if dump file not open)
 391   julong _bytes_written; // number of byte written to dump file
 392 
 393   char* _buffer;    // internal buffer
 394   size_t _size;
 395   size_t _pos;
 396 
<span class="line-modified"> 397   bool _in_dump_segment; // Are we currently in a dump segment?</span>
<span class="line-added"> 398   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?</span>
<span class="line-added"> 399   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.</span>
<span class="line-added"> 400   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().</span>
 401 
 402   char* _error;   // error message when I/O fails
 403 
 404   void set_file_descriptor(int fd)              { _fd = fd; }
 405   int file_descriptor() const                   { return _fd; }
 406 
<span class="line-added"> 407   bool is_open() const                          { return file_descriptor() &gt;= 0; }</span>
<span class="line-added"> 408   void flush();</span>
<span class="line-added"> 409 </span>
 410   char* buffer() const                          { return _buffer; }
 411   size_t buffer_size() const                    { return _size; }
 412   size_t position() const                       { return _pos; }
 413   void set_position(size_t pos)                 { _pos = pos; }
 414 
 415   void set_error(const char* error)             { _error = (char*)os::strdup(error); }
 416 
 417   // all I/O go through this function
 418   void write_internal(void* s, size_t len);
 419 
 420  public:
 421   DumpWriter(const char* path);
 422   ~DumpWriter();
 423 
 424   void close();






 425 
 426   // total number of bytes written to the disk
 427   julong bytes_written() const          { return _bytes_written; }
 428 







 429   char* error() const                   { return _error; }
 430 



 431   // writer functions
 432   void write_raw(void* s, size_t len);
 433   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
 434   void write_u2(u2 x);
 435   void write_u4(u4 x);
 436   void write_u8(u8 x);
 437   void write_objectID(oop o);
 438   void write_symbolID(Symbol* o);
 439   void write_classID(Klass* k);
 440   void write_id(u4 x);
<span class="line-added"> 441 </span>
<span class="line-added"> 442   // Start a new sub-record. Starts a new heap dump segment if needed.</span>
<span class="line-added"> 443   void start_sub_record(u1 tag, u4 len);</span>
<span class="line-added"> 444   // Ends the current sub-record.</span>
<span class="line-added"> 445   void end_sub_record();</span>
<span class="line-added"> 446   // Finishes the current dump segment if not already finished.</span>
<span class="line-added"> 447   void finish_dump_segment();</span>
 448 };
 449 
<span class="line-modified"> 450 DumpWriter::DumpWriter(const char* path) : _fd(-1), _bytes_written(0), _pos(0),</span>
<span class="line-added"> 451                                            _in_dump_segment(false), _error(NULL) {</span>
 452   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
 453   // sufficient memory then reduce size until we can allocate something.
<span class="line-modified"> 454   _size = io_buffer_max_size;</span>
 455   do {
 456     _buffer = (char*)os::malloc(_size, mtInternal);
 457     if (_buffer == NULL) {
 458       _size = _size &gt;&gt; 1;
 459     }
<span class="line-modified"> 460   } while (_buffer == NULL &amp;&amp; _size &gt;= io_buffer_min_size);</span>
<span class="line-modified"> 461 </span>
<span class="line-modified"> 462   if (_buffer == NULL) {</span>
<span class="line-modified"> 463     set_error(&quot;Could not allocate buffer memory for heap dump&quot;);</span>
<span class="line-modified"> 464   } else {</span>
<span class="line-modified"> 465     _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467     // if the open failed we record the error</span>
<span class="line-modified"> 468     if (_fd &lt; 0) {</span>
<span class="line-modified"> 469       set_error(os::strerror(errno));</span>
<span class="line-modified"> 470     }</span>
 471   }
 472 }
 473 
 474 DumpWriter::~DumpWriter() {
<span class="line-modified"> 475   close();</span>
<span class="line-modified"> 476   os::free(_buffer);</span>
<span class="line-modified"> 477   os::free(_error);</span>



 478 }
 479 
 480 // closes dump file (if open)
 481 void DumpWriter::close() {
 482   // flush and close dump file
 483   if (is_open()) {
 484     flush();
 485     os::close(file_descriptor());
 486     set_file_descriptor(-1);
 487   }
 488 }
 489 
















 490 // write directly to the file
 491 void DumpWriter::write_internal(void* s, size_t len) {
 492   if (is_open()) {
 493     const char* pos = (char*)s;
 494     ssize_t n = 0;
 495     while (len &gt; 0) {
<span class="line-modified"> 496       uint tmp = (uint)MIN2(len, (size_t)INT_MAX);</span>
 497       n = os::write(file_descriptor(), pos, tmp);
 498 
 499       if (n &lt; 0) {
 500         // EINTR cannot happen here, os::write will take care of that
 501         set_error(os::strerror(errno));
 502         os::close(file_descriptor());
 503         set_file_descriptor(-1);
 504         return;
 505       }
 506 
 507       _bytes_written += n;
 508       pos += n;
 509       len -= n;
 510     }
 511   }
 512 }
 513 
 514 // write raw bytes
 515 void DumpWriter::write_raw(void* s, size_t len) {
<span class="line-modified"> 516   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);</span>
<span class="line-modified"> 517   debug_only(_sub_record_left -= len);</span>



 518 
<span class="line-modified"> 519   // flush buffer to make room</span>
<span class="line-modified"> 520   if (len &gt; buffer_size() - position()) {</span>
<span class="line-added"> 521     assert(!_in_dump_segment || _is_huge_sub_record, &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
<span class="line-added"> 522     flush();</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524     // If larger than the buffer, just write it directly.</span>
<span class="line-added"> 525     if (len &gt; buffer_size()) {</span>
 526       write_internal(s, len);
<span class="line-modified"> 527 </span>
<span class="line-modified"> 528       return;</span>


 529     }
 530   }
<span class="line-added"> 531 </span>
<span class="line-added"> 532   memcpy(buffer() + position(), s, len);</span>
<span class="line-added"> 533   set_position(position() + len);</span>
 534 }
 535 
 536 // flush any buffered bytes to the file
 537 void DumpWriter::flush() {
<span class="line-modified"> 538   write_internal(buffer(), position());</span>
<span class="line-modified"> 539   set_position(0);</span>


























 540 }
 541 
 542 void DumpWriter::write_u2(u2 x) {
 543   u2 v;
 544   Bytes::put_Java_u2((address)&amp;v, x);
 545   write_raw((void*)&amp;v, 2);
 546 }
 547 
 548 void DumpWriter::write_u4(u4 x) {
 549   u4 v;
 550   Bytes::put_Java_u4((address)&amp;v, x);
 551   write_raw((void*)&amp;v, 4);
 552 }
 553 
 554 void DumpWriter::write_u8(u8 x) {
 555   u8 v;
 556   Bytes::put_Java_u8((address)&amp;v, x);
 557   write_raw((void*)&amp;v, 8);
 558 }
 559 
 560 void DumpWriter::write_objectID(oop o) {
<span class="line-modified"> 561   address a = cast_from_oop&lt;address&gt;(o);</span>
 562 #ifdef _LP64
 563   write_u8((u8)a);
 564 #else
 565   write_u4((u4)a);
 566 #endif
 567 }
 568 
 569 void DumpWriter::write_symbolID(Symbol* s) {
 570   address a = (address)((uintptr_t)s);
 571 #ifdef _LP64
 572   write_u8((u8)a);
 573 #else
 574   write_u4((u4)a);
 575 #endif
 576 }
 577 
 578 void DumpWriter::write_id(u4 x) {
 579 #ifdef _LP64
 580   write_u8((u8) x);
 581 #else
 582   write_u4(x);
 583 #endif
 584 }
 585 
 586 // We use java mirror as the class ID
 587 void DumpWriter::write_classID(Klass* k) {
 588   write_objectID(k-&gt;java_mirror());
 589 }
 590 
<span class="line-added"> 591 void DumpWriter::finish_dump_segment() {</span>
<span class="line-added"> 592   if (_in_dump_segment) {</span>
<span class="line-added"> 593     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);</span>
<span class="line-added"> 594     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last</span>
<span class="line-added"> 597     // (in which case the segment length was already set to the correct value initially).</span>
<span class="line-added"> 598     if (!_is_huge_sub_record) {</span>
<span class="line-added"> 599       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);</span>
<span class="line-added"> 600       Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));</span>
<span class="line-added"> 601     }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603     flush();</span>
<span class="line-added"> 604     _in_dump_segment = false;</span>
<span class="line-added"> 605   }</span>
<span class="line-added"> 606 }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608 void DumpWriter::start_sub_record(u1 tag, u4 len) {</span>
<span class="line-added"> 609   if (!_in_dump_segment) {</span>
<span class="line-added"> 610     if (position() &gt; 0) {</span>
<span class="line-added"> 611       flush();</span>
<span class="line-added"> 612       assert(position() == 0, &quot;Must be at the start&quot;);</span>
<span class="line-added"> 613     }</span>
<span class="line-added"> 614 </span>
<span class="line-added"> 615     write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-added"> 616     write_u4(0); // timestamp</span>
<span class="line-added"> 617     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,</span>
<span class="line-added"> 618     // this is already the correct length, since we don&#39;t add more sub-records.</span>
<span class="line-added"> 619     write_u4(len);</span>
<span class="line-added"> 620     _in_dump_segment = true;</span>
<span class="line-added"> 621     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;</span>
<span class="line-added"> 622   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {</span>
<span class="line-added"> 623     // This object will not fit in completely or the last sub-record was huge.</span>
<span class="line-added"> 624     // Finish the current segement and try again.</span>
<span class="line-added"> 625     finish_dump_segment();</span>
<span class="line-added"> 626     start_sub_record(tag, len);</span>
<span class="line-added"> 627 </span>
<span class="line-added"> 628     return;</span>
<span class="line-added"> 629   }</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631   debug_only(_sub_record_left = len);</span>
<span class="line-added"> 632   debug_only(_sub_record_ended = false);</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634   write_u1(tag);</span>
<span class="line-added"> 635 }</span>
 636 
<span class="line-added"> 637 void DumpWriter::end_sub_record() {</span>
<span class="line-added"> 638   assert(_in_dump_segment, &quot;must be in dump segment&quot;);</span>
<span class="line-added"> 639   assert(_sub_record_left == 0, &quot;sub-record not written completely&quot;);</span>
<span class="line-added"> 640   assert(!_sub_record_ended, &quot;Must not have ended yet&quot;);</span>
<span class="line-added"> 641   debug_only(_sub_record_ended = true);</span>
<span class="line-added"> 642 }</span>
 643 
 644 // Support class with a collection of functions used when dumping the heap
 645 
 646 class DumperSupport : AllStatic {
 647  public:
 648 
 649   // write a header of the given type
 650   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 651 
 652   // returns hprof tag for the given type signature
 653   static hprofTag sig2tag(Symbol* sig);
 654   // returns hprof tag for the given basic type
 655   static hprofTag type2tag(BasicType type);
<span class="line-added"> 656   // Returns the size of the data to write.</span>
<span class="line-added"> 657   static u4 sig2size(Symbol* sig);</span>
 658 
 659   // returns the size of the instance of the given class
 660   static u4 instance_size(Klass* k);
 661 
 662   // dump a jfloat
 663   static void dump_float(DumpWriter* writer, jfloat f);
 664   // dump a jdouble
 665   static void dump_double(DumpWriter* writer, jdouble d);
 666   // dumps the raw value of the given field
 667   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
<span class="line-added"> 668   // returns the size of the static fields; also counts the static fields</span>
<span class="line-added"> 669   static u4 get_static_fields_size(InstanceKlass* ik, u2&amp; field_count);</span>
 670   // dumps static fields of the given class
 671   static void dump_static_fields(DumpWriter* writer, Klass* k);
 672   // dump the raw values of the instance fields of the given object
 673   static void dump_instance_fields(DumpWriter* writer, oop o);
<span class="line-added"> 674   // get the count of the instance fields for a given class</span>
<span class="line-added"> 675   static u2 get_instance_fields_count(InstanceKlass* ik);</span>
 676   // dumps the definition of the instance fields for a given class
 677   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 678   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 679   static void dump_instance(DumpWriter* writer, oop o);
 680   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 681   // array classes
 682   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 683   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 684   // class (and each multi-dimensional array class too)
 685   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 686 
 687   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 688   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 689   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 690   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 691   // create HPROF_FRAME record for the given method and bci
 692   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 693 
 694   // check if we need to truncate an array
 695   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 696 






 697   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 698   static void end_of_dump(DumpWriter* writer);
<span class="line-added"> 699 </span>
<span class="line-added"> 700   static oop mask_dormant_archived_object(oop o) {</span>
<span class="line-added"> 701     if (o != NULL &amp;&amp; o-&gt;klass()-&gt;java_mirror() == NULL) {</span>
<span class="line-added"> 702       // Ignore this object since the corresponding java mirror is not loaded.</span>
<span class="line-added"> 703       // Might be a dormant archive object.</span>
<span class="line-added"> 704       return NULL;</span>
<span class="line-added"> 705     } else {</span>
<span class="line-added"> 706       return o;</span>
<span class="line-added"> 707     }</span>
<span class="line-added"> 708   }</span>
 709 };
 710 
 711 // write a header of the given type
 712 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 713   writer-&gt;write_u1((u1)tag);
 714   writer-&gt;write_u4(0);                  // current ticks
 715   writer-&gt;write_u4(len);
 716 }
 717 
 718 // returns hprof tag for the given type signature
 719 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 720   switch (sig-&gt;char_at(0)) {
 721     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 722     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 723     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 724     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 725     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 726     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 727     case JVM_SIGNATURE_INT      : return HPROF_INT;
 728     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 729     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 730     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 731     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 732   }
 733 }
 734 
 735 hprofTag DumperSupport::type2tag(BasicType type) {
 736   switch (type) {
 737     case T_BYTE     : return HPROF_BYTE;
 738     case T_CHAR     : return HPROF_CHAR;
 739     case T_FLOAT    : return HPROF_FLOAT;
 740     case T_DOUBLE   : return HPROF_DOUBLE;
 741     case T_INT      : return HPROF_INT;
 742     case T_LONG     : return HPROF_LONG;
 743     case T_SHORT    : return HPROF_SHORT;
 744     case T_BOOLEAN  : return HPROF_BOOLEAN;
 745     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 746   }
 747 }
 748 
<span class="line-added"> 749 u4 DumperSupport::sig2size(Symbol* sig) {</span>
<span class="line-added"> 750   switch (sig-&gt;char_at(0)) {</span>
<span class="line-added"> 751     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added"> 752     case JVM_SIGNATURE_ARRAY: return sizeof(address);</span>
<span class="line-added"> 753     case JVM_SIGNATURE_BOOLEAN:</span>
<span class="line-added"> 754     case JVM_SIGNATURE_BYTE: return 1;</span>
<span class="line-added"> 755     case JVM_SIGNATURE_SHORT:</span>
<span class="line-added"> 756     case JVM_SIGNATURE_CHAR: return 2;</span>
<span class="line-added"> 757     case JVM_SIGNATURE_INT:</span>
<span class="line-added"> 758     case JVM_SIGNATURE_FLOAT: return 4;</span>
<span class="line-added"> 759     case JVM_SIGNATURE_LONG:</span>
<span class="line-added"> 760     case JVM_SIGNATURE_DOUBLE: return 8;</span>
<span class="line-added"> 761     default: ShouldNotReachHere(); /* to shut up compiler */ return 0;</span>
<span class="line-added"> 762   }</span>
<span class="line-added"> 763 }</span>
<span class="line-added"> 764 </span>
 765 // dump a jfloat
 766 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 767   if (g_isnan(f)) {
 768     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 769   } else {
 770     union {
 771       int i;
 772       float f;
 773     } u;
 774     u.f = (float)f;
 775     writer-&gt;write_u4((u4)u.i);
 776   }
 777 }
 778 
 779 // dump a jdouble
 780 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 781   union {
 782     jlong l;
 783     double d;
 784   } u;
 785   if (g_isnan(d)) {                 // collapsing NaNs
 786     u.l = (jlong)(0x7ff80000);
 787     u.l = (u.l &lt;&lt; 32);
 788   } else {
 789     u.d = (double)d;
 790   }
 791   writer-&gt;write_u8((u8)u.l);
 792 }
 793 
 794 // dumps the raw value of the given field
 795 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 796   switch (type) {
 797     case JVM_SIGNATURE_CLASS :
 798     case JVM_SIGNATURE_ARRAY : {
<span class="line-modified"> 799       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;(offset);</span>
<span class="line-added"> 800       if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added"> 801         ResourceMark rm;</span>
<span class="line-added"> 802         log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added"> 803                              p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added"> 804                              p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added"> 805       }</span>
<span class="line-added"> 806       o = mask_dormant_archived_object(o);</span>
 807       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 808       writer-&gt;write_objectID(o);
 809       break;
 810     }
 811     case JVM_SIGNATURE_BYTE : {
 812       jbyte b = obj-&gt;byte_field(offset);
 813       writer-&gt;write_u1((u1)b);
 814       break;
 815     }
 816     case JVM_SIGNATURE_CHAR : {
 817       jchar c = obj-&gt;char_field(offset);
 818       writer-&gt;write_u2((u2)c);
 819       break;
 820     }
 821     case JVM_SIGNATURE_SHORT : {
 822       jshort s = obj-&gt;short_field(offset);
 823       writer-&gt;write_u2((u2)s);
 824       break;
 825     }
 826     case JVM_SIGNATURE_FLOAT : {
</pre>
<hr />
<pre>
 842       jlong l = obj-&gt;long_field(offset);
 843       writer-&gt;write_u8((u8)l);
 844       break;
 845     }
 846     case JVM_SIGNATURE_BOOLEAN : {
 847       jboolean b = obj-&gt;bool_field(offset);
 848       writer-&gt;write_u1((u1)b);
 849       break;
 850     }
 851     default : {
 852       ShouldNotReachHere();
 853       break;
 854     }
 855   }
 856 }
 857 
 858 // returns the size of the instance of the given class
 859 u4 DumperSupport::instance_size(Klass* k) {
 860   HandleMark hm;
 861   InstanceKlass* ik = InstanceKlass::cast(k);

 862   u4 size = 0;
 863 
 864   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 865     if (!fld.access_flags().is_static()) {
<span class="line-modified"> 866       size += sig2size(fld.signature());</span>


















 867     }
 868   }
 869   return size;
 870 }
 871 
<span class="line-modified"> 872 u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2&amp; field_count) {</span>

 873   HandleMark hm;
<span class="line-modified"> 874   field_count = 0;</span>
<span class="line-added"> 875   u4 size = 0;</span>
 876 


 877   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<span class="line-modified"> 878     if (fldc.access_flags().is_static()) {</span>
<span class="line-added"> 879       field_count++;</span>
<span class="line-added"> 880       size += sig2size(fldc.signature());</span>
<span class="line-added"> 881     }</span>
 882   }
 883 
 884   // Add in resolved_references which is referenced by the cpCache
 885   // The resolved_references is an array per InstanceKlass holding the
 886   // strings and other oops resolved from the constant pool.
 887   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 888   if (resolved_references != NULL) {
 889     field_count++;
<span class="line-added"> 890     size += sizeof(address);</span>
 891 
 892     // Add in the resolved_references of the used previous versions of the class
 893     // in the case of RedefineClasses
 894     InstanceKlass* prev = ik-&gt;previous_versions();
 895     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 896       field_count++;
<span class="line-added"> 897       size += sizeof(address);</span>
 898       prev = prev-&gt;previous_versions();
 899     }
 900   }
 901 
 902   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 903   // arrays.
 904   oop init_lock = ik-&gt;init_lock();
 905   if (init_lock != NULL) {
 906     field_count++;
<span class="line-added"> 907     size += sizeof(address);</span>
 908   }
 909 
<span class="line-modified"> 910   // We write the value itself plus a name and a one byte type tag per field.</span>
<span class="line-added"> 911   return size + field_count * (sizeof(address) + 1);</span>
<span class="line-added"> 912 }</span>
 913 
<span class="line-modified"> 914 // dumps static fields of the given class</span>
<span class="line-added"> 915 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
<span class="line-added"> 916   HandleMark hm;</span>
<span class="line-added"> 917   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919   // dump the field descriptors and raw values</span>
 920   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 921     if (fld.access_flags().is_static()) {
 922       Symbol* sig = fld.signature();
 923 
 924       writer-&gt;write_symbolID(fld.name());   // name
 925       writer-&gt;write_u1(sig2tag(sig));       // type
 926 
 927       // value
 928       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 929     }
 930   }
 931 
 932   // Add resolved_references for each class that has them
<span class="line-added"> 933   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();</span>
 934   if (resolved_references != NULL) {
 935     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 936     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 937     writer-&gt;write_objectID(resolved_references);
 938 
 939     // Also write any previous versions
 940     InstanceKlass* prev = ik-&gt;previous_versions();
 941     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 942       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 943       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 944       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 945       prev = prev-&gt;previous_versions();
 946     }
 947   }
 948 
 949   // Add init lock to the end if the class is not yet initialized
<span class="line-added"> 950   oop init_lock = ik-&gt;init_lock();</span>
 951   if (init_lock != NULL) {
 952     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 953     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 954     writer-&gt;write_objectID(init_lock);
 955   }
 956 }
 957 
 958 // dump the raw values of the instance fields of the given object
 959 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
 960   HandleMark hm;
 961   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 962 
 963   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 964     if (!fld.access_flags().is_static()) {
 965       Symbol* sig = fld.signature();
 966       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 967     }
 968   }
 969 }
 970 
 971 // dumps the definition of the instance fields for a given class
<span class="line-modified"> 972 u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {</span>
 973   HandleMark hm;



 974   u2 field_count = 0;
<span class="line-added"> 975 </span>
 976   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 977     if (!fldc.access_flags().is_static()) field_count++;
 978   }
 979 
<span class="line-modified"> 980   return field_count;</span>
<span class="line-added"> 981 }</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983 // dumps the definition of the instance fields for a given class</span>
<span class="line-added"> 984 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
<span class="line-added"> 985   HandleMark hm;</span>
<span class="line-added"> 986   InstanceKlass* ik = InstanceKlass::cast(k);</span>
 987 
<span class="line-modified"> 988   // dump the field descriptors</span>
 989   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 990     if (!fld.access_flags().is_static()) {
 991       Symbol* sig = fld.signature();
 992 
 993       writer-&gt;write_symbolID(fld.name());   // name
 994       writer-&gt;write_u1(sig2tag(sig));       // type
 995     }
 996   }
 997 }
 998 
 999 // creates HPROF_GC_INSTANCE_DUMP record for the given object
1000 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<span class="line-modified">1001   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());</span>
<span class="line-added">1002   u4 is = instance_size(ik);</span>
<span class="line-added">1003   u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;</span>
1004 
<span class="line-modified">1005   writer-&gt;start_sub_record(HPROF_GC_INSTANCE_DUMP, size);</span>
1006   writer-&gt;write_objectID(o);
1007   writer-&gt;write_u4(STACK_TRACE_ID);
1008 
1009   // class ID
<span class="line-modified">1010   writer-&gt;write_classID(ik);</span>
1011 
1012   // number of bytes that follow
<span class="line-modified">1013   writer-&gt;write_u4(is);</span>
1014 
1015   // field values
1016   dump_instance_fields(writer, o);
<span class="line-added">1017 </span>
<span class="line-added">1018   writer-&gt;end_sub_record();</span>
1019 }
1020 
1021 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
1022 // its array classes
1023 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
1024   InstanceKlass* ik = InstanceKlass::cast(k);
1025 
1026   // We can safepoint and do a heap dump at a point where we have a Klass,
1027   // but no java mirror class has been setup for it. So we need to check
1028   // that the class is at least loaded, to avoid crash from a null mirror.
1029   if (!ik-&gt;is_loaded()) {
1030     return;
1031   }
1032 
<span class="line-modified">1033   u2 static_fields_count = 0;</span>
<span class="line-added">1034   u4 static_size = get_static_fields_size(ik, static_fields_count);</span>
<span class="line-added">1035   u2 instance_fields_count = get_instance_fields_count(ik);</span>
<span class="line-added">1036   u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);</span>
<span class="line-added">1037   u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;</span>
<span class="line-added">1038 </span>
<span class="line-added">1039   writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
1040 
1041   // class ID
1042   writer-&gt;write_classID(ik);
1043   writer-&gt;write_u4(STACK_TRACE_ID);
1044 
1045   // super class ID
1046   InstanceKlass* java_super = ik-&gt;java_super();
1047   if (java_super == NULL) {
1048     writer-&gt;write_objectID(oop(NULL));
1049   } else {
1050     writer-&gt;write_classID(java_super);
1051   }
1052 
1053   writer-&gt;write_objectID(ik-&gt;class_loader());
1054   writer-&gt;write_objectID(ik-&gt;signers());
1055   writer-&gt;write_objectID(ik-&gt;protection_domain());
1056 
1057   // reserved
1058   writer-&gt;write_objectID(oop(NULL));
1059   writer-&gt;write_objectID(oop(NULL));
1060 
1061   // instance size
<span class="line-modified">1062   writer-&gt;write_u4(DumperSupport::instance_size(ik));</span>
1063 
1064   // size of constant pool - ignored by HAT 1.1
1065   writer-&gt;write_u2(0);
1066 
<span class="line-modified">1067   // static fields</span>
<span class="line-modified">1068   writer-&gt;write_u2(static_fields_count);</span>
<span class="line-added">1069   dump_static_fields(writer, ik);</span>
1070 
1071   // description of instance fields
<span class="line-modified">1072   writer-&gt;write_u2(instance_fields_count);</span>
<span class="line-added">1073   dump_instance_field_descriptors(writer, ik);</span>
<span class="line-added">1074 </span>
<span class="line-added">1075   writer-&gt;end_sub_record();</span>
1076 
1077   // array classes
<span class="line-modified">1078   k = ik-&gt;array_klass_or_null();</span>
1079   while (k != NULL) {
<span class="line-modified">1080     assert(k-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>

1081 
<span class="line-modified">1082     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-modified">1083     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
<span class="line-added">1084     writer-&gt;write_classID(k);</span>
1085     writer-&gt;write_u4(STACK_TRACE_ID);
1086 
1087     // super class of array classes is java.lang.Object
<span class="line-modified">1088     java_super = k-&gt;java_super();</span>
1089     assert(java_super != NULL, &quot;checking&quot;);
1090     writer-&gt;write_classID(java_super);
1091 
1092     writer-&gt;write_objectID(ik-&gt;class_loader());
1093     writer-&gt;write_objectID(ik-&gt;signers());
1094     writer-&gt;write_objectID(ik-&gt;protection_domain());
1095 
1096     writer-&gt;write_objectID(oop(NULL));    // reserved
1097     writer-&gt;write_objectID(oop(NULL));
1098     writer-&gt;write_u4(0);             // instance size
1099     writer-&gt;write_u2(0);             // constant pool
1100     writer-&gt;write_u2(0);             // static fields
1101     writer-&gt;write_u2(0);             // instance fields
1102 
<span class="line-added">1103     writer-&gt;end_sub_record();</span>
<span class="line-added">1104 </span>
1105     // get the array class for the next rank
<span class="line-modified">1106     k = k-&gt;array_klass_or_null();</span>
1107   }
1108 }
1109 
1110 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1111 // class (and each multi-dimensional array class too)
1112 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1113  // array classes
1114  while (k != NULL) {
1115     Klass* klass = k;
1116 
<span class="line-modified">1117     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-added">1118     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
1119     writer-&gt;write_classID(klass);
1120     writer-&gt;write_u4(STACK_TRACE_ID);
1121 
1122     // super class of array classes is java.lang.Object
1123     InstanceKlass* java_super = klass-&gt;java_super();
1124     assert(java_super != NULL, &quot;checking&quot;);
1125     writer-&gt;write_classID(java_super);
1126 
1127     writer-&gt;write_objectID(oop(NULL));    // loader
1128     writer-&gt;write_objectID(oop(NULL));    // signers
1129     writer-&gt;write_objectID(oop(NULL));    // protection domain
1130 
1131     writer-&gt;write_objectID(oop(NULL));    // reserved
1132     writer-&gt;write_objectID(oop(NULL));
1133     writer-&gt;write_u4(0);             // instance size
1134     writer-&gt;write_u2(0);             // constant pool
1135     writer-&gt;write_u2(0);             // static fields
1136     writer-&gt;write_u2(0);             // instance fields
1137 
<span class="line-added">1138     writer-&gt;end_sub_record();</span>
<span class="line-added">1139 </span>
1140     // get the array class for the next rank
1141     k = klass-&gt;array_klass_or_null();
1142   }
1143 }
1144 
1145 // Hprof uses an u4 as record length field,
1146 // which means we need to truncate arrays that are too long.
1147 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1148   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1149   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1150 
1151   int length = array-&gt;length();
1152 
1153   int type_size;
1154   if (type == T_OBJECT) {
1155     type_size = sizeof(address);
1156   } else {
1157     type_size = type2aelembytes(type);
1158   }
1159 
1160   size_t length_in_bytes = (size_t)length * type_size;
<span class="line-added">1161   uint max_bytes = max_juint - header_size;</span>
1162 
















1163   if (length_in_bytes &gt; max_bytes) {
1164     length = max_bytes / type_size;
1165     length_in_bytes = (size_t)length * type_size;
1166 
1167     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1168             type2name_tab[type], array-&gt;length(), length);
1169   }
1170   return length;
1171 }
1172 
1173 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1174 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1175   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1176   short header_size = 1 + 2 * 4 + 2 * sizeof(address);

1177   int length = calculate_array_max_length(writer, array, header_size);
<span class="line-added">1178   u4 size = header_size + length * sizeof(address);</span>
1179 
<span class="line-modified">1180   writer-&gt;start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);</span>
1181   writer-&gt;write_objectID(array);
1182   writer-&gt;write_u4(STACK_TRACE_ID);
1183   writer-&gt;write_u4(length);
1184 
1185   // array class ID
1186   writer-&gt;write_classID(array-&gt;klass());
1187 
1188   // [id]* elements
1189   for (int index = 0; index &lt; length; index++) {
1190     oop o = array-&gt;obj_at(index);
<span class="line-added">1191     if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">1192       ResourceMark rm;</span>
<span class="line-added">1193       log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added">1194                            p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">1195                            p2i(array), array-&gt;klass()-&gt;external_name());</span>
<span class="line-added">1196     }</span>
<span class="line-added">1197     o = mask_dormant_archived_object(o);</span>
1198     writer-&gt;write_objectID(o);
1199   }
<span class="line-added">1200 </span>
<span class="line-added">1201   writer-&gt;end_sub_record();</span>
1202 }
1203 
1204 #define WRITE_ARRAY(Array, Type, Size, Length) \
1205   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1206 
1207 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1208 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1209   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1210 
1211   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1212   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1213 
1214   int length = calculate_array_max_length(writer, array, header_size);
1215   int type_size = type2aelembytes(type);
1216   u4 length_in_bytes = (u4)length * type_size;
<span class="line-added">1217   u4 size = header_size + length_in_bytes;</span>
1218 
<span class="line-modified">1219   writer-&gt;start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);</span>
1220   writer-&gt;write_objectID(array);
1221   writer-&gt;write_u4(STACK_TRACE_ID);
1222   writer-&gt;write_u4(length);
1223   writer-&gt;write_u1(type2tag(type));
1224 
1225   // nothing to copy
1226   if (length == 0) {
<span class="line-added">1227     writer-&gt;end_sub_record();</span>
1228     return;
1229   }
1230 
1231   // If the byte ordering is big endian then we can copy most types directly
1232 
1233   switch (type) {
1234     case T_INT : {
1235       if (Endian::is_Java_byte_ordering_different()) {
1236         WRITE_ARRAY(array, int, u4, length);
1237       } else {
1238         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1239       }
1240       break;
1241     }
1242     case T_BYTE : {
1243       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1244       break;
1245     }
1246     case T_CHAR : {
1247       if (Endian::is_Java_byte_ordering_different()) {
</pre>
<hr />
<pre>
1277     }
1278 
1279     // handle float/doubles in a special value to ensure than NaNs are
1280     // written correctly. TO DO: Check if we can avoid this on processors that
1281     // use IEEE 754.
1282 
1283     case T_FLOAT : {
1284       for (int i = 0; i &lt; length; i++) {
1285         dump_float(writer, array-&gt;float_at(i));
1286       }
1287       break;
1288     }
1289     case T_DOUBLE : {
1290       for (int i = 0; i &lt; length; i++) {
1291         dump_double(writer, array-&gt;double_at(i));
1292       }
1293       break;
1294     }
1295     default : ShouldNotReachHere();
1296   }
<span class="line-added">1297 </span>
<span class="line-added">1298   writer-&gt;end_sub_record();</span>
1299 }
1300 
1301 // create a HPROF_FRAME record of the given Method* and bci
1302 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1303                                      int frame_serial_num,
1304                                      int class_serial_num,
1305                                      Method* m,
1306                                      int bci) {
1307   int line_number;
1308   if (m-&gt;is_native()) {
1309     line_number = -3;  // native frame
1310   } else {
1311     line_number = m-&gt;line_number_from_bci(bci);
1312   }
1313 
1314   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1315   writer-&gt;write_id(frame_serial_num);               // frame serial number
1316   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1317   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1318 
</pre>
<hr />
<pre>
1354   DumpWriter* _writer;
1355   u4 _thread_serial_num;
1356   int _frame_num;
1357   DumpWriter* writer() const                { return _writer; }
1358  public:
1359   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1360     _writer = writer;
1361     _thread_serial_num = thread_serial_num;
1362     _frame_num = -1;  // default - empty stack
1363   }
1364   void set_frame_number(int n) { _frame_num = n; }
1365   void do_oop(oop* obj_p);
1366   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1367 };
1368 
1369 
1370 void JNILocalsDumper::do_oop(oop* obj_p) {
1371   // ignore null handles
1372   oop o = *obj_p;
1373   if (o != NULL) {
<span class="line-modified">1374     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1375     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);</span>
1376     writer()-&gt;write_objectID(o);
1377     writer()-&gt;write_u4(_thread_serial_num);
1378     writer()-&gt;write_u4((u4)_frame_num);
<span class="line-added">1379     writer()-&gt;end_sub_record();</span>
1380   }
1381 }
1382 
1383 
1384 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1385 
1386 class JNIGlobalsDumper : public OopClosure {
1387  private:
1388   DumpWriter* _writer;
1389   DumpWriter* writer() const                { return _writer; }
1390 
1391  public:
1392   JNIGlobalsDumper(DumpWriter* writer) {
1393     _writer = writer;
1394   }
1395   void do_oop(oop* obj_p);
1396   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1397 };
1398 
1399 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1400   oop o = *obj_p;
1401 
1402   // ignore these
1403   if (o == NULL) return;
1404 
1405   // we ignore global ref to symbols and other internal objects
1406   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<span class="line-modified">1407     u4 size = 1 + 2 * sizeof(address);</span>
<span class="line-added">1408     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);</span>
1409     writer()-&gt;write_objectID(o);
1410     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
<span class="line-added">1411     writer()-&gt;end_sub_record();</span>
1412   }
1413 };
1414 
1415 
1416 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1417 
1418 class MonitorUsedDumper : public OopClosure {
1419  private:
1420   DumpWriter* _writer;
1421   DumpWriter* writer() const                { return _writer; }
1422  public:
1423   MonitorUsedDumper(DumpWriter* writer) {
1424     _writer = writer;
1425   }
1426   void do_oop(oop* obj_p) {
<span class="line-modified">1427     u4 size = 1 + sizeof(address);</span>
<span class="line-added">1428     writer()-&gt;start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);</span>
1429     writer()-&gt;write_objectID(*obj_p);
<span class="line-added">1430     writer()-&gt;end_sub_record();</span>
1431   }
1432   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1433 };
1434 
1435 
1436 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1437 
1438 class StickyClassDumper : public KlassClosure {
1439  private:
1440   DumpWriter* _writer;
1441   DumpWriter* writer() const                { return _writer; }
1442  public:
1443   StickyClassDumper(DumpWriter* writer) {
1444     _writer = writer;
1445   }
1446   void do_klass(Klass* k) {
1447     if (k-&gt;is_instance_klass()) {
1448       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1449       u4 size = 1 + sizeof(address);</span>
<span class="line-modified">1450       writer()-&gt;start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);</span>
<span class="line-modified">1451       writer()-&gt;write_classID(ik);</span>
<span class="line-added">1452       writer()-&gt;end_sub_record();</span>
1453     }
<span class="line-added">1454   }</span>
1455 };
1456 
1457 
1458 class VM_HeapDumper;
1459 
1460 // Support class using when iterating over the heap.
1461 
1462 class HeapObjectDumper : public ObjectClosure {
1463  private:
1464   VM_HeapDumper* _dumper;
1465   DumpWriter* _writer;
1466 
1467   VM_HeapDumper* dumper()               { return _dumper; }
1468   DumpWriter* writer()                  { return _writer; }
1469 



1470  public:
1471   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1472     _dumper = dumper;
1473     _writer = writer;
1474   }
1475 
1476   // called for each object in the heap
1477   void do_object(oop o);
1478 };
1479 
1480 void HeapObjectDumper::do_object(oop o) {
1481   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1482   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1483     if (!java_lang_Class::is_primitive(o)) {
1484       return;
1485     }
1486   }
1487 
<span class="line-added">1488   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">1489     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());</span>
<span class="line-added">1490     return;</span>
<span class="line-added">1491   }</span>
<span class="line-added">1492 </span>
1493   if (o-&gt;is_instance()) {
1494     // create a HPROF_GC_INSTANCE record for each object
1495     DumperSupport::dump_instance(writer(), o);

1496   } else if (o-&gt;is_objArray()) {
1497     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1498     DumperSupport::dump_object_array(writer(), objArrayOop(o));

1499   } else if (o-&gt;is_typeArray()) {
1500     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1501     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));

1502   }
1503 }
1504 
1505 // The VM operation that performs the heap dump
1506 class VM_HeapDumper : public VM_GC_Operation {
1507  private:
1508   static VM_HeapDumper* _global_dumper;
1509   static DumpWriter*    _global_writer;
1510   DumpWriter*           _local_writer;
1511   JavaThread*           _oome_thread;
1512   Method*               _oome_constructor;
1513   bool _gc_before_heap_dump;
1514   GrowableArray&lt;Klass*&gt;* _klass_map;
1515   ThreadStackTrace** _stack_traces;
1516   int _num_threads;
1517 
1518   // accessors and setters
1519   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1520   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1521   void set_global_dumper() {
</pre>
<hr />
<pre>
1572       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1573                                                           vmSymbols::void_method_signature());
1574       // get thread throwing OOME when generating the heap dump at OOME
1575       _oome_thread = JavaThread::current();
1576     } else {
1577       _oome_thread = NULL;
1578       _oome_constructor = NULL;
1579     }
1580   }
1581   ~VM_HeapDumper() {
1582     if (_stack_traces != NULL) {
1583       for (int i=0; i &lt; _num_threads; i++) {
1584         delete _stack_traces[i];
1585       }
1586       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1587     }
1588     delete _klass_map;
1589   }
1590 
1591   VMOp_Type type() const { return VMOp_HeapDumper; }


1592   void doit();
1593 };
1594 
1595 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1596 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1597 
1598 bool VM_HeapDumper::skip_operation() const {
1599   return false;
1600 }
1601 




















































1602 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1603 void DumperSupport::end_of_dump(DumpWriter* writer) {
<span class="line-modified">1604   writer-&gt;finish_dump_segment();</span>







1605 
<span class="line-modified">1606   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-modified">1607   writer-&gt;write_u4(0);</span>
<span class="line-modified">1608   writer-&gt;write_u4(0);</span>
1609 }
1610 
1611 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1612 // array classes)
1613 void VM_HeapDumper::do_load_class(Klass* k) {
1614   static u4 class_serial_num = 0;
1615 
1616   // len of HPROF_LOAD_CLASS record
1617   u4 remaining = 2*oopSize + 2*sizeof(u4);
1618 
1619   // write a HPROF_LOAD_CLASS for the class and each array class
1620   do {
1621     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1622 
1623     // class serial number is just a number
1624     writer()-&gt;write_u4(++class_serial_num);
1625 
1626     // class ID
1627     Klass* klass = k;
1628     writer()-&gt;write_classID(klass);
</pre>
<hr />
<pre>
1678     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1679     frame* last_entry_frame = NULL;
1680     int extra_frames = 0;
1681 
1682     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1683       extra_frames++;
1684     }
1685     while (vf != NULL) {
1686       blk.set_frame_number(stack_depth);
1687       if (vf-&gt;is_java_frame()) {
1688 
1689         // java frame (interpreted, compiled, ...)
1690         javaVFrame *jvf = javaVFrame::cast(vf);
1691         if (!(jvf-&gt;method()-&gt;is_native())) {
1692           StackValueCollection* locals = jvf-&gt;locals();
1693           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1694             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1695               oop o = locals-&gt;obj_at(slot)();
1696 
1697               if (o != NULL) {
<span class="line-modified">1698                 u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1699                 writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
1700                 writer()-&gt;write_objectID(o);
1701                 writer()-&gt;write_u4(thread_serial_num);
1702                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<span class="line-added">1703                 writer()-&gt;end_sub_record();</span>
1704               }
1705             }
1706           }
1707           StackValueCollection *exprs = jvf-&gt;expressions();
1708           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1709             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1710                oop o = exprs-&gt;obj_at(index)();
1711                if (o != NULL) {
<span class="line-modified">1712                  u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1713                  writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
1714                  writer()-&gt;write_objectID(o);
1715                  writer()-&gt;write_u4(thread_serial_num);
1716                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<span class="line-added">1717                  writer()-&gt;end_sub_record();</span>
1718                }
1719              }
1720           }
1721         } else {
1722           // native frame
1723           if (stack_depth == 0) {
1724             // JNI locals for the top frame.
1725             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1726           } else {
1727             if (last_entry_frame != NULL) {
1728               // JNI locals for the entry frame
1729               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1730               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1731             }
1732           }
1733         }
1734         // increment only for Java frames
1735         stack_depth++;
1736         last_entry_frame = NULL;
1737 
</pre>
<hr />
<pre>
1745         }
1746       }
1747       vf = vf-&gt;sender();
1748     }
1749   } else {
1750     // no last java frame but there may be JNI locals
1751     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1752   }
1753   return stack_depth;
1754 }
1755 
1756 
1757 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1758 // the stack so that locals and JNI locals are dumped.
1759 void VM_HeapDumper::do_threads() {
1760   for (int i=0; i &lt; _num_threads; i++) {
1761     JavaThread* thread = _stack_traces[i]-&gt;thread();
1762     oop threadObj = thread-&gt;threadObj();
1763     u4 thread_serial_num = i+1;
1764     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<span class="line-modified">1765     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1766     writer()-&gt;start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);</span>
1767     writer()-&gt;write_objectID(threadObj);
1768     writer()-&gt;write_u4(thread_serial_num);  // thread number
1769     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
<span class="line-added">1770     writer()-&gt;end_sub_record();</span>
1771     int num_frames = do_thread(thread, thread_serial_num);
1772     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1773            &quot;total number of Java frames not matched&quot;);
1774   }
1775 }
1776 
1777 
1778 // The VM operation that dumps the heap. The dump consists of the following
1779 // records:
1780 //
1781 //  HPROF_HEADER
1782 //  [HPROF_UTF8]*
1783 //  [HPROF_LOAD_CLASS]*
1784 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1785 //  [HPROF_GC_CLASS_DUMP]*
1786 //  [HPROF_HEAP_DUMP_SEGMENT]*
1787 //  HPROF_HEAP_DUMP_END
1788 //
1789 // The HPROF_TRACE records represent the stack traces where the heap dump
1790 // is generated and a &quot;dummy trace&quot; record which does not include
</pre>
<hr />
<pre>
1811     if (GCLocker::is_active()) {
1812       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1813     } else {
1814       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1815     }
1816   }
1817 
1818   // At this point we should be the only dumper active, so
1819   // the following should be safe.
1820   set_global_dumper();
1821   set_global_writer();
1822 
1823   // Write the file header - we always use 1.0.2
1824   size_t used = ch-&gt;used();
1825   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1826 
1827   // header is few bytes long - no chance to overflow int
1828   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1829   writer()-&gt;write_u1(0); // terminator
1830   writer()-&gt;write_u4(oopSize);
<span class="line-added">1831   // timestamp is current time in ms</span>
1832   writer()-&gt;write_u8(os::javaTimeMillis());
1833 
1834   // HPROF_UTF8 records
1835   SymbolTableDumper sym_dumper(writer());
1836   SymbolTable::symbols_do(&amp;sym_dumper);
1837 
1838   // write HPROF_LOAD_CLASS records
1839   {
1840     LockedClassesDo locked_load_classes(&amp;do_load_class);
1841     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1842   }
1843   Universe::basic_type_classes_do(&amp;do_load_class);
1844 
1845   // write HPROF_FRAME and HPROF_TRACE records
1846   // this must be called after _klass_map is built when iterating the classes above.
1847   dump_stack_traces();
1848 



1849   // Writes HPROF_GC_CLASS_DUMP records
1850   {
1851     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1852     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1853   }
1854   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);

1855 
1856   // writes HPROF_GC_INSTANCE_DUMP records.
1857   // After each sub-record is written check_segment_length will be invoked
1858   // to check if the current segment exceeds a threshold. If so, a new
1859   // segment is started.
1860   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1861   // of the heap dump.
1862   HeapObjectDumper obj_dumper(this, writer());
<span class="line-modified">1863   Universe::heap()-&gt;object_iterate(&amp;obj_dumper);</span>
1864 
1865   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1866   do_threads();

1867 
1868   // HPROF_GC_ROOT_MONITOR_USED
1869   MonitorUsedDumper mon_dumper(writer());
1870   ObjectSynchronizer::oops_do(&amp;mon_dumper);

1871 
1872   // HPROF_GC_ROOT_JNI_GLOBAL
1873   JNIGlobalsDumper jni_dumper(writer());
1874   JNIHandles::oops_do(&amp;jni_dumper);
1875   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1876                                    // for things like preallocated throwable backtraces

1877 
1878   // HPROF_GC_ROOT_STICKY_CLASS
1879   // These should be classes in the NULL class loader data, and not all classes
1880   // if !ClassUnloading
1881   StickyClassDumper class_dumper(writer());
1882   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1883 
<span class="line-modified">1884   // Writes the HPROF_HEAP_DUMP_END record.</span>
1885   DumperSupport::end_of_dump(writer());
1886 
1887   // Now we clear the global variables, so that a future dumper might run.
1888   clear_global_dumper();
1889   clear_global_writer();
1890 }
1891 
1892 void VM_HeapDumper::dump_stack_traces() {
1893   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1894   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1895   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1896   writer()-&gt;write_u4(0);                    // thread number
1897   writer()-&gt;write_u4(0);                    // frame count
1898 
1899   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1900   int frame_serial_num = 0;
1901   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1902     oop threadObj = thread-&gt;threadObj();
1903     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1904       // dump thread stack trace
</pre>
<hr />
<pre>
1927         // the class serial number starts from 1
1928         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1929         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1930       }
1931       depth += extra_frames;
1932 
1933       // write HPROF_TRACE record for one thread
1934       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1935       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1936       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1937       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1938       writer()-&gt;write_u4(depth);                 // frame count
1939       for (int j=1; j &lt;= depth; j++) {
1940         writer()-&gt;write_id(thread_frame_start + j);
1941       }
1942     }
1943   }
1944 }
1945 
1946 // dump the heap to given path.
<span class="line-modified">1947 int HeapDumper::dump(const char* path, outputStream* out) {</span>
1948   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1949 
1950   // print message in interactive case
<span class="line-modified">1951   if (out != NULL) {</span>
<span class="line-modified">1952     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
1953     timer()-&gt;start();
1954   }
1955 
<span class="line-added">1956   // create JFR event</span>
<span class="line-added">1957   EventHeapDump event;</span>
<span class="line-added">1958 </span>
1959   // create the dump writer. If the file can be opened then bail
1960   DumpWriter writer(path);
<span class="line-modified">1961   if (writer.error() != NULL) {</span>
1962     set_error(writer.error());
<span class="line-modified">1963     if (out != NULL) {</span>
<span class="line-modified">1964       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
1965         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1966     }
1967     return -1;
1968   }
1969 
1970   // generate the dump
1971   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1972   if (Thread::current()-&gt;is_VM_thread()) {
1973     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1974     dumper.doit();
1975   } else {
1976     VMThread::execute(&amp;dumper);
1977   }
1978 
1979   // close dump file and record any error that the writer may have encountered
1980   writer.close();
1981   set_error(writer.error());
1982 
<span class="line-added">1983   // emit JFR event</span>
<span class="line-added">1984   if (error() == NULL) {</span>
<span class="line-added">1985     event.set_destination(path);</span>
<span class="line-added">1986     event.set_gcBeforeDump(_gc_before_heap_dump);</span>
<span class="line-added">1987     event.set_size(writer.bytes_written());</span>
<span class="line-added">1988     event.set_onOutOfMemoryError(_oome);</span>
<span class="line-added">1989     event.commit();</span>
<span class="line-added">1990   }</span>
<span class="line-added">1991 </span>
1992   // print message in interactive case
<span class="line-modified">1993   if (out != NULL) {</span>
1994     timer()-&gt;stop();
1995     if (error() == NULL) {
<span class="line-modified">1996       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
1997                     writer.bytes_written(), timer()-&gt;seconds());
1998     } else {
<span class="line-modified">1999       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
2000     }
2001   }
2002 
2003   return (writer.error() == NULL) ? 0 : -1;
2004 }
2005 
2006 // stop timer (if still active), and free any error string we might be holding
2007 HeapDumper::~HeapDumper() {
2008   if (timer()-&gt;is_active()) {
2009     timer()-&gt;stop();
2010   }
2011   set_error(NULL);
2012 }
2013 
2014 
2015 // returns the error string (resource allocated), or NULL
2016 char* HeapDumper::error_as_C_string() const {
2017   if (error() != NULL) {
2018     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2019     strcpy(str, error());
</pre>
<hr />
<pre>
2107     const size_t len = strlen(base_path) + 1;
2108     my_path = (char*)os::malloc(len, mtInternal);
2109     if (my_path == NULL) {
2110       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2111       return;
2112     }
2113     strncpy(my_path, base_path, len);
2114   } else {
2115     // Append a sequence number id for dumps following the first
2116     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2117     my_path = (char*)os::malloc(len, mtInternal);
2118     if (my_path == NULL) {
2119       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2120       return;
2121     }
2122     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2123   }
2124   dump_file_seq++;   // increment seq number for next time we dump
2125 
2126   HeapDumper dumper(false /* no GC before heap dump */,

2127                     oome  /* pass along out-of-memory-error flag */);
<span class="line-modified">2128   dumper.dump(my_path, tty);</span>
2129   os::free(my_path);
2130 }
</pre>
</td>
</tr>
</table>
<center><a href="gcNotifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapDumper.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/diagnosticCommand.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
 26 #define SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
 27 
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/symbolTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;runtime/arguments.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/vmThread.hpp&quot;
 35 #include &quot;services/diagnosticArgument.hpp&quot;
 36 #include &quot;services/diagnosticCommand.hpp&quot;
 37 #include &quot;services/diagnosticFramework.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 #include &quot;utilities/ostream.hpp&quot;
 40 #include &quot;oops/method.hpp&quot;
 41 
 42 class HelpDCmd : public DCmdWithParser {
 43 protected:
 44   DCmdArgument&lt;bool&gt; _all;
 45   DCmdArgument&lt;char*&gt; _cmd;
 46 public:
 47   HelpDCmd(outputStream* output, bool heap);
 48   static const char* name() { return &quot;help&quot;; }
 49   static const char* description() {
 50     return &quot;For more information about a specific command use &#39;help &lt;command&gt;&#39;. &quot;
 51            &quot;With no argument this will show a list of available commands. &quot;
 52            &quot;&#39;help all&#39; will show help for all commands.&quot;;
 53   }
 54   static const char* impact() { return &quot;Low&quot;; }
 55   static int num_arguments();
 56   virtual void execute(DCmdSource source, TRAPS);
 57 };
 58 
 59 class VersionDCmd : public DCmd {
 60 public:
 61   VersionDCmd(outputStream* output, bool heap) : DCmd(output,heap) { }
 62   static const char* name() { return &quot;VM.version&quot;; }
 63   static const char* description() {
 64     return &quot;Print JVM version information.&quot;;
 65   }
 66   static const char* impact() { return &quot;Low&quot;; }
 67   static const JavaPermission permission() {
 68     JavaPermission p = {&quot;java.util.PropertyPermission&quot;,
 69                         &quot;java.vm.version&quot;, &quot;read&quot;};
 70     return p;
 71   }
 72   static int num_arguments() { return 0; }
 73   virtual void execute(DCmdSource source, TRAPS);
 74 };
 75 
 76 class CommandLineDCmd : public DCmd {
 77 public:
 78   CommandLineDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
 79   static const char* name() { return &quot;VM.command_line&quot;; }
 80   static const char* description() {
 81     return &quot;Print the command line used to start this VM instance.&quot;;
 82   }
 83   static const char* impact() { return &quot;Low&quot;; }
 84   static const JavaPermission permission() {
 85     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
 86                         &quot;monitor&quot;, NULL};
 87     return p;
 88   }
 89   static int num_arguments() { return 0; }
 90   virtual void execute(DCmdSource source, TRAPS) {
 91     Arguments::print_on(_output);
 92   }
 93 };
 94 
 95 // See also: get_system_properties in attachListener.cpp
 96 class PrintSystemPropertiesDCmd : public DCmd {
 97 public:
 98   PrintSystemPropertiesDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
 99     static const char* name() { return &quot;VM.system_properties&quot;; }
100     static const char* description() {
101       return &quot;Print system properties.&quot;;
102     }
103     static const char* impact() {
104       return &quot;Low&quot;;
105     }
106     static const JavaPermission permission() {
107       JavaPermission p = {&quot;java.util.PropertyPermission&quot;,
108                           &quot;*&quot;, &quot;read&quot;};
109       return p;
110     }
111     static int num_arguments() { return 0; }
112     virtual void execute(DCmdSource source, TRAPS);
113 };
114 
115 // See also: print_flag in attachListener.cpp
116 class PrintVMFlagsDCmd : public DCmdWithParser {
117 protected:
118   DCmdArgument&lt;bool&gt; _all;
119 public:
120   PrintVMFlagsDCmd(outputStream* output, bool heap);
121   static const char* name() { return &quot;VM.flags&quot;; }
122   static const char* description() {
123     return &quot;Print VM flag options and their current values.&quot;;
124   }
125   static const char* impact() {
126     return &quot;Low&quot;;
127   }
128   static const JavaPermission permission() {
129     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
130                         &quot;monitor&quot;, NULL};
131     return p;
132   }
133   static int num_arguments();
134   virtual void execute(DCmdSource source, TRAPS);
135 };
136 
137 class SetVMFlagDCmd : public DCmdWithParser {
138 protected:
139   DCmdArgument&lt;char*&gt; _flag;
140   DCmdArgument&lt;char*&gt; _value;
141 
142 public:
143   SetVMFlagDCmd(outputStream* output, bool heap);
144   static const char* name() { return &quot;VM.set_flag&quot;; }
145   static const char* description() {
146     return &quot;Sets VM flag option using the provided value.&quot;;
147   }
148   static const char* impact() {
149     return &quot;Low&quot;;
150   }
151   static const JavaPermission permission() {
152     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
153                         &quot;control&quot;, NULL};
154     return p;
155   }
156   static int num_arguments();
157   virtual void execute(DCmdSource source, TRAPS);
158 };
159 
160 class JVMTIDataDumpDCmd : public DCmd {
161 public:
162   JVMTIDataDumpDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
163   static const char* name() { return &quot;JVMTI.data_dump&quot;; }
164   static const char* description() {
165     return &quot;Signal the JVM to do a data-dump request for JVMTI.&quot;;
166   }
167   static const char* impact() {
168     return &quot;High&quot;;
169   }
170   static const JavaPermission permission() {
171     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
172                         &quot;monitor&quot;, NULL};
173     return p;
174   }
175   static int num_arguments() { return 0; }
176   virtual void execute(DCmdSource source, TRAPS);
177 };
178 
179 #if INCLUDE_SERVICES
180 #if INCLUDE_JVMTI
181 class JVMTIAgentLoadDCmd : public DCmdWithParser {
182 protected:
183   DCmdArgument&lt;char*&gt; _libpath;
184   DCmdArgument&lt;char*&gt; _option;
185 public:
186   JVMTIAgentLoadDCmd(outputStream* output, bool heap);
187   static const char* name() { return &quot;JVMTI.agent_load&quot;; }
188   static const char* description() {
189     return &quot;Load JVMTI native agent.&quot;;
190   }
191   static const char* impact() { return &quot;Low&quot;; }
192   static const JavaPermission permission() {
193     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
194                         &quot;control&quot;, NULL};
195     return p;
196   }
197   static int num_arguments();
198   virtual void execute(DCmdSource source, TRAPS);
199 };
200 #endif // INCLUDE_JVMTI
201 #endif // INCLUDE_SERVICES
202 
203 class VMDynamicLibrariesDCmd : public DCmd {
204 public:
205   VMDynamicLibrariesDCmd(outputStream* output, bool heap);
206   static const char* name() {
207     return &quot;VM.dynlibs&quot;;
208   }
209   static const char* description() {
210     return &quot;Print loaded dynamic libraries.&quot;;
211   }
212   static const char* impact() {
213     return &quot;Low&quot;;
214   }
215   static const JavaPermission permission() {
216     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
217                         &quot;monitor&quot;, NULL};
218     return p;
219   }
220   static int num_arguments() {
221     return 0;
222   };
223   virtual void execute(DCmdSource source, TRAPS);
224 };
225 
226 class VMUptimeDCmd : public DCmdWithParser {
227 protected:
228   DCmdArgument&lt;bool&gt; _date;
229 public:
230   VMUptimeDCmd(outputStream* output, bool heap);
231   static const char* name() { return &quot;VM.uptime&quot;; }
232   static const char* description() {
233     return &quot;Print VM uptime.&quot;;
234   }
235   static const char* impact() {
236     return &quot;Low&quot;;
237   }
238   static int num_arguments();
239   virtual void execute(DCmdSource source, TRAPS);
240 };
241 
242 class VMInfoDCmd : public DCmd {
243 public:
244   VMInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
245   static const char* name() { return &quot;VM.info&quot;; }
246   static const char* description() {
247     return &quot;Print information about JVM environment and status.&quot;;
248   }
249   static const char* impact() { return &quot;Low&quot;; }
250   static const JavaPermission permission() {
251     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
252                         &quot;monitor&quot;, NULL};
253     return p;
254   }
255   static int num_arguments() { return 0; }
256   virtual void execute(DCmdSource source, TRAPS);
257 };
258 
259 class SystemGCDCmd : public DCmd {
260 public:
261   SystemGCDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
262     static const char* name() { return &quot;GC.run&quot;; }
263     static const char* description() {
264       return &quot;Call java.lang.System.gc().&quot;;
265     }
266     static const char* impact() {
267       return &quot;Medium: Depends on Java heap size and content.&quot;;
268     }
269     static int num_arguments() { return 0; }
270     virtual void execute(DCmdSource source, TRAPS);
271 };
272 
273 class RunFinalizationDCmd : public DCmd {
274 public:
275   RunFinalizationDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
276     static const char* name() { return &quot;GC.run_finalization&quot;; }
277     static const char* description() {
278       return &quot;Call java.lang.System.runFinalization().&quot;;
279     }
280     static const char* impact() {
281       return &quot;Medium: Depends on Java content.&quot;;
282     }
283     static int num_arguments() { return 0; }
284     virtual void execute(DCmdSource source, TRAPS);
285 };
286 
287 class HeapInfoDCmd : public DCmd {
288 public:
289   HeapInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
290   static const char* name() { return &quot;GC.heap_info&quot;; }
291   static const char* description() {
292     return &quot;Provide generic Java heap information.&quot;;
293   }
294   static const char* impact() {
295     return &quot;Medium&quot;;
296   }
297   static int num_arguments() { return 0; }
298   static const JavaPermission permission() {
299     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
300       &quot;monitor&quot;, NULL};
301       return p;
302   }
303 
304   virtual void execute(DCmdSource source, TRAPS);
305 };
306 
307 class FinalizerInfoDCmd : public DCmd {
308 public:
309   FinalizerInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
310   static const char* name() { return &quot;GC.finalizer_info&quot;; }
311   static const char* description() {
312     return &quot;Provide information about Java finalization queue.&quot;;
313   }
314   static const char* impact() {
315     return &quot;Medium&quot;;
316   }
317   static int num_arguments() { return 0; }
318   static const JavaPermission permission() {
319     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
320       &quot;monitor&quot;, NULL};
321       return p;
322   }
323 
324   virtual void execute(DCmdSource source, TRAPS);
325 };
326 
327 #if INCLUDE_SERVICES   // Heap dumping supported
328 // See also: dump_heap in attachListener.cpp
329 class HeapDumpDCmd : public DCmdWithParser {
330 protected:
331   DCmdArgument&lt;char*&gt; _filename;
332   DCmdArgument&lt;bool&gt;  _all;
333 public:
334   HeapDumpDCmd(outputStream* output, bool heap);
335   static const char* name() {
336     return &quot;GC.heap_dump&quot;;
337   }
338   static const char* description() {
339     return &quot;Generate a HPROF format dump of the Java heap.&quot;;
340   }
341   static const char* impact() {
342     return &quot;High: Depends on Java heap size and content. &quot;
343            &quot;Request a full GC unless the &#39;-all&#39; option is specified.&quot;;
344   }
345   static const JavaPermission permission() {
346     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
347                         &quot;monitor&quot;, NULL};
348     return p;
349   }
350   static int num_arguments();
351   virtual void execute(DCmdSource source, TRAPS);
352 };
353 #endif // INCLUDE_SERVICES
354 
355 // See also: inspectheap in attachListener.cpp
356 class ClassHistogramDCmd : public DCmdWithParser {
357 protected:
358   DCmdArgument&lt;bool&gt; _all;
359 public:
360   ClassHistogramDCmd(outputStream* output, bool heap);
361   static const char* name() {
362     return &quot;GC.class_histogram&quot;;
363   }
364   static const char* description() {
365     return &quot;Provide statistics about the Java heap usage.&quot;;
366   }
367   static const char* impact() {
368     return &quot;High: Depends on Java heap size and content.&quot;;
369   }
370   static const JavaPermission permission() {
371     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
372                         &quot;monitor&quot;, NULL};
373     return p;
374   }
375   static int num_arguments();
376   virtual void execute(DCmdSource source, TRAPS);
377 };
378 
<a name="2" id="anc2"></a>





















379 class ClassHierarchyDCmd : public DCmdWithParser {
380 protected:
381   DCmdArgument&lt;bool&gt; _print_interfaces; // true if inherited interfaces should be printed.
382   DCmdArgument&lt;bool&gt; _print_subclasses; // true if subclasses of the specified classname should be printed.
383   DCmdArgument&lt;char*&gt; _classname; // Optional single class name whose hierarchy should be printed.
384 public:
385   ClassHierarchyDCmd(outputStream* output, bool heap);
386   static const char* name() {
387     return &quot;VM.class_hierarchy&quot;;
388   }
389   static const char* description() {
390     return &quot;Print a list of all loaded classes, indented to show the class hiearchy. &quot;
391            &quot;The name of each class is followed by the ClassLoaderData* of its ClassLoader, &quot;
392            &quot;or \&quot;null\&quot; if loaded by the bootstrap class loader.&quot;;
393   }
394   static const char* impact() {
395       return &quot;Medium: Depends on number of loaded classes.&quot;;
396   }
397   static const JavaPermission permission() {
398     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
399                         &quot;monitor&quot;, NULL};
400     return p;
401   }
402   static int num_arguments();
403   virtual void execute(DCmdSource source, TRAPS);
404 };
405 
406 class TouchedMethodsDCmd : public DCmdWithParser {
407 public:
408   TouchedMethodsDCmd(outputStream* output, bool heap);
409   static const char* name() {
410     return &quot;VM.print_touched_methods&quot;;
411   }
412   static const char* description() {
413     return &quot;Print all methods that have ever been touched during the lifetime of this JVM.&quot;;
414   }
415   static const char* impact() {
416     return &quot;Medium: Depends on Java content.&quot;;
417   }
418   static int num_arguments();
419   virtual void execute(DCmdSource source, TRAPS);
420 };
421 
422 // See also: thread_dump in attachListener.cpp
423 class ThreadDumpDCmd : public DCmdWithParser {
424 protected:
425   DCmdArgument&lt;bool&gt; _locks;
426   DCmdArgument&lt;bool&gt; _extended;
427 public:
428   ThreadDumpDCmd(outputStream* output, bool heap);
429   static const char* name() { return &quot;Thread.print&quot;; }
430   static const char* description() {
431     return &quot;Print all threads with stacktraces.&quot;;
432   }
433   static const char* impact() {
434     return &quot;Medium: Depends on the number of threads.&quot;;
435   }
436   static const JavaPermission permission() {
437     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
438                         &quot;monitor&quot;, NULL};
439     return p;
440   }
441   static int num_arguments();
442   virtual void execute(DCmdSource source, TRAPS);
443 };
444 
445 // Enhanced JMX Agent support
446 
447 class JMXStartRemoteDCmd : public DCmdWithParser {
448 
449   // Explicitly list all properties that could be
450   // passed to Agent.startRemoteManagementAgent()
451   // com.sun.management is omitted
452 
453   DCmdArgument&lt;char *&gt; _config_file;
454   DCmdArgument&lt;char *&gt; _jmxremote_host;
455   DCmdArgument&lt;char *&gt; _jmxremote_port;
456   DCmdArgument&lt;char *&gt; _jmxremote_rmi_port;
457   DCmdArgument&lt;char *&gt; _jmxremote_ssl;
458   DCmdArgument&lt;char *&gt; _jmxremote_registry_ssl;
459   DCmdArgument&lt;char *&gt; _jmxremote_authenticate;
460   DCmdArgument&lt;char *&gt; _jmxremote_password_file;
461   DCmdArgument&lt;char *&gt; _jmxremote_access_file;
462   DCmdArgument&lt;char *&gt; _jmxremote_login_config;
463   DCmdArgument&lt;char *&gt; _jmxremote_ssl_enabled_cipher_suites;
464   DCmdArgument&lt;char *&gt; _jmxremote_ssl_enabled_protocols;
465   DCmdArgument&lt;char *&gt; _jmxremote_ssl_need_client_auth;
466   DCmdArgument&lt;char *&gt; _jmxremote_ssl_config_file;
467 
468   // JDP support
469   // Keep autodiscovery char* not bool to pass true/false
470   // as property value to java level.
471   DCmdArgument&lt;char *&gt; _jmxremote_autodiscovery;
472   DCmdArgument&lt;jlong&gt;  _jdp_port;
473   DCmdArgument&lt;char *&gt; _jdp_address;
474   DCmdArgument&lt;char *&gt; _jdp_source_addr;
475   DCmdArgument&lt;jlong&gt;  _jdp_ttl;
476   DCmdArgument&lt;jlong&gt;  _jdp_pause;
477   DCmdArgument&lt;char *&gt; _jdp_name;
478 
479 public:
480   JMXStartRemoteDCmd(outputStream *output, bool heap_allocated);
481 
482   static const char *name() {
483     return &quot;ManagementAgent.start&quot;;
484   }
485 
486   static const char *description() {
487     return &quot;Start remote management agent.&quot;;
488   }
489 
490   static int num_arguments();
491 
492   virtual void execute(DCmdSource source, TRAPS);
493 
494 };
495 
496 class JMXStartLocalDCmd : public DCmd {
497 
498   // Explicitly request start of local agent,
499   // it will not be started by start dcmd
500 
501 
502 public:
503   JMXStartLocalDCmd(outputStream *output, bool heap_allocated);
504 
505   static const char *name() {
506     return &quot;ManagementAgent.start_local&quot;;
507   }
508 
509   static const char *description() {
510     return &quot;Start local management agent.&quot;;
511   }
512 
513   virtual void execute(DCmdSource source, TRAPS);
514 
515 };
516 
517 class JMXStopRemoteDCmd : public DCmd {
518 public:
519   JMXStopRemoteDCmd(outputStream *output, bool heap_allocated) :
520   DCmd(output, heap_allocated) {
521     // Do Nothing
522   }
523 
524   static const char *name() {
525     return &quot;ManagementAgent.stop&quot;;
526   }
527 
528   static const char *description() {
529     return &quot;Stop remote management agent.&quot;;
530   }
531 
532   virtual void execute(DCmdSource source, TRAPS);
533 };
534 
535 // Print the JMX system status
536 class JMXStatusDCmd : public DCmd {
537 public:
538   JMXStatusDCmd(outputStream *output, bool heap_allocated);
539 
540   static const char *name() {
541     return &quot;ManagementAgent.status&quot;;
542   }
543 
544   static const char *description() {
545     return &quot;Print the management agent status.&quot;;
546   }
547 
548   static const JavaPermission permission() {
549     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
550                         &quot;monitor&quot;, NULL};
551     return p;
552   }
553 
554   virtual void execute(DCmdSource source, TRAPS);
555 
556 };
557 
558 class CompileQueueDCmd : public DCmd {
559 public:
560   CompileQueueDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
561   static const char* name() {
562     return &quot;Compiler.queue&quot;;
563   }
564   static const char* description() {
565     return &quot;Print methods queued for compilation.&quot;;
566   }
567   static const char* impact() {
568     return &quot;Low&quot;;
569   }
570   static const JavaPermission permission() {
571     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
572                         &quot;monitor&quot;, NULL};
573     return p;
574   }
575   static int num_arguments() { return 0; }
576   virtual void execute(DCmdSource source, TRAPS);
577 };
578 
579 class CodeListDCmd : public DCmd {
580 public:
581   CodeListDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
582   static const char* name() {
583     return &quot;Compiler.codelist&quot;;
584   }
585   static const char* description() {
586     return &quot;Print all compiled methods in code cache that are alive&quot;;
587   }
588   static const char* impact() {
589     return &quot;Medium&quot;;
590   }
591   static const JavaPermission permission() {
592     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
593                         &quot;monitor&quot;, NULL};
594     return p;
595   }
596   static int num_arguments() { return 0; }
597   virtual void execute(DCmdSource source, TRAPS);
598 };
599 
600 
601 class CodeCacheDCmd : public DCmd {
602 public:
603   CodeCacheDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
604   static const char* name() {
605     return &quot;Compiler.codecache&quot;;
606   }
607   static const char* description() {
608     return &quot;Print code cache layout and bounds.&quot;;
609   }
610   static const char* impact() {
611     return &quot;Low&quot;;
612   }
613   static const JavaPermission permission() {
614     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
615                         &quot;monitor&quot;, NULL};
616     return p;
617   }
618   static int num_arguments() { return 0; }
619   virtual void execute(DCmdSource source, TRAPS);
620 };
621 
622 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
623 class CodeHeapAnalyticsDCmd : public DCmdWithParser {
624 protected:
625   DCmdArgument&lt;char*&gt; _function;
<a name="3" id="anc3"></a><span class="line-modified">626   DCmdArgument&lt;jlong&gt; _granularity;</span>
627 public:
628   CodeHeapAnalyticsDCmd(outputStream* output, bool heap);
629   static const char* name() {
630     return &quot;Compiler.CodeHeap_Analytics&quot;;
631   }
632   static const char* description() {
633     return &quot;Print CodeHeap analytics&quot;;
634   }
635   static const char* impact() {
636     return &quot;Low: Depends on code heap size and content. &quot;
637            &quot;Holds CodeCache_lock during analysis step, usually sub-second duration.&quot;;
638   }
639   static const JavaPermission permission() {
640     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
641                         &quot;monitor&quot;, NULL};
642     return p;
643   }
644   static int num_arguments();
645   virtual void execute(DCmdSource source, TRAPS);
646 };
647 //---&lt;  END  &gt;--- CodeHeap State Analytics.
648 
649 class CompilerDirectivesPrintDCmd : public DCmd {
650 public:
651   CompilerDirectivesPrintDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
652   static const char* name() {
653     return &quot;Compiler.directives_print&quot;;
654   }
655   static const char* description() {
656     return &quot;Print all active compiler directives.&quot;;
657   }
658   static const char* impact() {
659     return &quot;Low&quot;;
660   }
661   static const JavaPermission permission() {
662     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
663                         &quot;monitor&quot;, NULL};
664     return p;
665   }
666   static int num_arguments() { return 0; }
667   virtual void execute(DCmdSource source, TRAPS);
668 };
669 
670 class CompilerDirectivesRemoveDCmd : public DCmd {
671 public:
672   CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
673   static const char* name() {
674     return &quot;Compiler.directives_remove&quot;;
675   }
676   static const char* description() {
677     return &quot;Remove latest added compiler directive.&quot;;
678   }
679   static const char* impact() {
680     return &quot;Low&quot;;
681   }
682   static const JavaPermission permission() {
683     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
684                         &quot;monitor&quot;, NULL};
685     return p;
686   }
687   static int num_arguments() { return 0; }
688   virtual void execute(DCmdSource source, TRAPS);
689 };
690 
691 class CompilerDirectivesAddDCmd : public DCmdWithParser {
692 protected:
693   DCmdArgument&lt;char*&gt; _filename;
694 public:
695   CompilerDirectivesAddDCmd(outputStream* output, bool heap);
696   static const char* name() {
697     return &quot;Compiler.directives_add&quot;;
698   }
699   static const char* description() {
700     return &quot;Add compiler directives from file.&quot;;
701   }
702   static const char* impact() {
703     return &quot;Low&quot;;
704   }
705   static const JavaPermission permission() {
706     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
707                         &quot;monitor&quot;, NULL};
708     return p;
709   }
710   static int num_arguments();
711   virtual void execute(DCmdSource source, TRAPS);
712 };
713 
714 class CompilerDirectivesClearDCmd : public DCmd {
715 public:
716   CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
717   static const char* name() {
718     return &quot;Compiler.directives_clear&quot;;
719   }
720   static const char* description() {
721     return &quot;Remove all compiler directives.&quot;;
722   }
723   static const char* impact() {
724     return &quot;Low&quot;;
725   }
726   static const JavaPermission permission() {
727     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
728                         &quot;monitor&quot;, NULL};
729     return p;
730   }
731   static int num_arguments() { return 0; }
732   virtual void execute(DCmdSource source, TRAPS);
733 };
734 
735 ///////////////////////////////////////////////////////////////////////
736 //
737 // jcmd command support for symbol table, string table and system dictionary dumping:
738 //   VM.symboltable -verbose: for dumping the symbol table
739 //   VM.stringtable -verbose: for dumping the string table
740 //   VM.systemdictionary -verbose: for dumping the system dictionary table
741 //
742 class VM_DumpHashtable : public VM_Operation {
743 private:
744   outputStream* _out;
745   int _which;
746   bool _verbose;
747 public:
748   enum {
749     DumpSymbols = 1 &lt;&lt; 0,
750     DumpStrings = 1 &lt;&lt; 1,
751     DumpSysDict = 1 &lt;&lt; 2  // not implemented yet
752   };
753   VM_DumpHashtable(outputStream* out, int which, bool verbose) {
754     _out = out;
755     _which = which;
756     _verbose = verbose;
757   }
758 
759   virtual VMOp_Type type() const { return VMOp_DumpHashtable; }
760 
761   virtual void doit() {
762     switch (_which) {
763     case DumpSymbols:
764       SymbolTable::dump(_out, _verbose);
765       break;
766     case DumpStrings:
767       StringTable::dump(_out, _verbose);
768       break;
769     case DumpSysDict:
770       SystemDictionary::dump(_out, _verbose);
771       break;
772     default:
773       ShouldNotReachHere();
774     }
775   }
776 };
777 
778 class SymboltableDCmd : public DCmdWithParser {
779 protected:
780   DCmdArgument&lt;bool&gt; _verbose;
781 public:
782   SymboltableDCmd(outputStream* output, bool heap);
783   static const char* name() {
784     return &quot;VM.symboltable&quot;;
785   }
786   static const char* description() {
787     return &quot;Dump symbol table.&quot;;
788   }
789   static const char* impact() {
790     return &quot;Medium: Depends on Java content.&quot;;
791   }
792   static const JavaPermission permission() {
793     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
794                         &quot;monitor&quot;, NULL};
795     return p;
796   }
797   static int num_arguments();
798   virtual void execute(DCmdSource source, TRAPS);
799 };
800 
801 class StringtableDCmd : public DCmdWithParser {
802 protected:
803   DCmdArgument&lt;bool&gt; _verbose;
804 public:
805   StringtableDCmd(outputStream* output, bool heap);
806   static const char* name() {
807     return &quot;VM.stringtable&quot;;
808   }
809   static const char* description() {
810     return &quot;Dump string table.&quot;;
811   }
812   static const char* impact() {
813     return &quot;Medium: Depends on Java content.&quot;;
814   }
815   static const JavaPermission permission() {
816     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
817                         &quot;monitor&quot;, NULL};
818     return p;
819   }
820   static int num_arguments();
821   virtual void execute(DCmdSource source, TRAPS);
822 };
823 
824 class SystemDictionaryDCmd : public DCmdWithParser {
825 protected:
826   DCmdArgument&lt;bool&gt; _verbose;
827 public:
828   SystemDictionaryDCmd(outputStream* output, bool heap);
829   static const char* name() {
830     return &quot;VM.systemdictionary&quot;;
831   }
832   static const char* description() {
833     return &quot;Prints the statistics for dictionary hashtable sizes and bucket length&quot;;
834   }
835   static const char* impact() {
836       return &quot;Medium: Depends on Java content.&quot;;
837   }
838   static const JavaPermission permission() {
839     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
840                         &quot;monitor&quot;, NULL};
841     return p;
842   }
843   static int num_arguments();
844   virtual void execute(DCmdSource source, TRAPS);
845 };
846 
847 #if INCLUDE_JVMTI
848 class DebugOnCmdStartDCmd : public DCmdWithParser {
849 public:
850   DebugOnCmdStartDCmd(outputStream* output, bool heap);
851   static const char* name() {
852     return &quot;VM.start_java_debugging&quot;;
853   }
854   static const char* description() {
855     return &quot;Starts up the Java debugging if the jdwp agentlib was enabled with the option onjcmd=y.&quot;;
856   }
857   static const char* impact() {
858     return &quot;High: Switches the VM into Java debug mode.&quot;;
859   }
860   static const JavaPermission permission() {
<a name="4" id="anc4"></a><span class="line-modified">861     JavaPermission p = { &quot;java.lang.management.ManagementPermission&quot;, &quot;control&quot;, NULL };</span>
862     return p;
863   }
864   static int num_arguments() { return 0; }
865   virtual void execute(DCmdSource source, TRAPS);
866 };
867 #endif // INCLUDE_JVMTI
868 
<a name="5" id="anc5"></a><span class="line-added">869 class EventLogDCmd : public DCmdWithParser {</span>
<span class="line-added">870 protected:</span>
<span class="line-added">871   DCmdArgument&lt;char*&gt; _log;</span>
<span class="line-added">872   DCmdArgument&lt;char*&gt; _max;</span>
<span class="line-added">873 public:</span>
<span class="line-added">874   EventLogDCmd(outputStream* output, bool heap);</span>
<span class="line-added">875   static const char* name() {</span>
<span class="line-added">876     return &quot;VM.events&quot;;</span>
<span class="line-added">877   }</span>
<span class="line-added">878   static const char* description() {</span>
<span class="line-added">879     return &quot;Print VM event logs&quot;;</span>
<span class="line-added">880   }</span>
<span class="line-added">881   static const char* impact() {</span>
<span class="line-added">882     return &quot;Low: Depends on event log size. &quot;;</span>
<span class="line-added">883   }</span>
<span class="line-added">884   static const JavaPermission permission() {</span>
<span class="line-added">885     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,</span>
<span class="line-added">886                         &quot;monitor&quot;, NULL};</span>
<span class="line-added">887     return p;</span>
<span class="line-added">888   }</span>
<span class="line-added">889   static int num_arguments();</span>
<span class="line-added">890   virtual void execute(DCmdSource source, TRAPS);</span>
<span class="line-added">891 };</span>
<span class="line-added">892 </span>
893 #endif // SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
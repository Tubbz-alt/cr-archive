<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nmtDCmd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/threadService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;memory/allocation.hpp&quot;
  28 #include &quot;memory/heapInspection.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/instanceKlass.hpp&quot;

  32 #include &quot;oops/objArrayOop.inline.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;

  34 #include &quot;runtime/atomic.hpp&quot;
  35 #include &quot;runtime/handles.inline.hpp&quot;
  36 #include &quot;runtime/init.hpp&quot;
  37 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  38 #include &quot;runtime/thread.inline.hpp&quot;
  39 #include &quot;runtime/threadSMR.inline.hpp&quot;
  40 #include &quot;runtime/vframe.hpp&quot;
  41 #include &quot;runtime/vmThread.hpp&quot;
  42 #include &quot;runtime/vmOperations.hpp&quot;
  43 #include &quot;services/threadService.hpp&quot;
  44 
  45 // TODO: we need to define a naming convention for perf counters
  46 // to distinguish counters for:
  47 //   - standard JSR174 use
  48 //   - Hotspot extension (public and committed)
  49 //   - Hotspot extension (private/internal and uncommitted)
  50 
  51 // Default is disabled.
  52 bool ThreadService::_thread_monitoring_contention_enabled = false;
  53 bool ThreadService::_thread_cpu_time_enabled = false;
</pre>
<hr />
<pre>
  80                                                  PerfData::U_None, CHECK);
  81 
  82   _peak_threads_count =
  83                 PerfDataManager::create_variable(JAVA_THREADS, &quot;livePeak&quot;,
  84                                                  PerfData::U_None, CHECK);
  85 
  86   _daemon_threads_count =
  87                 PerfDataManager::create_variable(JAVA_THREADS, &quot;daemon&quot;,
  88                                                  PerfData::U_None, CHECK);
  89 
  90   if (os::is_thread_cpu_time_supported()) {
  91     _thread_cpu_time_enabled = true;
  92   }
  93 
  94   _thread_allocated_memory_enabled = true; // Always on, so enable it
  95 }
  96 
  97 void ThreadService::reset_peak_thread_count() {
  98   // Acquire the lock to update the peak thread count
  99   // to synchronize with thread addition and removal.
<span class="line-modified"> 100   MutexLockerEx mu(Threads_lock);</span>
 101   _peak_threads_count-&gt;set_value(get_live_thread_count());
 102 }
 103 
 104 static bool is_hidden_thread(JavaThread *thread) {
 105   // hide VM internal or JVMTI agent threads
 106   return thread-&gt;is_hidden_from_external_view() || thread-&gt;is_jvmti_agent_thread();
 107 }
 108 
 109 void ThreadService::add_thread(JavaThread* thread, bool daemon) {
 110   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 111 
 112   // Do not count hidden threads
 113   if (is_hidden_thread(thread)) {
 114     return;
 115   }
 116 
 117   _total_threads_count-&gt;inc();
 118   _live_threads_count-&gt;inc();
 119   Atomic::inc(&amp;_atomic_threads_count);
 120   int count = _atomic_threads_count;
</pre>
<hr />
<pre>
 199   assert(!jt-&gt;is_terminated() &amp;&amp; jt-&gt;is_exiting(), &quot;must be exiting&quot;);
 200 
 201   decrement_thread_counts(jt, daemon);
 202 }
 203 
 204 // FIXME: JVMTI should call this function
 205 Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
 206   assert(thread != NULL, &quot;should be non-NULL&quot;);
 207   debug_only(Thread::check_for_dangling_thread_pointer(thread);)
 208 
 209   ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
 210 
 211   oop obj = NULL;
 212   if (wait_obj != NULL) {
 213     // thread is doing an Object.wait() call
 214     obj = (oop) wait_obj-&gt;object();
 215     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 216   } else {
 217     ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
 218     if (enter_obj != NULL) {
<span class="line-modified"> 219       // thread is trying to enter() or raw_enter() an ObjectMonitor.</span>
 220       obj = (oop) enter_obj-&gt;object();

 221     }
<span class="line-removed"> 222     // If obj == NULL, then ObjectMonitor is raw which doesn&#39;t count.</span>
 223   }
 224 
 225   Handle h(Thread::current(), obj);
 226   return h;
 227 }
 228 
 229 bool ThreadService::set_thread_monitoring_contention(bool flag) {
 230   MutexLocker m(Management_lock);
 231 
 232   bool prev = _thread_monitoring_contention_enabled;
 233   _thread_monitoring_contention_enabled = flag;
 234 
 235   return prev;
 236 }
 237 
 238 bool ThreadService::set_thread_cpu_time_enabled(bool flag) {
 239   MutexLocker m(Management_lock);
 240 
 241   bool prev = _thread_cpu_time_enabled;
 242   _thread_cpu_time_enabled = flag;
</pre>
<hr />
<pre>
 336     }
 337   }
 338 
 339   return result_obj;
 340 }
 341 
 342 void ThreadService::reset_contention_count_stat(JavaThread* thread) {
 343   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 344   if (stat != NULL) {
 345     stat-&gt;reset_count_stat();
 346   }
 347 }
 348 
 349 void ThreadService::reset_contention_time_stat(JavaThread* thread) {
 350   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 351   if (stat != NULL) {
 352     stat-&gt;reset_time_stat();
 353   }
 354 }
 355 
<span class="line-modified"> 356 // Find deadlocks involving object monitors and concurrent locks if concurrent_locks is true</span>

 357 DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
 358   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 359 
 360   // This code was modified from the original Threads::find_deadlocks code.
 361   int globalDfn = 0, thisDfn;
 362   ObjectMonitor* waitingToLockMonitor = NULL;

 363   oop waitingToLockBlocker = NULL;
 364   bool blocked_on_monitor = false;
 365   JavaThread *currentThread, *previousThread;
 366   int num_deadlocks = 0;
 367 
 368   // Initialize the depth-first-number for each JavaThread.
 369   JavaThreadIterator jti(t_list);
 370   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 371     jt-&gt;set_depth_first_number(-1);
 372   }
 373 
 374   DeadlockCycle* deadlocks = NULL;
 375   DeadlockCycle* last = NULL;
 376   DeadlockCycle* cycle = new DeadlockCycle();
 377   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 378     if (jt-&gt;depth_first_number() &gt;= 0) {
 379       // this thread was already visited
 380       continue;
 381     }
 382 
 383     thisDfn = globalDfn;
 384     jt-&gt;set_depth_first_number(globalDfn++);
 385     previousThread = jt;
 386     currentThread = jt;
 387 
 388     cycle-&gt;reset();
 389 
 390     // When there is a deadlock, all the monitors involved in the dependency
 391     // cycle must be contended and heavyweight. So we only care about the
 392     // heavyweight monitor a thread is waiting to lock.
<span class="line-modified"> 393     waitingToLockMonitor = (ObjectMonitor*)jt-&gt;current_pending_monitor();</span>






 394     if (concurrent_locks) {
 395       waitingToLockBlocker = jt-&gt;current_park_blocker();
 396     }
<span class="line-modified"> 397     while (waitingToLockMonitor != NULL || waitingToLockBlocker != NULL) {</span>



 398       cycle-&gt;add_thread(currentThread);
<span class="line-modified"> 399       if (waitingToLockMonitor != NULL) {</span>








 400         address currentOwner = (address)waitingToLockMonitor-&gt;owner();
 401         if (currentOwner != NULL) {
 402           currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 403                                                                     currentOwner);
 404           if (currentThread == NULL) {
 405             // This function is called at a safepoint so the JavaThread
 406             // that owns waitingToLockMonitor should be findable, but
 407             // if it is not findable, then the previous currentThread is
 408             // blocked permanently. We record this as a deadlock.
 409             num_deadlocks++;
 410 
 411             cycle-&gt;set_deadlock(true);
 412 
 413             // add this cycle to the deadlocks list
 414             if (deadlocks == NULL) {
 415               deadlocks = cycle;
 416             } else {
 417               last-&gt;set_next(cycle);
 418             }
 419             last = cycle;
</pre>
<hr />
<pre>
 662     // Iterate inflated monitors and find monitors locked by this thread
 663     // not found in the stack
 664     InflatedMonitorsClosure imc(_thread, this);
 665     ObjectSynchronizer::monitors_iterate(&amp;imc);
 666   }
 667 }
 668 
 669 
 670 bool ThreadStackTrace::is_owned_monitor_on_stack(oop object) {
 671   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 672 
 673   bool found = false;
 674   int num_frames = get_stack_depth();
 675   for (int depth = 0; depth &lt; num_frames; depth++) {
 676     StackFrameInfo* frame = stack_frame_at(depth);
 677     int len = frame-&gt;num_locked_monitors();
 678     GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
 679     for (int j = 0; j &lt; len; j++) {
 680       oop monitor = locked_monitors-&gt;at(j);
 681       assert(monitor != NULL, &quot;must be a Java object&quot;);
<span class="line-modified"> 682       if (oopDesc::equals(monitor, object)) {</span>
 683         found = true;
 684         break;
 685       }
 686     }
 687   }
 688   return found;
 689 }
 690 
 691 Handle ThreadStackTrace::allocate_fill_stack_trace_element_array(TRAPS) {
 692   InstanceKlass* ik = SystemDictionary::StackTraceElement_klass();
 693   assert(ik != NULL, &quot;must be loaded in 1.4+&quot;);
 694 
 695   // Allocate an array of java/lang/StackTraceElement object
 696   objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);
 697   objArrayHandle backtrace(THREAD, ste);
 698   for (int j = 0; j &lt; _depth; j++) {
 699     StackFrameInfo* frame = _frames-&gt;at(j);
 700     methodHandle mh(THREAD, frame-&gt;method());
 701     oop element = java_lang_StackTraceElement::create(mh, frame-&gt;bci(), CHECK_NH);
 702     backtrace-&gt;obj_at_put(j, element);
</pre>
<hr />
<pre>
 875     } else {
 876       _blocker_object = obj();
 877       JavaThread* owner = ObjectSynchronizer::get_lock_owner(t_list, obj);
 878       if ((owner == NULL &amp;&amp; _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
 879           || (owner != NULL &amp;&amp; owner-&gt;is_attaching_via_jni())) {
 880         // ownership information of the monitor is not available
 881         // (may no longer be owned or releasing to some other thread)
 882         // make this thread in RUNNABLE state.
 883         // And when the owner thread is in attaching state, the java thread
 884         // is not completely initialized. For example thread name and id
 885         // and may not be set, so hide the attaching thread.
 886         _thread_status = java_lang_Thread::RUNNABLE;
 887         _blocker_object = NULL;
 888       } else if (owner != NULL) {
 889         _blocker_object_owner = owner-&gt;threadObj();
 890       }
 891     }
 892   }
 893 
 894   // Support for JSR-166 locks
<span class="line-modified"> 895   if (JDK_Version::current().supports_thread_park_blocker() &amp;&amp;</span>
<span class="line-removed"> 896         (_thread_status == java_lang_Thread::PARKED ||</span>
<span class="line-removed"> 897          _thread_status == java_lang_Thread::PARKED_TIMED)) {</span>
<span class="line-removed"> 898 </span>
 899     _blocker_object = thread-&gt;current_park_blocker();
 900     if (_blocker_object != NULL &amp;&amp; _blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 901       _blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(_blocker_object);
 902     }
 903   }
 904 }
 905 
 906 ThreadSnapshot::~ThreadSnapshot() {
 907   delete _stack_trace;
 908   delete _concurrent_locks;
 909 }
 910 
 911 void ThreadSnapshot::dump_stack_at_safepoint(int max_depth, bool with_locked_monitors) {
 912   _stack_trace = new ThreadStackTrace(_thread, with_locked_monitors);
 913   _stack_trace-&gt;dump_stack_at_safepoint(max_depth);
 914 }
 915 
 916 
 917 void ThreadSnapshot::oops_do(OopClosure* f) {
 918   f-&gt;do_oop(&amp;_threadObj);
</pre>
<hr />
<pre>
 933 }
 934 
 935 
 936 DeadlockCycle::DeadlockCycle() {
 937   _is_deadlock = false;
 938   _threads = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, true);
 939   _next = NULL;
 940 }
 941 
 942 DeadlockCycle::~DeadlockCycle() {
 943   delete _threads;
 944 }
 945 
 946 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 947   st-&gt;cr();
 948   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 949   st-&gt;print(&quot;=============================&quot;);
 950 
 951   JavaThread* currentThread;
 952   ObjectMonitor* waitingToLockMonitor;

 953   oop waitingToLockBlocker;
 954   int len = _threads-&gt;length();
 955   for (int i = 0; i &lt; len; i++) {
 956     currentThread = _threads-&gt;at(i);
<span class="line-modified"> 957     waitingToLockMonitor = (ObjectMonitor*)currentThread-&gt;current_pending_monitor();</span>

 958     waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 959     st-&gt;cr();
 960     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
 961     const char* owner_desc = &quot;,\n  which is held by&quot;;



















 962     if (waitingToLockMonitor != NULL) {
 963       st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
 964       oop obj = (oop)waitingToLockMonitor-&gt;object();
<span class="line-modified"> 965       if (obj != NULL) {</span>
<span class="line-modified"> 966         st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),</span>
<span class="line-removed"> 967                    obj-&gt;klass()-&gt;external_name());</span>
 968 
<span class="line-modified"> 969         if (!currentThread-&gt;current_pending_monitor_is_from_java()) {</span>
<span class="line-modified"> 970           owner_desc = &quot;\n  in JNI, which is held by&quot;;</span>
<span class="line-removed"> 971         }</span>
<span class="line-removed"> 972       } else {</span>
<span class="line-removed"> 973         // No Java object associated - a JVMTI raw monitor</span>
<span class="line-removed"> 974         owner_desc = &quot; (JVMTI raw monitor),\n  which is held by&quot;;</span>
 975       }
 976       currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 977                                                                 (address)waitingToLockMonitor-&gt;owner());
 978       if (currentThread == NULL) {
 979         // The deadlock was detected at a safepoint so the JavaThread
 980         // that owns waitingToLockMonitor should be findable, but
 981         // if it is not findable, then the previous currentThread is
 982         // blocked permanently.
<span class="line-modified"> 983         st-&gt;print(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,</span>
 984                   p2i(waitingToLockMonitor-&gt;owner()));
 985         continue;
 986       }
 987     } else {
 988       st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
 989                 p2i(waitingToLockBlocker),
 990                 waitingToLockBlocker-&gt;klass()-&gt;external_name());
 991       assert(waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass()),
 992              &quot;Must be an AbstractOwnableSynchronizer&quot;);
 993       oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
 994       currentThread = java_lang_Thread::thread(ownerObj);
 995       assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
 996     }
<span class="line-modified"> 997     st-&gt;print(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
 998   }
 999 
<span class="line-removed">1000   st-&gt;cr();</span>
1001   st-&gt;cr();
1002 
1003   // Print stack traces
1004   bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
1005   JavaMonitorsInStackTrace = true;
1006   st-&gt;print_cr(&quot;Java stack information for the threads listed above:&quot;);
1007   st-&gt;print_cr(&quot;===================================================&quot;);
1008   for (int j = 0; j &lt; len; j++) {
1009     currentThread = _threads-&gt;at(j);
1010     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
1011     currentThread-&gt;print_stack_on(st);
1012   }
1013   JavaMonitorsInStackTrace = oldJavaMonitorsInStackTrace;
1014 }
1015 
1016 ThreadsListEnumerator::ThreadsListEnumerator(Thread* cur_thread,
1017                                              bool include_jvmti_agent_threads,
1018                                              bool include_jni_attaching_threads) {
1019   assert(cur_thread == Thread::current(), &quot;Check current thread&quot;);
1020 
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;memory/allocation.hpp&quot;
  28 #include &quot;memory/heapInspection.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-added">  32 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  33 #include &quot;oops/objArrayOop.inline.hpp&quot;
  34 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  35 #include &quot;prims/jvmtiRawMonitor.hpp&quot;</span>
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/handles.inline.hpp&quot;
  38 #include &quot;runtime/init.hpp&quot;
  39 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  40 #include &quot;runtime/thread.inline.hpp&quot;
  41 #include &quot;runtime/threadSMR.inline.hpp&quot;
  42 #include &quot;runtime/vframe.hpp&quot;
  43 #include &quot;runtime/vmThread.hpp&quot;
  44 #include &quot;runtime/vmOperations.hpp&quot;
  45 #include &quot;services/threadService.hpp&quot;
  46 
  47 // TODO: we need to define a naming convention for perf counters
  48 // to distinguish counters for:
  49 //   - standard JSR174 use
  50 //   - Hotspot extension (public and committed)
  51 //   - Hotspot extension (private/internal and uncommitted)
  52 
  53 // Default is disabled.
  54 bool ThreadService::_thread_monitoring_contention_enabled = false;
  55 bool ThreadService::_thread_cpu_time_enabled = false;
</pre>
<hr />
<pre>
  82                                                  PerfData::U_None, CHECK);
  83 
  84   _peak_threads_count =
  85                 PerfDataManager::create_variable(JAVA_THREADS, &quot;livePeak&quot;,
  86                                                  PerfData::U_None, CHECK);
  87 
  88   _daemon_threads_count =
  89                 PerfDataManager::create_variable(JAVA_THREADS, &quot;daemon&quot;,
  90                                                  PerfData::U_None, CHECK);
  91 
  92   if (os::is_thread_cpu_time_supported()) {
  93     _thread_cpu_time_enabled = true;
  94   }
  95 
  96   _thread_allocated_memory_enabled = true; // Always on, so enable it
  97 }
  98 
  99 void ThreadService::reset_peak_thread_count() {
 100   // Acquire the lock to update the peak thread count
 101   // to synchronize with thread addition and removal.
<span class="line-modified"> 102   MutexLocker mu(Threads_lock);</span>
 103   _peak_threads_count-&gt;set_value(get_live_thread_count());
 104 }
 105 
 106 static bool is_hidden_thread(JavaThread *thread) {
 107   // hide VM internal or JVMTI agent threads
 108   return thread-&gt;is_hidden_from_external_view() || thread-&gt;is_jvmti_agent_thread();
 109 }
 110 
 111 void ThreadService::add_thread(JavaThread* thread, bool daemon) {
 112   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 113 
 114   // Do not count hidden threads
 115   if (is_hidden_thread(thread)) {
 116     return;
 117   }
 118 
 119   _total_threads_count-&gt;inc();
 120   _live_threads_count-&gt;inc();
 121   Atomic::inc(&amp;_atomic_threads_count);
 122   int count = _atomic_threads_count;
</pre>
<hr />
<pre>
 201   assert(!jt-&gt;is_terminated() &amp;&amp; jt-&gt;is_exiting(), &quot;must be exiting&quot;);
 202 
 203   decrement_thread_counts(jt, daemon);
 204 }
 205 
 206 // FIXME: JVMTI should call this function
 207 Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
 208   assert(thread != NULL, &quot;should be non-NULL&quot;);
 209   debug_only(Thread::check_for_dangling_thread_pointer(thread);)
 210 
 211   ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
 212 
 213   oop obj = NULL;
 214   if (wait_obj != NULL) {
 215     // thread is doing an Object.wait() call
 216     obj = (oop) wait_obj-&gt;object();
 217     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 218   } else {
 219     ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
 220     if (enter_obj != NULL) {
<span class="line-modified"> 221       // thread is trying to enter() an ObjectMonitor.</span>
 222       obj = (oop) enter_obj-&gt;object();
<span class="line-added"> 223       assert(obj != NULL, &quot;ObjectMonitor should have an associated object!&quot;);</span>
 224     }

 225   }
 226 
 227   Handle h(Thread::current(), obj);
 228   return h;
 229 }
 230 
 231 bool ThreadService::set_thread_monitoring_contention(bool flag) {
 232   MutexLocker m(Management_lock);
 233 
 234   bool prev = _thread_monitoring_contention_enabled;
 235   _thread_monitoring_contention_enabled = flag;
 236 
 237   return prev;
 238 }
 239 
 240 bool ThreadService::set_thread_cpu_time_enabled(bool flag) {
 241   MutexLocker m(Management_lock);
 242 
 243   bool prev = _thread_cpu_time_enabled;
 244   _thread_cpu_time_enabled = flag;
</pre>
<hr />
<pre>
 338     }
 339   }
 340 
 341   return result_obj;
 342 }
 343 
 344 void ThreadService::reset_contention_count_stat(JavaThread* thread) {
 345   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 346   if (stat != NULL) {
 347     stat-&gt;reset_count_stat();
 348   }
 349 }
 350 
 351 void ThreadService::reset_contention_time_stat(JavaThread* thread) {
 352   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 353   if (stat != NULL) {
 354     stat-&gt;reset_time_stat();
 355   }
 356 }
 357 
<span class="line-modified"> 358 // Find deadlocks involving raw monitors, object monitors and concurrent locks</span>
<span class="line-added"> 359 // if concurrent_locks is true.</span>
 360 DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
 361   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 362 
 363   // This code was modified from the original Threads::find_deadlocks code.
 364   int globalDfn = 0, thisDfn;
 365   ObjectMonitor* waitingToLockMonitor = NULL;
<span class="line-added"> 366   JvmtiRawMonitor* waitingToLockRawMonitor = NULL;</span>
 367   oop waitingToLockBlocker = NULL;
 368   bool blocked_on_monitor = false;
 369   JavaThread *currentThread, *previousThread;
 370   int num_deadlocks = 0;
 371 
 372   // Initialize the depth-first-number for each JavaThread.
 373   JavaThreadIterator jti(t_list);
 374   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 375     jt-&gt;set_depth_first_number(-1);
 376   }
 377 
 378   DeadlockCycle* deadlocks = NULL;
 379   DeadlockCycle* last = NULL;
 380   DeadlockCycle* cycle = new DeadlockCycle();
 381   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 382     if (jt-&gt;depth_first_number() &gt;= 0) {
 383       // this thread was already visited
 384       continue;
 385     }
 386 
 387     thisDfn = globalDfn;
 388     jt-&gt;set_depth_first_number(globalDfn++);
 389     previousThread = jt;
 390     currentThread = jt;
 391 
 392     cycle-&gt;reset();
 393 
 394     // When there is a deadlock, all the monitors involved in the dependency
 395     // cycle must be contended and heavyweight. So we only care about the
 396     // heavyweight monitor a thread is waiting to lock.
<span class="line-modified"> 397     waitingToLockMonitor = jt-&gt;current_pending_monitor();</span>
<span class="line-added"> 398     // JVM TI raw monitors can also be involved in deadlocks, and we can be</span>
<span class="line-added"> 399     // waiting to lock both a raw monitor and ObjectMonitor at the same time.</span>
<span class="line-added"> 400     // It isn&#39;t clear how to make deadlock detection work correctly if that</span>
<span class="line-added"> 401     // happens.</span>
<span class="line-added"> 402     waitingToLockRawMonitor = jt-&gt;current_pending_raw_monitor();</span>
<span class="line-added"> 403 </span>
 404     if (concurrent_locks) {
 405       waitingToLockBlocker = jt-&gt;current_park_blocker();
 406     }
<span class="line-modified"> 407 </span>
<span class="line-added"> 408     while (waitingToLockMonitor != NULL ||</span>
<span class="line-added"> 409            waitingToLockRawMonitor != NULL ||</span>
<span class="line-added"> 410            waitingToLockBlocker != NULL) {</span>
 411       cycle-&gt;add_thread(currentThread);
<span class="line-modified"> 412       // Give preference to the raw monitor</span>
<span class="line-added"> 413       if (waitingToLockRawMonitor != NULL) {</span>
<span class="line-added"> 414         Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="line-added"> 415         if (owner != NULL &amp;&amp; // the raw monitor could be released at any time</span>
<span class="line-added"> 416             owner-&gt;is_Java_thread()) {</span>
<span class="line-added"> 417           // only JavaThreads can be reported here</span>
<span class="line-added"> 418           currentThread = (JavaThread*) owner;</span>
<span class="line-added"> 419         }</span>
<span class="line-added"> 420       } else if (waitingToLockMonitor != NULL) {</span>
 421         address currentOwner = (address)waitingToLockMonitor-&gt;owner();
 422         if (currentOwner != NULL) {
 423           currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 424                                                                     currentOwner);
 425           if (currentThread == NULL) {
 426             // This function is called at a safepoint so the JavaThread
 427             // that owns waitingToLockMonitor should be findable, but
 428             // if it is not findable, then the previous currentThread is
 429             // blocked permanently. We record this as a deadlock.
 430             num_deadlocks++;
 431 
 432             cycle-&gt;set_deadlock(true);
 433 
 434             // add this cycle to the deadlocks list
 435             if (deadlocks == NULL) {
 436               deadlocks = cycle;
 437             } else {
 438               last-&gt;set_next(cycle);
 439             }
 440             last = cycle;
</pre>
<hr />
<pre>
 683     // Iterate inflated monitors and find monitors locked by this thread
 684     // not found in the stack
 685     InflatedMonitorsClosure imc(_thread, this);
 686     ObjectSynchronizer::monitors_iterate(&amp;imc);
 687   }
 688 }
 689 
 690 
 691 bool ThreadStackTrace::is_owned_monitor_on_stack(oop object) {
 692   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 693 
 694   bool found = false;
 695   int num_frames = get_stack_depth();
 696   for (int depth = 0; depth &lt; num_frames; depth++) {
 697     StackFrameInfo* frame = stack_frame_at(depth);
 698     int len = frame-&gt;num_locked_monitors();
 699     GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
 700     for (int j = 0; j &lt; len; j++) {
 701       oop monitor = locked_monitors-&gt;at(j);
 702       assert(monitor != NULL, &quot;must be a Java object&quot;);
<span class="line-modified"> 703       if (monitor == object) {</span>
 704         found = true;
 705         break;
 706       }
 707     }
 708   }
 709   return found;
 710 }
 711 
 712 Handle ThreadStackTrace::allocate_fill_stack_trace_element_array(TRAPS) {
 713   InstanceKlass* ik = SystemDictionary::StackTraceElement_klass();
 714   assert(ik != NULL, &quot;must be loaded in 1.4+&quot;);
 715 
 716   // Allocate an array of java/lang/StackTraceElement object
 717   objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);
 718   objArrayHandle backtrace(THREAD, ste);
 719   for (int j = 0; j &lt; _depth; j++) {
 720     StackFrameInfo* frame = _frames-&gt;at(j);
 721     methodHandle mh(THREAD, frame-&gt;method());
 722     oop element = java_lang_StackTraceElement::create(mh, frame-&gt;bci(), CHECK_NH);
 723     backtrace-&gt;obj_at_put(j, element);
</pre>
<hr />
<pre>
 896     } else {
 897       _blocker_object = obj();
 898       JavaThread* owner = ObjectSynchronizer::get_lock_owner(t_list, obj);
 899       if ((owner == NULL &amp;&amp; _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
 900           || (owner != NULL &amp;&amp; owner-&gt;is_attaching_via_jni())) {
 901         // ownership information of the monitor is not available
 902         // (may no longer be owned or releasing to some other thread)
 903         // make this thread in RUNNABLE state.
 904         // And when the owner thread is in attaching state, the java thread
 905         // is not completely initialized. For example thread name and id
 906         // and may not be set, so hide the attaching thread.
 907         _thread_status = java_lang_Thread::RUNNABLE;
 908         _blocker_object = NULL;
 909       } else if (owner != NULL) {
 910         _blocker_object_owner = owner-&gt;threadObj();
 911       }
 912     }
 913   }
 914 
 915   // Support for JSR-166 locks
<span class="line-modified"> 916   if (_thread_status == java_lang_Thread::PARKED || _thread_status == java_lang_Thread::PARKED_TIMED) {</span>



 917     _blocker_object = thread-&gt;current_park_blocker();
 918     if (_blocker_object != NULL &amp;&amp; _blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 919       _blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(_blocker_object);
 920     }
 921   }
 922 }
 923 
 924 ThreadSnapshot::~ThreadSnapshot() {
 925   delete _stack_trace;
 926   delete _concurrent_locks;
 927 }
 928 
 929 void ThreadSnapshot::dump_stack_at_safepoint(int max_depth, bool with_locked_monitors) {
 930   _stack_trace = new ThreadStackTrace(_thread, with_locked_monitors);
 931   _stack_trace-&gt;dump_stack_at_safepoint(max_depth);
 932 }
 933 
 934 
 935 void ThreadSnapshot::oops_do(OopClosure* f) {
 936   f-&gt;do_oop(&amp;_threadObj);
</pre>
<hr />
<pre>
 951 }
 952 
 953 
 954 DeadlockCycle::DeadlockCycle() {
 955   _is_deadlock = false;
 956   _threads = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, true);
 957   _next = NULL;
 958 }
 959 
 960 DeadlockCycle::~DeadlockCycle() {
 961   delete _threads;
 962 }
 963 
 964 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 965   st-&gt;cr();
 966   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 967   st-&gt;print(&quot;=============================&quot;);
 968 
 969   JavaThread* currentThread;
 970   ObjectMonitor* waitingToLockMonitor;
<span class="line-added"> 971   JvmtiRawMonitor* waitingToLockRawMonitor;</span>
 972   oop waitingToLockBlocker;
 973   int len = _threads-&gt;length();
 974   for (int i = 0; i &lt; len; i++) {
 975     currentThread = _threads-&gt;at(i);
<span class="line-modified"> 976     waitingToLockMonitor = currentThread-&gt;current_pending_monitor();</span>
<span class="line-added"> 977     waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();</span>
 978     waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 979     st-&gt;cr();
 980     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
 981     const char* owner_desc = &quot;,\n  which is held by&quot;;
<span class="line-added"> 982 </span>
<span class="line-added"> 983     // Note: As the JVM TI &quot;monitor contended enter&quot; event callback is executed after ObjectMonitor</span>
<span class="line-added"> 984     // sets the current pending monitor, it is possible to then see a pending raw monitor as well.</span>
<span class="line-added"> 985     if (waitingToLockRawMonitor != NULL) {</span>
<span class="line-added"> 986       st-&gt;print(&quot;  waiting to lock JVM TI raw monitor &quot; INTPTR_FORMAT, p2i(waitingToLockRawMonitor));</span>
<span class="line-added"> 987       Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="line-added"> 988       // Could be NULL as the raw monitor could be released at any time if held by non-JavaThread</span>
<span class="line-added"> 989       if (owner != NULL) {</span>
<span class="line-added"> 990         if (owner-&gt;is_Java_thread()) {</span>
<span class="line-added"> 991           currentThread = (JavaThread*) owner;</span>
<span class="line-added"> 992           st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
<span class="line-added"> 993         } else {</span>
<span class="line-added"> 994           st-&gt;print_cr(&quot;,\n  which has now been released&quot;);</span>
<span class="line-added"> 995         }</span>
<span class="line-added"> 996       } else {</span>
<span class="line-added"> 997         st-&gt;print_cr(&quot;%s non-Java thread=&quot; PTR_FORMAT, owner_desc, p2i(owner));</span>
<span class="line-added"> 998       }</span>
<span class="line-added"> 999     }</span>
<span class="line-added">1000 </span>
1001     if (waitingToLockMonitor != NULL) {
1002       st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
1003       oop obj = (oop)waitingToLockMonitor-&gt;object();
<span class="line-modified">1004       st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),</span>
<span class="line-modified">1005                  obj-&gt;klass()-&gt;external_name());</span>

1006 
<span class="line-modified">1007       if (!currentThread-&gt;current_pending_monitor_is_from_java()) {</span>
<span class="line-modified">1008         owner_desc = &quot;\n  in JNI, which is held by&quot;;</span>




1009       }
1010       currentThread = Threads::owning_thread_from_monitor_owner(t_list,
1011                                                                 (address)waitingToLockMonitor-&gt;owner());
1012       if (currentThread == NULL) {
1013         // The deadlock was detected at a safepoint so the JavaThread
1014         // that owns waitingToLockMonitor should be findable, but
1015         // if it is not findable, then the previous currentThread is
1016         // blocked permanently.
<span class="line-modified">1017         st-&gt;print_cr(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,</span>
1018                   p2i(waitingToLockMonitor-&gt;owner()));
1019         continue;
1020       }
1021     } else {
1022       st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
1023                 p2i(waitingToLockBlocker),
1024                 waitingToLockBlocker-&gt;klass()-&gt;external_name());
1025       assert(waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass()),
1026              &quot;Must be an AbstractOwnableSynchronizer&quot;);
1027       oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
1028       currentThread = java_lang_Thread::thread(ownerObj);
1029       assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
1030     }
<span class="line-modified">1031     st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
1032   }
1033 

1034   st-&gt;cr();
1035 
1036   // Print stack traces
1037   bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
1038   JavaMonitorsInStackTrace = true;
1039   st-&gt;print_cr(&quot;Java stack information for the threads listed above:&quot;);
1040   st-&gt;print_cr(&quot;===================================================&quot;);
1041   for (int j = 0; j &lt; len; j++) {
1042     currentThread = _threads-&gt;at(j);
1043     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
1044     currentThread-&gt;print_stack_on(st);
1045   }
1046   JavaMonitorsInStackTrace = oldJavaMonitorsInStackTrace;
1047 }
1048 
1049 ThreadsListEnumerator::ThreadsListEnumerator(Thread* cur_thread,
1050                                              bool include_jvmti_agent_threads,
1051                                              bool include_jni_attaching_threads) {
1052   assert(cur_thread == Thread::current(), &quot;Check current thread&quot;);
1053 
</pre>
</td>
</tr>
</table>
<center><a href="nmtDCmd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
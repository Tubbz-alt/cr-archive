diff a/src/hotspot/share/services/memoryManager.cpp b/src/hotspot/share/services/memoryManager.cpp
--- a/src/hotspot/share/services/memoryManager.cpp
+++ b/src/hotspot/share/services/memoryManager.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,13 +25,13 @@
 #include "precompiled.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "memory/allocation.inline.hpp"
 #include "oops/oop.inline.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/javaCalls.hpp"
-#include "runtime/orderAccess.hpp"
 #include "services/lowMemoryDetector.hpp"
 #include "services/management.hpp"
 #include "services/memoryManager.hpp"
 #include "services/memoryPool.hpp"
 #include "services/memoryService.hpp"
@@ -63,11 +63,11 @@
 }
 
 instanceOop MemoryManager::get_memory_manager_instance(TRAPS) {
   // Must do an acquire so as to force ordering of subsequent
   // loads from anything _memory_mgr_obj points to or implies.
-  instanceOop mgr_obj = OrderAccess::load_acquire(&_memory_mgr_obj);
+  instanceOop mgr_obj = Atomic::load_acquire(&_memory_mgr_obj);
   if (mgr_obj == NULL) {
     // It's ok for more than one thread to execute the code up to the locked region.
     // Extra manager instances will just be gc'ed.
     Klass* k = Management::sun_management_ManagementFactoryHelper_klass(CHECK_0);
 
@@ -108,19 +108,19 @@
     instanceHandle mgr(THREAD, m);
 
     {
       // Get lock before setting _memory_mgr_obj
       // since another thread may have created the instance
-      MutexLocker ml(Management_lock);
+      MutexLocker ml(THREAD, Management_lock);
 
       // Check if another thread has created the management object.  We reload
       // _memory_mgr_obj here because some other thread may have initialized
       // it while we were executing the code before the lock.
       //
       // The lock has done an acquire, so the load can't float above it, but
       // we need to do a load_acquire as above.
-      mgr_obj = OrderAccess::load_acquire(&_memory_mgr_obj);
+      mgr_obj = Atomic::load_acquire(&_memory_mgr_obj);
       if (mgr_obj != NULL) {
          return mgr_obj;
       }
 
       // Get the address of the object we created via call_special.
@@ -128,11 +128,11 @@
 
       // Use store barrier to make sure the memory accesses associated
       // with creating the management object are visible before publishing
       // its address.  The unlock will publish the store to _memory_mgr_obj
       // because it does a release first.
-      OrderAccess::release_store(&_memory_mgr_obj, mgr_obj);
+      Atomic::release_store(&_memory_mgr_obj, mgr_obj);
     }
   }
 
   return mgr_obj;
 }
@@ -141,12 +141,12 @@
   f->do_oop((oop*) &_memory_mgr_obj);
 }
 
 GCStatInfo::GCStatInfo(int num_pools) {
   // initialize the arrays for memory usage
-  _before_gc_usage_array = (MemoryUsage*) NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);
-  _after_gc_usage_array  = (MemoryUsage*) NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);
+  _before_gc_usage_array = NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);
+  _after_gc_usage_array  = NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);
   _usage_array_size = num_pools;
   clear();
 }
 
 GCStatInfo::~GCStatInfo() {
@@ -176,11 +176,11 @@
 GCMemoryManager::GCMemoryManager(const char* name, const char* gc_end_message) :
   MemoryManager(name), _gc_end_message(gc_end_message) {
   _num_collections = 0;
   _last_gc_stat = NULL;
   _last_gc_lock = new Mutex(Mutex::leaf, "_last_gc_lock", true,
-                            Monitor::_safepoint_check_never);
+                            Mutex::_safepoint_check_never);
   _current_gc_stat = NULL;
   _num_gc_threads = 1;
   _notification_enabled = false;
 }
 
@@ -280,11 +280,11 @@
 
   if (countCollection) {
     _num_collections++;
     // alternately update two objects making one public when complete
     {
-      MutexLockerEx ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);
+      MutexLocker ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);
       GCStatInfo *tmp = _last_gc_stat;
       _last_gc_stat = _current_gc_stat;
       _current_gc_stat = tmp;
       // reset the current stat for diagnosability purposes
       _current_gc_stat->clear();
@@ -295,11 +295,11 @@
     }
   }
 }
 
 size_t GCMemoryManager::get_last_gc_stat(GCStatInfo* dest) {
-  MutexLockerEx ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);
   if (_last_gc_stat->gc_index() != 0) {
     dest->set_index(_last_gc_stat->gc_index());
     dest->set_start_time(_last_gc_stat->start_time());
     dest->set_end_time(_last_gc_stat->end_time());
     assert(dest->usage_array_size() == _last_gc_stat->usage_array_size(),

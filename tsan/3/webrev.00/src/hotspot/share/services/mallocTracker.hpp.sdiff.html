<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/mallocTracker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mallocTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="management.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/mallocTracker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38  * records total memory allocation size and number of allocations.
 39  * The counters are updated atomically.
 40  */
 41 class MemoryCounter {
 42  private:
 43   volatile size_t   _count;
 44   volatile size_t   _size;
 45 
 46   DEBUG_ONLY(size_t   _peak_count;)
 47   DEBUG_ONLY(size_t   _peak_size; )
 48 
 49  public:
 50   MemoryCounter() : _count(0), _size(0) {
 51     DEBUG_ONLY(_peak_count = 0;)
 52     DEBUG_ONLY(_peak_size  = 0;)
 53   }
 54 
 55   inline void allocate(size_t sz) {
 56     Atomic::inc(&amp;_count);
 57     if (sz &gt; 0) {
<span class="line-modified"> 58       Atomic::add(sz, &amp;_size);</span>
 59       DEBUG_ONLY(_peak_size = MAX2(_peak_size, _size));
 60     }
 61     DEBUG_ONLY(_peak_count = MAX2(_peak_count, _count);)
 62   }
 63 
 64   inline void deallocate(size_t sz) {
 65     assert(_count &gt; 0, &quot;Nothing allocated yet&quot;);
 66     assert(_size &gt;= sz, &quot;deallocation &gt; allocated&quot;);
 67     Atomic::dec(&amp;_count);
 68     if (sz &gt; 0) {
<span class="line-modified"> 69       Atomic::sub(sz, &amp;_size);</span>
 70     }
 71   }
 72 
<span class="line-modified"> 73   inline void resize(long sz) {</span>
 74     if (sz != 0) {
<span class="line-modified"> 75       Atomic::add(size_t(sz), &amp;_size);</span>

 76       DEBUG_ONLY(_peak_size = MAX2(_size, _peak_size);)
 77     }
 78   }
 79 
 80   inline size_t count() const { return _count; }
 81   inline size_t size()  const { return _size;  }
 82   DEBUG_ONLY(inline size_t peak_count() const { return _peak_count; })
 83   DEBUG_ONLY(inline size_t peak_size()  const { return _peak_size; })
 84 
 85 };
 86 
 87 /*
 88  * Malloc memory used by a particular subsystem.
 89  * It includes the memory acquired through os::malloc()
 90  * call and arena&#39;s backing memory.
 91  */
 92 class MallocMemory {
 93  private:
 94   MemoryCounter _malloc;
 95   MemoryCounter _arena;
 96 
 97  public:
 98   MallocMemory() { }
 99 
100   inline void record_malloc(size_t sz) {
101     _malloc.allocate(sz);
102   }
103 
104   inline void record_free(size_t sz) {
105     _malloc.deallocate(sz);
106   }
107 
108   inline void record_new_arena() {
109     _arena.allocate(0);
110   }
111 
112   inline void record_arena_free() {
113     _arena.deallocate(0);
114   }
115 
<span class="line-modified">116   inline void record_arena_size_change(long sz) {</span>
117     _arena.resize(sz);
118   }
119 
120   inline size_t malloc_size()  const { return _malloc.size(); }
121   inline size_t malloc_count() const { return _malloc.count();}
122   inline size_t arena_size()   const { return _arena.size();  }
123   inline size_t arena_count()  const { return _arena.count(); }
124 
125   DEBUG_ONLY(inline const MemoryCounter&amp; malloc_counter() const { return _malloc; })
126   DEBUG_ONLY(inline const MemoryCounter&amp; arena_counter()  const { return _arena;  })
127 };
128 
129 class MallocMemorySummary;
130 
131 // A snapshot of malloc&#39;d memory, includes malloc memory
132 // usage by types and memory used by tracking itself.
133 class MallocMemorySnapshot : public ResourceObj {
134   friend class MallocMemorySummary;
135 
136  private:
</pre>
<hr />
<pre>
190 
191  public:
192    static void initialize();
193 
194    static inline void record_malloc(size_t size, MEMFLAGS flag) {
195      as_snapshot()-&gt;by_type(flag)-&gt;record_malloc(size);
196    }
197 
198    static inline void record_free(size_t size, MEMFLAGS flag) {
199      as_snapshot()-&gt;by_type(flag)-&gt;record_free(size);
200    }
201 
202    static inline void record_new_arena(MEMFLAGS flag) {
203      as_snapshot()-&gt;by_type(flag)-&gt;record_new_arena();
204    }
205 
206    static inline void record_arena_free(MEMFLAGS flag) {
207      as_snapshot()-&gt;by_type(flag)-&gt;record_arena_free();
208    }
209 
<span class="line-modified">210    static inline void record_arena_size_change(long size, MEMFLAGS flag) {</span>
211      as_snapshot()-&gt;by_type(flag)-&gt;record_arena_size_change(size);
212    }
213 
214    static void snapshot(MallocMemorySnapshot* s) {
215      as_snapshot()-&gt;copy_to(s);
216      s-&gt;make_adjustment();
217    }
218 
219    // Record memory used by malloc tracking header
220    static inline void record_new_malloc_header(size_t sz) {
221      as_snapshot()-&gt;malloc_overhead()-&gt;allocate(sz);
222    }
223 
224    static inline void record_free_malloc_header(size_t sz) {
225      as_snapshot()-&gt;malloc_overhead()-&gt;deallocate(sz);
226    }
227 
228    // The memory used by malloc tracking headers
229    static inline size_t tracking_overhead() {
230      return as_snapshot()-&gt;malloc_overhead()-&gt;size();
</pre>
<hr />
<pre>
344 
345   // Get memory type
346   static inline MEMFLAGS get_flags(void* memblock) {
347     MallocHeader* header = malloc_header(memblock);
348     return header-&gt;flags();
349   }
350 
351   // Get header size
352   static inline size_t get_header_size(void* memblock) {
353     return (memblock == NULL) ? 0 : sizeof(MallocHeader);
354   }
355 
356   static inline void record_new_arena(MEMFLAGS flags) {
357     MallocMemorySummary::record_new_arena(flags);
358   }
359 
360   static inline void record_arena_free(MEMFLAGS flags) {
361     MallocMemorySummary::record_arena_free(flags);
362   }
363 
<span class="line-modified">364   static inline void record_arena_size_change(int size, MEMFLAGS flags) {</span>
365     MallocMemorySummary::record_arena_size_change(size, flags);
366   }
367  private:
368   static inline MallocHeader* malloc_header(void *memblock) {
369     assert(memblock != NULL, &quot;NULL pointer&quot;);
370     MallocHeader* header = (MallocHeader*)((char*)memblock - sizeof(MallocHeader));
371     return header;
372   }
373 };
374 
375 #endif // INCLUDE_NMT
376 
377 
378 #endif // SHARE_SERVICES_MALLOCTRACKER_HPP
</pre>
</td>
<td>
<hr />
<pre>
 38  * records total memory allocation size and number of allocations.
 39  * The counters are updated atomically.
 40  */
 41 class MemoryCounter {
 42  private:
 43   volatile size_t   _count;
 44   volatile size_t   _size;
 45 
 46   DEBUG_ONLY(size_t   _peak_count;)
 47   DEBUG_ONLY(size_t   _peak_size; )
 48 
 49  public:
 50   MemoryCounter() : _count(0), _size(0) {
 51     DEBUG_ONLY(_peak_count = 0;)
 52     DEBUG_ONLY(_peak_size  = 0;)
 53   }
 54 
 55   inline void allocate(size_t sz) {
 56     Atomic::inc(&amp;_count);
 57     if (sz &gt; 0) {
<span class="line-modified"> 58       Atomic::add(&amp;_size, sz);</span>
 59       DEBUG_ONLY(_peak_size = MAX2(_peak_size, _size));
 60     }
 61     DEBUG_ONLY(_peak_count = MAX2(_peak_count, _count);)
 62   }
 63 
 64   inline void deallocate(size_t sz) {
 65     assert(_count &gt; 0, &quot;Nothing allocated yet&quot;);
 66     assert(_size &gt;= sz, &quot;deallocation &gt; allocated&quot;);
 67     Atomic::dec(&amp;_count);
 68     if (sz &gt; 0) {
<span class="line-modified"> 69       Atomic::sub(&amp;_size, sz);</span>
 70     }
 71   }
 72 
<span class="line-modified"> 73   inline void resize(ssize_t sz) {</span>
 74     if (sz != 0) {
<span class="line-modified"> 75       assert(sz &gt;= 0 || _size &gt;= size_t(-sz), &quot;Must be&quot;);</span>
<span class="line-added"> 76       Atomic::add(&amp;_size, size_t(sz));</span>
 77       DEBUG_ONLY(_peak_size = MAX2(_size, _peak_size);)
 78     }
 79   }
 80 
 81   inline size_t count() const { return _count; }
 82   inline size_t size()  const { return _size;  }
 83   DEBUG_ONLY(inline size_t peak_count() const { return _peak_count; })
 84   DEBUG_ONLY(inline size_t peak_size()  const { return _peak_size; })
 85 
 86 };
 87 
 88 /*
 89  * Malloc memory used by a particular subsystem.
 90  * It includes the memory acquired through os::malloc()
 91  * call and arena&#39;s backing memory.
 92  */
 93 class MallocMemory {
 94  private:
 95   MemoryCounter _malloc;
 96   MemoryCounter _arena;
 97 
 98  public:
 99   MallocMemory() { }
100 
101   inline void record_malloc(size_t sz) {
102     _malloc.allocate(sz);
103   }
104 
105   inline void record_free(size_t sz) {
106     _malloc.deallocate(sz);
107   }
108 
109   inline void record_new_arena() {
110     _arena.allocate(0);
111   }
112 
113   inline void record_arena_free() {
114     _arena.deallocate(0);
115   }
116 
<span class="line-modified">117   inline void record_arena_size_change(ssize_t sz) {</span>
118     _arena.resize(sz);
119   }
120 
121   inline size_t malloc_size()  const { return _malloc.size(); }
122   inline size_t malloc_count() const { return _malloc.count();}
123   inline size_t arena_size()   const { return _arena.size();  }
124   inline size_t arena_count()  const { return _arena.count(); }
125 
126   DEBUG_ONLY(inline const MemoryCounter&amp; malloc_counter() const { return _malloc; })
127   DEBUG_ONLY(inline const MemoryCounter&amp; arena_counter()  const { return _arena;  })
128 };
129 
130 class MallocMemorySummary;
131 
132 // A snapshot of malloc&#39;d memory, includes malloc memory
133 // usage by types and memory used by tracking itself.
134 class MallocMemorySnapshot : public ResourceObj {
135   friend class MallocMemorySummary;
136 
137  private:
</pre>
<hr />
<pre>
191 
192  public:
193    static void initialize();
194 
195    static inline void record_malloc(size_t size, MEMFLAGS flag) {
196      as_snapshot()-&gt;by_type(flag)-&gt;record_malloc(size);
197    }
198 
199    static inline void record_free(size_t size, MEMFLAGS flag) {
200      as_snapshot()-&gt;by_type(flag)-&gt;record_free(size);
201    }
202 
203    static inline void record_new_arena(MEMFLAGS flag) {
204      as_snapshot()-&gt;by_type(flag)-&gt;record_new_arena();
205    }
206 
207    static inline void record_arena_free(MEMFLAGS flag) {
208      as_snapshot()-&gt;by_type(flag)-&gt;record_arena_free();
209    }
210 
<span class="line-modified">211    static inline void record_arena_size_change(ssize_t size, MEMFLAGS flag) {</span>
212      as_snapshot()-&gt;by_type(flag)-&gt;record_arena_size_change(size);
213    }
214 
215    static void snapshot(MallocMemorySnapshot* s) {
216      as_snapshot()-&gt;copy_to(s);
217      s-&gt;make_adjustment();
218    }
219 
220    // Record memory used by malloc tracking header
221    static inline void record_new_malloc_header(size_t sz) {
222      as_snapshot()-&gt;malloc_overhead()-&gt;allocate(sz);
223    }
224 
225    static inline void record_free_malloc_header(size_t sz) {
226      as_snapshot()-&gt;malloc_overhead()-&gt;deallocate(sz);
227    }
228 
229    // The memory used by malloc tracking headers
230    static inline size_t tracking_overhead() {
231      return as_snapshot()-&gt;malloc_overhead()-&gt;size();
</pre>
<hr />
<pre>
345 
346   // Get memory type
347   static inline MEMFLAGS get_flags(void* memblock) {
348     MallocHeader* header = malloc_header(memblock);
349     return header-&gt;flags();
350   }
351 
352   // Get header size
353   static inline size_t get_header_size(void* memblock) {
354     return (memblock == NULL) ? 0 : sizeof(MallocHeader);
355   }
356 
357   static inline void record_new_arena(MEMFLAGS flags) {
358     MallocMemorySummary::record_new_arena(flags);
359   }
360 
361   static inline void record_arena_free(MEMFLAGS flags) {
362     MallocMemorySummary::record_arena_free(flags);
363   }
364 
<span class="line-modified">365   static inline void record_arena_size_change(ssize_t size, MEMFLAGS flags) {</span>
366     MallocMemorySummary::record_arena_size_change(size, flags);
367   }
368  private:
369   static inline MallocHeader* malloc_header(void *memblock) {
370     assert(memblock != NULL, &quot;NULL pointer&quot;);
371     MallocHeader* header = (MallocHeader*)((char*)memblock - sizeof(MallocHeader));
372     return header;
373   }
374 };
375 
376 #endif // INCLUDE_NMT
377 
378 
379 #endif // SHARE_SERVICES_MALLOCTRACKER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="mallocTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="management.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/attachListener.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_ATTACHLISTENER_HPP
 26 #define SHARE_SERVICES_ATTACHLISTENER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 
 34 // The AttachListener thread services a queue of operations that are enqueued
 35 // by client tools. Each operation is identified by a name and has up to 3
 36 // arguments. The operation name is mapped to a function which performs the
 37 // operation. The function is called with an outputStream which is can use to
 38 // write any result data (for examples the properties command serializes
 39 // properties names and values to the output stream). When the function
 40 // complets the result value and any result data is returned to the client
 41 // tool.
 42 
 43 class AttachOperation;
 44 
 45 typedef jint (*AttachOperationFunction)(AttachOperation* op, outputStream* out);
 46 
 47 struct AttachOperationFunctionInfo {
 48   const char* name;
 49   AttachOperationFunction func;
 50 };
 51 
 52 class AttachListener: AllStatic {
 53  public:
 54   static void vm_start() NOT_SERVICES_RETURN;
 55   static void init()  NOT_SERVICES_RETURN;
 56   static void abort() NOT_SERVICES_RETURN;
 57 
 58   // invoke to perform clean-up tasks when all clients detach
 59   static void detachall() NOT_SERVICES_RETURN;
 60 
 61   // indicates if the Attach Listener needs to be created at startup
 62   static bool init_at_startup() NOT_SERVICES_RETURN_(false);
 63 
 64   // indicates if we have a trigger to start the Attach Listener
 65   static bool is_init_trigger() NOT_SERVICES_RETURN_(false);
 66 
 67 #if !INCLUDE_SERVICES
 68   static bool is_attach_supported()             { return false; }
 69 #else
 70  private:
 71   static volatile bool _initialized;
 72 
 73  public:
 74   static bool is_initialized()                  { return _initialized; }
 75   static void set_initialized()                 { _initialized = true; }
 76 
 77   // indicates if this VM supports attach-on-demand
 78   static bool is_attach_supported()             { return !DisableAttachMechanism; }
 79 
 80   // platform specific initialization
 81   static int pd_init();
 82 
 83   // platform specific operation
 84   static AttachOperationFunctionInfo* pd_find_operation(const char* name);
 85 
 86   // platform specific flag change
 87   static jint pd_set_flag(AttachOperation* op, outputStream* out);
 88 
 89   // platform specific detachall
 90   static void pd_detachall();
 91 
 92   // platform specific data dump
 93   static void pd_data_dump();
 94 
 95   // dequeue the next operation
 96   static AttachOperation* dequeue();
 97 #endif // !INCLUDE_SERVICES
 98 
 99  private:
100   static bool has_init_error(TRAPS);
101 };
102 
103 #if INCLUDE_SERVICES
104 class AttachOperation: public CHeapObj&lt;mtInternal&gt; {
105  public:
106   enum {
107     name_length_max = 16,       // maximum length of  name
108     arg_length_max = 1024,      // maximum length of argument
109     arg_count_max = 3           // maximum number of arguments
110   };
111 
112   // name of special operation that can be enqueued when all
113   // clients detach
114   static char* detachall_operation_name() { return (char*)&quot;detachall&quot;; }
115 
116  private:
117   char _name[name_length_max+1];
118   char _arg[arg_count_max][arg_length_max+1];
119 
120  public:
121   const char* name() const                      { return _name; }
122 
123   // set the operation name
124   void set_name(char* name) {
125     assert(strlen(name) &lt;= name_length_max, &quot;exceeds maximum name length&quot;);
126     size_t len = MIN2(strlen(name), (size_t)name_length_max);
127     memcpy(_name, name, len);
128     _name[len] = &#39;\0&#39;;
129   }
130 
131   // get an argument value
132   const char* arg(int i) const {
133     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
134     return _arg[i];
135   }
136 
137   // set an argument value
138   void set_arg(int i, char* arg) {
139     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
140     if (arg == NULL) {
141       _arg[i][0] = &#39;\0&#39;;
142     } else {
143       assert(strlen(arg) &lt;= arg_length_max, &quot;exceeds maximum argument length&quot;);
144       size_t len = MIN2(strlen(arg), (size_t)arg_length_max);
145       memcpy(_arg[i], arg, len);
146       _arg[i][len] = &#39;\0&#39;;
147     }
148   }
149 
150   // create an operation of a given name
151   AttachOperation(char* name) {
152     set_name(name);
153     for (int i=0; i&lt;arg_count_max; i++) {
154       set_arg(i, NULL);
155     }
156   }
157 
158   // complete operation by sending result code and any result data to the client
159   virtual void complete(jint result, bufferedStream* result_stream) = 0;
160 };
161 #endif // INCLUDE_SERVICES
162 
163 #endif // SHARE_SERVICES_ATTACHLISTENER_HPP
    </pre>
  </body>
</html>
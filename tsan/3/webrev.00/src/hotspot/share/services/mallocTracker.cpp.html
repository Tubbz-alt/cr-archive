<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/services/mallocTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;services/mallocSiteTable.hpp&quot;
 27 #include &quot;services/mallocTracker.hpp&quot;
 28 #include &quot;services/mallocTracker.inline.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 
 31 size_t MallocMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(MallocMemorySnapshot, size_t)];
 32 
 33 // Total malloc&#39;d memory amount
 34 size_t MallocMemorySnapshot::total() const {
 35   size_t amount = 0;
 36   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 37     amount += _malloc[index].malloc_size();
 38   }
 39   amount += _tracking_header.size() + total_arena();
 40   return amount;
 41 }
 42 
 43 // Total malloc&#39;d memory used by arenas
 44 size_t MallocMemorySnapshot::total_arena() const {
 45   size_t amount = 0;
 46   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 47     amount += _malloc[index].arena_size();
 48   }
 49   return amount;
 50 }
 51 
 52 // Make adjustment by subtracting chunks used by arenas
 53 // from total chunks to get total free chunk size
 54 void MallocMemorySnapshot::make_adjustment() {
 55   size_t arena_size = total_arena();
 56   int chunk_idx = NMTUtil::flag_to_index(mtChunk);
 57   _malloc[chunk_idx].record_free(arena_size);
 58 }
 59 
 60 
 61 void MallocMemorySummary::initialize() {
 62   assert(sizeof(_snapshot) &gt;= sizeof(MallocMemorySnapshot), &quot;Sanity Check&quot;);
 63   // Uses placement new operator to initialize static area.
 64   ::new ((void*)_snapshot)MallocMemorySnapshot();
 65 }
 66 
 67 void MallocHeader::release() const {
 68   // Tracking already shutdown, no housekeeping is needed anymore
 69   if (MemTracker::tracking_level() &lt;= NMT_minimal) return;
 70 
 71   MallocMemorySummary::record_free(size(), flags());
 72   MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));
 73   if (MemTracker::tracking_level() == NMT_detail) {
 74     MallocSiteTable::deallocation_at(size(), _bucket_idx, _pos_idx);
 75   }
 76 }
 77 
 78 bool MallocHeader::record_malloc_site(const NativeCallStack&amp; stack, size_t size,
 79   size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const {
 80   bool ret = MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);
 81 
 82   // Something went wrong, could be OOM or overflow malloc site table.
 83   // We want to keep tracking data under OOM circumstance, so transition to
 84   // summary tracking.
 85   if (!ret) {
 86     MemTracker::transition_to(NMT_summary);
 87   }
 88   return ret;
 89 }
 90 
 91 bool MallocHeader::get_stack(NativeCallStack&amp; stack) const {
 92   return MallocSiteTable::access_stack(stack, _bucket_idx, _pos_idx);
 93 }
 94 
 95 bool MallocTracker::initialize(NMT_TrackingLevel level) {
 96   if (level &gt;= NMT_summary) {
 97     MallocMemorySummary::initialize();
 98   }
 99 
100   if (level == NMT_detail) {
101     return MallocSiteTable::initialize();
102   }
103   return true;
104 }
105 
106 bool MallocTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
107   assert(from != NMT_off, &quot;Can not transition from off state&quot;);
108   assert(to != NMT_off, &quot;Can not transition to off state&quot;);
109   assert (from != NMT_minimal, &quot;cannot transition from minimal state&quot;);
110 
111   if (from == NMT_detail) {
112     assert(to == NMT_minimal || to == NMT_summary, &quot;Just check&quot;);
113     MallocSiteTable::shutdown();
114   }
115   return true;
116 }
117 
118 // Record a malloc memory allocation
119 void* MallocTracker::record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,
120   const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
121   assert(level != NMT_off, &quot;precondition&quot;);
122   void*         memblock;      // the address for user data
123   MallocHeader* header = NULL;
124 
125   if (malloc_base == NULL) {
126     return NULL;
127   }
128 
129   // Uses placement global new operator to initialize malloc header
130 
131   header = ::new (malloc_base)MallocHeader(size, flags, stack, level);
132   memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));
133 
134   // The alignment check: 8 bytes alignment for 32 bit systems.
135   //                      16 bytes alignment for 64-bit systems.
136   assert(((size_t)memblock &amp; (sizeof(size_t) * 2 - 1)) == 0, &quot;Alignment check&quot;);
137 
138 #ifdef ASSERT
139   if (level &gt; NMT_minimal) {
140     // Read back
141     assert(get_size(memblock) == size,   &quot;Wrong size&quot;);
142     assert(get_flags(memblock) == flags, &quot;Wrong flags&quot;);
143   }
144 #endif
145 
146   return memblock;
147 }
148 
149 void* MallocTracker::record_free(void* memblock) {
150   assert(MemTracker::tracking_level() != NMT_off &amp;&amp; memblock != NULL, &quot;precondition&quot;);
151   MallocHeader* header = malloc_header(memblock);
152   header-&gt;release();
153   return (void*)header;
154 }
    </pre>
  </body>
</html>
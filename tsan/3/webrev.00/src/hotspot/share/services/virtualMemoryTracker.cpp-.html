<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/virtualMemoryTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;memory/metaspace.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;runtime/threadCritical.hpp&quot;
 31 #include &quot;services/memTracker.hpp&quot;
 32 #include &quot;services/virtualMemoryTracker.hpp&quot;
 33 
 34 size_t VirtualMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(VirtualMemorySnapshot, size_t)];
 35 
 36 void VirtualMemorySummary::initialize() {
 37   assert(sizeof(_snapshot) &gt;= sizeof(VirtualMemorySnapshot), &quot;Sanity Check&quot;);
 38   // Use placement operator new to initialize static data area.
 39   ::new ((void*)_snapshot) VirtualMemorySnapshot();
 40 }
 41 
 42 void VirtualMemorySummary::snapshot(VirtualMemorySnapshot* s) {
 43   // Snapshot current thread stacks
 44   VirtualMemoryTracker::snapshot_thread_stacks();
 45   as_snapshot()-&gt;copy_to(s);
 46 }
 47 
 48 SortedLinkedList&lt;ReservedMemoryRegion, compare_reserved_region_base&gt;* VirtualMemoryTracker::_reserved_regions;
 49 
 50 int compare_committed_region(const CommittedMemoryRegion&amp; r1, const CommittedMemoryRegion&amp; r2) {
 51   return r1.compare(r2);
 52 }
 53 
 54 int compare_reserved_region_base(const ReservedMemoryRegion&amp; r1, const ReservedMemoryRegion&amp; r2) {
 55   return r1.compare(r2);
 56 }
 57 
 58 static bool is_mergeable_with(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack&amp; stack) {
 59   return rgn-&gt;adjacent_to(addr, size) &amp;&amp; rgn-&gt;call_stack()-&gt;equals(stack);
 60 }
 61 
 62 static bool is_same_as(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack&amp; stack) {
 63   // It would have made sense to use rgn-&gt;equals(...), but equals returns true for overlapping regions.
 64   return rgn-&gt;same_region(addr, size) &amp;&amp; rgn-&gt;call_stack()-&gt;equals(stack);
 65 }
 66 
 67 static LinkedListNode&lt;CommittedMemoryRegion&gt;* find_preceding_node_from(LinkedListNode&lt;CommittedMemoryRegion&gt;* from, address addr) {
 68   LinkedListNode&lt;CommittedMemoryRegion&gt;* preceding = NULL;
 69 
 70   for (LinkedListNode&lt;CommittedMemoryRegion&gt;* node = from; node != NULL; node = node-&gt;next()) {
 71     CommittedMemoryRegion* rgn = node-&gt;data();
 72 
 73     // We searched past the region start.
 74     if (rgn-&gt;end() &gt; addr) {
 75       break;
 76     }
 77 
 78     preceding = node;
 79   }
 80 
 81   return preceding;
 82 }
 83 
 84 static bool try_merge_with(LinkedListNode&lt;CommittedMemoryRegion&gt;* node, address addr, size_t size, const NativeCallStack&amp; stack) {
 85   if (node != NULL) {
 86     CommittedMemoryRegion* rgn = node-&gt;data();
 87 
 88     if (is_mergeable_with(rgn, addr, size, stack)) {
 89       rgn-&gt;expand_region(addr, size);
 90       return true;
 91     }
 92   }
 93 
 94   return false;
 95 }
 96 
 97 static bool try_merge_with(LinkedListNode&lt;CommittedMemoryRegion&gt;* node, LinkedListNode&lt;CommittedMemoryRegion&gt;* other) {
 98   if (other == NULL) {
 99     return false;
100   }
101 
102   CommittedMemoryRegion* rgn = other-&gt;data();
103   return try_merge_with(node, rgn-&gt;base(), rgn-&gt;size(), *rgn-&gt;call_stack());
104 }
105 
106 bool ReservedMemoryRegion::add_committed_region(address addr, size_t size, const NativeCallStack&amp; stack) {
107   assert(addr != NULL, &quot;Invalid address&quot;);
108   assert(size &gt; 0, &quot;Invalid size&quot;);
109   assert(contain_region(addr, size), &quot;Not contain this region&quot;);
110 
111   // Find the region that fully precedes the [addr, addr + size) region.
112   LinkedListNode&lt;CommittedMemoryRegion&gt;* prev = find_preceding_node_from(_committed_regions.head(), addr);
113   LinkedListNode&lt;CommittedMemoryRegion&gt;* next = (prev != NULL ? prev-&gt;next() : _committed_regions.head());
114 
115   if (next != NULL) {
116     // Ignore request if region already exists.
117     if (is_same_as(next-&gt;data(), addr, size, stack)) {
118       return true;
119     }
120 
121     // The new region is after prev, and either overlaps with the
122     // next region (and maybe more regions), or overlaps with no region.
123     if (next-&gt;data()-&gt;overlap_region(addr, size)) {
124       // Remove _all_ overlapping regions, and parts of regions,
125       // in preparation for the addition of this new region.
126       remove_uncommitted_region(addr, size);
127 
128       // The remove could have split a region into two and created a
129       // new prev region. Need to reset the prev and next pointers.
130       prev = find_preceding_node_from((prev != NULL ? prev : _committed_regions.head()), addr);
131       next = (prev != NULL ? prev-&gt;next() : _committed_regions.head());
132     }
133   }
134 
135   // At this point the previous overlapping regions have been
136   // cleared, and the full region is guaranteed to be inserted.
137   VirtualMemorySummary::record_committed_memory(size, flag());
138 
139   // Try to merge with prev and possibly next.
140   if (try_merge_with(prev, addr, size, stack)) {
141     if (try_merge_with(prev, next)) {
142       // prev was expanded to contain the new region
143       // and next, need to remove next from the list
144       _committed_regions.remove_after(prev);
145     }
146 
147     return true;
148   }
149 
150   // Didn&#39;t merge with prev, try with next.
151   if (try_merge_with(next, addr, size, stack)) {
152     return true;
153   }
154 
155   // Couldn&#39;t merge with any regions - create a new region.
156   return add_committed_region(CommittedMemoryRegion(addr, size, stack));
157 }
158 
159 bool ReservedMemoryRegion::remove_uncommitted_region(LinkedListNode&lt;CommittedMemoryRegion&gt;* node,
160   address addr, size_t size) {
161   assert(addr != NULL, &quot;Invalid address&quot;);
162   assert(size &gt; 0, &quot;Invalid size&quot;);
163 
164   CommittedMemoryRegion* rgn = node-&gt;data();
165   assert(rgn-&gt;contain_region(addr, size), &quot;Has to be contained&quot;);
166   assert(!rgn-&gt;same_region(addr, size), &quot;Can not be the same region&quot;);
167 
168   if (rgn-&gt;base() == addr ||
169       rgn-&gt;end() == addr + size) {
170     rgn-&gt;exclude_region(addr, size);
171     return true;
172   } else {
173     // split this region
174     address top =rgn-&gt;end();
175     // use this region for lower part
176     size_t exclude_size = rgn-&gt;end() - addr;
177     rgn-&gt;exclude_region(addr, exclude_size);
178 
179     // higher part
180     address high_base = addr + size;
181     size_t  high_size = top - high_base;
182 
183     CommittedMemoryRegion high_rgn(high_base, high_size, *rgn-&gt;call_stack());
184     LinkedListNode&lt;CommittedMemoryRegion&gt;* high_node = _committed_regions.add(high_rgn);
185     assert(high_node == NULL || node-&gt;next() == high_node, &quot;Should be right after&quot;);
186     return (high_node != NULL);
187   }
188 
189   return false;
190 }
191 
192 bool ReservedMemoryRegion::remove_uncommitted_region(address addr, size_t sz) {
193   assert(addr != NULL, &quot;Invalid address&quot;);
194   assert(sz &gt; 0, &quot;Invalid size&quot;);
195 
196   CommittedMemoryRegion del_rgn(addr, sz, *call_stack());
197   address end = addr + sz;
198 
199   LinkedListNode&lt;CommittedMemoryRegion&gt;* head = _committed_regions.head();
200   LinkedListNode&lt;CommittedMemoryRegion&gt;* prev = NULL;
201   CommittedMemoryRegion* crgn;
202 
203   while (head != NULL) {
204     crgn = head-&gt;data();
205 
206     if (crgn-&gt;same_region(addr, sz)) {
207       VirtualMemorySummary::record_uncommitted_memory(crgn-&gt;size(), flag());
208       _committed_regions.remove_after(prev);
209       return true;
210     }
211 
212     // del_rgn contains crgn
213     if (del_rgn.contain_region(crgn-&gt;base(), crgn-&gt;size())) {
214       VirtualMemorySummary::record_uncommitted_memory(crgn-&gt;size(), flag());
215       head = head-&gt;next();
216       _committed_regions.remove_after(prev);
217       continue;  // don&#39;t update head or prev
218     }
219 
220     // Found addr in the current crgn. There are 2 subcases:
221     if (crgn-&gt;contain_address(addr)) {
222 
223       // (1) Found addr+size in current crgn as well. (del_rgn is contained in crgn)
224       if (crgn-&gt;contain_address(end - 1)) {
225         VirtualMemorySummary::record_uncommitted_memory(sz, flag());
226         return remove_uncommitted_region(head, addr, sz); // done!
227       } else {
228         // (2) Did not find del_rgn&#39;s end in crgn.
229         size_t size = crgn-&gt;end() - del_rgn.base();
230         crgn-&gt;exclude_region(addr, size);
231         VirtualMemorySummary::record_uncommitted_memory(size, flag());
232       }
233 
234     } else if (crgn-&gt;contain_address(end - 1)) {
235       // Found del_rgn&#39;s end, but not its base addr.
236       size_t size = del_rgn.end() - crgn-&gt;base();
237       crgn-&gt;exclude_region(crgn-&gt;base(), size);
238       VirtualMemorySummary::record_uncommitted_memory(size, flag());
239       return true;  // should be done if the list is sorted properly!
240     }
241 
242     prev = head;
243     head = head-&gt;next();
244   }
245 
246   return true;
247 }
248 
249 void ReservedMemoryRegion::move_committed_regions(address addr, ReservedMemoryRegion&amp; rgn) {
250   assert(addr != NULL, &quot;Invalid address&quot;);
251 
252   // split committed regions
253   LinkedListNode&lt;CommittedMemoryRegion&gt;* head =
254     _committed_regions.head();
255   LinkedListNode&lt;CommittedMemoryRegion&gt;* prev = NULL;
256 
257   while (head != NULL) {
258     if (head-&gt;data()-&gt;base() &gt;= addr) {
259       break;
260     }
261     prev = head;
262     head = head-&gt;next();
263   }
264 
265   if (head != NULL) {
266     if (prev != NULL) {
267       prev-&gt;set_next(head-&gt;next());
268     } else {
269       _committed_regions.set_head(NULL);
270     }
271   }
272 
273   rgn._committed_regions.set_head(head);
274 }
275 
276 size_t ReservedMemoryRegion::committed_size() const {
277   size_t committed = 0;
278   LinkedListNode&lt;CommittedMemoryRegion&gt;* head =
279     _committed_regions.head();
280   while (head != NULL) {
281     committed += head-&gt;data()-&gt;size();
282     head = head-&gt;next();
283   }
284   return committed;
285 }
286 
287 void ReservedMemoryRegion::set_flag(MEMFLAGS f) {
288   assert((flag() == mtNone || flag() == f), &quot;Overwrite memory type&quot;);
289   if (flag() != f) {
290     VirtualMemorySummary::move_reserved_memory(flag(), f, size());
291     VirtualMemorySummary::move_committed_memory(flag(), f, committed_size());
292     _flag = f;
293   }
294 }
295 
296 address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {
297   assert(flag() == mtThreadStack, &quot;Only for thread stack&quot;);
298   LinkedListNode&lt;CommittedMemoryRegion&gt;* head = _committed_regions.head();
299   address bottom = base();
300   address top = base() + size();
301   while (head != NULL) {
302     address committed_top = head-&gt;data()-&gt;base() + head-&gt;data()-&gt;size();
303     if (committed_top &lt; top) {
304       // committed stack guard pages, skip them
305       bottom = head-&gt;data()-&gt;base() + head-&gt;data()-&gt;size();
306       head = head-&gt;next();
307     } else {
308       assert(top == committed_top, &quot;Sanity&quot;);
309       break;
310     }
311   }
312 
313   return bottom;
314 }
315 
316 bool VirtualMemoryTracker::initialize(NMT_TrackingLevel level) {
317   if (level &gt;= NMT_summary) {
318     VirtualMemorySummary::initialize();
319   }
320   return true;
321 }
322 
323 bool VirtualMemoryTracker::late_initialize(NMT_TrackingLevel level) {
324   if (level &gt;= NMT_summary) {
325     _reserved_regions = new (std::nothrow, ResourceObj::C_HEAP, mtNMT)
326       SortedLinkedList&lt;ReservedMemoryRegion, compare_reserved_region_base&gt;();
327     return (_reserved_regions != NULL);
328   }
329   return true;
330 }
331 
332 bool VirtualMemoryTracker::add_reserved_region(address base_addr, size_t size,
333     const NativeCallStack&amp; stack, MEMFLAGS flag) {
334   assert(base_addr != NULL, &quot;Invalid address&quot;);
335   assert(size &gt; 0, &quot;Invalid size&quot;);
336   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
337   ReservedMemoryRegion  rgn(base_addr, size, stack, flag);
338   ReservedMemoryRegion* reserved_rgn = _reserved_regions-&gt;find(rgn);
339 
340   if (reserved_rgn == NULL) {
341     VirtualMemorySummary::record_reserved_memory(size, flag);
342     return _reserved_regions-&gt;add(rgn) != NULL;
343   } else {
344     if (reserved_rgn-&gt;same_region(base_addr, size)) {
345       reserved_rgn-&gt;set_call_stack(stack);
346       reserved_rgn-&gt;set_flag(flag);
347       return true;
348     } else if (reserved_rgn-&gt;adjacent_to(base_addr, size)) {
349       VirtualMemorySummary::record_reserved_memory(size, flag);
350       reserved_rgn-&gt;expand_region(base_addr, size);
351       reserved_rgn-&gt;set_call_stack(stack);
352       return true;
353     } else {
354       // Overlapped reservation.
355       // It can happen when the regions are thread stacks, as JNI
356       // thread does not detach from VM before exits, and leads to
357       // leak JavaThread object
358       if (reserved_rgn-&gt;flag() == mtThreadStack) {
359         guarantee(!CheckJNICalls, &quot;Attached JNI thread exited without being detached&quot;);
360         // Overwrite with new region
361 
362         // Release old region
363         VirtualMemorySummary::record_uncommitted_memory(reserved_rgn-&gt;committed_size(), reserved_rgn-&gt;flag());
364         VirtualMemorySummary::record_released_memory(reserved_rgn-&gt;size(), reserved_rgn-&gt;flag());
365 
366         // Add new region
367         VirtualMemorySummary::record_reserved_memory(rgn.size(), flag);
368 
369         *reserved_rgn = rgn;
370         return true;
371       }
372 
373       // CDS mapping region.
374       // CDS reserves the whole region for mapping CDS archive, then maps each section into the region.
375       // NMT reports CDS as a whole.
376       if (reserved_rgn-&gt;flag() == mtClassShared) {
377         assert(reserved_rgn-&gt;contain_region(base_addr, size), &quot;Reserved CDS region should contain this mapping region&quot;);
378         return true;
379       }
380 
381       // Mapped CDS string region.
382       // The string region(s) is part of the java heap.
383       if (reserved_rgn-&gt;flag() == mtJavaHeap) {
384         assert(reserved_rgn-&gt;contain_region(base_addr, size), &quot;Reserved heap region should contain this mapping region&quot;);
385         return true;
386       }
387 
388       ShouldNotReachHere();
389       return false;
390     }
391   }
392 }
393 
394 void VirtualMemoryTracker::set_reserved_region_type(address addr, MEMFLAGS flag) {
395   assert(addr != NULL, &quot;Invalid address&quot;);
396   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
397 
398   ReservedMemoryRegion   rgn(addr, 1);
399   ReservedMemoryRegion*  reserved_rgn = _reserved_regions-&gt;find(rgn);
400   if (reserved_rgn != NULL) {
401     assert(reserved_rgn-&gt;contain_address(addr), &quot;Containment&quot;);
402     if (reserved_rgn-&gt;flag() != flag) {
403       assert(reserved_rgn-&gt;flag() == mtNone, &quot;Overwrite memory type&quot;);
404       reserved_rgn-&gt;set_flag(flag);
405     }
406   }
407 }
408 
409 bool VirtualMemoryTracker::add_committed_region(address addr, size_t size,
410   const NativeCallStack&amp; stack) {
411   assert(addr != NULL, &quot;Invalid address&quot;);
412   assert(size &gt; 0, &quot;Invalid size&quot;);
413   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
414 
415   ReservedMemoryRegion  rgn(addr, size);
416   ReservedMemoryRegion* reserved_rgn = _reserved_regions-&gt;find(rgn);
417 
418   assert(reserved_rgn != NULL, &quot;No reserved region&quot;);
419   assert(reserved_rgn-&gt;contain_region(addr, size), &quot;Not completely contained&quot;);
420   bool result = reserved_rgn-&gt;add_committed_region(addr, size, stack);
421   return result;
422 }
423 
424 bool VirtualMemoryTracker::remove_uncommitted_region(address addr, size_t size) {
425   assert(addr != NULL, &quot;Invalid address&quot;);
426   assert(size &gt; 0, &quot;Invalid size&quot;);
427   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
428 
429   ReservedMemoryRegion  rgn(addr, size);
430   ReservedMemoryRegion* reserved_rgn = _reserved_regions-&gt;find(rgn);
431   assert(reserved_rgn != NULL, &quot;No reserved region&quot;);
432   assert(reserved_rgn-&gt;contain_region(addr, size), &quot;Not completely contained&quot;);
433   bool result = reserved_rgn-&gt;remove_uncommitted_region(addr, size);
434   return result;
435 }
436 
437 bool VirtualMemoryTracker::remove_released_region(address addr, size_t size) {
438   assert(addr != NULL, &quot;Invalid address&quot;);
439   assert(size &gt; 0, &quot;Invalid size&quot;);
440   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
441 
442   ReservedMemoryRegion  rgn(addr, size);
443   ReservedMemoryRegion* reserved_rgn = _reserved_regions-&gt;find(rgn);
444 
445   assert(reserved_rgn != NULL, &quot;No reserved region&quot;);
446 
447   // uncommit regions within the released region
448   if (!reserved_rgn-&gt;remove_uncommitted_region(addr, size)) {
449     return false;
450   }
451 
452   if (reserved_rgn-&gt;flag() == mtClassShared &amp;&amp;
453       reserved_rgn-&gt;contain_region(addr, size) &amp;&amp;
454       !reserved_rgn-&gt;same_region(addr, size)) {
455     // This is an unmapped CDS region, which is part of the reserved shared
456     // memory region.
457     // See special handling in VirtualMemoryTracker::add_reserved_region also.
458     return true;
459   }
460 
461   VirtualMemorySummary::record_released_memory(size, reserved_rgn-&gt;flag());
462 
463   if (reserved_rgn-&gt;same_region(addr, size)) {
464     return _reserved_regions-&gt;remove(rgn);
465   } else {
466     assert(reserved_rgn-&gt;contain_region(addr, size), &quot;Not completely contained&quot;);
467     if (reserved_rgn-&gt;base() == addr ||
468         reserved_rgn-&gt;end() == addr + size) {
469         reserved_rgn-&gt;exclude_region(addr, size);
470       return true;
471     } else {
472       address top = reserved_rgn-&gt;end();
473       address high_base = addr + size;
474       ReservedMemoryRegion high_rgn(high_base, top - high_base,
475         *reserved_rgn-&gt;call_stack(), reserved_rgn-&gt;flag());
476 
477       // use original region for lower region
478       reserved_rgn-&gt;exclude_region(addr, top - addr);
479       LinkedListNode&lt;ReservedMemoryRegion&gt;* new_rgn = _reserved_regions-&gt;add(high_rgn);
480       if (new_rgn == NULL) {
481         return false;
482       } else {
483         reserved_rgn-&gt;move_committed_regions(addr, *new_rgn-&gt;data());
484         return true;
485       }
486     }
487   }
488 }
489 
490 // Iterate the range, find committed region within its bound.
491 class RegionIterator : public StackObj {
492 private:
493   const address _start;
494   const size_t  _size;
495 
496   address _current_start;
497   size_t  _current_size;
498 public:
499   RegionIterator(address start, size_t size) :
500     _start(start), _size(size), _current_start(start), _current_size(size) {
501   }
502 
503   // return true if committed region is found
504   bool next_committed(address&amp; start, size_t&amp; size);
505 private:
506   address end() const { return _start + _size; }
507 };
508 
509 bool RegionIterator::next_committed(address&amp; committed_start, size_t&amp; committed_size) {
510   if (end() &lt;= _current_start) return false;
511 
512   const size_t page_sz = os::vm_page_size();
513   assert(_current_start + _current_size == end(), &quot;Must be&quot;);
514   if (os::committed_in_range(_current_start, _current_size, committed_start, committed_size)) {
515     assert(committed_start != NULL, &quot;Must be&quot;);
516     assert(committed_size &gt; 0 &amp;&amp; is_aligned(committed_size, os::vm_page_size()), &quot;Must be&quot;);
517 
518     size_t remaining_size = (_current_start + _current_size) - (committed_start + committed_size);
519     _current_start = committed_start + committed_size;
520     _current_size = remaining_size;
521     return true;
522   } else {
523     return false;
524   }
525 }
526 
527 // Walk all known thread stacks, snapshot their committed ranges.
528 class SnapshotThreadStackWalker : public VirtualMemoryWalker {
529 public:
530   SnapshotThreadStackWalker() {}
531 
532   bool do_allocation_site(const ReservedMemoryRegion* rgn) {
533     if (rgn-&gt;flag() == mtThreadStack) {
534       address stack_bottom = rgn-&gt;thread_stack_uncommitted_bottom();
535       address committed_start;
536       size_t  committed_size;
537       size_t stack_size = rgn-&gt;base() + rgn-&gt;size() - stack_bottom;
538 
539       ReservedMemoryRegion* region = const_cast&lt;ReservedMemoryRegion*&gt;(rgn);
540       NativeCallStack ncs; // empty stack
541 
542       RegionIterator itr(stack_bottom, stack_size);
543       DEBUG_ONLY(bool found_stack = false;)
544       while (itr.next_committed(committed_start, committed_size)) {
545         assert(committed_start != NULL, &quot;Should not be null&quot;);
546         assert(committed_size &gt; 0, &quot;Should not be 0&quot;);
547         region-&gt;add_committed_region(committed_start, committed_size, ncs);
548         DEBUG_ONLY(found_stack = true;)
549       }
550 #ifdef ASSERT
551       if (!found_stack) {
552         log_debug(thread)(&quot;Thread exited without proper cleanup, may leak thread object&quot;);
553       }
554 #endif
555     }
556     return true;
557   }
558 };
559 
560 void VirtualMemoryTracker::snapshot_thread_stacks() {
561   SnapshotThreadStackWalker walker;
562   walk_virtual_memory(&amp;walker);
563 }
564 
565 bool VirtualMemoryTracker::walk_virtual_memory(VirtualMemoryWalker* walker) {
566   assert(_reserved_regions != NULL, &quot;Sanity check&quot;);
567   ThreadCritical tc;
568   // Check that the _reserved_regions haven&#39;t been deleted.
569   if (_reserved_regions != NULL) {
570     LinkedListNode&lt;ReservedMemoryRegion&gt;* head = _reserved_regions-&gt;head();
571     while (head != NULL) {
572       const ReservedMemoryRegion* rgn = head-&gt;peek();
573       if (!walker-&gt;do_allocation_site(rgn)) {
574         return false;
575       }
576       head = head-&gt;next();
577     }
578    }
579   return true;
580 }
581 
582 // Transition virtual memory tracking level.
583 bool VirtualMemoryTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
584   assert (from != NMT_minimal, &quot;cannot convert from the lowest tracking level to anything&quot;);
585   if (to == NMT_minimal) {
586     assert(from == NMT_summary || from == NMT_detail, &quot;Just check&quot;);
587     // Clean up virtual memory tracking data structures.
588     ThreadCritical tc;
589     // Check for potential race with other thread calling transition
590     if (_reserved_regions != NULL) {
591       delete _reserved_regions;
592       _reserved_regions = NULL;
593     }
594   }
595 
596   return true;
597 }
598 
599 // Metaspace Support
600 MetaspaceSnapshot::MetaspaceSnapshot() {
601   for (int index = (int)Metaspace::ClassType; index &lt; (int)Metaspace::MetadataTypeCount; index ++) {
602     Metaspace::MetadataType type = (Metaspace::MetadataType)index;
603     assert_valid_metadata_type(type);
604     _reserved_in_bytes[type]  = 0;
605     _committed_in_bytes[type] = 0;
606     _used_in_bytes[type]      = 0;
607     _free_in_bytes[type]      = 0;
608   }
609 }
610 
611 void MetaspaceSnapshot::snapshot(Metaspace::MetadataType type, MetaspaceSnapshot&amp; mss) {
612   assert_valid_metadata_type(type);
613 
614   mss._reserved_in_bytes[type]   = MetaspaceUtils::reserved_bytes(type);
615   mss._committed_in_bytes[type]  = MetaspaceUtils::committed_bytes(type);
616   mss._used_in_bytes[type]       = MetaspaceUtils::used_bytes(type);
617 
618   size_t free_in_bytes = (MetaspaceUtils::capacity_bytes(type) - MetaspaceUtils::used_bytes(type))
619                        + MetaspaceUtils::free_chunks_total_bytes(type)
620                        + MetaspaceUtils::free_in_vs_bytes(type);
621   mss._free_in_bytes[type] = free_in_bytes;
622 }
623 
624 void MetaspaceSnapshot::snapshot(MetaspaceSnapshot&amp; mss) {
625   snapshot(Metaspace::ClassType, mss);
626   if (Metaspace::using_class_space()) {
627     snapshot(Metaspace::NonClassType, mss);
628   }
629 }
    </pre>
  </body>
</html>
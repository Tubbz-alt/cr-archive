<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/mallocSiteTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_MALLOCSITETABLE_HPP
 26 #define SHARE_SERVICES_MALLOCSITETABLE_HPP
 27 
<a name="1" id="anc1"></a><span class="line-added"> 28 #include &quot;utilities/macros.hpp&quot;</span>
<span class="line-added"> 29 </span>
 30 #if INCLUDE_NMT
 31 
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;services/allocationSite.hpp&quot;
 35 #include &quot;services/mallocTracker.hpp&quot;
 36 #include &quot;services/nmtCommon.hpp&quot;
 37 #include &quot;utilities/nativeCallStack.hpp&quot;
 38 
 39 // MallocSite represents a code path that eventually calls
 40 // os::malloc() to allocate memory
 41 class MallocSite : public AllocationSite&lt;MemoryCounter&gt; {
 42  public:
 43   MallocSite() :
 44     AllocationSite&lt;MemoryCounter&gt;(NativeCallStack::empty_stack(), mtNone) {}
 45 
 46   MallocSite(const NativeCallStack&amp; stack, MEMFLAGS flags) :
 47     AllocationSite&lt;MemoryCounter&gt;(stack, flags) {}
 48 
 49 
 50   void allocate(size_t size)      { data()-&gt;allocate(size);   }
 51   void deallocate(size_t size)    { data()-&gt;deallocate(size); }
 52 
 53   // Memory allocated from this code path
 54   size_t size()  const { return peek()-&gt;size(); }
 55   // The number of calls were made
 56   size_t count() const { return peek()-&gt;count(); }
 57 };
 58 
 59 // Malloc site hashtable entry
 60 class MallocSiteHashtableEntry : public CHeapObj&lt;mtNMT&gt; {
 61  private:
 62   MallocSite                         _malloc_site;
 63   MallocSiteHashtableEntry* volatile _next;
 64 
 65  public:
 66   MallocSiteHashtableEntry() : _next(NULL) { }
 67 
 68   MallocSiteHashtableEntry(NativeCallStack stack, MEMFLAGS flags):
 69     _malloc_site(stack, flags), _next(NULL) {
 70     assert(flags != mtNone, &quot;Expect a real memory type&quot;);
 71   }
 72 
 73   inline const MallocSiteHashtableEntry* next() const {
 74     return _next;
 75   }
 76 
 77   // Insert an entry atomically.
 78   // Return true if the entry is inserted successfully.
 79   // The operation can be failed due to contention from other thread.
 80   bool atomic_insert(MallocSiteHashtableEntry* entry);
 81 
 82   void set_callsite(const MallocSite&amp; site) {
 83     _malloc_site = site;
 84   }
 85 
 86   inline const MallocSite* peek() const { return &amp;_malloc_site; }
 87   inline MallocSite* data()             { return &amp;_malloc_site; }
 88 
 89   inline long hash() const { return _malloc_site.hash(); }
 90   inline bool equals(const NativeCallStack&amp; stack) const {
 91     return _malloc_site.equals(stack);
 92   }
 93   // Allocation/deallocation on this allocation site
 94   inline void allocate(size_t size)   { _malloc_site.allocate(size);   }
 95   inline void deallocate(size_t size) { _malloc_site.deallocate(size); }
 96   // Memory counters
 97   inline size_t size() const  { return _malloc_site.size();  }
 98   inline size_t count() const { return _malloc_site.count(); }
 99 };
100 
101 // The walker walks every entry on MallocSiteTable
102 class MallocSiteWalker : public StackObj {
103  public:
104    virtual bool do_malloc_site(const MallocSite* e) { return false; }
105 };
106 
107 /*
108  * Native memory tracking call site table.
109  * The table is only needed when detail tracking is enabled.
110  */
111 class MallocSiteTable : AllStatic {
112  private:
113   // The number of hash bucket in this hashtable. The number should
114   // be tuned if malloc activities changed significantly.
115   // The statistics data can be obtained via Jcmd
116   // jcmd &lt;pid&gt; VM.native_memory statistics.
117 
118   // Currently, (number of buckets / number of entires) ratio is
119   // about 1 / 6
120   enum {
121     table_base_size = 128,   // The base size is calculated from statistics to give
122                              // table ratio around 1:6
123     table_size = (table_base_size * NMT_TrackingStackDepth - 1)
124   };
125 
126 
127   // This is a very special lock, that allows multiple shared accesses (sharedLock), but
128   // once exclusive access (exclusiveLock) is requested, all shared accesses are
129   // rejected forever.
130   class AccessLock : public StackObj {
131     enum LockState {
132       NoLock,
133       SharedLock,
134       ExclusiveLock
135     };
136 
137    private:
138     // A very large negative number. The only possibility to &quot;overflow&quot;
139     // this number is when there are more than -min_jint threads in
140     // this process, which is not going to happen in foreseeable future.
141     const static int _MAGIC_ = min_jint;
142 
143     LockState      _lock_state;
144     volatile int*  _lock;
145    public:
146     AccessLock(volatile int* lock) :
147       _lock_state(NoLock), _lock(lock) {
148     }
149 
150     ~AccessLock() {
151       if (_lock_state == SharedLock) {
152         Atomic::dec(_lock);
153       }
154     }
155     // Acquire shared lock.
156     // Return true if shared access is granted.
157     inline bool sharedLock() {
<a name="2" id="anc2"></a><span class="line-modified">158       jint res = Atomic::add(_lock, 1);</span>
159       if (res &lt; 0) {
160         Atomic::dec(_lock);
161         return false;
162       }
163       _lock_state = SharedLock;
164       return true;
165     }
166     // Acquire exclusive lock
167     void exclusiveLock();
168  };
169 
170  public:
171   static bool initialize();
172   static void shutdown();
173 
174   NOT_PRODUCT(static int access_peak_count() { return _peak_count; })
175 
176   // Number of hash buckets
177   static inline int hash_buckets()      { return (int)table_size; }
178 
179   // Access and copy a call stack from this table. Shared lock should be
180   // acquired before access the entry.
181   static inline bool access_stack(NativeCallStack&amp; stack, size_t bucket_idx,
182     size_t pos_idx) {
183     AccessLock locker(&amp;_access_count);
184     if (locker.sharedLock()) {
185       NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)
186       MallocSite* site = malloc_site(bucket_idx, pos_idx);
187       if (site != NULL) {
188         stack = *site-&gt;call_stack();
189         return true;
190       }
191     }
192     return false;
193   }
194 
195   // Record a new allocation from specified call path.
196   // Return true if the allocation is recorded successfully, bucket_idx
197   // and pos_idx are also updated to indicate the entry where the allocation
198   // information was recorded.
199   // Return false only occurs under rare scenarios:
200   //  1. out of memory
201   //  2. overflow hash bucket
202   static inline bool allocation_at(const NativeCallStack&amp; stack, size_t size,
203     size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) {
204     AccessLock locker(&amp;_access_count);
205     if (locker.sharedLock()) {
206       NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)
207       MallocSite* site = lookup_or_add(stack, bucket_idx, pos_idx, flags);
208       if (site != NULL) site-&gt;allocate(size);
209       return site != NULL;
210     }
211     return false;
212   }
213 
214   // Record memory deallocation. bucket_idx and pos_idx indicate where the allocation
215   // information was recorded.
216   static inline bool deallocation_at(size_t size, size_t bucket_idx, size_t pos_idx) {
217     AccessLock locker(&amp;_access_count);
218     if (locker.sharedLock()) {
219       NOT_PRODUCT(_peak_count = MAX2(_peak_count, _access_count);)
220       MallocSite* site = malloc_site(bucket_idx, pos_idx);
221       if (site != NULL) {
222         site-&gt;deallocate(size);
223         return true;
224       }
225     }
226     return false;
227   }
228 
229   // Walk this table.
230   static bool walk_malloc_site(MallocSiteWalker* walker);
231 
232  private:
233   static MallocSiteHashtableEntry* new_entry(const NativeCallStack&amp; key, MEMFLAGS flags);
234   static void reset();
235 
236   // Delete a bucket linked list
237   static void delete_linked_list(MallocSiteHashtableEntry* head);
238 
239   static MallocSite* lookup_or_add(const NativeCallStack&amp; key, size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags);
240   static MallocSite* malloc_site(size_t bucket_idx, size_t pos_idx);
241   static bool walk(MallocSiteWalker* walker);
242 
243   static inline unsigned int hash_to_index(unsigned int hash) {
244     return (hash % table_size);
245   }
246 
247   static inline const NativeCallStack* hash_entry_allocation_stack() {
248     assert(_hash_entry_allocation_stack != NULL, &quot;Must be set&quot;);
249     return _hash_entry_allocation_stack;
250   }
251 
252   static inline const MallocSiteHashtableEntry* hash_entry_allocation_site() {
253     assert(_hash_entry_allocation_site != NULL, &quot;Must be set&quot;);
254     return _hash_entry_allocation_site;
255   }
256 
257  private:
258   // Counter for counting concurrent access
259   static volatile int                _access_count;
260 
261   // The callsite hashtable. It has to be a static table,
262   // since malloc call can come from C runtime linker.
263   static MallocSiteHashtableEntry*        _table[table_size];
264   static const NativeCallStack*           _hash_entry_allocation_stack;
265   static const MallocSiteHashtableEntry*  _hash_entry_allocation_site;
266 
267 
268   NOT_PRODUCT(static int     _peak_count;)
269 };
270 
271 #endif // INCLUDE_NMT
272 #endif // SHARE_SERVICES_MALLOCSITETABLE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/mallocTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 
<a name="1" id="anc1"></a><span class="line-removed"> 26 #include &quot;runtime/atomic.hpp&quot;</span>
 27 #include &quot;services/mallocSiteTable.hpp&quot;
 28 #include &quot;services/mallocTracker.hpp&quot;
 29 #include &quot;services/mallocTracker.inline.hpp&quot;
 30 #include &quot;services/memTracker.hpp&quot;
 31 
 32 size_t MallocMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(MallocMemorySnapshot, size_t)];
 33 
 34 // Total malloc&#39;d memory amount
 35 size_t MallocMemorySnapshot::total() const {
 36   size_t amount = 0;
 37   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 38     amount += _malloc[index].malloc_size();
 39   }
 40   amount += _tracking_header.size() + total_arena();
 41   return amount;
 42 }
 43 
 44 // Total malloc&#39;d memory used by arenas
 45 size_t MallocMemorySnapshot::total_arena() const {
 46   size_t amount = 0;
 47   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 48     amount += _malloc[index].arena_size();
 49   }
 50   return amount;
 51 }
 52 
 53 // Make adjustment by subtracting chunks used by arenas
 54 // from total chunks to get total free chunk size
 55 void MallocMemorySnapshot::make_adjustment() {
 56   size_t arena_size = total_arena();
 57   int chunk_idx = NMTUtil::flag_to_index(mtChunk);
 58   _malloc[chunk_idx].record_free(arena_size);
 59 }
 60 
 61 
 62 void MallocMemorySummary::initialize() {
 63   assert(sizeof(_snapshot) &gt;= sizeof(MallocMemorySnapshot), &quot;Sanity Check&quot;);
 64   // Uses placement new operator to initialize static area.
 65   ::new ((void*)_snapshot)MallocMemorySnapshot();
 66 }
 67 
 68 void MallocHeader::release() const {
 69   // Tracking already shutdown, no housekeeping is needed anymore
 70   if (MemTracker::tracking_level() &lt;= NMT_minimal) return;
 71 
 72   MallocMemorySummary::record_free(size(), flags());
 73   MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));
 74   if (MemTracker::tracking_level() == NMT_detail) {
 75     MallocSiteTable::deallocation_at(size(), _bucket_idx, _pos_idx);
 76   }
 77 }
 78 
 79 bool MallocHeader::record_malloc_site(const NativeCallStack&amp; stack, size_t size,
 80   size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const {
 81   bool ret = MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);
 82 
 83   // Something went wrong, could be OOM or overflow malloc site table.
 84   // We want to keep tracking data under OOM circumstance, so transition to
 85   // summary tracking.
 86   if (!ret) {
 87     MemTracker::transition_to(NMT_summary);
 88   }
 89   return ret;
 90 }
 91 
 92 bool MallocHeader::get_stack(NativeCallStack&amp; stack) const {
 93   return MallocSiteTable::access_stack(stack, _bucket_idx, _pos_idx);
 94 }
 95 
 96 bool MallocTracker::initialize(NMT_TrackingLevel level) {
 97   if (level &gt;= NMT_summary) {
 98     MallocMemorySummary::initialize();
 99   }
100 
101   if (level == NMT_detail) {
102     return MallocSiteTable::initialize();
103   }
104   return true;
105 }
106 
107 bool MallocTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
108   assert(from != NMT_off, &quot;Can not transition from off state&quot;);
109   assert(to != NMT_off, &quot;Can not transition to off state&quot;);
110   assert (from != NMT_minimal, &quot;cannot transition from minimal state&quot;);
111 
112   if (from == NMT_detail) {
113     assert(to == NMT_minimal || to == NMT_summary, &quot;Just check&quot;);
114     MallocSiteTable::shutdown();
115   }
116   return true;
117 }
118 
119 // Record a malloc memory allocation
120 void* MallocTracker::record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,
121   const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
<a name="2" id="anc2"></a>
122   void*         memblock;      // the address for user data
123   MallocHeader* header = NULL;
124 
125   if (malloc_base == NULL) {
126     return NULL;
127   }
128 
129   // Uses placement global new operator to initialize malloc header
130 
<a name="3" id="anc3"></a><span class="line-removed">131   if (level == NMT_off) {</span>
<span class="line-removed">132     return malloc_base;</span>
<span class="line-removed">133   }</span>
<span class="line-removed">134 </span>
135   header = ::new (malloc_base)MallocHeader(size, flags, stack, level);
136   memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));
137 
138   // The alignment check: 8 bytes alignment for 32 bit systems.
139   //                      16 bytes alignment for 64-bit systems.
140   assert(((size_t)memblock &amp; (sizeof(size_t) * 2 - 1)) == 0, &quot;Alignment check&quot;);
141 
142 #ifdef ASSERT
143   if (level &gt; NMT_minimal) {
144     // Read back
145     assert(get_size(memblock) == size,   &quot;Wrong size&quot;);
146     assert(get_flags(memblock) == flags, &quot;Wrong flags&quot;);
147   }
148 #endif
149 
150   return memblock;
151 }
152 
153 void* MallocTracker::record_free(void* memblock) {
<a name="4" id="anc4"></a><span class="line-modified">154   // Never turned on</span>
<span class="line-removed">155   if (MemTracker::tracking_level() == NMT_off ||</span>
<span class="line-removed">156       memblock == NULL) {</span>
<span class="line-removed">157     return memblock;</span>
<span class="line-removed">158   }</span>
159   MallocHeader* header = malloc_header(memblock);
160   header-&gt;release();
<a name="5" id="anc5"></a><span class="line-removed">161 </span>
162   return (void*)header;
163 }
<a name="6" id="anc6"></a><span class="line-removed">164 </span>
<span class="line-removed">165 </span>
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/attachListener.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 32 #include &quot;prims/jvmtiExport.hpp&quot;
 33 #include &quot;runtime/arguments.hpp&quot;
 34 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/java.hpp&quot;
 38 #include &quot;runtime/javaCalls.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;services/attachListener.hpp&quot;
 41 #include &quot;services/diagnosticCommand.hpp&quot;
 42 #include &quot;services/heapDumper.hpp&quot;
 43 #include &quot;services/writeableFlags.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 #include &quot;utilities/formatBuffer.hpp&quot;
 46 
 47 volatile bool AttachListener::_initialized;
 48 
 49 // Implementation of &quot;properties&quot; command.
 50 //
 51 // Invokes VMSupport.serializePropertiesToByteArray to serialize
 52 // the system properties into a byte array.
 53 
 54 static InstanceKlass* load_and_initialize_klass(Symbol* sh, TRAPS) {
 55   Klass* k = SystemDictionary::resolve_or_fail(sh, true, CHECK_NULL);
 56   InstanceKlass* ik = InstanceKlass::cast(k);
 57   if (ik-&gt;should_be_initialized()) {
 58     ik-&gt;initialize(CHECK_NULL);
 59   }
 60   return ik;
 61 }
 62 
 63 static jint get_properties(AttachOperation* op, outputStream* out, Symbol* serializePropertiesMethod) {
 64   Thread* THREAD = Thread::current();
 65   HandleMark hm;
 66 
 67   // load VMSupport
 68   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
 69   InstanceKlass* k = load_and_initialize_klass(klass, THREAD);
 70   if (HAS_PENDING_EXCEPTION) {
 71     java_lang_Throwable::print(PENDING_EXCEPTION, out);
 72     CLEAR_PENDING_EXCEPTION;
 73     return JNI_ERR;
 74   }
 75 
 76   // invoke the serializePropertiesToByteArray method
 77   JavaValue result(T_OBJECT);
 78   JavaCallArguments args;
 79 
 80 
 81   Symbol* signature = vmSymbols::serializePropertiesToByteArray_signature();
 82   JavaCalls::call_static(&amp;result,
 83                          k,
 84                          serializePropertiesMethod,
 85                          signature,
 86                          &amp;args,
 87                          THREAD);
 88   if (HAS_PENDING_EXCEPTION) {
 89     java_lang_Throwable::print(PENDING_EXCEPTION, out);
 90     CLEAR_PENDING_EXCEPTION;
 91     return JNI_ERR;
 92   }
 93 
 94   // The result should be a [B
 95   oop res = (oop)result.get_jobject();
 96   assert(res-&gt;is_typeArray(), &quot;just checking&quot;);
 97   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;just checking&quot;);
 98 
 99   // copy the bytes to the output stream
100   typeArrayOop ba = typeArrayOop(res);
101   jbyte* addr = typeArrayOop(res)-&gt;byte_at_addr(0);
102   out-&gt;print_raw((const char*)addr, ba-&gt;length());
103 
104   return JNI_OK;
105 }
106 
107 // Implementation of &quot;load&quot; command.
108 static jint load_agent(AttachOperation* op, outputStream* out) {
109   // get agent name and options
110   const char* agent = op-&gt;arg(0);
111   const char* absParam = op-&gt;arg(1);
112   const char* options = op-&gt;arg(2);
113 
114   // If loading a java agent then need to ensure that the java.instrument module is loaded
115   if (strcmp(agent, &quot;instrument&quot;) == 0) {
116     Thread* THREAD = Thread::current();
117     ResourceMark rm(THREAD);
118     HandleMark hm(THREAD);
119     JavaValue result(T_OBJECT);
120     Handle h_module_name = java_lang_String::create_from_str(&quot;java.instrument&quot;, THREAD);
121     JavaCalls::call_static(&amp;result,
122                            SystemDictionary::module_Modules_klass(),
123                            vmSymbols::loadModule_name(),
124                            vmSymbols::loadModule_signature(),
125                            h_module_name,
126                            THREAD);
127     if (HAS_PENDING_EXCEPTION) {
128       java_lang_Throwable::print(PENDING_EXCEPTION, out);
129       CLEAR_PENDING_EXCEPTION;
130       return JNI_ERR;
131     }
132   }
133 
134   return JvmtiExport::load_agent_library(agent, absParam, options, out);
135 }
136 
137 // Implementation of &quot;properties&quot; command.
138 // See also: PrintSystemPropertiesDCmd class
139 static jint get_system_properties(AttachOperation* op, outputStream* out) {
140   return get_properties(op, out, vmSymbols::serializePropertiesToByteArray_name());
141 }
142 
143 // Implementation of &quot;agent_properties&quot; command.
144 static jint get_agent_properties(AttachOperation* op, outputStream* out) {
145   return get_properties(op, out, vmSymbols::serializeAgentPropertiesToByteArray_name());
146 }
147 
148 // Implementation of &quot;datadump&quot; command.
149 //
150 // Raises a SIGBREAK signal so that VM dump threads, does deadlock detection,
151 // etc. In theory this command should only post a DataDumpRequest to any
152 // JVMTI environment that has enabled this event. However it&#39;s useful to
153 // trigger the SIGBREAK handler.
154 
155 static jint data_dump(AttachOperation* op, outputStream* out) {
156   if (!ReduceSignalUsage) {
157     AttachListener::pd_data_dump();
158   } else {
159     if (JvmtiExport::should_post_data_dump()) {
160       JvmtiExport::post_data_dump();
161     }
162   }
163   return JNI_OK;
164 }
165 
166 // Implementation of &quot;threaddump&quot; command - essentially a remote ctrl-break
167 // See also: ThreadDumpDCmd class
168 //
169 static jint thread_dump(AttachOperation* op, outputStream* out) {
170   bool print_concurrent_locks = false;
171   bool print_extended_info = false;
172   if (op-&gt;arg(0) != NULL) {
173     for (int i = 0; op-&gt;arg(0)[i] != 0; ++i) {
174       if (op-&gt;arg(0)[i] == &#39;l&#39;) {
175         print_concurrent_locks = true;
176       }
177       if (op-&gt;arg(0)[i] == &#39;e&#39;) {
178         print_extended_info = true;
179       }
180     }
181   }
182 
183   // thread stacks
184   VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info);
185   VMThread::execute(&amp;op1);
186 
187   // JNI global handles
188   VM_PrintJNI op2(out);
189   VMThread::execute(&amp;op2);
190 
191   // Deadlock detection
192   VM_FindDeadlocks op3(out);
193   VMThread::execute(&amp;op3);
194 
195   return JNI_OK;
196 }
197 
198 // A jcmd attach operation request was received, which will now
199 // dispatch to the diagnostic commands used for serviceability functions.
200 static jint jcmd(AttachOperation* op, outputStream* out) {
201   Thread* THREAD = Thread::current();
202   // All the supplied jcmd arguments are stored as a single
203   // string (op-&gt;arg(0)). This is parsed by the Dcmd framework.
204   DCmd::parse_and_execute(DCmd_Source_AttachAPI, out, op-&gt;arg(0), &#39; &#39;, THREAD);
205   if (HAS_PENDING_EXCEPTION) {
206     java_lang_Throwable::print(PENDING_EXCEPTION, out);
207     out-&gt;cr();
208     CLEAR_PENDING_EXCEPTION;
209     return JNI_ERR;
210   }
211   return JNI_OK;
212 }
213 
214 // Implementation of &quot;dumpheap&quot; command.
215 // See also: HeapDumpDCmd class
216 //
217 // Input arguments :-
218 //   arg0: Name of the dump file
219 //   arg1: &quot;-live&quot; or &quot;-all&quot;
220 jint dump_heap(AttachOperation* op, outputStream* out) {
221   const char* path = op-&gt;arg(0);
222   if (path == NULL || path[0] == &#39;\0&#39;) {
223     out-&gt;print_cr(&quot;No dump file specified&quot;);
224   } else {
225     bool live_objects_only = true;   // default is true to retain the behavior before this change is made
226     const char* arg1 = op-&gt;arg(1);
227     if (arg1 != NULL &amp;&amp; (strlen(arg1) &gt; 0)) {
228       if (strcmp(arg1, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg1, &quot;-live&quot;) != 0) {
229         out-&gt;print_cr(&quot;Invalid argument to dumpheap operation: %s&quot;, arg1);
230         return JNI_ERR;
231       }
232       live_objects_only = strcmp(arg1, &quot;-live&quot;) == 0;
233     }
234 
235     // Request a full GC before heap dump if live_objects_only = true
236     // This helps reduces the amount of unreachable objects in the dump
237     // and makes it easier to browse.
238     HeapDumper dumper(live_objects_only /* request GC */);
239     int res = dumper.dump(op-&gt;arg(0));
240     if (res == 0) {
241       out-&gt;print_cr(&quot;Heap dump file created&quot;);
242     } else {
243       // heap dump failed
244       ResourceMark rm;
245       char* error = dumper.error_as_C_string();
246       if (error == NULL) {
247         out-&gt;print_cr(&quot;Dump failed - reason unknown&quot;);
248       } else {
249         out-&gt;print_cr(&quot;%s&quot;, error);
250       }
251     }
252   }
253   return JNI_OK;
254 }
255 
256 // Implementation of &quot;inspectheap&quot; command
257 // See also: ClassHistogramDCmd class
258 //
259 // Input arguments :-
260 //   arg0: &quot;-live&quot; or &quot;-all&quot;
261 //   arg1: Name of the dump file or NULL
262 static jint heap_inspection(AttachOperation* op, outputStream* out) {
263   bool live_objects_only = true;   // default is true to retain the behavior before this change is made
264   outputStream* os = out;   // if path not specified or path is NULL, use out
265   fileStream* fs = NULL;
266   const char* arg0 = op-&gt;arg(0);
267   if (arg0 != NULL &amp;&amp; (strlen(arg0) &gt; 0)) {
268     if (strcmp(arg0, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg0, &quot;-live&quot;) != 0) {
269       out-&gt;print_cr(&quot;Invalid argument to inspectheap operation: %s&quot;, arg0);
270       return JNI_ERR;
271     }
272     live_objects_only = strcmp(arg0, &quot;-live&quot;) == 0;
273   }
274 
275   const char* path = op-&gt;arg(1);
276   if (path != NULL) {
277     if (path[0] == &#39;\0&#39;) {
278       out-&gt;print_cr(&quot;No dump file specified&quot;);
279     } else {
280       // create file
281       fs = new (ResourceObj::C_HEAP, mtInternal) fileStream(path);
282       if (fs == NULL) {
283         out-&gt;print_cr(&quot;Failed to allocate space for file: %s&quot;, path);
284         return JNI_ERR;
285       }
286       os = fs;
287     }
288   }
289 
290   VM_GC_HeapInspection heapop(os, live_objects_only /* request full gc */);
291   VMThread::execute(&amp;heapop);
292   if (os != NULL &amp;&amp; os != out) {
293     out-&gt;print_cr(&quot;Heap inspection file created: %s&quot;, path);
294     delete fs;
295   }
296   return JNI_OK;
297 }
298 
299 // Implementation of &quot;setflag&quot; command
300 static jint set_flag(AttachOperation* op, outputStream* out) {
301 
302   const char* name = NULL;
303   if ((name = op-&gt;arg(0)) == NULL) {
304     out-&gt;print_cr(&quot;flag name is missing&quot;);
305     return JNI_ERR;
306   }
307 
308   FormatBuffer&lt;80&gt; err_msg(&quot;%s&quot;, &quot;&quot;);
309 
310   int ret = WriteableFlags::set_flag(op-&gt;arg(0), op-&gt;arg(1), JVMFlag::ATTACH_ON_DEMAND, err_msg);
311   if (ret != JVMFlag::SUCCESS) {
312     if (ret == JVMFlag::NON_WRITABLE) {
313       // if the flag is not manageable try to change it through
314       // the platform dependent implementation
315       return AttachListener::pd_set_flag(op, out);
316     } else {
317       out-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
318     }
319 
320     return JNI_ERR;
321   }
322   return JNI_OK;
323 }
324 
325 // Implementation of &quot;printflag&quot; command
326 // See also: PrintVMFlagsDCmd class
327 static jint print_flag(AttachOperation* op, outputStream* out) {
328   const char* name = NULL;
329   if ((name = op-&gt;arg(0)) == NULL) {
330     out-&gt;print_cr(&quot;flag name is missing&quot;);
331     return JNI_ERR;
332   }
333   JVMFlag* f = JVMFlag::find_flag((char*)name, strlen(name));
334   if (f) {
335     f-&gt;print_as_flag(out);
336     out-&gt;cr();
337   } else {
338     out-&gt;print_cr(&quot;no such flag &#39;%s&#39;&quot;, name);
339   }
340   return JNI_OK;
341 }
342 
343 // Table to map operation names to functions.
344 
345 // names must be of length &lt;= AttachOperation::name_length_max
346 static AttachOperationFunctionInfo funcs[] = {
347   { &quot;agentProperties&quot;,  get_agent_properties },
348   { &quot;datadump&quot;,         data_dump },
349   { &quot;dumpheap&quot;,         dump_heap },
350   { &quot;load&quot;,             load_agent },
351   { &quot;properties&quot;,       get_system_properties },
352   { &quot;threaddump&quot;,       thread_dump },
353   { &quot;inspectheap&quot;,      heap_inspection },
354   { &quot;setflag&quot;,          set_flag },
355   { &quot;printflag&quot;,        print_flag },
356   { &quot;jcmd&quot;,             jcmd },
357   { NULL,               NULL }
358 };
359 
360 
361 
362 // The Attach Listener threads services a queue. It dequeues an operation
363 // from the queue, examines the operation name (command), and dispatches
364 // to the corresponding function to perform the operation.
365 
366 static void attach_listener_thread_entry(JavaThread* thread, TRAPS) {
367   os::set_priority(thread, NearMaxPriority);
368 
369   assert(thread == Thread::current(), &quot;Must be&quot;);
370   assert(thread-&gt;stack_base() != NULL &amp;&amp; thread-&gt;stack_size() &gt; 0,
371          &quot;Should already be setup&quot;);
372 
373   if (AttachListener::pd_init() != 0) {
374     return;
375   }
376   AttachListener::set_initialized();
377 
378   for (;;) {
379     AttachOperation* op = AttachListener::dequeue();
380     if (op == NULL) {
381       return;   // dequeue failed or shutdown
382     }
383 
384     ResourceMark rm;
385     bufferedStream st;
386     jint res = JNI_OK;
387 
388     // handle special detachall operation
389     if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {
390       AttachListener::detachall();
391     } else if (!EnableDynamicAgentLoading &amp;&amp; strcmp(op-&gt;name(), &quot;load&quot;) == 0) {
392       st.print(&quot;Dynamic agent loading is not enabled. &quot;
393                &quot;Use -XX:+EnableDynamicAgentLoading to launch target VM.&quot;);
394       res = JNI_ERR;
395     } else {
396       // find the function to dispatch too
397       AttachOperationFunctionInfo* info = NULL;
398       for (int i=0; funcs[i].name != NULL; i++) {
399         const char* name = funcs[i].name;
400         assert(strlen(name) &lt;= AttachOperation::name_length_max, &quot;operation &lt;= name_length_max&quot;);
401         if (strcmp(op-&gt;name(), name) == 0) {
402           info = &amp;(funcs[i]);
403           break;
404         }
405       }
406 
407       // check for platform dependent attach operation
408       if (info == NULL) {
409         info = AttachListener::pd_find_operation(op-&gt;name());
410       }
411 
412       if (info != NULL) {
413         // dispatch to the function that implements this operation
414         res = (info-&gt;func)(op, &amp;st);
415       } else {
416         st.print(&quot;Operation %s not recognized!&quot;, op-&gt;name());
417         res = JNI_ERR;
418       }
419     }
420 
421     // operation complete - send result and output to client
422     op-&gt;complete(res, &amp;st);
423   }
424 }
425 
426 bool AttachListener::has_init_error(TRAPS) {
427   if (HAS_PENDING_EXCEPTION) {
428     tty-&gt;print_cr(&quot;Exception in VM (AttachListener::init) : &quot;);
429     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
430     tty-&gt;cr();
431 
432     CLEAR_PENDING_EXCEPTION;
433 
434     return true;
435   } else {
436     return false;
437   }
438 }
439 
440 // Starts the Attach Listener thread
441 void AttachListener::init() {
442   EXCEPTION_MARK;
443 
444   const char thread_name[] = &quot;Attach Listener&quot;;
445   Handle string = java_lang_String::create_from_str(thread_name, THREAD);
446   if (has_init_error(THREAD)) {
447     return;
448   }
449 
450   // Initialize thread_oop to put it into the system threadGroup
451   Handle thread_group (THREAD, Universe::system_thread_group());
452   Handle thread_oop = JavaCalls::construct_new_instance(SystemDictionary::Thread_klass(),
453                        vmSymbols::threadgroup_string_void_signature(),
454                        thread_group,
455                        string,
456                        THREAD);
457   if (has_init_error(THREAD)) {
458     return;
459   }
460 
461   Klass* group = SystemDictionary::ThreadGroup_klass();
462   JavaValue result(T_VOID);
463   JavaCalls::call_special(&amp;result,
464                         thread_group,
465                         group,
466                         vmSymbols::add_method_name(),
467                         vmSymbols::thread_void_signature(),
468                         thread_oop,
469                         THREAD);
470   if (has_init_error(THREAD)) {
471     return;
472   }
473 
474   { MutexLocker mu(Threads_lock);
475     JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);
476 
477     // Check that thread and osthread were created
478     if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
479       vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
480                                     os::native_thread_creation_failed_msg());
481     }
482 
483     java_lang_Thread::set_thread(thread_oop(), listener_thread);
484     java_lang_Thread::set_daemon(thread_oop());
485 
486     listener_thread-&gt;set_threadObj(thread_oop());
487     Threads::add(listener_thread);
488     Thread::start(listener_thread);
489   }
490 }
491 
492 // Performs clean-up tasks on platforms where we can detect that the last
493 // client has detached
494 void AttachListener::detachall() {
495   // call the platform dependent clean-up
496   pd_detachall();
497 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/classLoadingService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 29 #include &quot;memory/universe.hpp&quot;</span>
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/mutexLocker.hpp&quot;
 32 #include &quot;services/classLoadingService.hpp&quot;
 33 #include &quot;services/memoryService.hpp&quot;
 34 #include &quot;utilities/dtrace.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #include &quot;utilities/defaultStream.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;logging/logConfiguration.hpp&quot;
 39 
 40 #ifdef DTRACE_ENABLED
 41 
 42 // Only bother with this argument setup if dtrace is available
 43 
 44 #define HOTSPOT_CLASS_unloaded HOTSPOT_CLASS_UNLOADED
 45 #define HOTSPOT_CLASS_loaded HOTSPOT_CLASS_LOADED
 46 #define DTRACE_CLASSLOAD_PROBE(type, clss, shared)  \
 47   {                                                 \
 48     char* data = NULL;                              \
 49     int len = 0;                                    \
 50     Symbol* name = (clss)-&gt;name();                  \
 51     if (name != NULL) {                             \
 52       data = (char*)name-&gt;bytes();                  \
 53       len = name-&gt;utf8_length();                    \
 54     }                                               \
 55     HOTSPOT_CLASS_##type( /* type = unloaded, loaded */ \
 56       data, len, (void*)(clss)-&gt;class_loader_data(), (shared)); \
 57   }
 58 
 59 #else //  ndef DTRACE_ENABLED
 60 
 61 #define DTRACE_CLASSLOAD_PROBE(type, clss, shared)
 62 
 63 #endif
 64 
 65 #if INCLUDE_MANAGEMENT
 66 // counters for classes loaded from class files
 67 PerfCounter*    ClassLoadingService::_classes_loaded_count = NULL;
 68 PerfCounter*    ClassLoadingService::_classes_unloaded_count = NULL;
 69 PerfCounter*    ClassLoadingService::_classbytes_loaded = NULL;
 70 PerfCounter*    ClassLoadingService::_classbytes_unloaded = NULL;
 71 
 72 // counters for classes loaded from shared archive
 73 PerfCounter*    ClassLoadingService::_shared_classes_loaded_count = NULL;
 74 PerfCounter*    ClassLoadingService::_shared_classes_unloaded_count = NULL;
 75 PerfCounter*    ClassLoadingService::_shared_classbytes_loaded = NULL;
 76 PerfCounter*    ClassLoadingService::_shared_classbytes_unloaded = NULL;
 77 PerfVariable*   ClassLoadingService::_class_methods_size = NULL;
 78 
 79 void ClassLoadingService::init() {
 80   EXCEPTION_MARK;
 81 
 82   // These counters are for java.lang.management API support.
 83   // They are created even if -XX:-UsePerfData is set and in
 84   // that case, they will be allocated on C heap.
 85   _classes_loaded_count =
 86                  PerfDataManager::create_counter(JAVA_CLS, &quot;loadedClasses&quot;,
 87                                                  PerfData::U_Events, CHECK);
 88 
 89   _classes_unloaded_count =
 90                  PerfDataManager::create_counter(JAVA_CLS, &quot;unloadedClasses&quot;,
 91                                                  PerfData::U_Events, CHECK);
 92 
 93   _shared_classes_loaded_count =
 94                  PerfDataManager::create_counter(JAVA_CLS, &quot;sharedLoadedClasses&quot;,
 95                                                  PerfData::U_Events, CHECK);
 96 
 97   _shared_classes_unloaded_count =
 98                  PerfDataManager::create_counter(JAVA_CLS, &quot;sharedUnloadedClasses&quot;,
 99                                                  PerfData::U_Events, CHECK);
100 
101   if (UsePerfData) {
102     _classbytes_loaded =
103                  PerfDataManager::create_counter(SUN_CLS, &quot;loadedBytes&quot;,
104                                                  PerfData::U_Bytes, CHECK);
105 
106     _classbytes_unloaded =
107                  PerfDataManager::create_counter(SUN_CLS, &quot;unloadedBytes&quot;,
108                                                  PerfData::U_Bytes, CHECK);
109     _shared_classbytes_loaded =
110                  PerfDataManager::create_counter(SUN_CLS, &quot;sharedLoadedBytes&quot;,
111                                                  PerfData::U_Bytes, CHECK);
112 
113     _shared_classbytes_unloaded =
114                  PerfDataManager::create_counter(SUN_CLS, &quot;sharedUnloadedBytes&quot;,
115                                                  PerfData::U_Bytes, CHECK);
116     _class_methods_size =
117                  PerfDataManager::create_variable(SUN_CLS, &quot;methodBytes&quot;,
118                                                   PerfData::U_Bytes, CHECK);
119   }
120 }
121 
122 void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {
123   DTRACE_CLASSLOAD_PROBE(unloaded, k, false);
124   // Classes that can be unloaded must be non-shared
125   _classes_unloaded_count-&gt;inc();
126 
127   if (UsePerfData) {
128     // add the class size
129     size_t size = compute_class_size(k);
130     _classbytes_unloaded-&gt;inc(size);
131 
132     // Compute method size &amp; subtract from running total.
133     // We are called during phase 1 of mark sweep, so it&#39;s
134     // still ok to iterate through Method*s here.
135     Array&lt;Method*&gt;* methods = k-&gt;methods();
136     for (int i = 0; i &lt; methods-&gt;length(); i++) {
137       _class_methods_size-&gt;inc(-methods-&gt;at(i)-&gt;size());
138     }
139   }
140 }
141 
142 void ClassLoadingService::notify_class_loaded(InstanceKlass* k, bool shared_class) {
143   DTRACE_CLASSLOAD_PROBE(loaded, k, shared_class);
144   PerfCounter* classes_counter = (shared_class ? _shared_classes_loaded_count
145                                                : _classes_loaded_count);
146   // increment the count
147   classes_counter-&gt;inc();
148 
149   if (UsePerfData) {
150     PerfCounter* classbytes_counter = (shared_class ? _shared_classbytes_loaded
151                                                     : _classbytes_loaded);
152     // add the class size
153     size_t size = compute_class_size(k);
154     classbytes_counter-&gt;inc(size);
155   }
156 }
157 
158 size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {
159   // lifted from ClassStatistics.do_class(Klass* k)
160 
161   size_t class_size = 0;
162 
163   class_size += k-&gt;size();
164 
165   if (k-&gt;is_instance_klass()) {
166     class_size += k-&gt;methods()-&gt;size();
167     // FIXME: Need to count the contents of methods
168     class_size += k-&gt;constants()-&gt;size();
169     class_size += k-&gt;local_interfaces()-&gt;size();
170     if (k-&gt;transitive_interfaces() != NULL) {
171       class_size += k-&gt;transitive_interfaces()-&gt;size();
172     }
173     // We do not have to count implementors, since we only store one!
174     // FIXME: How should these be accounted for, now when they have moved.
175     //class_size += k-&gt;fields()-&gt;size();
176   }
177   return class_size * oopSize;
178 }
179 
180 bool ClassLoadingService::set_verbose(bool verbose) {
181   MutexLocker m(Management_lock);
182   // verbose will be set to the previous value
183   LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;
184   LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));
185   reset_trace_class_unloading();
186   return verbose;
187 }
188 
189 // Caller to this function must own Management_lock
190 void ClassLoadingService::reset_trace_class_unloading() {
191   assert(Management_lock-&gt;owned_by_self(), &quot;Must own the Management_lock&quot;);
192   bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();
193   LogLevelType level = value ? LogLevel::Info : LogLevel::Off;
194   LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));
195 }
196 
197 #endif // INCLUDE_MANAGEMENT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
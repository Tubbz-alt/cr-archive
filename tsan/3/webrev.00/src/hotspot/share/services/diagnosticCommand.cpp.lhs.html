<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;compiler/directivesParser.hpp&quot;
  31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  32 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
  34 #include &quot;oops/objArrayOop.inline.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  37 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  38 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/javaCalls.hpp&quot;
  42 #include &quot;runtime/os.hpp&quot;
  43 #include &quot;services/diagnosticArgument.hpp&quot;
  44 #include &quot;services/diagnosticCommand.hpp&quot;
  45 #include &quot;services/diagnosticFramework.hpp&quot;
  46 #include &quot;services/heapDumper.hpp&quot;
  47 #include &quot;services/management.hpp&quot;
  48 #include &quot;services/writeableFlags.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;
<a name="3" id="anc3"></a>
  50 #include &quot;utilities/formatBuffer.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 
  53 
  54 static void loadAgentModule(TRAPS) {
  55   ResourceMark rm(THREAD);
  56   HandleMark hm(THREAD);
  57 
  58   JavaValue result(T_OBJECT);
  59   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  60   JavaCalls::call_static(&amp;result,
  61                          SystemDictionary::module_Modules_klass(),
  62                          vmSymbols::loadModule_name(),
  63                          vmSymbols::loadModule_signature(),
  64                          h_module_name,
  65                          THREAD);
  66 }
  67 
  68 void DCmdRegistrant::register_dcmds(){
  69   // Registration of the diagnostic commands
  70   // First argument specifies which interfaces will export the command
  71   // Second argument specifies if the command is enabled
  72   // Third  argument specifies if the command is hidden
  73   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  74                          | DCmd_Source_MBean;
  75   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  76   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  77   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  88 #if INCLUDE_SERVICES
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  90   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));
<a name="4" id="anc4"></a><span class="line-removed">  91   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassStatsDCmd&gt;(full_export, true, false));</span>
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));
<a name="5" id="anc5"></a>
  97 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
  99 #endif // INCLUDE_JVMTI
 100 #endif // INCLUDE_SERVICES
 101 #if INCLUDE_JVMTI
 102   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 103 #endif // INCLUDE_JVMTI
 104   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 105   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 106   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 107   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 112 
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 114   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 115   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 116   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 117 
 118   // Enhanced JMX Agent Support
 119   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 120   // appropriate permission is created for them
 121   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 122   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 123   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 124   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 125   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 126 
 127   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 128 #if INCLUDE_JVMTI
<a name="6" id="anc6"></a><span class="line-modified"> 129   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, false));</span>
 130 #endif // INCLUDE_JVMTI
 131 
 132 }
 133 
 134 #ifndef HAVE_EXTRA_DCMD
 135 void DCmdRegistrant::register_dcmds_ext(){
 136    // Do nothing here
 137 }
 138 #endif
 139 
 140 
 141 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 142   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 143   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 144         &quot;STRING&quot;, false) {
 145   _dcmdparser.add_dcmd_option(&amp;_all);
 146   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 147 };
 148 
 149 
 150 static int compare_strings(const char** s1, const char** s2) {
 151   return ::strcmp(*s1, *s2);
 152 }
 153 
 154 void HelpDCmd::execute(DCmdSource source, TRAPS) {
 155   if (_all.value()) {
 156     GrowableArray&lt;const char*&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 157     cmd_list-&gt;sort(compare_strings);
 158     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 159       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 160                                                   strlen(cmd_list-&gt;at(i)));
 161       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 162                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 163       output()-&gt;print_cr(&quot;\t%s&quot;, factory-&gt;description());
 164       output()-&gt;cr();
 165       factory = factory-&gt;next();
 166     }
 167   } else if (_cmd.has_value()) {
 168     DCmd* cmd = NULL;
 169     DCmdFactory* factory = DCmdFactory::factory(source, _cmd.value(),
 170                                                 strlen(_cmd.value()));
 171     if (factory != NULL) {
 172       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 173                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 174       output()-&gt;print_cr(&quot;%s&quot;, factory-&gt;description());
 175       output()-&gt;print_cr(&quot;\nImpact: %s&quot;, factory-&gt;impact());
 176       JavaPermission p = factory-&gt;permission();
 177       if(p._class != NULL) {
 178         if(p._action != NULL) {
 179           output()-&gt;print_cr(&quot;\nPermission: %s(%s, %s)&quot;,
 180                   p._class, p._name == NULL ? &quot;null&quot; : p._name, p._action);
 181         } else {
 182           output()-&gt;print_cr(&quot;\nPermission: %s(%s)&quot;,
 183                   p._class, p._name == NULL ? &quot;null&quot; : p._name);
 184         }
 185       }
 186       output()-&gt;cr();
 187       cmd = factory-&gt;create_resource_instance(output());
 188       if (cmd != NULL) {
 189         DCmdMark mark(cmd);
 190         cmd-&gt;print_help(factory-&gt;name());
 191       }
 192     } else {
 193       output()-&gt;print_cr(&quot;Help unavailable : &#39;%s&#39; : No such command&quot;, _cmd.value());
 194     }
 195   } else {
 196     output()-&gt;print_cr(&quot;The following commands are available:&quot;);
 197     GrowableArray&lt;const char *&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 198     cmd_list-&gt;sort(compare_strings);
 199     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 200       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 201                                                   strlen(cmd_list-&gt;at(i)));
 202       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 203                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 204       factory = factory-&gt;_next;
 205     }
 206     output()-&gt;print_cr(&quot;\nFor more information about a specific command use &#39;help &lt;command&gt;&#39;.&quot;);
 207   }
 208 }
 209 
 210 int HelpDCmd::num_arguments() {
 211   ResourceMark rm;
 212   HelpDCmd* dcmd = new HelpDCmd(NULL, false);
 213   if (dcmd != NULL) {
 214     DCmdMark mark(dcmd);
 215     return dcmd-&gt;_dcmdparser.num_arguments();
 216   } else {
 217     return 0;
 218   }
 219 }
 220 
 221 void VersionDCmd::execute(DCmdSource source, TRAPS) {
 222   output()-&gt;print_cr(&quot;%s version %s&quot;, VM_Version::vm_name(),
 223           VM_Version::vm_release());
 224   JDK_Version jdk_version = JDK_Version::current();
 225   if (jdk_version.patch_version() &gt; 0) {
 226     output()-&gt;print_cr(&quot;JDK %d.%d.%d.%d&quot;, jdk_version.major_version(),
 227             jdk_version.minor_version(), jdk_version.security_version(),
 228             jdk_version.patch_version());
 229   } else {
 230     output()-&gt;print_cr(&quot;JDK %d.%d.%d&quot;, jdk_version.major_version(),
 231             jdk_version.minor_version(), jdk_version.security_version());
 232   }
 233 }
 234 
 235 PrintVMFlagsDCmd::PrintVMFlagsDCmd(outputStream* output, bool heap) :
 236                                    DCmdWithParser(output, heap),
 237   _all(&quot;-all&quot;, &quot;Print all flags supported by the VM&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 238   _dcmdparser.add_dcmd_option(&amp;_all);
 239 }
 240 
 241 void PrintVMFlagsDCmd::execute(DCmdSource source, TRAPS) {
 242   if (_all.value()) {
 243     JVMFlag::printFlags(output(), true);
 244   } else {
 245     JVMFlag::printSetFlags(output());
 246   }
 247 }
 248 
 249 int PrintVMFlagsDCmd::num_arguments() {
 250     ResourceMark rm;
 251     PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);
 252     if (dcmd != NULL) {
 253       DCmdMark mark(dcmd);
 254       return dcmd-&gt;_dcmdparser.num_arguments();
 255     } else {
 256       return 0;
 257     }
 258 }
 259 
 260 SetVMFlagDCmd::SetVMFlagDCmd(outputStream* output, bool heap) :
 261                                    DCmdWithParser(output, heap),
 262   _flag(&quot;flag name&quot;, &quot;The name of the flag we want to set&quot;,
 263         &quot;STRING&quot;, true),
 264   _value(&quot;string value&quot;, &quot;The value we want to set&quot;, &quot;STRING&quot;, false) {
 265   _dcmdparser.add_dcmd_argument(&amp;_flag);
 266   _dcmdparser.add_dcmd_argument(&amp;_value);
 267 }
 268 
 269 void SetVMFlagDCmd::execute(DCmdSource source, TRAPS) {
 270   const char* val = NULL;
 271   if (_value.value() != NULL) {
 272     val = _value.value();
 273   }
 274 
 275   FormatBuffer&lt;80&gt; err_msg(&quot;%s&quot;, &quot;&quot;);
 276   int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);
 277 
 278   if (ret != JVMFlag::SUCCESS) {
 279     output()-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
 280   }
 281 }
 282 
 283 int SetVMFlagDCmd::num_arguments() {
 284   ResourceMark rm;
 285   SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);
 286   if (dcmd != NULL) {
 287     DCmdMark mark(dcmd);
 288     return dcmd-&gt;_dcmdparser.num_arguments();
 289   } else {
 290     return 0;
 291   }
 292 }
 293 
 294 void JVMTIDataDumpDCmd::execute(DCmdSource source, TRAPS) {
 295   if (JvmtiExport::should_post_data_dump()) {
 296     JvmtiExport::post_data_dump();
 297   }
 298 }
 299 
 300 #if INCLUDE_SERVICES
 301 JVMTIAgentLoadDCmd::JVMTIAgentLoadDCmd(outputStream* output, bool heap) :
 302                                        DCmdWithParser(output, heap),
 303   _libpath(&quot;library path&quot;, &quot;Absolute path of the JVMTI agent to load.&quot;,
 304            &quot;STRING&quot;, true),
 305   _option(&quot;agent option&quot;, &quot;Option string to pass the agent.&quot;, &quot;STRING&quot;, false) {
 306   _dcmdparser.add_dcmd_argument(&amp;_libpath);
 307   _dcmdparser.add_dcmd_argument(&amp;_option);
 308 }
 309 
 310 void JVMTIAgentLoadDCmd::execute(DCmdSource source, TRAPS) {
 311 
 312   if (_libpath.value() == NULL) {
 313     output()-&gt;print_cr(&quot;JVMTI.agent_load dcmd needs library path.&quot;);
 314     return;
 315   }
 316 
 317   char *suffix = strrchr(_libpath.value(), &#39;.&#39;);
 318   bool is_java_agent = (suffix != NULL) &amp;&amp; (strncmp(&quot;.jar&quot;, suffix, 4) == 0);
 319 
 320   if (is_java_agent) {
 321     if (_option.value() == NULL) {
 322       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;,
 323                                       _libpath.value(), output());
 324     } else {
 325       size_t opt_len = strlen(_libpath.value()) + strlen(_option.value()) + 2;
 326       if (opt_len &gt; 4096) {
 327         output()-&gt;print_cr(&quot;JVMTI agent attach failed: Options is too long.&quot;);
 328         return;
 329       }
 330 
 331       char *opt = (char *)os::malloc(opt_len, mtInternal);
 332       if (opt == NULL) {
 333         output()-&gt;print_cr(&quot;JVMTI agent attach failed: &quot;
 334                            &quot;Could not allocate &quot; SIZE_FORMAT &quot; bytes for argument.&quot;,
 335                            opt_len);
 336         return;
 337       }
 338 
 339       jio_snprintf(opt, opt_len, &quot;%s=%s&quot;, _libpath.value(), _option.value());
 340       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;, opt, output());
 341 
 342       os::free(opt);
 343     }
 344   } else {
 345     JvmtiExport::load_agent_library(_libpath.value(), &quot;true&quot;,
 346                                     _option.value(), output());
 347   }
 348 }
 349 
 350 int JVMTIAgentLoadDCmd::num_arguments() {
 351   ResourceMark rm;
 352   JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);
 353   if (dcmd != NULL) {
 354     DCmdMark mark(dcmd);
 355     return dcmd-&gt;_dcmdparser.num_arguments();
 356   } else {
 357     return 0;
 358   }
 359 }
 360 #endif // INCLUDE_SERVICES
 361 
 362 void PrintSystemPropertiesDCmd::execute(DCmdSource source, TRAPS) {
 363   // load VMSupport
 364   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
 365   Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK);
 366   InstanceKlass* ik = InstanceKlass::cast(k);
 367   if (ik-&gt;should_be_initialized()) {
 368     ik-&gt;initialize(THREAD);
 369   }
 370   if (HAS_PENDING_EXCEPTION) {
 371     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 372     output()-&gt;cr();
 373     CLEAR_PENDING_EXCEPTION;
 374     return;
 375   }
 376 
 377   // invoke the serializePropertiesToByteArray method
 378   JavaValue result(T_OBJECT);
 379   JavaCallArguments args;
 380 
 381   Symbol* signature = vmSymbols::serializePropertiesToByteArray_signature();
 382   JavaCalls::call_static(&amp;result,
 383                          ik,
 384                          vmSymbols::serializePropertiesToByteArray_name(),
 385                          signature,
 386                          &amp;args,
 387                          THREAD);
 388   if (HAS_PENDING_EXCEPTION) {
 389     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 390     output()-&gt;cr();
 391     CLEAR_PENDING_EXCEPTION;
 392     return;
 393   }
 394 
 395   // The result should be a [B
 396   oop res = (oop)result.get_jobject();
 397   assert(res-&gt;is_typeArray(), &quot;just checking&quot;);
 398   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;just checking&quot;);
 399 
 400   // copy the bytes to the output stream
 401   typeArrayOop ba = typeArrayOop(res);
 402   jbyte* addr = typeArrayOop(res)-&gt;byte_at_addr(0);
 403   output()-&gt;print_raw((const char*)addr, ba-&gt;length());
 404 }
 405 
 406 VMUptimeDCmd::VMUptimeDCmd(outputStream* output, bool heap) :
 407                            DCmdWithParser(output, heap),
 408   _date(&quot;-date&quot;, &quot;Add a prefix with current date&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 409   _dcmdparser.add_dcmd_option(&amp;_date);
 410 }
 411 
 412 void VMUptimeDCmd::execute(DCmdSource source, TRAPS) {
 413   if (_date.value()) {
 414     output()-&gt;date_stamp(true, &quot;&quot;, &quot;: &quot;);
 415   }
 416   output()-&gt;time_stamp().update_to(tty-&gt;time_stamp().ticks());
 417   output()-&gt;stamp();
 418   output()-&gt;print_cr(&quot; s&quot;);
 419 }
 420 
 421 int VMUptimeDCmd::num_arguments() {
 422   ResourceMark rm;
 423   VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);
 424   if (dcmd != NULL) {
 425     DCmdMark mark(dcmd);
 426     return dcmd-&gt;_dcmdparser.num_arguments();
 427   } else {
 428     return 0;
 429   }
 430 }
 431 
 432 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 433   VMError::print_vm_info(_output);
 434 }
 435 
 436 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 437   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 438 }
 439 
 440 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 441   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(),
 442                                                  true, CHECK);
 443   JavaValue result(T_VOID);
 444   JavaCalls::call_static(&amp;result, k,
 445                          vmSymbols::run_finalization_name(),
 446                          vmSymbols::void_method_signature(), CHECK);
 447 }
 448 
 449 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
<a name="7" id="anc7"></a><span class="line-modified"> 450   MutexLocker hl(Heap_lock);</span>
 451   Universe::heap()-&gt;print_on(output());
 452 }
 453 
 454 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
<a name="8" id="anc8"></a><span class="line-modified"> 455   ResourceMark rm;</span>
 456 
 457   Klass* k = SystemDictionary::resolve_or_fail(
 458     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 459 
 460   JavaValue result(T_ARRAY);
 461 
 462   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 463   // and expect it to return array of FinalizerHistogramEntry as Object[]
 464 
 465   JavaCalls::call_static(&amp;result, k,
 466                          vmSymbols::get_finalizer_histogram_name(),
 467                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 468 
 469   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 470   if (result_oop-&gt;length() == 0) {
 471     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 472     return;
 473   }
 474 
 475   oop foop = result_oop-&gt;obj_at(0);
 476   InstanceKlass* ik = InstanceKlass::cast(foop-&gt;klass());
 477 
 478   fieldDescriptor count_fd, name_fd;
 479 
 480   Klass* count_res = ik-&gt;find_field(
 481     vmSymbols::finalizer_histogram_entry_count_field(), vmSymbols::int_signature(), &amp;count_fd);
 482 
 483   Klass* name_res = ik-&gt;find_field(
 484     vmSymbols::finalizer_histogram_entry_name_field(), vmSymbols::string_signature(), &amp;name_fd);
 485 
 486   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 487 
 488   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 489   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 490   output()-&gt;print_cr(&quot;-----------------------&quot;);
 491 
 492   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 493     oop element_oop = result_oop-&gt;obj_at(i);
 494     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 495     char *name = java_lang_String::as_utf8_string(str_oop);
 496     int count = element_oop-&gt;int_field(count_fd.offset());
 497     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 498   }
 499 }
 500 
 501 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 502 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 503                            DCmdWithParser(output, heap),
 504   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 505   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 506        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 507   _dcmdparser.add_dcmd_option(&amp;_all);
 508   _dcmdparser.add_dcmd_argument(&amp;_filename);
 509 }
 510 
 511 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 512   // Request a full GC before heap dump if _all is false
 513   // This helps reduces the amount of unreachable objects in the dump
 514   // and makes it easier to browse.
 515   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
<a name="9" id="anc9"></a><span class="line-modified"> 516   int res = dumper.dump(_filename.value());</span>
<span class="line-removed"> 517   if (res == 0) {</span>
<span class="line-removed"> 518     output()-&gt;print_cr(&quot;Heap dump file created&quot;);</span>
<span class="line-removed"> 519   } else {</span>
<span class="line-removed"> 520     // heap dump failed</span>
<span class="line-removed"> 521     ResourceMark rm;</span>
<span class="line-removed"> 522     char* error = dumper.error_as_C_string();</span>
<span class="line-removed"> 523     if (error == NULL) {</span>
<span class="line-removed"> 524       output()-&gt;print_cr(&quot;Dump failed - reason unknown&quot;);</span>
<span class="line-removed"> 525     } else {</span>
<span class="line-removed"> 526       output()-&gt;print_cr(&quot;%s&quot;, error);</span>
<span class="line-removed"> 527     }</span>
<span class="line-removed"> 528   }</span>
 529 }
 530 
 531 int HeapDumpDCmd::num_arguments() {
 532   ResourceMark rm;
 533   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 534   if (dcmd != NULL) {
 535     DCmdMark mark(dcmd);
 536     return dcmd-&gt;_dcmdparser.num_arguments();
 537   } else {
 538     return 0;
 539   }
 540 }
 541 
 542 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 543                                        DCmdWithParser(output, heap),
 544   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 545        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 546   _dcmdparser.add_dcmd_option(&amp;_all);
 547 }
 548 
 549 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 550   VM_GC_HeapInspection heapop(output(),
 551                               !_all.value() /* request full gc if false */);
 552   VMThread::execute(&amp;heapop);
 553 }
 554 
 555 int ClassHistogramDCmd::num_arguments() {
 556   ResourceMark rm;
 557   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 558   if (dcmd != NULL) {
 559     DCmdMark mark(dcmd);
 560     return dcmd-&gt;_dcmdparser.num_arguments();
 561   } else {
 562     return 0;
 563   }
 564 }
 565 
<a name="10" id="anc10"></a><span class="line-removed"> 566 #define DEFAULT_COLUMNS &quot;InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total&quot;</span>
<span class="line-removed"> 567 ClassStatsDCmd::ClassStatsDCmd(outputStream* output, bool heap) :</span>
<span class="line-removed"> 568                                        DCmdWithParser(output, heap),</span>
<span class="line-removed"> 569   _all(&quot;-all&quot;, &quot;Show all columns&quot;,</span>
<span class="line-removed"> 570        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 571   _csv(&quot;-csv&quot;, &quot;Print in CSV (comma-separated values) format for spreadsheets&quot;,</span>
<span class="line-removed"> 572        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 573   _help(&quot;-help&quot;, &quot;Show meaning of all the columns&quot;,</span>
<span class="line-removed"> 574        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 575   _columns(&quot;columns&quot;, &quot;Comma-separated list of all the columns to show. &quot;</span>
<span class="line-removed"> 576            &quot;If not specified, the following columns are shown: &quot; DEFAULT_COLUMNS,</span>
<span class="line-removed"> 577            &quot;STRING&quot;, false) {</span>
<span class="line-removed"> 578   _dcmdparser.add_dcmd_option(&amp;_all);</span>
<span class="line-removed"> 579   _dcmdparser.add_dcmd_option(&amp;_csv);</span>
<span class="line-removed"> 580   _dcmdparser.add_dcmd_option(&amp;_help);</span>
<span class="line-removed"> 581   _dcmdparser.add_dcmd_argument(&amp;_columns);</span>
<span class="line-removed"> 582 }</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584 void ClassStatsDCmd::execute(DCmdSource source, TRAPS) {</span>
<span class="line-removed"> 585   VM_GC_HeapInspection heapop(output(),</span>
<span class="line-removed"> 586                               true /* request_full_gc */);</span>
<span class="line-removed"> 587   heapop.set_csv_format(_csv.value());</span>
<span class="line-removed"> 588   heapop.set_print_help(_help.value());</span>
<span class="line-removed"> 589   heapop.set_print_class_stats(true);</span>
<span class="line-removed"> 590   if (_all.value()) {</span>
<span class="line-removed"> 591     if (_columns.has_value()) {</span>
<span class="line-removed"> 592       output()-&gt;print_cr(&quot;Cannot specify -all and individual columns at the same time&quot;);</span>
<span class="line-removed"> 593       return;</span>
<span class="line-removed"> 594     } else {</span>
<span class="line-removed"> 595       heapop.set_columns(NULL);</span>
<span class="line-removed"> 596     }</span>
<span class="line-removed"> 597   } else {</span>
<span class="line-removed"> 598     if (_columns.has_value()) {</span>
<span class="line-removed"> 599       heapop.set_columns(_columns.value());</span>
<span class="line-removed"> 600     } else {</span>
<span class="line-removed"> 601       heapop.set_columns(DEFAULT_COLUMNS);</span>
<span class="line-removed"> 602     }</span>
<span class="line-removed"> 603   }</span>
<span class="line-removed"> 604   VMThread::execute(&amp;heapop);</span>
<span class="line-removed"> 605 }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607 int ClassStatsDCmd::num_arguments() {</span>
<span class="line-removed"> 608   ResourceMark rm;</span>
<span class="line-removed"> 609   ClassStatsDCmd* dcmd = new ClassStatsDCmd(NULL, false);</span>
<span class="line-removed"> 610   if (dcmd != NULL) {</span>
<span class="line-removed"> 611     DCmdMark mark(dcmd);</span>
<span class="line-removed"> 612     return dcmd-&gt;_dcmdparser.num_arguments();</span>
<span class="line-removed"> 613   } else {</span>
<span class="line-removed"> 614     return 0;</span>
<span class="line-removed"> 615   }</span>
<span class="line-removed"> 616 }</span>
 617 #endif // INCLUDE_SERVICES
 618 
 619 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 620                                DCmdWithParser(output, heap),
 621   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 622   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 623   _dcmdparser.add_dcmd_option(&amp;_locks);
 624   _dcmdparser.add_dcmd_option(&amp;_extended);
 625 }
 626 
 627 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 628   // thread stacks
 629   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 630   VMThread::execute(&amp;op1);
 631 
 632   // JNI global handles
 633   VM_PrintJNI op2(output());
 634   VMThread::execute(&amp;op2);
 635 
 636   // Deadlock detection
 637   VM_FindDeadlocks op3(output());
 638   VMThread::execute(&amp;op3);
 639 }
 640 
 641 int ThreadDumpDCmd::num_arguments() {
 642   ResourceMark rm;
 643   ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);
 644   if (dcmd != NULL) {
 645     DCmdMark mark(dcmd);
 646     return dcmd-&gt;_dcmdparser.num_arguments();
 647   } else {
 648     return 0;
 649   }
 650 }
 651 
 652 // Enhanced JMX Agent support
 653 
 654 JMXStartRemoteDCmd::JMXStartRemoteDCmd(outputStream *output, bool heap_allocated) :
 655 
 656   DCmdWithParser(output, heap_allocated),
 657 
 658   _config_file
 659   (&quot;config.file&quot;,
 660    &quot;set com.sun.management.config.file&quot;, &quot;STRING&quot;, false),
 661 
 662   _jmxremote_host
 663   (&quot;jmxremote.host&quot;,
 664    &quot;set com.sun.management.jmxremote.host&quot;, &quot;STRING&quot;, false),
 665 
 666   _jmxremote_port
 667   (&quot;jmxremote.port&quot;,
 668    &quot;set com.sun.management.jmxremote.port&quot;, &quot;STRING&quot;, false),
 669 
 670   _jmxremote_rmi_port
 671   (&quot;jmxremote.rmi.port&quot;,
 672    &quot;set com.sun.management.jmxremote.rmi.port&quot;, &quot;STRING&quot;, false),
 673 
 674   _jmxremote_ssl
 675   (&quot;jmxremote.ssl&quot;,
 676    &quot;set com.sun.management.jmxremote.ssl&quot;, &quot;STRING&quot;, false),
 677 
 678   _jmxremote_registry_ssl
 679   (&quot;jmxremote.registry.ssl&quot;,
 680    &quot;set com.sun.management.jmxremote.registry.ssl&quot;, &quot;STRING&quot;, false),
 681 
 682   _jmxremote_authenticate
 683   (&quot;jmxremote.authenticate&quot;,
 684    &quot;set com.sun.management.jmxremote.authenticate&quot;, &quot;STRING&quot;, false),
 685 
 686   _jmxremote_password_file
 687   (&quot;jmxremote.password.file&quot;,
 688    &quot;set com.sun.management.jmxremote.password.file&quot;, &quot;STRING&quot;, false),
 689 
 690   _jmxremote_access_file
 691   (&quot;jmxremote.access.file&quot;,
 692    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 693 
 694   _jmxremote_login_config
 695   (&quot;jmxremote.login.config&quot;,
 696    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 697 
 698   _jmxremote_ssl_enabled_cipher_suites
 699   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 700    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 701 
 702   _jmxremote_ssl_enabled_protocols
 703   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 704    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 705 
 706   _jmxremote_ssl_need_client_auth
 707   (&quot;jmxremote.ssl.need.client.auth&quot;,
 708    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 709 
 710   _jmxremote_ssl_config_file
 711   (&quot;jmxremote.ssl.config.file&quot;,
<a name="11" id="anc11"></a><span class="line-modified"> 712    &quot;set com.sun.management.jmxremote.ssl_config_file&quot;, &quot;STRING&quot;, false),</span>
 713 
 714 // JDP Protocol support
 715   _jmxremote_autodiscovery
 716   (&quot;jmxremote.autodiscovery&quot;,
 717    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 718 
 719    _jdp_port
 720   (&quot;jdp.port&quot;,
 721    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 722 
 723    _jdp_address
 724   (&quot;jdp.address&quot;,
 725    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 726 
 727    _jdp_source_addr
 728   (&quot;jdp.source_addr&quot;,
 729    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 730 
 731    _jdp_ttl
 732   (&quot;jdp.ttl&quot;,
 733    &quot;set com.sun.management.jdp.ttl&quot;, &quot;INT&quot;, false),
 734 
 735    _jdp_pause
 736   (&quot;jdp.pause&quot;,
 737    &quot;set com.sun.management.jdp.pause&quot;, &quot;INT&quot;, false),
 738 
 739    _jdp_name
 740   (&quot;jdp.name&quot;,
 741    &quot;set com.sun.management.jdp.name&quot;, &quot;STRING&quot;, false)
 742 
 743   {
 744     _dcmdparser.add_dcmd_option(&amp;_config_file);
 745     _dcmdparser.add_dcmd_option(&amp;_jmxremote_host);
 746     _dcmdparser.add_dcmd_option(&amp;_jmxremote_port);
 747     _dcmdparser.add_dcmd_option(&amp;_jmxremote_rmi_port);
 748     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl);
 749     _dcmdparser.add_dcmd_option(&amp;_jmxremote_registry_ssl);
 750     _dcmdparser.add_dcmd_option(&amp;_jmxremote_authenticate);
 751     _dcmdparser.add_dcmd_option(&amp;_jmxremote_password_file);
 752     _dcmdparser.add_dcmd_option(&amp;_jmxremote_access_file);
 753     _dcmdparser.add_dcmd_option(&amp;_jmxremote_login_config);
 754     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_cipher_suites);
 755     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_protocols);
 756     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_need_client_auth);
 757     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_config_file);
 758     _dcmdparser.add_dcmd_option(&amp;_jmxremote_autodiscovery);
 759     _dcmdparser.add_dcmd_option(&amp;_jdp_port);
 760     _dcmdparser.add_dcmd_option(&amp;_jdp_address);
 761     _dcmdparser.add_dcmd_option(&amp;_jdp_source_addr);
 762     _dcmdparser.add_dcmd_option(&amp;_jdp_ttl);
 763     _dcmdparser.add_dcmd_option(&amp;_jdp_pause);
 764     _dcmdparser.add_dcmd_option(&amp;_jdp_name);
 765 }
 766 
 767 
 768 int JMXStartRemoteDCmd::num_arguments() {
 769   ResourceMark rm;
 770   JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);
 771   if (dcmd != NULL) {
 772     DCmdMark mark(dcmd);
 773     return dcmd-&gt;_dcmdparser.num_arguments();
 774   } else {
 775     return 0;
 776   }
 777 }
 778 
 779 
 780 void JMXStartRemoteDCmd::execute(DCmdSource source, TRAPS) {
 781     ResourceMark rm(THREAD);
 782     HandleMark hm(THREAD);
 783 
 784     // Load and initialize the jdk.internal.agent.Agent class
 785     // invoke startRemoteManagementAgent(string) method to start
 786     // the remote management server.
 787     // throw java.lang.NoSuchMethodError if the method doesn&#39;t exist
 788 
 789     loadAgentModule(CHECK);
 790     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 791     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 792 
 793     JavaValue result(T_VOID);
 794 
 795     // Pass all command line arguments to java as key=value,...
 796     // All checks are done on java side
 797 
 798     int len = 0;
 799     stringStream options;
 800     char comma[2] = {0,0};
 801 
 802     // Leave default values on Agent.class side and pass only
 803     // agruments explicitly set by user. All arguments passed
 804     // to jcmd override properties with the same name set by
 805     // command line with -D or by managmenent.properties
 806     // file.
 807 #define PUT_OPTION(a) \
 808     do { \
 809         if ( (a).is_set() ){ \
 810             if ( *((a).type()) == &#39;I&#39; ) { \
 811                 options.print(&quot;%scom.sun.management.%s=&quot; JLONG_FORMAT, comma, (a).name(), (jlong)((a).value())); \
 812             } else { \
 813                 options.print(&quot;%scom.sun.management.%s=%s&quot;, comma, (a).name(), (char*)((a).value())); \
 814             } \
 815             comma[0] = &#39;,&#39;; \
 816         }\
 817     } while(0);
 818 
 819 
 820     PUT_OPTION(_config_file);
 821     PUT_OPTION(_jmxremote_host);
 822     PUT_OPTION(_jmxremote_port);
 823     PUT_OPTION(_jmxremote_rmi_port);
 824     PUT_OPTION(_jmxremote_ssl);
 825     PUT_OPTION(_jmxremote_registry_ssl);
 826     PUT_OPTION(_jmxremote_authenticate);
 827     PUT_OPTION(_jmxremote_password_file);
 828     PUT_OPTION(_jmxremote_access_file);
 829     PUT_OPTION(_jmxremote_login_config);
 830     PUT_OPTION(_jmxremote_ssl_enabled_cipher_suites);
 831     PUT_OPTION(_jmxremote_ssl_enabled_protocols);
 832     PUT_OPTION(_jmxremote_ssl_need_client_auth);
 833     PUT_OPTION(_jmxremote_ssl_config_file);
 834     PUT_OPTION(_jmxremote_autodiscovery);
 835     PUT_OPTION(_jdp_port);
 836     PUT_OPTION(_jdp_address);
 837     PUT_OPTION(_jdp_source_addr);
 838     PUT_OPTION(_jdp_ttl);
 839     PUT_OPTION(_jdp_pause);
 840     PUT_OPTION(_jdp_name);
 841 
 842 #undef PUT_OPTION
 843 
 844     Handle str = java_lang_String::create_from_str(options.as_string(), CHECK);
 845     JavaCalls::call_static(&amp;result, k, vmSymbols::startRemoteAgent_name(), vmSymbols::string_void_signature(), str, CHECK);
 846 }
 847 
 848 JMXStartLocalDCmd::JMXStartLocalDCmd(outputStream *output, bool heap_allocated) :
 849   DCmd(output, heap_allocated) {
 850   // do nothing
 851 }
 852 
 853 void JMXStartLocalDCmd::execute(DCmdSource source, TRAPS) {
 854     ResourceMark rm(THREAD);
 855     HandleMark hm(THREAD);
 856 
 857     // Load and initialize the jdk.internal.agent.Agent class
 858     // invoke startLocalManagementAgent(void) method to start
 859     // the local management server
 860     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 861 
 862     loadAgentModule(CHECK);
 863     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 864     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 865 
 866     JavaValue result(T_VOID);
 867     JavaCalls::call_static(&amp;result, k, vmSymbols::startLocalAgent_name(), vmSymbols::void_method_signature(), CHECK);
 868 }
 869 
 870 void JMXStopRemoteDCmd::execute(DCmdSource source, TRAPS) {
 871     ResourceMark rm(THREAD);
 872     HandleMark hm(THREAD);
 873 
 874     // Load and initialize the jdk.internal.agent.Agent class
 875     // invoke stopRemoteManagementAgent method to stop the
 876     // management server
 877     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 878 
 879     loadAgentModule(CHECK);
 880     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 881     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 882 
 883     JavaValue result(T_VOID);
 884     JavaCalls::call_static(&amp;result, k, vmSymbols::stopRemoteAgent_name(), vmSymbols::void_method_signature(), CHECK);
 885 }
 886 
 887 JMXStatusDCmd::JMXStatusDCmd(outputStream *output, bool heap_allocated) :
 888   DCmd(output, heap_allocated) {
 889   // do nothing
 890 }
 891 
 892 void JMXStatusDCmd::execute(DCmdSource source, TRAPS) {
 893   ResourceMark rm(THREAD);
 894   HandleMark hm(THREAD);
 895 
 896   // Load and initialize the jdk.internal.agent.Agent class
 897   // invoke getManagementAgentStatus() method to generate the status info
 898   // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 899 
 900   loadAgentModule(CHECK);
 901   Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 902   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 903 
 904   JavaValue result(T_OBJECT);
 905   JavaCalls::call_static(&amp;result, k, vmSymbols::getAgentStatus_name(), vmSymbols::void_string_signature(), CHECK);
 906 
 907   jvalue* jv = (jvalue*) result.get_value_addr();
 908   oop str = (oop) jv-&gt;l;
 909   if (str != NULL) {
 910       char* out = java_lang_String::as_utf8_string(str);
 911       if (out) {
 912           output()-&gt;print_cr(&quot;%s&quot;, out);
 913           return;
 914       }
 915   }
 916   output()-&gt;print_cr(&quot;Error obtaining management agent status&quot;);
 917 }
 918 
 919 VMDynamicLibrariesDCmd::VMDynamicLibrariesDCmd(outputStream *output, bool heap_allocated) :
 920   DCmd(output, heap_allocated) {
 921   // do nothing
 922 }
 923 
 924 void VMDynamicLibrariesDCmd::execute(DCmdSource source, TRAPS) {
 925   os::print_dll_info(output());
 926   output()-&gt;cr();
 927 }
 928 
 929 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 930   VM_PrintCompileQueue printCompileQueueOp(output());
 931   VMThread::execute(&amp;printCompileQueueOp);
 932 }
 933 
 934 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 935   CodeCache::print_codelist(output());
 936 }
 937 
 938 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 939   CodeCache::print_layout(output());
 940 }
 941 
 942 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 943 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 944                                              DCmdWithParser(output, heap),
 945   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
<a name="12" id="anc12"></a><span class="line-modified"> 946   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;STRING&quot;, false, &quot;4096&quot;) {</span>
 947   _dcmdparser.add_dcmd_argument(&amp;_function);
 948   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 949 }
 950 
 951 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
<a name="13" id="anc13"></a><span class="line-modified"> 952   CompileBroker::print_heapinfo(output(), _function.value(), _granularity.value());</span>







 953 }
 954 
 955 int CodeHeapAnalyticsDCmd::num_arguments() {
 956   ResourceMark rm;
 957   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 958   if (dcmd != NULL) {
 959     DCmdMark mark(dcmd);
 960     return dcmd-&gt;_dcmdparser.num_arguments();
 961   } else {
 962     return 0;
 963   }
 964 }
 965 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 966 
<a name="14" id="anc14"></a>






































 967 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 968   DirectivesStack::print(output());
 969 }
 970 
 971 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 972                            DCmdWithParser(output, heap),
 973   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 974   _dcmdparser.add_dcmd_argument(&amp;_filename);
 975 }
 976 
 977 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 978   DirectivesParser::parse_from_file(_filename.value(), output());
 979 }
 980 
 981 int CompilerDirectivesAddDCmd::num_arguments() {
 982   ResourceMark rm;
 983   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 984   if (dcmd != NULL) {
 985     DCmdMark mark(dcmd);
 986     return dcmd-&gt;_dcmdparser.num_arguments();
 987   } else {
 988     return 0;
 989   }
 990 }
 991 
 992 void CompilerDirectivesRemoveDCmd::execute(DCmdSource source, TRAPS) {
 993   DirectivesStack::pop(1);
 994 }
 995 
 996 void CompilerDirectivesClearDCmd::execute(DCmdSource source, TRAPS) {
 997   DirectivesStack::clear();
 998 }
 999 #if INCLUDE_SERVICES
1000 ClassHierarchyDCmd::ClassHierarchyDCmd(outputStream* output, bool heap) :
1001                                        DCmdWithParser(output, heap),
1002   _print_interfaces(&quot;-i&quot;, &quot;Inherited interfaces should be printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1003   _print_subclasses(&quot;-s&quot;, &quot;If a classname is specified, print its subclasses. &quot;
1004                     &quot;Otherwise only its superclasses are printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1005   _classname(&quot;classname&quot;, &quot;Name of class whose hierarchy should be printed. &quot;
1006              &quot;If not specified, all class hierarchies are printed.&quot;,
1007              &quot;STRING&quot;, false) {
1008   _dcmdparser.add_dcmd_option(&amp;_print_interfaces);
1009   _dcmdparser.add_dcmd_option(&amp;_print_subclasses);
1010   _dcmdparser.add_dcmd_argument(&amp;_classname);
1011 }
1012 
1013 void ClassHierarchyDCmd::execute(DCmdSource source, TRAPS) {
1014   VM_PrintClassHierarchy printClassHierarchyOp(output(), _print_interfaces.value(),
1015                                                _print_subclasses.value(), _classname.value());
1016   VMThread::execute(&amp;printClassHierarchyOp);
1017 }
1018 
1019 int ClassHierarchyDCmd::num_arguments() {
1020   ResourceMark rm;
1021   ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);
1022   if (dcmd != NULL) {
1023     DCmdMark mark(dcmd);
1024     return dcmd-&gt;_dcmdparser.num_arguments();
1025   } else {
1026     return 0;
1027   }
1028 }
1029 
1030 #endif
1031 
1032 class VM_DumpTouchedMethods : public VM_Operation {
1033 private:
1034   outputStream* _out;
1035 public:
1036   VM_DumpTouchedMethods(outputStream* out) {
1037     _out = out;
1038   }
1039 
1040   virtual VMOp_Type type() const { return VMOp_DumpTouchedMethods; }
1041 
1042   virtual void doit() {
1043     Method::print_touched_methods(_out);
1044   }
1045 };
1046 
1047 TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :
1048                                        DCmdWithParser(output, heap)
1049 {}
1050 
1051 void TouchedMethodsDCmd::execute(DCmdSource source, TRAPS) {
1052   if (!LogTouchedMethods) {
1053     output()-&gt;print_cr(&quot;VM.print_touched_methods command requires -XX:+LogTouchedMethods&quot;);
1054     return;
1055   }
1056   VM_DumpTouchedMethods dumper(output());
1057   VMThread::execute(&amp;dumper);
1058 }
1059 
1060 int TouchedMethodsDCmd::num_arguments() {
1061   return 0;
1062 }
1063 
1064 #if INCLUDE_JVMTI
1065 extern &quot;C&quot; typedef char const* (JNICALL *debugInit_startDebuggingViaCommandPtr)(JNIEnv* env, jthread thread, char const** transport_name,
1066                                                                                 char const** address, jboolean* first_start);
1067 static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = NULL;
1068 
1069 DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {
1070 }
1071 
1072 void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
1073   char const* transport = NULL;
1074   char const* addr = NULL;
1075   jboolean is_first_start = JNI_FALSE;
1076   JavaThread* thread = (JavaThread*) THREAD;
1077   jthread jt = JNIHandles::make_local(thread-&gt;threadObj());
1078   ThreadToNativeFromVM ttn(thread);
1079   const char *error = &quot;Could not find jdwp agent.&quot;;
1080 
1081   if (!dvc_start_ptr) {
1082     for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
1083       if ((strcmp(&quot;jdwp&quot;, agent-&gt;name()) == 0) &amp;&amp; (dvc_start_ptr == NULL)) {
1084         char const* func = &quot;debugInit_startDebuggingViaCommand&quot;;
1085         dvc_start_ptr = (debugInit_startDebuggingViaCommandPtr) os::find_agent_function(agent, false, &amp;func, 1);
1086       }
1087     }
1088   }
1089 
1090   if (dvc_start_ptr) {
1091     error = dvc_start_ptr(thread-&gt;jni_environment(), jt, &amp;transport, &amp;addr, &amp;is_first_start);
1092   }
1093 
1094   if (error != NULL) {
1095     output()-&gt;print_cr(&quot;Debugging has not been started: %s&quot;, error);
1096   } else {
1097     output()-&gt;print_cr(is_first_start ? &quot;Debugging has been started.&quot; : &quot;Debugging is already active.&quot;);
1098     output()-&gt;print_cr(&quot;Transport : %s&quot;, transport ? transport : &quot;#unknown&quot;);
1099     output()-&gt;print_cr(&quot;Address : %s&quot;, addr ? addr : &quot;#unknown&quot;);
1100   }
1101 }
1102 #endif // INCLUDE_JVMTI
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
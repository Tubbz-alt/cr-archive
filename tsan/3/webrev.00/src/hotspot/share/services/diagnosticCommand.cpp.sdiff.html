<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="diagnosticArgument.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="diagnosticCommand.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/diagnosticCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;compiler/directivesParser.hpp&quot;
  31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  32 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;

  34 #include &quot;oops/objArrayOop.inline.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  37 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  38 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/javaCalls.hpp&quot;
  42 #include &quot;runtime/os.hpp&quot;
  43 #include &quot;services/diagnosticArgument.hpp&quot;
  44 #include &quot;services/diagnosticCommand.hpp&quot;
  45 #include &quot;services/diagnosticFramework.hpp&quot;
  46 #include &quot;services/heapDumper.hpp&quot;
  47 #include &quot;services/management.hpp&quot;
  48 #include &quot;services/writeableFlags.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;

  50 #include &quot;utilities/formatBuffer.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 
  53 
  54 static void loadAgentModule(TRAPS) {
  55   ResourceMark rm(THREAD);
  56   HandleMark hm(THREAD);
  57 
  58   JavaValue result(T_OBJECT);
  59   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  60   JavaCalls::call_static(&amp;result,
  61                          SystemDictionary::module_Modules_klass(),
  62                          vmSymbols::loadModule_name(),
  63                          vmSymbols::loadModule_signature(),
  64                          h_module_name,
  65                          THREAD);
  66 }
  67 
  68 void DCmdRegistrant::register_dcmds(){
  69   // Registration of the diagnostic commands
</pre>
<hr />
<pre>
  71   // Second argument specifies if the command is enabled
  72   // Third  argument specifies if the command is hidden
  73   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  74                          | DCmd_Source_MBean;
  75   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  76   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  77   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  88 #if INCLUDE_SERVICES
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  90   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));
<span class="line-removed">  91   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassStatsDCmd&gt;(full_export, true, false));</span>
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));

  97 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
  99 #endif // INCLUDE_JVMTI
 100 #endif // INCLUDE_SERVICES
 101 #if INCLUDE_JVMTI
 102   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 103 #endif // INCLUDE_JVMTI
 104   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 105   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 106   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 107   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 112 
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 114   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 115   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 116   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 117 
 118   // Enhanced JMX Agent Support
 119   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 120   // appropriate permission is created for them
 121   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 122   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 123   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 124   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 125   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 126 
 127   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 128 #if INCLUDE_JVMTI
<span class="line-modified"> 129   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, false));</span>
 130 #endif // INCLUDE_JVMTI
 131 
 132 }
 133 
 134 #ifndef HAVE_EXTRA_DCMD
 135 void DCmdRegistrant::register_dcmds_ext(){
 136    // Do nothing here
 137 }
 138 #endif
 139 
 140 
 141 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 142   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 143   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 144         &quot;STRING&quot;, false) {
 145   _dcmdparser.add_dcmd_option(&amp;_all);
 146   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 147 };
 148 
 149 
</pre>
<hr />
<pre>
 430 }
 431 
 432 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 433   VMError::print_vm_info(_output);
 434 }
 435 
 436 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 437   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 438 }
 439 
 440 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 441   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(),
 442                                                  true, CHECK);
 443   JavaValue result(T_VOID);
 444   JavaCalls::call_static(&amp;result, k,
 445                          vmSymbols::run_finalization_name(),
 446                          vmSymbols::void_method_signature(), CHECK);
 447 }
 448 
 449 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 450   MutexLocker hl(Heap_lock);</span>
 451   Universe::heap()-&gt;print_on(output());
 452 }
 453 
 454 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 455   ResourceMark rm;</span>
 456 
 457   Klass* k = SystemDictionary::resolve_or_fail(
 458     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 459 
 460   JavaValue result(T_ARRAY);
 461 
 462   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 463   // and expect it to return array of FinalizerHistogramEntry as Object[]
 464 
 465   JavaCalls::call_static(&amp;result, k,
 466                          vmSymbols::get_finalizer_histogram_name(),
 467                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 468 
 469   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 470   if (result_oop-&gt;length() == 0) {
 471     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 472     return;
 473   }
 474 
 475   oop foop = result_oop-&gt;obj_at(0);
</pre>
<hr />
<pre>
 496     int count = element_oop-&gt;int_field(count_fd.offset());
 497     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 498   }
 499 }
 500 
 501 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 502 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 503                            DCmdWithParser(output, heap),
 504   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 505   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 506        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 507   _dcmdparser.add_dcmd_option(&amp;_all);
 508   _dcmdparser.add_dcmd_argument(&amp;_filename);
 509 }
 510 
 511 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 512   // Request a full GC before heap dump if _all is false
 513   // This helps reduces the amount of unreachable objects in the dump
 514   // and makes it easier to browse.
 515   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
<span class="line-modified"> 516   int res = dumper.dump(_filename.value());</span>
<span class="line-removed"> 517   if (res == 0) {</span>
<span class="line-removed"> 518     output()-&gt;print_cr(&quot;Heap dump file created&quot;);</span>
<span class="line-removed"> 519   } else {</span>
<span class="line-removed"> 520     // heap dump failed</span>
<span class="line-removed"> 521     ResourceMark rm;</span>
<span class="line-removed"> 522     char* error = dumper.error_as_C_string();</span>
<span class="line-removed"> 523     if (error == NULL) {</span>
<span class="line-removed"> 524       output()-&gt;print_cr(&quot;Dump failed - reason unknown&quot;);</span>
<span class="line-removed"> 525     } else {</span>
<span class="line-removed"> 526       output()-&gt;print_cr(&quot;%s&quot;, error);</span>
<span class="line-removed"> 527     }</span>
<span class="line-removed"> 528   }</span>
 529 }
 530 
 531 int HeapDumpDCmd::num_arguments() {
 532   ResourceMark rm;
 533   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 534   if (dcmd != NULL) {
 535     DCmdMark mark(dcmd);
 536     return dcmd-&gt;_dcmdparser.num_arguments();
 537   } else {
 538     return 0;
 539   }
 540 }
 541 
 542 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 543                                        DCmdWithParser(output, heap),
 544   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 545        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 546   _dcmdparser.add_dcmd_option(&amp;_all);
 547 }
 548 
 549 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 550   VM_GC_HeapInspection heapop(output(),
 551                               !_all.value() /* request full gc if false */);
 552   VMThread::execute(&amp;heapop);
 553 }
 554 
 555 int ClassHistogramDCmd::num_arguments() {
 556   ResourceMark rm;
 557   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 558   if (dcmd != NULL) {
 559     DCmdMark mark(dcmd);
 560     return dcmd-&gt;_dcmdparser.num_arguments();
 561   } else {
 562     return 0;
 563   }
 564 }
 565 
<span class="line-removed"> 566 #define DEFAULT_COLUMNS &quot;InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total&quot;</span>
<span class="line-removed"> 567 ClassStatsDCmd::ClassStatsDCmd(outputStream* output, bool heap) :</span>
<span class="line-removed"> 568                                        DCmdWithParser(output, heap),</span>
<span class="line-removed"> 569   _all(&quot;-all&quot;, &quot;Show all columns&quot;,</span>
<span class="line-removed"> 570        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 571   _csv(&quot;-csv&quot;, &quot;Print in CSV (comma-separated values) format for spreadsheets&quot;,</span>
<span class="line-removed"> 572        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 573   _help(&quot;-help&quot;, &quot;Show meaning of all the columns&quot;,</span>
<span class="line-removed"> 574        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-removed"> 575   _columns(&quot;columns&quot;, &quot;Comma-separated list of all the columns to show. &quot;</span>
<span class="line-removed"> 576            &quot;If not specified, the following columns are shown: &quot; DEFAULT_COLUMNS,</span>
<span class="line-removed"> 577            &quot;STRING&quot;, false) {</span>
<span class="line-removed"> 578   _dcmdparser.add_dcmd_option(&amp;_all);</span>
<span class="line-removed"> 579   _dcmdparser.add_dcmd_option(&amp;_csv);</span>
<span class="line-removed"> 580   _dcmdparser.add_dcmd_option(&amp;_help);</span>
<span class="line-removed"> 581   _dcmdparser.add_dcmd_argument(&amp;_columns);</span>
<span class="line-removed"> 582 }</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584 void ClassStatsDCmd::execute(DCmdSource source, TRAPS) {</span>
<span class="line-removed"> 585   VM_GC_HeapInspection heapop(output(),</span>
<span class="line-removed"> 586                               true /* request_full_gc */);</span>
<span class="line-removed"> 587   heapop.set_csv_format(_csv.value());</span>
<span class="line-removed"> 588   heapop.set_print_help(_help.value());</span>
<span class="line-removed"> 589   heapop.set_print_class_stats(true);</span>
<span class="line-removed"> 590   if (_all.value()) {</span>
<span class="line-removed"> 591     if (_columns.has_value()) {</span>
<span class="line-removed"> 592       output()-&gt;print_cr(&quot;Cannot specify -all and individual columns at the same time&quot;);</span>
<span class="line-removed"> 593       return;</span>
<span class="line-removed"> 594     } else {</span>
<span class="line-removed"> 595       heapop.set_columns(NULL);</span>
<span class="line-removed"> 596     }</span>
<span class="line-removed"> 597   } else {</span>
<span class="line-removed"> 598     if (_columns.has_value()) {</span>
<span class="line-removed"> 599       heapop.set_columns(_columns.value());</span>
<span class="line-removed"> 600     } else {</span>
<span class="line-removed"> 601       heapop.set_columns(DEFAULT_COLUMNS);</span>
<span class="line-removed"> 602     }</span>
<span class="line-removed"> 603   }</span>
<span class="line-removed"> 604   VMThread::execute(&amp;heapop);</span>
<span class="line-removed"> 605 }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607 int ClassStatsDCmd::num_arguments() {</span>
<span class="line-removed"> 608   ResourceMark rm;</span>
<span class="line-removed"> 609   ClassStatsDCmd* dcmd = new ClassStatsDCmd(NULL, false);</span>
<span class="line-removed"> 610   if (dcmd != NULL) {</span>
<span class="line-removed"> 611     DCmdMark mark(dcmd);</span>
<span class="line-removed"> 612     return dcmd-&gt;_dcmdparser.num_arguments();</span>
<span class="line-removed"> 613   } else {</span>
<span class="line-removed"> 614     return 0;</span>
<span class="line-removed"> 615   }</span>
<span class="line-removed"> 616 }</span>
 617 #endif // INCLUDE_SERVICES
 618 
 619 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 620                                DCmdWithParser(output, heap),
 621   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 622   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 623   _dcmdparser.add_dcmd_option(&amp;_locks);
 624   _dcmdparser.add_dcmd_option(&amp;_extended);
 625 }
 626 
 627 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 628   // thread stacks
 629   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 630   VMThread::execute(&amp;op1);
 631 
 632   // JNI global handles
 633   VM_PrintJNI op2(output());
 634   VMThread::execute(&amp;op2);
 635 
 636   // Deadlock detection
</pre>
<hr />
<pre>
 692    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 693 
 694   _jmxremote_login_config
 695   (&quot;jmxremote.login.config&quot;,
 696    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 697 
 698   _jmxremote_ssl_enabled_cipher_suites
 699   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 700    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 701 
 702   _jmxremote_ssl_enabled_protocols
 703   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 704    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 705 
 706   _jmxremote_ssl_need_client_auth
 707   (&quot;jmxremote.ssl.need.client.auth&quot;,
 708    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 709 
 710   _jmxremote_ssl_config_file
 711   (&quot;jmxremote.ssl.config.file&quot;,
<span class="line-modified"> 712    &quot;set com.sun.management.jmxremote.ssl_config_file&quot;, &quot;STRING&quot;, false),</span>
 713 
 714 // JDP Protocol support
 715   _jmxremote_autodiscovery
 716   (&quot;jmxremote.autodiscovery&quot;,
 717    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 718 
 719    _jdp_port
 720   (&quot;jdp.port&quot;,
 721    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 722 
 723    _jdp_address
 724   (&quot;jdp.address&quot;,
 725    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 726 
 727    _jdp_source_addr
 728   (&quot;jdp.source_addr&quot;,
 729    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 730 
 731    _jdp_ttl
 732   (&quot;jdp.ttl&quot;,
</pre>
<hr />
<pre>
 926   output()-&gt;cr();
 927 }
 928 
 929 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 930   VM_PrintCompileQueue printCompileQueueOp(output());
 931   VMThread::execute(&amp;printCompileQueueOp);
 932 }
 933 
 934 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 935   CodeCache::print_codelist(output());
 936 }
 937 
 938 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 939   CodeCache::print_layout(output());
 940 }
 941 
 942 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 943 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 944                                              DCmdWithParser(output, heap),
 945   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
<span class="line-modified"> 946   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;STRING&quot;, false, &quot;4096&quot;) {</span>
 947   _dcmdparser.add_dcmd_argument(&amp;_function);
 948   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 949 }
 950 
 951 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 952   CompileBroker::print_heapinfo(output(), _function.value(), _granularity.value());</span>







 953 }
 954 
 955 int CodeHeapAnalyticsDCmd::num_arguments() {
 956   ResourceMark rm;
 957   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 958   if (dcmd != NULL) {
 959     DCmdMark mark(dcmd);
 960     return dcmd-&gt;_dcmdparser.num_arguments();
 961   } else {
 962     return 0;
 963   }
 964 }
 965 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 966 







































 967 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 968   DirectivesStack::print(output());
 969 }
 970 
 971 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 972                            DCmdWithParser(output, heap),
 973   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 974   _dcmdparser.add_dcmd_argument(&amp;_filename);
 975 }
 976 
 977 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 978   DirectivesParser::parse_from_file(_filename.value(), output());
 979 }
 980 
 981 int CompilerDirectivesAddDCmd::num_arguments() {
 982   ResourceMark rm;
 983   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 984   if (dcmd != NULL) {
 985     DCmdMark mark(dcmd);
 986     return dcmd-&gt;_dcmdparser.num_arguments();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;compiler/directivesParser.hpp&quot;
  31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  32 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  34 #include &quot;memory/universe.hpp&quot;</span>
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  39 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  40 #include &quot;runtime/handles.inline.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/javaCalls.hpp&quot;
  43 #include &quot;runtime/os.hpp&quot;
  44 #include &quot;services/diagnosticArgument.hpp&quot;
  45 #include &quot;services/diagnosticCommand.hpp&quot;
  46 #include &quot;services/diagnosticFramework.hpp&quot;
  47 #include &quot;services/heapDumper.hpp&quot;
  48 #include &quot;services/management.hpp&quot;
  49 #include &quot;services/writeableFlags.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
<span class="line-added">  51 #include &quot;utilities/events.hpp&quot;</span>
  52 #include &quot;utilities/formatBuffer.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 
  55 
  56 static void loadAgentModule(TRAPS) {
  57   ResourceMark rm(THREAD);
  58   HandleMark hm(THREAD);
  59 
  60   JavaValue result(T_OBJECT);
  61   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  62   JavaCalls::call_static(&amp;result,
  63                          SystemDictionary::module_Modules_klass(),
  64                          vmSymbols::loadModule_name(),
  65                          vmSymbols::loadModule_signature(),
  66                          h_module_name,
  67                          THREAD);
  68 }
  69 
  70 void DCmdRegistrant::register_dcmds(){
  71   // Registration of the diagnostic commands
</pre>
<hr />
<pre>
  73   // Second argument specifies if the command is enabled
  74   // Third  argument specifies if the command is hidden
  75   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  76                          | DCmd_Source_MBean;
  77   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  88   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  90 #if INCLUDE_SERVICES
  91   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));

  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  97   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));
<span class="line-added">  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;EventLogDCmd&gt;(full_export, true, false));</span>
  99 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
 100   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
 101 #endif // INCLUDE_JVMTI
 102 #endif // INCLUDE_SERVICES
 103 #if INCLUDE_JVMTI
 104   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 105 #endif // INCLUDE_JVMTI
 106   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 107   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 112   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 114 
 115   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 116   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 117   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 118   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 119 
 120   // Enhanced JMX Agent Support
 121   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 122   // appropriate permission is created for them
 123   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 124   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 125   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 126   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 127   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 128 
 129   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 130 #if INCLUDE_JVMTI
<span class="line-modified"> 131   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, true));</span>
 132 #endif // INCLUDE_JVMTI
 133 
 134 }
 135 
 136 #ifndef HAVE_EXTRA_DCMD
 137 void DCmdRegistrant::register_dcmds_ext(){
 138    // Do nothing here
 139 }
 140 #endif
 141 
 142 
 143 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 144   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 145   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 146         &quot;STRING&quot;, false) {
 147   _dcmdparser.add_dcmd_option(&amp;_all);
 148   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 149 };
 150 
 151 
</pre>
<hr />
<pre>
 432 }
 433 
 434 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 435   VMError::print_vm_info(_output);
 436 }
 437 
 438 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 439   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 440 }
 441 
 442 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 443   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(),
 444                                                  true, CHECK);
 445   JavaValue result(T_VOID);
 446   JavaCalls::call_static(&amp;result, k,
 447                          vmSymbols::run_finalization_name(),
 448                          vmSymbols::void_method_signature(), CHECK);
 449 }
 450 
 451 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 452   MutexLocker hl(THREAD, Heap_lock);</span>
 453   Universe::heap()-&gt;print_on(output());
 454 }
 455 
 456 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 457   ResourceMark rm(THREAD);</span>
 458 
 459   Klass* k = SystemDictionary::resolve_or_fail(
 460     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 461 
 462   JavaValue result(T_ARRAY);
 463 
 464   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 465   // and expect it to return array of FinalizerHistogramEntry as Object[]
 466 
 467   JavaCalls::call_static(&amp;result, k,
 468                          vmSymbols::get_finalizer_histogram_name(),
 469                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 470 
 471   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 472   if (result_oop-&gt;length() == 0) {
 473     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 474     return;
 475   }
 476 
 477   oop foop = result_oop-&gt;obj_at(0);
</pre>
<hr />
<pre>
 498     int count = element_oop-&gt;int_field(count_fd.offset());
 499     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 500   }
 501 }
 502 
 503 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 504 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 505                            DCmdWithParser(output, heap),
 506   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 507   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 508        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 509   _dcmdparser.add_dcmd_option(&amp;_all);
 510   _dcmdparser.add_dcmd_argument(&amp;_filename);
 511 }
 512 
 513 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 514   // Request a full GC before heap dump if _all is false
 515   // This helps reduces the amount of unreachable objects in the dump
 516   // and makes it easier to browse.
 517   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
<span class="line-modified"> 518   dumper.dump(_filename.value(), output());</span>












 519 }
 520 
 521 int HeapDumpDCmd::num_arguments() {
 522   ResourceMark rm;
 523   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 524   if (dcmd != NULL) {
 525     DCmdMark mark(dcmd);
 526     return dcmd-&gt;_dcmdparser.num_arguments();
 527   } else {
 528     return 0;
 529   }
 530 }
 531 
 532 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 533                                        DCmdWithParser(output, heap),
 534   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 535        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 536   _dcmdparser.add_dcmd_option(&amp;_all);
 537 }
 538 
 539 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 540   VM_GC_HeapInspection heapop(output(),
 541                               !_all.value() /* request full gc if false */);
 542   VMThread::execute(&amp;heapop);
 543 }
 544 
 545 int ClassHistogramDCmd::num_arguments() {
 546   ResourceMark rm;
 547   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 548   if (dcmd != NULL) {
 549     DCmdMark mark(dcmd);
 550     return dcmd-&gt;_dcmdparser.num_arguments();
 551   } else {
 552     return 0;
 553   }
 554 }
 555 



















































 556 #endif // INCLUDE_SERVICES
 557 
 558 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 559                                DCmdWithParser(output, heap),
 560   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 561   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 562   _dcmdparser.add_dcmd_option(&amp;_locks);
 563   _dcmdparser.add_dcmd_option(&amp;_extended);
 564 }
 565 
 566 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 567   // thread stacks
 568   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 569   VMThread::execute(&amp;op1);
 570 
 571   // JNI global handles
 572   VM_PrintJNI op2(output());
 573   VMThread::execute(&amp;op2);
 574 
 575   // Deadlock detection
</pre>
<hr />
<pre>
 631    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 632 
 633   _jmxremote_login_config
 634   (&quot;jmxremote.login.config&quot;,
 635    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 636 
 637   _jmxremote_ssl_enabled_cipher_suites
 638   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 639    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 640 
 641   _jmxremote_ssl_enabled_protocols
 642   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 643    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 644 
 645   _jmxremote_ssl_need_client_auth
 646   (&quot;jmxremote.ssl.need.client.auth&quot;,
 647    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 648 
 649   _jmxremote_ssl_config_file
 650   (&quot;jmxremote.ssl.config.file&quot;,
<span class="line-modified"> 651    &quot;set com.sun.management.jmxremote.ssl.config.file&quot;, &quot;STRING&quot;, false),</span>
 652 
 653 // JDP Protocol support
 654   _jmxremote_autodiscovery
 655   (&quot;jmxremote.autodiscovery&quot;,
 656    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 657 
 658    _jdp_port
 659   (&quot;jdp.port&quot;,
 660    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 661 
 662    _jdp_address
 663   (&quot;jdp.address&quot;,
 664    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 665 
 666    _jdp_source_addr
 667   (&quot;jdp.source_addr&quot;,
 668    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 669 
 670    _jdp_ttl
 671   (&quot;jdp.ttl&quot;,
</pre>
<hr />
<pre>
 865   output()-&gt;cr();
 866 }
 867 
 868 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 869   VM_PrintCompileQueue printCompileQueueOp(output());
 870   VMThread::execute(&amp;printCompileQueueOp);
 871 }
 872 
 873 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 874   CodeCache::print_codelist(output());
 875 }
 876 
 877 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 878   CodeCache::print_layout(output());
 879 }
 880 
 881 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 882 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 883                                              DCmdWithParser(output, heap),
 884   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
<span class="line-modified"> 885   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;INT&quot;, false, &quot;4096&quot;) {</span>
 886   _dcmdparser.add_dcmd_argument(&amp;_function);
 887   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 888 }
 889 
 890 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-modified"> 891   jlong granularity = _granularity.value();</span>
<span class="line-added"> 892   if (granularity &lt; 1) {</span>
<span class="line-added"> 893     Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-added"> 894                        &quot;Invalid granularity value &quot; JLONG_FORMAT  &quot;. Should be positive.\n&quot;, granularity);</span>
<span class="line-added"> 895     return;</span>
<span class="line-added"> 896   }</span>
<span class="line-added"> 897 </span>
<span class="line-added"> 898   CompileBroker::print_heapinfo(output(), _function.value(), granularity);</span>
 899 }
 900 
 901 int CodeHeapAnalyticsDCmd::num_arguments() {
 902   ResourceMark rm;
 903   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 904   if (dcmd != NULL) {
 905     DCmdMark mark(dcmd);
 906     return dcmd-&gt;_dcmdparser.num_arguments();
 907   } else {
 908     return 0;
 909   }
 910 }
 911 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 912 
<span class="line-added"> 913 EventLogDCmd::EventLogDCmd(outputStream* output, bool heap) :</span>
<span class="line-added"> 914   DCmdWithParser(output, heap),</span>
<span class="line-added"> 915   _log(&quot;log&quot;, &quot;Name of log to be printed. If omitted, all logs are printed.&quot;, &quot;STRING&quot;, false, NULL),</span>
<span class="line-added"> 916   _max(&quot;max&quot;, &quot;Maximum number of events to be printed (newest first). If omitted, all events are printed.&quot;, &quot;STRING&quot;, false, NULL)</span>
<span class="line-added"> 917 {</span>
<span class="line-added"> 918   _dcmdparser.add_dcmd_option(&amp;_log);</span>
<span class="line-added"> 919   _dcmdparser.add_dcmd_option(&amp;_max);</span>
<span class="line-added"> 920 }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922 void EventLogDCmd::execute(DCmdSource source, TRAPS) {</span>
<span class="line-added"> 923   const char* max_value = _max.value();</span>
<span class="line-added"> 924   long max = -1;</span>
<span class="line-added"> 925   if (max_value != NULL) {</span>
<span class="line-added"> 926     char* endptr = NULL;</span>
<span class="line-added"> 927     max = ::strtol(max_value, &amp;endptr, 10);</span>
<span class="line-added"> 928     if (max == 0 &amp;&amp; max_value == endptr) {</span>
<span class="line-added"> 929       output()-&gt;print_cr(&quot;Invalid max option: \&quot;%s\&quot;.&quot;, max_value);</span>
<span class="line-added"> 930       return;</span>
<span class="line-added"> 931     }</span>
<span class="line-added"> 932   }</span>
<span class="line-added"> 933   const char* log_name = _log.value();</span>
<span class="line-added"> 934   if (log_name != NULL) {</span>
<span class="line-added"> 935     Events::print_one(output(), log_name, max);</span>
<span class="line-added"> 936   } else {</span>
<span class="line-added"> 937     Events::print_all(output(), max);</span>
<span class="line-added"> 938   }</span>
<span class="line-added"> 939 }</span>
<span class="line-added"> 940 </span>
<span class="line-added"> 941 int EventLogDCmd::num_arguments() {</span>
<span class="line-added"> 942   ResourceMark rm;</span>
<span class="line-added"> 943   EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);</span>
<span class="line-added"> 944   if (dcmd != NULL) {</span>
<span class="line-added"> 945     DCmdMark mark(dcmd);</span>
<span class="line-added"> 946     return dcmd-&gt;_dcmdparser.num_arguments();</span>
<span class="line-added"> 947   } else {</span>
<span class="line-added"> 948     return 0;</span>
<span class="line-added"> 949   }</span>
<span class="line-added"> 950 }</span>
<span class="line-added"> 951 </span>
 952 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 953   DirectivesStack::print(output());
 954 }
 955 
 956 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 957                            DCmdWithParser(output, heap),
 958   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 959   _dcmdparser.add_dcmd_argument(&amp;_filename);
 960 }
 961 
 962 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 963   DirectivesParser::parse_from_file(_filename.value(), output());
 964 }
 965 
 966 int CompilerDirectivesAddDCmd::num_arguments() {
 967   ResourceMark rm;
 968   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 969   if (dcmd != NULL) {
 970     DCmdMark mark(dcmd);
 971     return dcmd-&gt;_dcmdparser.num_arguments();
</pre>
</td>
</tr>
</table>
<center><a href="diagnosticArgument.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="diagnosticCommand.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
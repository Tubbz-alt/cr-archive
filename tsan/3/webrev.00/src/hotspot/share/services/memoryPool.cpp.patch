diff a/src/hotspot/share/services/memoryPool.cpp b/src/hotspot/share/services/memoryPool.cpp
--- a/src/hotspot/share/services/memoryPool.cpp
+++ b/src/hotspot/share/services/memoryPool.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,13 +25,13 @@
 #include "precompiled.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "memory/metaspace.hpp"
 #include "oops/oop.inline.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/javaCalls.hpp"
-#include "runtime/orderAccess.hpp"
 #include "services/lowMemoryDetector.hpp"
 #include "services/management.hpp"
 #include "services/memoryManager.hpp"
 #include "services/memoryPool.hpp"
 #include "utilities/globalDefinitions.hpp"
@@ -75,11 +75,11 @@
 // It creates a MemoryPool instance when the first time
 // this function is called.
 instanceOop MemoryPool::get_memory_pool_instance(TRAPS) {
   // Must do an acquire so as to force ordering of subsequent
   // loads from anything _memory_pool_obj points to or implies.
-  instanceOop pool_obj = OrderAccess::load_acquire(&_memory_pool_obj);
+  instanceOop pool_obj = Atomic::load_acquire(&_memory_pool_obj);
   if (pool_obj == NULL) {
     // It's ok for more than one thread to execute the code up to the locked region.
     // Extra pool instances will just be gc'ed.
     InstanceKlass* ik = Management::sun_management_ManagementFactoryHelper_klass(CHECK_NULL);
 
@@ -108,19 +108,19 @@
     instanceOop p = (instanceOop) result.get_jobject();
     instanceHandle pool(THREAD, p);
 
     {
       // Get lock since another thread may have create the instance
-      MutexLocker ml(Management_lock);
+      MutexLocker ml(THREAD, Management_lock);
 
       // Check if another thread has created the pool.  We reload
       // _memory_pool_obj here because some other thread may have
       // initialized it while we were executing the code before the lock.
       //
       // The lock has done an acquire, so the load can't float above it,
       // but we need to do a load_acquire as above.
-      pool_obj = OrderAccess::load_acquire(&_memory_pool_obj);
+      pool_obj = Atomic::load_acquire(&_memory_pool_obj);
       if (pool_obj != NULL) {
          return pool_obj;
       }
 
       // Get the address of the object we created via call_special.
@@ -128,11 +128,11 @@
 
       // Use store barrier to make sure the memory accesses associated
       // with creating the pool are visible before publishing its address.
       // The unlock will publish the store to _memory_pool_obj because
       // it does a release first.
-      OrderAccess::release_store(&_memory_pool_obj, pool_obj);
+      Atomic::release_store(&_memory_pool_obj, pool_obj);
     }
   }
 
   return pool_obj;
 }

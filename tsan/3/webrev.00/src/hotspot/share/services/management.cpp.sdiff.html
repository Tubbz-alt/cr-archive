<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/management.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mallocTracker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memBaseline.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/management.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jmm.h&quot;

  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/iterator.hpp&quot;
  31 #include &quot;memory/oopFactory.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;

  33 #include &quot;oops/klass.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;runtime/arguments.hpp&quot;
  39 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  40 #include &quot;runtime/globals.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/javaCalls.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;

  45 #include &quot;runtime/os.hpp&quot;
<span class="line-removed">  46 #include &quot;runtime/serviceThread.hpp&quot;</span>
  47 #include &quot;runtime/thread.inline.hpp&quot;
  48 #include &quot;runtime/threadSMR.hpp&quot;
  49 #include &quot;services/classLoadingService.hpp&quot;
  50 #include &quot;services/diagnosticCommand.hpp&quot;
  51 #include &quot;services/diagnosticFramework.hpp&quot;
  52 #include &quot;services/writeableFlags.hpp&quot;
  53 #include &quot;services/heapDumper.hpp&quot;
  54 #include &quot;services/lowMemoryDetector.hpp&quot;
  55 #include &quot;services/gcNotifier.hpp&quot;
  56 #include &quot;services/nmtDCmd.hpp&quot;
  57 #include &quot;services/management.hpp&quot;
  58 #include &quot;services/memoryManager.hpp&quot;
  59 #include &quot;services/memoryPool.hpp&quot;
  60 #include &quot;services/memoryService.hpp&quot;
  61 #include &quot;services/runtimeService.hpp&quot;
  62 #include &quot;services/threadService.hpp&quot;
  63 #include &quot;utilities/debug.hpp&quot;
  64 #include &quot;utilities/formatBuffer.hpp&quot;
  65 #include &quot;utilities/macros.hpp&quot;
  66 
</pre>
<hr />
<pre>
 127     _optional_support.isOtherThreadCpuTimeSupported = 0;
 128   }
 129 
 130   _optional_support.isObjectMonitorUsageSupported = 1;
 131 #if INCLUDE_SERVICES
 132   // This depends on the heap inspector
 133   _optional_support.isSynchronizerUsageSupported = 1;
 134 #endif // INCLUDE_SERVICES
 135   _optional_support.isThreadAllocatedMemorySupported = 1;
 136   _optional_support.isRemoteDiagnosticCommandsSupported = 1;
 137 
 138   // Registration of the diagnostic commands
 139   DCmdRegistrant::register_dcmds();
 140   DCmdRegistrant::register_dcmds_ext();
 141   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
 142                          | DCmd_Source_MBean;
 143   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;NMTDCmd&gt;(full_export, true, false));
 144 }
 145 
 146 void Management::initialize(TRAPS) {
<span class="line-modified"> 147   // Start the service thread</span>
<span class="line-modified"> 148   ServiceThread::initialize();</span>
<span class="line-modified"> 149 </span>
 150   if (ManagementServer) {
 151     ResourceMark rm(THREAD);
 152     HandleMark hm(THREAD);
 153 
 154     // Load and initialize the jdk.internal.agent.Agent class
 155     // invoke startAgent method to start the management server
 156     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 157     Klass* k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_agent_Agent(),
 158                                                    loader,
 159                                                    Handle(),
 160                                                    THREAD);
 161     if (k == NULL) {
 162       vm_exit_during_initialization(&quot;Management agent initialization failure: &quot;
 163           &quot;class jdk.internal.agent.Agent not found.&quot;);
 164     }
 165 
 166     JavaValue result(T_VOID);
 167     JavaCalls::call_static(&amp;result,
 168                            k,
 169                            vmSymbols::startAgent_name(),
</pre>
<hr />
<pre>
 826  private:
 827   int _count;
 828  public:
 829   VmThreadCountClosure() : _count(0) {};
 830   void do_thread(Thread* thread);
 831   int count() { return _count; }
 832 };
 833 
 834 void VmThreadCountClosure::do_thread(Thread* thread) {
 835   // exclude externally visible JavaThreads
 836   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
 837     return;
 838   }
 839 
 840   _count++;
 841 }
 842 
 843 static jint get_vm_thread_count() {
 844   VmThreadCountClosure vmtcc;
 845   {
<span class="line-modified"> 846     MutexLockerEx ml(Threads_lock);</span>
 847     Threads::threads_do(&amp;vmtcc);
 848   }
 849 
 850   return vmtcc.count();
 851 }
 852 
 853 static jint get_num_flags() {
 854   // last flag entry is always NULL, so subtract 1
 855   int nFlags = (int) JVMFlag::numFlags - 1;
 856   int count = 0;
 857   for (int i = 0; i &lt; nFlags; i++) {
 858     JVMFlag* flag = &amp;JVMFlag::flags[i];
 859     // Exclude the locked (diagnostic, experimental) flags
 860     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
 861       count++;
 862     }
 863   }
 864   return count;
 865 }
 866 
</pre>
<hr />
<pre>
1527     // return the requested globals
1528     objArrayOop ta = objArrayOop(JNIHandles::resolve_non_null(names));
1529     objArrayHandle names_ah(THREAD, ta);
1530     // Make sure we have a String array
1531     Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1532     if (element_klass != SystemDictionary::String_klass()) {
1533       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1534                  &quot;Array element type is not String class&quot;, 0);
1535     }
1536 
1537     int names_length = names_ah-&gt;length();
1538     int num_entries = 0;
1539     for (int i = 0; i &lt; names_length &amp;&amp; i &lt; count; i++) {
1540       oop s = names_ah-&gt;obj_at(i);
1541       if (s == NULL) {
1542         THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1543       }
1544 
1545       Handle sh(THREAD, s);
1546       char* str = java_lang_String::as_utf8_string(s);
<span class="line-modified">1547       JVMFlag* flag = JVMFlag::find_flag(str, strlen(str));</span>
1548       if (flag != NULL &amp;&amp;
1549           add_global_entry(env, sh, &amp;globals[i], flag, THREAD)) {
1550         num_entries++;
1551       } else {
1552         globals[i].name = NULL;
1553       }
1554     }
1555     return num_entries;
1556   } else {
1557     // return all globals if names == NULL
1558 
1559     // last flag entry is always NULL, so subtract 1
1560     int nFlags = (int) JVMFlag::numFlags - 1;
1561     Handle null_h;
1562     int num_entries = 0;
1563     for (int i = 0; i &lt; nFlags &amp;&amp; num_entries &lt; count;  i++) {
1564       JVMFlag* flag = &amp;JVMFlag::flags[i];
1565       // Exclude notproduct and develop flags in product builds.
1566       if (flag-&gt;is_constant_in_binary()) {
1567         continue;
</pre>
<hr />
<pre>
1686                                            jobjectArray names,
1687                                            jlongArray times))
1688   if (names == NULL || times == NULL) {
1689      THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1690   }
1691   objArrayOop na = objArrayOop(JNIHandles::resolve_non_null(names));
1692   objArrayHandle names_ah(THREAD, na);
1693 
1694   // Make sure we have a String array
1695   Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1696   if (element_klass != SystemDictionary::String_klass()) {
1697     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1698                &quot;Array element type is not String class&quot;, 0);
1699   }
1700 
1701   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(times));
1702   typeArrayHandle times_ah(THREAD, ta);
1703 
1704   ThreadTimesClosure ttc(names_ah, times_ah);
1705   {
<span class="line-modified">1706     MutexLockerEx ml(Threads_lock);</span>
1707     Threads::threads_do(&amp;ttc);
1708   }
1709   ttc.do_unlocked();
1710   return ttc.count();
1711 JVM_END
1712 
1713 static Handle find_deadlocks(bool object_monitors_only, TRAPS) {
1714   ResourceMark rm(THREAD);
1715 
1716   VM_FindDeadlocks op(!object_monitors_only /* also check concurrent locks? */);
1717   VMThread::execute(&amp;op);
1718 
1719   DeadlockCycle* deadlocks = op.result();
1720   if (deadlocks == NULL) {
1721     // no deadlock found and return
1722     return Handle();
1723   }
1724 
1725   int num_threads = 0;
1726   DeadlockCycle* cycle;
</pre>
<hr />
<pre>
2049     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2050                    &quot;Command line content cannot be null.&quot;);
2051   }
2052   bufferedStream output;
2053   DCmd::parse_and_execute(DCmd_Source_MBean, &amp;output, cmdline, &#39; &#39;, CHECK_NULL);
2054   oop result = java_lang_String::create_oop_from_str(output.as_string(), CHECK_NULL);
2055   return (jstring) JNIHandles::make_local(env, result);
2056 JVM_END
2057 
2058 JVM_ENTRY(void, jmm_SetDiagnosticFrameworkNotificationEnabled(JNIEnv *env, jboolean enabled))
2059   DCmdFactory::set_jmx_notification_enabled(enabled?true:false);
2060 JVM_END
2061 
2062 jlong Management::ticks_to_ms(jlong ticks) {
2063   assert(os::elapsed_frequency() &gt; 0, &quot;Must be non-zero&quot;);
2064   return (jlong)(((double)ticks / (double)os::elapsed_frequency())
2065                  * (double)1000.0);
2066 }
2067 #endif // INCLUDE_MANAGEMENT
2068 

























2069 // Gets an array containing the amount of memory allocated on the Java
2070 // heap for a set of threads (in bytes).  Each element of the array is
2071 // the amount of memory allocated for the thread ID specified in the
2072 // corresponding entry in the given array of thread IDs; or -1 if the
2073 // thread does not exist or has terminated.
2074 JVM_ENTRY(void, jmm_GetThreadAllocatedMemory(JNIEnv *env, jlongArray ids,
2075                                              jlongArray sizeArray))
2076   // Check if threads is null
2077   if (ids == NULL || sizeArray == NULL) {
2078     THROW(vmSymbols::java_lang_NullPointerException());
2079   }
2080 
2081   ResourceMark rm(THREAD);
2082   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2083   typeArrayHandle ids_ah(THREAD, ta);
2084 
2085   typeArrayOop sa = typeArrayOop(JNIHandles::resolve_non_null(sizeArray));
2086   typeArrayHandle sizeArray_h(THREAD, sa);
2087 
2088   // validate the thread id array
</pre>
<hr />
<pre>
2173     if (java_thread != NULL) {
2174       timeArray_h-&gt;long_at_put(i, os::thread_cpu_time((Thread*)java_thread,
2175                                                       user_sys_cpu_time != 0));
2176     }
2177   }
2178 JVM_END
2179 
2180 
2181 
2182 #if INCLUDE_MANAGEMENT
2183 const struct jmmInterface_1_ jmm_interface = {
2184   NULL,
2185   NULL,
2186   jmm_GetVersion,
2187   jmm_GetOptionalSupport,
2188   jmm_GetThreadInfo,
2189   jmm_GetMemoryPools,
2190   jmm_GetMemoryManagers,
2191   jmm_GetMemoryPoolUsage,
2192   jmm_GetPeakMemoryPoolUsage,

2193   jmm_GetThreadAllocatedMemory,
2194   jmm_GetMemoryUsage,
2195   jmm_GetLongAttribute,
2196   jmm_GetBoolAttribute,
2197   jmm_SetBoolAttribute,
2198   jmm_GetLongAttributes,
2199   jmm_FindMonitorDeadlockedThreads,
2200   jmm_GetThreadCpuTime,
2201   jmm_GetVMGlobalNames,
2202   jmm_GetVMGlobals,
2203   jmm_GetInternalThreadTimes,
2204   jmm_ResetStatistic,
2205   jmm_SetPoolSensor,
2206   jmm_SetPoolThreshold,
2207   jmm_GetPoolCollectionUsage,
2208   jmm_GetGCExtAttributeInfo,
2209   jmm_GetLastGCStat,
2210   jmm_GetThreadCpuTimeWithKind,
2211   jmm_GetThreadCpuTimesWithKind,
2212   jmm_DumpHeap0,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jmm.h&quot;
<span class="line-added">  27 #include &quot;classfile/classLoader.hpp&quot;</span>
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/iterator.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  34 #include &quot;memory/universe.hpp&quot;</span>
  35 #include &quot;oops/klass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/objArrayOop.inline.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  40 #include &quot;runtime/arguments.hpp&quot;
  41 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  42 #include &quot;runtime/globals.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-added">  47 #include &quot;runtime/notificationThread.hpp&quot;</span>
  48 #include &quot;runtime/os.hpp&quot;

  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;services/classLoadingService.hpp&quot;
  52 #include &quot;services/diagnosticCommand.hpp&quot;
  53 #include &quot;services/diagnosticFramework.hpp&quot;
  54 #include &quot;services/writeableFlags.hpp&quot;
  55 #include &quot;services/heapDumper.hpp&quot;
  56 #include &quot;services/lowMemoryDetector.hpp&quot;
  57 #include &quot;services/gcNotifier.hpp&quot;
  58 #include &quot;services/nmtDCmd.hpp&quot;
  59 #include &quot;services/management.hpp&quot;
  60 #include &quot;services/memoryManager.hpp&quot;
  61 #include &quot;services/memoryPool.hpp&quot;
  62 #include &quot;services/memoryService.hpp&quot;
  63 #include &quot;services/runtimeService.hpp&quot;
  64 #include &quot;services/threadService.hpp&quot;
  65 #include &quot;utilities/debug.hpp&quot;
  66 #include &quot;utilities/formatBuffer.hpp&quot;
  67 #include &quot;utilities/macros.hpp&quot;
  68 
</pre>
<hr />
<pre>
 129     _optional_support.isOtherThreadCpuTimeSupported = 0;
 130   }
 131 
 132   _optional_support.isObjectMonitorUsageSupported = 1;
 133 #if INCLUDE_SERVICES
 134   // This depends on the heap inspector
 135   _optional_support.isSynchronizerUsageSupported = 1;
 136 #endif // INCLUDE_SERVICES
 137   _optional_support.isThreadAllocatedMemorySupported = 1;
 138   _optional_support.isRemoteDiagnosticCommandsSupported = 1;
 139 
 140   // Registration of the diagnostic commands
 141   DCmdRegistrant::register_dcmds();
 142   DCmdRegistrant::register_dcmds_ext();
 143   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
 144                          | DCmd_Source_MBean;
 145   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;NMTDCmd&gt;(full_export, true, false));
 146 }
 147 
 148 void Management::initialize(TRAPS) {
<span class="line-modified"> 149   if (UseNotificationThread) {</span>
<span class="line-modified"> 150     NotificationThread::initialize();</span>
<span class="line-modified"> 151   }</span>
 152   if (ManagementServer) {
 153     ResourceMark rm(THREAD);
 154     HandleMark hm(THREAD);
 155 
 156     // Load and initialize the jdk.internal.agent.Agent class
 157     // invoke startAgent method to start the management server
 158     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 159     Klass* k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_agent_Agent(),
 160                                                    loader,
 161                                                    Handle(),
 162                                                    THREAD);
 163     if (k == NULL) {
 164       vm_exit_during_initialization(&quot;Management agent initialization failure: &quot;
 165           &quot;class jdk.internal.agent.Agent not found.&quot;);
 166     }
 167 
 168     JavaValue result(T_VOID);
 169     JavaCalls::call_static(&amp;result,
 170                            k,
 171                            vmSymbols::startAgent_name(),
</pre>
<hr />
<pre>
 828  private:
 829   int _count;
 830  public:
 831   VmThreadCountClosure() : _count(0) {};
 832   void do_thread(Thread* thread);
 833   int count() { return _count; }
 834 };
 835 
 836 void VmThreadCountClosure::do_thread(Thread* thread) {
 837   // exclude externally visible JavaThreads
 838   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
 839     return;
 840   }
 841 
 842   _count++;
 843 }
 844 
 845 static jint get_vm_thread_count() {
 846   VmThreadCountClosure vmtcc;
 847   {
<span class="line-modified"> 848     MutexLocker ml(Threads_lock);</span>
 849     Threads::threads_do(&amp;vmtcc);
 850   }
 851 
 852   return vmtcc.count();
 853 }
 854 
 855 static jint get_num_flags() {
 856   // last flag entry is always NULL, so subtract 1
 857   int nFlags = (int) JVMFlag::numFlags - 1;
 858   int count = 0;
 859   for (int i = 0; i &lt; nFlags; i++) {
 860     JVMFlag* flag = &amp;JVMFlag::flags[i];
 861     // Exclude the locked (diagnostic, experimental) flags
 862     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
 863       count++;
 864     }
 865   }
 866   return count;
 867 }
 868 
</pre>
<hr />
<pre>
1529     // return the requested globals
1530     objArrayOop ta = objArrayOop(JNIHandles::resolve_non_null(names));
1531     objArrayHandle names_ah(THREAD, ta);
1532     // Make sure we have a String array
1533     Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1534     if (element_klass != SystemDictionary::String_klass()) {
1535       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1536                  &quot;Array element type is not String class&quot;, 0);
1537     }
1538 
1539     int names_length = names_ah-&gt;length();
1540     int num_entries = 0;
1541     for (int i = 0; i &lt; names_length &amp;&amp; i &lt; count; i++) {
1542       oop s = names_ah-&gt;obj_at(i);
1543       if (s == NULL) {
1544         THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1545       }
1546 
1547       Handle sh(THREAD, s);
1548       char* str = java_lang_String::as_utf8_string(s);
<span class="line-modified">1549       JVMFlag* flag = JVMFlag::find_flag(str);</span>
1550       if (flag != NULL &amp;&amp;
1551           add_global_entry(env, sh, &amp;globals[i], flag, THREAD)) {
1552         num_entries++;
1553       } else {
1554         globals[i].name = NULL;
1555       }
1556     }
1557     return num_entries;
1558   } else {
1559     // return all globals if names == NULL
1560 
1561     // last flag entry is always NULL, so subtract 1
1562     int nFlags = (int) JVMFlag::numFlags - 1;
1563     Handle null_h;
1564     int num_entries = 0;
1565     for (int i = 0; i &lt; nFlags &amp;&amp; num_entries &lt; count;  i++) {
1566       JVMFlag* flag = &amp;JVMFlag::flags[i];
1567       // Exclude notproduct and develop flags in product builds.
1568       if (flag-&gt;is_constant_in_binary()) {
1569         continue;
</pre>
<hr />
<pre>
1688                                            jobjectArray names,
1689                                            jlongArray times))
1690   if (names == NULL || times == NULL) {
1691      THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1692   }
1693   objArrayOop na = objArrayOop(JNIHandles::resolve_non_null(names));
1694   objArrayHandle names_ah(THREAD, na);
1695 
1696   // Make sure we have a String array
1697   Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1698   if (element_klass != SystemDictionary::String_klass()) {
1699     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1700                &quot;Array element type is not String class&quot;, 0);
1701   }
1702 
1703   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(times));
1704   typeArrayHandle times_ah(THREAD, ta);
1705 
1706   ThreadTimesClosure ttc(names_ah, times_ah);
1707   {
<span class="line-modified">1708     MutexLocker ml(THREAD, Threads_lock);</span>
1709     Threads::threads_do(&amp;ttc);
1710   }
1711   ttc.do_unlocked();
1712   return ttc.count();
1713 JVM_END
1714 
1715 static Handle find_deadlocks(bool object_monitors_only, TRAPS) {
1716   ResourceMark rm(THREAD);
1717 
1718   VM_FindDeadlocks op(!object_monitors_only /* also check concurrent locks? */);
1719   VMThread::execute(&amp;op);
1720 
1721   DeadlockCycle* deadlocks = op.result();
1722   if (deadlocks == NULL) {
1723     // no deadlock found and return
1724     return Handle();
1725   }
1726 
1727   int num_threads = 0;
1728   DeadlockCycle* cycle;
</pre>
<hr />
<pre>
2051     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2052                    &quot;Command line content cannot be null.&quot;);
2053   }
2054   bufferedStream output;
2055   DCmd::parse_and_execute(DCmd_Source_MBean, &amp;output, cmdline, &#39; &#39;, CHECK_NULL);
2056   oop result = java_lang_String::create_oop_from_str(output.as_string(), CHECK_NULL);
2057   return (jstring) JNIHandles::make_local(env, result);
2058 JVM_END
2059 
2060 JVM_ENTRY(void, jmm_SetDiagnosticFrameworkNotificationEnabled(JNIEnv *env, jboolean enabled))
2061   DCmdFactory::set_jmx_notification_enabled(enabled?true:false);
2062 JVM_END
2063 
2064 jlong Management::ticks_to_ms(jlong ticks) {
2065   assert(os::elapsed_frequency() &gt; 0, &quot;Must be non-zero&quot;);
2066   return (jlong)(((double)ticks / (double)os::elapsed_frequency())
2067                  * (double)1000.0);
2068 }
2069 #endif // INCLUDE_MANAGEMENT
2070 
<span class="line-added">2071 // Gets the amount of memory allocated on the Java heap for a single thread.</span>
<span class="line-added">2072 // Returns -1 if the thread does not exist or has terminated.</span>
<span class="line-added">2073 JVM_ENTRY(jlong, jmm_GetOneThreadAllocatedMemory(JNIEnv *env, jlong thread_id))</span>
<span class="line-added">2074   if (thread_id &lt; 0) {</span>
<span class="line-added">2075     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-added">2076                &quot;Invalid thread ID&quot;, -1);</span>
<span class="line-added">2077   }</span>
<span class="line-added">2078 </span>
<span class="line-added">2079   if (thread_id == 0) {</span>
<span class="line-added">2080     // current thread</span>
<span class="line-added">2081     if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-added">2082       return ((JavaThread*)THREAD)-&gt;cooked_allocated_bytes();</span>
<span class="line-added">2083     }</span>
<span class="line-added">2084     return -1;</span>
<span class="line-added">2085   }</span>
<span class="line-added">2086 </span>
<span class="line-added">2087   ThreadsListHandle tlh;</span>
<span class="line-added">2088   JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);</span>
<span class="line-added">2089 </span>
<span class="line-added">2090   if (java_thread != NULL) {</span>
<span class="line-added">2091     return java_thread-&gt;cooked_allocated_bytes();</span>
<span class="line-added">2092   }</span>
<span class="line-added">2093   return -1;</span>
<span class="line-added">2094 JVM_END</span>
<span class="line-added">2095 </span>
2096 // Gets an array containing the amount of memory allocated on the Java
2097 // heap for a set of threads (in bytes).  Each element of the array is
2098 // the amount of memory allocated for the thread ID specified in the
2099 // corresponding entry in the given array of thread IDs; or -1 if the
2100 // thread does not exist or has terminated.
2101 JVM_ENTRY(void, jmm_GetThreadAllocatedMemory(JNIEnv *env, jlongArray ids,
2102                                              jlongArray sizeArray))
2103   // Check if threads is null
2104   if (ids == NULL || sizeArray == NULL) {
2105     THROW(vmSymbols::java_lang_NullPointerException());
2106   }
2107 
2108   ResourceMark rm(THREAD);
2109   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2110   typeArrayHandle ids_ah(THREAD, ta);
2111 
2112   typeArrayOop sa = typeArrayOop(JNIHandles::resolve_non_null(sizeArray));
2113   typeArrayHandle sizeArray_h(THREAD, sa);
2114 
2115   // validate the thread id array
</pre>
<hr />
<pre>
2200     if (java_thread != NULL) {
2201       timeArray_h-&gt;long_at_put(i, os::thread_cpu_time((Thread*)java_thread,
2202                                                       user_sys_cpu_time != 0));
2203     }
2204   }
2205 JVM_END
2206 
2207 
2208 
2209 #if INCLUDE_MANAGEMENT
2210 const struct jmmInterface_1_ jmm_interface = {
2211   NULL,
2212   NULL,
2213   jmm_GetVersion,
2214   jmm_GetOptionalSupport,
2215   jmm_GetThreadInfo,
2216   jmm_GetMemoryPools,
2217   jmm_GetMemoryManagers,
2218   jmm_GetMemoryPoolUsage,
2219   jmm_GetPeakMemoryPoolUsage,
<span class="line-added">2220   jmm_GetOneThreadAllocatedMemory,</span>
2221   jmm_GetThreadAllocatedMemory,
2222   jmm_GetMemoryUsage,
2223   jmm_GetLongAttribute,
2224   jmm_GetBoolAttribute,
2225   jmm_SetBoolAttribute,
2226   jmm_GetLongAttributes,
2227   jmm_FindMonitorDeadlockedThreads,
2228   jmm_GetThreadCpuTime,
2229   jmm_GetVMGlobalNames,
2230   jmm_GetVMGlobals,
2231   jmm_GetInternalThreadTimes,
2232   jmm_ResetStatistic,
2233   jmm_SetPoolSensor,
2234   jmm_SetPoolThreshold,
2235   jmm_GetPoolCollectionUsage,
2236   jmm_GetGCExtAttributeInfo,
2237   jmm_GetLastGCStat,
2238   jmm_GetThreadCpuTimeWithKind,
2239   jmm_GetThreadCpuTimesWithKind,
2240   jmm_DumpHeap0,
</pre>
</td>
</tr>
</table>
<center><a href="mallocTracker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memBaseline.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
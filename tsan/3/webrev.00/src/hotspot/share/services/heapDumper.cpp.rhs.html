<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  35 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/handles.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.hpp&quot;
  47 #include &quot;runtime/os.inline.hpp&quot;
  48 #include &quot;runtime/reflectionUtils.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;runtime/vframe.hpp&quot;
  52 #include &quot;runtime/vmThread.hpp&quot;
  53 #include &quot;runtime/vmOperations.hpp&quot;
  54 #include &quot;services/heapDumper.hpp&quot;
  55 #include &quot;services/threadService.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
  57 #include &quot;utilities/ostream.hpp&quot;
  58 
  59 /*
  60  * HPROF binary format - description copied from:
  61  *   src/share/demo/jvmti/hprof/hprof_io.c
  62  *
  63  *
  64  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  65  *
  66  *  u4        size of identifiers. Identifiers are used to represent
  67  *            UTF8 strings, objects, stack traces, etc. They usually
  68  *            have the same size as host pointers. For example, on
  69  *            Solaris and Win32, the size is 4.
  70  * u4         high word
  71  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  72  * [record]*  a sequence of records.
  73  *
  74  *
  75  * Record format:
  76  *
  77  * u1         a TAG denoting the type of the record
  78  * u4         number of *microseconds* since the time stamp in the
  79  *            header. (wraps around in a little more than an hour)
  80  * u4         number of bytes *remaining* in the record. Note that
  81  *            this number excludes the tag and the length field itself.
  82  * [u1]*      BODY of the record (a sequence of bytes)
  83  *
  84  *
  85  * The following TAGs are supported:
  86  *
  87  * TAG           BODY       notes
  88  *----------------------------------------------------------
  89  * HPROF_UTF8               a UTF8-encoded name
  90  *
  91  *               id         name ID
  92  *               [u1]*      UTF8 characters (no trailing zero)
  93  *
  94  * HPROF_LOAD_CLASS         a newly loaded class
  95  *
  96  *                u4        class serial number (&gt; 0)
  97  *                id        class object ID
  98  *                u4        stack trace serial number
  99  *                id        class name ID
 100  *
 101  * HPROF_UNLOAD_CLASS       an unloading class
 102  *
 103  *                u4        class serial_number
 104  *
 105  * HPROF_FRAME              a Java stack frame
 106  *
 107  *                id        stack frame ID
 108  *                id        method name ID
 109  *                id        method signature ID
 110  *                id        source file name ID
 111  *                u4        class serial number
 112  *                i4        line number. &gt;0: normal
 113  *                                       -1: unknown
 114  *                                       -2: compiled method
 115  *                                       -3: native method
 116  *
 117  * HPROF_TRACE              a Java stack trace
 118  *
 119  *               u4         stack trace serial number
 120  *               u4         thread serial number
 121  *               u4         number of frames
 122  *               [id]*      stack frame IDs
 123  *
 124  *
 125  * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC
 126  *
 127  *               u2         flags 0x0001: incremental vs. complete
 128  *                                0x0002: sorted by allocation vs. live
 129  *                                0x0004: whether to force a GC
 130  *               u4         cutoff ratio
 131  *               u4         total live bytes
 132  *               u4         total live instances
 133  *               u8         total bytes allocated
 134  *               u8         total instances allocated
 135  *               u4         number of sites that follow
 136  *               [u1        is_array: 0:  normal object
 137  *                                    2:  object array
 138  *                                    4:  boolean array
 139  *                                    5:  char array
 140  *                                    6:  float array
 141  *                                    7:  double array
 142  *                                    8:  byte array
 143  *                                    9:  short array
 144  *                                    10: int array
 145  *                                    11: long array
 146  *                u4        class serial number (may be zero during startup)
 147  *                u4        stack trace serial number
 148  *                u4        number of bytes alive
 149  *                u4        number of instances alive
 150  *                u4        number of bytes allocated
 151  *                u4]*      number of instance allocated
 152  *
 153  * HPROF_START_THREAD       a newly started thread.
 154  *
 155  *               u4         thread serial number (&gt; 0)
 156  *               id         thread object ID
 157  *               u4         stack trace serial number
 158  *               id         thread name ID
 159  *               id         thread group name ID
 160  *               id         thread group parent name ID
 161  *
 162  * HPROF_END_THREAD         a terminating thread.
 163  *
 164  *               u4         thread serial number
 165  *
 166  * HPROF_HEAP_SUMMARY       heap summary
 167  *
 168  *               u4         total live bytes
 169  *               u4         total live instances
 170  *               u8         total bytes allocated
 171  *               u8         total instances allocated
 172  *
 173  * HPROF_HEAP_DUMP          denote a heap dump
 174  *
 175  *               [heap dump sub-records]*
 176  *
 177  *                          There are four kinds of heap dump sub-records:
 178  *
 179  *               u1         sub-record type
 180  *
 181  *               HPROF_GC_ROOT_UNKNOWN         unknown root
 182  *
 183  *                          id         object ID
 184  *
 185  *               HPROF_GC_ROOT_THREAD_OBJ      thread object
 186  *
 187  *                          id         thread object ID  (may be 0 for a
 188  *                                     thread newly attached through JNI)
 189  *                          u4         thread sequence number
 190  *                          u4         stack trace sequence number
 191  *
 192  *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root
 193  *
 194  *                          id         object ID
 195  *                          id         JNI global ref ID
 196  *
 197  *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref
 198  *
 199  *                          id         object ID
 200  *                          u4         thread serial number
 201  *                          u4         frame # in stack trace (-1 for empty)
 202  *
 203  *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame
 204  *
 205  *                          id         object ID
 206  *                          u4         thread serial number
 207  *                          u4         frame # in stack trace (-1 for empty)
 208  *
 209  *               HPROF_GC_ROOT_NATIVE_STACK    Native stack
 210  *
 211  *                          id         object ID
 212  *                          u4         thread serial number
 213  *
 214  *               HPROF_GC_ROOT_STICKY_CLASS    System class
 215  *
 216  *                          id         object ID
 217  *
 218  *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block
 219  *
 220  *                          id         object ID
 221  *                          u4         thread serial number
 222  *
 223  *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor
 224  *
 225  *                          id         object ID
 226  *
 227  *               HPROF_GC_CLASS_DUMP           dump of a class object
 228  *
 229  *                          id         class object ID
 230  *                          u4         stack trace serial number
 231  *                          id         super class object ID
 232  *                          id         class loader object ID
 233  *                          id         signers object ID
 234  *                          id         protection domain object ID
 235  *                          id         reserved
 236  *                          id         reserved
 237  *
 238  *                          u4         instance size (in bytes)
 239  *
 240  *                          u2         size of constant pool
 241  *                          [u2,       constant pool index,
 242  *                           ty,       type
 243  *                                     2:  object
 244  *                                     4:  boolean
 245  *                                     5:  char
 246  *                                     6:  float
 247  *                                     7:  double
 248  *                                     8:  byte
 249  *                                     9:  short
 250  *                                     10: int
 251  *                                     11: long
 252  *                           vl]*      and value
 253  *
 254  *                          u2         number of static fields
 255  *                          [id,       static field name,
 256  *                           ty,       type,
 257  *                           vl]*      and value
 258  *
 259  *                          u2         number of inst. fields (not inc. super)
 260  *                          [id,       instance field name,
 261  *                           ty]*      type
 262  *
 263  *               HPROF_GC_INSTANCE_DUMP        dump of a normal object
 264  *
 265  *                          id         object ID
 266  *                          u4         stack trace serial number
 267  *                          id         class object ID
 268  *                          u4         number of bytes that follow
 269  *                          [vl]*      instance field values (class, followed
 270  *                                     by super, super&#39;s super ...)
 271  *
 272  *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array
 273  *
 274  *                          id         array object ID
 275  *                          u4         stack trace serial number
 276  *                          u4         number of elements
 277  *                          id         array class ID
 278  *                          [id]*      elements
 279  *
 280  *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array
 281  *
 282  *                          id         array object ID
 283  *                          u4         stack trace serial number
 284  *                          u4         number of elements
 285  *                          u1         element type
 286  *                                     4:  boolean array
 287  *                                     5:  char array
 288  *                                     6:  float array
 289  *                                     7:  double array
 290  *                                     8:  byte array
 291  *                                     9:  short array
 292  *                                     10: int array
 293  *                                     11: long array
 294  *                          [u1]*      elements
 295  *
 296  * HPROF_CPU_SAMPLES        a set of sample traces of running threads
 297  *
 298  *                u4        total number of samples
 299  *                u4        # of traces
 300  *               [u4        # of samples
 301  *                u4]*      stack trace serial number
 302  *
 303  * HPROF_CONTROL_SETTINGS   the settings of on/off switches
 304  *
 305  *                u4        0x00000001: alloc traces on/off
 306  *                          0x00000002: cpu sampling on/off
 307  *                u2        stack trace depth
 308  *
 309  *
 310  * When the header is &quot;JAVA PROFILE 1.0.2&quot; a heap dump can optionally
 311  * be generated as a sequence of heap dump segments. This sequence is
 312  * terminated by an end record. The additional tags allowed by format
 313  * &quot;JAVA PROFILE 1.0.2&quot; are:
 314  *
 315  * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment
 316  *
 317  *               [heap dump sub-records]*
 318  *               The same sub-record types allowed by HPROF_HEAP_DUMP
 319  *
 320  * HPROF_HEAP_DUMP_END      denotes the end of a heap dump
 321  *
 322  */
 323 
 324 
 325 // HPROF tags
 326 
 327 typedef enum {
 328   // top-level records
 329   HPROF_UTF8                    = 0x01,
 330   HPROF_LOAD_CLASS              = 0x02,
 331   HPROF_UNLOAD_CLASS            = 0x03,
 332   HPROF_FRAME                   = 0x04,
 333   HPROF_TRACE                   = 0x05,
 334   HPROF_ALLOC_SITES             = 0x06,
 335   HPROF_HEAP_SUMMARY            = 0x07,
 336   HPROF_START_THREAD            = 0x0A,
 337   HPROF_END_THREAD              = 0x0B,
 338   HPROF_HEAP_DUMP               = 0x0C,
 339   HPROF_CPU_SAMPLES             = 0x0D,
 340   HPROF_CONTROL_SETTINGS        = 0x0E,
 341 
 342   // 1.0.2 record types
 343   HPROF_HEAP_DUMP_SEGMENT       = 0x1C,
 344   HPROF_HEAP_DUMP_END           = 0x2C,
 345 
 346   // field types
 347   HPROF_ARRAY_OBJECT            = 0x01,
 348   HPROF_NORMAL_OBJECT           = 0x02,
 349   HPROF_BOOLEAN                 = 0x04,
 350   HPROF_CHAR                    = 0x05,
 351   HPROF_FLOAT                   = 0x06,
 352   HPROF_DOUBLE                  = 0x07,
 353   HPROF_BYTE                    = 0x08,
 354   HPROF_SHORT                   = 0x09,
 355   HPROF_INT                     = 0x0A,
 356   HPROF_LONG                    = 0x0B,
 357 
 358   // data-dump sub-records
 359   HPROF_GC_ROOT_UNKNOWN         = 0xFF,
 360   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 361   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 362   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 363   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 364   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 365   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 366   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 367   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 368   HPROF_GC_CLASS_DUMP           = 0x20,
 369   HPROF_GC_INSTANCE_DUMP        = 0x21,
 370   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 371   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 372 } hprofTag;
 373 
 374 // Default stack trace ID (used for dummy HPROF_TRACE record)
 375 enum {
 376   STACK_TRACE_ID = 1,
 377   INITIAL_CLASS_COUNT = 200
 378 };
 379 
 380 // Supports I/O operations on a dump file
 381 
 382 class DumpWriter : public StackObj {
 383  private:
 384   enum {
<a name="3" id="anc3"></a><span class="line-modified"> 385     io_buffer_max_size = 8*M,</span>
<span class="line-added"> 386     io_buffer_min_size = 64*K,</span>
<span class="line-added"> 387     dump_segment_header_size = 9</span>
 388   };
 389 
 390   int _fd;              // file descriptor (-1 if dump file not open)
 391   julong _bytes_written; // number of byte written to dump file
 392 
 393   char* _buffer;    // internal buffer
 394   size_t _size;
 395   size_t _pos;
 396 
<a name="4" id="anc4"></a><span class="line-modified"> 397   bool _in_dump_segment; // Are we currently in a dump segment?</span>
<span class="line-added"> 398   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?</span>
<span class="line-added"> 399   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.</span>
<span class="line-added"> 400   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().</span>
 401 
 402   char* _error;   // error message when I/O fails
 403 
 404   void set_file_descriptor(int fd)              { _fd = fd; }
 405   int file_descriptor() const                   { return _fd; }
 406 
<a name="5" id="anc5"></a><span class="line-added"> 407   bool is_open() const                          { return file_descriptor() &gt;= 0; }</span>
<span class="line-added"> 408   void flush();</span>
<span class="line-added"> 409 </span>
 410   char* buffer() const                          { return _buffer; }
 411   size_t buffer_size() const                    { return _size; }
 412   size_t position() const                       { return _pos; }
 413   void set_position(size_t pos)                 { _pos = pos; }
 414 
 415   void set_error(const char* error)             { _error = (char*)os::strdup(error); }
 416 
 417   // all I/O go through this function
 418   void write_internal(void* s, size_t len);
 419 
 420  public:
 421   DumpWriter(const char* path);
 422   ~DumpWriter();
 423 
 424   void close();
<a name="6" id="anc6"></a>





 425 
 426   // total number of bytes written to the disk
 427   julong bytes_written() const          { return _bytes_written; }
 428 
<a name="7" id="anc7"></a>






 429   char* error() const                   { return _error; }
 430 
<a name="8" id="anc8"></a>


 431   // writer functions
 432   void write_raw(void* s, size_t len);
 433   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
 434   void write_u2(u2 x);
 435   void write_u4(u4 x);
 436   void write_u8(u8 x);
 437   void write_objectID(oop o);
 438   void write_symbolID(Symbol* o);
 439   void write_classID(Klass* k);
 440   void write_id(u4 x);
<a name="9" id="anc9"></a><span class="line-added"> 441 </span>
<span class="line-added"> 442   // Start a new sub-record. Starts a new heap dump segment if needed.</span>
<span class="line-added"> 443   void start_sub_record(u1 tag, u4 len);</span>
<span class="line-added"> 444   // Ends the current sub-record.</span>
<span class="line-added"> 445   void end_sub_record();</span>
<span class="line-added"> 446   // Finishes the current dump segment if not already finished.</span>
<span class="line-added"> 447   void finish_dump_segment();</span>
 448 };
 449 
<a name="10" id="anc10"></a><span class="line-modified"> 450 DumpWriter::DumpWriter(const char* path) : _fd(-1), _bytes_written(0), _pos(0),</span>
<span class="line-added"> 451                                            _in_dump_segment(false), _error(NULL) {</span>
 452   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
 453   // sufficient memory then reduce size until we can allocate something.
<a name="11" id="anc11"></a><span class="line-modified"> 454   _size = io_buffer_max_size;</span>
 455   do {
 456     _buffer = (char*)os::malloc(_size, mtInternal);
 457     if (_buffer == NULL) {
 458       _size = _size &gt;&gt; 1;
 459     }
<a name="12" id="anc12"></a><span class="line-modified"> 460   } while (_buffer == NULL &amp;&amp; _size &gt;= io_buffer_min_size);</span>
<span class="line-modified"> 461 </span>
<span class="line-modified"> 462   if (_buffer == NULL) {</span>
<span class="line-modified"> 463     set_error(&quot;Could not allocate buffer memory for heap dump&quot;);</span>
<span class="line-modified"> 464   } else {</span>
<span class="line-modified"> 465     _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467     // if the open failed we record the error</span>
<span class="line-modified"> 468     if (_fd &lt; 0) {</span>
<span class="line-modified"> 469       set_error(os::strerror(errno));</span>
<span class="line-modified"> 470     }</span>
 471   }
 472 }
 473 
 474 DumpWriter::~DumpWriter() {
<a name="13" id="anc13"></a><span class="line-modified"> 475   close();</span>
<span class="line-modified"> 476   os::free(_buffer);</span>
<span class="line-modified"> 477   os::free(_error);</span>



 478 }
 479 
 480 // closes dump file (if open)
 481 void DumpWriter::close() {
 482   // flush and close dump file
 483   if (is_open()) {
 484     flush();
 485     os::close(file_descriptor());
 486     set_file_descriptor(-1);
 487   }
 488 }
 489 
<a name="14" id="anc14"></a>















 490 // write directly to the file
 491 void DumpWriter::write_internal(void* s, size_t len) {
 492   if (is_open()) {
 493     const char* pos = (char*)s;
 494     ssize_t n = 0;
 495     while (len &gt; 0) {
<a name="15" id="anc15"></a><span class="line-modified"> 496       uint tmp = (uint)MIN2(len, (size_t)INT_MAX);</span>
 497       n = os::write(file_descriptor(), pos, tmp);
 498 
 499       if (n &lt; 0) {
 500         // EINTR cannot happen here, os::write will take care of that
 501         set_error(os::strerror(errno));
 502         os::close(file_descriptor());
 503         set_file_descriptor(-1);
 504         return;
 505       }
 506 
 507       _bytes_written += n;
 508       pos += n;
 509       len -= n;
 510     }
 511   }
 512 }
 513 
 514 // write raw bytes
 515 void DumpWriter::write_raw(void* s, size_t len) {
<a name="16" id="anc16"></a><span class="line-modified"> 516   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);</span>
<span class="line-modified"> 517   debug_only(_sub_record_left -= len);</span>



 518 
<a name="17" id="anc17"></a><span class="line-modified"> 519   // flush buffer to make room</span>
<span class="line-modified"> 520   if (len &gt; buffer_size() - position()) {</span>
<span class="line-added"> 521     assert(!_in_dump_segment || _is_huge_sub_record, &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
<span class="line-added"> 522     flush();</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524     // If larger than the buffer, just write it directly.</span>
<span class="line-added"> 525     if (len &gt; buffer_size()) {</span>
 526       write_internal(s, len);
<a name="18" id="anc18"></a><span class="line-modified"> 527 </span>
<span class="line-modified"> 528       return;</span>


 529     }
 530   }
<a name="19" id="anc19"></a><span class="line-added"> 531 </span>
<span class="line-added"> 532   memcpy(buffer() + position(), s, len);</span>
<span class="line-added"> 533   set_position(position() + len);</span>
 534 }
 535 
 536 // flush any buffered bytes to the file
 537 void DumpWriter::flush() {
<a name="20" id="anc20"></a><span class="line-modified"> 538   write_internal(buffer(), position());</span>
<span class="line-modified"> 539   set_position(0);</span>


























 540 }
 541 
 542 void DumpWriter::write_u2(u2 x) {
 543   u2 v;
 544   Bytes::put_Java_u2((address)&amp;v, x);
 545   write_raw((void*)&amp;v, 2);
 546 }
 547 
 548 void DumpWriter::write_u4(u4 x) {
 549   u4 v;
 550   Bytes::put_Java_u4((address)&amp;v, x);
 551   write_raw((void*)&amp;v, 4);
 552 }
 553 
 554 void DumpWriter::write_u8(u8 x) {
 555   u8 v;
 556   Bytes::put_Java_u8((address)&amp;v, x);
 557   write_raw((void*)&amp;v, 8);
 558 }
 559 
 560 void DumpWriter::write_objectID(oop o) {
<a name="21" id="anc21"></a><span class="line-modified"> 561   address a = cast_from_oop&lt;address&gt;(o);</span>
 562 #ifdef _LP64
 563   write_u8((u8)a);
 564 #else
 565   write_u4((u4)a);
 566 #endif
 567 }
 568 
 569 void DumpWriter::write_symbolID(Symbol* s) {
 570   address a = (address)((uintptr_t)s);
 571 #ifdef _LP64
 572   write_u8((u8)a);
 573 #else
 574   write_u4((u4)a);
 575 #endif
 576 }
 577 
 578 void DumpWriter::write_id(u4 x) {
 579 #ifdef _LP64
 580   write_u8((u8) x);
 581 #else
 582   write_u4(x);
 583 #endif
 584 }
 585 
 586 // We use java mirror as the class ID
 587 void DumpWriter::write_classID(Klass* k) {
 588   write_objectID(k-&gt;java_mirror());
 589 }
 590 
<a name="22" id="anc22"></a><span class="line-added"> 591 void DumpWriter::finish_dump_segment() {</span>
<span class="line-added"> 592   if (_in_dump_segment) {</span>
<span class="line-added"> 593     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);</span>
<span class="line-added"> 594     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last</span>
<span class="line-added"> 597     // (in which case the segment length was already set to the correct value initially).</span>
<span class="line-added"> 598     if (!_is_huge_sub_record) {</span>
<span class="line-added"> 599       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);</span>
<span class="line-added"> 600       Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));</span>
<span class="line-added"> 601     }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603     flush();</span>
<span class="line-added"> 604     _in_dump_segment = false;</span>
<span class="line-added"> 605   }</span>
<span class="line-added"> 606 }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608 void DumpWriter::start_sub_record(u1 tag, u4 len) {</span>
<span class="line-added"> 609   if (!_in_dump_segment) {</span>
<span class="line-added"> 610     if (position() &gt; 0) {</span>
<span class="line-added"> 611       flush();</span>
<span class="line-added"> 612       assert(position() == 0, &quot;Must be at the start&quot;);</span>
<span class="line-added"> 613     }</span>
<span class="line-added"> 614 </span>
<span class="line-added"> 615     write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-added"> 616     write_u4(0); // timestamp</span>
<span class="line-added"> 617     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,</span>
<span class="line-added"> 618     // this is already the correct length, since we don&#39;t add more sub-records.</span>
<span class="line-added"> 619     write_u4(len);</span>
<span class="line-added"> 620     _in_dump_segment = true;</span>
<span class="line-added"> 621     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;</span>
<span class="line-added"> 622   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {</span>
<span class="line-added"> 623     // This object will not fit in completely or the last sub-record was huge.</span>
<span class="line-added"> 624     // Finish the current segement and try again.</span>
<span class="line-added"> 625     finish_dump_segment();</span>
<span class="line-added"> 626     start_sub_record(tag, len);</span>
<span class="line-added"> 627 </span>
<span class="line-added"> 628     return;</span>
<span class="line-added"> 629   }</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631   debug_only(_sub_record_left = len);</span>
<span class="line-added"> 632   debug_only(_sub_record_ended = false);</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634   write_u1(tag);</span>
<span class="line-added"> 635 }</span>
 636 
<a name="23" id="anc23"></a><span class="line-added"> 637 void DumpWriter::end_sub_record() {</span>
<span class="line-added"> 638   assert(_in_dump_segment, &quot;must be in dump segment&quot;);</span>
<span class="line-added"> 639   assert(_sub_record_left == 0, &quot;sub-record not written completely&quot;);</span>
<span class="line-added"> 640   assert(!_sub_record_ended, &quot;Must not have ended yet&quot;);</span>
<span class="line-added"> 641   debug_only(_sub_record_ended = true);</span>
<span class="line-added"> 642 }</span>
 643 
 644 // Support class with a collection of functions used when dumping the heap
 645 
 646 class DumperSupport : AllStatic {
 647  public:
 648 
 649   // write a header of the given type
 650   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 651 
 652   // returns hprof tag for the given type signature
 653   static hprofTag sig2tag(Symbol* sig);
 654   // returns hprof tag for the given basic type
 655   static hprofTag type2tag(BasicType type);
<a name="24" id="anc24"></a><span class="line-added"> 656   // Returns the size of the data to write.</span>
<span class="line-added"> 657   static u4 sig2size(Symbol* sig);</span>
 658 
 659   // returns the size of the instance of the given class
 660   static u4 instance_size(Klass* k);
 661 
 662   // dump a jfloat
 663   static void dump_float(DumpWriter* writer, jfloat f);
 664   // dump a jdouble
 665   static void dump_double(DumpWriter* writer, jdouble d);
 666   // dumps the raw value of the given field
 667   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
<a name="25" id="anc25"></a><span class="line-added"> 668   // returns the size of the static fields; also counts the static fields</span>
<span class="line-added"> 669   static u4 get_static_fields_size(InstanceKlass* ik, u2&amp; field_count);</span>
 670   // dumps static fields of the given class
 671   static void dump_static_fields(DumpWriter* writer, Klass* k);
 672   // dump the raw values of the instance fields of the given object
 673   static void dump_instance_fields(DumpWriter* writer, oop o);
<a name="26" id="anc26"></a><span class="line-added"> 674   // get the count of the instance fields for a given class</span>
<span class="line-added"> 675   static u2 get_instance_fields_count(InstanceKlass* ik);</span>
 676   // dumps the definition of the instance fields for a given class
 677   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 678   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 679   static void dump_instance(DumpWriter* writer, oop o);
 680   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 681   // array classes
 682   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 683   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 684   // class (and each multi-dimensional array class too)
 685   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 686 
 687   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 688   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 689   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 690   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 691   // create HPROF_FRAME record for the given method and bci
 692   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 693 
 694   // check if we need to truncate an array
 695   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 696 
<a name="27" id="anc27"></a>





 697   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 698   static void end_of_dump(DumpWriter* writer);
<a name="28" id="anc28"></a><span class="line-added"> 699 </span>
<span class="line-added"> 700   static oop mask_dormant_archived_object(oop o) {</span>
<span class="line-added"> 701     if (o != NULL &amp;&amp; o-&gt;klass()-&gt;java_mirror() == NULL) {</span>
<span class="line-added"> 702       // Ignore this object since the corresponding java mirror is not loaded.</span>
<span class="line-added"> 703       // Might be a dormant archive object.</span>
<span class="line-added"> 704       return NULL;</span>
<span class="line-added"> 705     } else {</span>
<span class="line-added"> 706       return o;</span>
<span class="line-added"> 707     }</span>
<span class="line-added"> 708   }</span>
 709 };
 710 
 711 // write a header of the given type
 712 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 713   writer-&gt;write_u1((u1)tag);
 714   writer-&gt;write_u4(0);                  // current ticks
 715   writer-&gt;write_u4(len);
 716 }
 717 
 718 // returns hprof tag for the given type signature
 719 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 720   switch (sig-&gt;char_at(0)) {
 721     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 722     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 723     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 724     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 725     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 726     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 727     case JVM_SIGNATURE_INT      : return HPROF_INT;
 728     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 729     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 730     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 731     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 732   }
 733 }
 734 
 735 hprofTag DumperSupport::type2tag(BasicType type) {
 736   switch (type) {
 737     case T_BYTE     : return HPROF_BYTE;
 738     case T_CHAR     : return HPROF_CHAR;
 739     case T_FLOAT    : return HPROF_FLOAT;
 740     case T_DOUBLE   : return HPROF_DOUBLE;
 741     case T_INT      : return HPROF_INT;
 742     case T_LONG     : return HPROF_LONG;
 743     case T_SHORT    : return HPROF_SHORT;
 744     case T_BOOLEAN  : return HPROF_BOOLEAN;
 745     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 746   }
 747 }
 748 
<a name="29" id="anc29"></a><span class="line-added"> 749 u4 DumperSupport::sig2size(Symbol* sig) {</span>
<span class="line-added"> 750   switch (sig-&gt;char_at(0)) {</span>
<span class="line-added"> 751     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added"> 752     case JVM_SIGNATURE_ARRAY: return sizeof(address);</span>
<span class="line-added"> 753     case JVM_SIGNATURE_BOOLEAN:</span>
<span class="line-added"> 754     case JVM_SIGNATURE_BYTE: return 1;</span>
<span class="line-added"> 755     case JVM_SIGNATURE_SHORT:</span>
<span class="line-added"> 756     case JVM_SIGNATURE_CHAR: return 2;</span>
<span class="line-added"> 757     case JVM_SIGNATURE_INT:</span>
<span class="line-added"> 758     case JVM_SIGNATURE_FLOAT: return 4;</span>
<span class="line-added"> 759     case JVM_SIGNATURE_LONG:</span>
<span class="line-added"> 760     case JVM_SIGNATURE_DOUBLE: return 8;</span>
<span class="line-added"> 761     default: ShouldNotReachHere(); /* to shut up compiler */ return 0;</span>
<span class="line-added"> 762   }</span>
<span class="line-added"> 763 }</span>
<span class="line-added"> 764 </span>
 765 // dump a jfloat
 766 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 767   if (g_isnan(f)) {
 768     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 769   } else {
 770     union {
 771       int i;
 772       float f;
 773     } u;
 774     u.f = (float)f;
 775     writer-&gt;write_u4((u4)u.i);
 776   }
 777 }
 778 
 779 // dump a jdouble
 780 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 781   union {
 782     jlong l;
 783     double d;
 784   } u;
 785   if (g_isnan(d)) {                 // collapsing NaNs
 786     u.l = (jlong)(0x7ff80000);
 787     u.l = (u.l &lt;&lt; 32);
 788   } else {
 789     u.d = (double)d;
 790   }
 791   writer-&gt;write_u8((u8)u.l);
 792 }
 793 
 794 // dumps the raw value of the given field
 795 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 796   switch (type) {
 797     case JVM_SIGNATURE_CLASS :
 798     case JVM_SIGNATURE_ARRAY : {
<a name="30" id="anc30"></a><span class="line-modified"> 799       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;(offset);</span>
<span class="line-added"> 800       if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added"> 801         ResourceMark rm;</span>
<span class="line-added"> 802         log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added"> 803                              p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added"> 804                              p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added"> 805       }</span>
<span class="line-added"> 806       o = mask_dormant_archived_object(o);</span>
 807       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 808       writer-&gt;write_objectID(o);
 809       break;
 810     }
 811     case JVM_SIGNATURE_BYTE : {
 812       jbyte b = obj-&gt;byte_field(offset);
 813       writer-&gt;write_u1((u1)b);
 814       break;
 815     }
 816     case JVM_SIGNATURE_CHAR : {
 817       jchar c = obj-&gt;char_field(offset);
 818       writer-&gt;write_u2((u2)c);
 819       break;
 820     }
 821     case JVM_SIGNATURE_SHORT : {
 822       jshort s = obj-&gt;short_field(offset);
 823       writer-&gt;write_u2((u2)s);
 824       break;
 825     }
 826     case JVM_SIGNATURE_FLOAT : {
 827       jfloat f = obj-&gt;float_field(offset);
 828       dump_float(writer, f);
 829       break;
 830     }
 831     case JVM_SIGNATURE_DOUBLE : {
 832       jdouble d = obj-&gt;double_field(offset);
 833       dump_double(writer, d);
 834       break;
 835     }
 836     case JVM_SIGNATURE_INT : {
 837       jint i = obj-&gt;int_field(offset);
 838       writer-&gt;write_u4((u4)i);
 839       break;
 840     }
 841     case JVM_SIGNATURE_LONG : {
 842       jlong l = obj-&gt;long_field(offset);
 843       writer-&gt;write_u8((u8)l);
 844       break;
 845     }
 846     case JVM_SIGNATURE_BOOLEAN : {
 847       jboolean b = obj-&gt;bool_field(offset);
 848       writer-&gt;write_u1((u1)b);
 849       break;
 850     }
 851     default : {
 852       ShouldNotReachHere();
 853       break;
 854     }
 855   }
 856 }
 857 
 858 // returns the size of the instance of the given class
 859 u4 DumperSupport::instance_size(Klass* k) {
 860   HandleMark hm;
 861   InstanceKlass* ik = InstanceKlass::cast(k);
<a name="31" id="anc31"></a>
 862   u4 size = 0;
 863 
 864   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 865     if (!fld.access_flags().is_static()) {
<a name="32" id="anc32"></a><span class="line-modified"> 866       size += sig2size(fld.signature());</span>


















 867     }
 868   }
 869   return size;
 870 }
 871 
<a name="33" id="anc33"></a><span class="line-modified"> 872 u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2&amp; field_count) {</span>

 873   HandleMark hm;
<a name="34" id="anc34"></a><span class="line-modified"> 874   field_count = 0;</span>
<span class="line-added"> 875   u4 size = 0;</span>
 876 
<a name="35" id="anc35"></a>

 877   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<a name="36" id="anc36"></a><span class="line-modified"> 878     if (fldc.access_flags().is_static()) {</span>
<span class="line-added"> 879       field_count++;</span>
<span class="line-added"> 880       size += sig2size(fldc.signature());</span>
<span class="line-added"> 881     }</span>
 882   }
 883 
 884   // Add in resolved_references which is referenced by the cpCache
 885   // The resolved_references is an array per InstanceKlass holding the
 886   // strings and other oops resolved from the constant pool.
 887   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 888   if (resolved_references != NULL) {
 889     field_count++;
<a name="37" id="anc37"></a><span class="line-added"> 890     size += sizeof(address);</span>
 891 
 892     // Add in the resolved_references of the used previous versions of the class
 893     // in the case of RedefineClasses
 894     InstanceKlass* prev = ik-&gt;previous_versions();
 895     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 896       field_count++;
<a name="38" id="anc38"></a><span class="line-added"> 897       size += sizeof(address);</span>
 898       prev = prev-&gt;previous_versions();
 899     }
 900   }
 901 
 902   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 903   // arrays.
 904   oop init_lock = ik-&gt;init_lock();
 905   if (init_lock != NULL) {
 906     field_count++;
<a name="39" id="anc39"></a><span class="line-added"> 907     size += sizeof(address);</span>
 908   }
 909 
<a name="40" id="anc40"></a><span class="line-modified"> 910   // We write the value itself plus a name and a one byte type tag per field.</span>
<span class="line-added"> 911   return size + field_count * (sizeof(address) + 1);</span>
<span class="line-added"> 912 }</span>
 913 
<a name="41" id="anc41"></a><span class="line-modified"> 914 // dumps static fields of the given class</span>
<span class="line-added"> 915 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
<span class="line-added"> 916   HandleMark hm;</span>
<span class="line-added"> 917   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919   // dump the field descriptors and raw values</span>
 920   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 921     if (fld.access_flags().is_static()) {
 922       Symbol* sig = fld.signature();
 923 
 924       writer-&gt;write_symbolID(fld.name());   // name
 925       writer-&gt;write_u1(sig2tag(sig));       // type
 926 
 927       // value
 928       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 929     }
 930   }
 931 
 932   // Add resolved_references for each class that has them
<a name="42" id="anc42"></a><span class="line-added"> 933   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();</span>
 934   if (resolved_references != NULL) {
 935     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 936     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 937     writer-&gt;write_objectID(resolved_references);
 938 
 939     // Also write any previous versions
 940     InstanceKlass* prev = ik-&gt;previous_versions();
 941     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 942       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 943       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 944       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 945       prev = prev-&gt;previous_versions();
 946     }
 947   }
 948 
 949   // Add init lock to the end if the class is not yet initialized
<a name="43" id="anc43"></a><span class="line-added"> 950   oop init_lock = ik-&gt;init_lock();</span>
 951   if (init_lock != NULL) {
 952     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 953     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 954     writer-&gt;write_objectID(init_lock);
 955   }
 956 }
 957 
 958 // dump the raw values of the instance fields of the given object
 959 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
 960   HandleMark hm;
 961   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 962 
 963   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 964     if (!fld.access_flags().is_static()) {
 965       Symbol* sig = fld.signature();
 966       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 967     }
 968   }
 969 }
 970 
 971 // dumps the definition of the instance fields for a given class
<a name="44" id="anc44"></a><span class="line-modified"> 972 u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {</span>
 973   HandleMark hm;
<a name="45" id="anc45"></a>


 974   u2 field_count = 0;
<a name="46" id="anc46"></a><span class="line-added"> 975 </span>
 976   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 977     if (!fldc.access_flags().is_static()) field_count++;
 978   }
 979 
<a name="47" id="anc47"></a><span class="line-modified"> 980   return field_count;</span>
<span class="line-added"> 981 }</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983 // dumps the definition of the instance fields for a given class</span>
<span class="line-added"> 984 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
<span class="line-added"> 985   HandleMark hm;</span>
<span class="line-added"> 986   InstanceKlass* ik = InstanceKlass::cast(k);</span>
 987 
<a name="48" id="anc48"></a><span class="line-modified"> 988   // dump the field descriptors</span>
 989   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 990     if (!fld.access_flags().is_static()) {
 991       Symbol* sig = fld.signature();
 992 
 993       writer-&gt;write_symbolID(fld.name());   // name
 994       writer-&gt;write_u1(sig2tag(sig));       // type
 995     }
 996   }
 997 }
 998 
 999 // creates HPROF_GC_INSTANCE_DUMP record for the given object
1000 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<a name="49" id="anc49"></a><span class="line-modified">1001   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());</span>
<span class="line-added">1002   u4 is = instance_size(ik);</span>
<span class="line-added">1003   u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;</span>
1004 
<a name="50" id="anc50"></a><span class="line-modified">1005   writer-&gt;start_sub_record(HPROF_GC_INSTANCE_DUMP, size);</span>
1006   writer-&gt;write_objectID(o);
1007   writer-&gt;write_u4(STACK_TRACE_ID);
1008 
1009   // class ID
<a name="51" id="anc51"></a><span class="line-modified">1010   writer-&gt;write_classID(ik);</span>
1011 
1012   // number of bytes that follow
<a name="52" id="anc52"></a><span class="line-modified">1013   writer-&gt;write_u4(is);</span>
1014 
1015   // field values
1016   dump_instance_fields(writer, o);
<a name="53" id="anc53"></a><span class="line-added">1017 </span>
<span class="line-added">1018   writer-&gt;end_sub_record();</span>
1019 }
1020 
1021 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
1022 // its array classes
1023 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
1024   InstanceKlass* ik = InstanceKlass::cast(k);
1025 
1026   // We can safepoint and do a heap dump at a point where we have a Klass,
1027   // but no java mirror class has been setup for it. So we need to check
1028   // that the class is at least loaded, to avoid crash from a null mirror.
1029   if (!ik-&gt;is_loaded()) {
1030     return;
1031   }
1032 
<a name="54" id="anc54"></a><span class="line-modified">1033   u2 static_fields_count = 0;</span>
<span class="line-added">1034   u4 static_size = get_static_fields_size(ik, static_fields_count);</span>
<span class="line-added">1035   u2 instance_fields_count = get_instance_fields_count(ik);</span>
<span class="line-added">1036   u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);</span>
<span class="line-added">1037   u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;</span>
<span class="line-added">1038 </span>
<span class="line-added">1039   writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
1040 
1041   // class ID
1042   writer-&gt;write_classID(ik);
1043   writer-&gt;write_u4(STACK_TRACE_ID);
1044 
1045   // super class ID
1046   InstanceKlass* java_super = ik-&gt;java_super();
1047   if (java_super == NULL) {
1048     writer-&gt;write_objectID(oop(NULL));
1049   } else {
1050     writer-&gt;write_classID(java_super);
1051   }
1052 
1053   writer-&gt;write_objectID(ik-&gt;class_loader());
1054   writer-&gt;write_objectID(ik-&gt;signers());
1055   writer-&gt;write_objectID(ik-&gt;protection_domain());
1056 
1057   // reserved
1058   writer-&gt;write_objectID(oop(NULL));
1059   writer-&gt;write_objectID(oop(NULL));
1060 
1061   // instance size
<a name="55" id="anc55"></a><span class="line-modified">1062   writer-&gt;write_u4(DumperSupport::instance_size(ik));</span>
1063 
1064   // size of constant pool - ignored by HAT 1.1
1065   writer-&gt;write_u2(0);
1066 
<a name="56" id="anc56"></a><span class="line-modified">1067   // static fields</span>
<span class="line-modified">1068   writer-&gt;write_u2(static_fields_count);</span>
<span class="line-added">1069   dump_static_fields(writer, ik);</span>
1070 
1071   // description of instance fields
<a name="57" id="anc57"></a><span class="line-modified">1072   writer-&gt;write_u2(instance_fields_count);</span>
<span class="line-added">1073   dump_instance_field_descriptors(writer, ik);</span>
<span class="line-added">1074 </span>
<span class="line-added">1075   writer-&gt;end_sub_record();</span>
1076 
1077   // array classes
<a name="58" id="anc58"></a><span class="line-modified">1078   k = ik-&gt;array_klass_or_null();</span>
1079   while (k != NULL) {
<a name="59" id="anc59"></a><span class="line-modified">1080     assert(k-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>

1081 
<a name="60" id="anc60"></a><span class="line-modified">1082     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-modified">1083     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
<span class="line-added">1084     writer-&gt;write_classID(k);</span>
1085     writer-&gt;write_u4(STACK_TRACE_ID);
1086 
1087     // super class of array classes is java.lang.Object
<a name="61" id="anc61"></a><span class="line-modified">1088     java_super = k-&gt;java_super();</span>
1089     assert(java_super != NULL, &quot;checking&quot;);
1090     writer-&gt;write_classID(java_super);
1091 
1092     writer-&gt;write_objectID(ik-&gt;class_loader());
1093     writer-&gt;write_objectID(ik-&gt;signers());
1094     writer-&gt;write_objectID(ik-&gt;protection_domain());
1095 
1096     writer-&gt;write_objectID(oop(NULL));    // reserved
1097     writer-&gt;write_objectID(oop(NULL));
1098     writer-&gt;write_u4(0);             // instance size
1099     writer-&gt;write_u2(0);             // constant pool
1100     writer-&gt;write_u2(0);             // static fields
1101     writer-&gt;write_u2(0);             // instance fields
1102 
<a name="62" id="anc62"></a><span class="line-added">1103     writer-&gt;end_sub_record();</span>
<span class="line-added">1104 </span>
1105     // get the array class for the next rank
<a name="63" id="anc63"></a><span class="line-modified">1106     k = k-&gt;array_klass_or_null();</span>
1107   }
1108 }
1109 
1110 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1111 // class (and each multi-dimensional array class too)
1112 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1113  // array classes
1114  while (k != NULL) {
1115     Klass* klass = k;
1116 
<a name="64" id="anc64"></a><span class="line-modified">1117     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;</span>
<span class="line-added">1118     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);</span>
1119     writer-&gt;write_classID(klass);
1120     writer-&gt;write_u4(STACK_TRACE_ID);
1121 
1122     // super class of array classes is java.lang.Object
1123     InstanceKlass* java_super = klass-&gt;java_super();
1124     assert(java_super != NULL, &quot;checking&quot;);
1125     writer-&gt;write_classID(java_super);
1126 
1127     writer-&gt;write_objectID(oop(NULL));    // loader
1128     writer-&gt;write_objectID(oop(NULL));    // signers
1129     writer-&gt;write_objectID(oop(NULL));    // protection domain
1130 
1131     writer-&gt;write_objectID(oop(NULL));    // reserved
1132     writer-&gt;write_objectID(oop(NULL));
1133     writer-&gt;write_u4(0);             // instance size
1134     writer-&gt;write_u2(0);             // constant pool
1135     writer-&gt;write_u2(0);             // static fields
1136     writer-&gt;write_u2(0);             // instance fields
1137 
<a name="65" id="anc65"></a><span class="line-added">1138     writer-&gt;end_sub_record();</span>
<span class="line-added">1139 </span>
1140     // get the array class for the next rank
1141     k = klass-&gt;array_klass_or_null();
1142   }
1143 }
1144 
1145 // Hprof uses an u4 as record length field,
1146 // which means we need to truncate arrays that are too long.
1147 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1148   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1149   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1150 
1151   int length = array-&gt;length();
1152 
1153   int type_size;
1154   if (type == T_OBJECT) {
1155     type_size = sizeof(address);
1156   } else {
1157     type_size = type2aelembytes(type);
1158   }
1159 
1160   size_t length_in_bytes = (size_t)length * type_size;
<a name="66" id="anc66"></a><span class="line-added">1161   uint max_bytes = max_juint - header_size;</span>
1162 
<a name="67" id="anc67"></a>















1163   if (length_in_bytes &gt; max_bytes) {
1164     length = max_bytes / type_size;
1165     length_in_bytes = (size_t)length * type_size;
1166 
1167     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1168             type2name_tab[type], array-&gt;length(), length);
1169   }
1170   return length;
1171 }
1172 
1173 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1174 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1175   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1176   short header_size = 1 + 2 * 4 + 2 * sizeof(address);
<a name="68" id="anc68"></a>
1177   int length = calculate_array_max_length(writer, array, header_size);
<a name="69" id="anc69"></a><span class="line-added">1178   u4 size = header_size + length * sizeof(address);</span>
1179 
<a name="70" id="anc70"></a><span class="line-modified">1180   writer-&gt;start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);</span>
1181   writer-&gt;write_objectID(array);
1182   writer-&gt;write_u4(STACK_TRACE_ID);
1183   writer-&gt;write_u4(length);
1184 
1185   // array class ID
1186   writer-&gt;write_classID(array-&gt;klass());
1187 
1188   // [id]* elements
1189   for (int index = 0; index &lt; length; index++) {
1190     oop o = array-&gt;obj_at(index);
<a name="71" id="anc71"></a><span class="line-added">1191     if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">1192       ResourceMark rm;</span>
<span class="line-added">1193       log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,</span>
<span class="line-added">1194                            p2i(o), o-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">1195                            p2i(array), array-&gt;klass()-&gt;external_name());</span>
<span class="line-added">1196     }</span>
<span class="line-added">1197     o = mask_dormant_archived_object(o);</span>
1198     writer-&gt;write_objectID(o);
1199   }
<a name="72" id="anc72"></a><span class="line-added">1200 </span>
<span class="line-added">1201   writer-&gt;end_sub_record();</span>
1202 }
1203 
1204 #define WRITE_ARRAY(Array, Type, Size, Length) \
1205   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1206 
1207 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1208 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1209   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1210 
1211   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1212   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1213 
1214   int length = calculate_array_max_length(writer, array, header_size);
1215   int type_size = type2aelembytes(type);
1216   u4 length_in_bytes = (u4)length * type_size;
<a name="73" id="anc73"></a><span class="line-added">1217   u4 size = header_size + length_in_bytes;</span>
1218 
<a name="74" id="anc74"></a><span class="line-modified">1219   writer-&gt;start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);</span>
1220   writer-&gt;write_objectID(array);
1221   writer-&gt;write_u4(STACK_TRACE_ID);
1222   writer-&gt;write_u4(length);
1223   writer-&gt;write_u1(type2tag(type));
1224 
1225   // nothing to copy
1226   if (length == 0) {
<a name="75" id="anc75"></a><span class="line-added">1227     writer-&gt;end_sub_record();</span>
1228     return;
1229   }
1230 
1231   // If the byte ordering is big endian then we can copy most types directly
1232 
1233   switch (type) {
1234     case T_INT : {
1235       if (Endian::is_Java_byte_ordering_different()) {
1236         WRITE_ARRAY(array, int, u4, length);
1237       } else {
1238         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1239       }
1240       break;
1241     }
1242     case T_BYTE : {
1243       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1244       break;
1245     }
1246     case T_CHAR : {
1247       if (Endian::is_Java_byte_ordering_different()) {
1248         WRITE_ARRAY(array, char, u2, length);
1249       } else {
1250         writer-&gt;write_raw((void*)(array-&gt;char_at_addr(0)), length_in_bytes);
1251       }
1252       break;
1253     }
1254     case T_SHORT : {
1255       if (Endian::is_Java_byte_ordering_different()) {
1256         WRITE_ARRAY(array, short, u2, length);
1257       } else {
1258         writer-&gt;write_raw((void*)(array-&gt;short_at_addr(0)), length_in_bytes);
1259       }
1260       break;
1261     }
1262     case T_BOOLEAN : {
1263       if (Endian::is_Java_byte_ordering_different()) {
1264         WRITE_ARRAY(array, bool, u1, length);
1265       } else {
1266         writer-&gt;write_raw((void*)(array-&gt;bool_at_addr(0)), length_in_bytes);
1267       }
1268       break;
1269     }
1270     case T_LONG : {
1271       if (Endian::is_Java_byte_ordering_different()) {
1272         WRITE_ARRAY(array, long, u8, length);
1273       } else {
1274         writer-&gt;write_raw((void*)(array-&gt;long_at_addr(0)), length_in_bytes);
1275       }
1276       break;
1277     }
1278 
1279     // handle float/doubles in a special value to ensure than NaNs are
1280     // written correctly. TO DO: Check if we can avoid this on processors that
1281     // use IEEE 754.
1282 
1283     case T_FLOAT : {
1284       for (int i = 0; i &lt; length; i++) {
1285         dump_float(writer, array-&gt;float_at(i));
1286       }
1287       break;
1288     }
1289     case T_DOUBLE : {
1290       for (int i = 0; i &lt; length; i++) {
1291         dump_double(writer, array-&gt;double_at(i));
1292       }
1293       break;
1294     }
1295     default : ShouldNotReachHere();
1296   }
<a name="76" id="anc76"></a><span class="line-added">1297 </span>
<span class="line-added">1298   writer-&gt;end_sub_record();</span>
1299 }
1300 
1301 // create a HPROF_FRAME record of the given Method* and bci
1302 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1303                                      int frame_serial_num,
1304                                      int class_serial_num,
1305                                      Method* m,
1306                                      int bci) {
1307   int line_number;
1308   if (m-&gt;is_native()) {
1309     line_number = -3;  // native frame
1310   } else {
1311     line_number = m-&gt;line_number_from_bci(bci);
1312   }
1313 
1314   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1315   writer-&gt;write_id(frame_serial_num);               // frame serial number
1316   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1317   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1318 
1319   assert(m-&gt;method_holder()-&gt;is_instance_klass(), &quot;not InstanceKlass&quot;);
1320   writer-&gt;write_symbolID(m-&gt;method_holder()-&gt;source_file_name());  // source file name
1321   writer-&gt;write_u4(class_serial_num);               // class serial number
1322   writer-&gt;write_u4((u4) line_number);               // line number
1323 }
1324 
1325 
1326 // Support class used to generate HPROF_UTF8 records from the entries in the
1327 // SymbolTable.
1328 
1329 class SymbolTableDumper : public SymbolClosure {
1330  private:
1331   DumpWriter* _writer;
1332   DumpWriter* writer() const                { return _writer; }
1333  public:
1334   SymbolTableDumper(DumpWriter* writer)     { _writer = writer; }
1335   void do_symbol(Symbol** p);
1336 };
1337 
1338 void SymbolTableDumper::do_symbol(Symbol** p) {
1339   ResourceMark rm;
1340   Symbol* sym = load_symbol(p);
1341   int len = sym-&gt;utf8_length();
1342   if (len &gt; 0) {
1343     char* s = sym-&gt;as_utf8();
1344     DumperSupport::write_header(writer(), HPROF_UTF8, oopSize + len);
1345     writer()-&gt;write_symbolID(sym);
1346     writer()-&gt;write_raw(s, len);
1347   }
1348 }
1349 
1350 // Support class used to generate HPROF_GC_ROOT_JNI_LOCAL records
1351 
1352 class JNILocalsDumper : public OopClosure {
1353  private:
1354   DumpWriter* _writer;
1355   u4 _thread_serial_num;
1356   int _frame_num;
1357   DumpWriter* writer() const                { return _writer; }
1358  public:
1359   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1360     _writer = writer;
1361     _thread_serial_num = thread_serial_num;
1362     _frame_num = -1;  // default - empty stack
1363   }
1364   void set_frame_number(int n) { _frame_num = n; }
1365   void do_oop(oop* obj_p);
1366   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1367 };
1368 
1369 
1370 void JNILocalsDumper::do_oop(oop* obj_p) {
1371   // ignore null handles
1372   oop o = *obj_p;
1373   if (o != NULL) {
<a name="77" id="anc77"></a><span class="line-modified">1374     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1375     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);</span>
1376     writer()-&gt;write_objectID(o);
1377     writer()-&gt;write_u4(_thread_serial_num);
1378     writer()-&gt;write_u4((u4)_frame_num);
<a name="78" id="anc78"></a><span class="line-added">1379     writer()-&gt;end_sub_record();</span>
1380   }
1381 }
1382 
1383 
1384 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1385 
1386 class JNIGlobalsDumper : public OopClosure {
1387  private:
1388   DumpWriter* _writer;
1389   DumpWriter* writer() const                { return _writer; }
1390 
1391  public:
1392   JNIGlobalsDumper(DumpWriter* writer) {
1393     _writer = writer;
1394   }
1395   void do_oop(oop* obj_p);
1396   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1397 };
1398 
1399 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1400   oop o = *obj_p;
1401 
1402   // ignore these
1403   if (o == NULL) return;
1404 
1405   // we ignore global ref to symbols and other internal objects
1406   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<a name="79" id="anc79"></a><span class="line-modified">1407     u4 size = 1 + 2 * sizeof(address);</span>
<span class="line-added">1408     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);</span>
1409     writer()-&gt;write_objectID(o);
1410     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
<a name="80" id="anc80"></a><span class="line-added">1411     writer()-&gt;end_sub_record();</span>
1412   }
1413 };
1414 
1415 
1416 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1417 
1418 class MonitorUsedDumper : public OopClosure {
1419  private:
1420   DumpWriter* _writer;
1421   DumpWriter* writer() const                { return _writer; }
1422  public:
1423   MonitorUsedDumper(DumpWriter* writer) {
1424     _writer = writer;
1425   }
1426   void do_oop(oop* obj_p) {
<a name="81" id="anc81"></a><span class="line-modified">1427     u4 size = 1 + sizeof(address);</span>
<span class="line-added">1428     writer()-&gt;start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);</span>
1429     writer()-&gt;write_objectID(*obj_p);
<a name="82" id="anc82"></a><span class="line-added">1430     writer()-&gt;end_sub_record();</span>
1431   }
1432   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1433 };
1434 
1435 
1436 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1437 
1438 class StickyClassDumper : public KlassClosure {
1439  private:
1440   DumpWriter* _writer;
1441   DumpWriter* writer() const                { return _writer; }
1442  public:
1443   StickyClassDumper(DumpWriter* writer) {
1444     _writer = writer;
1445   }
1446   void do_klass(Klass* k) {
1447     if (k-&gt;is_instance_klass()) {
1448       InstanceKlass* ik = InstanceKlass::cast(k);
<a name="83" id="anc83"></a><span class="line-modified">1449       u4 size = 1 + sizeof(address);</span>
<span class="line-modified">1450       writer()-&gt;start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);</span>
<span class="line-modified">1451       writer()-&gt;write_classID(ik);</span>
<span class="line-added">1452       writer()-&gt;end_sub_record();</span>
1453     }
<a name="84" id="anc84"></a><span class="line-added">1454   }</span>
1455 };
1456 
1457 
1458 class VM_HeapDumper;
1459 
1460 // Support class using when iterating over the heap.
1461 
1462 class HeapObjectDumper : public ObjectClosure {
1463  private:
1464   VM_HeapDumper* _dumper;
1465   DumpWriter* _writer;
1466 
1467   VM_HeapDumper* dumper()               { return _dumper; }
1468   DumpWriter* writer()                  { return _writer; }
1469 
<a name="85" id="anc85"></a>


1470  public:
1471   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1472     _dumper = dumper;
1473     _writer = writer;
1474   }
1475 
1476   // called for each object in the heap
1477   void do_object(oop o);
1478 };
1479 
1480 void HeapObjectDumper::do_object(oop o) {
1481   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1482   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1483     if (!java_lang_Class::is_primitive(o)) {
1484       return;
1485     }
1486   }
1487 
<a name="86" id="anc86"></a><span class="line-added">1488   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {</span>
<span class="line-added">1489     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());</span>
<span class="line-added">1490     return;</span>
<span class="line-added">1491   }</span>
<span class="line-added">1492 </span>
1493   if (o-&gt;is_instance()) {
1494     // create a HPROF_GC_INSTANCE record for each object
1495     DumperSupport::dump_instance(writer(), o);
<a name="87" id="anc87"></a>
1496   } else if (o-&gt;is_objArray()) {
1497     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1498     DumperSupport::dump_object_array(writer(), objArrayOop(o));
<a name="88" id="anc88"></a>
1499   } else if (o-&gt;is_typeArray()) {
1500     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1501     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
<a name="89" id="anc89"></a>
1502   }
1503 }
1504 
1505 // The VM operation that performs the heap dump
1506 class VM_HeapDumper : public VM_GC_Operation {
1507  private:
1508   static VM_HeapDumper* _global_dumper;
1509   static DumpWriter*    _global_writer;
1510   DumpWriter*           _local_writer;
1511   JavaThread*           _oome_thread;
1512   Method*               _oome_constructor;
1513   bool _gc_before_heap_dump;
1514   GrowableArray&lt;Klass*&gt;* _klass_map;
1515   ThreadStackTrace** _stack_traces;
1516   int _num_threads;
1517 
1518   // accessors and setters
1519   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1520   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1521   void set_global_dumper() {
1522     assert(_global_dumper == NULL, &quot;Error&quot;);
1523     _global_dumper = this;
1524   }
1525   void set_global_writer() {
1526     assert(_global_writer == NULL, &quot;Error&quot;);
1527     _global_writer = _local_writer;
1528   }
1529   void clear_global_dumper() { _global_dumper = NULL; }
1530   void clear_global_writer() { _global_writer = NULL; }
1531 
1532   bool skip_operation() const;
1533 
1534   // writes a HPROF_LOAD_CLASS record
1535   class ClassesDo;
1536   static void do_load_class(Klass* k);
1537 
1538   // writes a HPROF_GC_CLASS_DUMP record for the given class
1539   // (and each array class too)
1540   static void do_class_dump(Klass* k);
1541 
1542   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1543   // array (and each multi-dimensional array too)
1544   static void do_basic_type_array_class_dump(Klass* k);
1545 
1546   // HPROF_GC_ROOT_THREAD_OBJ records
1547   int do_thread(JavaThread* thread, u4 thread_serial_num);
1548   void do_threads();
1549 
1550   void add_class_serial_number(Klass* k, int serial_num) {
1551     _klass_map-&gt;at_put_grow(serial_num, k);
1552   }
1553 
1554   // HPROF_TRACE and HPROF_FRAME records
1555   void dump_stack_traces();
1556 
1557  public:
1558   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1559     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1560                     GCCause::_heap_dump /* GC Cause */,
1561                     0 /* total full collections, dummy, ignored */,
1562                     gc_before_heap_dump) {
1563     _local_writer = writer;
1564     _gc_before_heap_dump = gc_before_heap_dump;
1565     _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, true);
1566     _stack_traces = NULL;
1567     _num_threads = 0;
1568     if (oome) {
1569       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1570       // get OutOfMemoryError zero-parameter constructor
1571       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1572       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1573                                                           vmSymbols::void_method_signature());
1574       // get thread throwing OOME when generating the heap dump at OOME
1575       _oome_thread = JavaThread::current();
1576     } else {
1577       _oome_thread = NULL;
1578       _oome_constructor = NULL;
1579     }
1580   }
1581   ~VM_HeapDumper() {
1582     if (_stack_traces != NULL) {
1583       for (int i=0; i &lt; _num_threads; i++) {
1584         delete _stack_traces[i];
1585       }
1586       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1587     }
1588     delete _klass_map;
1589   }
1590 
1591   VMOp_Type type() const { return VMOp_HeapDumper; }
<a name="90" id="anc90"></a>

1592   void doit();
1593 };
1594 
1595 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1596 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1597 
1598 bool VM_HeapDumper::skip_operation() const {
1599   return false;
1600 }
1601 
<a name="91" id="anc91"></a>



















































1602 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1603 void DumperSupport::end_of_dump(DumpWriter* writer) {
<a name="92" id="anc92"></a><span class="line-modified">1604   writer-&gt;finish_dump_segment();</span>







1605 
<a name="93" id="anc93"></a><span class="line-modified">1606   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-modified">1607   writer-&gt;write_u4(0);</span>
<span class="line-modified">1608   writer-&gt;write_u4(0);</span>
1609 }
1610 
1611 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1612 // array classes)
1613 void VM_HeapDumper::do_load_class(Klass* k) {
1614   static u4 class_serial_num = 0;
1615 
1616   // len of HPROF_LOAD_CLASS record
1617   u4 remaining = 2*oopSize + 2*sizeof(u4);
1618 
1619   // write a HPROF_LOAD_CLASS for the class and each array class
1620   do {
1621     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1622 
1623     // class serial number is just a number
1624     writer()-&gt;write_u4(++class_serial_num);
1625 
1626     // class ID
1627     Klass* klass = k;
1628     writer()-&gt;write_classID(klass);
1629 
1630     // add the Klass* and class serial number pair
1631     dumper()-&gt;add_class_serial_number(klass, class_serial_num);
1632 
1633     writer()-&gt;write_u4(STACK_TRACE_ID);
1634 
1635     // class name ID
1636     Symbol* name = klass-&gt;name();
1637     writer()-&gt;write_symbolID(name);
1638 
1639     // write a LOAD_CLASS record for the array type (if it exists)
1640     k = klass-&gt;array_klass_or_null();
1641   } while (k != NULL);
1642 }
1643 
1644 // writes a HPROF_GC_CLASS_DUMP record for the given class
1645 void VM_HeapDumper::do_class_dump(Klass* k) {
1646   if (k-&gt;is_instance_klass()) {
1647     DumperSupport::dump_class_and_array_classes(writer(), k);
1648   }
1649 }
1650 
1651 // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1652 // array (and each multi-dimensional array too)
1653 void VM_HeapDumper::do_basic_type_array_class_dump(Klass* k) {
1654   DumperSupport::dump_basic_type_array_class(writer(), k);
1655 }
1656 
1657 // Walk the stack of the given thread.
1658 // Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local
1659 // Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local
1660 //
1661 // It returns the number of Java frames in this thread stack
1662 int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {
1663   JNILocalsDumper blk(writer(), thread_serial_num);
1664 
1665   oop threadObj = java_thread-&gt;threadObj();
1666   assert(threadObj != NULL, &quot;sanity check&quot;);
1667 
1668   int stack_depth = 0;
1669   if (java_thread-&gt;has_last_Java_frame()) {
1670 
1671     // vframes are resource allocated
1672     Thread* current_thread = Thread::current();
1673     ResourceMark rm(current_thread);
1674     HandleMark hm(current_thread);
1675 
1676     RegisterMap reg_map(java_thread);
1677     frame f = java_thread-&gt;last_frame();
1678     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1679     frame* last_entry_frame = NULL;
1680     int extra_frames = 0;
1681 
1682     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1683       extra_frames++;
1684     }
1685     while (vf != NULL) {
1686       blk.set_frame_number(stack_depth);
1687       if (vf-&gt;is_java_frame()) {
1688 
1689         // java frame (interpreted, compiled, ...)
1690         javaVFrame *jvf = javaVFrame::cast(vf);
1691         if (!(jvf-&gt;method()-&gt;is_native())) {
1692           StackValueCollection* locals = jvf-&gt;locals();
1693           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1694             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1695               oop o = locals-&gt;obj_at(slot)();
1696 
1697               if (o != NULL) {
<a name="94" id="anc94"></a><span class="line-modified">1698                 u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1699                 writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
1700                 writer()-&gt;write_objectID(o);
1701                 writer()-&gt;write_u4(thread_serial_num);
1702                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<a name="95" id="anc95"></a><span class="line-added">1703                 writer()-&gt;end_sub_record();</span>
1704               }
1705             }
1706           }
1707           StackValueCollection *exprs = jvf-&gt;expressions();
1708           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1709             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1710                oop o = exprs-&gt;obj_at(index)();
1711                if (o != NULL) {
<a name="96" id="anc96"></a><span class="line-modified">1712                  u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1713                  writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);</span>
1714                  writer()-&gt;write_objectID(o);
1715                  writer()-&gt;write_u4(thread_serial_num);
1716                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<a name="97" id="anc97"></a><span class="line-added">1717                  writer()-&gt;end_sub_record();</span>
1718                }
1719              }
1720           }
1721         } else {
1722           // native frame
1723           if (stack_depth == 0) {
1724             // JNI locals for the top frame.
1725             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1726           } else {
1727             if (last_entry_frame != NULL) {
1728               // JNI locals for the entry frame
1729               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1730               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1731             }
1732           }
1733         }
1734         // increment only for Java frames
1735         stack_depth++;
1736         last_entry_frame = NULL;
1737 
1738       } else {
1739         // externalVFrame - if it&#39;s an entry frame then report any JNI locals
1740         // as roots when we find the corresponding native javaVFrame
1741         frame* fr = vf-&gt;frame_pointer();
1742         assert(fr != NULL, &quot;sanity check&quot;);
1743         if (fr-&gt;is_entry_frame()) {
1744           last_entry_frame = fr;
1745         }
1746       }
1747       vf = vf-&gt;sender();
1748     }
1749   } else {
1750     // no last java frame but there may be JNI locals
1751     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1752   }
1753   return stack_depth;
1754 }
1755 
1756 
1757 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1758 // the stack so that locals and JNI locals are dumped.
1759 void VM_HeapDumper::do_threads() {
1760   for (int i=0; i &lt; _num_threads; i++) {
1761     JavaThread* thread = _stack_traces[i]-&gt;thread();
1762     oop threadObj = thread-&gt;threadObj();
1763     u4 thread_serial_num = i+1;
1764     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<a name="98" id="anc98"></a><span class="line-modified">1765     u4 size = 1 + sizeof(address) + 4 + 4;</span>
<span class="line-added">1766     writer()-&gt;start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);</span>
1767     writer()-&gt;write_objectID(threadObj);
1768     writer()-&gt;write_u4(thread_serial_num);  // thread number
1769     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
<a name="99" id="anc99"></a><span class="line-added">1770     writer()-&gt;end_sub_record();</span>
1771     int num_frames = do_thread(thread, thread_serial_num);
1772     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1773            &quot;total number of Java frames not matched&quot;);
1774   }
1775 }
1776 
1777 
1778 // The VM operation that dumps the heap. The dump consists of the following
1779 // records:
1780 //
1781 //  HPROF_HEADER
1782 //  [HPROF_UTF8]*
1783 //  [HPROF_LOAD_CLASS]*
1784 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1785 //  [HPROF_GC_CLASS_DUMP]*
1786 //  [HPROF_HEAP_DUMP_SEGMENT]*
1787 //  HPROF_HEAP_DUMP_END
1788 //
1789 // The HPROF_TRACE records represent the stack traces where the heap dump
1790 // is generated and a &quot;dummy trace&quot; record which does not include
1791 // any frames. The dummy trace record is used to be referenced as the
1792 // unknown object alloc site.
1793 //
1794 // Each HPROF_HEAP_DUMP_SEGMENT record has a length followed by sub-records.
1795 // To allow the heap dump be generated in a single pass we remember the position
1796 // of the dump length and fix it up after all sub-records have been written.
1797 // To generate the sub-records we iterate over the heap, writing
1798 // HPROF_GC_INSTANCE_DUMP, HPROF_GC_OBJ_ARRAY_DUMP, and HPROF_GC_PRIM_ARRAY_DUMP
1799 // records as we go. Once that is done we write records for some of the GC
1800 // roots.
1801 
1802 void VM_HeapDumper::doit() {
1803 
1804   HandleMark hm;
1805   CollectedHeap* ch = Universe::heap();
1806 
1807   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1808                                  // not happen (e.g. due to GCLocker)
1809 
1810   if (_gc_before_heap_dump) {
1811     if (GCLocker::is_active()) {
1812       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1813     } else {
1814       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1815     }
1816   }
1817 
1818   // At this point we should be the only dumper active, so
1819   // the following should be safe.
1820   set_global_dumper();
1821   set_global_writer();
1822 
1823   // Write the file header - we always use 1.0.2
1824   size_t used = ch-&gt;used();
1825   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1826 
1827   // header is few bytes long - no chance to overflow int
1828   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1829   writer()-&gt;write_u1(0); // terminator
1830   writer()-&gt;write_u4(oopSize);
<a name="100" id="anc100"></a><span class="line-added">1831   // timestamp is current time in ms</span>
1832   writer()-&gt;write_u8(os::javaTimeMillis());
1833 
1834   // HPROF_UTF8 records
1835   SymbolTableDumper sym_dumper(writer());
1836   SymbolTable::symbols_do(&amp;sym_dumper);
1837 
1838   // write HPROF_LOAD_CLASS records
1839   {
1840     LockedClassesDo locked_load_classes(&amp;do_load_class);
1841     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1842   }
1843   Universe::basic_type_classes_do(&amp;do_load_class);
1844 
1845   // write HPROF_FRAME and HPROF_TRACE records
1846   // this must be called after _klass_map is built when iterating the classes above.
1847   dump_stack_traces();
1848 
<a name="101" id="anc101"></a>


1849   // Writes HPROF_GC_CLASS_DUMP records
1850   {
1851     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1852     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1853   }
1854   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
<a name="102" id="anc102"></a>
1855 
1856   // writes HPROF_GC_INSTANCE_DUMP records.
1857   // After each sub-record is written check_segment_length will be invoked
1858   // to check if the current segment exceeds a threshold. If so, a new
1859   // segment is started.
1860   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1861   // of the heap dump.
1862   HeapObjectDumper obj_dumper(this, writer());
<a name="103" id="anc103"></a><span class="line-modified">1863   Universe::heap()-&gt;object_iterate(&amp;obj_dumper);</span>
1864 
1865   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1866   do_threads();
<a name="104" id="anc104"></a>
1867 
1868   // HPROF_GC_ROOT_MONITOR_USED
1869   MonitorUsedDumper mon_dumper(writer());
1870   ObjectSynchronizer::oops_do(&amp;mon_dumper);
<a name="105" id="anc105"></a>
1871 
1872   // HPROF_GC_ROOT_JNI_GLOBAL
1873   JNIGlobalsDumper jni_dumper(writer());
1874   JNIHandles::oops_do(&amp;jni_dumper);
1875   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1876                                    // for things like preallocated throwable backtraces
<a name="106" id="anc106"></a>
1877 
1878   // HPROF_GC_ROOT_STICKY_CLASS
1879   // These should be classes in the NULL class loader data, and not all classes
1880   // if !ClassUnloading
1881   StickyClassDumper class_dumper(writer());
1882   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1883 
<a name="107" id="anc107"></a><span class="line-modified">1884   // Writes the HPROF_HEAP_DUMP_END record.</span>
1885   DumperSupport::end_of_dump(writer());
1886 
1887   // Now we clear the global variables, so that a future dumper might run.
1888   clear_global_dumper();
1889   clear_global_writer();
1890 }
1891 
1892 void VM_HeapDumper::dump_stack_traces() {
1893   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1894   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1895   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1896   writer()-&gt;write_u4(0);                    // thread number
1897   writer()-&gt;write_u4(0);                    // frame count
1898 
1899   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1900   int frame_serial_num = 0;
1901   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1902     oop threadObj = thread-&gt;threadObj();
1903     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1904       // dump thread stack trace
1905       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1906       stack_trace-&gt;dump_stack_at_safepoint(-1);
1907       _stack_traces[_num_threads++] = stack_trace;
1908 
1909       // write HPROF_FRAME records for this thread&#39;s stack trace
1910       int depth = stack_trace-&gt;get_stack_depth();
1911       int thread_frame_start = frame_serial_num;
1912       int extra_frames = 0;
1913       // write fake frame that makes it look like the thread, which caused OOME,
1914       // is in the OutOfMemoryError zero-parameter constructor
1915       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1916         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1917         // the class serial number starts from 1
1918         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1919         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1920                                         _oome_constructor, 0);
1921         extra_frames++;
1922       }
1923       for (int j=0; j &lt; depth; j++) {
1924         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
1925         Method* m = frame-&gt;method();
1926         int class_serial_num = _klass_map-&gt;find(m-&gt;method_holder());
1927         // the class serial number starts from 1
1928         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1929         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1930       }
1931       depth += extra_frames;
1932 
1933       // write HPROF_TRACE record for one thread
1934       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1935       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1936       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1937       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1938       writer()-&gt;write_u4(depth);                 // frame count
1939       for (int j=1; j &lt;= depth; j++) {
1940         writer()-&gt;write_id(thread_frame_start + j);
1941       }
1942     }
1943   }
1944 }
1945 
1946 // dump the heap to given path.
<a name="108" id="anc108"></a><span class="line-modified">1947 int HeapDumper::dump(const char* path, outputStream* out) {</span>
1948   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1949 
1950   // print message in interactive case
<a name="109" id="anc109"></a><span class="line-modified">1951   if (out != NULL) {</span>
<span class="line-modified">1952     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
1953     timer()-&gt;start();
1954   }
1955 
<a name="110" id="anc110"></a><span class="line-added">1956   // create JFR event</span>
<span class="line-added">1957   EventHeapDump event;</span>
<span class="line-added">1958 </span>
1959   // create the dump writer. If the file can be opened then bail
1960   DumpWriter writer(path);
<a name="111" id="anc111"></a><span class="line-modified">1961   if (writer.error() != NULL) {</span>
1962     set_error(writer.error());
<a name="112" id="anc112"></a><span class="line-modified">1963     if (out != NULL) {</span>
<span class="line-modified">1964       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
1965         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1966     }
1967     return -1;
1968   }
1969 
1970   // generate the dump
1971   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1972   if (Thread::current()-&gt;is_VM_thread()) {
1973     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1974     dumper.doit();
1975   } else {
1976     VMThread::execute(&amp;dumper);
1977   }
1978 
1979   // close dump file and record any error that the writer may have encountered
1980   writer.close();
1981   set_error(writer.error());
1982 
<a name="113" id="anc113"></a><span class="line-added">1983   // emit JFR event</span>
<span class="line-added">1984   if (error() == NULL) {</span>
<span class="line-added">1985     event.set_destination(path);</span>
<span class="line-added">1986     event.set_gcBeforeDump(_gc_before_heap_dump);</span>
<span class="line-added">1987     event.set_size(writer.bytes_written());</span>
<span class="line-added">1988     event.set_onOutOfMemoryError(_oome);</span>
<span class="line-added">1989     event.commit();</span>
<span class="line-added">1990   }</span>
<span class="line-added">1991 </span>
1992   // print message in interactive case
<a name="114" id="anc114"></a><span class="line-modified">1993   if (out != NULL) {</span>
1994     timer()-&gt;stop();
1995     if (error() == NULL) {
<a name="115" id="anc115"></a><span class="line-modified">1996       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
1997                     writer.bytes_written(), timer()-&gt;seconds());
1998     } else {
<a name="116" id="anc116"></a><span class="line-modified">1999       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
2000     }
2001   }
2002 
2003   return (writer.error() == NULL) ? 0 : -1;
2004 }
2005 
2006 // stop timer (if still active), and free any error string we might be holding
2007 HeapDumper::~HeapDumper() {
2008   if (timer()-&gt;is_active()) {
2009     timer()-&gt;stop();
2010   }
2011   set_error(NULL);
2012 }
2013 
2014 
2015 // returns the error string (resource allocated), or NULL
2016 char* HeapDumper::error_as_C_string() const {
2017   if (error() != NULL) {
2018     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2019     strcpy(str, error());
2020     return str;
2021   } else {
2022     return NULL;
2023   }
2024 }
2025 
2026 // set the error string
2027 void HeapDumper::set_error(char* error) {
2028   if (_error != NULL) {
2029     os::free(_error);
2030   }
2031   if (error == NULL) {
2032     _error = NULL;
2033   } else {
2034     _error = os::strdup(error);
2035     assert(_error != NULL, &quot;allocation failure&quot;);
2036   }
2037 }
2038 
2039 // Called by out-of-memory error reporting by a single Java thread
2040 // outside of a JVM safepoint
2041 void HeapDumper::dump_heap_from_oome() {
2042   HeapDumper::dump_heap(true);
2043 }
2044 
2045 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2046 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2047 // callers are strictly serialized and guaranteed not to interfere below. For more
2048 // general use, however, this method will need modification to prevent
2049 // inteference when updating the static variables base_path and dump_file_seq below.
2050 void HeapDumper::dump_heap() {
2051   HeapDumper::dump_heap(false);
2052 }
2053 
2054 void HeapDumper::dump_heap(bool oome) {
2055   static char base_path[JVM_MAXPATHLEN] = {&#39;\0&#39;};
2056   static uint dump_file_seq = 0;
2057   char* my_path;
2058   const int max_digit_chars = 20;
2059 
2060   const char* dump_file_name = &quot;java_pid&quot;;
2061   const char* dump_file_ext  = &quot;.hprof&quot;;
2062 
2063   // The dump file defaults to java_pid&lt;pid&gt;.hprof in the current working
2064   // directory. HeapDumpPath=&lt;file&gt; can be used to specify an alternative
2065   // dump file name or a directory where dump file is created.
2066   if (dump_file_seq == 0) { // first time in, we initialize base_path
2067     // Calculate potentially longest base path and check if we have enough
2068     // allocated statically.
2069     const size_t total_length =
2070                       (HeapDumpPath == NULL ? 0 : strlen(HeapDumpPath)) +
2071                       strlen(os::file_separator()) + max_digit_chars +
2072                       strlen(dump_file_name) + strlen(dump_file_ext) + 1;
2073     if (total_length &gt; sizeof(base_path)) {
2074       warning(&quot;Cannot create heap dump file.  HeapDumpPath is too long.&quot;);
2075       return;
2076     }
2077 
2078     bool use_default_filename = true;
2079     if (HeapDumpPath == NULL || HeapDumpPath[0] == &#39;\0&#39;) {
2080       // HeapDumpPath=&lt;file&gt; not specified
2081     } else {
2082       strcpy(base_path, HeapDumpPath);
2083       // check if the path is a directory (must exist)
2084       DIR* dir = os::opendir(base_path);
2085       if (dir == NULL) {
2086         use_default_filename = false;
2087       } else {
2088         // HeapDumpPath specified a directory. We append a file separator
2089         // (if needed).
2090         os::closedir(dir);
2091         size_t fs_len = strlen(os::file_separator());
2092         if (strlen(base_path) &gt;= fs_len) {
2093           char* end = base_path;
2094           end += (strlen(base_path) - fs_len);
2095           if (strcmp(end, os::file_separator()) != 0) {
2096             strcat(base_path, os::file_separator());
2097           }
2098         }
2099       }
2100     }
2101     // If HeapDumpPath wasn&#39;t a file name then we append the default name
2102     if (use_default_filename) {
2103       const size_t dlen = strlen(base_path);  // if heap dump dir specified
2104       jio_snprintf(&amp;base_path[dlen], sizeof(base_path)-dlen, &quot;%s%d%s&quot;,
2105                    dump_file_name, os::current_process_id(), dump_file_ext);
2106     }
2107     const size_t len = strlen(base_path) + 1;
2108     my_path = (char*)os::malloc(len, mtInternal);
2109     if (my_path == NULL) {
2110       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2111       return;
2112     }
2113     strncpy(my_path, base_path, len);
2114   } else {
2115     // Append a sequence number id for dumps following the first
2116     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2117     my_path = (char*)os::malloc(len, mtInternal);
2118     if (my_path == NULL) {
2119       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2120       return;
2121     }
2122     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2123   }
2124   dump_file_seq++;   // increment seq number for next time we dump
2125 
2126   HeapDumper dumper(false /* no GC before heap dump */,
<a name="117" id="anc117"></a>
2127                     oome  /* pass along out-of-memory-error flag */);
<a name="118" id="anc118"></a><span class="line-modified">2128   dumper.dump(my_path, tty);</span>
2129   os::free(my_path);
2130 }
<a name="119" id="anc119"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="119" type="hidden" />
</body>
</html>
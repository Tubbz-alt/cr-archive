<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/management.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jmm.h&quot;
<a name="2" id="anc2"></a>
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/iterator.hpp&quot;
  31 #include &quot;memory/oopFactory.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
  33 #include &quot;oops/klass.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;runtime/arguments.hpp&quot;
  39 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  40 #include &quot;runtime/globals.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/javaCalls.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;
<a name="4" id="anc4"></a>
  45 #include &quot;runtime/os.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed">  46 #include &quot;runtime/serviceThread.hpp&quot;</span>
  47 #include &quot;runtime/thread.inline.hpp&quot;
  48 #include &quot;runtime/threadSMR.hpp&quot;
  49 #include &quot;services/classLoadingService.hpp&quot;
  50 #include &quot;services/diagnosticCommand.hpp&quot;
  51 #include &quot;services/diagnosticFramework.hpp&quot;
  52 #include &quot;services/writeableFlags.hpp&quot;
  53 #include &quot;services/heapDumper.hpp&quot;
  54 #include &quot;services/lowMemoryDetector.hpp&quot;
  55 #include &quot;services/gcNotifier.hpp&quot;
  56 #include &quot;services/nmtDCmd.hpp&quot;
  57 #include &quot;services/management.hpp&quot;
  58 #include &quot;services/memoryManager.hpp&quot;
  59 #include &quot;services/memoryPool.hpp&quot;
  60 #include &quot;services/memoryService.hpp&quot;
  61 #include &quot;services/runtimeService.hpp&quot;
  62 #include &quot;services/threadService.hpp&quot;
  63 #include &quot;utilities/debug.hpp&quot;
  64 #include &quot;utilities/formatBuffer.hpp&quot;
  65 #include &quot;utilities/macros.hpp&quot;
  66 
  67 PerfVariable* Management::_begin_vm_creation_time = NULL;
  68 PerfVariable* Management::_end_vm_creation_time = NULL;
  69 PerfVariable* Management::_vm_init_done_time = NULL;
  70 
  71 InstanceKlass* Management::_diagnosticCommandImpl_klass = NULL;
  72 InstanceKlass* Management::_garbageCollectorExtImpl_klass = NULL;
  73 InstanceKlass* Management::_garbageCollectorMXBean_klass = NULL;
  74 InstanceKlass* Management::_gcInfo_klass = NULL;
  75 InstanceKlass* Management::_managementFactoryHelper_klass = NULL;
  76 InstanceKlass* Management::_memoryManagerMXBean_klass = NULL;
  77 InstanceKlass* Management::_memoryPoolMXBean_klass = NULL;
  78 InstanceKlass* Management::_memoryUsage_klass = NULL;
  79 InstanceKlass* Management::_sensor_klass = NULL;
  80 InstanceKlass* Management::_threadInfo_klass = NULL;
  81 
  82 jmmOptionalSupport Management::_optional_support = {0};
  83 TimeStamp Management::_stamp;
  84 
  85 void management_init() {
  86 #if INCLUDE_MANAGEMENT
  87   Management::init();
  88   ThreadService::init();
  89   RuntimeService::init();
  90   ClassLoadingService::init();
  91 #else
  92   ThreadService::init();
  93 #endif // INCLUDE_MANAGEMENT
  94 }
  95 
  96 #if INCLUDE_MANAGEMENT
  97 
  98 void Management::init() {
  99   EXCEPTION_MARK;
 100 
 101   // These counters are for java.lang.management API support.
 102   // They are created even if -XX:-UsePerfData is set and in
 103   // that case, they will be allocated on C heap.
 104 
 105   _begin_vm_creation_time =
 106             PerfDataManager::create_variable(SUN_RT, &quot;createVmBeginTime&quot;,
 107                                              PerfData::U_None, CHECK);
 108 
 109   _end_vm_creation_time =
 110             PerfDataManager::create_variable(SUN_RT, &quot;createVmEndTime&quot;,
 111                                              PerfData::U_None, CHECK);
 112 
 113   _vm_init_done_time =
 114             PerfDataManager::create_variable(SUN_RT, &quot;vmInitDoneTime&quot;,
 115                                              PerfData::U_None, CHECK);
 116 
 117   // Initialize optional support
 118   _optional_support.isLowMemoryDetectionSupported = 1;
 119   _optional_support.isCompilationTimeMonitoringSupported = 1;
 120   _optional_support.isThreadContentionMonitoringSupported = 1;
 121 
 122   if (os::is_thread_cpu_time_supported()) {
 123     _optional_support.isCurrentThreadCpuTimeSupported = 1;
 124     _optional_support.isOtherThreadCpuTimeSupported = 1;
 125   } else {
 126     _optional_support.isCurrentThreadCpuTimeSupported = 0;
 127     _optional_support.isOtherThreadCpuTimeSupported = 0;
 128   }
 129 
 130   _optional_support.isObjectMonitorUsageSupported = 1;
 131 #if INCLUDE_SERVICES
 132   // This depends on the heap inspector
 133   _optional_support.isSynchronizerUsageSupported = 1;
 134 #endif // INCLUDE_SERVICES
 135   _optional_support.isThreadAllocatedMemorySupported = 1;
 136   _optional_support.isRemoteDiagnosticCommandsSupported = 1;
 137 
 138   // Registration of the diagnostic commands
 139   DCmdRegistrant::register_dcmds();
 140   DCmdRegistrant::register_dcmds_ext();
 141   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
 142                          | DCmd_Source_MBean;
 143   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;NMTDCmd&gt;(full_export, true, false));
 144 }
 145 
 146 void Management::initialize(TRAPS) {
<a name="6" id="anc6"></a><span class="line-modified"> 147   // Start the service thread</span>
<span class="line-modified"> 148   ServiceThread::initialize();</span>
<span class="line-modified"> 149 </span>
 150   if (ManagementServer) {
 151     ResourceMark rm(THREAD);
 152     HandleMark hm(THREAD);
 153 
 154     // Load and initialize the jdk.internal.agent.Agent class
 155     // invoke startAgent method to start the management server
 156     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 157     Klass* k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_agent_Agent(),
 158                                                    loader,
 159                                                    Handle(),
 160                                                    THREAD);
 161     if (k == NULL) {
 162       vm_exit_during_initialization(&quot;Management agent initialization failure: &quot;
 163           &quot;class jdk.internal.agent.Agent not found.&quot;);
 164     }
 165 
 166     JavaValue result(T_VOID);
 167     JavaCalls::call_static(&amp;result,
 168                            k,
 169                            vmSymbols::startAgent_name(),
 170                            vmSymbols::void_method_signature(),
 171                            CHECK);
 172   }
 173 }
 174 
 175 void Management::get_optional_support(jmmOptionalSupport* support) {
 176   memcpy(support, &amp;_optional_support, sizeof(jmmOptionalSupport));
 177 }
 178 
 179 InstanceKlass* Management::load_and_initialize_klass(Symbol* sh, TRAPS) {
 180   Klass* k = SystemDictionary::resolve_or_fail(sh, true, CHECK_NULL);
 181   return initialize_klass(k, THREAD);
 182 }
 183 
 184 InstanceKlass* Management::load_and_initialize_klass_or_null(Symbol* sh, TRAPS) {
 185   Klass* k = SystemDictionary::resolve_or_null(sh, CHECK_NULL);
 186   if (k == NULL) {
 187      return NULL;
 188   }
 189   return initialize_klass(k, THREAD);
 190 }
 191 
 192 InstanceKlass* Management::initialize_klass(Klass* k, TRAPS) {
 193   InstanceKlass* ik = InstanceKlass::cast(k);
 194   if (ik-&gt;should_be_initialized()) {
 195     ik-&gt;initialize(CHECK_NULL);
 196   }
 197   // If these classes change to not be owned by the boot loader, they need
 198   // to be walked to keep their class loader alive in oops_do.
 199   assert(ik-&gt;class_loader() == NULL, &quot;need to follow in oops_do&quot;);
 200   return ik;
 201 }
 202 
 203 void Management::record_vm_startup_time(jlong begin, jlong duration) {
 204   // if the performance counter is not initialized,
 205   // then vm initialization failed; simply return.
 206   if (_begin_vm_creation_time == NULL) return;
 207 
 208   _begin_vm_creation_time-&gt;set_value(begin);
 209   _end_vm_creation_time-&gt;set_value(begin + duration);
 210   PerfMemory::set_accessible(true);
 211 }
 212 
 213 jlong Management::timestamp() {
 214   TimeStamp t;
 215   t.update();
 216   return t.ticks() - _stamp.ticks();
 217 }
 218 
 219 void Management::oops_do(OopClosure* f) {
 220   MemoryService::oops_do(f);
 221   ThreadService::oops_do(f);
 222 }
 223 
 224 InstanceKlass* Management::java_lang_management_ThreadInfo_klass(TRAPS) {
 225   if (_threadInfo_klass == NULL) {
 226     _threadInfo_klass = load_and_initialize_klass(vmSymbols::java_lang_management_ThreadInfo(), CHECK_NULL);
 227   }
 228   return _threadInfo_klass;
 229 }
 230 
 231 InstanceKlass* Management::java_lang_management_MemoryUsage_klass(TRAPS) {
 232   if (_memoryUsage_klass == NULL) {
 233     _memoryUsage_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryUsage(), CHECK_NULL);
 234   }
 235   return _memoryUsage_klass;
 236 }
 237 
 238 InstanceKlass* Management::java_lang_management_MemoryPoolMXBean_klass(TRAPS) {
 239   if (_memoryPoolMXBean_klass == NULL) {
 240     _memoryPoolMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryPoolMXBean(), CHECK_NULL);
 241   }
 242   return _memoryPoolMXBean_klass;
 243 }
 244 
 245 InstanceKlass* Management::java_lang_management_MemoryManagerMXBean_klass(TRAPS) {
 246   if (_memoryManagerMXBean_klass == NULL) {
 247     _memoryManagerMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryManagerMXBean(), CHECK_NULL);
 248   }
 249   return _memoryManagerMXBean_klass;
 250 }
 251 
 252 InstanceKlass* Management::java_lang_management_GarbageCollectorMXBean_klass(TRAPS) {
 253   if (_garbageCollectorMXBean_klass == NULL) {
 254       _garbageCollectorMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_GarbageCollectorMXBean(), CHECK_NULL);
 255   }
 256   return _garbageCollectorMXBean_klass;
 257 }
 258 
 259 InstanceKlass* Management::sun_management_Sensor_klass(TRAPS) {
 260   if (_sensor_klass == NULL) {
 261     _sensor_klass = load_and_initialize_klass(vmSymbols::sun_management_Sensor(), CHECK_NULL);
 262   }
 263   return _sensor_klass;
 264 }
 265 
 266 InstanceKlass* Management::sun_management_ManagementFactoryHelper_klass(TRAPS) {
 267   if (_managementFactoryHelper_klass == NULL) {
 268     _managementFactoryHelper_klass = load_and_initialize_klass(vmSymbols::sun_management_ManagementFactoryHelper(), CHECK_NULL);
 269   }
 270   return _managementFactoryHelper_klass;
 271 }
 272 
 273 InstanceKlass* Management::com_sun_management_internal_GarbageCollectorExtImpl_klass(TRAPS) {
 274   if (_garbageCollectorExtImpl_klass == NULL) {
 275     _garbageCollectorExtImpl_klass =
 276                 load_and_initialize_klass_or_null(vmSymbols::com_sun_management_internal_GarbageCollectorExtImpl(), CHECK_NULL);
 277   }
 278   return _garbageCollectorExtImpl_klass;
 279 }
 280 
 281 InstanceKlass* Management::com_sun_management_GcInfo_klass(TRAPS) {
 282   if (_gcInfo_klass == NULL) {
 283     _gcInfo_klass = load_and_initialize_klass(vmSymbols::com_sun_management_GcInfo(), CHECK_NULL);
 284   }
 285   return _gcInfo_klass;
 286 }
 287 
 288 InstanceKlass* Management::com_sun_management_internal_DiagnosticCommandImpl_klass(TRAPS) {
 289   if (_diagnosticCommandImpl_klass == NULL) {
 290     _diagnosticCommandImpl_klass = load_and_initialize_klass(vmSymbols::com_sun_management_internal_DiagnosticCommandImpl(), CHECK_NULL);
 291   }
 292   return _diagnosticCommandImpl_klass;
 293 }
 294 
 295 static void initialize_ThreadInfo_constructor_arguments(JavaCallArguments* args, ThreadSnapshot* snapshot, TRAPS) {
 296   Handle snapshot_thread(THREAD, snapshot-&gt;threadObj());
 297 
 298   jlong contended_time;
 299   jlong waited_time;
 300   if (ThreadService::is_thread_monitoring_contention()) {
 301     contended_time = Management::ticks_to_ms(snapshot-&gt;contended_enter_ticks());
 302     waited_time = Management::ticks_to_ms(snapshot-&gt;monitor_wait_ticks() + snapshot-&gt;sleep_ticks());
 303   } else {
 304     // set them to -1 if thread contention monitoring is disabled.
 305     contended_time = max_julong;
 306     waited_time = max_julong;
 307   }
 308 
 309   int thread_status = snapshot-&gt;thread_status();
 310   assert((thread_status &amp; JMM_THREAD_STATE_FLAG_MASK) == 0, &quot;Flags already set in thread_status in Thread object&quot;);
 311   if (snapshot-&gt;is_ext_suspended()) {
 312     thread_status |= JMM_THREAD_STATE_FLAG_SUSPENDED;
 313   }
 314   if (snapshot-&gt;is_in_native()) {
 315     thread_status |= JMM_THREAD_STATE_FLAG_NATIVE;
 316   }
 317 
 318   ThreadStackTrace* st = snapshot-&gt;get_stack_trace();
 319   Handle stacktrace_h;
 320   if (st != NULL) {
 321     stacktrace_h = st-&gt;allocate_fill_stack_trace_element_array(CHECK);
 322   } else {
 323     stacktrace_h = Handle();
 324   }
 325 
 326   args-&gt;push_oop(snapshot_thread);
 327   args-&gt;push_int(thread_status);
 328   args-&gt;push_oop(Handle(THREAD, snapshot-&gt;blocker_object()));
 329   args-&gt;push_oop(Handle(THREAD, snapshot-&gt;blocker_object_owner()));
 330   args-&gt;push_long(snapshot-&gt;contended_enter_count());
 331   args-&gt;push_long(contended_time);
 332   args-&gt;push_long(snapshot-&gt;monitor_wait_count() + snapshot-&gt;sleep_count());
 333   args-&gt;push_long(waited_time);
 334   args-&gt;push_oop(stacktrace_h);
 335 }
 336 
 337 // Helper function to construct a ThreadInfo object
 338 instanceOop Management::create_thread_info_instance(ThreadSnapshot* snapshot, TRAPS) {
 339   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
 340   JavaCallArguments args(14);
 341 
 342   // initialize the arguments for the ThreadInfo constructor
 343   initialize_ThreadInfo_constructor_arguments(&amp;args, snapshot, CHECK_NULL);
 344 
 345   // Call ThreadInfo constructor with no locked monitors and synchronizers
 346   Handle element = JavaCalls::construct_new_instance(
 347                           ik,
 348                           vmSymbols::java_lang_management_ThreadInfo_constructor_signature(),
 349                           &amp;args,
 350                           CHECK_NULL);
 351   return (instanceOop) element();
 352 }
 353 
 354 instanceOop Management::create_thread_info_instance(ThreadSnapshot* snapshot,
 355                                                     objArrayHandle monitors_array,
 356                                                     typeArrayHandle depths_array,
 357                                                     objArrayHandle synchronizers_array,
 358                                                     TRAPS) {
 359   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
 360   JavaCallArguments args(17);
 361 
 362   // initialize the arguments for the ThreadInfo constructor
 363   initialize_ThreadInfo_constructor_arguments(&amp;args, snapshot, CHECK_NULL);
 364 
 365   // push the locked monitors and synchronizers in the arguments
 366   args.push_oop(monitors_array);
 367   args.push_oop(depths_array);
 368   args.push_oop(synchronizers_array);
 369 
 370   // Call ThreadInfo constructor with locked monitors and synchronizers
 371   Handle element = JavaCalls::construct_new_instance(
 372                           ik,
 373                           vmSymbols::java_lang_management_ThreadInfo_with_locks_constructor_signature(),
 374                           &amp;args,
 375                           CHECK_NULL);
 376   return (instanceOop) element();
 377 }
 378 
 379 
 380 static GCMemoryManager* get_gc_memory_manager_from_jobject(jobject mgr, TRAPS) {
 381   if (mgr == NULL) {
 382     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 383   }
 384   oop mgr_obj = JNIHandles::resolve(mgr);
 385   instanceHandle h(THREAD, (instanceOop) mgr_obj);
 386 
 387   InstanceKlass* k = Management::java_lang_management_GarbageCollectorMXBean_klass(CHECK_NULL);
 388   if (!h-&gt;is_a(k)) {
 389     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 390                &quot;the object is not an instance of java.lang.management.GarbageCollectorMXBean class&quot;,
 391                NULL);
 392   }
 393 
 394   MemoryManager* gc = MemoryService::get_memory_manager(h);
 395   if (gc == NULL || !gc-&gt;is_gc_memory_manager()) {
 396     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 397                &quot;Invalid GC memory manager&quot;,
 398                NULL);
 399   }
 400   return (GCMemoryManager*) gc;
 401 }
 402 
 403 static MemoryPool* get_memory_pool_from_jobject(jobject obj, TRAPS) {
 404   if (obj == NULL) {
 405     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 406   }
 407 
 408   oop pool_obj = JNIHandles::resolve(obj);
 409   assert(pool_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
 410   instanceHandle ph(THREAD, (instanceOop) pool_obj);
 411 
 412   return MemoryService::get_memory_pool(ph);
 413 }
 414 
 415 #endif // INCLUDE_MANAGEMENT
 416 
 417 static void validate_thread_id_array(typeArrayHandle ids_ah, TRAPS) {
 418   int num_threads = ids_ah-&gt;length();
 419 
 420   // Validate input thread IDs
 421   int i = 0;
 422   for (i = 0; i &lt; num_threads; i++) {
 423     jlong tid = ids_ah-&gt;long_at(i);
 424     if (tid &lt;= 0) {
 425       // throw exception if invalid thread id.
 426       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 427                 &quot;Invalid thread ID entry&quot;);
 428     }
 429   }
 430 }
 431 
 432 #if INCLUDE_MANAGEMENT
 433 
 434 static void validate_thread_info_array(objArrayHandle infoArray_h, TRAPS) {
 435   // check if the element of infoArray is of type ThreadInfo class
 436   Klass* threadinfo_klass = Management::java_lang_management_ThreadInfo_klass(CHECK);
 437   Klass* element_klass = ObjArrayKlass::cast(infoArray_h-&gt;klass())-&gt;element_klass();
 438   if (element_klass != threadinfo_klass) {
 439     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 440               &quot;infoArray element type is not ThreadInfo class&quot;);
 441   }
 442 }
 443 
 444 
 445 static MemoryManager* get_memory_manager_from_jobject(jobject obj, TRAPS) {
 446   if (obj == NULL) {
 447     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 448   }
 449 
 450   oop mgr_obj = JNIHandles::resolve(obj);
 451   assert(mgr_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
 452   instanceHandle mh(THREAD, (instanceOop) mgr_obj);
 453 
 454   return MemoryService::get_memory_manager(mh);
 455 }
 456 
 457 // Returns a version string and sets major and minor version if
 458 // the input parameters are non-null.
 459 JVM_LEAF(jint, jmm_GetVersion(JNIEnv *env))
 460   return JMM_VERSION;
 461 JVM_END
 462 
 463 // Gets the list of VM monitoring and management optional supports
 464 // Returns 0 if succeeded; otherwise returns non-zero.
 465 JVM_LEAF(jint, jmm_GetOptionalSupport(JNIEnv *env, jmmOptionalSupport* support))
 466   if (support == NULL) {
 467     return -1;
 468   }
 469   Management::get_optional_support(support);
 470   return 0;
 471 JVM_END
 472 
 473 // Returns an array of java/lang/management/MemoryPoolMXBean object
 474 // one for each memory pool if obj == null; otherwise returns
 475 // an array of memory pools for a given memory manager if
 476 // it is a valid memory manager.
 477 JVM_ENTRY(jobjectArray, jmm_GetMemoryPools(JNIEnv* env, jobject obj))
 478   ResourceMark rm(THREAD);
 479 
 480   int num_memory_pools;
 481   MemoryManager* mgr = NULL;
 482   if (obj == NULL) {
 483     num_memory_pools = MemoryService::num_memory_pools();
 484   } else {
 485     mgr = get_memory_manager_from_jobject(obj, CHECK_NULL);
 486     if (mgr == NULL) {
 487       return NULL;
 488     }
 489     num_memory_pools = mgr-&gt;num_memory_pools();
 490   }
 491 
 492   // Allocate the resulting MemoryPoolMXBean[] object
 493   InstanceKlass* ik = Management::java_lang_management_MemoryPoolMXBean_klass(CHECK_NULL);
 494   objArrayOop r = oopFactory::new_objArray(ik, num_memory_pools, CHECK_NULL);
 495   objArrayHandle poolArray(THREAD, r);
 496 
 497   if (mgr == NULL) {
 498     // Get all memory pools
 499     for (int i = 0; i &lt; num_memory_pools; i++) {
 500       MemoryPool* pool = MemoryService::get_memory_pool(i);
 501       instanceOop p = pool-&gt;get_memory_pool_instance(CHECK_NULL);
 502       instanceHandle ph(THREAD, p);
 503       poolArray-&gt;obj_at_put(i, ph());
 504     }
 505   } else {
 506     // Get memory pools managed by a given memory manager
 507     for (int i = 0; i &lt; num_memory_pools; i++) {
 508       MemoryPool* pool = mgr-&gt;get_memory_pool(i);
 509       instanceOop p = pool-&gt;get_memory_pool_instance(CHECK_NULL);
 510       instanceHandle ph(THREAD, p);
 511       poolArray-&gt;obj_at_put(i, ph());
 512     }
 513   }
 514   return (jobjectArray) JNIHandles::make_local(env, poolArray());
 515 JVM_END
 516 
 517 // Returns an array of java/lang/management/MemoryManagerMXBean object
 518 // one for each memory manager if obj == null; otherwise returns
 519 // an array of memory managers for a given memory pool if
 520 // it is a valid memory pool.
 521 JVM_ENTRY(jobjectArray, jmm_GetMemoryManagers(JNIEnv* env, jobject obj))
 522   ResourceMark rm(THREAD);
 523 
 524   int num_mgrs;
 525   MemoryPool* pool = NULL;
 526   if (obj == NULL) {
 527     num_mgrs = MemoryService::num_memory_managers();
 528   } else {
 529     pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 530     if (pool == NULL) {
 531       return NULL;
 532     }
 533     num_mgrs = pool-&gt;num_memory_managers();
 534   }
 535 
 536   // Allocate the resulting MemoryManagerMXBean[] object
 537   InstanceKlass* ik = Management::java_lang_management_MemoryManagerMXBean_klass(CHECK_NULL);
 538   objArrayOop r = oopFactory::new_objArray(ik, num_mgrs, CHECK_NULL);
 539   objArrayHandle mgrArray(THREAD, r);
 540 
 541   if (pool == NULL) {
 542     // Get all memory managers
 543     for (int i = 0; i &lt; num_mgrs; i++) {
 544       MemoryManager* mgr = MemoryService::get_memory_manager(i);
 545       instanceOop p = mgr-&gt;get_memory_manager_instance(CHECK_NULL);
 546       instanceHandle ph(THREAD, p);
 547       mgrArray-&gt;obj_at_put(i, ph());
 548     }
 549   } else {
 550     // Get memory managers for a given memory pool
 551     for (int i = 0; i &lt; num_mgrs; i++) {
 552       MemoryManager* mgr = pool-&gt;get_memory_manager(i);
 553       instanceOop p = mgr-&gt;get_memory_manager_instance(CHECK_NULL);
 554       instanceHandle ph(THREAD, p);
 555       mgrArray-&gt;obj_at_put(i, ph());
 556     }
 557   }
 558   return (jobjectArray) JNIHandles::make_local(env, mgrArray());
 559 JVM_END
 560 
 561 
 562 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 563 // of a given memory pool.
 564 JVM_ENTRY(jobject, jmm_GetMemoryPoolUsage(JNIEnv* env, jobject obj))
 565   ResourceMark rm(THREAD);
 566 
 567   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 568   if (pool != NULL) {
 569     MemoryUsage usage = pool-&gt;get_memory_usage();
 570     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 571     return JNIHandles::make_local(env, h());
 572   } else {
 573     return NULL;
 574   }
 575 JVM_END
 576 
 577 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 578 // of a given memory pool.
 579 JVM_ENTRY(jobject, jmm_GetPeakMemoryPoolUsage(JNIEnv* env, jobject obj))
 580   ResourceMark rm(THREAD);
 581 
 582   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 583   if (pool != NULL) {
 584     MemoryUsage usage = pool-&gt;get_peak_memory_usage();
 585     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 586     return JNIHandles::make_local(env, h());
 587   } else {
 588     return NULL;
 589   }
 590 JVM_END
 591 
 592 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 593 // of a given memory pool after most recent GC.
 594 JVM_ENTRY(jobject, jmm_GetPoolCollectionUsage(JNIEnv* env, jobject obj))
 595   ResourceMark rm(THREAD);
 596 
 597   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 598   if (pool != NULL &amp;&amp; pool-&gt;is_collected_pool()) {
 599     MemoryUsage usage = pool-&gt;get_last_collection_usage();
 600     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 601     return JNIHandles::make_local(env, h());
 602   } else {
 603     return NULL;
 604   }
 605 JVM_END
 606 
 607 // Sets the memory pool sensor for a threshold type
 608 JVM_ENTRY(void, jmm_SetPoolSensor(JNIEnv* env, jobject obj, jmmThresholdType type, jobject sensorObj))
 609   if (obj == NULL || sensorObj == NULL) {
 610     THROW(vmSymbols::java_lang_NullPointerException());
 611   }
 612 
 613   InstanceKlass* sensor_klass = Management::sun_management_Sensor_klass(CHECK);
 614   oop s = JNIHandles::resolve(sensorObj);
 615   assert(s-&gt;is_instance(), &quot;Sensor should be an instanceOop&quot;);
 616   instanceHandle sensor_h(THREAD, (instanceOop) s);
 617   if (!sensor_h-&gt;is_a(sensor_klass)) {
 618     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 619               &quot;Sensor is not an instance of sun.management.Sensor class&quot;);
 620   }
 621 
 622   MemoryPool* mpool = get_memory_pool_from_jobject(obj, CHECK);
 623   assert(mpool != NULL, &quot;MemoryPool should exist&quot;);
 624 
 625   switch (type) {
 626     case JMM_USAGE_THRESHOLD_HIGH:
 627     case JMM_USAGE_THRESHOLD_LOW:
 628       // have only one sensor for threshold high and low
 629       mpool-&gt;set_usage_sensor_obj(sensor_h);
 630       break;
 631     case JMM_COLLECTION_USAGE_THRESHOLD_HIGH:
 632     case JMM_COLLECTION_USAGE_THRESHOLD_LOW:
 633       // have only one sensor for threshold high and low
 634       mpool-&gt;set_gc_usage_sensor_obj(sensor_h);
 635       break;
 636     default:
 637       assert(false, &quot;Unrecognized type&quot;);
 638   }
 639 
 640 JVM_END
 641 
 642 
 643 // Sets the threshold of a given memory pool.
 644 // Returns the previous threshold.
 645 //
 646 // Input parameters:
 647 //   pool      - the MemoryPoolMXBean object
 648 //   type      - threshold type
 649 //   threshold - the new threshold (must not be negative)
 650 //
 651 JVM_ENTRY(jlong, jmm_SetPoolThreshold(JNIEnv* env, jobject obj, jmmThresholdType type, jlong threshold))
 652   if (threshold &lt; 0) {
 653     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 654                &quot;Invalid threshold value&quot;,
 655                -1);
 656   }
 657 
 658   if ((size_t)threshold &gt; max_uintx) {
 659     stringStream st;
 660     st.print(&quot;Invalid valid threshold value. Threshold value (&quot; JLONG_FORMAT &quot;) &gt; max value of size_t (&quot; UINTX_FORMAT &quot;)&quot;, threshold, max_uintx);
 661     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), st.as_string(), -1);
 662   }
 663 
 664   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_(0L));
 665   assert(pool != NULL, &quot;MemoryPool should exist&quot;);
 666 
 667   jlong prev = 0;
 668   switch (type) {
 669     case JMM_USAGE_THRESHOLD_HIGH:
 670       if (!pool-&gt;usage_threshold()-&gt;is_high_threshold_supported()) {
 671         return -1;
 672       }
 673       prev = pool-&gt;usage_threshold()-&gt;set_high_threshold((size_t) threshold);
 674       break;
 675 
 676     case JMM_USAGE_THRESHOLD_LOW:
 677       if (!pool-&gt;usage_threshold()-&gt;is_low_threshold_supported()) {
 678         return -1;
 679       }
 680       prev = pool-&gt;usage_threshold()-&gt;set_low_threshold((size_t) threshold);
 681       break;
 682 
 683     case JMM_COLLECTION_USAGE_THRESHOLD_HIGH:
 684       if (!pool-&gt;gc_usage_threshold()-&gt;is_high_threshold_supported()) {
 685         return -1;
 686       }
 687       // return and the new threshold is effective for the next GC
 688       return pool-&gt;gc_usage_threshold()-&gt;set_high_threshold((size_t) threshold);
 689 
 690     case JMM_COLLECTION_USAGE_THRESHOLD_LOW:
 691       if (!pool-&gt;gc_usage_threshold()-&gt;is_low_threshold_supported()) {
 692         return -1;
 693       }
 694       // return and the new threshold is effective for the next GC
 695       return pool-&gt;gc_usage_threshold()-&gt;set_low_threshold((size_t) threshold);
 696 
 697     default:
 698       assert(false, &quot;Unrecognized type&quot;);
 699       return -1;
 700   }
 701 
 702   // When the threshold is changed, reevaluate if the low memory
 703   // detection is enabled.
 704   if (prev != threshold) {
 705     LowMemoryDetector::recompute_enabled_for_collected_pools();
 706     LowMemoryDetector::detect_low_memory(pool);
 707   }
 708   return prev;
 709 JVM_END
 710 
 711 // Returns a java/lang/management/MemoryUsage object representing
 712 // the memory usage for the heap or non-heap memory.
 713 JVM_ENTRY(jobject, jmm_GetMemoryUsage(JNIEnv* env, jboolean heap))
 714   ResourceMark rm(THREAD);
 715 
 716   MemoryUsage usage;
 717 
 718   if (heap) {
 719     usage = Universe::heap()-&gt;memory_usage();
 720   } else {
 721     // Calculate the memory usage by summing up the pools.
 722     size_t total_init = 0;
 723     size_t total_used = 0;
 724     size_t total_committed = 0;
 725     size_t total_max = 0;
 726     bool   has_undefined_init_size = false;
 727     bool   has_undefined_max_size = false;
 728 
 729     for (int i = 0; i &lt; MemoryService::num_memory_pools(); i++) {
 730       MemoryPool* pool = MemoryService::get_memory_pool(i);
 731       if (pool-&gt;is_non_heap()) {
 732         MemoryUsage u = pool-&gt;get_memory_usage();
 733         total_used += u.used();
 734         total_committed += u.committed();
 735 
 736         if (u.init_size() == MemoryUsage::undefined_size()) {
 737           has_undefined_init_size = true;
 738         }
 739         if (!has_undefined_init_size) {
 740           total_init += u.init_size();
 741         }
 742 
 743         if (u.max_size() == MemoryUsage::undefined_size()) {
 744           has_undefined_max_size = true;
 745         }
 746         if (!has_undefined_max_size) {
 747           total_max += u.max_size();
 748         }
 749       }
 750     }
 751 
 752     // if any one of the memory pool has undefined init_size or max_size,
 753     // set it to MemoryUsage::undefined_size()
 754     if (has_undefined_init_size) {
 755       total_init = MemoryUsage::undefined_size();
 756     }
 757     if (has_undefined_max_size) {
 758       total_max = MemoryUsage::undefined_size();
 759     }
 760 
 761     usage = MemoryUsage(total_init, total_used, total_committed, total_max);
 762   }
 763 
 764   Handle obj = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 765   return JNIHandles::make_local(env, obj());
 766 JVM_END
 767 
 768 // Returns the boolean value of a given attribute.
 769 JVM_LEAF(jboolean, jmm_GetBoolAttribute(JNIEnv *env, jmmBoolAttribute att))
 770   switch (att) {
 771   case JMM_VERBOSE_GC:
 772     return MemoryService::get_verbose();
 773   case JMM_VERBOSE_CLASS:
 774     return ClassLoadingService::get_verbose();
 775   case JMM_THREAD_CONTENTION_MONITORING:
 776     return ThreadService::is_thread_monitoring_contention();
 777   case JMM_THREAD_CPU_TIME:
 778     return ThreadService::is_thread_cpu_time_enabled();
 779   case JMM_THREAD_ALLOCATED_MEMORY:
 780     return ThreadService::is_thread_allocated_memory_enabled();
 781   default:
 782     assert(0, &quot;Unrecognized attribute&quot;);
 783     return false;
 784   }
 785 JVM_END
 786 
 787 // Sets the given boolean attribute and returns the previous value.
 788 JVM_ENTRY(jboolean, jmm_SetBoolAttribute(JNIEnv *env, jmmBoolAttribute att, jboolean flag))
 789   switch (att) {
 790   case JMM_VERBOSE_GC:
 791     return MemoryService::set_verbose(flag != 0);
 792   case JMM_VERBOSE_CLASS:
 793     return ClassLoadingService::set_verbose(flag != 0);
 794   case JMM_THREAD_CONTENTION_MONITORING:
 795     return ThreadService::set_thread_monitoring_contention(flag != 0);
 796   case JMM_THREAD_CPU_TIME:
 797     return ThreadService::set_thread_cpu_time_enabled(flag != 0);
 798   case JMM_THREAD_ALLOCATED_MEMORY:
 799     return ThreadService::set_thread_allocated_memory_enabled(flag != 0);
 800   default:
 801     assert(0, &quot;Unrecognized attribute&quot;);
 802     return false;
 803   }
 804 JVM_END
 805 
 806 
 807 static jlong get_gc_attribute(GCMemoryManager* mgr, jmmLongAttribute att) {
 808   switch (att) {
 809   case JMM_GC_TIME_MS:
 810     return mgr-&gt;gc_time_ms();
 811 
 812   case JMM_GC_COUNT:
 813     return mgr-&gt;gc_count();
 814 
 815   case JMM_GC_EXT_ATTRIBUTE_INFO_SIZE:
 816     // current implementation only has 1 ext attribute
 817     return 1;
 818 
 819   default:
 820     assert(0, &quot;Unrecognized GC attribute&quot;);
 821     return -1;
 822   }
 823 }
 824 
 825 class VmThreadCountClosure: public ThreadClosure {
 826  private:
 827   int _count;
 828  public:
 829   VmThreadCountClosure() : _count(0) {};
 830   void do_thread(Thread* thread);
 831   int count() { return _count; }
 832 };
 833 
 834 void VmThreadCountClosure::do_thread(Thread* thread) {
 835   // exclude externally visible JavaThreads
 836   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
 837     return;
 838   }
 839 
 840   _count++;
 841 }
 842 
 843 static jint get_vm_thread_count() {
 844   VmThreadCountClosure vmtcc;
 845   {
<a name="7" id="anc7"></a><span class="line-modified"> 846     MutexLockerEx ml(Threads_lock);</span>
 847     Threads::threads_do(&amp;vmtcc);
 848   }
 849 
 850   return vmtcc.count();
 851 }
 852 
 853 static jint get_num_flags() {
 854   // last flag entry is always NULL, so subtract 1
 855   int nFlags = (int) JVMFlag::numFlags - 1;
 856   int count = 0;
 857   for (int i = 0; i &lt; nFlags; i++) {
 858     JVMFlag* flag = &amp;JVMFlag::flags[i];
 859     // Exclude the locked (diagnostic, experimental) flags
 860     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
 861       count++;
 862     }
 863   }
 864   return count;
 865 }
 866 
 867 static jlong get_long_attribute(jmmLongAttribute att) {
 868   switch (att) {
 869   case JMM_CLASS_LOADED_COUNT:
 870     return ClassLoadingService::loaded_class_count();
 871 
 872   case JMM_CLASS_UNLOADED_COUNT:
 873     return ClassLoadingService::unloaded_class_count();
 874 
 875   case JMM_THREAD_TOTAL_COUNT:
 876     return ThreadService::get_total_thread_count();
 877 
 878   case JMM_THREAD_LIVE_COUNT:
 879     return ThreadService::get_live_thread_count();
 880 
 881   case JMM_THREAD_PEAK_COUNT:
 882     return ThreadService::get_peak_thread_count();
 883 
 884   case JMM_THREAD_DAEMON_COUNT:
 885     return ThreadService::get_daemon_thread_count();
 886 
 887   case JMM_JVM_INIT_DONE_TIME_MS:
 888     return Management::vm_init_done_time();
 889 
 890   case JMM_JVM_UPTIME_MS:
 891     return Management::ticks_to_ms(os::elapsed_counter());
 892 
 893   case JMM_COMPILE_TOTAL_TIME_MS:
 894     return Management::ticks_to_ms(CompileBroker::total_compilation_ticks());
 895 
 896   case JMM_OS_PROCESS_ID:
 897     return os::current_process_id();
 898 
 899   // Hotspot-specific counters
 900   case JMM_CLASS_LOADED_BYTES:
 901     return ClassLoadingService::loaded_class_bytes();
 902 
 903   case JMM_CLASS_UNLOADED_BYTES:
 904     return ClassLoadingService::unloaded_class_bytes();
 905 
 906   case JMM_SHARED_CLASS_LOADED_COUNT:
 907     return ClassLoadingService::loaded_shared_class_count();
 908 
 909   case JMM_SHARED_CLASS_UNLOADED_COUNT:
 910     return ClassLoadingService::unloaded_shared_class_count();
 911 
 912 
 913   case JMM_SHARED_CLASS_LOADED_BYTES:
 914     return ClassLoadingService::loaded_shared_class_bytes();
 915 
 916   case JMM_SHARED_CLASS_UNLOADED_BYTES:
 917     return ClassLoadingService::unloaded_shared_class_bytes();
 918 
 919   case JMM_TOTAL_CLASSLOAD_TIME_MS:
 920     return ClassLoader::classloader_time_ms();
 921 
 922   case JMM_VM_GLOBAL_COUNT:
 923     return get_num_flags();
 924 
 925   case JMM_SAFEPOINT_COUNT:
 926     return RuntimeService::safepoint_count();
 927 
 928   case JMM_TOTAL_SAFEPOINTSYNC_TIME_MS:
 929     return RuntimeService::safepoint_sync_time_ms();
 930 
 931   case JMM_TOTAL_STOPPED_TIME_MS:
 932     return RuntimeService::safepoint_time_ms();
 933 
 934   case JMM_TOTAL_APP_TIME_MS:
 935     return RuntimeService::application_time_ms();
 936 
 937   case JMM_VM_THREAD_COUNT:
 938     return get_vm_thread_count();
 939 
 940   case JMM_CLASS_INIT_TOTAL_COUNT:
 941     return ClassLoader::class_init_count();
 942 
 943   case JMM_CLASS_INIT_TOTAL_TIME_MS:
 944     return ClassLoader::class_init_time_ms();
 945 
 946   case JMM_CLASS_VERIFY_TOTAL_TIME_MS:
 947     return ClassLoader::class_verify_time_ms();
 948 
 949   case JMM_METHOD_DATA_SIZE_BYTES:
 950     return ClassLoadingService::class_method_data_size();
 951 
 952   case JMM_OS_MEM_TOTAL_PHYSICAL_BYTES:
 953     return os::physical_memory();
 954 
 955   default:
 956     return -1;
 957   }
 958 }
 959 
 960 
 961 // Returns the long value of a given attribute.
 962 JVM_ENTRY(jlong, jmm_GetLongAttribute(JNIEnv *env, jobject obj, jmmLongAttribute att))
 963   if (obj == NULL) {
 964     return get_long_attribute(att);
 965   } else {
 966     GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK_(0L));
 967     if (mgr != NULL) {
 968       return get_gc_attribute(mgr, att);
 969     }
 970   }
 971   return -1;
 972 JVM_END
 973 
 974 // Gets the value of all attributes specified in the given array
 975 // and sets the value in the result array.
 976 // Returns the number of attributes found.
 977 JVM_ENTRY(jint, jmm_GetLongAttributes(JNIEnv *env,
 978                                       jobject obj,
 979                                       jmmLongAttribute* atts,
 980                                       jint count,
 981                                       jlong* result))
 982 
 983   int num_atts = 0;
 984   if (obj == NULL) {
 985     for (int i = 0; i &lt; count; i++) {
 986       result[i] = get_long_attribute(atts[i]);
 987       if (result[i] != -1) {
 988         num_atts++;
 989       }
 990     }
 991   } else {
 992     GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK_0);
 993     for (int i = 0; i &lt; count; i++) {
 994       result[i] = get_gc_attribute(mgr, atts[i]);
 995       if (result[i] != -1) {
 996         num_atts++;
 997       }
 998     }
 999   }
1000   return num_atts;
1001 JVM_END
1002 
1003 // Helper function to do thread dump for a specific list of threads
1004 static void do_thread_dump(ThreadDumpResult* dump_result,
1005                            typeArrayHandle ids_ah,  // array of thread ID (long[])
1006                            int num_threads,
1007                            int max_depth,
1008                            bool with_locked_monitors,
1009                            bool with_locked_synchronizers,
1010                            TRAPS) {
1011   // no need to actually perform thread dump if no TIDs are specified
1012   if (num_threads == 0) return;
1013 
1014   // First get an array of threadObj handles.
1015   // A JavaThread may terminate before we get the stack trace.
1016   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
1017 
1018   {
1019     // Need this ThreadsListHandle for converting Java thread IDs into
1020     // threadObj handles; dump_result-&gt;set_t_list() is called in the
1021     // VM op below so we can&#39;t use it yet.
1022     ThreadsListHandle tlh;
1023     for (int i = 0; i &lt; num_threads; i++) {
1024       jlong tid = ids_ah-&gt;long_at(i);
1025       JavaThread* jt = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
1026       oop thread_obj = (jt != NULL ? jt-&gt;threadObj() : (oop)NULL);
1027       instanceHandle threadObj_h(THREAD, (instanceOop) thread_obj);
1028       thread_handle_array-&gt;append(threadObj_h);
1029     }
1030   }
1031 
1032   // Obtain thread dumps and thread snapshot information
1033   VM_ThreadDump op(dump_result,
1034                    thread_handle_array,
1035                    num_threads,
1036                    max_depth, /* stack depth */
1037                    with_locked_monitors,
1038                    with_locked_synchronizers);
1039   VMThread::execute(&amp;op);
1040 }
1041 
1042 // Gets an array of ThreadInfo objects. Each element is the ThreadInfo
1043 // for the thread ID specified in the corresponding entry in
1044 // the given array of thread IDs; or NULL if the thread does not exist
1045 // or has terminated.
1046 //
1047 // Input parameters:
1048 //   ids       - array of thread IDs
1049 //   maxDepth  - the maximum depth of stack traces to be dumped:
1050 //               maxDepth == -1 requests to dump entire stack trace.
1051 //               maxDepth == 0  requests no stack trace.
1052 //   infoArray - array of ThreadInfo objects
1053 //
1054 // QQQ - Why does this method return a value instead of void?
1055 JVM_ENTRY(jint, jmm_GetThreadInfo(JNIEnv *env, jlongArray ids, jint maxDepth, jobjectArray infoArray))
1056   // Check if threads is null
1057   if (ids == NULL || infoArray == NULL) {
1058     THROW_(vmSymbols::java_lang_NullPointerException(), -1);
1059   }
1060 
1061   if (maxDepth &lt; -1) {
1062     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1063                &quot;Invalid maxDepth&quot;, -1);
1064   }
1065 
1066   ResourceMark rm(THREAD);
1067   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
1068   typeArrayHandle ids_ah(THREAD, ta);
1069 
1070   oop infoArray_obj = JNIHandles::resolve_non_null(infoArray);
1071   objArrayOop oa = objArrayOop(infoArray_obj);
1072   objArrayHandle infoArray_h(THREAD, oa);
1073 
1074   // validate the thread id array
1075   validate_thread_id_array(ids_ah, CHECK_0);
1076 
1077   // validate the ThreadInfo[] parameters
1078   validate_thread_info_array(infoArray_h, CHECK_0);
1079 
1080   // infoArray must be of the same length as the given array of thread IDs
1081   int num_threads = ids_ah-&gt;length();
1082   if (num_threads != infoArray_h-&gt;length()) {
1083     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1084                &quot;The length of the given ThreadInfo array does not match the length of the given array of thread IDs&quot;, -1);
1085   }
1086 
1087   // Must use ThreadDumpResult to store the ThreadSnapshot.
1088   // GC may occur after the thread snapshots are taken but before
1089   // this function returns. The threadObj and other oops kept
1090   // in the ThreadSnapshot are marked and adjusted during GC.
1091   ThreadDumpResult dump_result(num_threads);
1092 
1093   if (maxDepth == 0) {
1094     // No stack trace to dump so we do not need to stop the world.
1095     // Since we never do the VM op here we must set the threads list.
1096     dump_result.set_t_list();
1097     for (int i = 0; i &lt; num_threads; i++) {
1098       jlong tid = ids_ah-&gt;long_at(i);
1099       JavaThread* jt = dump_result.t_list()-&gt;find_JavaThread_from_java_tid(tid);
1100       if (jt == NULL) {
1101         // if the thread does not exist or now it is terminated,
1102         // create dummy snapshot
1103         dump_result.add_thread_snapshot();
1104       } else {
1105         dump_result.add_thread_snapshot(jt);
1106       }
1107     }
1108   } else {
1109     // obtain thread dump with the specific list of threads with stack trace
1110     do_thread_dump(&amp;dump_result,
1111                    ids_ah,
1112                    num_threads,
1113                    maxDepth,
1114                    false, /* no locked monitor */
1115                    false, /* no locked synchronizers */
1116                    CHECK_0);
1117   }
1118 
1119   int num_snapshots = dump_result.num_snapshots();
1120   assert(num_snapshots == num_threads, &quot;Must match the number of thread snapshots&quot;);
1121   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
1122   int index = 0;
1123   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; index++, ts = ts-&gt;next()) {
1124     // For each thread, create an java/lang/management/ThreadInfo object
1125     // and fill with the thread information
1126 
1127     if (ts-&gt;threadObj() == NULL) {
1128      // if the thread does not exist or now it is terminated, set threadinfo to NULL
1129       infoArray_h-&gt;obj_at_put(index, NULL);
1130       continue;
1131     }
1132 
1133     // Create java.lang.management.ThreadInfo object
1134     instanceOop info_obj = Management::create_thread_info_instance(ts, CHECK_0);
1135     infoArray_h-&gt;obj_at_put(index, info_obj);
1136   }
1137   return 0;
1138 JVM_END
1139 
1140 // Dump thread info for the specified threads.
1141 // It returns an array of ThreadInfo objects. Each element is the ThreadInfo
1142 // for the thread ID specified in the corresponding entry in
1143 // the given array of thread IDs; or NULL if the thread does not exist
1144 // or has terminated.
1145 //
1146 // Input parameter:
1147 //    ids - array of thread IDs; NULL indicates all live threads
1148 //    locked_monitors - if true, dump locked object monitors
1149 //    locked_synchronizers - if true, dump locked JSR-166 synchronizers
1150 //
1151 JVM_ENTRY(jobjectArray, jmm_DumpThreads(JNIEnv *env, jlongArray thread_ids, jboolean locked_monitors,
1152                                         jboolean locked_synchronizers, jint maxDepth))
1153   ResourceMark rm(THREAD);
1154 
1155   typeArrayOop ta = typeArrayOop(JNIHandles::resolve(thread_ids));
1156   int num_threads = (ta != NULL ? ta-&gt;length() : 0);
1157   typeArrayHandle ids_ah(THREAD, ta);
1158 
1159   ThreadDumpResult dump_result(num_threads);  // can safepoint
1160 
1161   if (ids_ah() != NULL) {
1162 
1163     // validate the thread id array
1164     validate_thread_id_array(ids_ah, CHECK_NULL);
1165 
1166     // obtain thread dump of a specific list of threads
1167     do_thread_dump(&amp;dump_result,
1168                    ids_ah,
1169                    num_threads,
1170                    maxDepth, /* stack depth */
1171                    (locked_monitors ? true : false),      /* with locked monitors */
1172                    (locked_synchronizers ? true : false), /* with locked synchronizers */
1173                    CHECK_NULL);
1174   } else {
1175     // obtain thread dump of all threads
1176     VM_ThreadDump op(&amp;dump_result,
1177                      maxDepth, /* stack depth */
1178                      (locked_monitors ? true : false),     /* with locked monitors */
1179                      (locked_synchronizers ? true : false) /* with locked synchronizers */);
1180     VMThread::execute(&amp;op);
1181   }
1182 
1183   int num_snapshots = dump_result.num_snapshots();
1184   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
1185 
1186   // create the result ThreadInfo[] object
1187   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
1188   objArrayOop r = oopFactory::new_objArray(ik, num_snapshots, CHECK_NULL);
1189   objArrayHandle result_h(THREAD, r);
1190 
1191   int index = 0;
1192   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; ts = ts-&gt;next(), index++) {
1193     if (ts-&gt;threadObj() == NULL) {
1194      // if the thread does not exist or now it is terminated, set threadinfo to NULL
1195       result_h-&gt;obj_at_put(index, NULL);
1196       continue;
1197     }
1198 
1199     ThreadStackTrace* stacktrace = ts-&gt;get_stack_trace();
1200     assert(stacktrace != NULL, &quot;Must have a stack trace dumped&quot;);
1201 
1202     // Create Object[] filled with locked monitors
1203     // Create int[] filled with the stack depth where a monitor was locked
1204     int num_frames = stacktrace-&gt;get_stack_depth();
1205     int num_locked_monitors = stacktrace-&gt;num_jni_locked_monitors();
1206 
1207     // Count the total number of locked monitors
1208     for (int i = 0; i &lt; num_frames; i++) {
1209       StackFrameInfo* frame = stacktrace-&gt;stack_frame_at(i);
1210       num_locked_monitors += frame-&gt;num_locked_monitors();
1211     }
1212 
1213     objArrayHandle monitors_array;
1214     typeArrayHandle depths_array;
1215     objArrayHandle synchronizers_array;
1216 
1217     if (locked_monitors) {
1218       // Constructs Object[] and int[] to contain the object monitor and the stack depth
1219       // where the thread locked it
1220       objArrayOop array = oopFactory::new_objArray(SystemDictionary::Object_klass(), num_locked_monitors, CHECK_NULL);
1221       objArrayHandle mh(THREAD, array);
1222       monitors_array = mh;
1223 
1224       typeArrayOop tarray = oopFactory::new_typeArray(T_INT, num_locked_monitors, CHECK_NULL);
1225       typeArrayHandle dh(THREAD, tarray);
1226       depths_array = dh;
1227 
1228       int count = 0;
1229       int j = 0;
1230       for (int depth = 0; depth &lt; num_frames; depth++) {
1231         StackFrameInfo* frame = stacktrace-&gt;stack_frame_at(depth);
1232         int len = frame-&gt;num_locked_monitors();
1233         GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
1234         for (j = 0; j &lt; len; j++) {
1235           oop monitor = locked_monitors-&gt;at(j);
1236           assert(monitor != NULL, &quot;must be a Java object&quot;);
1237           monitors_array-&gt;obj_at_put(count, monitor);
1238           depths_array-&gt;int_at_put(count, depth);
1239           count++;
1240         }
1241       }
1242 
1243       GrowableArray&lt;oop&gt;* jni_locked_monitors = stacktrace-&gt;jni_locked_monitors();
1244       for (j = 0; j &lt; jni_locked_monitors-&gt;length(); j++) {
1245         oop object = jni_locked_monitors-&gt;at(j);
1246         assert(object != NULL, &quot;must be a Java object&quot;);
1247         monitors_array-&gt;obj_at_put(count, object);
1248         // Monitor locked via JNI MonitorEnter call doesn&#39;t have stack depth info
1249         depths_array-&gt;int_at_put(count, -1);
1250         count++;
1251       }
1252       assert(count == num_locked_monitors, &quot;number of locked monitors doesn&#39;t match&quot;);
1253     }
1254 
1255     if (locked_synchronizers) {
1256       // Create Object[] filled with locked JSR-166 synchronizers
1257       assert(ts-&gt;threadObj() != NULL, &quot;Must be a valid JavaThread&quot;);
1258       ThreadConcurrentLocks* tcl = ts-&gt;get_concurrent_locks();
1259       GrowableArray&lt;instanceOop&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
1260       int num_locked_synchronizers = (locks != NULL ? locks-&gt;length() : 0);
1261 
1262       objArrayOop array = oopFactory::new_objArray(SystemDictionary::Object_klass(), num_locked_synchronizers, CHECK_NULL);
1263       objArrayHandle sh(THREAD, array);
1264       synchronizers_array = sh;
1265 
1266       for (int k = 0; k &lt; num_locked_synchronizers; k++) {
1267         synchronizers_array-&gt;obj_at_put(k, locks-&gt;at(k));
1268       }
1269     }
1270 
1271     // Create java.lang.management.ThreadInfo object
1272     instanceOop info_obj = Management::create_thread_info_instance(ts,
1273                                                                    monitors_array,
1274                                                                    depths_array,
1275                                                                    synchronizers_array,
1276                                                                    CHECK_NULL);
1277     result_h-&gt;obj_at_put(index, info_obj);
1278   }
1279 
1280   return (jobjectArray) JNIHandles::make_local(env, result_h());
1281 JVM_END
1282 
1283 // Reset statistic.  Return true if the requested statistic is reset.
1284 // Otherwise, return false.
1285 //
1286 // Input parameters:
1287 //  obj  - specify which instance the statistic associated with to be reset
1288 //         For PEAK_POOL_USAGE stat, obj is required to be a memory pool object.
1289 //         For THREAD_CONTENTION_COUNT and TIME stat, obj is required to be a thread ID.
1290 //  type - the type of statistic to be reset
1291 //
1292 JVM_ENTRY(jboolean, jmm_ResetStatistic(JNIEnv *env, jvalue obj, jmmStatisticType type))
1293   ResourceMark rm(THREAD);
1294 
1295   switch (type) {
1296     case JMM_STAT_PEAK_THREAD_COUNT:
1297       ThreadService::reset_peak_thread_count();
1298       return true;
1299 
1300     case JMM_STAT_THREAD_CONTENTION_COUNT:
1301     case JMM_STAT_THREAD_CONTENTION_TIME: {
1302       jlong tid = obj.j;
1303       if (tid &lt; 0) {
1304         THROW_(vmSymbols::java_lang_IllegalArgumentException(), JNI_FALSE);
1305       }
1306 
1307       // Look for the JavaThread of this given tid
1308       JavaThreadIteratorWithHandle jtiwh;
1309       if (tid == 0) {
1310         // reset contention statistics for all threads if tid == 0
1311         for (; JavaThread *java_thread = jtiwh.next(); ) {
1312           if (type == JMM_STAT_THREAD_CONTENTION_COUNT) {
1313             ThreadService::reset_contention_count_stat(java_thread);
1314           } else {
1315             ThreadService::reset_contention_time_stat(java_thread);
1316           }
1317         }
1318       } else {
1319         // reset contention statistics for a given thread
1320         JavaThread* java_thread = jtiwh.list()-&gt;find_JavaThread_from_java_tid(tid);
1321         if (java_thread == NULL) {
1322           return false;
1323         }
1324 
1325         if (type == JMM_STAT_THREAD_CONTENTION_COUNT) {
1326           ThreadService::reset_contention_count_stat(java_thread);
1327         } else {
1328           ThreadService::reset_contention_time_stat(java_thread);
1329         }
1330       }
1331       return true;
1332       break;
1333     }
1334     case JMM_STAT_PEAK_POOL_USAGE: {
1335       jobject o = obj.l;
1336       if (o == NULL) {
1337         THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
1338       }
1339 
1340       oop pool_obj = JNIHandles::resolve(o);
1341       assert(pool_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
1342       instanceHandle ph(THREAD, (instanceOop) pool_obj);
1343 
1344       MemoryPool* pool = MemoryService::get_memory_pool(ph);
1345       if (pool != NULL) {
1346         pool-&gt;reset_peak_memory_usage();
1347         return true;
1348       }
1349       break;
1350     }
1351     case JMM_STAT_GC_STAT: {
1352       jobject o = obj.l;
1353       if (o == NULL) {
1354         THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
1355       }
1356 
1357       GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(o, CHECK_0);
1358       if (mgr != NULL) {
1359         mgr-&gt;reset_gc_stat();
1360         return true;
1361       }
1362       break;
1363     }
1364     default:
1365       assert(0, &quot;Unknown Statistic Type&quot;);
1366   }
1367   return false;
1368 JVM_END
1369 
1370 // Returns the fast estimate of CPU time consumed by
1371 // a given thread (in nanoseconds).
1372 // If thread_id == 0, return CPU time for the current thread.
1373 JVM_ENTRY(jlong, jmm_GetThreadCpuTime(JNIEnv *env, jlong thread_id))
1374   if (!os::is_thread_cpu_time_supported()) {
1375     return -1;
1376   }
1377 
1378   if (thread_id &lt; 0) {
1379     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1380                &quot;Invalid thread ID&quot;, -1);
1381   }
1382 
1383   JavaThread* java_thread = NULL;
1384   if (thread_id == 0) {
1385     // current thread
1386     return os::current_thread_cpu_time();
1387   } else {
1388     ThreadsListHandle tlh;
1389     java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);
1390     if (java_thread != NULL) {
1391       return os::thread_cpu_time((Thread*) java_thread);
1392     }
1393   }
1394   return -1;
1395 JVM_END
1396 
1397 // Returns a String array of all VM global flag names
1398 JVM_ENTRY(jobjectArray, jmm_GetVMGlobalNames(JNIEnv *env))
1399   // last flag entry is always NULL, so subtract 1
1400   int nFlags = (int) JVMFlag::numFlags - 1;
1401   // allocate a temp array
1402   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1403                                            nFlags, CHECK_0);
1404   objArrayHandle flags_ah(THREAD, r);
1405   int num_entries = 0;
1406   for (int i = 0; i &lt; nFlags; i++) {
1407     JVMFlag* flag = &amp;JVMFlag::flags[i];
1408     // Exclude notproduct and develop flags in product builds.
1409     if (flag-&gt;is_constant_in_binary()) {
1410       continue;
1411     }
1412     // Exclude the locked (experimental, diagnostic) flags
1413     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
1414       Handle s = java_lang_String::create_from_str(flag-&gt;_name, CHECK_0);
1415       flags_ah-&gt;obj_at_put(num_entries, s());
1416       num_entries++;
1417     }
1418   }
1419 
1420   if (num_entries &lt; nFlags) {
1421     // Return array of right length
1422     objArrayOop res = oopFactory::new_objArray(SystemDictionary::String_klass(), num_entries, CHECK_0);
1423     for(int i = 0; i &lt; num_entries; i++) {
1424       res-&gt;obj_at_put(i, flags_ah-&gt;obj_at(i));
1425     }
1426     return (jobjectArray)JNIHandles::make_local(env, res);
1427   }
1428 
1429   return (jobjectArray)JNIHandles::make_local(env, flags_ah());
1430 JVM_END
1431 
1432 // Utility function used by jmm_GetVMGlobals.  Returns false if flag type
1433 // can&#39;t be determined, true otherwise.  If false is returned, then *global
1434 // will be incomplete and invalid.
1435 bool add_global_entry(JNIEnv* env, Handle name, jmmVMGlobal *global, JVMFlag *flag, TRAPS) {
1436   Handle flag_name;
1437   if (name() == NULL) {
1438     flag_name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_false);
1439   } else {
1440     flag_name = name;
1441   }
1442   global-&gt;name = (jstring)JNIHandles::make_local(env, flag_name());
1443 
1444   if (flag-&gt;is_bool()) {
1445     global-&gt;value.z = flag-&gt;get_bool() ? JNI_TRUE : JNI_FALSE;
1446     global-&gt;type = JMM_VMGLOBAL_TYPE_JBOOLEAN;
1447   } else if (flag-&gt;is_int()) {
1448     global-&gt;value.j = (jlong)flag-&gt;get_int();
1449     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1450   } else if (flag-&gt;is_uint()) {
1451     global-&gt;value.j = (jlong)flag-&gt;get_uint();
1452     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1453   } else if (flag-&gt;is_intx()) {
1454     global-&gt;value.j = (jlong)flag-&gt;get_intx();
1455     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1456   } else if (flag-&gt;is_uintx()) {
1457     global-&gt;value.j = (jlong)flag-&gt;get_uintx();
1458     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1459   } else if (flag-&gt;is_uint64_t()) {
1460     global-&gt;value.j = (jlong)flag-&gt;get_uint64_t();
1461     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1462   } else if (flag-&gt;is_double()) {
1463     global-&gt;value.d = (jdouble)flag-&gt;get_double();
1464     global-&gt;type = JMM_VMGLOBAL_TYPE_JDOUBLE;
1465   } else if (flag-&gt;is_size_t()) {
1466     global-&gt;value.j = (jlong)flag-&gt;get_size_t();
1467     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1468   } else if (flag-&gt;is_ccstr()) {
1469     Handle str = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_false);
1470     global-&gt;value.l = (jobject)JNIHandles::make_local(env, str());
1471     global-&gt;type = JMM_VMGLOBAL_TYPE_JSTRING;
1472   } else {
1473     global-&gt;type = JMM_VMGLOBAL_TYPE_UNKNOWN;
1474     return false;
1475   }
1476 
1477   global-&gt;writeable = flag-&gt;is_writeable();
1478   global-&gt;external = flag-&gt;is_external();
1479   switch (flag-&gt;get_origin()) {
1480     case JVMFlag::DEFAULT:
1481       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_DEFAULT;
1482       break;
1483     case JVMFlag::COMMAND_LINE:
1484       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_COMMAND_LINE;
1485       break;
1486     case JVMFlag::ENVIRON_VAR:
1487       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ENVIRON_VAR;
1488       break;
1489     case JVMFlag::CONFIG_FILE:
1490       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_CONFIG_FILE;
1491       break;
1492     case JVMFlag::MANAGEMENT:
1493       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_MANAGEMENT;
1494       break;
1495     case JVMFlag::ERGONOMIC:
1496       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ERGONOMIC;
1497       break;
1498     case JVMFlag::ATTACH_ON_DEMAND:
1499       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ATTACH_ON_DEMAND;
1500       break;
1501     default:
1502       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_OTHER;
1503   }
1504 
1505   return true;
1506 }
1507 
1508 // Fill globals array of count length with jmmVMGlobal entries
1509 // specified by names. If names == NULL, fill globals array
1510 // with all Flags. Return value is number of entries
1511 // created in globals.
1512 // If a JVMFlag with a given name in an array element does not
1513 // exist, globals[i].name will be set to NULL.
1514 JVM_ENTRY(jint, jmm_GetVMGlobals(JNIEnv *env,
1515                                  jobjectArray names,
1516                                  jmmVMGlobal *globals,
1517                                  jint count))
1518 
1519 
1520   if (globals == NULL) {
1521     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1522   }
1523 
1524   ResourceMark rm(THREAD);
1525 
1526   if (names != NULL) {
1527     // return the requested globals
1528     objArrayOop ta = objArrayOop(JNIHandles::resolve_non_null(names));
1529     objArrayHandle names_ah(THREAD, ta);
1530     // Make sure we have a String array
1531     Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1532     if (element_klass != SystemDictionary::String_klass()) {
1533       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1534                  &quot;Array element type is not String class&quot;, 0);
1535     }
1536 
1537     int names_length = names_ah-&gt;length();
1538     int num_entries = 0;
1539     for (int i = 0; i &lt; names_length &amp;&amp; i &lt; count; i++) {
1540       oop s = names_ah-&gt;obj_at(i);
1541       if (s == NULL) {
1542         THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1543       }
1544 
1545       Handle sh(THREAD, s);
1546       char* str = java_lang_String::as_utf8_string(s);
<a name="8" id="anc8"></a><span class="line-modified">1547       JVMFlag* flag = JVMFlag::find_flag(str, strlen(str));</span>
1548       if (flag != NULL &amp;&amp;
1549           add_global_entry(env, sh, &amp;globals[i], flag, THREAD)) {
1550         num_entries++;
1551       } else {
1552         globals[i].name = NULL;
1553       }
1554     }
1555     return num_entries;
1556   } else {
1557     // return all globals if names == NULL
1558 
1559     // last flag entry is always NULL, so subtract 1
1560     int nFlags = (int) JVMFlag::numFlags - 1;
1561     Handle null_h;
1562     int num_entries = 0;
1563     for (int i = 0; i &lt; nFlags &amp;&amp; num_entries &lt; count;  i++) {
1564       JVMFlag* flag = &amp;JVMFlag::flags[i];
1565       // Exclude notproduct and develop flags in product builds.
1566       if (flag-&gt;is_constant_in_binary()) {
1567         continue;
1568       }
1569       // Exclude the locked (diagnostic, experimental) flags
1570       if ((flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) &amp;&amp;
1571           add_global_entry(env, null_h, &amp;globals[num_entries], flag, THREAD)) {
1572         num_entries++;
1573       }
1574     }
1575     return num_entries;
1576   }
1577 JVM_END
1578 
1579 JVM_ENTRY(void, jmm_SetVMGlobal(JNIEnv *env, jstring flag_name, jvalue new_value))
1580   ResourceMark rm(THREAD);
1581 
1582   oop fn = JNIHandles::resolve_external_guard(flag_name);
1583   if (fn == NULL) {
1584     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1585               &quot;The flag name cannot be null.&quot;);
1586   }
1587   char* name = java_lang_String::as_utf8_string(fn);
1588 
1589   FormatBuffer&lt;80&gt; error_msg(&quot;%s&quot;, &quot;&quot;);
1590   int succeed = WriteableFlags::set_flag(name, new_value, JVMFlag::MANAGEMENT, error_msg);
1591 
1592   if (succeed != JVMFlag::SUCCESS) {
1593     if (succeed == JVMFlag::MISSING_VALUE) {
1594       // missing value causes NPE to be thrown
1595       THROW(vmSymbols::java_lang_NullPointerException());
1596     } else {
1597       // all the other errors are reported as IAE with the appropriate error message
1598       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1599                 error_msg.buffer());
1600     }
1601   }
1602   assert(succeed == JVMFlag::SUCCESS, &quot;Setting flag should succeed&quot;);
1603 JVM_END
1604 
1605 class ThreadTimesClosure: public ThreadClosure {
1606  private:
1607   objArrayHandle _names_strings;
1608   char **_names_chars;
1609   typeArrayHandle _times;
1610   int _names_len;
1611   int _times_len;
1612   int _count;
1613 
1614  public:
1615   ThreadTimesClosure(objArrayHandle names, typeArrayHandle times);
1616   ~ThreadTimesClosure();
1617   virtual void do_thread(Thread* thread);
1618   void do_unlocked();
1619   int count() { return _count; }
1620 };
1621 
1622 ThreadTimesClosure::ThreadTimesClosure(objArrayHandle names,
1623                                        typeArrayHandle times) {
1624   assert(names() != NULL, &quot;names was NULL&quot;);
1625   assert(times() != NULL, &quot;times was NULL&quot;);
1626   _names_strings = names;
1627   _names_len = names-&gt;length();
1628   _names_chars = NEW_C_HEAP_ARRAY(char*, _names_len, mtInternal);
1629   _times = times;
1630   _times_len = times-&gt;length();
1631   _count = 0;
1632 }
1633 
1634 //
1635 // Called with Threads_lock held
1636 //
1637 void ThreadTimesClosure::do_thread(Thread* thread) {
1638   assert(Threads_lock-&gt;owned_by_self(), &quot;Must hold Threads_lock&quot;);
1639   assert(thread != NULL, &quot;thread was NULL&quot;);
1640 
1641   // exclude externally visible JavaThreads
1642   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1643     return;
1644   }
1645 
1646   if (_count &gt;= _names_len || _count &gt;= _times_len) {
1647     // skip if the result array is not big enough
1648     return;
1649   }
1650 
1651   EXCEPTION_MARK;
1652   ResourceMark rm(THREAD); // thread-&gt;name() uses ResourceArea
1653 
1654   assert(thread-&gt;name() != NULL, &quot;All threads should have a name&quot;);
1655   _names_chars[_count] = os::strdup(thread-&gt;name());
1656   _times-&gt;long_at_put(_count, os::is_thread_cpu_time_supported() ?
1657                         os::thread_cpu_time(thread) : -1);
1658   _count++;
1659 }
1660 
1661 // Called without Threads_lock, we can allocate String objects.
1662 void ThreadTimesClosure::do_unlocked() {
1663 
1664   EXCEPTION_MARK;
1665   for (int i = 0; i &lt; _count; i++) {
1666     Handle s = java_lang_String::create_from_str(_names_chars[i],  CHECK);
1667     _names_strings-&gt;obj_at_put(i, s());
1668   }
1669 }
1670 
1671 ThreadTimesClosure::~ThreadTimesClosure() {
1672   for (int i = 0; i &lt; _count; i++) {
1673     os::free(_names_chars[i]);
1674   }
1675   FREE_C_HEAP_ARRAY(char *, _names_chars);
1676 }
1677 
1678 // Fills names with VM internal thread names and times with the corresponding
1679 // CPU times.  If names or times is NULL, a NullPointerException is thrown.
1680 // If the element type of names is not String, an IllegalArgumentException is
1681 // thrown.
1682 // If an array is not large enough to hold all the entries, only the entries
1683 // that fit will be returned.  Return value is the number of VM internal
1684 // threads entries.
1685 JVM_ENTRY(jint, jmm_GetInternalThreadTimes(JNIEnv *env,
1686                                            jobjectArray names,
1687                                            jlongArray times))
1688   if (names == NULL || times == NULL) {
1689      THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1690   }
1691   objArrayOop na = objArrayOop(JNIHandles::resolve_non_null(names));
1692   objArrayHandle names_ah(THREAD, na);
1693 
1694   // Make sure we have a String array
1695   Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1696   if (element_klass != SystemDictionary::String_klass()) {
1697     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1698                &quot;Array element type is not String class&quot;, 0);
1699   }
1700 
1701   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(times));
1702   typeArrayHandle times_ah(THREAD, ta);
1703 
1704   ThreadTimesClosure ttc(names_ah, times_ah);
1705   {
<a name="9" id="anc9"></a><span class="line-modified">1706     MutexLockerEx ml(Threads_lock);</span>
1707     Threads::threads_do(&amp;ttc);
1708   }
1709   ttc.do_unlocked();
1710   return ttc.count();
1711 JVM_END
1712 
1713 static Handle find_deadlocks(bool object_monitors_only, TRAPS) {
1714   ResourceMark rm(THREAD);
1715 
1716   VM_FindDeadlocks op(!object_monitors_only /* also check concurrent locks? */);
1717   VMThread::execute(&amp;op);
1718 
1719   DeadlockCycle* deadlocks = op.result();
1720   if (deadlocks == NULL) {
1721     // no deadlock found and return
1722     return Handle();
1723   }
1724 
1725   int num_threads = 0;
1726   DeadlockCycle* cycle;
1727   for (cycle = deadlocks; cycle != NULL; cycle = cycle-&gt;next()) {
1728     num_threads += cycle-&gt;num_threads();
1729   }
1730 
1731   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NH);
1732   objArrayHandle threads_ah(THREAD, r);
1733 
1734   int index = 0;
1735   for (cycle = deadlocks; cycle != NULL; cycle = cycle-&gt;next()) {
1736     GrowableArray&lt;JavaThread*&gt;* deadlock_threads = cycle-&gt;threads();
1737     int len = deadlock_threads-&gt;length();
1738     for (int i = 0; i &lt; len; i++) {
1739       threads_ah-&gt;obj_at_put(index, deadlock_threads-&gt;at(i)-&gt;threadObj());
1740       index++;
1741     }
1742   }
1743   return threads_ah;
1744 }
1745 
1746 // Finds cycles of threads that are deadlocked involved in object monitors
1747 // and JSR-166 synchronizers.
1748 // Returns an array of Thread objects which are in deadlock, if any.
1749 // Otherwise, returns NULL.
1750 //
1751 // Input parameter:
1752 //    object_monitors_only - if true, only check object monitors
1753 //
1754 JVM_ENTRY(jobjectArray, jmm_FindDeadlockedThreads(JNIEnv *env, jboolean object_monitors_only))
1755   Handle result = find_deadlocks(object_monitors_only != 0, CHECK_0);
1756   return (jobjectArray) JNIHandles::make_local(env, result());
1757 JVM_END
1758 
1759 // Finds cycles of threads that are deadlocked on monitor locks
1760 // Returns an array of Thread objects which are in deadlock, if any.
1761 // Otherwise, returns NULL.
1762 JVM_ENTRY(jobjectArray, jmm_FindMonitorDeadlockedThreads(JNIEnv *env))
1763   Handle result = find_deadlocks(true, CHECK_0);
1764   return (jobjectArray) JNIHandles::make_local(env, result());
1765 JVM_END
1766 
1767 // Gets the information about GC extension attributes including
1768 // the name of the attribute, its type, and a short description.
1769 //
1770 // Input parameters:
1771 //   mgr   - GC memory manager
1772 //   info  - caller allocated array of jmmExtAttributeInfo
1773 //   count - number of elements of the info array
1774 //
1775 // Returns the number of GC extension attributes filled in the info array; or
1776 // -1 if info is not big enough
1777 //
1778 JVM_ENTRY(jint, jmm_GetGCExtAttributeInfo(JNIEnv *env, jobject mgr, jmmExtAttributeInfo* info, jint count))
1779   // All GC memory managers have 1 attribute (number of GC threads)
1780   if (count == 0) {
1781     return 0;
1782   }
1783 
1784   if (info == NULL) {
1785    THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1786   }
1787 
1788   info[0].name = &quot;GcThreadCount&quot;;
1789   info[0].type = &#39;I&#39;;
1790   info[0].description = &quot;Number of GC threads&quot;;
1791   return 1;
1792 JVM_END
1793 
1794 // verify the given array is an array of java/lang/management/MemoryUsage objects
1795 // of a given length and return the objArrayOop
1796 static objArrayOop get_memory_usage_objArray(jobjectArray array, int length, TRAPS) {
1797   if (array == NULL) {
1798     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1799   }
1800 
1801   objArrayOop oa = objArrayOop(JNIHandles::resolve_non_null(array));
1802   objArrayHandle array_h(THREAD, oa);
1803 
1804   // array must be of the given length
1805   if (length != array_h-&gt;length()) {
1806     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1807                &quot;The length of the given MemoryUsage array does not match the number of memory pools.&quot;, 0);
1808   }
1809 
1810   // check if the element of array is of type MemoryUsage class
1811   Klass* usage_klass = Management::java_lang_management_MemoryUsage_klass(CHECK_0);
1812   Klass* element_klass = ObjArrayKlass::cast(array_h-&gt;klass())-&gt;element_klass();
1813   if (element_klass != usage_klass) {
1814     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1815                &quot;The element type is not MemoryUsage class&quot;, 0);
1816   }
1817 
1818   return array_h();
1819 }
1820 
1821 // Gets the statistics of the last GC of a given GC memory manager.
1822 // Input parameters:
1823 //   obj     - GarbageCollectorMXBean object
1824 //   gc_stat - caller allocated jmmGCStat where:
1825 //     a. before_gc_usage - array of MemoryUsage objects
1826 //     b. after_gc_usage  - array of MemoryUsage objects
1827 //     c. gc_ext_attributes_values_size is set to the
1828 //        gc_ext_attribute_values array allocated
1829 //     d. gc_ext_attribute_values is a caller allocated array of jvalue.
1830 //
1831 // On return,
1832 //   gc_index == 0 indicates no GC statistics available
1833 //
1834 //   before_gc_usage and after_gc_usage - filled with per memory pool
1835 //      before and after GC usage in the same order as the memory pools
1836 //      returned by GetMemoryPools for a given GC memory manager.
1837 //   num_gc_ext_attributes indicates the number of elements in
1838 //      the gc_ext_attribute_values array is filled; or
1839 //      -1 if the gc_ext_attributes_values array is not big enough
1840 //
1841 JVM_ENTRY(void, jmm_GetLastGCStat(JNIEnv *env, jobject obj, jmmGCStat *gc_stat))
1842   ResourceMark rm(THREAD);
1843 
1844   if (gc_stat-&gt;gc_ext_attribute_values_size &gt; 0 &amp;&amp; gc_stat-&gt;gc_ext_attribute_values == NULL) {
1845     THROW(vmSymbols::java_lang_NullPointerException());
1846   }
1847 
1848   // Get the GCMemoryManager
1849   GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK);
1850 
1851   // Make a copy of the last GC statistics
1852   // GC may occur while constructing the last GC information
1853   int num_pools = MemoryService::num_memory_pools();
1854   GCStatInfo stat(num_pools);
1855   if (mgr-&gt;get_last_gc_stat(&amp;stat) == 0) {
1856     gc_stat-&gt;gc_index = 0;
1857     return;
1858   }
1859 
1860   gc_stat-&gt;gc_index = stat.gc_index();
1861   gc_stat-&gt;start_time = Management::ticks_to_ms(stat.start_time());
1862   gc_stat-&gt;end_time = Management::ticks_to_ms(stat.end_time());
1863 
1864   // Current implementation does not have GC extension attributes
1865   gc_stat-&gt;num_gc_ext_attributes = 0;
1866 
1867   // Fill the arrays of MemoryUsage objects with before and after GC
1868   // per pool memory usage
1869   objArrayOop bu = get_memory_usage_objArray(gc_stat-&gt;usage_before_gc,
1870                                              num_pools,
1871                                              CHECK);
1872   objArrayHandle usage_before_gc_ah(THREAD, bu);
1873 
1874   objArrayOop au = get_memory_usage_objArray(gc_stat-&gt;usage_after_gc,
1875                                              num_pools,
1876                                              CHECK);
1877   objArrayHandle usage_after_gc_ah(THREAD, au);
1878 
1879   for (int i = 0; i &lt; num_pools; i++) {
1880     Handle before_usage = MemoryService::create_MemoryUsage_obj(stat.before_gc_usage_for_pool(i), CHECK);
1881     Handle after_usage;
1882 
1883     MemoryUsage u = stat.after_gc_usage_for_pool(i);
1884     if (u.max_size() == 0 &amp;&amp; u.used() &gt; 0) {
1885       // If max size == 0, this pool is a survivor space.
1886       // Set max size = -1 since the pools will be swapped after GC.
1887       MemoryUsage usage(u.init_size(), u.used(), u.committed(), (size_t)-1);
1888       after_usage = MemoryService::create_MemoryUsage_obj(usage, CHECK);
1889     } else {
1890       after_usage = MemoryService::create_MemoryUsage_obj(stat.after_gc_usage_for_pool(i), CHECK);
1891     }
1892     usage_before_gc_ah-&gt;obj_at_put(i, before_usage());
1893     usage_after_gc_ah-&gt;obj_at_put(i, after_usage());
1894   }
1895 
1896   if (gc_stat-&gt;gc_ext_attribute_values_size &gt; 0) {
1897     // Current implementation only has 1 attribute (number of GC threads)
1898     // The type is &#39;I&#39;
1899     gc_stat-&gt;gc_ext_attribute_values[0].i = mgr-&gt;num_gc_threads();
1900   }
1901 JVM_END
1902 
1903 JVM_ENTRY(void, jmm_SetGCNotificationEnabled(JNIEnv *env, jobject obj, jboolean enabled))
1904   ResourceMark rm(THREAD);
1905   // Get the GCMemoryManager
1906   GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK);
1907   mgr-&gt;set_notification_enabled(enabled?true:false);
1908 JVM_END
1909 
1910 // Dump heap - Returns 0 if succeeds.
1911 JVM_ENTRY(jint, jmm_DumpHeap0(JNIEnv *env, jstring outputfile, jboolean live))
1912 #if INCLUDE_SERVICES
1913   ResourceMark rm(THREAD);
1914   oop on = JNIHandles::resolve_external_guard(outputfile);
1915   if (on == NULL) {
1916     THROW_MSG_(vmSymbols::java_lang_NullPointerException(),
1917                &quot;Output file name cannot be null.&quot;, -1);
1918   }
1919   Handle onhandle(THREAD, on);
1920   char* name = java_lang_String::as_platform_dependent_str(onhandle, CHECK_(-1));
1921   if (name == NULL) {
1922     THROW_MSG_(vmSymbols::java_lang_NullPointerException(),
1923                &quot;Output file name cannot be null.&quot;, -1);
1924   }
1925   HeapDumper dumper(live ? true : false);
1926   if (dumper.dump(name) != 0) {
1927     const char* errmsg = dumper.error_as_C_string();
1928     THROW_MSG_(vmSymbols::java_io_IOException(), errmsg, -1);
1929   }
1930   return 0;
1931 #else  // INCLUDE_SERVICES
1932   return -1;
1933 #endif // INCLUDE_SERVICES
1934 JVM_END
1935 
1936 JVM_ENTRY(jobjectArray, jmm_GetDiagnosticCommands(JNIEnv *env))
1937   ResourceMark rm(THREAD);
1938   GrowableArray&lt;const char *&gt;* dcmd_list = DCmdFactory::DCmd_list(DCmd_Source_MBean);
1939   objArrayOop cmd_array_oop = oopFactory::new_objArray(SystemDictionary::String_klass(),
1940           dcmd_list-&gt;length(), CHECK_NULL);
1941   objArrayHandle cmd_array(THREAD, cmd_array_oop);
1942   for (int i = 0; i &lt; dcmd_list-&gt;length(); i++) {
1943     oop cmd_name = java_lang_String::create_oop_from_str(dcmd_list-&gt;at(i), CHECK_NULL);
1944     cmd_array-&gt;obj_at_put(i, cmd_name);
1945   }
1946   return (jobjectArray) JNIHandles::make_local(env, cmd_array());
1947 JVM_END
1948 
1949 JVM_ENTRY(void, jmm_GetDiagnosticCommandInfo(JNIEnv *env, jobjectArray cmds,
1950           dcmdInfo* infoArray))
1951   if (cmds == NULL || infoArray == NULL) {
1952     THROW(vmSymbols::java_lang_NullPointerException());
1953   }
1954 
1955   ResourceMark rm(THREAD);
1956 
1957   objArrayOop ca = objArrayOop(JNIHandles::resolve_non_null(cmds));
1958   objArrayHandle cmds_ah(THREAD, ca);
1959 
1960   // Make sure we have a String array
1961   Klass* element_klass = ObjArrayKlass::cast(cmds_ah-&gt;klass())-&gt;element_klass();
1962   if (element_klass != SystemDictionary::String_klass()) {
1963     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1964                &quot;Array element type is not String class&quot;);
1965   }
1966 
1967   GrowableArray&lt;DCmdInfo *&gt;* info_list = DCmdFactory::DCmdInfo_list(DCmd_Source_MBean);
1968 
1969   int num_cmds = cmds_ah-&gt;length();
1970   for (int i = 0; i &lt; num_cmds; i++) {
1971     oop cmd = cmds_ah-&gt;obj_at(i);
1972     if (cmd == NULL) {
1973         THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1974                 &quot;Command name cannot be null.&quot;);
1975     }
1976     char* cmd_name = java_lang_String::as_utf8_string(cmd);
1977     if (cmd_name == NULL) {
1978         THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1979                 &quot;Command name cannot be null.&quot;);
1980     }
1981     int pos = info_list-&gt;find((void*)cmd_name,DCmdInfo::by_name);
1982     if (pos == -1) {
1983         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1984              &quot;Unknown diagnostic command&quot;);
1985     }
1986     DCmdInfo* info = info_list-&gt;at(pos);
1987     infoArray[i].name = info-&gt;name();
1988     infoArray[i].description = info-&gt;description();
1989     infoArray[i].impact = info-&gt;impact();
1990     JavaPermission p = info-&gt;permission();
1991     infoArray[i].permission_class = p._class;
1992     infoArray[i].permission_name = p._name;
1993     infoArray[i].permission_action = p._action;
1994     infoArray[i].num_arguments = info-&gt;num_arguments();
1995     infoArray[i].enabled = info-&gt;is_enabled();
1996   }
1997 JVM_END
1998 
1999 JVM_ENTRY(void, jmm_GetDiagnosticCommandArgumentsInfo(JNIEnv *env,
2000           jstring command, dcmdArgInfo* infoArray))
2001   ResourceMark rm(THREAD);
2002   oop cmd = JNIHandles::resolve_external_guard(command);
2003   if (cmd == NULL) {
2004     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
2005               &quot;Command line cannot be null.&quot;);
2006   }
2007   char* cmd_name = java_lang_String::as_utf8_string(cmd);
2008   if (cmd_name == NULL) {
2009     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
2010               &quot;Command line content cannot be null.&quot;);
2011   }
2012   DCmd* dcmd = NULL;
2013   DCmdFactory*factory = DCmdFactory::factory(DCmd_Source_MBean, cmd_name,
2014                                              strlen(cmd_name));
2015   if (factory != NULL) {
2016     dcmd = factory-&gt;create_resource_instance(NULL);
2017   }
2018   if (dcmd == NULL) {
2019     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2020               &quot;Unknown diagnostic command&quot;);
2021   }
2022   DCmdMark mark(dcmd);
2023   GrowableArray&lt;DCmdArgumentInfo*&gt;* array = dcmd-&gt;argument_info_array();
2024   if (array-&gt;length() == 0) {
2025     return;
2026   }
2027   for (int i = 0; i &lt; array-&gt;length(); i++) {
2028     infoArray[i].name = array-&gt;at(i)-&gt;name();
2029     infoArray[i].description = array-&gt;at(i)-&gt;description();
2030     infoArray[i].type = array-&gt;at(i)-&gt;type();
2031     infoArray[i].default_string = array-&gt;at(i)-&gt;default_string();
2032     infoArray[i].mandatory = array-&gt;at(i)-&gt;is_mandatory();
2033     infoArray[i].option = array-&gt;at(i)-&gt;is_option();
2034     infoArray[i].multiple = array-&gt;at(i)-&gt;is_multiple();
2035     infoArray[i].position = array-&gt;at(i)-&gt;position();
2036   }
2037   return;
2038 JVM_END
2039 
2040 JVM_ENTRY(jstring, jmm_ExecuteDiagnosticCommand(JNIEnv *env, jstring commandline))
2041   ResourceMark rm(THREAD);
2042   oop cmd = JNIHandles::resolve_external_guard(commandline);
2043   if (cmd == NULL) {
2044     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2045                    &quot;Command line cannot be null.&quot;);
2046   }
2047   char* cmdline = java_lang_String::as_utf8_string(cmd);
2048   if (cmdline == NULL) {
2049     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2050                    &quot;Command line content cannot be null.&quot;);
2051   }
2052   bufferedStream output;
2053   DCmd::parse_and_execute(DCmd_Source_MBean, &amp;output, cmdline, &#39; &#39;, CHECK_NULL);
2054   oop result = java_lang_String::create_oop_from_str(output.as_string(), CHECK_NULL);
2055   return (jstring) JNIHandles::make_local(env, result);
2056 JVM_END
2057 
2058 JVM_ENTRY(void, jmm_SetDiagnosticFrameworkNotificationEnabled(JNIEnv *env, jboolean enabled))
2059   DCmdFactory::set_jmx_notification_enabled(enabled?true:false);
2060 JVM_END
2061 
2062 jlong Management::ticks_to_ms(jlong ticks) {
2063   assert(os::elapsed_frequency() &gt; 0, &quot;Must be non-zero&quot;);
2064   return (jlong)(((double)ticks / (double)os::elapsed_frequency())
2065                  * (double)1000.0);
2066 }
2067 #endif // INCLUDE_MANAGEMENT
2068 
<a name="10" id="anc10"></a>
























2069 // Gets an array containing the amount of memory allocated on the Java
2070 // heap for a set of threads (in bytes).  Each element of the array is
2071 // the amount of memory allocated for the thread ID specified in the
2072 // corresponding entry in the given array of thread IDs; or -1 if the
2073 // thread does not exist or has terminated.
2074 JVM_ENTRY(void, jmm_GetThreadAllocatedMemory(JNIEnv *env, jlongArray ids,
2075                                              jlongArray sizeArray))
2076   // Check if threads is null
2077   if (ids == NULL || sizeArray == NULL) {
2078     THROW(vmSymbols::java_lang_NullPointerException());
2079   }
2080 
2081   ResourceMark rm(THREAD);
2082   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2083   typeArrayHandle ids_ah(THREAD, ta);
2084 
2085   typeArrayOop sa = typeArrayOop(JNIHandles::resolve_non_null(sizeArray));
2086   typeArrayHandle sizeArray_h(THREAD, sa);
2087 
2088   // validate the thread id array
2089   validate_thread_id_array(ids_ah, CHECK);
2090 
2091   // sizeArray must be of the same length as the given array of thread IDs
2092   int num_threads = ids_ah-&gt;length();
2093   if (num_threads != sizeArray_h-&gt;length()) {
2094     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2095               &quot;The length of the given long array does not match the length of &quot;
2096               &quot;the given array of thread IDs&quot;);
2097   }
2098 
2099   ThreadsListHandle tlh;
2100   for (int i = 0; i &lt; num_threads; i++) {
2101     JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(ids_ah-&gt;long_at(i));
2102     if (java_thread != NULL) {
2103       sizeArray_h-&gt;long_at_put(i, java_thread-&gt;cooked_allocated_bytes());
2104     }
2105   }
2106 JVM_END
2107 
2108 // Returns the CPU time consumed by a given thread (in nanoseconds).
2109 // If thread_id == 0, CPU time for the current thread is returned.
2110 // If user_sys_cpu_time = true, user level and system CPU time of
2111 // a given thread is returned; otherwise, only user level CPU time
2112 // is returned.
2113 JVM_ENTRY(jlong, jmm_GetThreadCpuTimeWithKind(JNIEnv *env, jlong thread_id, jboolean user_sys_cpu_time))
2114   if (!os::is_thread_cpu_time_supported()) {
2115     return -1;
2116   }
2117 
2118   if (thread_id &lt; 0) {
2119     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
2120                &quot;Invalid thread ID&quot;, -1);
2121   }
2122 
2123   JavaThread* java_thread = NULL;
2124   if (thread_id == 0) {
2125     // current thread
2126     return os::current_thread_cpu_time(user_sys_cpu_time != 0);
2127   } else {
2128     ThreadsListHandle tlh;
2129     java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);
2130     if (java_thread != NULL) {
2131       return os::thread_cpu_time((Thread*) java_thread, user_sys_cpu_time != 0);
2132     }
2133   }
2134   return -1;
2135 JVM_END
2136 
2137 // Gets an array containing the CPU times consumed by a set of threads
2138 // (in nanoseconds).  Each element of the array is the CPU time for the
2139 // thread ID specified in the corresponding entry in the given array
2140 // of thread IDs; or -1 if the thread does not exist or has terminated.
2141 // If user_sys_cpu_time = true, the sum of user level and system CPU time
2142 // for the given thread is returned; otherwise, only user level CPU time
2143 // is returned.
2144 JVM_ENTRY(void, jmm_GetThreadCpuTimesWithKind(JNIEnv *env, jlongArray ids,
2145                                               jlongArray timeArray,
2146                                               jboolean user_sys_cpu_time))
2147   // Check if threads is null
2148   if (ids == NULL || timeArray == NULL) {
2149     THROW(vmSymbols::java_lang_NullPointerException());
2150   }
2151 
2152   ResourceMark rm(THREAD);
2153   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2154   typeArrayHandle ids_ah(THREAD, ta);
2155 
2156   typeArrayOop tia = typeArrayOop(JNIHandles::resolve_non_null(timeArray));
2157   typeArrayHandle timeArray_h(THREAD, tia);
2158 
2159   // validate the thread id array
2160   validate_thread_id_array(ids_ah, CHECK);
2161 
2162   // timeArray must be of the same length as the given array of thread IDs
2163   int num_threads = ids_ah-&gt;length();
2164   if (num_threads != timeArray_h-&gt;length()) {
2165     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2166               &quot;The length of the given long array does not match the length of &quot;
2167               &quot;the given array of thread IDs&quot;);
2168   }
2169 
2170   ThreadsListHandle tlh;
2171   for (int i = 0; i &lt; num_threads; i++) {
2172     JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(ids_ah-&gt;long_at(i));
2173     if (java_thread != NULL) {
2174       timeArray_h-&gt;long_at_put(i, os::thread_cpu_time((Thread*)java_thread,
2175                                                       user_sys_cpu_time != 0));
2176     }
2177   }
2178 JVM_END
2179 
2180 
2181 
2182 #if INCLUDE_MANAGEMENT
2183 const struct jmmInterface_1_ jmm_interface = {
2184   NULL,
2185   NULL,
2186   jmm_GetVersion,
2187   jmm_GetOptionalSupport,
2188   jmm_GetThreadInfo,
2189   jmm_GetMemoryPools,
2190   jmm_GetMemoryManagers,
2191   jmm_GetMemoryPoolUsage,
2192   jmm_GetPeakMemoryPoolUsage,
<a name="11" id="anc11"></a>
2193   jmm_GetThreadAllocatedMemory,
2194   jmm_GetMemoryUsage,
2195   jmm_GetLongAttribute,
2196   jmm_GetBoolAttribute,
2197   jmm_SetBoolAttribute,
2198   jmm_GetLongAttributes,
2199   jmm_FindMonitorDeadlockedThreads,
2200   jmm_GetThreadCpuTime,
2201   jmm_GetVMGlobalNames,
2202   jmm_GetVMGlobals,
2203   jmm_GetInternalThreadTimes,
2204   jmm_ResetStatistic,
2205   jmm_SetPoolSensor,
2206   jmm_SetPoolThreshold,
2207   jmm_GetPoolCollectionUsage,
2208   jmm_GetGCExtAttributeInfo,
2209   jmm_GetLastGCStat,
2210   jmm_GetThreadCpuTimeWithKind,
2211   jmm_GetThreadCpuTimesWithKind,
2212   jmm_DumpHeap0,
2213   jmm_FindDeadlockedThreads,
2214   jmm_SetVMGlobal,
2215   NULL,
2216   jmm_DumpThreads,
2217   jmm_SetGCNotificationEnabled,
2218   jmm_GetDiagnosticCommands,
2219   jmm_GetDiagnosticCommandInfo,
2220   jmm_GetDiagnosticCommandArgumentsInfo,
2221   jmm_ExecuteDiagnosticCommand,
2222   jmm_SetDiagnosticFrameworkNotificationEnabled
2223 };
2224 #endif // INCLUDE_MANAGEMENT
2225 
2226 void* Management::get_jmm_interface(int version) {
2227 #if INCLUDE_MANAGEMENT
2228   if (version == JMM_VERSION) {
2229     return (void*) &amp;jmm_interface;
2230   }
2231 #endif // INCLUDE_MANAGEMENT
2232   return NULL;
2233 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
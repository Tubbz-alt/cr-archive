diff a/src/hotspot/share/services/diagnosticArgument.cpp b/src/hotspot/share/services/diagnosticArgument.cpp
--- a/src/hotspot/share/services/diagnosticArgument.cpp
+++ b/src/hotspot/share/services/diagnosticArgument.cpp
@@ -34,13 +34,11 @@
   assert(_array != NULL, "Sanity check");
 }
 
 StringArrayArgument::~StringArrayArgument() {
   for (int i=0; i<_array->length(); i++) {
-    if(_array->at(i) != NULL) { // Safety check
-      FREE_C_HEAP_ARRAY(char, _array->at(i));
-    }
+    FREE_C_HEAP_ARRAY(char, _array->at(i));
   }
   delete _array;
 }
 
 void StringArrayArgument::add(const char* str, size_t len) {
@@ -151,11 +149,17 @@
        set_value(false);
     } else {
       ResourceMark rm;
 
       char* buf = NEW_RESOURCE_ARRAY(char, len + 1);
+
+PRAGMA_DIAG_PUSH
+PRAGMA_STRINGOP_TRUNCATION_IGNORED
+      // This code can incorrectly cause a "stringop-truncation" warning with gcc
       strncpy(buf, str, len);
+PRAGMA_DIAG_POP
+
       buf[len] = '\0';
       Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
         "Boolean parsing error in command argument '%s'. Could not parse: %s.\n", _name, buf);
     }
   }
@@ -195,14 +199,12 @@
     set_value(NULL);
   }
 }
 
 template <> void DCmdArgument<char*>::destroy_value() {
-  if (_value != NULL) {
-    FREE_C_HEAP_ARRAY(char, _value);
-    set_value(NULL);
-  }
+  FREE_C_HEAP_ARRAY(char, _value);
+  set_value(NULL);
 }
 
 template <> void DCmdArgument<NanoTimeArgument>::parse_value(const char* str,
                                                  size_t len, TRAPS) {
   if (str == NULL) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/memTracker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_MEMTRACKER_HPP
 26 #define SHARE_SERVICES_MEMTRACKER_HPP
 27 
 28 #include &quot;services/nmtCommon.hpp&quot;
 29 #include &quot;utilities/nativeCallStack.hpp&quot;
 30 
 31 
 32 #if !INCLUDE_NMT
 33 
 34 #define CURRENT_PC   NativeCallStack::empty_stack()
 35 #define CALLER_PC    NativeCallStack::empty_stack()
 36 
 37 class Tracker : public StackObj {
 38  public:
 39   enum TrackerType {
 40      uncommit,
 41      release
 42   };
 43   Tracker(enum TrackerType type) : _type(type) { }
 44   void record(address addr, size_t size) { }
 45  private:
 46   enum TrackerType  _type;
 47 };
 48 
 49 class MemTracker : AllStatic {
 50  public:
 51   static inline NMT_TrackingLevel tracking_level() { return NMT_off; }
 52   static inline void shutdown() { }
 53   static inline void init() { }
 54   static bool check_launcher_nmt_support(const char* value) { return true; }
 55   static bool verify_nmt_option() { return true; }
 56 
 57   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
 58     const NativeCallStack&amp; stack, NMT_TrackingLevel level) { return mem_base; }
 59   static inline size_t malloc_header_size(NMT_TrackingLevel level) { return 0; }
 60   static inline size_t malloc_header_size(void* memblock) { return 0; }
 61   static inline void* malloc_base(void* memblock) { return memblock; }
 62   static inline void* record_free(void* memblock) { return memblock; }
 63 
 64   static inline void record_new_arena(MEMFLAGS flag) { }
 65   static inline void record_arena_free(MEMFLAGS flag) { }
 66   static inline void record_arena_size_change(int diff, MEMFLAGS flag) { }
 67   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
 68                        MEMFLAGS flag = mtNone) { }
 69   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
 70     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) { }
 71   static inline void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack&amp; stack) { }
 72   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) { }
 73   static inline void record_thread_stack(void* addr, size_t size) { }
 74   static inline void release_thread_stack(void* addr, size_t size) { }
 75 
 76   static void final_report(outputStream*) { }
 77   static void error_report(outputStream*) { }
 78 };
 79 
 80 #else
 81 
 82 #include &quot;runtime/mutexLocker.hpp&quot;
 83 #include &quot;runtime/threadCritical.hpp&quot;
 84 #include &quot;services/mallocTracker.hpp&quot;
 85 #include &quot;services/virtualMemoryTracker.hpp&quot;
 86 
 87 extern volatile bool NMT_stack_walkable;
 88 
 89 #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ? \
 90                     NativeCallStack(0, true) : NativeCallStack::empty_stack())
 91 #define CALLER_PC  ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ?  \
 92                     NativeCallStack(1, true) : NativeCallStack::empty_stack())
 93 
 94 class MemBaseline;
 95 
 96 // Tracker is used for guarding &#39;release&#39; semantics of virtual memory operation, to avoid
 97 // the other thread obtains and records the same region that is just &#39;released&#39; by current
 98 // thread but before it can record the operation.
 99 class Tracker : public StackObj {
100  public:
101   enum TrackerType {
102      uncommit,
103      release
104   };
105 
106  public:
107   Tracker(enum TrackerType type) : _type(type) { }
108   void record(address addr, size_t size);
109  private:
110   enum TrackerType  _type;
111   // Virtual memory tracking data structures are protected by ThreadCritical lock.
112   ThreadCritical    _tc;
113 };
114 
115 class MemTracker : AllStatic {
116   friend class VirtualMemoryTrackerTest;
117 
118  public:
119   static inline NMT_TrackingLevel tracking_level() {
120     if (_tracking_level == NMT_unknown) {
121       // No fencing is needed here, since JVM is in single-threaded
122       // mode.
123       _tracking_level = init_tracking_level();
124       _cmdline_tracking_level = _tracking_level;
125     }
126     return _tracking_level;
127   }
128 
129   // A late initialization, for the stuff(s) can not be
130   // done in init_tracking_level(), which can NOT malloc
131   // any memory.
132   static void init();
133 
134   // Shutdown native memory tracking
135   static void shutdown();
136 
137   // Verify native memory tracking command line option.
138   // This check allows JVM to detect if compatible launcher
139   // is used.
140   // If an incompatible launcher is used, NMT may not be
141   // able to start, even it is enabled by command line option.
142   // A warning message should be given if it is encountered.
143   static bool check_launcher_nmt_support(const char* value);
144 
145   // This method checks native memory tracking environment
146   // variable value passed by launcher.
147   // Launcher only obligated to pass native memory tracking
148   // option value, but not obligated to validate the value,
149   // and launcher has option to discard native memory tracking
150   // option from the command line once it sets up the environment
151   // variable, so NMT has to catch the bad value here.
152   static bool verify_nmt_option();
153 
154   // Transition the tracking level to specified level
155   static bool transition_to(NMT_TrackingLevel level);
156 
157   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
158     const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
159     return MallocTracker::record_malloc(mem_base, size, flag, stack, level);
160   }
161 
162   static inline size_t malloc_header_size(NMT_TrackingLevel level) {
163     return MallocTracker::malloc_header_size(level);
164   }
165 
166   static size_t malloc_header_size(void* memblock) {
167     if (tracking_level() != NMT_off) {
168       return MallocTracker::get_header_size(memblock);
169     }
170     return 0;
171   }
172 
173   // To malloc base address, which is the starting address
174   // of malloc tracking header if tracking is enabled.
175   // Otherwise, it returns the same address.
176   static void* malloc_base(void* memblock);
177 
178   // Record malloc free and return malloc base address
179   static inline void* record_free(void* memblock) {
180     return MallocTracker::record_free(memblock);
181   }
182 
183 
184   // Record creation of an arena
185   static inline void record_new_arena(MEMFLAGS flag) {
186     if (tracking_level() &lt; NMT_summary) return;
187     MallocTracker::record_new_arena(flag);
188   }
189 
190   // Record destruction of an arena
191   static inline void record_arena_free(MEMFLAGS flag) {
192     if (tracking_level() &lt; NMT_summary) return;
193     MallocTracker::record_arena_free(flag);
194   }
195 
196   // Record arena size change. Arena size is the size of all arena
197   // chuncks that backing up the arena.
198   static inline void record_arena_size_change(int diff, MEMFLAGS flag) {
199     if (tracking_level() &lt; NMT_summary) return;
200     MallocTracker::record_arena_size_change(diff, flag);
201   }
202 
203   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
204     MEMFLAGS flag = mtNone) {
205     if (tracking_level() &lt; NMT_summary) return;
206     if (addr != NULL) {
207       ThreadCritical tc;
208       // Recheck to avoid potential racing during NMT shutdown
209       if (tracking_level() &lt; NMT_summary) return;
210       VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);
211     }
212   }
213 
214   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
215     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) {
216     if (tracking_level() &lt; NMT_summary) return;
217     if (addr != NULL) {
218       ThreadCritical tc;
219       if (tracking_level() &lt; NMT_summary) return;
220       VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);
221       VirtualMemoryTracker::add_committed_region((address)addr, size, stack);
222     }
223   }
224 
225   static inline void record_virtual_memory_commit(void* addr, size_t size,
226     const NativeCallStack&amp; stack) {
227     if (tracking_level() &lt; NMT_summary) return;
228     if (addr != NULL) {
229       ThreadCritical tc;
230       if (tracking_level() &lt; NMT_summary) return;
231       VirtualMemoryTracker::add_committed_region((address)addr, size, stack);
232     }
233   }
234 
235   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) {
236     if (tracking_level() &lt; NMT_summary) return;
237     if (addr != NULL) {
238       ThreadCritical tc;
239       if (tracking_level() &lt; NMT_summary) return;
240       VirtualMemoryTracker::set_reserved_region_type((address)addr, flag);
241     }
242   }
243 
244 #ifdef _AIX
245   // See JDK-8202772 - temporarily disable thread stack tracking on AIX.
246   static inline void record_thread_stack(void* addr, size_t size) {}
247   static inline void release_thread_stack(void* addr, size_t size) {}
248 #else
249   static inline void record_thread_stack(void* addr, size_t size) {
250     if (tracking_level() &lt; NMT_summary) return;
251     if (addr != NULL) {
252       // uses thread stack malloc slot for book keeping number of threads
253       MallocMemorySummary::record_malloc(0, mtThreadStack);
254       record_virtual_memory_reserve(addr, size, CALLER_PC, mtThreadStack);
255     }
256   }
257 
258   static inline void release_thread_stack(void* addr, size_t size) {
259     if (tracking_level() &lt; NMT_summary) return;
260     if (addr != NULL) {
261       // uses thread stack malloc slot for book keeping number of threads
262       MallocMemorySummary::record_free(0, mtThreadStack);
263       ThreadCritical tc;
264       if (tracking_level() &lt; NMT_summary) return;
265       VirtualMemoryTracker::remove_released_region((address)addr, size);
266     }
267   }
268 #endif
269 
270   // Query lock is used to synchronize the access to tracking data.
271   // So far, it is only used by JCmd query, but it may be used by
272   // other tools.
273   static inline Mutex* query_lock() {
274     assert(NMTQuery_lock != NULL, &quot;not initialized!&quot;);
275     return NMTQuery_lock;
276   }
277 
278   // Make a final report or report for hs_err file.
279   static void error_report(outputStream* output) {
280     if (tracking_level() &gt;= NMT_summary) {
281       report(true, output);  // just print summary for error case.
282     }
283    }
284 
285   static void final_report(outputStream* output) {
286     NMT_TrackingLevel level = tracking_level();
287     if (level &gt;= NMT_summary) {
288       report(level == NMT_summary, output);
289     }
290   }
291 
292 
293   // Stored baseline
294   static inline MemBaseline&amp; get_baseline() {
295     return _baseline;
296   }
297 
298   static NMT_TrackingLevel cmdline_tracking_level() {
299     return _cmdline_tracking_level;
300   }
301 
302   static void tuning_statistics(outputStream* out);
303 
304  private:
305   static NMT_TrackingLevel init_tracking_level();
306   static void report(bool summary_only, outputStream* output);
307 
308  private:
309   // Tracking level
310   static volatile NMT_TrackingLevel   _tracking_level;
311   // If NMT option value passed by launcher through environment
312   // variable is valid
313   static bool                         _is_nmt_env_valid;
314   // command line tracking level
315   static NMT_TrackingLevel            _cmdline_tracking_level;
316   // Stored baseline
317   static MemBaseline      _baseline;
318   // Query lock
319   static Mutex*           _query_lock;
320 };
321 
322 #endif // INCLUDE_NMT
323 
324 #endif // SHARE_SERVICES_MEMTRACKER_HPP
    </pre>
  </body>
</html>
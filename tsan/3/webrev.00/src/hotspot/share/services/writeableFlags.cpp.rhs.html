<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/writeableFlags.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/arguments.hpp&quot;
 29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/jniHandles.hpp&quot;
 33 #include &quot;services/writeableFlags.hpp&quot;
 34 
 35 #define TEMP_BUF_SIZE 80
 36 
 37 static void buffer_concat(char* buffer, const char* src) {
 38   strncat(buffer, src, TEMP_BUF_SIZE - 1 - strlen(buffer));
 39 }
 40 
<a name="1" id="anc1"></a><span class="line-modified"> 41 static void print_flag_error_message_bounds(const JVMFlag* flag, char* buffer) {</span>
<span class="line-modified"> 42   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
 43   if (range != NULL) {
 44     buffer_concat(buffer, &quot;must have value in range &quot;);
 45 
 46     stringStream stream;
 47     range-&gt;print(&amp;stream);
 48     const char* range_string = stream.as_string();
 49     size_t j = strlen(buffer);
 50     for (size_t i=0; j&lt;TEMP_BUF_SIZE-1; i++) {
 51       if (range_string[i] == &#39;\0&#39;) {
 52         break;
 53       } else if (range_string[i] != &#39; &#39;) {
 54         buffer[j] = range_string[i];
 55         j++;
 56       }
 57     }
 58     buffer[j] = &#39;\0&#39;;
 59   }
 60 }
 61 
<a name="2" id="anc2"></a><span class="line-modified"> 62 static void print_flag_error_message_if_needed(JVMFlag::Error error, const JVMFlag* flag, FormatBuffer&lt;80&gt;&amp; err_msg) {</span>
 63   if (error == JVMFlag::SUCCESS) {
 64     return;
 65   }
 66 
<a name="3" id="anc3"></a><span class="line-added"> 67   const char* name = flag-&gt;_name;</span>
 68   char buffer[TEMP_BUF_SIZE] = {&#39;\0&#39;};
 69   if ((error != JVMFlag::MISSING_NAME) &amp;&amp; (name != NULL)) {
 70     buffer_concat(buffer, name);
 71     buffer_concat(buffer, &quot; error: &quot;);
 72   } else {
 73     buffer_concat(buffer, &quot;Error: &quot;);
 74   }
 75   switch (error) {
 76     case JVMFlag::MISSING_NAME:
 77       buffer_concat(buffer, &quot;flag name is missing.&quot;); break;
 78     case JVMFlag::MISSING_VALUE:
 79       buffer_concat(buffer, &quot;parsing the textual form of the value.&quot;); break;
 80     case JVMFlag::NON_WRITABLE:
 81       buffer_concat(buffer, &quot;flag is not writeable.&quot;); break;
 82     case JVMFlag::OUT_OF_BOUNDS:
<a name="4" id="anc4"></a><span class="line-modified"> 83       if (name != NULL) { print_flag_error_message_bounds(flag, buffer); } break;</span>
 84     case JVMFlag::VIOLATES_CONSTRAINT:
 85       buffer_concat(buffer, &quot;value violates its flag&#39;s constraint.&quot;); break;
 86     case JVMFlag::INVALID_FLAG:
 87       buffer_concat(buffer, &quot;there is no flag with the given name.&quot;); break;
 88     case JVMFlag::ERR_OTHER:
 89       buffer_concat(buffer, &quot;other, unspecified error related to setting the flag.&quot;); break;
 90     case JVMFlag::SUCCESS:
 91       break;
 92     default:
 93       break;
 94   }
 95 
 96   err_msg.print(&quot;%s&quot;, buffer);
 97 }
 98 
 99 // set a boolean global flag
100 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
101   if ((strcasecmp(arg, &quot;true&quot;) == 0) || (*arg == &#39;1&#39; &amp;&amp; *(arg + 1) == 0)) {
102     return set_bool_flag(name, true, origin, err_msg);
103   } else if ((strcasecmp(arg, &quot;false&quot;) == 0) || (*arg == &#39;0&#39; &amp;&amp; *(arg + 1) == 0)) {
104     return set_bool_flag(name, false, origin, err_msg);
105   }
106   err_msg.print(&quot;flag value must be a boolean (1/0 or true/false)&quot;);
107   return JVMFlag::WRONG_FORMAT;
108 }
109 
110 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, bool value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="5" id="anc5"></a><span class="line-modified">111   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">112   JVMFlag::Error err = JVMFlag::boolAtPut(flag, &amp;value, origin);</span>
<span class="line-added">113   print_flag_error_message_if_needed(err, flag, err_msg);</span>
114   return err;
115 }
116 
117 // set a int global flag
118 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
119   int value;
120 
121   if (sscanf(arg, &quot;%d&quot;, &amp;value) == 1) {
122     return set_int_flag(name, value, origin, err_msg);
123   }
124   err_msg.print(&quot;flag value must be an integer&quot;);
125   return JVMFlag::WRONG_FORMAT;
126 }
127 
128 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, int value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="6" id="anc6"></a><span class="line-modified">129   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">130   JVMFlag::Error err = JVMFlag::intAtPut(flag, &amp;value, origin);</span>
<span class="line-added">131   print_flag_error_message_if_needed(err, flag, err_msg);</span>
132   return err;
133 }
134 
135 // set a uint global flag
136 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
137   uint value;
138 
139   if (sscanf(arg, &quot;%u&quot;, &amp;value) == 1) {
140     return set_uint_flag(name, value, origin, err_msg);
141   }
142   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
143   return JVMFlag::WRONG_FORMAT;
144 }
145 
146 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, uint value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="7" id="anc7"></a><span class="line-modified">147   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">148   JVMFlag::Error err = JVMFlag::uintAtPut(flag, &amp;value, origin);</span>
<span class="line-added">149   print_flag_error_message_if_needed(err, flag, err_msg);</span>
150   return err;
151 }
152 
153 // set a intx global flag
154 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
155   intx value;
156 
157   if (sscanf(arg, INTX_FORMAT, &amp;value) == 1) {
158     return set_intx_flag(name, value, origin, err_msg);
159   }
160   err_msg.print(&quot;flag value must be an integer&quot;);
161   return JVMFlag::WRONG_FORMAT;
162 }
163 
164 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, intx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="8" id="anc8"></a><span class="line-modified">165   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">166   JVMFlag::Error err = JVMFlag::intxAtPut(flag, &amp;value, origin);</span>
<span class="line-added">167   print_flag_error_message_if_needed(err, flag, err_msg);</span>
168   return err;
169 }
170 
171 // set a uintx global flag
172 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
173   uintx value;
174 
175   if (sscanf(arg, UINTX_FORMAT, &amp;value) == 1) {
176     return set_uintx_flag(name, value, origin, err_msg);
177   }
178   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
179   return JVMFlag::WRONG_FORMAT;
180 }
181 
182 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, uintx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="9" id="anc9"></a><span class="line-modified">183   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">184   JVMFlag::Error err = JVMFlag::uintxAtPut(flag, &amp;value, origin);</span>
<span class="line-added">185   print_flag_error_message_if_needed(err, flag, err_msg);</span>
186   return err;
187 }
188 
189 // set a uint64_t global flag
190 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
191   uint64_t value;
192 
193   if (sscanf(arg, UINT64_FORMAT, &amp;value) == 1) {
194     return set_uint64_t_flag(name, value, origin, err_msg);
195   }
196   err_msg.print(&quot;flag value must be an unsigned 64-bit integer&quot;);
197   return JVMFlag::WRONG_FORMAT;
198 }
199 
200 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, uint64_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="10" id="anc10"></a><span class="line-modified">201   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">202   JVMFlag::Error err = JVMFlag::uint64_tAtPut(flag, &amp;value, origin);</span>
<span class="line-added">203   print_flag_error_message_if_needed(err, flag, err_msg);</span>
204   return err;
205 }
206 
207 // set a size_t global flag
208 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
209   size_t value;
210 
211   if (sscanf(arg, SIZE_FORMAT, &amp;value) == 1) {
212     return set_size_t_flag(name, value, origin, err_msg);
213   }
214   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
215   return JVMFlag::WRONG_FORMAT;
216 }
217 
218 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, size_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="11" id="anc11"></a><span class="line-modified">219   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">220   JVMFlag::Error err = JVMFlag::size_tAtPut(flag, &amp;value, origin);</span>
<span class="line-added">221   print_flag_error_message_if_needed(err, flag, err_msg);</span>
222   return err;
223 }
224 
225 // set a double global flag
226 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
227   double value;
228 
229   if (sscanf(arg, &quot;%lf&quot;, &amp;value) == 1) {
230     return set_double_flag(name, value, origin, err_msg);
231   }
232   err_msg.print(&quot;flag value must be a double&quot;);
233   return JVMFlag::WRONG_FORMAT;
234 }
235 
236 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, double value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="12" id="anc12"></a><span class="line-modified">237   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">238   JVMFlag::Error err = JVMFlag::doubleAtPut(flag, &amp;value, origin);</span>
<span class="line-added">239   print_flag_error_message_if_needed(err, flag, err_msg);</span>
240   return err;
241 }
242 
243 // set a string global flag using value from AttachOperation
244 JVMFlag::Error WriteableFlags::set_ccstr_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<a name="13" id="anc13"></a><span class="line-modified">245   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">246   JVMFlag::Error err = JVMFlag::ccstrAtPut(flag, &amp;value, origin);</span>
<span class="line-added">247   print_flag_error_message_if_needed(err, flag, err_msg);</span>
248   return err;
249 }
250 
251 /* sets a writeable flag to the provided value
252  *
253  * - return status is one of the WriteableFlags::err enum values
254  * - an eventual error message will be generated to the provided err_msg buffer
255  */
256 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, const char* flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
257   return set_flag(flag_name, &amp;flag_value, set_flag_from_char, origin, err_msg);
258 }
259 
260 /* sets a writeable flag to the provided value
261  *
262  * - return status is one of the WriteableFlags::err enum values
263  * - an eventual error message will be generated to the provided err_msg buffer
264  */
265 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, jvalue flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
266   return set_flag(flag_name, &amp;flag_value, set_flag_from_jvalue, origin, err_msg);
267 }
268 
269 // a writeable flag setter accepting either &#39;jvalue&#39; or &#39;char *&#39; values
270 JVMFlag::Error WriteableFlags::set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*,const void*,JVMFlag::Flags,FormatBuffer&lt;80&gt;&amp;), JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
271   if (name == NULL) {
272     err_msg.print(&quot;flag name is missing&quot;);
273     return JVMFlag::MISSING_NAME;
274   }
275   if (value == NULL) {
276     err_msg.print(&quot;flag value is missing&quot;);
277     return JVMFlag::MISSING_VALUE;
278   }
279 
<a name="14" id="anc14"></a><span class="line-modified">280   JVMFlag* f = JVMFlag::find_flag(name);</span>
281   if (f) {
282     // only writeable flags are allowed to be set
283     if (f-&gt;is_writeable()) {
284       return setter(f, value, origin, err_msg);
285     } else {
286       err_msg.print(&quot;only &#39;writeable&#39; flags can be set&quot;);
287       return JVMFlag::NON_WRITABLE;
288     }
289   }
290 
291   err_msg.print(&quot;flag %s does not exist&quot;, name);
292   return JVMFlag::INVALID_FLAG;
293 }
294 
295 // a writeable flag setter accepting &#39;char *&#39; values
296 JVMFlag::Error WriteableFlags::set_flag_from_char(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
297   char* flag_value = *(char**)value;
298   if (flag_value == NULL) {
299     err_msg.print(&quot;flag value is missing&quot;);
300     return JVMFlag::MISSING_VALUE;
301   }
302   if (f-&gt;is_bool()) {
303     return set_bool_flag(f-&gt;_name, flag_value, origin, err_msg);
304   } else if (f-&gt;is_int()) {
305     return set_int_flag(f-&gt;_name, flag_value, origin, err_msg);
306   } else if (f-&gt;is_uint()) {
307     return set_uint_flag(f-&gt;_name, flag_value, origin, err_msg);
308   } else if (f-&gt;is_intx()) {
309     return set_intx_flag(f-&gt;_name, flag_value, origin, err_msg);
310   } else if (f-&gt;is_uintx()) {
311     return set_uintx_flag(f-&gt;_name, flag_value, origin, err_msg);
312   } else if (f-&gt;is_uint64_t()) {
313     return set_uint64_t_flag(f-&gt;_name, flag_value, origin, err_msg);
314   } else if (f-&gt;is_size_t()) {
315     return set_size_t_flag(f-&gt;_name, flag_value, origin, err_msg);
316   } else if (f-&gt;is_double()) {
317     return set_double_flag(f-&gt;_name, flag_value, origin, err_msg);
318   } else if (f-&gt;is_ccstr()) {
319     return set_ccstr_flag(f-&gt;_name, flag_value, origin, err_msg);
320   } else {
321     ShouldNotReachHere();
322   }
323   return JVMFlag::ERR_OTHER;
324 }
325 
326 // a writeable flag setter accepting &#39;jvalue&#39; values
327 JVMFlag::Error WriteableFlags::set_flag_from_jvalue(JVMFlag* f, const void* value, JVMFlag::Flags origin,
328                                                  FormatBuffer&lt;80&gt;&amp; err_msg) {
329   jvalue new_value = *(jvalue*)value;
330   if (f-&gt;is_bool()) {
331     bool bvalue = (new_value.z == JNI_TRUE ? true : false);
332     return set_bool_flag(f-&gt;_name, bvalue, origin, err_msg);
333   } else if (f-&gt;is_int()) {
334     int ivalue = (int)new_value.j;
335     return set_int_flag(f-&gt;_name, ivalue, origin, err_msg);
336   } else if (f-&gt;is_uint()) {
337     uint uvalue = (uint)new_value.j;
338     return set_uint_flag(f-&gt;_name, uvalue, origin, err_msg);
339   } else if (f-&gt;is_intx()) {
340     intx ivalue = (intx)new_value.j;
341     return set_intx_flag(f-&gt;_name, ivalue, origin, err_msg);
342   } else if (f-&gt;is_uintx()) {
343     uintx uvalue = (uintx)new_value.j;
344     return set_uintx_flag(f-&gt;_name, uvalue, origin, err_msg);
345   } else if (f-&gt;is_uint64_t()) {
346     uint64_t uvalue = (uint64_t)new_value.j;
347     return set_uint64_t_flag(f-&gt;_name, uvalue, origin, err_msg);
348   } else if (f-&gt;is_size_t()) {
349     size_t svalue = (size_t)new_value.j;
350     return set_size_t_flag(f-&gt;_name, svalue, origin, err_msg);
351   } else if (f-&gt;is_double()) {
352     double dvalue = (double)new_value.d;
353     return set_double_flag(f-&gt;_name, dvalue, origin, err_msg);
354   } else if (f-&gt;is_ccstr()) {
355     oop str = JNIHandles::resolve_external_guard(new_value.l);
356     if (str == NULL) {
357       err_msg.print(&quot;flag value is missing&quot;);
358       return JVMFlag::MISSING_VALUE;
359     }
360     ccstr svalue = java_lang_String::as_utf8_string(str);
361     JVMFlag::Error ret = WriteableFlags::set_ccstr_flag(f-&gt;_name, svalue, origin, err_msg);
362     if (ret != JVMFlag::SUCCESS) {
363       FREE_C_HEAP_ARRAY(char, svalue);
364     }
365     return ret;
366   } else {
367     ShouldNotReachHere();
368   }
369   return JVMFlag::ERR_OTHER;
370 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/diagnosticArgument.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;runtime/thread.hpp&quot;
 30 #include &quot;services/diagnosticArgument.hpp&quot;
 31 
 32 StringArrayArgument::StringArrayArgument() {
 33   _array = new(ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;char *&gt;(32, true);
 34   assert(_array != NULL, &quot;Sanity check&quot;);
 35 }
 36 
 37 StringArrayArgument::~StringArrayArgument() {
 38   for (int i=0; i&lt;_array-&gt;length(); i++) {
<a name="1" id="anc1"></a><span class="line-modified"> 39     if(_array-&gt;at(i) != NULL) { // Safety check</span>
<span class="line-removed"> 40       FREE_C_HEAP_ARRAY(char, _array-&gt;at(i));</span>
<span class="line-removed"> 41     }</span>
 42   }
 43   delete _array;
 44 }
 45 
 46 void StringArrayArgument::add(const char* str, size_t len) {
 47   if (str != NULL) {
 48     char* ptr = NEW_C_HEAP_ARRAY(char, len+1, mtInternal);
 49     strncpy(ptr, str, len);
 50     ptr[len] = 0;
 51     _array-&gt;append(ptr);
 52   }
 53 }
 54 
 55 void GenDCmdArgument::read_value(const char* str, size_t len, TRAPS) {
 56   /* NOTE:Some argument types doesn&#39;t require a value,
 57    * for instance boolean arguments: &quot;enableFeatureX&quot;. is
 58    * equivalent to &quot;enableFeatureX=true&quot;. In these cases,
 59    * str will be null. This is perfectly valid.
 60    * All argument types must perform null checks on str.
 61    */
 62 
 63   if (is_set() &amp;&amp; !allow_multiple()) {
 64     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 65             &quot;Duplicates in diagnostic command arguments\n&quot;);
 66   }
 67   parse_value(str, len, CHECK);
 68   set_is_set(true);
 69 }
 70 
 71 void GenDCmdArgument::to_string(jlong l, char* buf, size_t len) const {
 72   jio_snprintf(buf, len, INT64_FORMAT, l);
 73 }
 74 
 75 void GenDCmdArgument::to_string(bool b, char* buf, size_t len) const {
 76   jio_snprintf(buf, len, b ? &quot;true&quot; : &quot;false&quot;);
 77 }
 78 
 79 void GenDCmdArgument::to_string(NanoTimeArgument n, char* buf, size_t len) const {
 80   jio_snprintf(buf, len, INT64_FORMAT, n._nanotime);
 81 }
 82 
 83 void GenDCmdArgument::to_string(MemorySizeArgument m, char* buf, size_t len) const {
 84   jio_snprintf(buf, len, INT64_FORMAT, m._size);
 85 }
 86 
 87 void GenDCmdArgument::to_string(char* c, char* buf, size_t len) const {
 88   jio_snprintf(buf, len, &quot;%s&quot;, (c != NULL) ? c : &quot;&quot;);
 89 }
 90 
 91 void GenDCmdArgument::to_string(StringArrayArgument* f, char* buf, size_t len) const {
 92   int length = f-&gt;array()-&gt;length();
 93   size_t written = 0;
 94   buf[0] = 0;
 95   for (int i = 0; i &lt; length; i++) {
 96     char* next_str = f-&gt;array()-&gt;at(i);
 97     size_t next_size = strlen(next_str);
 98     //Check if there&#39;s room left to write next element
 99     if (written + next_size &gt; len) {
100       return;
101     }
102     //Actually write element
103     strcat(buf, next_str);
104     written += next_size;
105     //Check if there&#39;s room left for the comma
106     if (i &lt; length-1 &amp;&amp; len - written &gt; 0) {
107       strcat(buf, &quot;,&quot;);
108     }
109   }
110 }
111 
112 template &lt;&gt; void DCmdArgument&lt;jlong&gt;::parse_value(const char* str,
113                                                   size_t len, TRAPS) {
114   int scanned = -1;
115   if (str == NULL
116       || sscanf(str, JLONG_FORMAT &quot;%n&quot;, &amp;_value, &amp;scanned) != 1
117       || (size_t)scanned != len)
118   {
119     ResourceMark rm;
120 
121     char* buf = NEW_RESOURCE_ARRAY(char, len + 1);
122     strncpy(buf, str, len);
123     buf[len] = &#39;\0&#39;;
124     Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
125       &quot;Integer parsing error in command argument &#39;%s&#39;. Could not parse: %s.\n&quot;, _name, buf);
126   }
127 }
128 
129 template &lt;&gt; void DCmdArgument&lt;jlong&gt;::init_value(TRAPS) {
130   if (has_default()) {
131     this-&gt;parse_value(_default_string, strlen(_default_string), THREAD);
132     if (HAS_PENDING_EXCEPTION) {
133       fatal(&quot;Default string must be parseable&quot;);
134     }
135   } else {
136     set_value(0);
137   }
138 }
139 
140 template &lt;&gt; void DCmdArgument&lt;jlong&gt;::destroy_value() { }
141 
142 template &lt;&gt; void DCmdArgument&lt;bool&gt;::parse_value(const char* str,
143                                                  size_t len, TRAPS) {
144   // len is the length of the current token starting at str
145   if (len == 0) {
146     set_value(true);
147   } else {
148     if (len == strlen(&quot;true&quot;) &amp;&amp; strncasecmp(str, &quot;true&quot;, len) == 0) {
149        set_value(true);
150     } else if (len == strlen(&quot;false&quot;) &amp;&amp; strncasecmp(str, &quot;false&quot;, len) == 0) {
151        set_value(false);
152     } else {
153       ResourceMark rm;
154 
155       char* buf = NEW_RESOURCE_ARRAY(char, len + 1);
<a name="2" id="anc2"></a>



156       strncpy(buf, str, len);
<a name="3" id="anc3"></a>

157       buf[len] = &#39;\0&#39;;
158       Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
159         &quot;Boolean parsing error in command argument &#39;%s&#39;. Could not parse: %s.\n&quot;, _name, buf);
160     }
161   }
162 }
163 
164 template &lt;&gt; void DCmdArgument&lt;bool&gt;::init_value(TRAPS) {
165   if (has_default()) {
166     this-&gt;parse_value(_default_string, strlen(_default_string), THREAD);
167     if (HAS_PENDING_EXCEPTION) {
168       fatal(&quot;Default string must be parsable&quot;);
169     }
170   } else {
171     set_value(false);
172   }
173 }
174 
175 template &lt;&gt; void DCmdArgument&lt;bool&gt;::destroy_value() { }
176 
177 template &lt;&gt; void DCmdArgument&lt;char*&gt;::parse_value(const char* str,
178                                                   size_t len, TRAPS) {
179   if (str == NULL) {
180     _value = NULL;
181   } else {
182     _value = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
183     int n = os::snprintf(_value, len + 1, &quot;%.*s&quot;, (int)len, str);
184     assert((size_t)n &lt;= len, &quot;Unexpected number of characters in string&quot;);
185   }
186 }
187 
188 template &lt;&gt; void DCmdArgument&lt;char*&gt;::init_value(TRAPS) {
189   if (has_default() &amp;&amp; _default_string != NULL) {
190     this-&gt;parse_value(_default_string, strlen(_default_string), THREAD);
191     if (HAS_PENDING_EXCEPTION) {
192      fatal(&quot;Default string must be parsable&quot;);
193     }
194   } else {
195     set_value(NULL);
196   }
197 }
198 
199 template &lt;&gt; void DCmdArgument&lt;char*&gt;::destroy_value() {
<a name="4" id="anc4"></a><span class="line-modified">200   if (_value != NULL) {</span>
<span class="line-modified">201     FREE_C_HEAP_ARRAY(char, _value);</span>
<span class="line-removed">202     set_value(NULL);</span>
<span class="line-removed">203   }</span>
204 }
205 
206 template &lt;&gt; void DCmdArgument&lt;NanoTimeArgument&gt;::parse_value(const char* str,
207                                                  size_t len, TRAPS) {
208   if (str == NULL) {
209     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
210               &quot;Integer parsing error nanotime value: syntax error, value is null\n&quot;);
211   }
212 
213   int argc = sscanf(str, JLONG_FORMAT, &amp;_value._time);
214   if (argc != 1) {
215     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
216               &quot;Integer parsing error nanotime value: syntax error\n&quot;);
217   }
218   size_t idx = 0;
219   while(idx &lt; len &amp;&amp; isdigit(str[idx])) {
220     idx++;
221   }
222   if (idx == len) {
223     // only accept missing unit if the value is 0
224     if (_value._time != 0) {
225       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
226                 &quot;Integer parsing error nanotime value: unit required\n&quot;);
227     } else {
228       _value._nanotime = 0;
229       strcpy(_value._unit, &quot;ns&quot;);
230       return;
231     }
232   } else if(len - idx &gt; 2) {
233     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
234               &quot;Integer parsing error nanotime value: illegal unit\n&quot;);
235   } else {
236     strncpy(_value._unit, &amp;str[idx], len - idx);
237     /*Write an extra null termination. This is safe because _value._unit
238      * is declared as char[3], and length is checked to be not larger than
239      * two above. Also, this is necessary, since length might be 1, and the
240      * default value already in the string is ns, which is two chars.
241      */
242     _value._unit[len-idx] = &#39;\0&#39;;
243   }
244 
245   if (strcmp(_value._unit, &quot;ns&quot;) == 0) {
246     _value._nanotime = _value._time;
247   } else if (strcmp(_value._unit, &quot;us&quot;) == 0) {
248     _value._nanotime = _value._time * 1000;
249   } else if (strcmp(_value._unit, &quot;ms&quot;) == 0) {
250     _value._nanotime = _value._time * 1000 * 1000;
251   } else if (strcmp(_value._unit, &quot;s&quot;) == 0) {
252     _value._nanotime = _value._time * 1000 * 1000 * 1000;
253   } else if (strcmp(_value._unit, &quot;m&quot;) == 0) {
254     _value._nanotime = _value._time * 60 * 1000 * 1000 * 1000;
255   } else if (strcmp(_value._unit, &quot;h&quot;) == 0) {
256     _value._nanotime = _value._time * 60 * 60 * 1000 * 1000 * 1000;
257   } else if (strcmp(_value._unit, &quot;d&quot;) == 0) {
258     _value._nanotime = _value._time * 24 * 60 * 60 * 1000 * 1000 * 1000;
259   } else {
260      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
261                &quot;Integer parsing error nanotime value: illegal unit\n&quot;);
262   }
263 }
264 
265 template &lt;&gt; void DCmdArgument&lt;NanoTimeArgument&gt;::init_value(TRAPS) {
266   if (has_default()) {
267     this-&gt;parse_value(_default_string, strlen(_default_string), THREAD);
268     if (HAS_PENDING_EXCEPTION) {
269       fatal(&quot;Default string must be parsable&quot;);
270     }
271   } else {
272     _value._time = 0;
273     _value._nanotime = 0;
274     strcpy(_value._unit, &quot;ns&quot;);
275   }
276 }
277 
278 template &lt;&gt; void DCmdArgument&lt;NanoTimeArgument&gt;::destroy_value() { }
279 
280 // WARNING StringArrayArgument can only be used as an option, it cannot be
281 // used as an argument with the DCmdParser
282 
283 template &lt;&gt; void DCmdArgument&lt;StringArrayArgument*&gt;::parse_value(const char* str,
284                                                   size_t len, TRAPS) {
285   _value-&gt;add(str,len);
286 }
287 
288 template &lt;&gt; void DCmdArgument&lt;StringArrayArgument*&gt;::init_value(TRAPS) {
289   _value = new StringArrayArgument();
290   _allow_multiple = true;
291   if (has_default()) {
292     fatal(&quot;StringArrayArgument cannot have default value&quot;);
293   }
294 }
295 
296 template &lt;&gt; void DCmdArgument&lt;StringArrayArgument*&gt;::destroy_value() {
297   if (_value != NULL) {
298     delete _value;
299     set_value(NULL);
300   }
301 }
302 
303 template &lt;&gt; void DCmdArgument&lt;MemorySizeArgument&gt;::parse_value(const char* str,
304                                                   size_t len, TRAPS) {
305   if (str == NULL) {
306     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
307                &quot;Parsing error memory size value: syntax error, value is null\n&quot;);
308   }
309   if (*str == &#39;-&#39;) {
310     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
311                &quot;Parsing error memory size value: negative values not allowed\n&quot;);
312   }
313   int res = sscanf(str, UINT64_FORMAT &quot;%c&quot;, &amp;_value._val, &amp;_value._multiplier);
314   if (res == 2) {
315      switch (_value._multiplier) {
316       case &#39;k&#39;: case &#39;K&#39;:
317          _value._size = _value._val * 1024;
318          break;
319       case &#39;m&#39;: case &#39;M&#39;:
320          _value._size = _value._val * 1024 * 1024;
321          break;
322       case &#39;g&#39;: case &#39;G&#39;:
323          _value._size = _value._val * 1024 * 1024 * 1024;
324          break;
325        default:
326          _value._size = _value._val;
327          _value._multiplier = &#39; &#39;;
328          //default case should be to break with no error, since user
329          //can write size in bytes, or might have a delimiter and next arg
330          break;
331      }
332    } else if (res == 1) {
333      _value._size = _value._val;
334    } else {
335      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
336                &quot;Parsing error memory size value: invalid value\n&quot;);
337    }
338 }
339 
340 template &lt;&gt; void DCmdArgument&lt;MemorySizeArgument&gt;::init_value(TRAPS) {
341   if (has_default()) {
342     this-&gt;parse_value(_default_string, strlen(_default_string), THREAD);
343     if (HAS_PENDING_EXCEPTION) {
344       fatal(&quot;Default string must be parsable&quot;);
345     }
346   } else {
347     _value._size = 0;
348     _value._val = 0;
349     _value._multiplier = &#39; &#39;;
350   }
351 }
352 
353 template &lt;&gt; void DCmdArgument&lt;MemorySizeArgument&gt;::destroy_value() { }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
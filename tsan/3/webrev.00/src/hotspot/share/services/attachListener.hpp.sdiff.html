<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/attachListener.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="attachListener.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoadingService.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/attachListener.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_ATTACHLISTENER_HPP
 26 #define SHARE_SERVICES_ATTACHLISTENER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;


 29 #include &quot;utilities/debug.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 
 34 // The AttachListener thread services a queue of operations that are enqueued
 35 // by client tools. Each operation is identified by a name and has up to 3
 36 // arguments. The operation name is mapped to a function which performs the
 37 // operation. The function is called with an outputStream which is can use to
 38 // write any result data (for examples the properties command serializes
 39 // properties names and values to the output stream). When the function
 40 // complets the result value and any result data is returned to the client
 41 // tool.
 42 
 43 class AttachOperation;
 44 
 45 typedef jint (*AttachOperationFunction)(AttachOperation* op, outputStream* out);
 46 
 47 struct AttachOperationFunctionInfo {
 48   const char* name;
 49   AttachOperationFunction func;
 50 };
 51 








 52 class AttachListener: AllStatic {
 53  public:
 54   static void vm_start() NOT_SERVICES_RETURN;
 55   static void init()  NOT_SERVICES_RETURN;
 56   static void abort() NOT_SERVICES_RETURN;
 57 
 58   // invoke to perform clean-up tasks when all clients detach
 59   static void detachall() NOT_SERVICES_RETURN;
 60 



 61   // indicates if the Attach Listener needs to be created at startup
 62   static bool init_at_startup() NOT_SERVICES_RETURN_(false);
 63 
 64   // indicates if we have a trigger to start the Attach Listener
 65   static bool is_init_trigger() NOT_SERVICES_RETURN_(false);
 66 
 67 #if !INCLUDE_SERVICES
 68   static bool is_attach_supported()             { return false; }
 69 #else

 70  private:
<span class="line-modified"> 71   static volatile bool _initialized;</span>
 72 
 73  public:
<span class="line-modified"> 74   static bool is_initialized()                  { return _initialized; }</span>
<span class="line-modified"> 75   static void set_initialized()                 { _initialized = true; }</span>


















 76 
 77   // indicates if this VM supports attach-on-demand
 78   static bool is_attach_supported()             { return !DisableAttachMechanism; }
 79 
 80   // platform specific initialization
 81   static int pd_init();
 82 
 83   // platform specific operation
 84   static AttachOperationFunctionInfo* pd_find_operation(const char* name);
 85 
 86   // platform specific flag change
 87   static jint pd_set_flag(AttachOperation* op, outputStream* out);
 88 
 89   // platform specific detachall
 90   static void pd_detachall();
 91 
 92   // platform specific data dump
 93   static void pd_data_dump();
 94 
 95   // dequeue the next operation
</pre>
<hr />
<pre>
104 class AttachOperation: public CHeapObj&lt;mtInternal&gt; {
105  public:
106   enum {
107     name_length_max = 16,       // maximum length of  name
108     arg_length_max = 1024,      // maximum length of argument
109     arg_count_max = 3           // maximum number of arguments
110   };
111 
112   // name of special operation that can be enqueued when all
113   // clients detach
114   static char* detachall_operation_name() { return (char*)&quot;detachall&quot;; }
115 
116  private:
117   char _name[name_length_max+1];
118   char _arg[arg_count_max][arg_length_max+1];
119 
120  public:
121   const char* name() const                      { return _name; }
122 
123   // set the operation name
<span class="line-modified">124   void set_name(char* name) {</span>
125     assert(strlen(name) &lt;= name_length_max, &quot;exceeds maximum name length&quot;);
126     size_t len = MIN2(strlen(name), (size_t)name_length_max);
127     memcpy(_name, name, len);
128     _name[len] = &#39;\0&#39;;
129   }
130 
131   // get an argument value
132   const char* arg(int i) const {
133     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
134     return _arg[i];
135   }
136 
137   // set an argument value
138   void set_arg(int i, char* arg) {
139     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
140     if (arg == NULL) {
141       _arg[i][0] = &#39;\0&#39;;
142     } else {
143       assert(strlen(arg) &lt;= arg_length_max, &quot;exceeds maximum argument length&quot;);
144       size_t len = MIN2(strlen(arg), (size_t)arg_length_max);
145       memcpy(_arg[i], arg, len);
146       _arg[i][len] = &#39;\0&#39;;
147     }
148   }
149 
150   // create an operation of a given name
<span class="line-modified">151   AttachOperation(char* name) {</span>
152     set_name(name);
153     for (int i=0; i&lt;arg_count_max; i++) {
154       set_arg(i, NULL);
155     }
156   }
157 
158   // complete operation by sending result code and any result data to the client
159   virtual void complete(jint result, bufferedStream* result_stream) = 0;
160 };
161 #endif // INCLUDE_SERVICES
162 
163 #endif // SHARE_SERVICES_ATTACHLISTENER_HPP
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_ATTACHLISTENER_HPP
 26 #define SHARE_SERVICES_ATTACHLISTENER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 29 #include &quot;metaprogramming/isRegisteredEnum.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;runtime/atomic.hpp&quot;</span>
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 
 36 // The AttachListener thread services a queue of operations that are enqueued
 37 // by client tools. Each operation is identified by a name and has up to 3
 38 // arguments. The operation name is mapped to a function which performs the
 39 // operation. The function is called with an outputStream which is can use to
 40 // write any result data (for examples the properties command serializes
 41 // properties names and values to the output stream). When the function
 42 // complets the result value and any result data is returned to the client
 43 // tool.
 44 
 45 class AttachOperation;
 46 
 47 typedef jint (*AttachOperationFunction)(AttachOperation* op, outputStream* out);
 48 
 49 struct AttachOperationFunctionInfo {
 50   const char* name;
 51   AttachOperationFunction func;
 52 };
 53 
<span class="line-added"> 54 enum AttachListenerState {</span>
<span class="line-added"> 55   AL_NOT_INITIALIZED,</span>
<span class="line-added"> 56   AL_INITIALIZING,</span>
<span class="line-added"> 57   AL_INITIALIZED</span>
<span class="line-added"> 58 };</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60 template&lt;&gt; struct IsRegisteredEnum&lt;AttachListenerState&gt; : public TrueType {};</span>
<span class="line-added"> 61 </span>
 62 class AttachListener: AllStatic {
 63  public:
 64   static void vm_start() NOT_SERVICES_RETURN;
 65   static void init()  NOT_SERVICES_RETURN;
 66   static void abort() NOT_SERVICES_RETURN;
 67 
 68   // invoke to perform clean-up tasks when all clients detach
 69   static void detachall() NOT_SERVICES_RETURN;
 70 
<span class="line-added"> 71   // check unix domain socket file on filesystem</span>
<span class="line-added"> 72   static bool check_socket_file() NOT_SERVICES_RETURN_(false);</span>
<span class="line-added"> 73 </span>
 74   // indicates if the Attach Listener needs to be created at startup
 75   static bool init_at_startup() NOT_SERVICES_RETURN_(false);
 76 
 77   // indicates if we have a trigger to start the Attach Listener
 78   static bool is_init_trigger() NOT_SERVICES_RETURN_(false);
 79 
 80 #if !INCLUDE_SERVICES
 81   static bool is_attach_supported()             { return false; }
 82 #else
<span class="line-added"> 83 </span>
 84  private:
<span class="line-modified"> 85   static volatile AttachListenerState _state;</span>
 86 
 87  public:
<span class="line-modified"> 88   static void set_state(AttachListenerState new_state) {</span>
<span class="line-modified"> 89     Atomic::store(&amp;_state, new_state);</span>
<span class="line-added"> 90   }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92   static AttachListenerState get_state() {</span>
<span class="line-added"> 93     return Atomic::load(&amp;_state);</span>
<span class="line-added"> 94   }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96   static AttachListenerState transit_state(AttachListenerState new_state,</span>
<span class="line-added"> 97                                            AttachListenerState cmp_state) {</span>
<span class="line-added"> 98     return Atomic::cmpxchg(&amp;_state, cmp_state, new_state);</span>
<span class="line-added"> 99   }</span>
<span class="line-added">100 </span>
<span class="line-added">101   static bool is_initialized() {</span>
<span class="line-added">102     return Atomic::load(&amp;_state) == AL_INITIALIZED;</span>
<span class="line-added">103   }</span>
<span class="line-added">104 </span>
<span class="line-added">105   static void set_initialized() {</span>
<span class="line-added">106     Atomic::store(&amp;_state, AL_INITIALIZED);</span>
<span class="line-added">107   }</span>
108 
109   // indicates if this VM supports attach-on-demand
110   static bool is_attach_supported()             { return !DisableAttachMechanism; }
111 
112   // platform specific initialization
113   static int pd_init();
114 
115   // platform specific operation
116   static AttachOperationFunctionInfo* pd_find_operation(const char* name);
117 
118   // platform specific flag change
119   static jint pd_set_flag(AttachOperation* op, outputStream* out);
120 
121   // platform specific detachall
122   static void pd_detachall();
123 
124   // platform specific data dump
125   static void pd_data_dump();
126 
127   // dequeue the next operation
</pre>
<hr />
<pre>
136 class AttachOperation: public CHeapObj&lt;mtInternal&gt; {
137  public:
138   enum {
139     name_length_max = 16,       // maximum length of  name
140     arg_length_max = 1024,      // maximum length of argument
141     arg_count_max = 3           // maximum number of arguments
142   };
143 
144   // name of special operation that can be enqueued when all
145   // clients detach
146   static char* detachall_operation_name() { return (char*)&quot;detachall&quot;; }
147 
148  private:
149   char _name[name_length_max+1];
150   char _arg[arg_count_max][arg_length_max+1];
151 
152  public:
153   const char* name() const                      { return _name; }
154 
155   // set the operation name
<span class="line-modified">156   void set_name(const char* name) {</span>
157     assert(strlen(name) &lt;= name_length_max, &quot;exceeds maximum name length&quot;);
158     size_t len = MIN2(strlen(name), (size_t)name_length_max);
159     memcpy(_name, name, len);
160     _name[len] = &#39;\0&#39;;
161   }
162 
163   // get an argument value
164   const char* arg(int i) const {
165     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
166     return _arg[i];
167   }
168 
169   // set an argument value
170   void set_arg(int i, char* arg) {
171     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
172     if (arg == NULL) {
173       _arg[i][0] = &#39;\0&#39;;
174     } else {
175       assert(strlen(arg) &lt;= arg_length_max, &quot;exceeds maximum argument length&quot;);
176       size_t len = MIN2(strlen(arg), (size_t)arg_length_max);
177       memcpy(_arg[i], arg, len);
178       _arg[i][len] = &#39;\0&#39;;
179     }
180   }
181 
182   // create an operation of a given name
<span class="line-modified">183   AttachOperation(const char* name) {</span>
184     set_name(name);
185     for (int i=0; i&lt;arg_count_max; i++) {
186       set_arg(i, NULL);
187     }
188   }
189 
190   // complete operation by sending result code and any result data to the client
191   virtual void complete(jint result, bufferedStream* result_stream) = 0;
192 };
193 #endif // INCLUDE_SERVICES
194 
195 #endif // SHARE_SERVICES_ATTACHLISTENER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="attachListener.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoadingService.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/memTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memReporter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memTracker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;jvm.h&quot;
 26 

 27 #include &quot;runtime/orderAccess.hpp&quot;
 28 #include &quot;runtime/vmThread.hpp&quot;
 29 #include &quot;runtime/vmOperations.hpp&quot;
 30 #include &quot;services/memBaseline.hpp&quot;
 31 #include &quot;services/memReporter.hpp&quot;
 32 #include &quot;services/mallocTracker.inline.hpp&quot;
 33 #include &quot;services/memTracker.hpp&quot;

 34 #include &quot;utilities/debug.hpp&quot;
 35 #include &quot;utilities/defaultStream.hpp&quot;
 36 #include &quot;utilities/vmError.hpp&quot;
 37 
 38 #ifdef _WINDOWS
 39 #include &lt;windows.h&gt;
 40 #endif
 41 
 42 #ifdef SOLARIS
 43   volatile bool NMT_stack_walkable = false;
 44 #else
 45   volatile bool NMT_stack_walkable = true;
 46 #endif
 47 
 48 volatile NMT_TrackingLevel MemTracker::_tracking_level = NMT_unknown;
 49 NMT_TrackingLevel MemTracker::_cmdline_tracking_level = NMT_unknown;
 50 
 51 MemBaseline MemTracker::_baseline;
 52 bool MemTracker::_is_nmt_env_valid = true;
 53 
</pre>
<hr />
<pre>
 75     } else if (strcmp(nmt_env_value, &quot;detail&quot;) == 0) {
 76       level = NMT_detail;
 77     } else if (strcmp(nmt_env_value, &quot;off&quot;) != 0) {
 78       // The value of the environment variable is invalid
 79       _is_nmt_env_valid = false;
 80     }
 81     // Remove the environment variable to avoid leaking to child processes
 82     os::unsetenv(nmt_env_variable);
 83   }
 84 
 85   if (!MallocTracker::initialize(level) ||
 86       !VirtualMemoryTracker::initialize(level)) {
 87     level = NMT_off;
 88   }
 89   return level;
 90 }
 91 
 92 void MemTracker::init() {
 93   NMT_TrackingLevel level = tracking_level();
 94   if (level &gt;= NMT_summary) {
<span class="line-modified"> 95     if (!VirtualMemoryTracker::late_initialize(level)) {</span>

 96       shutdown();
 97       return;
 98     }
 99   }
100 }
101 
102 bool MemTracker::check_launcher_nmt_support(const char* value) {
103   if (strcmp(value, &quot;=detail&quot;) == 0) {
104     if (MemTracker::tracking_level() != NMT_detail) {
105       return false;
106     }
107   } else if (strcmp(value, &quot;=summary&quot;) == 0) {
108     if (MemTracker::tracking_level() != NMT_summary) {
109       return false;
110     }
111   } else if (strcmp(value, &quot;=off&quot;) == 0) {
112     if (MemTracker::tracking_level() != NMT_off) {
113       return false;
114     }
115   } else {
</pre>
<hr />
<pre>
128 }
129 
130 void Tracker::record(address addr, size_t size) {
131   if (MemTracker::tracking_level() &lt; NMT_summary) return;
132   switch(_type) {
133     case uncommit:
134       VirtualMemoryTracker::remove_uncommitted_region(addr, size);
135       break;
136     case release:
137       VirtualMemoryTracker::remove_released_region(addr, size);
138         break;
139     default:
140       ShouldNotReachHere();
141   }
142 }
143 
144 
145 // Shutdown can only be issued via JCmd, and NMT JCmd is serialized by lock
146 void MemTracker::shutdown() {
147   // We can only shutdown NMT to minimal tracking level if it is ever on.
<span class="line-modified">148   if (tracking_level () &gt; NMT_minimal) {</span>
149     transition_to(NMT_minimal);
150   }
151 }
152 
153 bool MemTracker::transition_to(NMT_TrackingLevel level) {
154   NMT_TrackingLevel current_level = tracking_level();
155 
156   assert(level != NMT_off || current_level == NMT_off, &quot;Cannot transition NMT to off&quot;);
157 
158   if (current_level == level) {
159     return true;
160   } else if (current_level &gt; level) {
161     // Downgrade tracking level, we want to lower the tracking level first
162     _tracking_level = level;
163     // Make _tracking_level visible immediately.
164     OrderAccess::fence();
165     VirtualMemoryTracker::transition(current_level, level);
166     MallocTracker::transition(current_level, level);

167   } else {
168     // Upgrading tracking level is not supported and has never been supported.
169     // Allocating and deallocating malloc tracking structures is not thread safe and
170     // leads to inconsistencies unless a lot coarser locks are added.
171   }
172   return true;
173 }
174 
















175 void MemTracker::report(bool summary_only, outputStream* output) {
176  assert(output != NULL, &quot;No output stream&quot;);
177   MemBaseline baseline;
178   if (baseline.baseline(summary_only)) {
179     if (summary_only) {
180       MemSummaryReporter rpt(baseline, output);
181       rpt.report();
182     } else {
183       MemDetailReporter rpt(baseline, output);
184       rpt.report();
185       output-&gt;print(&quot;Metaspace:&quot;);
<span class="line-modified">186       // Metadata reporting requires a safepoint, so avoid it if VM is not in good state.</span>
<span class="line-modified">187       assert(!VMError::fatal_error_in_progress(), &quot;Do not report metadata in error report&quot;);</span>
<span class="line-modified">188       VM_PrintMetadata vmop(output, K,</span>
<span class="line-removed">189           MetaspaceUtils::rf_show_loaders |</span>
<span class="line-removed">190           MetaspaceUtils::rf_break_down_by_spacetype);</span>
<span class="line-removed">191       VMThread::execute(&amp;vmop);</span>
192     }
193   }
194 }
195 
196 // This is a walker to gather malloc site hashtable statistics,
197 // the result is used for tuning.
198 class StatisticsWalker : public MallocSiteWalker {
199  private:
200   enum Threshold {
201     // aggregates statistics over this threshold into one
202     // line item.
203     report_threshold = 20
204   };
205 
206  private:
207   // Number of allocation sites that have all memory freed
208   int   _empty_entries;
209   // Total number of allocation sites, include empty sites
210   int   _total_entries;
211   // Number of captured call stack distribution
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;jvm.h&quot;
 26 
<span class="line-added"> 27 #include &quot;runtime/atomic.hpp&quot;</span>
 28 #include &quot;runtime/orderAccess.hpp&quot;
 29 #include &quot;runtime/vmThread.hpp&quot;
 30 #include &quot;runtime/vmOperations.hpp&quot;
 31 #include &quot;services/memBaseline.hpp&quot;
 32 #include &quot;services/memReporter.hpp&quot;
 33 #include &quot;services/mallocTracker.inline.hpp&quot;
 34 #include &quot;services/memTracker.hpp&quot;
<span class="line-added"> 35 #include &quot;services/threadStackTracker.hpp&quot;</span>
 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/defaultStream.hpp&quot;
 38 #include &quot;utilities/vmError.hpp&quot;
 39 
 40 #ifdef _WINDOWS
 41 #include &lt;windows.h&gt;
 42 #endif
 43 
 44 #ifdef SOLARIS
 45   volatile bool NMT_stack_walkable = false;
 46 #else
 47   volatile bool NMT_stack_walkable = true;
 48 #endif
 49 
 50 volatile NMT_TrackingLevel MemTracker::_tracking_level = NMT_unknown;
 51 NMT_TrackingLevel MemTracker::_cmdline_tracking_level = NMT_unknown;
 52 
 53 MemBaseline MemTracker::_baseline;
 54 bool MemTracker::_is_nmt_env_valid = true;
 55 
</pre>
<hr />
<pre>
 77     } else if (strcmp(nmt_env_value, &quot;detail&quot;) == 0) {
 78       level = NMT_detail;
 79     } else if (strcmp(nmt_env_value, &quot;off&quot;) != 0) {
 80       // The value of the environment variable is invalid
 81       _is_nmt_env_valid = false;
 82     }
 83     // Remove the environment variable to avoid leaking to child processes
 84     os::unsetenv(nmt_env_variable);
 85   }
 86 
 87   if (!MallocTracker::initialize(level) ||
 88       !VirtualMemoryTracker::initialize(level)) {
 89     level = NMT_off;
 90   }
 91   return level;
 92 }
 93 
 94 void MemTracker::init() {
 95   NMT_TrackingLevel level = tracking_level();
 96   if (level &gt;= NMT_summary) {
<span class="line-modified"> 97     if (!VirtualMemoryTracker::late_initialize(level) ||</span>
<span class="line-added"> 98         !ThreadStackTracker::late_initialize(level)) {</span>
 99       shutdown();
100       return;
101     }
102   }
103 }
104 
105 bool MemTracker::check_launcher_nmt_support(const char* value) {
106   if (strcmp(value, &quot;=detail&quot;) == 0) {
107     if (MemTracker::tracking_level() != NMT_detail) {
108       return false;
109     }
110   } else if (strcmp(value, &quot;=summary&quot;) == 0) {
111     if (MemTracker::tracking_level() != NMT_summary) {
112       return false;
113     }
114   } else if (strcmp(value, &quot;=off&quot;) == 0) {
115     if (MemTracker::tracking_level() != NMT_off) {
116       return false;
117     }
118   } else {
</pre>
<hr />
<pre>
131 }
132 
133 void Tracker::record(address addr, size_t size) {
134   if (MemTracker::tracking_level() &lt; NMT_summary) return;
135   switch(_type) {
136     case uncommit:
137       VirtualMemoryTracker::remove_uncommitted_region(addr, size);
138       break;
139     case release:
140       VirtualMemoryTracker::remove_released_region(addr, size);
141         break;
142     default:
143       ShouldNotReachHere();
144   }
145 }
146 
147 
148 // Shutdown can only be issued via JCmd, and NMT JCmd is serialized by lock
149 void MemTracker::shutdown() {
150   // We can only shutdown NMT to minimal tracking level if it is ever on.
<span class="line-modified">151   if (tracking_level() &gt; NMT_minimal) {</span>
152     transition_to(NMT_minimal);
153   }
154 }
155 
156 bool MemTracker::transition_to(NMT_TrackingLevel level) {
157   NMT_TrackingLevel current_level = tracking_level();
158 
159   assert(level != NMT_off || current_level == NMT_off, &quot;Cannot transition NMT to off&quot;);
160 
161   if (current_level == level) {
162     return true;
163   } else if (current_level &gt; level) {
164     // Downgrade tracking level, we want to lower the tracking level first
165     _tracking_level = level;
166     // Make _tracking_level visible immediately.
167     OrderAccess::fence();
168     VirtualMemoryTracker::transition(current_level, level);
169     MallocTracker::transition(current_level, level);
<span class="line-added">170     ThreadStackTracker::transition(current_level, level);</span>
171   } else {
172     // Upgrading tracking level is not supported and has never been supported.
173     // Allocating and deallocating malloc tracking structures is not thread safe and
174     // leads to inconsistencies unless a lot coarser locks are added.
175   }
176   return true;
177 }
178 
<span class="line-added">179 </span>
<span class="line-added">180 static volatile bool g_final_report_did_run = false;</span>
<span class="line-added">181 void MemTracker::final_report(outputStream* output) {</span>
<span class="line-added">182   // This function is called during both error reporting and normal VM exit.</span>
<span class="line-added">183   // However, it should only ever run once.  E.g. if the VM crashes after</span>
<span class="line-added">184   // printing the final report during normal VM exit, it should not print</span>
<span class="line-added">185   // the final report again. In addition, it should be guarded from</span>
<span class="line-added">186   // recursive calls in case NMT reporting itself crashes.</span>
<span class="line-added">187   if (Atomic::cmpxchg(&amp;g_final_report_did_run, false, true) == false) {</span>
<span class="line-added">188     NMT_TrackingLevel level = tracking_level();</span>
<span class="line-added">189     if (level &gt;= NMT_summary) {</span>
<span class="line-added">190       report(level == NMT_summary, output);</span>
<span class="line-added">191     }</span>
<span class="line-added">192   }</span>
<span class="line-added">193 }</span>
<span class="line-added">194 </span>
195 void MemTracker::report(bool summary_only, outputStream* output) {
196  assert(output != NULL, &quot;No output stream&quot;);
197   MemBaseline baseline;
198   if (baseline.baseline(summary_only)) {
199     if (summary_only) {
200       MemSummaryReporter rpt(baseline, output);
201       rpt.report();
202     } else {
203       MemDetailReporter rpt(baseline, output);
204       rpt.report();
205       output-&gt;print(&quot;Metaspace:&quot;);
<span class="line-modified">206       // The basic metaspace report avoids any locking and should be safe to</span>
<span class="line-modified">207       // be called at any time.</span>
<span class="line-modified">208       MetaspaceUtils::print_basic_report(output, K);</span>



209     }
210   }
211 }
212 
213 // This is a walker to gather malloc site hashtable statistics,
214 // the result is used for tuning.
215 class StatisticsWalker : public MallocSiteWalker {
216  private:
217   enum Threshold {
218     // aggregates statistics over this threshold into one
219     // line item.
220     report_threshold = 20
221   };
222 
223  private:
224   // Number of allocation sites that have all memory freed
225   int   _empty_entries;
226   // Total number of allocation sites, include empty sites
227   int   _total_entries;
228   // Number of captured call stack distribution
</pre>
</td>
</tr>
</table>
<center><a href="memReporter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memTracker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
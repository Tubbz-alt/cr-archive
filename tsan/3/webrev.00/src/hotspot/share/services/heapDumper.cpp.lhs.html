<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
<a name="2" id="anc2"></a>
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;memory/universe.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/objArrayOop.inline.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/javaCalls.hpp&quot;
  45 #include &quot;runtime/jniHandles.hpp&quot;
  46 #include &quot;runtime/os.inline.hpp&quot;
  47 #include &quot;runtime/reflectionUtils.hpp&quot;
  48 #include &quot;runtime/thread.inline.hpp&quot;
  49 #include &quot;runtime/threadSMR.hpp&quot;
  50 #include &quot;runtime/vframe.hpp&quot;
  51 #include &quot;runtime/vmThread.hpp&quot;
  52 #include &quot;runtime/vmOperations.hpp&quot;
  53 #include &quot;services/heapDumper.hpp&quot;
  54 #include &quot;services/threadService.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 #include &quot;utilities/ostream.hpp&quot;
  57 
  58 /*
  59  * HPROF binary format - description copied from:
  60  *   src/share/demo/jvmti/hprof/hprof_io.c
  61  *
  62  *
  63  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  64  *
  65  *  u4        size of identifiers. Identifiers are used to represent
  66  *            UTF8 strings, objects, stack traces, etc. They usually
  67  *            have the same size as host pointers. For example, on
  68  *            Solaris and Win32, the size is 4.
  69  * u4         high word
  70  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  71  * [record]*  a sequence of records.
  72  *
  73  *
  74  * Record format:
  75  *
  76  * u1         a TAG denoting the type of the record
  77  * u4         number of *microseconds* since the time stamp in the
  78  *            header. (wraps around in a little more than an hour)
  79  * u4         number of bytes *remaining* in the record. Note that
  80  *            this number excludes the tag and the length field itself.
  81  * [u1]*      BODY of the record (a sequence of bytes)
  82  *
  83  *
  84  * The following TAGs are supported:
  85  *
  86  * TAG           BODY       notes
  87  *----------------------------------------------------------
  88  * HPROF_UTF8               a UTF8-encoded name
  89  *
  90  *               id         name ID
  91  *               [u1]*      UTF8 characters (no trailing zero)
  92  *
  93  * HPROF_LOAD_CLASS         a newly loaded class
  94  *
  95  *                u4        class serial number (&gt; 0)
  96  *                id        class object ID
  97  *                u4        stack trace serial number
  98  *                id        class name ID
  99  *
 100  * HPROF_UNLOAD_CLASS       an unloading class
 101  *
 102  *                u4        class serial_number
 103  *
 104  * HPROF_FRAME              a Java stack frame
 105  *
 106  *                id        stack frame ID
 107  *                id        method name ID
 108  *                id        method signature ID
 109  *                id        source file name ID
 110  *                u4        class serial number
 111  *                i4        line number. &gt;0: normal
 112  *                                       -1: unknown
 113  *                                       -2: compiled method
 114  *                                       -3: native method
 115  *
 116  * HPROF_TRACE              a Java stack trace
 117  *
 118  *               u4         stack trace serial number
 119  *               u4         thread serial number
 120  *               u4         number of frames
 121  *               [id]*      stack frame IDs
 122  *
 123  *
 124  * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC
 125  *
 126  *               u2         flags 0x0001: incremental vs. complete
 127  *                                0x0002: sorted by allocation vs. live
 128  *                                0x0004: whether to force a GC
 129  *               u4         cutoff ratio
 130  *               u4         total live bytes
 131  *               u4         total live instances
 132  *               u8         total bytes allocated
 133  *               u8         total instances allocated
 134  *               u4         number of sites that follow
 135  *               [u1        is_array: 0:  normal object
 136  *                                    2:  object array
 137  *                                    4:  boolean array
 138  *                                    5:  char array
 139  *                                    6:  float array
 140  *                                    7:  double array
 141  *                                    8:  byte array
 142  *                                    9:  short array
 143  *                                    10: int array
 144  *                                    11: long array
 145  *                u4        class serial number (may be zero during startup)
 146  *                u4        stack trace serial number
 147  *                u4        number of bytes alive
 148  *                u4        number of instances alive
 149  *                u4        number of bytes allocated
 150  *                u4]*      number of instance allocated
 151  *
 152  * HPROF_START_THREAD       a newly started thread.
 153  *
 154  *               u4         thread serial number (&gt; 0)
 155  *               id         thread object ID
 156  *               u4         stack trace serial number
 157  *               id         thread name ID
 158  *               id         thread group name ID
 159  *               id         thread group parent name ID
 160  *
 161  * HPROF_END_THREAD         a terminating thread.
 162  *
 163  *               u4         thread serial number
 164  *
 165  * HPROF_HEAP_SUMMARY       heap summary
 166  *
 167  *               u4         total live bytes
 168  *               u4         total live instances
 169  *               u8         total bytes allocated
 170  *               u8         total instances allocated
 171  *
 172  * HPROF_HEAP_DUMP          denote a heap dump
 173  *
 174  *               [heap dump sub-records]*
 175  *
 176  *                          There are four kinds of heap dump sub-records:
 177  *
 178  *               u1         sub-record type
 179  *
 180  *               HPROF_GC_ROOT_UNKNOWN         unknown root
 181  *
 182  *                          id         object ID
 183  *
 184  *               HPROF_GC_ROOT_THREAD_OBJ      thread object
 185  *
 186  *                          id         thread object ID  (may be 0 for a
 187  *                                     thread newly attached through JNI)
 188  *                          u4         thread sequence number
 189  *                          u4         stack trace sequence number
 190  *
 191  *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root
 192  *
 193  *                          id         object ID
 194  *                          id         JNI global ref ID
 195  *
 196  *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref
 197  *
 198  *                          id         object ID
 199  *                          u4         thread serial number
 200  *                          u4         frame # in stack trace (-1 for empty)
 201  *
 202  *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame
 203  *
 204  *                          id         object ID
 205  *                          u4         thread serial number
 206  *                          u4         frame # in stack trace (-1 for empty)
 207  *
 208  *               HPROF_GC_ROOT_NATIVE_STACK    Native stack
 209  *
 210  *                          id         object ID
 211  *                          u4         thread serial number
 212  *
 213  *               HPROF_GC_ROOT_STICKY_CLASS    System class
 214  *
 215  *                          id         object ID
 216  *
 217  *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block
 218  *
 219  *                          id         object ID
 220  *                          u4         thread serial number
 221  *
 222  *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor
 223  *
 224  *                          id         object ID
 225  *
 226  *               HPROF_GC_CLASS_DUMP           dump of a class object
 227  *
 228  *                          id         class object ID
 229  *                          u4         stack trace serial number
 230  *                          id         super class object ID
 231  *                          id         class loader object ID
 232  *                          id         signers object ID
 233  *                          id         protection domain object ID
 234  *                          id         reserved
 235  *                          id         reserved
 236  *
 237  *                          u4         instance size (in bytes)
 238  *
 239  *                          u2         size of constant pool
 240  *                          [u2,       constant pool index,
 241  *                           ty,       type
 242  *                                     2:  object
 243  *                                     4:  boolean
 244  *                                     5:  char
 245  *                                     6:  float
 246  *                                     7:  double
 247  *                                     8:  byte
 248  *                                     9:  short
 249  *                                     10: int
 250  *                                     11: long
 251  *                           vl]*      and value
 252  *
 253  *                          u2         number of static fields
 254  *                          [id,       static field name,
 255  *                           ty,       type,
 256  *                           vl]*      and value
 257  *
 258  *                          u2         number of inst. fields (not inc. super)
 259  *                          [id,       instance field name,
 260  *                           ty]*      type
 261  *
 262  *               HPROF_GC_INSTANCE_DUMP        dump of a normal object
 263  *
 264  *                          id         object ID
 265  *                          u4         stack trace serial number
 266  *                          id         class object ID
 267  *                          u4         number of bytes that follow
 268  *                          [vl]*      instance field values (class, followed
 269  *                                     by super, super&#39;s super ...)
 270  *
 271  *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array
 272  *
 273  *                          id         array object ID
 274  *                          u4         stack trace serial number
 275  *                          u4         number of elements
 276  *                          id         array class ID
 277  *                          [id]*      elements
 278  *
 279  *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array
 280  *
 281  *                          id         array object ID
 282  *                          u4         stack trace serial number
 283  *                          u4         number of elements
 284  *                          u1         element type
 285  *                                     4:  boolean array
 286  *                                     5:  char array
 287  *                                     6:  float array
 288  *                                     7:  double array
 289  *                                     8:  byte array
 290  *                                     9:  short array
 291  *                                     10: int array
 292  *                                     11: long array
 293  *                          [u1]*      elements
 294  *
 295  * HPROF_CPU_SAMPLES        a set of sample traces of running threads
 296  *
 297  *                u4        total number of samples
 298  *                u4        # of traces
 299  *               [u4        # of samples
 300  *                u4]*      stack trace serial number
 301  *
 302  * HPROF_CONTROL_SETTINGS   the settings of on/off switches
 303  *
 304  *                u4        0x00000001: alloc traces on/off
 305  *                          0x00000002: cpu sampling on/off
 306  *                u2        stack trace depth
 307  *
 308  *
 309  * When the header is &quot;JAVA PROFILE 1.0.2&quot; a heap dump can optionally
 310  * be generated as a sequence of heap dump segments. This sequence is
 311  * terminated by an end record. The additional tags allowed by format
 312  * &quot;JAVA PROFILE 1.0.2&quot; are:
 313  *
 314  * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment
 315  *
 316  *               [heap dump sub-records]*
 317  *               The same sub-record types allowed by HPROF_HEAP_DUMP
 318  *
 319  * HPROF_HEAP_DUMP_END      denotes the end of a heap dump
 320  *
 321  */
 322 
 323 
 324 // HPROF tags
 325 
 326 typedef enum {
 327   // top-level records
 328   HPROF_UTF8                    = 0x01,
 329   HPROF_LOAD_CLASS              = 0x02,
 330   HPROF_UNLOAD_CLASS            = 0x03,
 331   HPROF_FRAME                   = 0x04,
 332   HPROF_TRACE                   = 0x05,
 333   HPROF_ALLOC_SITES             = 0x06,
 334   HPROF_HEAP_SUMMARY            = 0x07,
 335   HPROF_START_THREAD            = 0x0A,
 336   HPROF_END_THREAD              = 0x0B,
 337   HPROF_HEAP_DUMP               = 0x0C,
 338   HPROF_CPU_SAMPLES             = 0x0D,
 339   HPROF_CONTROL_SETTINGS        = 0x0E,
 340 
 341   // 1.0.2 record types
 342   HPROF_HEAP_DUMP_SEGMENT       = 0x1C,
 343   HPROF_HEAP_DUMP_END           = 0x2C,
 344 
 345   // field types
 346   HPROF_ARRAY_OBJECT            = 0x01,
 347   HPROF_NORMAL_OBJECT           = 0x02,
 348   HPROF_BOOLEAN                 = 0x04,
 349   HPROF_CHAR                    = 0x05,
 350   HPROF_FLOAT                   = 0x06,
 351   HPROF_DOUBLE                  = 0x07,
 352   HPROF_BYTE                    = 0x08,
 353   HPROF_SHORT                   = 0x09,
 354   HPROF_INT                     = 0x0A,
 355   HPROF_LONG                    = 0x0B,
 356 
 357   // data-dump sub-records
 358   HPROF_GC_ROOT_UNKNOWN         = 0xFF,
 359   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 360   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 361   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 362   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 363   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 364   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 365   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 366   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 367   HPROF_GC_CLASS_DUMP           = 0x20,
 368   HPROF_GC_INSTANCE_DUMP        = 0x21,
 369   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 370   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 371 } hprofTag;
 372 
 373 // Default stack trace ID (used for dummy HPROF_TRACE record)
 374 enum {
 375   STACK_TRACE_ID = 1,
 376   INITIAL_CLASS_COUNT = 200
 377 };
 378 
 379 // Supports I/O operations on a dump file
 380 
 381 class DumpWriter : public StackObj {
 382  private:
 383   enum {
<a name="3" id="anc3"></a><span class="line-modified"> 384     io_buffer_size  = 8*M</span>


 385   };
 386 
 387   int _fd;              // file descriptor (-1 if dump file not open)
 388   julong _bytes_written; // number of byte written to dump file
 389 
 390   char* _buffer;    // internal buffer
 391   size_t _size;
 392   size_t _pos;
 393 
<a name="4" id="anc4"></a><span class="line-modified"> 394   jlong _dump_start;</span>



 395 
 396   char* _error;   // error message when I/O fails
 397 
 398   void set_file_descriptor(int fd)              { _fd = fd; }
 399   int file_descriptor() const                   { return _fd; }
 400 
<a name="5" id="anc5"></a>


 401   char* buffer() const                          { return _buffer; }
 402   size_t buffer_size() const                    { return _size; }
 403   size_t position() const                       { return _pos; }
 404   void set_position(size_t pos)                 { _pos = pos; }
 405 
 406   void set_error(const char* error)             { _error = (char*)os::strdup(error); }
 407 
 408   // all I/O go through this function
 409   void write_internal(void* s, size_t len);
 410 
 411  public:
 412   DumpWriter(const char* path);
 413   ~DumpWriter();
 414 
 415   void close();
<a name="6" id="anc6"></a><span class="line-removed"> 416   bool is_open() const                  { return file_descriptor() &gt;= 0; }</span>
<span class="line-removed"> 417   void flush();</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419   jlong dump_start() const                      { return _dump_start; }</span>
<span class="line-removed"> 420   void set_dump_start(jlong pos);</span>
<span class="line-removed"> 421   julong current_record_length();</span>
 422 
 423   // total number of bytes written to the disk
 424   julong bytes_written() const          { return _bytes_written; }
 425 
<a name="7" id="anc7"></a><span class="line-removed"> 426   // adjust the number of bytes written to disk (used to keep the count</span>
<span class="line-removed"> 427   // of the number of bytes written in case of rewrites)</span>
<span class="line-removed"> 428   void adjust_bytes_written(jlong n)    { _bytes_written += n; }</span>
<span class="line-removed"> 429 </span>
<span class="line-removed"> 430   // number of (buffered) bytes as yet unwritten to the dump file</span>
<span class="line-removed"> 431   size_t bytes_unwritten() const        { return position(); }</span>
<span class="line-removed"> 432 </span>
 433   char* error() const                   { return _error; }
 434 
<a name="8" id="anc8"></a><span class="line-removed"> 435   jlong current_offset();</span>
<span class="line-removed"> 436   void seek_to_offset(jlong pos);</span>
<span class="line-removed"> 437 </span>
 438   // writer functions
 439   void write_raw(void* s, size_t len);
 440   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }
 441   void write_u2(u2 x);
 442   void write_u4(u4 x);
 443   void write_u8(u8 x);
 444   void write_objectID(oop o);
 445   void write_symbolID(Symbol* o);
 446   void write_classID(Klass* k);
 447   void write_id(u4 x);
<a name="9" id="anc9"></a>






 448 };
 449 
<a name="10" id="anc10"></a><span class="line-modified"> 450 DumpWriter::DumpWriter(const char* path) {</span>

 451   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t
 452   // sufficient memory then reduce size until we can allocate something.
<a name="11" id="anc11"></a><span class="line-modified"> 453   _size = io_buffer_size;</span>
 454   do {
 455     _buffer = (char*)os::malloc(_size, mtInternal);
 456     if (_buffer == NULL) {
 457       _size = _size &gt;&gt; 1;
 458     }
<a name="12" id="anc12"></a><span class="line-modified"> 459   } while (_buffer == NULL &amp;&amp; _size &gt; 0);</span>
<span class="line-modified"> 460   assert((_size &gt; 0 &amp;&amp; _buffer != NULL) || (_size == 0 &amp;&amp; _buffer == NULL), &quot;sanity check&quot;);</span>
<span class="line-modified"> 461   _pos = 0;</span>
<span class="line-modified"> 462   _error = NULL;</span>
<span class="line-modified"> 463   _bytes_written = 0L;</span>
<span class="line-modified"> 464   _dump_start = (jlong)-1;</span>
<span class="line-modified"> 465   _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467   // if the open failed we record the error</span>
<span class="line-modified"> 468   if (_fd &lt; 0) {</span>
<span class="line-modified"> 469     _error = (char*)os::strdup(os::strerror(errno));</span>
 470   }
 471 }
 472 
 473 DumpWriter::~DumpWriter() {
<a name="13" id="anc13"></a><span class="line-modified"> 474   // flush and close dump file</span>
<span class="line-modified"> 475   if (is_open()) {</span>
<span class="line-modified"> 476     close();</span>
<span class="line-removed"> 477   }</span>
<span class="line-removed"> 478   if (_buffer != NULL) os::free(_buffer);</span>
<span class="line-removed"> 479   if (_error != NULL) os::free(_error);</span>
 480 }
 481 
 482 // closes dump file (if open)
 483 void DumpWriter::close() {
 484   // flush and close dump file
 485   if (is_open()) {
 486     flush();
 487     os::close(file_descriptor());
 488     set_file_descriptor(-1);
 489   }
 490 }
 491 
<a name="14" id="anc14"></a><span class="line-removed"> 492 // sets the dump starting position</span>
<span class="line-removed"> 493 void DumpWriter::set_dump_start(jlong pos) {</span>
<span class="line-removed"> 494   _dump_start = pos;</span>
<span class="line-removed"> 495 }</span>
<span class="line-removed"> 496 </span>
<span class="line-removed"> 497 julong DumpWriter::current_record_length() {</span>
<span class="line-removed"> 498   if (is_open()) {</span>
<span class="line-removed"> 499     // calculate the size of the dump record</span>
<span class="line-removed"> 500     julong dump_end = bytes_written() + bytes_unwritten();</span>
<span class="line-removed"> 501     assert(dump_end == (size_t)current_offset(), &quot;checking&quot;);</span>
<span class="line-removed"> 502     julong dump_len = dump_end - dump_start() - 4;</span>
<span class="line-removed"> 503     return dump_len;</span>
<span class="line-removed"> 504   }</span>
<span class="line-removed"> 505   return 0;</span>
<span class="line-removed"> 506 }</span>
<span class="line-removed"> 507 </span>
 508 // write directly to the file
 509 void DumpWriter::write_internal(void* s, size_t len) {
 510   if (is_open()) {
 511     const char* pos = (char*)s;
 512     ssize_t n = 0;
 513     while (len &gt; 0) {
<a name="15" id="anc15"></a><span class="line-modified"> 514       uint tmp = (uint)MIN2(len, (size_t)UINT_MAX);</span>
 515       n = os::write(file_descriptor(), pos, tmp);
 516 
 517       if (n &lt; 0) {
 518         // EINTR cannot happen here, os::write will take care of that
 519         set_error(os::strerror(errno));
 520         os::close(file_descriptor());
 521         set_file_descriptor(-1);
 522         return;
 523       }
 524 
 525       _bytes_written += n;
 526       pos += n;
 527       len -= n;
 528     }
 529   }
 530 }
 531 
 532 // write raw bytes
 533 void DumpWriter::write_raw(void* s, size_t len) {
<a name="16" id="anc16"></a><span class="line-modified"> 534   if (is_open()) {</span>
<span class="line-modified"> 535     // flush buffer to make room</span>
<span class="line-removed"> 536     if ((position() + len) &gt;= buffer_size()) {</span>
<span class="line-removed"> 537       flush();</span>
<span class="line-removed"> 538     }</span>
 539 
<a name="17" id="anc17"></a><span class="line-modified"> 540     // buffer not available or too big to buffer it</span>
<span class="line-modified"> 541     if ((buffer() == NULL) || (len &gt;= buffer_size())) {</span>





 542       write_internal(s, len);
<a name="18" id="anc18"></a><span class="line-modified"> 543     } else {</span>
<span class="line-modified"> 544       // Should optimize this for u1/u2/u4/u8 sizes.</span>
<span class="line-removed"> 545       memcpy(buffer() + position(), s, len);</span>
<span class="line-removed"> 546       set_position(position() + len);</span>
 547     }
 548   }
<a name="19" id="anc19"></a>


 549 }
 550 
 551 // flush any buffered bytes to the file
 552 void DumpWriter::flush() {
<a name="20" id="anc20"></a><span class="line-modified"> 553   if (is_open() &amp;&amp; position() &gt; 0) {</span>
<span class="line-modified"> 554     write_internal(buffer(), position());</span>
<span class="line-removed"> 555     set_position(0);</span>
<span class="line-removed"> 556   }</span>
<span class="line-removed"> 557 }</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559 jlong DumpWriter::current_offset() {</span>
<span class="line-removed"> 560   if (is_open()) {</span>
<span class="line-removed"> 561     // the offset is the file offset plus whatever we have buffered</span>
<span class="line-removed"> 562     jlong offset = os::current_file_offset(file_descriptor());</span>
<span class="line-removed"> 563     assert(offset &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed"> 564     return offset + position();</span>
<span class="line-removed"> 565   } else {</span>
<span class="line-removed"> 566     return (jlong)-1;</span>
<span class="line-removed"> 567   }</span>
<span class="line-removed"> 568 }</span>
<span class="line-removed"> 569 </span>
<span class="line-removed"> 570 void DumpWriter::seek_to_offset(jlong off) {</span>
<span class="line-removed"> 571   assert(off &gt;= 0, &quot;bad offset&quot;);</span>
<span class="line-removed"> 572 </span>
<span class="line-removed"> 573   // need to flush before seeking</span>
<span class="line-removed"> 574   flush();</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576   // may be closed due to I/O error</span>
<span class="line-removed"> 577   if (is_open()) {</span>
<span class="line-removed"> 578     jlong n = os::seek_to_file_offset(file_descriptor(), off);</span>
<span class="line-removed"> 579     assert(n &gt;= 0, &quot;lseek failed&quot;);</span>
<span class="line-removed"> 580   }</span>
 581 }
 582 
 583 void DumpWriter::write_u2(u2 x) {
 584   u2 v;
 585   Bytes::put_Java_u2((address)&amp;v, x);
 586   write_raw((void*)&amp;v, 2);
 587 }
 588 
 589 void DumpWriter::write_u4(u4 x) {
 590   u4 v;
 591   Bytes::put_Java_u4((address)&amp;v, x);
 592   write_raw((void*)&amp;v, 4);
 593 }
 594 
 595 void DumpWriter::write_u8(u8 x) {
 596   u8 v;
 597   Bytes::put_Java_u8((address)&amp;v, x);
 598   write_raw((void*)&amp;v, 8);
 599 }
 600 
 601 void DumpWriter::write_objectID(oop o) {
<a name="21" id="anc21"></a><span class="line-modified"> 602   address a = (address)o;</span>
 603 #ifdef _LP64
 604   write_u8((u8)a);
 605 #else
 606   write_u4((u4)a);
 607 #endif
 608 }
 609 
 610 void DumpWriter::write_symbolID(Symbol* s) {
 611   address a = (address)((uintptr_t)s);
 612 #ifdef _LP64
 613   write_u8((u8)a);
 614 #else
 615   write_u4((u4)a);
 616 #endif
 617 }
 618 
 619 void DumpWriter::write_id(u4 x) {
 620 #ifdef _LP64
 621   write_u8((u8) x);
 622 #else
 623   write_u4(x);
 624 #endif
 625 }
 626 
 627 // We use java mirror as the class ID
 628 void DumpWriter::write_classID(Klass* k) {
 629   write_objectID(k-&gt;java_mirror());
 630 }
 631 
<a name="22" id="anc22"></a>












































 632 
<a name="23" id="anc23"></a>





 633 
 634 // Support class with a collection of functions used when dumping the heap
 635 
 636 class DumperSupport : AllStatic {
 637  public:
 638 
 639   // write a header of the given type
 640   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 641 
 642   // returns hprof tag for the given type signature
 643   static hprofTag sig2tag(Symbol* sig);
 644   // returns hprof tag for the given basic type
 645   static hprofTag type2tag(BasicType type);
<a name="24" id="anc24"></a>

 646 
 647   // returns the size of the instance of the given class
 648   static u4 instance_size(Klass* k);
 649 
 650   // dump a jfloat
 651   static void dump_float(DumpWriter* writer, jfloat f);
 652   // dump a jdouble
 653   static void dump_double(DumpWriter* writer, jdouble d);
 654   // dumps the raw value of the given field
 655   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
<a name="25" id="anc25"></a>

 656   // dumps static fields of the given class
 657   static void dump_static_fields(DumpWriter* writer, Klass* k);
 658   // dump the raw values of the instance fields of the given object
 659   static void dump_instance_fields(DumpWriter* writer, oop o);
<a name="26" id="anc26"></a>

 660   // dumps the definition of the instance fields for a given class
 661   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 662   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 663   static void dump_instance(DumpWriter* writer, oop o);
 664   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 665   // array classes
 666   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 667   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 668   // class (and each multi-dimensional array class too)
 669   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 670 
 671   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 672   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 673   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 674   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 675   // create HPROF_FRAME record for the given method and bci
 676   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 677 
 678   // check if we need to truncate an array
 679   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 680 
<a name="27" id="anc27"></a><span class="line-removed"> 681   // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed"> 682   static void write_dump_header(DumpWriter* writer);</span>
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684   // fixes up the length of the current dump record</span>
<span class="line-removed"> 685   static void write_current_dump_record_length(DumpWriter* writer);</span>
<span class="line-removed"> 686 </span>
 687   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 688   static void end_of_dump(DumpWriter* writer);
<a name="28" id="anc28"></a>









 689 };
 690 
 691 // write a header of the given type
 692 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 693   writer-&gt;write_u1((u1)tag);
 694   writer-&gt;write_u4(0);                  // current ticks
 695   writer-&gt;write_u4(len);
 696 }
 697 
 698 // returns hprof tag for the given type signature
 699 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 700   switch (sig-&gt;char_at(0)) {
 701     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 702     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 703     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 704     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 705     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 706     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 707     case JVM_SIGNATURE_INT      : return HPROF_INT;
 708     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 709     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 710     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 711     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 712   }
 713 }
 714 
 715 hprofTag DumperSupport::type2tag(BasicType type) {
 716   switch (type) {
 717     case T_BYTE     : return HPROF_BYTE;
 718     case T_CHAR     : return HPROF_CHAR;
 719     case T_FLOAT    : return HPROF_FLOAT;
 720     case T_DOUBLE   : return HPROF_DOUBLE;
 721     case T_INT      : return HPROF_INT;
 722     case T_LONG     : return HPROF_LONG;
 723     case T_SHORT    : return HPROF_SHORT;
 724     case T_BOOLEAN  : return HPROF_BOOLEAN;
 725     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 726   }
 727 }
 728 
<a name="29" id="anc29"></a>















 729 // dump a jfloat
 730 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 731   if (g_isnan(f)) {
 732     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 733   } else {
 734     union {
 735       int i;
 736       float f;
 737     } u;
 738     u.f = (float)f;
 739     writer-&gt;write_u4((u4)u.i);
 740   }
 741 }
 742 
 743 // dump a jdouble
 744 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 745   union {
 746     jlong l;
 747     double d;
 748   } u;
 749   if (g_isnan(d)) {                 // collapsing NaNs
 750     u.l = (jlong)(0x7ff80000);
 751     u.l = (u.l &lt;&lt; 32);
 752   } else {
 753     u.d = (double)d;
 754   }
 755   writer-&gt;write_u8((u8)u.l);
 756 }
 757 
 758 // dumps the raw value of the given field
 759 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 760   switch (type) {
 761     case JVM_SIGNATURE_CLASS :
 762     case JVM_SIGNATURE_ARRAY : {
<a name="30" id="anc30"></a><span class="line-modified"> 763       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF&gt;(offset);</span>







 764       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 765       writer-&gt;write_objectID(o);
 766       break;
 767     }
 768     case JVM_SIGNATURE_BYTE : {
 769       jbyte b = obj-&gt;byte_field(offset);
 770       writer-&gt;write_u1((u1)b);
 771       break;
 772     }
 773     case JVM_SIGNATURE_CHAR : {
 774       jchar c = obj-&gt;char_field(offset);
 775       writer-&gt;write_u2((u2)c);
 776       break;
 777     }
 778     case JVM_SIGNATURE_SHORT : {
 779       jshort s = obj-&gt;short_field(offset);
 780       writer-&gt;write_u2((u2)s);
 781       break;
 782     }
 783     case JVM_SIGNATURE_FLOAT : {
 784       jfloat f = obj-&gt;float_field(offset);
 785       dump_float(writer, f);
 786       break;
 787     }
 788     case JVM_SIGNATURE_DOUBLE : {
 789       jdouble d = obj-&gt;double_field(offset);
 790       dump_double(writer, d);
 791       break;
 792     }
 793     case JVM_SIGNATURE_INT : {
 794       jint i = obj-&gt;int_field(offset);
 795       writer-&gt;write_u4((u4)i);
 796       break;
 797     }
 798     case JVM_SIGNATURE_LONG : {
 799       jlong l = obj-&gt;long_field(offset);
 800       writer-&gt;write_u8((u8)l);
 801       break;
 802     }
 803     case JVM_SIGNATURE_BOOLEAN : {
 804       jboolean b = obj-&gt;bool_field(offset);
 805       writer-&gt;write_u1((u1)b);
 806       break;
 807     }
 808     default : {
 809       ShouldNotReachHere();
 810       break;
 811     }
 812   }
 813 }
 814 
 815 // returns the size of the instance of the given class
 816 u4 DumperSupport::instance_size(Klass* k) {
 817   HandleMark hm;
 818   InstanceKlass* ik = InstanceKlass::cast(k);
<a name="31" id="anc31"></a><span class="line-removed"> 819 </span>
 820   u4 size = 0;
 821 
 822   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 823     if (!fld.access_flags().is_static()) {
<a name="32" id="anc32"></a><span class="line-modified"> 824       Symbol* sig = fld.signature();</span>
<span class="line-removed"> 825       switch (sig-&gt;char_at(0)) {</span>
<span class="line-removed"> 826         case JVM_SIGNATURE_CLASS   :</span>
<span class="line-removed"> 827         case JVM_SIGNATURE_ARRAY   : size += oopSize; break;</span>
<span class="line-removed"> 828 </span>
<span class="line-removed"> 829         case JVM_SIGNATURE_BYTE    :</span>
<span class="line-removed"> 830         case JVM_SIGNATURE_BOOLEAN : size += 1; break;</span>
<span class="line-removed"> 831 </span>
<span class="line-removed"> 832         case JVM_SIGNATURE_CHAR    :</span>
<span class="line-removed"> 833         case JVM_SIGNATURE_SHORT   : size += 2; break;</span>
<span class="line-removed"> 834 </span>
<span class="line-removed"> 835         case JVM_SIGNATURE_INT     :</span>
<span class="line-removed"> 836         case JVM_SIGNATURE_FLOAT   : size += 4; break;</span>
<span class="line-removed"> 837 </span>
<span class="line-removed"> 838         case JVM_SIGNATURE_LONG    :</span>
<span class="line-removed"> 839         case JVM_SIGNATURE_DOUBLE  : size += 8; break;</span>
<span class="line-removed"> 840 </span>
<span class="line-removed"> 841         default : ShouldNotReachHere();</span>
<span class="line-removed"> 842       }</span>
 843     }
 844   }
 845   return size;
 846 }
 847 
<a name="33" id="anc33"></a><span class="line-modified"> 848 // dumps static fields of the given class</span>
<span class="line-removed"> 849 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {</span>
 850   HandleMark hm;
<a name="34" id="anc34"></a><span class="line-modified"> 851   InstanceKlass* ik = InstanceKlass::cast(k);</span>

 852 
<a name="35" id="anc35"></a><span class="line-removed"> 853   // pass 1 - count the static fields</span>
<span class="line-removed"> 854   u2 field_count = 0;</span>
 855   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
<a name="36" id="anc36"></a><span class="line-modified"> 856     if (fldc.access_flags().is_static()) field_count++;</span>



 857   }
 858 
 859   // Add in resolved_references which is referenced by the cpCache
 860   // The resolved_references is an array per InstanceKlass holding the
 861   // strings and other oops resolved from the constant pool.
 862   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 863   if (resolved_references != NULL) {
 864     field_count++;
<a name="37" id="anc37"></a>
 865 
 866     // Add in the resolved_references of the used previous versions of the class
 867     // in the case of RedefineClasses
 868     InstanceKlass* prev = ik-&gt;previous_versions();
 869     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 870       field_count++;
<a name="38" id="anc38"></a>
 871       prev = prev-&gt;previous_versions();
 872     }
 873   }
 874 
 875   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 876   // arrays.
 877   oop init_lock = ik-&gt;init_lock();
 878   if (init_lock != NULL) {
 879     field_count++;
<a name="39" id="anc39"></a>
 880   }
 881 
<a name="40" id="anc40"></a><span class="line-modified"> 882   writer-&gt;write_u2(field_count);</span>


 883 
<a name="41" id="anc41"></a><span class="line-modified"> 884   // pass 2 - dump the field descriptors and raw values</span>





 885   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 886     if (fld.access_flags().is_static()) {
 887       Symbol* sig = fld.signature();
 888 
 889       writer-&gt;write_symbolID(fld.name());   // name
 890       writer-&gt;write_u1(sig2tag(sig));       // type
 891 
 892       // value
 893       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 894     }
 895   }
 896 
 897   // Add resolved_references for each class that has them
<a name="42" id="anc42"></a>
 898   if (resolved_references != NULL) {
 899     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 900     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 901     writer-&gt;write_objectID(resolved_references);
 902 
 903     // Also write any previous versions
 904     InstanceKlass* prev = ik-&gt;previous_versions();
 905     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 906       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 907       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 908       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 909       prev = prev-&gt;previous_versions();
 910     }
 911   }
 912 
 913   // Add init lock to the end if the class is not yet initialized
<a name="43" id="anc43"></a>
 914   if (init_lock != NULL) {
 915     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 916     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 917     writer-&gt;write_objectID(init_lock);
 918   }
 919 }
 920 
 921 // dump the raw values of the instance fields of the given object
 922 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
 923   HandleMark hm;
 924   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 925 
 926   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 927     if (!fld.access_flags().is_static()) {
 928       Symbol* sig = fld.signature();
 929       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 930     }
 931   }
 932 }
 933 
 934 // dumps the definition of the instance fields for a given class
<a name="44" id="anc44"></a><span class="line-modified"> 935 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {</span>
 936   HandleMark hm;
<a name="45" id="anc45"></a><span class="line-removed"> 937   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-removed"> 938 </span>
<span class="line-removed"> 939   // pass 1 - count the instance fields</span>
 940   u2 field_count = 0;
<a name="46" id="anc46"></a>
 941   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 942     if (!fldc.access_flags().is_static()) field_count++;
 943   }
 944 
<a name="47" id="anc47"></a><span class="line-modified"> 945   writer-&gt;write_u2(field_count);</span>






 946 
<a name="48" id="anc48"></a><span class="line-modified"> 947   // pass 2 - dump the field descriptors</span>
 948   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 949     if (!fld.access_flags().is_static()) {
 950       Symbol* sig = fld.signature();
 951 
 952       writer-&gt;write_symbolID(fld.name());   // name
 953       writer-&gt;write_u1(sig2tag(sig));       // type
 954     }
 955   }
 956 }
 957 
 958 // creates HPROF_GC_INSTANCE_DUMP record for the given object
 959 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
<a name="49" id="anc49"></a><span class="line-modified"> 960   Klass* k = o-&gt;klass();</span>


 961 
<a name="50" id="anc50"></a><span class="line-modified"> 962   writer-&gt;write_u1(HPROF_GC_INSTANCE_DUMP);</span>
 963   writer-&gt;write_objectID(o);
 964   writer-&gt;write_u4(STACK_TRACE_ID);
 965 
 966   // class ID
<a name="51" id="anc51"></a><span class="line-modified"> 967   writer-&gt;write_classID(k);</span>
 968 
 969   // number of bytes that follow
<a name="52" id="anc52"></a><span class="line-modified"> 970   writer-&gt;write_u4(instance_size(k) );</span>
 971 
 972   // field values
 973   dump_instance_fields(writer, o);
<a name="53" id="anc53"></a>

 974 }
 975 
 976 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
 977 // its array classes
 978 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
 979   InstanceKlass* ik = InstanceKlass::cast(k);
 980 
 981   // We can safepoint and do a heap dump at a point where we have a Klass,
 982   // but no java mirror class has been setup for it. So we need to check
 983   // that the class is at least loaded, to avoid crash from a null mirror.
 984   if (!ik-&gt;is_loaded()) {
 985     return;
 986   }
 987 
<a name="54" id="anc54"></a><span class="line-modified"> 988   writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>






 989 
 990   // class ID
 991   writer-&gt;write_classID(ik);
 992   writer-&gt;write_u4(STACK_TRACE_ID);
 993 
 994   // super class ID
 995   InstanceKlass* java_super = ik-&gt;java_super();
 996   if (java_super == NULL) {
 997     writer-&gt;write_objectID(oop(NULL));
 998   } else {
 999     writer-&gt;write_classID(java_super);
1000   }
1001 
1002   writer-&gt;write_objectID(ik-&gt;class_loader());
1003   writer-&gt;write_objectID(ik-&gt;signers());
1004   writer-&gt;write_objectID(ik-&gt;protection_domain());
1005 
1006   // reserved
1007   writer-&gt;write_objectID(oop(NULL));
1008   writer-&gt;write_objectID(oop(NULL));
1009 
1010   // instance size
<a name="55" id="anc55"></a><span class="line-modified">1011   writer-&gt;write_u4(DumperSupport::instance_size(k));</span>
1012 
1013   // size of constant pool - ignored by HAT 1.1
1014   writer-&gt;write_u2(0);
1015 
<a name="56" id="anc56"></a><span class="line-modified">1016   // number of static fields</span>
<span class="line-modified">1017   dump_static_fields(writer, k);</span>

1018 
1019   // description of instance fields
<a name="57" id="anc57"></a><span class="line-modified">1020   dump_instance_field_descriptors(writer, k);</span>



1021 
1022   // array classes
<a name="58" id="anc58"></a><span class="line-modified">1023   k = k-&gt;array_klass_or_null();</span>
1024   while (k != NULL) {
<a name="59" id="anc59"></a><span class="line-modified">1025     Klass* klass = k;</span>
<span class="line-removed">1026     assert(klass-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);</span>
1027 
<a name="60" id="anc60"></a><span class="line-modified">1028     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>
<span class="line-modified">1029     writer-&gt;write_classID(klass);</span>

1030     writer-&gt;write_u4(STACK_TRACE_ID);
1031 
1032     // super class of array classes is java.lang.Object
<a name="61" id="anc61"></a><span class="line-modified">1033     java_super = klass-&gt;java_super();</span>
1034     assert(java_super != NULL, &quot;checking&quot;);
1035     writer-&gt;write_classID(java_super);
1036 
1037     writer-&gt;write_objectID(ik-&gt;class_loader());
1038     writer-&gt;write_objectID(ik-&gt;signers());
1039     writer-&gt;write_objectID(ik-&gt;protection_domain());
1040 
1041     writer-&gt;write_objectID(oop(NULL));    // reserved
1042     writer-&gt;write_objectID(oop(NULL));
1043     writer-&gt;write_u4(0);             // instance size
1044     writer-&gt;write_u2(0);             // constant pool
1045     writer-&gt;write_u2(0);             // static fields
1046     writer-&gt;write_u2(0);             // instance fields
1047 
<a name="62" id="anc62"></a>

1048     // get the array class for the next rank
<a name="63" id="anc63"></a><span class="line-modified">1049     k = klass-&gt;array_klass_or_null();</span>
1050   }
1051 }
1052 
1053 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1054 // class (and each multi-dimensional array class too)
1055 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1056  // array classes
1057  while (k != NULL) {
1058     Klass* klass = k;
1059 
<a name="64" id="anc64"></a><span class="line-modified">1060     writer-&gt;write_u1(HPROF_GC_CLASS_DUMP);</span>

1061     writer-&gt;write_classID(klass);
1062     writer-&gt;write_u4(STACK_TRACE_ID);
1063 
1064     // super class of array classes is java.lang.Object
1065     InstanceKlass* java_super = klass-&gt;java_super();
1066     assert(java_super != NULL, &quot;checking&quot;);
1067     writer-&gt;write_classID(java_super);
1068 
1069     writer-&gt;write_objectID(oop(NULL));    // loader
1070     writer-&gt;write_objectID(oop(NULL));    // signers
1071     writer-&gt;write_objectID(oop(NULL));    // protection domain
1072 
1073     writer-&gt;write_objectID(oop(NULL));    // reserved
1074     writer-&gt;write_objectID(oop(NULL));
1075     writer-&gt;write_u4(0);             // instance size
1076     writer-&gt;write_u2(0);             // constant pool
1077     writer-&gt;write_u2(0);             // static fields
1078     writer-&gt;write_u2(0);             // instance fields
1079 
<a name="65" id="anc65"></a>

1080     // get the array class for the next rank
1081     k = klass-&gt;array_klass_or_null();
1082   }
1083 }
1084 
1085 // Hprof uses an u4 as record length field,
1086 // which means we need to truncate arrays that are too long.
1087 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1088   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1089   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1090 
1091   int length = array-&gt;length();
1092 
1093   int type_size;
1094   if (type == T_OBJECT) {
1095     type_size = sizeof(address);
1096   } else {
1097     type_size = type2aelembytes(type);
1098   }
1099 
1100   size_t length_in_bytes = (size_t)length * type_size;
<a name="66" id="anc66"></a>
1101 
<a name="67" id="anc67"></a><span class="line-removed">1102   // Create a new record if the current record is non-empty and the array can&#39;t fit.</span>
<span class="line-removed">1103   julong current_record_length = writer-&gt;current_record_length();</span>
<span class="line-removed">1104   if (current_record_length &gt; 0 &amp;&amp;</span>
<span class="line-removed">1105       (current_record_length + header_size + length_in_bytes) &gt; max_juint) {</span>
<span class="line-removed">1106     write_current_dump_record_length(writer);</span>
<span class="line-removed">1107     write_dump_header(writer);</span>
<span class="line-removed">1108 </span>
<span class="line-removed">1109     // We now have an empty record.</span>
<span class="line-removed">1110     current_record_length = 0;</span>
<span class="line-removed">1111   }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113   // Calculate max bytes we can use.</span>
<span class="line-removed">1114   uint max_bytes = max_juint - (header_size + current_record_length);</span>
<span class="line-removed">1115 </span>
<span class="line-removed">1116   // Array too long for the record?</span>
<span class="line-removed">1117   // Calculate max length and return it.</span>
1118   if (length_in_bytes &gt; max_bytes) {
1119     length = max_bytes / type_size;
1120     length_in_bytes = (size_t)length * type_size;
1121 
1122     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1123             type2name_tab[type], array-&gt;length(), length);
1124   }
1125   return length;
1126 }
1127 
1128 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1129 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1130   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1131   short header_size = 1 + 2 * 4 + 2 * sizeof(address);
<a name="68" id="anc68"></a><span class="line-removed">1132 </span>
1133   int length = calculate_array_max_length(writer, array, header_size);
<a name="69" id="anc69"></a>
1134 
<a name="70" id="anc70"></a><span class="line-modified">1135   writer-&gt;write_u1(HPROF_GC_OBJ_ARRAY_DUMP);</span>
1136   writer-&gt;write_objectID(array);
1137   writer-&gt;write_u4(STACK_TRACE_ID);
1138   writer-&gt;write_u4(length);
1139 
1140   // array class ID
1141   writer-&gt;write_classID(array-&gt;klass());
1142 
1143   // [id]* elements
1144   for (int index = 0; index &lt; length; index++) {
1145     oop o = array-&gt;obj_at(index);
<a name="71" id="anc71"></a>






1146     writer-&gt;write_objectID(o);
1147   }
<a name="72" id="anc72"></a>

1148 }
1149 
1150 #define WRITE_ARRAY(Array, Type, Size, Length) \
1151   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1152 
1153 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1154 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1155   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1156 
1157   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1158   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1159 
1160   int length = calculate_array_max_length(writer, array, header_size);
1161   int type_size = type2aelembytes(type);
1162   u4 length_in_bytes = (u4)length * type_size;
<a name="73" id="anc73"></a>
1163 
<a name="74" id="anc74"></a><span class="line-modified">1164   writer-&gt;write_u1(HPROF_GC_PRIM_ARRAY_DUMP);</span>
1165   writer-&gt;write_objectID(array);
1166   writer-&gt;write_u4(STACK_TRACE_ID);
1167   writer-&gt;write_u4(length);
1168   writer-&gt;write_u1(type2tag(type));
1169 
1170   // nothing to copy
1171   if (length == 0) {
<a name="75" id="anc75"></a>
1172     return;
1173   }
1174 
1175   // If the byte ordering is big endian then we can copy most types directly
1176 
1177   switch (type) {
1178     case T_INT : {
1179       if (Endian::is_Java_byte_ordering_different()) {
1180         WRITE_ARRAY(array, int, u4, length);
1181       } else {
1182         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1183       }
1184       break;
1185     }
1186     case T_BYTE : {
1187       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1188       break;
1189     }
1190     case T_CHAR : {
1191       if (Endian::is_Java_byte_ordering_different()) {
1192         WRITE_ARRAY(array, char, u2, length);
1193       } else {
1194         writer-&gt;write_raw((void*)(array-&gt;char_at_addr(0)), length_in_bytes);
1195       }
1196       break;
1197     }
1198     case T_SHORT : {
1199       if (Endian::is_Java_byte_ordering_different()) {
1200         WRITE_ARRAY(array, short, u2, length);
1201       } else {
1202         writer-&gt;write_raw((void*)(array-&gt;short_at_addr(0)), length_in_bytes);
1203       }
1204       break;
1205     }
1206     case T_BOOLEAN : {
1207       if (Endian::is_Java_byte_ordering_different()) {
1208         WRITE_ARRAY(array, bool, u1, length);
1209       } else {
1210         writer-&gt;write_raw((void*)(array-&gt;bool_at_addr(0)), length_in_bytes);
1211       }
1212       break;
1213     }
1214     case T_LONG : {
1215       if (Endian::is_Java_byte_ordering_different()) {
1216         WRITE_ARRAY(array, long, u8, length);
1217       } else {
1218         writer-&gt;write_raw((void*)(array-&gt;long_at_addr(0)), length_in_bytes);
1219       }
1220       break;
1221     }
1222 
1223     // handle float/doubles in a special value to ensure than NaNs are
1224     // written correctly. TO DO: Check if we can avoid this on processors that
1225     // use IEEE 754.
1226 
1227     case T_FLOAT : {
1228       for (int i = 0; i &lt; length; i++) {
1229         dump_float(writer, array-&gt;float_at(i));
1230       }
1231       break;
1232     }
1233     case T_DOUBLE : {
1234       for (int i = 0; i &lt; length; i++) {
1235         dump_double(writer, array-&gt;double_at(i));
1236       }
1237       break;
1238     }
1239     default : ShouldNotReachHere();
1240   }
<a name="76" id="anc76"></a>

1241 }
1242 
1243 // create a HPROF_FRAME record of the given Method* and bci
1244 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1245                                      int frame_serial_num,
1246                                      int class_serial_num,
1247                                      Method* m,
1248                                      int bci) {
1249   int line_number;
1250   if (m-&gt;is_native()) {
1251     line_number = -3;  // native frame
1252   } else {
1253     line_number = m-&gt;line_number_from_bci(bci);
1254   }
1255 
1256   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1257   writer-&gt;write_id(frame_serial_num);               // frame serial number
1258   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1259   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1260 
1261   assert(m-&gt;method_holder()-&gt;is_instance_klass(), &quot;not InstanceKlass&quot;);
1262   writer-&gt;write_symbolID(m-&gt;method_holder()-&gt;source_file_name());  // source file name
1263   writer-&gt;write_u4(class_serial_num);               // class serial number
1264   writer-&gt;write_u4((u4) line_number);               // line number
1265 }
1266 
1267 
1268 // Support class used to generate HPROF_UTF8 records from the entries in the
1269 // SymbolTable.
1270 
1271 class SymbolTableDumper : public SymbolClosure {
1272  private:
1273   DumpWriter* _writer;
1274   DumpWriter* writer() const                { return _writer; }
1275  public:
1276   SymbolTableDumper(DumpWriter* writer)     { _writer = writer; }
1277   void do_symbol(Symbol** p);
1278 };
1279 
1280 void SymbolTableDumper::do_symbol(Symbol** p) {
1281   ResourceMark rm;
1282   Symbol* sym = load_symbol(p);
1283   int len = sym-&gt;utf8_length();
1284   if (len &gt; 0) {
1285     char* s = sym-&gt;as_utf8();
1286     DumperSupport::write_header(writer(), HPROF_UTF8, oopSize + len);
1287     writer()-&gt;write_symbolID(sym);
1288     writer()-&gt;write_raw(s, len);
1289   }
1290 }
1291 
1292 // Support class used to generate HPROF_GC_ROOT_JNI_LOCAL records
1293 
1294 class JNILocalsDumper : public OopClosure {
1295  private:
1296   DumpWriter* _writer;
1297   u4 _thread_serial_num;
1298   int _frame_num;
1299   DumpWriter* writer() const                { return _writer; }
1300  public:
1301   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1302     _writer = writer;
1303     _thread_serial_num = thread_serial_num;
1304     _frame_num = -1;  // default - empty stack
1305   }
1306   void set_frame_number(int n) { _frame_num = n; }
1307   void do_oop(oop* obj_p);
1308   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1309 };
1310 
1311 
1312 void JNILocalsDumper::do_oop(oop* obj_p) {
1313   // ignore null handles
1314   oop o = *obj_p;
1315   if (o != NULL) {
<a name="77" id="anc77"></a><span class="line-modified">1316     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_LOCAL);</span>

1317     writer()-&gt;write_objectID(o);
1318     writer()-&gt;write_u4(_thread_serial_num);
1319     writer()-&gt;write_u4((u4)_frame_num);
<a name="78" id="anc78"></a>
1320   }
1321 }
1322 
1323 
1324 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1325 
1326 class JNIGlobalsDumper : public OopClosure {
1327  private:
1328   DumpWriter* _writer;
1329   DumpWriter* writer() const                { return _writer; }
1330 
1331  public:
1332   JNIGlobalsDumper(DumpWriter* writer) {
1333     _writer = writer;
1334   }
1335   void do_oop(oop* obj_p);
1336   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1337 };
1338 
1339 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1340   oop o = *obj_p;
1341 
1342   // ignore these
1343   if (o == NULL) return;
1344 
1345   // we ignore global ref to symbols and other internal objects
1346   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
<a name="79" id="anc79"></a><span class="line-modified">1347     writer()-&gt;write_u1(HPROF_GC_ROOT_JNI_GLOBAL);</span>

1348     writer()-&gt;write_objectID(o);
1349     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
<a name="80" id="anc80"></a>
1350   }
1351 };
1352 
1353 
1354 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1355 
1356 class MonitorUsedDumper : public OopClosure {
1357  private:
1358   DumpWriter* _writer;
1359   DumpWriter* writer() const                { return _writer; }
1360  public:
1361   MonitorUsedDumper(DumpWriter* writer) {
1362     _writer = writer;
1363   }
1364   void do_oop(oop* obj_p) {
<a name="81" id="anc81"></a><span class="line-modified">1365     writer()-&gt;write_u1(HPROF_GC_ROOT_MONITOR_USED);</span>

1366     writer()-&gt;write_objectID(*obj_p);
<a name="82" id="anc82"></a>
1367   }
1368   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1369 };
1370 
1371 
1372 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1373 
1374 class StickyClassDumper : public KlassClosure {
1375  private:
1376   DumpWriter* _writer;
1377   DumpWriter* writer() const                { return _writer; }
1378  public:
1379   StickyClassDumper(DumpWriter* writer) {
1380     _writer = writer;
1381   }
1382   void do_klass(Klass* k) {
1383     if (k-&gt;is_instance_klass()) {
1384       InstanceKlass* ik = InstanceKlass::cast(k);
<a name="83" id="anc83"></a><span class="line-modified">1385         writer()-&gt;write_u1(HPROF_GC_ROOT_STICKY_CLASS);</span>
<span class="line-modified">1386         writer()-&gt;write_classID(ik);</span>
<span class="line-modified">1387       }</span>

1388     }
<a name="84" id="anc84"></a>
1389 };
1390 
1391 
1392 class VM_HeapDumper;
1393 
1394 // Support class using when iterating over the heap.
1395 
1396 class HeapObjectDumper : public ObjectClosure {
1397  private:
1398   VM_HeapDumper* _dumper;
1399   DumpWriter* _writer;
1400 
1401   VM_HeapDumper* dumper()               { return _dumper; }
1402   DumpWriter* writer()                  { return _writer; }
1403 
<a name="85" id="anc85"></a><span class="line-removed">1404   // used to indicate that a record has been writen</span>
<span class="line-removed">1405   void mark_end_of_record();</span>
<span class="line-removed">1406 </span>
1407  public:
1408   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1409     _dumper = dumper;
1410     _writer = writer;
1411   }
1412 
1413   // called for each object in the heap
1414   void do_object(oop o);
1415 };
1416 
1417 void HeapObjectDumper::do_object(oop o) {
1418   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1419   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1420     if (!java_lang_Class::is_primitive(o)) {
1421       return;
1422     }
1423   }
1424 
<a name="86" id="anc86"></a>




1425   if (o-&gt;is_instance()) {
1426     // create a HPROF_GC_INSTANCE record for each object
1427     DumperSupport::dump_instance(writer(), o);
<a name="87" id="anc87"></a><span class="line-removed">1428     mark_end_of_record();</span>
1429   } else if (o-&gt;is_objArray()) {
1430     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1431     DumperSupport::dump_object_array(writer(), objArrayOop(o));
<a name="88" id="anc88"></a><span class="line-removed">1432     mark_end_of_record();</span>
1433   } else if (o-&gt;is_typeArray()) {
1434     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1435     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
<a name="89" id="anc89"></a><span class="line-removed">1436     mark_end_of_record();</span>
1437   }
1438 }
1439 
1440 // The VM operation that performs the heap dump
1441 class VM_HeapDumper : public VM_GC_Operation {
1442  private:
1443   static VM_HeapDumper* _global_dumper;
1444   static DumpWriter*    _global_writer;
1445   DumpWriter*           _local_writer;
1446   JavaThread*           _oome_thread;
1447   Method*               _oome_constructor;
1448   bool _gc_before_heap_dump;
1449   GrowableArray&lt;Klass*&gt;* _klass_map;
1450   ThreadStackTrace** _stack_traces;
1451   int _num_threads;
1452 
1453   // accessors and setters
1454   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1455   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1456   void set_global_dumper() {
1457     assert(_global_dumper == NULL, &quot;Error&quot;);
1458     _global_dumper = this;
1459   }
1460   void set_global_writer() {
1461     assert(_global_writer == NULL, &quot;Error&quot;);
1462     _global_writer = _local_writer;
1463   }
1464   void clear_global_dumper() { _global_dumper = NULL; }
1465   void clear_global_writer() { _global_writer = NULL; }
1466 
1467   bool skip_operation() const;
1468 
1469   // writes a HPROF_LOAD_CLASS record
1470   class ClassesDo;
1471   static void do_load_class(Klass* k);
1472 
1473   // writes a HPROF_GC_CLASS_DUMP record for the given class
1474   // (and each array class too)
1475   static void do_class_dump(Klass* k);
1476 
1477   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1478   // array (and each multi-dimensional array too)
1479   static void do_basic_type_array_class_dump(Klass* k);
1480 
1481   // HPROF_GC_ROOT_THREAD_OBJ records
1482   int do_thread(JavaThread* thread, u4 thread_serial_num);
1483   void do_threads();
1484 
1485   void add_class_serial_number(Klass* k, int serial_num) {
1486     _klass_map-&gt;at_put_grow(serial_num, k);
1487   }
1488 
1489   // HPROF_TRACE and HPROF_FRAME records
1490   void dump_stack_traces();
1491 
1492  public:
1493   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1494     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1495                     GCCause::_heap_dump /* GC Cause */,
1496                     0 /* total full collections, dummy, ignored */,
1497                     gc_before_heap_dump) {
1498     _local_writer = writer;
1499     _gc_before_heap_dump = gc_before_heap_dump;
1500     _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, true);
1501     _stack_traces = NULL;
1502     _num_threads = 0;
1503     if (oome) {
1504       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1505       // get OutOfMemoryError zero-parameter constructor
1506       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1507       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1508                                                           vmSymbols::void_method_signature());
1509       // get thread throwing OOME when generating the heap dump at OOME
1510       _oome_thread = JavaThread::current();
1511     } else {
1512       _oome_thread = NULL;
1513       _oome_constructor = NULL;
1514     }
1515   }
1516   ~VM_HeapDumper() {
1517     if (_stack_traces != NULL) {
1518       for (int i=0; i &lt; _num_threads; i++) {
1519         delete _stack_traces[i];
1520       }
1521       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1522     }
1523     delete _klass_map;
1524   }
1525 
1526   VMOp_Type type() const { return VMOp_HeapDumper; }
<a name="90" id="anc90"></a><span class="line-removed">1527   // used to mark sub-record boundary</span>
<span class="line-removed">1528   void check_segment_length();</span>
1529   void doit();
1530 };
1531 
1532 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1533 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1534 
1535 bool VM_HeapDumper::skip_operation() const {
1536   return false;
1537 }
1538 
<a name="91" id="anc91"></a><span class="line-removed">1539  // writes a HPROF_HEAP_DUMP_SEGMENT record</span>
<span class="line-removed">1540 void DumperSupport::write_dump_header(DumpWriter* writer) {</span>
<span class="line-removed">1541   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1542     writer-&gt;write_u1(HPROF_HEAP_DUMP_SEGMENT);</span>
<span class="line-removed">1543     writer-&gt;write_u4(0); // current ticks</span>
<span class="line-removed">1544 </span>
<span class="line-removed">1545     // record the starting position for the dump (its length will be fixed up later)</span>
<span class="line-removed">1546     writer-&gt;set_dump_start(writer-&gt;current_offset());</span>
<span class="line-removed">1547     writer-&gt;write_u4(0);</span>
<span class="line-removed">1548   }</span>
<span class="line-removed">1549 }</span>
<span class="line-removed">1550 </span>
<span class="line-removed">1551 // fixes up the length of the current dump record</span>
<span class="line-removed">1552 void DumperSupport::write_current_dump_record_length(DumpWriter* writer) {</span>
<span class="line-removed">1553   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1554     julong dump_end = writer-&gt;bytes_written() + writer-&gt;bytes_unwritten();</span>
<span class="line-removed">1555     julong dump_len = writer-&gt;current_record_length();</span>
<span class="line-removed">1556 </span>
<span class="line-removed">1557     // record length must fit in a u4</span>
<span class="line-removed">1558     if (dump_len &gt; max_juint) {</span>
<span class="line-removed">1559       warning(&quot;record is too large&quot;);</span>
<span class="line-removed">1560     }</span>
<span class="line-removed">1561 </span>
<span class="line-removed">1562     // seek to the dump start and fix-up the length</span>
<span class="line-removed">1563     assert(writer-&gt;dump_start() &gt;= 0, &quot;no dump start recorded&quot;);</span>
<span class="line-removed">1564     writer-&gt;seek_to_offset(writer-&gt;dump_start());</span>
<span class="line-removed">1565     writer-&gt;write_u4((u4)dump_len);</span>
<span class="line-removed">1566 </span>
<span class="line-removed">1567     // adjust the total size written to keep the bytes written correct.</span>
<span class="line-removed">1568     writer-&gt;adjust_bytes_written(-((jlong) sizeof(u4)));</span>
<span class="line-removed">1569 </span>
<span class="line-removed">1570     // seek to dump end so we can continue</span>
<span class="line-removed">1571     writer-&gt;seek_to_offset(dump_end);</span>
<span class="line-removed">1572 </span>
<span class="line-removed">1573     // no current dump record</span>
<span class="line-removed">1574     writer-&gt;set_dump_start((jlong)-1);</span>
<span class="line-removed">1575   }</span>
<span class="line-removed">1576 }</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578 // used on a sub-record boundary to check if we need to start a</span>
<span class="line-removed">1579 // new segment.</span>
<span class="line-removed">1580 void VM_HeapDumper::check_segment_length() {</span>
<span class="line-removed">1581   if (writer()-&gt;is_open()) {</span>
<span class="line-removed">1582     julong dump_len = writer()-&gt;current_record_length();</span>
<span class="line-removed">1583 </span>
<span class="line-removed">1584     if (dump_len &gt; 2UL*G) {</span>
<span class="line-removed">1585       DumperSupport::write_current_dump_record_length(writer());</span>
<span class="line-removed">1586       DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">1587     }</span>
<span class="line-removed">1588   }</span>
<span class="line-removed">1589 }</span>
<span class="line-removed">1590 </span>
1591 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1592 void DumperSupport::end_of_dump(DumpWriter* writer) {
<a name="92" id="anc92"></a><span class="line-modified">1593   if (writer-&gt;is_open()) {</span>
<span class="line-removed">1594     write_current_dump_record_length(writer);</span>
<span class="line-removed">1595 </span>
<span class="line-removed">1596     writer-&gt;write_u1(HPROF_HEAP_DUMP_END);</span>
<span class="line-removed">1597     writer-&gt;write_u4(0);</span>
<span class="line-removed">1598     writer-&gt;write_u4(0);</span>
<span class="line-removed">1599   }</span>
<span class="line-removed">1600 }</span>
1601 
<a name="93" id="anc93"></a><span class="line-modified">1602 // marks sub-record boundary</span>
<span class="line-modified">1603 void HeapObjectDumper::mark_end_of_record() {</span>
<span class="line-modified">1604   dumper()-&gt;check_segment_length();</span>
1605 }
1606 
1607 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1608 // array classes)
1609 void VM_HeapDumper::do_load_class(Klass* k) {
1610   static u4 class_serial_num = 0;
1611 
1612   // len of HPROF_LOAD_CLASS record
1613   u4 remaining = 2*oopSize + 2*sizeof(u4);
1614 
1615   // write a HPROF_LOAD_CLASS for the class and each array class
1616   do {
1617     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1618 
1619     // class serial number is just a number
1620     writer()-&gt;write_u4(++class_serial_num);
1621 
1622     // class ID
1623     Klass* klass = k;
1624     writer()-&gt;write_classID(klass);
1625 
1626     // add the Klass* and class serial number pair
1627     dumper()-&gt;add_class_serial_number(klass, class_serial_num);
1628 
1629     writer()-&gt;write_u4(STACK_TRACE_ID);
1630 
1631     // class name ID
1632     Symbol* name = klass-&gt;name();
1633     writer()-&gt;write_symbolID(name);
1634 
1635     // write a LOAD_CLASS record for the array type (if it exists)
1636     k = klass-&gt;array_klass_or_null();
1637   } while (k != NULL);
1638 }
1639 
1640 // writes a HPROF_GC_CLASS_DUMP record for the given class
1641 void VM_HeapDumper::do_class_dump(Klass* k) {
1642   if (k-&gt;is_instance_klass()) {
1643     DumperSupport::dump_class_and_array_classes(writer(), k);
1644   }
1645 }
1646 
1647 // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1648 // array (and each multi-dimensional array too)
1649 void VM_HeapDumper::do_basic_type_array_class_dump(Klass* k) {
1650   DumperSupport::dump_basic_type_array_class(writer(), k);
1651 }
1652 
1653 // Walk the stack of the given thread.
1654 // Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local
1655 // Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local
1656 //
1657 // It returns the number of Java frames in this thread stack
1658 int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {
1659   JNILocalsDumper blk(writer(), thread_serial_num);
1660 
1661   oop threadObj = java_thread-&gt;threadObj();
1662   assert(threadObj != NULL, &quot;sanity check&quot;);
1663 
1664   int stack_depth = 0;
1665   if (java_thread-&gt;has_last_Java_frame()) {
1666 
1667     // vframes are resource allocated
1668     Thread* current_thread = Thread::current();
1669     ResourceMark rm(current_thread);
1670     HandleMark hm(current_thread);
1671 
1672     RegisterMap reg_map(java_thread);
1673     frame f = java_thread-&gt;last_frame();
1674     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1675     frame* last_entry_frame = NULL;
1676     int extra_frames = 0;
1677 
1678     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1679       extra_frames++;
1680     }
1681     while (vf != NULL) {
1682       blk.set_frame_number(stack_depth);
1683       if (vf-&gt;is_java_frame()) {
1684 
1685         // java frame (interpreted, compiled, ...)
1686         javaVFrame *jvf = javaVFrame::cast(vf);
1687         if (!(jvf-&gt;method()-&gt;is_native())) {
1688           StackValueCollection* locals = jvf-&gt;locals();
1689           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1690             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1691               oop o = locals-&gt;obj_at(slot)();
1692 
1693               if (o != NULL) {
<a name="94" id="anc94"></a><span class="line-modified">1694                 writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>

1695                 writer()-&gt;write_objectID(o);
1696                 writer()-&gt;write_u4(thread_serial_num);
1697                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<a name="95" id="anc95"></a>
1698               }
1699             }
1700           }
1701           StackValueCollection *exprs = jvf-&gt;expressions();
1702           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1703             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1704                oop o = exprs-&gt;obj_at(index)();
1705                if (o != NULL) {
<a name="96" id="anc96"></a><span class="line-modified">1706                  writer()-&gt;write_u1(HPROF_GC_ROOT_JAVA_FRAME);</span>

1707                  writer()-&gt;write_objectID(o);
1708                  writer()-&gt;write_u4(thread_serial_num);
1709                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
<a name="97" id="anc97"></a>
1710                }
1711              }
1712           }
1713         } else {
1714           // native frame
1715           if (stack_depth == 0) {
1716             // JNI locals for the top frame.
1717             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1718           } else {
1719             if (last_entry_frame != NULL) {
1720               // JNI locals for the entry frame
1721               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1722               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1723             }
1724           }
1725         }
1726         // increment only for Java frames
1727         stack_depth++;
1728         last_entry_frame = NULL;
1729 
1730       } else {
1731         // externalVFrame - if it&#39;s an entry frame then report any JNI locals
1732         // as roots when we find the corresponding native javaVFrame
1733         frame* fr = vf-&gt;frame_pointer();
1734         assert(fr != NULL, &quot;sanity check&quot;);
1735         if (fr-&gt;is_entry_frame()) {
1736           last_entry_frame = fr;
1737         }
1738       }
1739       vf = vf-&gt;sender();
1740     }
1741   } else {
1742     // no last java frame but there may be JNI locals
1743     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1744   }
1745   return stack_depth;
1746 }
1747 
1748 
1749 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1750 // the stack so that locals and JNI locals are dumped.
1751 void VM_HeapDumper::do_threads() {
1752   for (int i=0; i &lt; _num_threads; i++) {
1753     JavaThread* thread = _stack_traces[i]-&gt;thread();
1754     oop threadObj = thread-&gt;threadObj();
1755     u4 thread_serial_num = i+1;
1756     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
<a name="98" id="anc98"></a><span class="line-modified">1757     writer()-&gt;write_u1(HPROF_GC_ROOT_THREAD_OBJ);</span>

1758     writer()-&gt;write_objectID(threadObj);
1759     writer()-&gt;write_u4(thread_serial_num);  // thread number
1760     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
<a name="99" id="anc99"></a>
1761     int num_frames = do_thread(thread, thread_serial_num);
1762     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1763            &quot;total number of Java frames not matched&quot;);
1764   }
1765 }
1766 
1767 
1768 // The VM operation that dumps the heap. The dump consists of the following
1769 // records:
1770 //
1771 //  HPROF_HEADER
1772 //  [HPROF_UTF8]*
1773 //  [HPROF_LOAD_CLASS]*
1774 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1775 //  [HPROF_GC_CLASS_DUMP]*
1776 //  [HPROF_HEAP_DUMP_SEGMENT]*
1777 //  HPROF_HEAP_DUMP_END
1778 //
1779 // The HPROF_TRACE records represent the stack traces where the heap dump
1780 // is generated and a &quot;dummy trace&quot; record which does not include
1781 // any frames. The dummy trace record is used to be referenced as the
1782 // unknown object alloc site.
1783 //
1784 // Each HPROF_HEAP_DUMP_SEGMENT record has a length followed by sub-records.
1785 // To allow the heap dump be generated in a single pass we remember the position
1786 // of the dump length and fix it up after all sub-records have been written.
1787 // To generate the sub-records we iterate over the heap, writing
1788 // HPROF_GC_INSTANCE_DUMP, HPROF_GC_OBJ_ARRAY_DUMP, and HPROF_GC_PRIM_ARRAY_DUMP
1789 // records as we go. Once that is done we write records for some of the GC
1790 // roots.
1791 
1792 void VM_HeapDumper::doit() {
1793 
1794   HandleMark hm;
1795   CollectedHeap* ch = Universe::heap();
1796 
1797   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1798                                  // not happen (e.g. due to GCLocker)
1799 
1800   if (_gc_before_heap_dump) {
1801     if (GCLocker::is_active()) {
1802       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1803     } else {
1804       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1805     }
1806   }
1807 
1808   // At this point we should be the only dumper active, so
1809   // the following should be safe.
1810   set_global_dumper();
1811   set_global_writer();
1812 
1813   // Write the file header - we always use 1.0.2
1814   size_t used = ch-&gt;used();
1815   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1816 
1817   // header is few bytes long - no chance to overflow int
1818   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1819   writer()-&gt;write_u1(0); // terminator
1820   writer()-&gt;write_u4(oopSize);
<a name="100" id="anc100"></a>
1821   writer()-&gt;write_u8(os::javaTimeMillis());
1822 
1823   // HPROF_UTF8 records
1824   SymbolTableDumper sym_dumper(writer());
1825   SymbolTable::symbols_do(&amp;sym_dumper);
1826 
1827   // write HPROF_LOAD_CLASS records
1828   {
1829     LockedClassesDo locked_load_classes(&amp;do_load_class);
1830     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1831   }
1832   Universe::basic_type_classes_do(&amp;do_load_class);
1833 
1834   // write HPROF_FRAME and HPROF_TRACE records
1835   // this must be called after _klass_map is built when iterating the classes above.
1836   dump_stack_traces();
1837 
<a name="101" id="anc101"></a><span class="line-removed">1838   // write HPROF_HEAP_DUMP_SEGMENT</span>
<span class="line-removed">1839   DumperSupport::write_dump_header(writer());</span>
<span class="line-removed">1840 </span>
1841   // Writes HPROF_GC_CLASS_DUMP records
1842   {
1843     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1844     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1845   }
1846   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
<a name="102" id="anc102"></a><span class="line-removed">1847   check_segment_length();</span>
1848 
1849   // writes HPROF_GC_INSTANCE_DUMP records.
1850   // After each sub-record is written check_segment_length will be invoked
1851   // to check if the current segment exceeds a threshold. If so, a new
1852   // segment is started.
1853   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1854   // of the heap dump.
1855   HeapObjectDumper obj_dumper(this, writer());
<a name="103" id="anc103"></a><span class="line-modified">1856   Universe::heap()-&gt;safe_object_iterate(&amp;obj_dumper);</span>
1857 
1858   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1859   do_threads();
<a name="104" id="anc104"></a><span class="line-removed">1860   check_segment_length();</span>
1861 
1862   // HPROF_GC_ROOT_MONITOR_USED
1863   MonitorUsedDumper mon_dumper(writer());
1864   ObjectSynchronizer::oops_do(&amp;mon_dumper);
<a name="105" id="anc105"></a><span class="line-removed">1865   check_segment_length();</span>
1866 
1867   // HPROF_GC_ROOT_JNI_GLOBAL
1868   JNIGlobalsDumper jni_dumper(writer());
1869   JNIHandles::oops_do(&amp;jni_dumper);
1870   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1871                                    // for things like preallocated throwable backtraces
<a name="106" id="anc106"></a><span class="line-removed">1872   check_segment_length();</span>
1873 
1874   // HPROF_GC_ROOT_STICKY_CLASS
1875   // These should be classes in the NULL class loader data, and not all classes
1876   // if !ClassUnloading
1877   StickyClassDumper class_dumper(writer());
1878   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1879 
<a name="107" id="anc107"></a><span class="line-modified">1880   // fixes up the length of the dump record and writes the HPROF_HEAP_DUMP_END record.</span>
1881   DumperSupport::end_of_dump(writer());
1882 
1883   // Now we clear the global variables, so that a future dumper might run.
1884   clear_global_dumper();
1885   clear_global_writer();
1886 }
1887 
1888 void VM_HeapDumper::dump_stack_traces() {
1889   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1890   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1891   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1892   writer()-&gt;write_u4(0);                    // thread number
1893   writer()-&gt;write_u4(0);                    // frame count
1894 
1895   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1896   int frame_serial_num = 0;
1897   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1898     oop threadObj = thread-&gt;threadObj();
1899     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1900       // dump thread stack trace
1901       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1902       stack_trace-&gt;dump_stack_at_safepoint(-1);
1903       _stack_traces[_num_threads++] = stack_trace;
1904 
1905       // write HPROF_FRAME records for this thread&#39;s stack trace
1906       int depth = stack_trace-&gt;get_stack_depth();
1907       int thread_frame_start = frame_serial_num;
1908       int extra_frames = 0;
1909       // write fake frame that makes it look like the thread, which caused OOME,
1910       // is in the OutOfMemoryError zero-parameter constructor
1911       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1912         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1913         // the class serial number starts from 1
1914         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1915         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1916                                         _oome_constructor, 0);
1917         extra_frames++;
1918       }
1919       for (int j=0; j &lt; depth; j++) {
1920         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
1921         Method* m = frame-&gt;method();
1922         int class_serial_num = _klass_map-&gt;find(m-&gt;method_holder());
1923         // the class serial number starts from 1
1924         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1925         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1926       }
1927       depth += extra_frames;
1928 
1929       // write HPROF_TRACE record for one thread
1930       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1931       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1932       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1933       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1934       writer()-&gt;write_u4(depth);                 // frame count
1935       for (int j=1; j &lt;= depth; j++) {
1936         writer()-&gt;write_id(thread_frame_start + j);
1937       }
1938     }
1939   }
1940 }
1941 
1942 // dump the heap to given path.
<a name="108" id="anc108"></a><span class="line-modified">1943 int HeapDumper::dump(const char* path) {</span>
1944   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1945 
1946   // print message in interactive case
<a name="109" id="anc109"></a><span class="line-modified">1947   if (print_to_tty()) {</span>
<span class="line-modified">1948     tty-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);</span>
1949     timer()-&gt;start();
1950   }
1951 
<a name="110" id="anc110"></a>


1952   // create the dump writer. If the file can be opened then bail
1953   DumpWriter writer(path);
<a name="111" id="anc111"></a><span class="line-modified">1954   if (!writer.is_open()) {</span>
1955     set_error(writer.error());
<a name="112" id="anc112"></a><span class="line-modified">1956     if (print_to_tty()) {</span>
<span class="line-modified">1957       tty-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,</span>
1958         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1959     }
1960     return -1;
1961   }
1962 
1963   // generate the dump
1964   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1965   if (Thread::current()-&gt;is_VM_thread()) {
1966     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1967     dumper.doit();
1968   } else {
1969     VMThread::execute(&amp;dumper);
1970   }
1971 
1972   // close dump file and record any error that the writer may have encountered
1973   writer.close();
1974   set_error(writer.error());
1975 
<a name="113" id="anc113"></a>








1976   // print message in interactive case
<a name="114" id="anc114"></a><span class="line-modified">1977   if (print_to_tty()) {</span>
1978     timer()-&gt;stop();
1979     if (error() == NULL) {
<a name="115" id="anc115"></a><span class="line-modified">1980       tty-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,</span>
1981                     writer.bytes_written(), timer()-&gt;seconds());
1982     } else {
<a name="116" id="anc116"></a><span class="line-modified">1983       tty-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());</span>
1984     }
1985   }
1986 
1987   return (writer.error() == NULL) ? 0 : -1;
1988 }
1989 
1990 // stop timer (if still active), and free any error string we might be holding
1991 HeapDumper::~HeapDumper() {
1992   if (timer()-&gt;is_active()) {
1993     timer()-&gt;stop();
1994   }
1995   set_error(NULL);
1996 }
1997 
1998 
1999 // returns the error string (resource allocated), or NULL
2000 char* HeapDumper::error_as_C_string() const {
2001   if (error() != NULL) {
2002     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2003     strcpy(str, error());
2004     return str;
2005   } else {
2006     return NULL;
2007   }
2008 }
2009 
2010 // set the error string
2011 void HeapDumper::set_error(char* error) {
2012   if (_error != NULL) {
2013     os::free(_error);
2014   }
2015   if (error == NULL) {
2016     _error = NULL;
2017   } else {
2018     _error = os::strdup(error);
2019     assert(_error != NULL, &quot;allocation failure&quot;);
2020   }
2021 }
2022 
2023 // Called by out-of-memory error reporting by a single Java thread
2024 // outside of a JVM safepoint
2025 void HeapDumper::dump_heap_from_oome() {
2026   HeapDumper::dump_heap(true);
2027 }
2028 
2029 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2030 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2031 // callers are strictly serialized and guaranteed not to interfere below. For more
2032 // general use, however, this method will need modification to prevent
2033 // inteference when updating the static variables base_path and dump_file_seq below.
2034 void HeapDumper::dump_heap() {
2035   HeapDumper::dump_heap(false);
2036 }
2037 
2038 void HeapDumper::dump_heap(bool oome) {
2039   static char base_path[JVM_MAXPATHLEN] = {&#39;\0&#39;};
2040   static uint dump_file_seq = 0;
2041   char* my_path;
2042   const int max_digit_chars = 20;
2043 
2044   const char* dump_file_name = &quot;java_pid&quot;;
2045   const char* dump_file_ext  = &quot;.hprof&quot;;
2046 
2047   // The dump file defaults to java_pid&lt;pid&gt;.hprof in the current working
2048   // directory. HeapDumpPath=&lt;file&gt; can be used to specify an alternative
2049   // dump file name or a directory where dump file is created.
2050   if (dump_file_seq == 0) { // first time in, we initialize base_path
2051     // Calculate potentially longest base path and check if we have enough
2052     // allocated statically.
2053     const size_t total_length =
2054                       (HeapDumpPath == NULL ? 0 : strlen(HeapDumpPath)) +
2055                       strlen(os::file_separator()) + max_digit_chars +
2056                       strlen(dump_file_name) + strlen(dump_file_ext) + 1;
2057     if (total_length &gt; sizeof(base_path)) {
2058       warning(&quot;Cannot create heap dump file.  HeapDumpPath is too long.&quot;);
2059       return;
2060     }
2061 
2062     bool use_default_filename = true;
2063     if (HeapDumpPath == NULL || HeapDumpPath[0] == &#39;\0&#39;) {
2064       // HeapDumpPath=&lt;file&gt; not specified
2065     } else {
2066       strcpy(base_path, HeapDumpPath);
2067       // check if the path is a directory (must exist)
2068       DIR* dir = os::opendir(base_path);
2069       if (dir == NULL) {
2070         use_default_filename = false;
2071       } else {
2072         // HeapDumpPath specified a directory. We append a file separator
2073         // (if needed).
2074         os::closedir(dir);
2075         size_t fs_len = strlen(os::file_separator());
2076         if (strlen(base_path) &gt;= fs_len) {
2077           char* end = base_path;
2078           end += (strlen(base_path) - fs_len);
2079           if (strcmp(end, os::file_separator()) != 0) {
2080             strcat(base_path, os::file_separator());
2081           }
2082         }
2083       }
2084     }
2085     // If HeapDumpPath wasn&#39;t a file name then we append the default name
2086     if (use_default_filename) {
2087       const size_t dlen = strlen(base_path);  // if heap dump dir specified
2088       jio_snprintf(&amp;base_path[dlen], sizeof(base_path)-dlen, &quot;%s%d%s&quot;,
2089                    dump_file_name, os::current_process_id(), dump_file_ext);
2090     }
2091     const size_t len = strlen(base_path) + 1;
2092     my_path = (char*)os::malloc(len, mtInternal);
2093     if (my_path == NULL) {
2094       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2095       return;
2096     }
2097     strncpy(my_path, base_path, len);
2098   } else {
2099     // Append a sequence number id for dumps following the first
2100     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2101     my_path = (char*)os::malloc(len, mtInternal);
2102     if (my_path == NULL) {
2103       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2104       return;
2105     }
2106     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2107   }
2108   dump_file_seq++;   // increment seq number for next time we dump
2109 
2110   HeapDumper dumper(false /* no GC before heap dump */,
<a name="117" id="anc117"></a><span class="line-removed">2111                     true  /* send to tty */,</span>
2112                     oome  /* pass along out-of-memory-error flag */);
<a name="118" id="anc118"></a><span class="line-modified">2113   dumper.dump(my_path);</span>
2114   os::free(my_path);
2115 }
<a name="119" id="anc119"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="119" type="hidden" />
</body>
</html>
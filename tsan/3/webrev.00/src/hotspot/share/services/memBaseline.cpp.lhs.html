<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/memBaseline.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/safepoint.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;services/memBaseline.hpp&quot;
 31 #include &quot;services/memTracker.hpp&quot;
 32 
 33 /*
 34  * Sizes are sorted in descenting order for reporting
 35  */
 36 int compare_malloc_size(const MallocSite&amp; s1, const MallocSite&amp; s2) {
 37   if (s1.size() == s2.size()) {
 38     return 0;
 39   } else if (s1.size() &gt; s2.size()) {
 40     return -1;
 41   } else {
 42     return 1;
 43   }
 44 }
 45 
 46 
 47 int compare_virtual_memory_size(const VirtualMemoryAllocationSite&amp; s1,
 48   const VirtualMemoryAllocationSite&amp; s2) {
 49   if (s1.reserved() == s2.reserved()) {
 50     return 0;
 51   } else if (s1.reserved() &gt; s2.reserved()) {
 52     return -1;
 53   } else {
 54     return 1;
 55   }
 56 }
 57 
 58 // Sort into allocation site addresses order for baseline comparison
 59 int compare_malloc_site(const MallocSite&amp; s1, const MallocSite&amp; s2) {
 60   return s1.call_stack()-&gt;compare(*s2.call_stack());
 61 }
 62 
 63 // Sort into allocation site addresses and memory type order for baseline comparison
 64 int compare_malloc_site_and_type(const MallocSite&amp; s1, const MallocSite&amp; s2) {
 65   int res = compare_malloc_site(s1, s2);
 66   if (res == 0) {
 67     res = (int)(s1.flag() - s2.flag());
 68   }
 69 
 70   return res;
 71 }
 72 
 73 int compare_virtual_memory_site(const VirtualMemoryAllocationSite&amp; s1,
 74   const VirtualMemoryAllocationSite&amp; s2) {
 75   return s1.call_stack()-&gt;compare(*s2.call_stack());
 76 }
 77 
 78 /*
 79  * Walker to walk malloc allocation site table
 80  */
 81 class MallocAllocationSiteWalker : public MallocSiteWalker {
 82  private:
 83   SortedLinkedList&lt;MallocSite, compare_malloc_size&gt; _malloc_sites;
 84   size_t         _count;
 85 
 86   // Entries in MallocSiteTable with size = 0 and count = 0,
 87   // when the malloc site is not longer there.
 88  public:
 89   MallocAllocationSiteWalker() : _count(0) { }
 90 
 91   inline size_t count() const { return _count; }
 92 
 93   LinkedList&lt;MallocSite&gt;* malloc_sites() {
 94     return &amp;_malloc_sites;
 95   }
 96 
 97   bool do_malloc_site(const MallocSite* site) {
 98     if (site-&gt;size() &gt;= MemBaseline::SIZE_THRESHOLD) {
 99       if (_malloc_sites.add(*site) != NULL) {
100         _count++;
101         return true;
102       } else {
103         return false;  // OOM
104       }
105     } else {
106       // malloc site does not meet threshold, ignore and continue
107       return true;
108     }
109   }
110 };
111 
112 // Compare virtual memory region&#39;s base address
113 int compare_virtual_memory_base(const ReservedMemoryRegion&amp; r1, const ReservedMemoryRegion&amp; r2) {
114   return r1.compare(r2);
115 }
116 
117 // Walk all virtual memory regions for baselining
118 class VirtualMemoryAllocationWalker : public VirtualMemoryWalker {
119  private:
120   SortedLinkedList&lt;ReservedMemoryRegion, compare_virtual_memory_base&gt;
121                 _virtual_memory_regions;
122   size_t        _count;
123 
124  public:
125   VirtualMemoryAllocationWalker() : _count(0) { }
126 
127   bool do_allocation_site(const ReservedMemoryRegion* rgn)  {
128     if (rgn-&gt;size() &gt;= MemBaseline::SIZE_THRESHOLD) {
129       if (_virtual_memory_regions.add(*rgn) != NULL) {
130         _count ++;
131         return true;
132       } else {
133         return false;
134       }
135     }
136     return true;
137   }
138 
139   LinkedList&lt;ReservedMemoryRegion&gt;* virtual_memory_allocations() {
140     return &amp;_virtual_memory_regions;
141   }
142 };
143 
144 
145 bool MemBaseline::baseline_summary() {
146   MallocMemorySummary::snapshot(&amp;_malloc_memory_snapshot);
147   VirtualMemorySummary::snapshot(&amp;_virtual_memory_snapshot);
148   MetaspaceSnapshot::snapshot(_metaspace_snapshot);
149   return true;
150 }
151 
152 bool MemBaseline::baseline_allocation_sites() {
153   // Malloc allocation sites
154   MallocAllocationSiteWalker malloc_walker;
155   if (!MallocSiteTable::walk_malloc_site(&amp;malloc_walker)) {
156     return false;
157   }
158 
<a name="1" id="anc1"></a>




159   _malloc_sites.move(malloc_walker.malloc_sites());
160   // The malloc sites are collected in size order
161   _malloc_sites_order = by_size;
162 
163   // Virtual memory allocation sites
164   VirtualMemoryAllocationWalker virtual_memory_walker;
165   if (!VirtualMemoryTracker::walk_virtual_memory(&amp;virtual_memory_walker)) {
166     return false;
167   }
168 
169   // Virtual memory allocations are collected in call stack order
170   _virtual_memory_allocations.move(virtual_memory_walker.virtual_memory_allocations());
171 
172   if (!aggregate_virtual_memory_allocation_sites()) {
173     return false;
174   }
175   // Virtual memory allocation sites are aggregrated in call stack order
176   _virtual_memory_sites_order = by_address;
177 
178   return true;
179 }
180 
181 bool MemBaseline::baseline(bool summaryOnly) {
182   reset();
183 
184   _instance_class_count = ClassLoaderDataGraph::num_instance_classes();
185   _array_class_count = ClassLoaderDataGraph::num_array_classes();
186 
187   if (!baseline_summary()) {
188     return false;
189   }
190 
191   _baseline_type = Summary_baselined;
192 
193   // baseline details
194   if (!summaryOnly &amp;&amp;
195       MemTracker::tracking_level() == NMT_detail) {
196     baseline_allocation_sites();
197     _baseline_type = Detail_baselined;
198   }
199 
200   return true;
201 }
202 
203 int compare_allocation_site(const VirtualMemoryAllocationSite&amp; s1,
204   const VirtualMemoryAllocationSite&amp; s2) {
205   return s1.call_stack()-&gt;compare(*s2.call_stack());
206 }
207 
208 bool MemBaseline::aggregate_virtual_memory_allocation_sites() {
209   SortedLinkedList&lt;VirtualMemoryAllocationSite, compare_allocation_site&gt; allocation_sites;
210 
211   VirtualMemoryAllocationIterator itr = virtual_memory_allocations();
212   const ReservedMemoryRegion* rgn;
213   VirtualMemoryAllocationSite* site;
214   while ((rgn = itr.next()) != NULL) {
215     VirtualMemoryAllocationSite tmp(*rgn-&gt;call_stack(), rgn-&gt;flag());
216     site = allocation_sites.find(tmp);
217     if (site == NULL) {
218       LinkedListNode&lt;VirtualMemoryAllocationSite&gt;* node =
219         allocation_sites.add(tmp);
220       if (node == NULL) return false;
221       site = node-&gt;data();
222     }
223     site-&gt;reserve_memory(rgn-&gt;size());
224     site-&gt;commit_memory(rgn-&gt;committed_size());
225   }
226 
227   _virtual_memory_sites.move(&amp;allocation_sites);
228   return true;
229 }
230 
231 MallocSiteIterator MemBaseline::malloc_sites(SortingOrder order) {
232   assert(!_malloc_sites.is_empty(), &quot;Not detail baseline&quot;);
233   switch(order) {
234     case by_size:
235       malloc_sites_to_size_order();
236       break;
237     case by_site:
238       malloc_sites_to_allocation_site_order();
239       break;
240     case by_site_and_type:
241       malloc_sites_to_allocation_site_and_type_order();
242       break;
243     case by_address:
244     default:
245       ShouldNotReachHere();
246   }
247   return MallocSiteIterator(_malloc_sites.head());
248 }
249 
250 VirtualMemorySiteIterator MemBaseline::virtual_memory_sites(SortingOrder order) {
251   assert(!_virtual_memory_sites.is_empty(), &quot;Not detail baseline&quot;);
252   switch(order) {
253     case by_size:
254       virtual_memory_sites_to_size_order();
255       break;
256     case by_site:
257       virtual_memory_sites_to_reservation_site_order();
258       break;
259     case by_address:
260     default:
261       ShouldNotReachHere();
262   }
263   return VirtualMemorySiteIterator(_virtual_memory_sites.head());
264 }
265 
266 
267 // Sorting allocations sites in different orders
268 void MemBaseline::malloc_sites_to_size_order() {
269   if (_malloc_sites_order != by_size) {
270     SortedLinkedList&lt;MallocSite, compare_malloc_size&gt; tmp;
271 
272     // Add malloc sites to sorted linked list to sort into size order
273     tmp.move(&amp;_malloc_sites);
274     _malloc_sites.set_head(tmp.head());
275     tmp.set_head(NULL);
276     _malloc_sites_order = by_size;
277   }
278 }
279 
280 void MemBaseline::malloc_sites_to_allocation_site_order() {
281   if (_malloc_sites_order != by_site &amp;&amp; _malloc_sites_order != by_site_and_type) {
282     SortedLinkedList&lt;MallocSite, compare_malloc_site&gt; tmp;
283     // Add malloc sites to sorted linked list to sort into site (address) order
284     tmp.move(&amp;_malloc_sites);
285     _malloc_sites.set_head(tmp.head());
286     tmp.set_head(NULL);
287     _malloc_sites_order = by_site;
288   }
289 }
290 
291 void MemBaseline::malloc_sites_to_allocation_site_and_type_order() {
292   if (_malloc_sites_order != by_site_and_type) {
293     SortedLinkedList&lt;MallocSite, compare_malloc_site_and_type&gt; tmp;
294     // Add malloc sites to sorted linked list to sort into site (address) order
295     tmp.move(&amp;_malloc_sites);
296     _malloc_sites.set_head(tmp.head());
297     tmp.set_head(NULL);
298     _malloc_sites_order = by_site_and_type;
299   }
300 }
301 
302 void MemBaseline::virtual_memory_sites_to_size_order() {
303   if (_virtual_memory_sites_order != by_size) {
304     SortedLinkedList&lt;VirtualMemoryAllocationSite, compare_virtual_memory_size&gt; tmp;
305 
306     tmp.move(&amp;_virtual_memory_sites);
307 
308     _virtual_memory_sites.set_head(tmp.head());
309     tmp.set_head(NULL);
310     _virtual_memory_sites_order = by_size;
311   }
312 }
313 
314 void MemBaseline::virtual_memory_sites_to_reservation_site_order() {
315   if (_virtual_memory_sites_order != by_size) {
316     SortedLinkedList&lt;VirtualMemoryAllocationSite, compare_virtual_memory_site&gt; tmp;
317 
318     tmp.move(&amp;_virtual_memory_sites);
319 
320     _virtual_memory_sites.set_head(tmp.head());
321     tmp.set_head(NULL);
322 
323     _virtual_memory_sites_order = by_size;
324   }
325 }
326 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/dtraceAttacher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;runtime/deoptimization.hpp&quot;
 29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 30 #include &quot;runtime/vmThread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;services/dtraceAttacher.hpp&quot;
 33 
 34 #ifdef SOLARIS
 35 
 36 class VM_DeoptimizeTheWorld : public VM_Operation {
 37  public:
 38   VMOp_Type type() const {
 39     return VMOp_DeoptimizeTheWorld;
 40   }
 41   void doit() {
 42     CodeCache::mark_all_nmethods_for_deoptimization();
 43     ResourceMark rm;
 44     DeoptimizationMarker dm;
 45     // Deoptimize all activations depending on marked methods
 46     Deoptimization::deoptimize_dependents();
 47 
 48     // Mark the dependent methods non entrant
 49     CodeCache::make_marked_nmethods_not_entrant();
 50   }
 51 };
 52 
 53 static void set_bool_flag(const char* flag, bool value) {
 54   JVMFlag::boolAtPut((char*)flag, strlen(flag), &amp;value,
 55                               JVMFlag::ATTACH_ON_DEMAND);
 56 }
 57 
 58 // Enable only the &quot;fine grained&quot; flags. Do *not* touch
 59 // the overall &quot;ExtendedDTraceProbes&quot; flag.
 60 void DTrace::enable_dprobes(int probes) {
 61   bool changed = false;
 62   if (!DTraceAllocProbes &amp;&amp; (probes &amp; DTRACE_ALLOC_PROBES)) {
 63     set_bool_flag(&quot;DTraceAllocProbes&quot;, true);
 64     changed = true;
 65   }
 66   if (!DTraceMethodProbes &amp;&amp; (probes &amp; DTRACE_METHOD_PROBES)) {
 67     set_bool_flag(&quot;DTraceMethodProbes&quot;, true);
 68     changed = true;
 69   }
 70   if (!DTraceMonitorProbes &amp;&amp; (probes &amp; DTRACE_MONITOR_PROBES)) {
 71     set_bool_flag(&quot;DTraceMonitorProbes&quot;, true);
 72     changed = true;
 73   }
 74 
 75   if (changed) {
 76     // one or more flags changed, need to deoptimize
 77     VM_DeoptimizeTheWorld op;
 78     VMThread::execute(&amp;op);
 79   }
 80 }
 81 
 82 // Disable only the &quot;fine grained&quot; flags. Do *not* touch
 83 // the overall &quot;ExtendedDTraceProbes&quot; flag.
 84 void DTrace::disable_dprobes(int probes) {
 85   bool changed = false;
 86   if (DTraceAllocProbes &amp;&amp; (probes &amp; DTRACE_ALLOC_PROBES)) {
 87     set_bool_flag(&quot;DTraceAllocProbes&quot;, false);
 88     changed = true;
 89   }
 90   if (DTraceMethodProbes &amp;&amp; (probes &amp; DTRACE_METHOD_PROBES)) {
 91     set_bool_flag(&quot;DTraceMethodProbes&quot;, false);
 92     changed = true;
 93   }
 94   if (DTraceMonitorProbes &amp;&amp; (probes &amp; DTRACE_MONITOR_PROBES)) {
 95     set_bool_flag(&quot;DTraceMonitorProbes&quot;, false);
 96     changed = true;
 97   }
 98   if (changed) {
 99     // one or more flags changed, need to deoptimize
100     VM_DeoptimizeTheWorld op;
101     VMThread::execute(&amp;op);
102   }
103 }
104 
105 // Do clean-up on &quot;all door clients detached&quot; event.
106 void DTrace::detach_all_clients() {
107   /*
108    * We restore the state of the fine grained flags
109    * to be consistent with overall ExtendedDTraceProbes.
110    * This way, we will honour command line setting or the
111    * last explicit modification of ExtendedDTraceProbes by
112    * a call to set_extended_dprobes.
113    */
114   if (ExtendedDTraceProbes) {
115     enable_dprobes(DTRACE_ALL_PROBES);
116   } else {
117     disable_dprobes(DTRACE_ALL_PROBES);
118   }
119 }
120 
121 void DTrace::set_extended_dprobes(bool flag) {
122   // explicit setting of ExtendedDTraceProbes flag
123   set_bool_flag(&quot;ExtendedDTraceProbes&quot;, flag);
124 
125   // make sure that the fine grained flags reflect the change.
126   if (flag) {
127     enable_dprobes(DTRACE_ALL_PROBES);
128   } else {
129     /*
130      * FIXME: Revisit this: currently all-client-detach detection
131      * does not work and hence disabled. The following scheme does
132      * not work. So, we have to disable fine-grained flags here.
133      *
134      * disable_dprobes call has to be delayed till next &quot;detach all &quot;event.
135      * This is to be  done so that concurrent DTrace clients that may
136      * have enabled one or more fine grained dprobes and may be running
137      * still. On &quot;detach all&quot; clients event, we would sync ExtendedDTraceProbes
138      * with  fine grained flags which would take care of disabling fine grained flags.
139      */
140     disable_dprobes(DTRACE_ALL_PROBES);
141   }
142 }
143 
144 void DTrace::set_monitor_dprobes(bool flag) {
145   // explicit setting of DTraceMonitorProbes flag
146   set_bool_flag(&quot;DTraceMonitorProbes&quot;, flag);
147 }
148 
149 #endif /* SOLARIS */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/diagnosticCommand.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
 26 #define SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
 27 
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/symbolTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;runtime/arguments.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/vmThread.hpp&quot;
 35 #include &quot;services/diagnosticArgument.hpp&quot;
 36 #include &quot;services/diagnosticCommand.hpp&quot;
 37 #include &quot;services/diagnosticFramework.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 #include &quot;utilities/ostream.hpp&quot;
 40 #include &quot;oops/method.hpp&quot;
 41 
 42 class HelpDCmd : public DCmdWithParser {
 43 protected:
 44   DCmdArgument&lt;bool&gt; _all;
 45   DCmdArgument&lt;char*&gt; _cmd;
 46 public:
 47   HelpDCmd(outputStream* output, bool heap);
 48   static const char* name() { return &quot;help&quot;; }
 49   static const char* description() {
 50     return &quot;For more information about a specific command use &#39;help &lt;command&gt;&#39;. &quot;
 51            &quot;With no argument this will show a list of available commands. &quot;
 52            &quot;&#39;help all&#39; will show help for all commands.&quot;;
 53   }
 54   static const char* impact() { return &quot;Low&quot;; }
 55   static int num_arguments();
 56   virtual void execute(DCmdSource source, TRAPS);
 57 };
 58 
 59 class VersionDCmd : public DCmd {
 60 public:
 61   VersionDCmd(outputStream* output, bool heap) : DCmd(output,heap) { }
 62   static const char* name() { return &quot;VM.version&quot;; }
 63   static const char* description() {
 64     return &quot;Print JVM version information.&quot;;
 65   }
 66   static const char* impact() { return &quot;Low&quot;; }
 67   static const JavaPermission permission() {
 68     JavaPermission p = {&quot;java.util.PropertyPermission&quot;,
 69                         &quot;java.vm.version&quot;, &quot;read&quot;};
 70     return p;
 71   }
 72   static int num_arguments() { return 0; }
 73   virtual void execute(DCmdSource source, TRAPS);
 74 };
 75 
 76 class CommandLineDCmd : public DCmd {
 77 public:
 78   CommandLineDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
 79   static const char* name() { return &quot;VM.command_line&quot;; }
 80   static const char* description() {
 81     return &quot;Print the command line used to start this VM instance.&quot;;
 82   }
 83   static const char* impact() { return &quot;Low&quot;; }
 84   static const JavaPermission permission() {
 85     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
 86                         &quot;monitor&quot;, NULL};
 87     return p;
 88   }
 89   static int num_arguments() { return 0; }
 90   virtual void execute(DCmdSource source, TRAPS) {
 91     Arguments::print_on(_output);
 92   }
 93 };
 94 
 95 // See also: get_system_properties in attachListener.cpp
 96 class PrintSystemPropertiesDCmd : public DCmd {
 97 public:
 98   PrintSystemPropertiesDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
 99     static const char* name() { return &quot;VM.system_properties&quot;; }
100     static const char* description() {
101       return &quot;Print system properties.&quot;;
102     }
103     static const char* impact() {
104       return &quot;Low&quot;;
105     }
106     static const JavaPermission permission() {
107       JavaPermission p = {&quot;java.util.PropertyPermission&quot;,
108                           &quot;*&quot;, &quot;read&quot;};
109       return p;
110     }
111     static int num_arguments() { return 0; }
112     virtual void execute(DCmdSource source, TRAPS);
113 };
114 
115 // See also: print_flag in attachListener.cpp
116 class PrintVMFlagsDCmd : public DCmdWithParser {
117 protected:
118   DCmdArgument&lt;bool&gt; _all;
119 public:
120   PrintVMFlagsDCmd(outputStream* output, bool heap);
121   static const char* name() { return &quot;VM.flags&quot;; }
122   static const char* description() {
123     return &quot;Print VM flag options and their current values.&quot;;
124   }
125   static const char* impact() {
126     return &quot;Low&quot;;
127   }
128   static const JavaPermission permission() {
129     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
130                         &quot;monitor&quot;, NULL};
131     return p;
132   }
133   static int num_arguments();
134   virtual void execute(DCmdSource source, TRAPS);
135 };
136 
137 class SetVMFlagDCmd : public DCmdWithParser {
138 protected:
139   DCmdArgument&lt;char*&gt; _flag;
140   DCmdArgument&lt;char*&gt; _value;
141 
142 public:
143   SetVMFlagDCmd(outputStream* output, bool heap);
144   static const char* name() { return &quot;VM.set_flag&quot;; }
145   static const char* description() {
146     return &quot;Sets VM flag option using the provided value.&quot;;
147   }
148   static const char* impact() {
149     return &quot;Low&quot;;
150   }
151   static const JavaPermission permission() {
152     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
153                         &quot;control&quot;, NULL};
154     return p;
155   }
156   static int num_arguments();
157   virtual void execute(DCmdSource source, TRAPS);
158 };
159 
160 class JVMTIDataDumpDCmd : public DCmd {
161 public:
162   JVMTIDataDumpDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
163   static const char* name() { return &quot;JVMTI.data_dump&quot;; }
164   static const char* description() {
165     return &quot;Signal the JVM to do a data-dump request for JVMTI.&quot;;
166   }
167   static const char* impact() {
168     return &quot;High&quot;;
169   }
170   static const JavaPermission permission() {
171     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
172                         &quot;monitor&quot;, NULL};
173     return p;
174   }
175   static int num_arguments() { return 0; }
176   virtual void execute(DCmdSource source, TRAPS);
177 };
178 
179 #if INCLUDE_SERVICES
180 #if INCLUDE_JVMTI
181 class JVMTIAgentLoadDCmd : public DCmdWithParser {
182 protected:
183   DCmdArgument&lt;char*&gt; _libpath;
184   DCmdArgument&lt;char*&gt; _option;
185 public:
186   JVMTIAgentLoadDCmd(outputStream* output, bool heap);
187   static const char* name() { return &quot;JVMTI.agent_load&quot;; }
188   static const char* description() {
189     return &quot;Load JVMTI native agent.&quot;;
190   }
191   static const char* impact() { return &quot;Low&quot;; }
192   static const JavaPermission permission() {
193     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
194                         &quot;control&quot;, NULL};
195     return p;
196   }
197   static int num_arguments();
198   virtual void execute(DCmdSource source, TRAPS);
199 };
200 #endif // INCLUDE_JVMTI
201 #endif // INCLUDE_SERVICES
202 
203 class VMDynamicLibrariesDCmd : public DCmd {
204 public:
205   VMDynamicLibrariesDCmd(outputStream* output, bool heap);
206   static const char* name() {
207     return &quot;VM.dynlibs&quot;;
208   }
209   static const char* description() {
210     return &quot;Print loaded dynamic libraries.&quot;;
211   }
212   static const char* impact() {
213     return &quot;Low&quot;;
214   }
215   static const JavaPermission permission() {
216     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
217                         &quot;monitor&quot;, NULL};
218     return p;
219   }
220   static int num_arguments() {
221     return 0;
222   };
223   virtual void execute(DCmdSource source, TRAPS);
224 };
225 
226 class VMUptimeDCmd : public DCmdWithParser {
227 protected:
228   DCmdArgument&lt;bool&gt; _date;
229 public:
230   VMUptimeDCmd(outputStream* output, bool heap);
231   static const char* name() { return &quot;VM.uptime&quot;; }
232   static const char* description() {
233     return &quot;Print VM uptime.&quot;;
234   }
235   static const char* impact() {
236     return &quot;Low&quot;;
237   }
238   static int num_arguments();
239   virtual void execute(DCmdSource source, TRAPS);
240 };
241 
242 class VMInfoDCmd : public DCmd {
243 public:
244   VMInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
245   static const char* name() { return &quot;VM.info&quot;; }
246   static const char* description() {
247     return &quot;Print information about JVM environment and status.&quot;;
248   }
249   static const char* impact() { return &quot;Low&quot;; }
250   static const JavaPermission permission() {
251     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
252                         &quot;monitor&quot;, NULL};
253     return p;
254   }
255   static int num_arguments() { return 0; }
256   virtual void execute(DCmdSource source, TRAPS);
257 };
258 
259 class SystemGCDCmd : public DCmd {
260 public:
261   SystemGCDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
262     static const char* name() { return &quot;GC.run&quot;; }
263     static const char* description() {
264       return &quot;Call java.lang.System.gc().&quot;;
265     }
266     static const char* impact() {
267       return &quot;Medium: Depends on Java heap size and content.&quot;;
268     }
269     static int num_arguments() { return 0; }
270     virtual void execute(DCmdSource source, TRAPS);
271 };
272 
273 class RunFinalizationDCmd : public DCmd {
274 public:
275   RunFinalizationDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
276     static const char* name() { return &quot;GC.run_finalization&quot;; }
277     static const char* description() {
278       return &quot;Call java.lang.System.runFinalization().&quot;;
279     }
280     static const char* impact() {
281       return &quot;Medium: Depends on Java content.&quot;;
282     }
283     static int num_arguments() { return 0; }
284     virtual void execute(DCmdSource source, TRAPS);
285 };
286 
287 class HeapInfoDCmd : public DCmd {
288 public:
289   HeapInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
290   static const char* name() { return &quot;GC.heap_info&quot;; }
291   static const char* description() {
292     return &quot;Provide generic Java heap information.&quot;;
293   }
294   static const char* impact() {
295     return &quot;Medium&quot;;
296   }
297   static int num_arguments() { return 0; }
298   static const JavaPermission permission() {
299     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
300       &quot;monitor&quot;, NULL};
301       return p;
302   }
303 
304   virtual void execute(DCmdSource source, TRAPS);
305 };
306 
307 class FinalizerInfoDCmd : public DCmd {
308 public:
309   FinalizerInfoDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
310   static const char* name() { return &quot;GC.finalizer_info&quot;; }
311   static const char* description() {
312     return &quot;Provide information about Java finalization queue.&quot;;
313   }
314   static const char* impact() {
315     return &quot;Medium&quot;;
316   }
317   static int num_arguments() { return 0; }
318   static const JavaPermission permission() {
319     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
320       &quot;monitor&quot;, NULL};
321       return p;
322   }
323 
324   virtual void execute(DCmdSource source, TRAPS);
325 };
326 
327 #if INCLUDE_SERVICES   // Heap dumping supported
328 // See also: dump_heap in attachListener.cpp
329 class HeapDumpDCmd : public DCmdWithParser {
330 protected:
331   DCmdArgument&lt;char*&gt; _filename;
332   DCmdArgument&lt;bool&gt;  _all;
333 public:
334   HeapDumpDCmd(outputStream* output, bool heap);
335   static const char* name() {
336     return &quot;GC.heap_dump&quot;;
337   }
338   static const char* description() {
339     return &quot;Generate a HPROF format dump of the Java heap.&quot;;
340   }
341   static const char* impact() {
342     return &quot;High: Depends on Java heap size and content. &quot;
343            &quot;Request a full GC unless the &#39;-all&#39; option is specified.&quot;;
344   }
345   static const JavaPermission permission() {
346     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
347                         &quot;monitor&quot;, NULL};
348     return p;
349   }
350   static int num_arguments();
351   virtual void execute(DCmdSource source, TRAPS);
352 };
353 #endif // INCLUDE_SERVICES
354 
355 // See also: inspectheap in attachListener.cpp
356 class ClassHistogramDCmd : public DCmdWithParser {
357 protected:
358   DCmdArgument&lt;bool&gt; _all;
359 public:
360   ClassHistogramDCmd(outputStream* output, bool heap);
361   static const char* name() {
362     return &quot;GC.class_histogram&quot;;
363   }
364   static const char* description() {
365     return &quot;Provide statistics about the Java heap usage.&quot;;
366   }
367   static const char* impact() {
368     return &quot;High: Depends on Java heap size and content.&quot;;
369   }
370   static const JavaPermission permission() {
371     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
372                         &quot;monitor&quot;, NULL};
373     return p;
374   }
375   static int num_arguments();
376   virtual void execute(DCmdSource source, TRAPS);
377 };
378 
379 class ClassStatsDCmd : public DCmdWithParser {
380 protected:
381   DCmdArgument&lt;bool&gt; _all;
382   DCmdArgument&lt;bool&gt; _csv;
383   DCmdArgument&lt;bool&gt; _help;
384   DCmdArgument&lt;char*&gt; _columns;
385 public:
386   ClassStatsDCmd(outputStream* output, bool heap);
387   static const char* name() {
388     return &quot;GC.class_stats&quot;;
389   }
390   static const char* description() {
391     return &quot;Provide statistics about Java class meta data.&quot;;
392   }
393   static const char* impact() {
394     return &quot;High: Depends on Java heap size and content.&quot;;
395   }
396   static int num_arguments();
397   virtual void execute(DCmdSource source, TRAPS);
398 };
399 
400 
401 class ClassHierarchyDCmd : public DCmdWithParser {
402 protected:
403   DCmdArgument&lt;bool&gt; _print_interfaces; // true if inherited interfaces should be printed.
404   DCmdArgument&lt;bool&gt; _print_subclasses; // true if subclasses of the specified classname should be printed.
405   DCmdArgument&lt;char*&gt; _classname; // Optional single class name whose hierarchy should be printed.
406 public:
407   ClassHierarchyDCmd(outputStream* output, bool heap);
408   static const char* name() {
409     return &quot;VM.class_hierarchy&quot;;
410   }
411   static const char* description() {
412     return &quot;Print a list of all loaded classes, indented to show the class hiearchy. &quot;
413            &quot;The name of each class is followed by the ClassLoaderData* of its ClassLoader, &quot;
414            &quot;or \&quot;null\&quot; if loaded by the bootstrap class loader.&quot;;
415   }
416   static const char* impact() {
417       return &quot;Medium: Depends on number of loaded classes.&quot;;
418   }
419   static const JavaPermission permission() {
420     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
421                         &quot;monitor&quot;, NULL};
422     return p;
423   }
424   static int num_arguments();
425   virtual void execute(DCmdSource source, TRAPS);
426 };
427 
428 class TouchedMethodsDCmd : public DCmdWithParser {
429 public:
430   TouchedMethodsDCmd(outputStream* output, bool heap);
431   static const char* name() {
432     return &quot;VM.print_touched_methods&quot;;
433   }
434   static const char* description() {
435     return &quot;Print all methods that have ever been touched during the lifetime of this JVM.&quot;;
436   }
437   static const char* impact() {
438     return &quot;Medium: Depends on Java content.&quot;;
439   }
440   static int num_arguments();
441   virtual void execute(DCmdSource source, TRAPS);
442 };
443 
444 // See also: thread_dump in attachListener.cpp
445 class ThreadDumpDCmd : public DCmdWithParser {
446 protected:
447   DCmdArgument&lt;bool&gt; _locks;
448   DCmdArgument&lt;bool&gt; _extended;
449 public:
450   ThreadDumpDCmd(outputStream* output, bool heap);
451   static const char* name() { return &quot;Thread.print&quot;; }
452   static const char* description() {
453     return &quot;Print all threads with stacktraces.&quot;;
454   }
455   static const char* impact() {
456     return &quot;Medium: Depends on the number of threads.&quot;;
457   }
458   static const JavaPermission permission() {
459     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
460                         &quot;monitor&quot;, NULL};
461     return p;
462   }
463   static int num_arguments();
464   virtual void execute(DCmdSource source, TRAPS);
465 };
466 
467 // Enhanced JMX Agent support
468 
469 class JMXStartRemoteDCmd : public DCmdWithParser {
470 
471   // Explicitly list all properties that could be
472   // passed to Agent.startRemoteManagementAgent()
473   // com.sun.management is omitted
474 
475   DCmdArgument&lt;char *&gt; _config_file;
476   DCmdArgument&lt;char *&gt; _jmxremote_host;
477   DCmdArgument&lt;char *&gt; _jmxremote_port;
478   DCmdArgument&lt;char *&gt; _jmxremote_rmi_port;
479   DCmdArgument&lt;char *&gt; _jmxremote_ssl;
480   DCmdArgument&lt;char *&gt; _jmxremote_registry_ssl;
481   DCmdArgument&lt;char *&gt; _jmxremote_authenticate;
482   DCmdArgument&lt;char *&gt; _jmxremote_password_file;
483   DCmdArgument&lt;char *&gt; _jmxremote_access_file;
484   DCmdArgument&lt;char *&gt; _jmxremote_login_config;
485   DCmdArgument&lt;char *&gt; _jmxremote_ssl_enabled_cipher_suites;
486   DCmdArgument&lt;char *&gt; _jmxremote_ssl_enabled_protocols;
487   DCmdArgument&lt;char *&gt; _jmxremote_ssl_need_client_auth;
488   DCmdArgument&lt;char *&gt; _jmxremote_ssl_config_file;
489 
490   // JDP support
491   // Keep autodiscovery char* not bool to pass true/false
492   // as property value to java level.
493   DCmdArgument&lt;char *&gt; _jmxremote_autodiscovery;
494   DCmdArgument&lt;jlong&gt;  _jdp_port;
495   DCmdArgument&lt;char *&gt; _jdp_address;
496   DCmdArgument&lt;char *&gt; _jdp_source_addr;
497   DCmdArgument&lt;jlong&gt;  _jdp_ttl;
498   DCmdArgument&lt;jlong&gt;  _jdp_pause;
499   DCmdArgument&lt;char *&gt; _jdp_name;
500 
501 public:
502   JMXStartRemoteDCmd(outputStream *output, bool heap_allocated);
503 
504   static const char *name() {
505     return &quot;ManagementAgent.start&quot;;
506   }
507 
508   static const char *description() {
509     return &quot;Start remote management agent.&quot;;
510   }
511 
512   static int num_arguments();
513 
514   virtual void execute(DCmdSource source, TRAPS);
515 
516 };
517 
518 class JMXStartLocalDCmd : public DCmd {
519 
520   // Explicitly request start of local agent,
521   // it will not be started by start dcmd
522 
523 
524 public:
525   JMXStartLocalDCmd(outputStream *output, bool heap_allocated);
526 
527   static const char *name() {
528     return &quot;ManagementAgent.start_local&quot;;
529   }
530 
531   static const char *description() {
532     return &quot;Start local management agent.&quot;;
533   }
534 
535   virtual void execute(DCmdSource source, TRAPS);
536 
537 };
538 
539 class JMXStopRemoteDCmd : public DCmd {
540 public:
541   JMXStopRemoteDCmd(outputStream *output, bool heap_allocated) :
542   DCmd(output, heap_allocated) {
543     // Do Nothing
544   }
545 
546   static const char *name() {
547     return &quot;ManagementAgent.stop&quot;;
548   }
549 
550   static const char *description() {
551     return &quot;Stop remote management agent.&quot;;
552   }
553 
554   virtual void execute(DCmdSource source, TRAPS);
555 };
556 
557 // Print the JMX system status
558 class JMXStatusDCmd : public DCmd {
559 public:
560   JMXStatusDCmd(outputStream *output, bool heap_allocated);
561 
562   static const char *name() {
563     return &quot;ManagementAgent.status&quot;;
564   }
565 
566   static const char *description() {
567     return &quot;Print the management agent status.&quot;;
568   }
569 
570   static const JavaPermission permission() {
571     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
572                         &quot;monitor&quot;, NULL};
573     return p;
574   }
575 
576   virtual void execute(DCmdSource source, TRAPS);
577 
578 };
579 
580 class CompileQueueDCmd : public DCmd {
581 public:
582   CompileQueueDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
583   static const char* name() {
584     return &quot;Compiler.queue&quot;;
585   }
586   static const char* description() {
587     return &quot;Print methods queued for compilation.&quot;;
588   }
589   static const char* impact() {
590     return &quot;Low&quot;;
591   }
592   static const JavaPermission permission() {
593     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
594                         &quot;monitor&quot;, NULL};
595     return p;
596   }
597   static int num_arguments() { return 0; }
598   virtual void execute(DCmdSource source, TRAPS);
599 };
600 
601 class CodeListDCmd : public DCmd {
602 public:
603   CodeListDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
604   static const char* name() {
605     return &quot;Compiler.codelist&quot;;
606   }
607   static const char* description() {
608     return &quot;Print all compiled methods in code cache that are alive&quot;;
609   }
610   static const char* impact() {
611     return &quot;Medium&quot;;
612   }
613   static const JavaPermission permission() {
614     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
615                         &quot;monitor&quot;, NULL};
616     return p;
617   }
618   static int num_arguments() { return 0; }
619   virtual void execute(DCmdSource source, TRAPS);
620 };
621 
622 
623 class CodeCacheDCmd : public DCmd {
624 public:
625   CodeCacheDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
626   static const char* name() {
627     return &quot;Compiler.codecache&quot;;
628   }
629   static const char* description() {
630     return &quot;Print code cache layout and bounds.&quot;;
631   }
632   static const char* impact() {
633     return &quot;Low&quot;;
634   }
635   static const JavaPermission permission() {
636     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
637                         &quot;monitor&quot;, NULL};
638     return p;
639   }
640   static int num_arguments() { return 0; }
641   virtual void execute(DCmdSource source, TRAPS);
642 };
643 
644 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
645 class CodeHeapAnalyticsDCmd : public DCmdWithParser {
646 protected:
647   DCmdArgument&lt;char*&gt; _function;
648   DCmdArgument&lt;char*&gt; _granularity;
649 public:
650   CodeHeapAnalyticsDCmd(outputStream* output, bool heap);
651   static const char* name() {
652     return &quot;Compiler.CodeHeap_Analytics&quot;;
653   }
654   static const char* description() {
655     return &quot;Print CodeHeap analytics&quot;;
656   }
657   static const char* impact() {
658     return &quot;Low: Depends on code heap size and content. &quot;
659            &quot;Holds CodeCache_lock during analysis step, usually sub-second duration.&quot;;
660   }
661   static const JavaPermission permission() {
662     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
663                         &quot;monitor&quot;, NULL};
664     return p;
665   }
666   static int num_arguments();
667   virtual void execute(DCmdSource source, TRAPS);
668 };
669 //---&lt;  END  &gt;--- CodeHeap State Analytics.
670 
671 class CompilerDirectivesPrintDCmd : public DCmd {
672 public:
673   CompilerDirectivesPrintDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
674   static const char* name() {
675     return &quot;Compiler.directives_print&quot;;
676   }
677   static const char* description() {
678     return &quot;Print all active compiler directives.&quot;;
679   }
680   static const char* impact() {
681     return &quot;Low&quot;;
682   }
683   static const JavaPermission permission() {
684     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
685                         &quot;monitor&quot;, NULL};
686     return p;
687   }
688   static int num_arguments() { return 0; }
689   virtual void execute(DCmdSource source, TRAPS);
690 };
691 
692 class CompilerDirectivesRemoveDCmd : public DCmd {
693 public:
694   CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
695   static const char* name() {
696     return &quot;Compiler.directives_remove&quot;;
697   }
698   static const char* description() {
699     return &quot;Remove latest added compiler directive.&quot;;
700   }
701   static const char* impact() {
702     return &quot;Low&quot;;
703   }
704   static const JavaPermission permission() {
705     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
706                         &quot;monitor&quot;, NULL};
707     return p;
708   }
709   static int num_arguments() { return 0; }
710   virtual void execute(DCmdSource source, TRAPS);
711 };
712 
713 class CompilerDirectivesAddDCmd : public DCmdWithParser {
714 protected:
715   DCmdArgument&lt;char*&gt; _filename;
716 public:
717   CompilerDirectivesAddDCmd(outputStream* output, bool heap);
718   static const char* name() {
719     return &quot;Compiler.directives_add&quot;;
720   }
721   static const char* description() {
722     return &quot;Add compiler directives from file.&quot;;
723   }
724   static const char* impact() {
725     return &quot;Low&quot;;
726   }
727   static const JavaPermission permission() {
728     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
729                         &quot;monitor&quot;, NULL};
730     return p;
731   }
732   static int num_arguments();
733   virtual void execute(DCmdSource source, TRAPS);
734 };
735 
736 class CompilerDirectivesClearDCmd : public DCmd {
737 public:
738   CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}
739   static const char* name() {
740     return &quot;Compiler.directives_clear&quot;;
741   }
742   static const char* description() {
743     return &quot;Remove all compiler directives.&quot;;
744   }
745   static const char* impact() {
746     return &quot;Low&quot;;
747   }
748   static const JavaPermission permission() {
749     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
750                         &quot;monitor&quot;, NULL};
751     return p;
752   }
753   static int num_arguments() { return 0; }
754   virtual void execute(DCmdSource source, TRAPS);
755 };
756 
757 ///////////////////////////////////////////////////////////////////////
758 //
759 // jcmd command support for symbol table, string table and system dictionary dumping:
760 //   VM.symboltable -verbose: for dumping the symbol table
761 //   VM.stringtable -verbose: for dumping the string table
762 //   VM.systemdictionary -verbose: for dumping the system dictionary table
763 //
764 class VM_DumpHashtable : public VM_Operation {
765 private:
766   outputStream* _out;
767   int _which;
768   bool _verbose;
769 public:
770   enum {
771     DumpSymbols = 1 &lt;&lt; 0,
772     DumpStrings = 1 &lt;&lt; 1,
773     DumpSysDict = 1 &lt;&lt; 2  // not implemented yet
774   };
775   VM_DumpHashtable(outputStream* out, int which, bool verbose) {
776     _out = out;
777     _which = which;
778     _verbose = verbose;
779   }
780 
781   virtual VMOp_Type type() const { return VMOp_DumpHashtable; }
782 
783   virtual void doit() {
784     switch (_which) {
785     case DumpSymbols:
786       SymbolTable::dump(_out, _verbose);
787       break;
788     case DumpStrings:
789       StringTable::dump(_out, _verbose);
790       break;
791     case DumpSysDict:
792       SystemDictionary::dump(_out, _verbose);
793       break;
794     default:
795       ShouldNotReachHere();
796     }
797   }
798 };
799 
800 class SymboltableDCmd : public DCmdWithParser {
801 protected:
802   DCmdArgument&lt;bool&gt; _verbose;
803 public:
804   SymboltableDCmd(outputStream* output, bool heap);
805   static const char* name() {
806     return &quot;VM.symboltable&quot;;
807   }
808   static const char* description() {
809     return &quot;Dump symbol table.&quot;;
810   }
811   static const char* impact() {
812     return &quot;Medium: Depends on Java content.&quot;;
813   }
814   static const JavaPermission permission() {
815     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
816                         &quot;monitor&quot;, NULL};
817     return p;
818   }
819   static int num_arguments();
820   virtual void execute(DCmdSource source, TRAPS);
821 };
822 
823 class StringtableDCmd : public DCmdWithParser {
824 protected:
825   DCmdArgument&lt;bool&gt; _verbose;
826 public:
827   StringtableDCmd(outputStream* output, bool heap);
828   static const char* name() {
829     return &quot;VM.stringtable&quot;;
830   }
831   static const char* description() {
832     return &quot;Dump string table.&quot;;
833   }
834   static const char* impact() {
835     return &quot;Medium: Depends on Java content.&quot;;
836   }
837   static const JavaPermission permission() {
838     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
839                         &quot;monitor&quot;, NULL};
840     return p;
841   }
842   static int num_arguments();
843   virtual void execute(DCmdSource source, TRAPS);
844 };
845 
846 class SystemDictionaryDCmd : public DCmdWithParser {
847 protected:
848   DCmdArgument&lt;bool&gt; _verbose;
849 public:
850   SystemDictionaryDCmd(outputStream* output, bool heap);
851   static const char* name() {
852     return &quot;VM.systemdictionary&quot;;
853   }
854   static const char* description() {
855     return &quot;Prints the statistics for dictionary hashtable sizes and bucket length&quot;;
856   }
857   static const char* impact() {
858       return &quot;Medium: Depends on Java content.&quot;;
859   }
860   static const JavaPermission permission() {
861     JavaPermission p = {&quot;java.lang.management.ManagementPermission&quot;,
862                         &quot;monitor&quot;, NULL};
863     return p;
864   }
865   static int num_arguments();
866   virtual void execute(DCmdSource source, TRAPS);
867 };
868 
869 #if INCLUDE_JVMTI
870 class DebugOnCmdStartDCmd : public DCmdWithParser {
871 public:
872   DebugOnCmdStartDCmd(outputStream* output, bool heap);
873   static const char* name() {
874     return &quot;VM.start_java_debugging&quot;;
875   }
876   static const char* description() {
877     return &quot;Starts up the Java debugging if the jdwp agentlib was enabled with the option onjcmd=y.&quot;;
878   }
879   static const char* impact() {
880     return &quot;High: Switches the VM into Java debug mode.&quot;;
881   }
882   static const JavaPermission permission() {
883     JavaPermission p = { &quot;java.lang.management.ManagementPermission&quot;, &quot;monitor&quot;, NULL };
884     return p;
885   }
886   static int num_arguments() { return 0; }
887   virtual void execute(DCmdSource source, TRAPS);
888 };
889 #endif // INCLUDE_JVMTI
890 
891 #endif // SHARE_SERVICES_DIAGNOSTICCOMMAND_HPP
    </pre>
  </body>
</html>
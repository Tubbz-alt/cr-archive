<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/classLoadingService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/mutexLocker.hpp&quot;
 31 #include &quot;services/classLoadingService.hpp&quot;
 32 #include &quot;services/memoryService.hpp&quot;
 33 #include &quot;utilities/dtrace.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;utilities/defaultStream.hpp&quot;
 36 #include &quot;logging/log.hpp&quot;
 37 #include &quot;logging/logConfiguration.hpp&quot;
 38 
 39 #ifdef DTRACE_ENABLED
 40 
 41 // Only bother with this argument setup if dtrace is available
 42 
 43 #define HOTSPOT_CLASS_unloaded HOTSPOT_CLASS_UNLOADED
 44 #define HOTSPOT_CLASS_loaded HOTSPOT_CLASS_LOADED
 45 #define DTRACE_CLASSLOAD_PROBE(type, clss, shared)  \
 46   {                                                 \
 47     char* data = NULL;                              \
 48     int len = 0;                                    \
 49     Symbol* name = (clss)-&gt;name();                  \
 50     if (name != NULL) {                             \
 51       data = (char*)name-&gt;bytes();                  \
 52       len = name-&gt;utf8_length();                    \
 53     }                                               \
 54     HOTSPOT_CLASS_##type( /* type = unloaded, loaded */ \
 55       data, len, (void*)(clss)-&gt;class_loader_data(), (shared)); \
 56   }
 57 
 58 #else //  ndef DTRACE_ENABLED
 59 
 60 #define DTRACE_CLASSLOAD_PROBE(type, clss, shared)
 61 
 62 #endif
 63 
 64 #if INCLUDE_MANAGEMENT
 65 // counters for classes loaded from class files
 66 PerfCounter*    ClassLoadingService::_classes_loaded_count = NULL;
 67 PerfCounter*    ClassLoadingService::_classes_unloaded_count = NULL;
 68 PerfCounter*    ClassLoadingService::_classbytes_loaded = NULL;
 69 PerfCounter*    ClassLoadingService::_classbytes_unloaded = NULL;
 70 
 71 // counters for classes loaded from shared archive
 72 PerfCounter*    ClassLoadingService::_shared_classes_loaded_count = NULL;
 73 PerfCounter*    ClassLoadingService::_shared_classes_unloaded_count = NULL;
 74 PerfCounter*    ClassLoadingService::_shared_classbytes_loaded = NULL;
 75 PerfCounter*    ClassLoadingService::_shared_classbytes_unloaded = NULL;
 76 PerfVariable*   ClassLoadingService::_class_methods_size = NULL;
 77 
 78 void ClassLoadingService::init() {
 79   EXCEPTION_MARK;
 80 
 81   // These counters are for java.lang.management API support.
 82   // They are created even if -XX:-UsePerfData is set and in
 83   // that case, they will be allocated on C heap.
 84   _classes_loaded_count =
 85                  PerfDataManager::create_counter(JAVA_CLS, &quot;loadedClasses&quot;,
 86                                                  PerfData::U_Events, CHECK);
 87 
 88   _classes_unloaded_count =
 89                  PerfDataManager::create_counter(JAVA_CLS, &quot;unloadedClasses&quot;,
 90                                                  PerfData::U_Events, CHECK);
 91 
 92   _shared_classes_loaded_count =
 93                  PerfDataManager::create_counter(JAVA_CLS, &quot;sharedLoadedClasses&quot;,
 94                                                  PerfData::U_Events, CHECK);
 95 
 96   _shared_classes_unloaded_count =
 97                  PerfDataManager::create_counter(JAVA_CLS, &quot;sharedUnloadedClasses&quot;,
 98                                                  PerfData::U_Events, CHECK);
 99 
100   if (UsePerfData) {
101     _classbytes_loaded =
102                  PerfDataManager::create_counter(SUN_CLS, &quot;loadedBytes&quot;,
103                                                  PerfData::U_Bytes, CHECK);
104 
105     _classbytes_unloaded =
106                  PerfDataManager::create_counter(SUN_CLS, &quot;unloadedBytes&quot;,
107                                                  PerfData::U_Bytes, CHECK);
108     _shared_classbytes_loaded =
109                  PerfDataManager::create_counter(SUN_CLS, &quot;sharedLoadedBytes&quot;,
110                                                  PerfData::U_Bytes, CHECK);
111 
112     _shared_classbytes_unloaded =
113                  PerfDataManager::create_counter(SUN_CLS, &quot;sharedUnloadedBytes&quot;,
114                                                  PerfData::U_Bytes, CHECK);
115     _class_methods_size =
116                  PerfDataManager::create_variable(SUN_CLS, &quot;methodBytes&quot;,
117                                                   PerfData::U_Bytes, CHECK);
118   }
119 }
120 
121 void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {
122   DTRACE_CLASSLOAD_PROBE(unloaded, k, false);
123   // Classes that can be unloaded must be non-shared
124   _classes_unloaded_count-&gt;inc();
125 
126   if (UsePerfData) {
127     // add the class size
128     size_t size = compute_class_size(k);
129     _classbytes_unloaded-&gt;inc(size);
130 
131     // Compute method size &amp; subtract from running total.
132     // We are called during phase 1 of mark sweep, so it&#39;s
133     // still ok to iterate through Method*s here.
134     Array&lt;Method*&gt;* methods = k-&gt;methods();
135     for (int i = 0; i &lt; methods-&gt;length(); i++) {
136       _class_methods_size-&gt;inc(-methods-&gt;at(i)-&gt;size());
137     }
138   }
139 }
140 
141 void ClassLoadingService::notify_class_loaded(InstanceKlass* k, bool shared_class) {
142   DTRACE_CLASSLOAD_PROBE(loaded, k, shared_class);
143   PerfCounter* classes_counter = (shared_class ? _shared_classes_loaded_count
144                                                : _classes_loaded_count);
145   // increment the count
146   classes_counter-&gt;inc();
147 
148   if (UsePerfData) {
149     PerfCounter* classbytes_counter = (shared_class ? _shared_classbytes_loaded
150                                                     : _classbytes_loaded);
151     // add the class size
152     size_t size = compute_class_size(k);
153     classbytes_counter-&gt;inc(size);
154   }
155 }
156 
157 size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {
158   // lifted from ClassStatistics.do_class(Klass* k)
159 
160   size_t class_size = 0;
161 
162   class_size += k-&gt;size();
163 
164   if (k-&gt;is_instance_klass()) {
165     class_size += k-&gt;methods()-&gt;size();
166     // FIXME: Need to count the contents of methods
167     class_size += k-&gt;constants()-&gt;size();
168     class_size += k-&gt;local_interfaces()-&gt;size();
169     if (k-&gt;transitive_interfaces() != NULL) {
170       class_size += k-&gt;transitive_interfaces()-&gt;size();
171     }
172     // We do not have to count implementors, since we only store one!
173     // FIXME: How should these be accounted for, now when they have moved.
174     //class_size += k-&gt;fields()-&gt;size();
175   }
176   return class_size * oopSize;
177 }
178 
179 bool ClassLoadingService::set_verbose(bool verbose) {
180   MutexLocker m(Management_lock);
181   // verbose will be set to the previous value
182   LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;
183   LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));
184   reset_trace_class_unloading();
185   return verbose;
186 }
187 
188 // Caller to this function must own Management_lock
189 void ClassLoadingService::reset_trace_class_unloading() {
190   assert(Management_lock-&gt;owned_by_self(), &quot;Must own the Management_lock&quot;);
191   bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();
192   LogLevelType level = value ? LogLevel::Info : LogLevel::Off;
193   LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));
194 }
195 
196 #endif // INCLUDE_MANAGEMENT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
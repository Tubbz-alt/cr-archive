<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;memory/allocation.hpp&quot;
  28 #include &quot;memory/heapInspection.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/instanceKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  32 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  33 #include &quot;oops/objArrayOop.inline.hpp&quot;
  34 #include &quot;oops/oop.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  35 #include &quot;prims/jvmtiRawMonitor.hpp&quot;</span>
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/handles.inline.hpp&quot;
  38 #include &quot;runtime/init.hpp&quot;
  39 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  40 #include &quot;runtime/thread.inline.hpp&quot;
  41 #include &quot;runtime/threadSMR.inline.hpp&quot;
  42 #include &quot;runtime/vframe.hpp&quot;
  43 #include &quot;runtime/vmThread.hpp&quot;
  44 #include &quot;runtime/vmOperations.hpp&quot;
  45 #include &quot;services/threadService.hpp&quot;
  46 
  47 // TODO: we need to define a naming convention for perf counters
  48 // to distinguish counters for:
  49 //   - standard JSR174 use
  50 //   - Hotspot extension (public and committed)
  51 //   - Hotspot extension (private/internal and uncommitted)
  52 
  53 // Default is disabled.
  54 bool ThreadService::_thread_monitoring_contention_enabled = false;
  55 bool ThreadService::_thread_cpu_time_enabled = false;
  56 bool ThreadService::_thread_allocated_memory_enabled = false;
  57 
  58 PerfCounter*  ThreadService::_total_threads_count = NULL;
  59 PerfVariable* ThreadService::_live_threads_count = NULL;
  60 PerfVariable* ThreadService::_peak_threads_count = NULL;
  61 PerfVariable* ThreadService::_daemon_threads_count = NULL;
  62 volatile int ThreadService::_atomic_threads_count = 0;
  63 volatile int ThreadService::_atomic_daemon_threads_count = 0;
  64 
  65 ThreadDumpResult* ThreadService::_threaddump_list = NULL;
  66 
  67 static const int INITIAL_ARRAY_SIZE = 10;
  68 
  69 void ThreadService::init() {
  70   EXCEPTION_MARK;
  71 
  72   // These counters are for java.lang.management API support.
  73   // They are created even if -XX:-UsePerfData is set and in
  74   // that case, they will be allocated on C heap.
  75 
  76   _total_threads_count =
  77                 PerfDataManager::create_counter(JAVA_THREADS, &quot;started&quot;,
  78                                                 PerfData::U_Events, CHECK);
  79 
  80   _live_threads_count =
  81                 PerfDataManager::create_variable(JAVA_THREADS, &quot;live&quot;,
  82                                                  PerfData::U_None, CHECK);
  83 
  84   _peak_threads_count =
  85                 PerfDataManager::create_variable(JAVA_THREADS, &quot;livePeak&quot;,
  86                                                  PerfData::U_None, CHECK);
  87 
  88   _daemon_threads_count =
  89                 PerfDataManager::create_variable(JAVA_THREADS, &quot;daemon&quot;,
  90                                                  PerfData::U_None, CHECK);
  91 
  92   if (os::is_thread_cpu_time_supported()) {
  93     _thread_cpu_time_enabled = true;
  94   }
  95 
  96   _thread_allocated_memory_enabled = true; // Always on, so enable it
  97 }
  98 
  99 void ThreadService::reset_peak_thread_count() {
 100   // Acquire the lock to update the peak thread count
 101   // to synchronize with thread addition and removal.
<a name="3" id="anc3"></a><span class="line-modified"> 102   MutexLocker mu(Threads_lock);</span>
 103   _peak_threads_count-&gt;set_value(get_live_thread_count());
 104 }
 105 
 106 static bool is_hidden_thread(JavaThread *thread) {
 107   // hide VM internal or JVMTI agent threads
 108   return thread-&gt;is_hidden_from_external_view() || thread-&gt;is_jvmti_agent_thread();
 109 }
 110 
 111 void ThreadService::add_thread(JavaThread* thread, bool daemon) {
 112   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 113 
 114   // Do not count hidden threads
 115   if (is_hidden_thread(thread)) {
 116     return;
 117   }
 118 
 119   _total_threads_count-&gt;inc();
 120   _live_threads_count-&gt;inc();
 121   Atomic::inc(&amp;_atomic_threads_count);
 122   int count = _atomic_threads_count;
 123 
 124   if (count &gt; _peak_threads_count-&gt;get_value()) {
 125     _peak_threads_count-&gt;set_value(count);
 126   }
 127 
 128   if (daemon) {
 129     _daemon_threads_count-&gt;inc();
 130     Atomic::inc(&amp;_atomic_daemon_threads_count);
 131   }
 132 }
 133 
 134 void ThreadService::decrement_thread_counts(JavaThread* jt, bool daemon) {
 135   Atomic::dec(&amp;_atomic_threads_count);
 136 
 137   if (daemon) {
 138     Atomic::dec(&amp;_atomic_daemon_threads_count);
 139   }
 140 }
 141 
 142 void ThreadService::remove_thread(JavaThread* thread, bool daemon) {
 143   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 144 
 145   // Do not count hidden threads
 146   if (is_hidden_thread(thread)) {
 147     return;
 148   }
 149 
 150   assert(!thread-&gt;is_terminated(), &quot;must not be terminated&quot;);
 151   if (!thread-&gt;is_exiting()) {
 152     // JavaThread::exit() skipped calling current_thread_exiting()
 153     decrement_thread_counts(thread, daemon);
 154   }
 155 
 156   int daemon_count = _atomic_daemon_threads_count;
 157   int count = _atomic_threads_count;
 158 
 159   // Counts are incremented at the same time, but atomic counts are
 160   // decremented earlier than perf counts.
 161   assert(_live_threads_count-&gt;get_value() &gt; count,
 162     &quot;thread count mismatch %d : %d&quot;,
 163     (int)_live_threads_count-&gt;get_value(), count);
 164 
 165   _live_threads_count-&gt;dec(1);
 166   if (daemon) {
 167     assert(_daemon_threads_count-&gt;get_value() &gt; daemon_count,
 168       &quot;thread count mismatch %d : %d&quot;,
 169       (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 170 
 171     _daemon_threads_count-&gt;dec(1);
 172   }
 173 
 174   // Counts are incremented at the same time, but atomic counts are
 175   // decremented earlier than perf counts.
 176   assert(_daemon_threads_count-&gt;get_value() &gt;= daemon_count,
 177     &quot;thread count mismatch %d : %d&quot;,
 178     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 179   assert(_live_threads_count-&gt;get_value() &gt;= count,
 180     &quot;thread count mismatch %d : %d&quot;,
 181     (int)_live_threads_count-&gt;get_value(), count);
 182   assert(_live_threads_count-&gt;get_value() &gt; 0 ||
 183     (_live_threads_count-&gt;get_value() == 0 &amp;&amp; count == 0 &amp;&amp;
 184     _daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 185     &quot;thread counts should reach 0 at the same time, live %d,%d daemon %d,%d&quot;,
 186     (int)_live_threads_count-&gt;get_value(), count,
 187     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 188   assert(_daemon_threads_count-&gt;get_value() &gt; 0 ||
 189     (_daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 190     &quot;thread counts should reach 0 at the same time, daemon %d,%d&quot;,
 191     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 192 }
 193 
 194 void ThreadService::current_thread_exiting(JavaThread* jt, bool daemon) {
 195   // Do not count hidden threads
 196   if (is_hidden_thread(jt)) {
 197     return;
 198   }
 199 
 200   assert(jt == JavaThread::current(), &quot;Called by current thread&quot;);
 201   assert(!jt-&gt;is_terminated() &amp;&amp; jt-&gt;is_exiting(), &quot;must be exiting&quot;);
 202 
 203   decrement_thread_counts(jt, daemon);
 204 }
 205 
 206 // FIXME: JVMTI should call this function
 207 Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
 208   assert(thread != NULL, &quot;should be non-NULL&quot;);
 209   debug_only(Thread::check_for_dangling_thread_pointer(thread);)
 210 
 211   ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
 212 
 213   oop obj = NULL;
 214   if (wait_obj != NULL) {
 215     // thread is doing an Object.wait() call
 216     obj = (oop) wait_obj-&gt;object();
 217     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 218   } else {
 219     ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
 220     if (enter_obj != NULL) {
<a name="4" id="anc4"></a><span class="line-modified"> 221       // thread is trying to enter() an ObjectMonitor.</span>
 222       obj = (oop) enter_obj-&gt;object();
<a name="5" id="anc5"></a><span class="line-added"> 223       assert(obj != NULL, &quot;ObjectMonitor should have an associated object!&quot;);</span>
 224     }
<a name="6" id="anc6"></a>
 225   }
 226 
 227   Handle h(Thread::current(), obj);
 228   return h;
 229 }
 230 
 231 bool ThreadService::set_thread_monitoring_contention(bool flag) {
 232   MutexLocker m(Management_lock);
 233 
 234   bool prev = _thread_monitoring_contention_enabled;
 235   _thread_monitoring_contention_enabled = flag;
 236 
 237   return prev;
 238 }
 239 
 240 bool ThreadService::set_thread_cpu_time_enabled(bool flag) {
 241   MutexLocker m(Management_lock);
 242 
 243   bool prev = _thread_cpu_time_enabled;
 244   _thread_cpu_time_enabled = flag;
 245 
 246   return prev;
 247 }
 248 
 249 bool ThreadService::set_thread_allocated_memory_enabled(bool flag) {
 250   MutexLocker m(Management_lock);
 251 
 252   bool prev = _thread_allocated_memory_enabled;
 253   _thread_allocated_memory_enabled = flag;
 254 
 255   return prev;
 256 }
 257 
 258 // GC support
 259 void ThreadService::oops_do(OopClosure* f) {
 260   for (ThreadDumpResult* dump = _threaddump_list; dump != NULL; dump = dump-&gt;next()) {
 261     dump-&gt;oops_do(f);
 262   }
 263 }
 264 
 265 void ThreadService::metadata_do(void f(Metadata*)) {
 266   for (ThreadDumpResult* dump = _threaddump_list; dump != NULL; dump = dump-&gt;next()) {
 267     dump-&gt;metadata_do(f);
 268   }
 269 }
 270 
 271 void ThreadService::add_thread_dump(ThreadDumpResult* dump) {
 272   MutexLocker ml(Management_lock);
 273   if (_threaddump_list == NULL) {
 274     _threaddump_list = dump;
 275   } else {
 276     dump-&gt;set_next(_threaddump_list);
 277     _threaddump_list = dump;
 278   }
 279 }
 280 
 281 void ThreadService::remove_thread_dump(ThreadDumpResult* dump) {
 282   MutexLocker ml(Management_lock);
 283 
 284   ThreadDumpResult* prev = NULL;
 285   bool found = false;
 286   for (ThreadDumpResult* d = _threaddump_list; d != NULL; prev = d, d = d-&gt;next()) {
 287     if (d == dump) {
 288       if (prev == NULL) {
 289         _threaddump_list = dump-&gt;next();
 290       } else {
 291         prev-&gt;set_next(dump-&gt;next());
 292       }
 293       found = true;
 294       break;
 295     }
 296   }
 297   assert(found, &quot;The threaddump result to be removed must exist.&quot;);
 298 }
 299 
 300 // Dump stack trace of threads specified in the given threads array.
 301 // Returns StackTraceElement[][] each element is the stack trace of a thread in
 302 // the corresponding entry in the given threads array
 303 Handle ThreadService::dump_stack_traces(GrowableArray&lt;instanceHandle&gt;* threads,
 304                                         int num_threads,
 305                                         TRAPS) {
 306   assert(num_threads &gt; 0, &quot;just checking&quot;);
 307 
 308   ThreadDumpResult dump_result;
 309   VM_ThreadDump op(&amp;dump_result,
 310                    threads,
 311                    num_threads,
 312                    -1,    /* entire stack */
 313                    false, /* with locked monitors */
 314                    false  /* with locked synchronizers */);
 315   VMThread::execute(&amp;op);
 316 
 317   // Allocate the resulting StackTraceElement[][] object
 318 
 319   ResourceMark rm(THREAD);
 320   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_StackTraceElement_array(), true, CHECK_NH);
 321   ObjArrayKlass* ik = ObjArrayKlass::cast(k);
 322   objArrayOop r = oopFactory::new_objArray(ik, num_threads, CHECK_NH);
 323   objArrayHandle result_obj(THREAD, r);
 324 
 325   int num_snapshots = dump_result.num_snapshots();
 326   assert(num_snapshots == num_threads, &quot;Must have num_threads thread snapshots&quot;);
 327   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
 328   int i = 0;
 329   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; i++, ts = ts-&gt;next()) {
 330     ThreadStackTrace* stacktrace = ts-&gt;get_stack_trace();
 331     if (stacktrace == NULL) {
 332       // No stack trace
 333       result_obj-&gt;obj_at_put(i, NULL);
 334     } else {
 335       // Construct an array of java/lang/StackTraceElement object
 336       Handle backtrace_h = stacktrace-&gt;allocate_fill_stack_trace_element_array(CHECK_NH);
 337       result_obj-&gt;obj_at_put(i, backtrace_h());
 338     }
 339   }
 340 
 341   return result_obj;
 342 }
 343 
 344 void ThreadService::reset_contention_count_stat(JavaThread* thread) {
 345   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 346   if (stat != NULL) {
 347     stat-&gt;reset_count_stat();
 348   }
 349 }
 350 
 351 void ThreadService::reset_contention_time_stat(JavaThread* thread) {
 352   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 353   if (stat != NULL) {
 354     stat-&gt;reset_time_stat();
 355   }
 356 }
 357 
<a name="7" id="anc7"></a><span class="line-modified"> 358 // Find deadlocks involving raw monitors, object monitors and concurrent locks</span>
<span class="line-added"> 359 // if concurrent_locks is true.</span>
 360 DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
 361   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 362 
 363   // This code was modified from the original Threads::find_deadlocks code.
 364   int globalDfn = 0, thisDfn;
 365   ObjectMonitor* waitingToLockMonitor = NULL;
<a name="8" id="anc8"></a><span class="line-added"> 366   JvmtiRawMonitor* waitingToLockRawMonitor = NULL;</span>
 367   oop waitingToLockBlocker = NULL;
 368   bool blocked_on_monitor = false;
 369   JavaThread *currentThread, *previousThread;
 370   int num_deadlocks = 0;
 371 
 372   // Initialize the depth-first-number for each JavaThread.
 373   JavaThreadIterator jti(t_list);
 374   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 375     jt-&gt;set_depth_first_number(-1);
 376   }
 377 
 378   DeadlockCycle* deadlocks = NULL;
 379   DeadlockCycle* last = NULL;
 380   DeadlockCycle* cycle = new DeadlockCycle();
 381   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 382     if (jt-&gt;depth_first_number() &gt;= 0) {
 383       // this thread was already visited
 384       continue;
 385     }
 386 
 387     thisDfn = globalDfn;
 388     jt-&gt;set_depth_first_number(globalDfn++);
 389     previousThread = jt;
 390     currentThread = jt;
 391 
 392     cycle-&gt;reset();
 393 
 394     // When there is a deadlock, all the monitors involved in the dependency
 395     // cycle must be contended and heavyweight. So we only care about the
 396     // heavyweight monitor a thread is waiting to lock.
<a name="9" id="anc9"></a><span class="line-modified"> 397     waitingToLockMonitor = jt-&gt;current_pending_monitor();</span>
<span class="line-added"> 398     // JVM TI raw monitors can also be involved in deadlocks, and we can be</span>
<span class="line-added"> 399     // waiting to lock both a raw monitor and ObjectMonitor at the same time.</span>
<span class="line-added"> 400     // It isn&#39;t clear how to make deadlock detection work correctly if that</span>
<span class="line-added"> 401     // happens.</span>
<span class="line-added"> 402     waitingToLockRawMonitor = jt-&gt;current_pending_raw_monitor();</span>
<span class="line-added"> 403 </span>
 404     if (concurrent_locks) {
 405       waitingToLockBlocker = jt-&gt;current_park_blocker();
 406     }
<a name="10" id="anc10"></a><span class="line-modified"> 407 </span>
<span class="line-added"> 408     while (waitingToLockMonitor != NULL ||</span>
<span class="line-added"> 409            waitingToLockRawMonitor != NULL ||</span>
<span class="line-added"> 410            waitingToLockBlocker != NULL) {</span>
 411       cycle-&gt;add_thread(currentThread);
<a name="11" id="anc11"></a><span class="line-modified"> 412       // Give preference to the raw monitor</span>
<span class="line-added"> 413       if (waitingToLockRawMonitor != NULL) {</span>
<span class="line-added"> 414         Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="line-added"> 415         if (owner != NULL &amp;&amp; // the raw monitor could be released at any time</span>
<span class="line-added"> 416             owner-&gt;is_Java_thread()) {</span>
<span class="line-added"> 417           // only JavaThreads can be reported here</span>
<span class="line-added"> 418           currentThread = (JavaThread*) owner;</span>
<span class="line-added"> 419         }</span>
<span class="line-added"> 420       } else if (waitingToLockMonitor != NULL) {</span>
 421         address currentOwner = (address)waitingToLockMonitor-&gt;owner();
 422         if (currentOwner != NULL) {
 423           currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 424                                                                     currentOwner);
 425           if (currentThread == NULL) {
 426             // This function is called at a safepoint so the JavaThread
 427             // that owns waitingToLockMonitor should be findable, but
 428             // if it is not findable, then the previous currentThread is
 429             // blocked permanently. We record this as a deadlock.
 430             num_deadlocks++;
 431 
 432             cycle-&gt;set_deadlock(true);
 433 
 434             // add this cycle to the deadlocks list
 435             if (deadlocks == NULL) {
 436               deadlocks = cycle;
 437             } else {
 438               last-&gt;set_next(cycle);
 439             }
 440             last = cycle;
 441             cycle = new DeadlockCycle();
 442             break;
 443           }
 444         }
 445       } else {
 446         if (concurrent_locks) {
 447           if (waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 448             oop threadObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
 449             // This JavaThread (if there is one) is protected by the
 450             // ThreadsListSetter in VM_FindDeadlocks::doit().
 451             currentThread = threadObj != NULL ? java_lang_Thread::thread(threadObj) : NULL;
 452           } else {
 453             currentThread = NULL;
 454           }
 455         }
 456       }
 457 
 458       if (currentThread == NULL) {
 459         // No dependency on another thread
 460         break;
 461       }
 462       if (currentThread-&gt;depth_first_number() &lt; 0) {
 463         // First visit to this thread
 464         currentThread-&gt;set_depth_first_number(globalDfn++);
 465       } else if (currentThread-&gt;depth_first_number() &lt; thisDfn) {
 466         // Thread already visited, and not on a (new) cycle
 467         break;
 468       } else if (currentThread == previousThread) {
 469         // Self-loop, ignore
 470         break;
 471       } else {
 472         // We have a (new) cycle
 473         num_deadlocks++;
 474 
 475         cycle-&gt;set_deadlock(true);
 476 
 477         // add this cycle to the deadlocks list
 478         if (deadlocks == NULL) {
 479           deadlocks = cycle;
 480         } else {
 481           last-&gt;set_next(cycle);
 482         }
 483         last = cycle;
 484         cycle = new DeadlockCycle();
 485         break;
 486       }
 487       previousThread = currentThread;
 488       waitingToLockMonitor = (ObjectMonitor*)currentThread-&gt;current_pending_monitor();
 489       if (concurrent_locks) {
 490         waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 491       }
 492     }
 493 
 494   }
 495   delete cycle;
 496   return deadlocks;
 497 }
 498 
 499 ThreadDumpResult::ThreadDumpResult() : _num_threads(0), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 500 
 501   // Create a new ThreadDumpResult object and append to the list.
 502   // If GC happens before this function returns, Method*
 503   // in the stack trace will be visited.
 504   ThreadService::add_thread_dump(this);
 505 }
 506 
 507 ThreadDumpResult::ThreadDumpResult(int num_threads) : _num_threads(num_threads), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 508   // Create a new ThreadDumpResult object and append to the list.
 509   // If GC happens before this function returns, oops
 510   // will be visited.
 511   ThreadService::add_thread_dump(this);
 512 }
 513 
 514 ThreadDumpResult::~ThreadDumpResult() {
 515   ThreadService::remove_thread_dump(this);
 516 
 517   // free all the ThreadSnapshot objects created during
 518   // the VM_ThreadDump operation
 519   ThreadSnapshot* ts = _snapshots;
 520   while (ts != NULL) {
 521     ThreadSnapshot* p = ts;
 522     ts = ts-&gt;next();
 523     delete p;
 524   }
 525 }
 526 
 527 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot() {
 528   ThreadSnapshot* ts = new ThreadSnapshot();
 529   link_thread_snapshot(ts);
 530   return ts;
 531 }
 532 
 533 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot(JavaThread* thread) {
 534   // Note: it is very important that the ThreadSnapshot* gets linked before
 535   // ThreadSnapshot::initialize gets called. This is to ensure that
 536   // ThreadSnapshot::oops_do can get called prior to the field
 537   // ThreadSnapshot::_threadObj being assigned a value (to prevent a dangling
 538   // oop).
 539   ThreadSnapshot* ts = new ThreadSnapshot();
 540   link_thread_snapshot(ts);
 541   ts-&gt;initialize(t_list(), thread);
 542   return ts;
 543 }
 544 
 545 void ThreadDumpResult::link_thread_snapshot(ThreadSnapshot* ts) {
 546   assert(_num_threads == 0 || _num_snapshots &lt; _num_threads,
 547          &quot;_num_snapshots must be less than _num_threads&quot;);
 548   _num_snapshots++;
 549   if (_snapshots == NULL) {
 550     _snapshots = ts;
 551   } else {
 552     _last-&gt;set_next(ts);
 553   }
 554   _last = ts;
 555 }
 556 
 557 void ThreadDumpResult::oops_do(OopClosure* f) {
 558   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 559     ts-&gt;oops_do(f);
 560   }
 561 }
 562 
 563 void ThreadDumpResult::metadata_do(void f(Metadata*)) {
 564   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 565     ts-&gt;metadata_do(f);
 566   }
 567 }
 568 
 569 ThreadsList* ThreadDumpResult::t_list() {
 570   return _setter.list();
 571 }
 572 
 573 StackFrameInfo::StackFrameInfo(javaVFrame* jvf, bool with_lock_info) {
 574   _method = jvf-&gt;method();
 575   _bci = jvf-&gt;bci();
 576   _class_holder = _method-&gt;method_holder()-&gt;klass_holder();
 577   _locked_monitors = NULL;
 578   if (with_lock_info) {
 579     ResourceMark rm;
 580     GrowableArray&lt;MonitorInfo*&gt;* list = jvf-&gt;locked_monitors();
 581     int length = list-&gt;length();
 582     if (length &gt; 0) {
 583       _locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(length, true);
 584       for (int i = 0; i &lt; length; i++) {
 585         MonitorInfo* monitor = list-&gt;at(i);
 586         assert(monitor-&gt;owner() != NULL, &quot;This monitor must have an owning object&quot;);
 587         _locked_monitors-&gt;append(monitor-&gt;owner());
 588       }
 589     }
 590   }
 591 }
 592 
 593 void StackFrameInfo::oops_do(OopClosure* f) {
 594   if (_locked_monitors != NULL) {
 595     int length = _locked_monitors-&gt;length();
 596     for (int i = 0; i &lt; length; i++) {
 597       f-&gt;do_oop((oop*) _locked_monitors-&gt;adr_at(i));
 598     }
 599   }
 600   f-&gt;do_oop(&amp;_class_holder);
 601 }
 602 
 603 void StackFrameInfo::metadata_do(void f(Metadata*)) {
 604   f(_method);
 605 }
 606 
 607 void StackFrameInfo::print_on(outputStream* st) const {
 608   ResourceMark rm;
 609   java_lang_Throwable::print_stack_element(st, method(), bci());
 610   int len = (_locked_monitors != NULL ? _locked_monitors-&gt;length() : 0);
 611   for (int i = 0; i &lt; len; i++) {
 612     oop o = _locked_monitors-&gt;at(i);
 613     st-&gt;print_cr(&quot;\t- locked &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
 614   }
 615 
 616 }
 617 
 618 // Iterate through monitor cache to find JNI locked monitors
 619 class InflatedMonitorsClosure: public MonitorClosure {
 620 private:
 621   ThreadStackTrace* _stack_trace;
 622   Thread* _thread;
 623 public:
 624   InflatedMonitorsClosure(Thread* t, ThreadStackTrace* st) {
 625     _thread = t;
 626     _stack_trace = st;
 627   }
 628   void do_monitor(ObjectMonitor* mid) {
 629     if (mid-&gt;owner() == _thread) {
 630       oop object = (oop) mid-&gt;object();
 631       if (!_stack_trace-&gt;is_owned_monitor_on_stack(object)) {
 632         _stack_trace-&gt;add_jni_locked_monitor(object);
 633       }
 634     }
 635   }
 636 };
 637 
 638 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
 639   _thread = t;
 640   _frames = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;StackFrameInfo*&gt;(INITIAL_ARRAY_SIZE, true);
 641   _depth = 0;
 642   _with_locked_monitors = with_locked_monitors;
 643   if (_with_locked_monitors) {
 644     _jni_locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, true);
 645   } else {
 646     _jni_locked_monitors = NULL;
 647   }
 648 }
 649 
 650 ThreadStackTrace::~ThreadStackTrace() {
 651   for (int i = 0; i &lt; _frames-&gt;length(); i++) {
 652     delete _frames-&gt;at(i);
 653   }
 654   delete _frames;
 655   if (_jni_locked_monitors != NULL) {
 656     delete _jni_locked_monitors;
 657   }
 658 }
 659 
 660 void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth) {
 661   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 662 
 663   if (_thread-&gt;has_last_Java_frame()) {
 664     RegisterMap reg_map(_thread);
 665     vframe* start_vf = _thread-&gt;last_java_vframe(&amp;reg_map);
 666     int count = 0;
 667     for (vframe* f = start_vf; f; f = f-&gt;sender() ) {
 668       if (maxDepth &gt;= 0 &amp;&amp; count == maxDepth) {
 669         // Skip frames if more than maxDepth
 670         break;
 671       }
 672       if (f-&gt;is_java_frame()) {
 673         javaVFrame* jvf = javaVFrame::cast(f);
 674         add_stack_frame(jvf);
 675         count++;
 676       } else {
 677         // Ignore non-Java frames
 678       }
 679     }
 680   }
 681 
 682   if (_with_locked_monitors) {
 683     // Iterate inflated monitors and find monitors locked by this thread
 684     // not found in the stack
 685     InflatedMonitorsClosure imc(_thread, this);
 686     ObjectSynchronizer::monitors_iterate(&amp;imc);
 687   }
 688 }
 689 
 690 
 691 bool ThreadStackTrace::is_owned_monitor_on_stack(oop object) {
 692   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 693 
 694   bool found = false;
 695   int num_frames = get_stack_depth();
 696   for (int depth = 0; depth &lt; num_frames; depth++) {
 697     StackFrameInfo* frame = stack_frame_at(depth);
 698     int len = frame-&gt;num_locked_monitors();
 699     GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
 700     for (int j = 0; j &lt; len; j++) {
 701       oop monitor = locked_monitors-&gt;at(j);
 702       assert(monitor != NULL, &quot;must be a Java object&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 703       if (monitor == object) {</span>
 704         found = true;
 705         break;
 706       }
 707     }
 708   }
 709   return found;
 710 }
 711 
 712 Handle ThreadStackTrace::allocate_fill_stack_trace_element_array(TRAPS) {
 713   InstanceKlass* ik = SystemDictionary::StackTraceElement_klass();
 714   assert(ik != NULL, &quot;must be loaded in 1.4+&quot;);
 715 
 716   // Allocate an array of java/lang/StackTraceElement object
 717   objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);
 718   objArrayHandle backtrace(THREAD, ste);
 719   for (int j = 0; j &lt; _depth; j++) {
 720     StackFrameInfo* frame = _frames-&gt;at(j);
 721     methodHandle mh(THREAD, frame-&gt;method());
 722     oop element = java_lang_StackTraceElement::create(mh, frame-&gt;bci(), CHECK_NH);
 723     backtrace-&gt;obj_at_put(j, element);
 724   }
 725   return backtrace;
 726 }
 727 
 728 void ThreadStackTrace::add_stack_frame(javaVFrame* jvf) {
 729   StackFrameInfo* frame = new StackFrameInfo(jvf, _with_locked_monitors);
 730   _frames-&gt;append(frame);
 731   _depth++;
 732 }
 733 
 734 void ThreadStackTrace::oops_do(OopClosure* f) {
 735   int length = _frames-&gt;length();
 736   for (int i = 0; i &lt; length; i++) {
 737     _frames-&gt;at(i)-&gt;oops_do(f);
 738   }
 739 
 740   length = (_jni_locked_monitors != NULL ? _jni_locked_monitors-&gt;length() : 0);
 741   for (int j = 0; j &lt; length; j++) {
 742     f-&gt;do_oop((oop*) _jni_locked_monitors-&gt;adr_at(j));
 743   }
 744 }
 745 
 746 void ThreadStackTrace::metadata_do(void f(Metadata*)) {
 747   int length = _frames-&gt;length();
 748   for (int i = 0; i &lt; length; i++) {
 749     _frames-&gt;at(i)-&gt;metadata_do(f);
 750   }
 751 }
 752 
 753 
 754 ConcurrentLocksDump::~ConcurrentLocksDump() {
 755   if (_retain_map_on_free) {
 756     return;
 757   }
 758 
 759   for (ThreadConcurrentLocks* t = _map; t != NULL;)  {
 760     ThreadConcurrentLocks* tcl = t;
 761     t = t-&gt;next();
 762     delete tcl;
 763   }
 764 }
 765 
 766 void ConcurrentLocksDump::dump_at_safepoint() {
 767   // dump all locked concurrent locks
 768   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 769 
 770   GrowableArray&lt;oop&gt;* aos_objects = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, true /* C_heap */);
 771 
 772   // Find all instances of AbstractOwnableSynchronizer
 773   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
 774                                               aos_objects);
 775   // Build a map of thread to its owned AQS locks
 776   build_map(aos_objects);
 777 
 778   delete aos_objects;
 779 }
 780 
 781 
 782 // build a map of JavaThread to all its owned AbstractOwnableSynchronizer
 783 void ConcurrentLocksDump::build_map(GrowableArray&lt;oop&gt;* aos_objects) {
 784   int length = aos_objects-&gt;length();
 785   for (int i = 0; i &lt; length; i++) {
 786     oop o = aos_objects-&gt;at(i);
 787     oop owner_thread_obj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(o);
 788     if (owner_thread_obj != NULL) {
 789       // See comments in ThreadConcurrentLocks to see how this
 790       // JavaThread* is protected.
 791       JavaThread* thread = java_lang_Thread::thread(owner_thread_obj);
 792       assert(o-&gt;is_instance(), &quot;Must be an instanceOop&quot;);
 793       add_lock(thread, (instanceOop) o);
 794     }
 795   }
 796 }
 797 
 798 void ConcurrentLocksDump::add_lock(JavaThread* thread, instanceOop o) {
 799   ThreadConcurrentLocks* tcl = thread_concurrent_locks(thread);
 800   if (tcl != NULL) {
 801     tcl-&gt;add_lock(o);
 802     return;
 803   }
 804 
 805   // First owned lock found for this thread
 806   tcl = new ThreadConcurrentLocks(thread);
 807   tcl-&gt;add_lock(o);
 808   if (_map == NULL) {
 809     _map = tcl;
 810   } else {
 811     _last-&gt;set_next(tcl);
 812   }
 813   _last = tcl;
 814 }
 815 
 816 ThreadConcurrentLocks* ConcurrentLocksDump::thread_concurrent_locks(JavaThread* thread) {
 817   for (ThreadConcurrentLocks* tcl = _map; tcl != NULL; tcl = tcl-&gt;next()) {
 818     if (tcl-&gt;java_thread() == thread) {
 819       return tcl;
 820     }
 821   }
 822   return NULL;
 823 }
 824 
 825 void ConcurrentLocksDump::print_locks_on(JavaThread* t, outputStream* st) {
 826   st-&gt;print_cr(&quot;   Locked ownable synchronizers:&quot;);
 827   ThreadConcurrentLocks* tcl = thread_concurrent_locks(t);
 828   GrowableArray&lt;instanceOop&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
 829   if (locks == NULL || locks-&gt;is_empty()) {
 830     st-&gt;print_cr(&quot;\t- None&quot;);
 831     st-&gt;cr();
 832     return;
 833   }
 834 
 835   for (int i = 0; i &lt; locks-&gt;length(); i++) {
 836     instanceOop obj = locks-&gt;at(i);
 837     st-&gt;print_cr(&quot;\t- &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;external_name());
 838   }
 839   st-&gt;cr();
 840 }
 841 
 842 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
 843   _thread = thread;
 844   _owned_locks = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;instanceOop&gt;(INITIAL_ARRAY_SIZE, true);
 845   _next = NULL;
 846 }
 847 
 848 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
 849   delete _owned_locks;
 850 }
 851 
 852 void ThreadConcurrentLocks::add_lock(instanceOop o) {
 853   _owned_locks-&gt;append(o);
 854 }
 855 
 856 void ThreadConcurrentLocks::oops_do(OopClosure* f) {
 857   int length = _owned_locks-&gt;length();
 858   for (int i = 0; i &lt; length; i++) {
 859     f-&gt;do_oop((oop*) _owned_locks-&gt;adr_at(i));
 860   }
 861 }
 862 
 863 ThreadStatistics::ThreadStatistics() {
 864   _contended_enter_count = 0;
 865   _monitor_wait_count = 0;
 866   _sleep_count = 0;
 867   _count_pending_reset = false;
 868   _timer_pending_reset = false;
 869   memset((void*) _perf_recursion_counts, 0, sizeof(_perf_recursion_counts));
 870 }
 871 
 872 void ThreadSnapshot::initialize(ThreadsList * t_list, JavaThread* thread) {
 873   _thread = thread;
 874   _threadObj = thread-&gt;threadObj();
 875 
 876   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 877   _contended_enter_ticks = stat-&gt;contended_enter_ticks();
 878   _contended_enter_count = stat-&gt;contended_enter_count();
 879   _monitor_wait_ticks = stat-&gt;monitor_wait_ticks();
 880   _monitor_wait_count = stat-&gt;monitor_wait_count();
 881   _sleep_ticks = stat-&gt;sleep_ticks();
 882   _sleep_count = stat-&gt;sleep_count();
 883 
 884   _thread_status = java_lang_Thread::get_thread_status(_threadObj);
 885   _is_ext_suspended = thread-&gt;is_being_ext_suspended();
 886   _is_in_native = (thread-&gt;thread_state() == _thread_in_native);
 887 
 888   if (_thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER ||
 889       _thread_status == java_lang_Thread::IN_OBJECT_WAIT ||
 890       _thread_status == java_lang_Thread::IN_OBJECT_WAIT_TIMED) {
 891 
 892     Handle obj = ThreadService::get_current_contended_monitor(thread);
 893     if (obj() == NULL) {
 894       // monitor no longer exists; thread is not blocked
 895       _thread_status = java_lang_Thread::RUNNABLE;
 896     } else {
 897       _blocker_object = obj();
 898       JavaThread* owner = ObjectSynchronizer::get_lock_owner(t_list, obj);
 899       if ((owner == NULL &amp;&amp; _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
 900           || (owner != NULL &amp;&amp; owner-&gt;is_attaching_via_jni())) {
 901         // ownership information of the monitor is not available
 902         // (may no longer be owned or releasing to some other thread)
 903         // make this thread in RUNNABLE state.
 904         // And when the owner thread is in attaching state, the java thread
 905         // is not completely initialized. For example thread name and id
 906         // and may not be set, so hide the attaching thread.
 907         _thread_status = java_lang_Thread::RUNNABLE;
 908         _blocker_object = NULL;
 909       } else if (owner != NULL) {
 910         _blocker_object_owner = owner-&gt;threadObj();
 911       }
 912     }
 913   }
 914 
 915   // Support for JSR-166 locks
<a name="13" id="anc13"></a><span class="line-modified"> 916   if (_thread_status == java_lang_Thread::PARKED || _thread_status == java_lang_Thread::PARKED_TIMED) {</span>



 917     _blocker_object = thread-&gt;current_park_blocker();
 918     if (_blocker_object != NULL &amp;&amp; _blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 919       _blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(_blocker_object);
 920     }
 921   }
 922 }
 923 
 924 ThreadSnapshot::~ThreadSnapshot() {
 925   delete _stack_trace;
 926   delete _concurrent_locks;
 927 }
 928 
 929 void ThreadSnapshot::dump_stack_at_safepoint(int max_depth, bool with_locked_monitors) {
 930   _stack_trace = new ThreadStackTrace(_thread, with_locked_monitors);
 931   _stack_trace-&gt;dump_stack_at_safepoint(max_depth);
 932 }
 933 
 934 
 935 void ThreadSnapshot::oops_do(OopClosure* f) {
 936   f-&gt;do_oop(&amp;_threadObj);
 937   f-&gt;do_oop(&amp;_blocker_object);
 938   f-&gt;do_oop(&amp;_blocker_object_owner);
 939   if (_stack_trace != NULL) {
 940     _stack_trace-&gt;oops_do(f);
 941   }
 942   if (_concurrent_locks != NULL) {
 943     _concurrent_locks-&gt;oops_do(f);
 944   }
 945 }
 946 
 947 void ThreadSnapshot::metadata_do(void f(Metadata*)) {
 948   if (_stack_trace != NULL) {
 949     _stack_trace-&gt;metadata_do(f);
 950   }
 951 }
 952 
 953 
 954 DeadlockCycle::DeadlockCycle() {
 955   _is_deadlock = false;
 956   _threads = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, true);
 957   _next = NULL;
 958 }
 959 
 960 DeadlockCycle::~DeadlockCycle() {
 961   delete _threads;
 962 }
 963 
 964 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 965   st-&gt;cr();
 966   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 967   st-&gt;print(&quot;=============================&quot;);
 968 
 969   JavaThread* currentThread;
 970   ObjectMonitor* waitingToLockMonitor;
<a name="14" id="anc14"></a><span class="line-added"> 971   JvmtiRawMonitor* waitingToLockRawMonitor;</span>
 972   oop waitingToLockBlocker;
 973   int len = _threads-&gt;length();
 974   for (int i = 0; i &lt; len; i++) {
 975     currentThread = _threads-&gt;at(i);
<a name="15" id="anc15"></a><span class="line-modified"> 976     waitingToLockMonitor = currentThread-&gt;current_pending_monitor();</span>
<span class="line-added"> 977     waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();</span>
 978     waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 979     st-&gt;cr();
 980     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
 981     const char* owner_desc = &quot;,\n  which is held by&quot;;
<a name="16" id="anc16"></a><span class="line-added"> 982 </span>
<span class="line-added"> 983     // Note: As the JVM TI &quot;monitor contended enter&quot; event callback is executed after ObjectMonitor</span>
<span class="line-added"> 984     // sets the current pending monitor, it is possible to then see a pending raw monitor as well.</span>
<span class="line-added"> 985     if (waitingToLockRawMonitor != NULL) {</span>
<span class="line-added"> 986       st-&gt;print(&quot;  waiting to lock JVM TI raw monitor &quot; INTPTR_FORMAT, p2i(waitingToLockRawMonitor));</span>
<span class="line-added"> 987       Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="line-added"> 988       // Could be NULL as the raw monitor could be released at any time if held by non-JavaThread</span>
<span class="line-added"> 989       if (owner != NULL) {</span>
<span class="line-added"> 990         if (owner-&gt;is_Java_thread()) {</span>
<span class="line-added"> 991           currentThread = (JavaThread*) owner;</span>
<span class="line-added"> 992           st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
<span class="line-added"> 993         } else {</span>
<span class="line-added"> 994           st-&gt;print_cr(&quot;,\n  which has now been released&quot;);</span>
<span class="line-added"> 995         }</span>
<span class="line-added"> 996       } else {</span>
<span class="line-added"> 997         st-&gt;print_cr(&quot;%s non-Java thread=&quot; PTR_FORMAT, owner_desc, p2i(owner));</span>
<span class="line-added"> 998       }</span>
<span class="line-added"> 999     }</span>
<span class="line-added">1000 </span>
1001     if (waitingToLockMonitor != NULL) {
1002       st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
1003       oop obj = (oop)waitingToLockMonitor-&gt;object();
<a name="17" id="anc17"></a><span class="line-modified">1004       st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),</span>
<span class="line-modified">1005                  obj-&gt;klass()-&gt;external_name());</span>

1006 
<a name="18" id="anc18"></a><span class="line-modified">1007       if (!currentThread-&gt;current_pending_monitor_is_from_java()) {</span>
<span class="line-modified">1008         owner_desc = &quot;\n  in JNI, which is held by&quot;;</span>




1009       }
1010       currentThread = Threads::owning_thread_from_monitor_owner(t_list,
1011                                                                 (address)waitingToLockMonitor-&gt;owner());
1012       if (currentThread == NULL) {
1013         // The deadlock was detected at a safepoint so the JavaThread
1014         // that owns waitingToLockMonitor should be findable, but
1015         // if it is not findable, then the previous currentThread is
1016         // blocked permanently.
<a name="19" id="anc19"></a><span class="line-modified">1017         st-&gt;print_cr(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,</span>
1018                   p2i(waitingToLockMonitor-&gt;owner()));
1019         continue;
1020       }
1021     } else {
1022       st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
1023                 p2i(waitingToLockBlocker),
1024                 waitingToLockBlocker-&gt;klass()-&gt;external_name());
1025       assert(waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass()),
1026              &quot;Must be an AbstractOwnableSynchronizer&quot;);
1027       oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
1028       currentThread = java_lang_Thread::thread(ownerObj);
1029       assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
1030     }
<a name="20" id="anc20"></a><span class="line-modified">1031     st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
1032   }
1033 
<a name="21" id="anc21"></a>
1034   st-&gt;cr();
1035 
1036   // Print stack traces
1037   bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
1038   JavaMonitorsInStackTrace = true;
1039   st-&gt;print_cr(&quot;Java stack information for the threads listed above:&quot;);
1040   st-&gt;print_cr(&quot;===================================================&quot;);
1041   for (int j = 0; j &lt; len; j++) {
1042     currentThread = _threads-&gt;at(j);
1043     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
1044     currentThread-&gt;print_stack_on(st);
1045   }
1046   JavaMonitorsInStackTrace = oldJavaMonitorsInStackTrace;
1047 }
1048 
1049 ThreadsListEnumerator::ThreadsListEnumerator(Thread* cur_thread,
1050                                              bool include_jvmti_agent_threads,
1051                                              bool include_jni_attaching_threads) {
1052   assert(cur_thread == Thread::current(), &quot;Check current thread&quot;);
1053 
1054   int init_size = ThreadService::get_live_thread_count();
1055   _threads_array = new GrowableArray&lt;instanceHandle&gt;(init_size);
1056 
1057   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
1058     // skips JavaThreads in the process of exiting
1059     // and also skips VM internal JavaThreads
1060     // Threads in _thread_new or _thread_new_trans state are included.
1061     // i.e. threads have been started but not yet running.
1062     if (jt-&gt;threadObj() == NULL   ||
1063         jt-&gt;is_exiting() ||
1064         !java_lang_Thread::is_alive(jt-&gt;threadObj())   ||
1065         jt-&gt;is_hidden_from_external_view()) {
1066       continue;
1067     }
1068 
1069     // skip agent threads
1070     if (!include_jvmti_agent_threads &amp;&amp; jt-&gt;is_jvmti_agent_thread()) {
1071       continue;
1072     }
1073 
1074     // skip jni threads in the process of attaching
1075     if (!include_jni_attaching_threads &amp;&amp; jt-&gt;is_attaching_via_jni()) {
1076       continue;
1077     }
1078 
1079     instanceHandle h(cur_thread, (instanceOop) jt-&gt;threadObj());
1080     _threads_array-&gt;append(h);
1081   }
1082 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
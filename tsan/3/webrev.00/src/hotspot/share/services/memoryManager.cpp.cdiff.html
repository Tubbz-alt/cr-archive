<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/services/memoryManager.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memTracker.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memoryManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;services/lowMemoryDetector.hpp&quot;
  #include &quot;services/management.hpp&quot;
  #include &quot;services/memoryManager.hpp&quot;
  #include &quot;services/memoryPool.hpp&quot;
  #include &quot;services/memoryService.hpp&quot;
<span class="line-new-header">--- 25,13 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;services/lowMemoryDetector.hpp&quot;
  #include &quot;services/management.hpp&quot;
  #include &quot;services/memoryManager.hpp&quot;
  #include &quot;services/memoryPool.hpp&quot;
  #include &quot;services/memoryService.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,11 ***</span>
  }
  
  instanceOop MemoryManager::get_memory_manager_instance(TRAPS) {
    // Must do an acquire so as to force ordering of subsequent
    // loads from anything _memory_mgr_obj points to or implies.
<span class="line-modified">!   instanceOop mgr_obj = OrderAccess::load_acquire(&amp;_memory_mgr_obj);</span>
    if (mgr_obj == NULL) {
      // It&#39;s ok for more than one thread to execute the code up to the locked region.
      // Extra manager instances will just be gc&#39;ed.
      Klass* k = Management::sun_management_ManagementFactoryHelper_klass(CHECK_0);
  
<span class="line-new-header">--- 63,11 ---</span>
  }
  
  instanceOop MemoryManager::get_memory_manager_instance(TRAPS) {
    // Must do an acquire so as to force ordering of subsequent
    // loads from anything _memory_mgr_obj points to or implies.
<span class="line-modified">!   instanceOop mgr_obj = Atomic::load_acquire(&amp;_memory_mgr_obj);</span>
    if (mgr_obj == NULL) {
      // It&#39;s ok for more than one thread to execute the code up to the locked region.
      // Extra manager instances will just be gc&#39;ed.
      Klass* k = Management::sun_management_ManagementFactoryHelper_klass(CHECK_0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,19 ***</span>
      instanceHandle mgr(THREAD, m);
  
      {
        // Get lock before setting _memory_mgr_obj
        // since another thread may have created the instance
<span class="line-modified">!       MutexLocker ml(Management_lock);</span>
  
        // Check if another thread has created the management object.  We reload
        // _memory_mgr_obj here because some other thread may have initialized
        // it while we were executing the code before the lock.
        //
        // The lock has done an acquire, so the load can&#39;t float above it, but
        // we need to do a load_acquire as above.
<span class="line-modified">!       mgr_obj = OrderAccess::load_acquire(&amp;_memory_mgr_obj);</span>
        if (mgr_obj != NULL) {
           return mgr_obj;
        }
  
        // Get the address of the object we created via call_special.
<span class="line-new-header">--- 108,19 ---</span>
      instanceHandle mgr(THREAD, m);
  
      {
        // Get lock before setting _memory_mgr_obj
        // since another thread may have created the instance
<span class="line-modified">!       MutexLocker ml(THREAD, Management_lock);</span>
  
        // Check if another thread has created the management object.  We reload
        // _memory_mgr_obj here because some other thread may have initialized
        // it while we were executing the code before the lock.
        //
        // The lock has done an acquire, so the load can&#39;t float above it, but
        // we need to do a load_acquire as above.
<span class="line-modified">!       mgr_obj = Atomic::load_acquire(&amp;_memory_mgr_obj);</span>
        if (mgr_obj != NULL) {
           return mgr_obj;
        }
  
        // Get the address of the object we created via call_special.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,11 ***</span>
  
        // Use store barrier to make sure the memory accesses associated
        // with creating the management object are visible before publishing
        // its address.  The unlock will publish the store to _memory_mgr_obj
        // because it does a release first.
<span class="line-modified">!       OrderAccess::release_store(&amp;_memory_mgr_obj, mgr_obj);</span>
      }
    }
  
    return mgr_obj;
  }
<span class="line-new-header">--- 128,11 ---</span>
  
        // Use store barrier to make sure the memory accesses associated
        // with creating the management object are visible before publishing
        // its address.  The unlock will publish the store to _memory_mgr_obj
        // because it does a release first.
<span class="line-modified">!       Atomic::release_store(&amp;_memory_mgr_obj, mgr_obj);</span>
      }
    }
  
    return mgr_obj;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,12 ***</span>
    f-&gt;do_oop((oop*) &amp;_memory_mgr_obj);
  }
  
  GCStatInfo::GCStatInfo(int num_pools) {
    // initialize the arrays for memory usage
<span class="line-modified">!   _before_gc_usage_array = (MemoryUsage*) NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);</span>
<span class="line-modified">!   _after_gc_usage_array  = (MemoryUsage*) NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);</span>
    _usage_array_size = num_pools;
    clear();
  }
  
  GCStatInfo::~GCStatInfo() {
<span class="line-new-header">--- 141,12 ---</span>
    f-&gt;do_oop((oop*) &amp;_memory_mgr_obj);
  }
  
  GCStatInfo::GCStatInfo(int num_pools) {
    // initialize the arrays for memory usage
<span class="line-modified">!   _before_gc_usage_array = NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);</span>
<span class="line-modified">!   _after_gc_usage_array  = NEW_C_HEAP_ARRAY(MemoryUsage, num_pools, mtInternal);</span>
    _usage_array_size = num_pools;
    clear();
  }
  
  GCStatInfo::~GCStatInfo() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
  GCMemoryManager::GCMemoryManager(const char* name, const char* gc_end_message) :
    MemoryManager(name), _gc_end_message(gc_end_message) {
    _num_collections = 0;
    _last_gc_stat = NULL;
    _last_gc_lock = new Mutex(Mutex::leaf, &quot;_last_gc_lock&quot;, true,
<span class="line-modified">!                             Monitor::_safepoint_check_never);</span>
    _current_gc_stat = NULL;
    _num_gc_threads = 1;
    _notification_enabled = false;
  }
  
<span class="line-new-header">--- 176,11 ---</span>
  GCMemoryManager::GCMemoryManager(const char* name, const char* gc_end_message) :
    MemoryManager(name), _gc_end_message(gc_end_message) {
    _num_collections = 0;
    _last_gc_stat = NULL;
    _last_gc_lock = new Mutex(Mutex::leaf, &quot;_last_gc_lock&quot;, true,
<span class="line-modified">!                             Mutex::_safepoint_check_never);</span>
    _current_gc_stat = NULL;
    _num_gc_threads = 1;
    _notification_enabled = false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,11 ***</span>
  
    if (countCollection) {
      _num_collections++;
      // alternately update two objects making one public when complete
      {
<span class="line-modified">!       MutexLockerEx ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);</span>
        GCStatInfo *tmp = _last_gc_stat;
        _last_gc_stat = _current_gc_stat;
        _current_gc_stat = tmp;
        // reset the current stat for diagnosability purposes
        _current_gc_stat-&gt;clear();
<span class="line-new-header">--- 280,11 ---</span>
  
    if (countCollection) {
      _num_collections++;
      // alternately update two objects making one public when complete
      {
<span class="line-modified">!       MutexLocker ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);</span>
        GCStatInfo *tmp = _last_gc_stat;
        _last_gc_stat = _current_gc_stat;
        _current_gc_stat = tmp;
        // reset the current stat for diagnosability purposes
        _current_gc_stat-&gt;clear();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,11 ***</span>
      }
    }
  }
  
  size_t GCMemoryManager::get_last_gc_stat(GCStatInfo* dest) {
<span class="line-modified">!   MutexLockerEx ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_last_gc_stat-&gt;gc_index() != 0) {
      dest-&gt;set_index(_last_gc_stat-&gt;gc_index());
      dest-&gt;set_start_time(_last_gc_stat-&gt;start_time());
      dest-&gt;set_end_time(_last_gc_stat-&gt;end_time());
      assert(dest-&gt;usage_array_size() == _last_gc_stat-&gt;usage_array_size(),
<span class="line-new-header">--- 295,11 ---</span>
      }
    }
  }
  
  size_t GCMemoryManager::get_last_gc_stat(GCStatInfo* dest) {
<span class="line-modified">!   MutexLocker ml(_last_gc_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_last_gc_stat-&gt;gc_index() != 0) {
      dest-&gt;set_index(_last_gc_stat-&gt;gc_index());
      dest-&gt;set_start_time(_last_gc_stat-&gt;start_time());
      dest-&gt;set_end_time(_last_gc_stat-&gt;end_time());
      assert(dest-&gt;usage_array_size() == _last_gc_stat-&gt;usage_array_size(),
</pre>
<center><a href="memTracker.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
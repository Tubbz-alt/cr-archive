<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/diagnosticFramework.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="diagnosticCommand.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dtraceAttacher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/diagnosticFramework.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
420   _dcmdparser.print_help(output(), name);
421 }
422 
423 void DCmdWithParser::reset(TRAPS) {
424   _dcmdparser.reset(CHECK);
425 }
426 
427 void DCmdWithParser::cleanup() {
428   _dcmdparser.cleanup();
429 }
430 
431 GrowableArray&lt;const char*&gt;* DCmdWithParser::argument_name_array() const {
432   return _dcmdparser.argument_name_array();
433 }
434 
435 GrowableArray&lt;DCmdArgumentInfo*&gt;* DCmdWithParser::argument_info_array() const {
436   return _dcmdparser.argument_info_array();
437 }
438 
439 void DCmdFactory::push_jmx_notification_request() {
<span class="line-modified">440   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
441   _has_pending_jmx_notification = true;
<span class="line-modified">442   Service_lock-&gt;notify_all();</span>
443 }
444 
445 void DCmdFactory::send_notification(TRAPS) {
446   DCmdFactory::send_notification_internal(THREAD);
447   // Clearing pending exception to avoid premature termination of
448   // the service thread
449   if (HAS_PENDING_EXCEPTION) {
450     CLEAR_PENDING_EXCEPTION;
451   }
452 }
453 void DCmdFactory::send_notification_internal(TRAPS) {
454   ResourceMark rm(THREAD);
455   HandleMark hm(THREAD);
456   bool notif = false;
457   {
<span class="line-modified">458     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
459     notif = _has_pending_jmx_notification;
460     _has_pending_jmx_notification = false;
461   }
462   if (notif) {
463 
464     Klass* k = Management::com_sun_management_internal_DiagnosticCommandImpl_klass(CHECK);
465     InstanceKlass* dcmd_mbean_klass = InstanceKlass::cast(k);
466 
467     JavaValue result(T_OBJECT);
468     JavaCalls::call_static(&amp;result,
469             dcmd_mbean_klass,
470             vmSymbols::getDiagnosticCommandMBean_name(),
471             vmSymbols::getDiagnosticCommandMBean_signature(),
472             CHECK);
473 
474     instanceOop m = (instanceOop) result.get_jobject();
475     instanceHandle dcmd_mbean_h(THREAD, m);
476 
477     if (!dcmd_mbean_h-&gt;is_a(k)) {
478       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
479               &quot;DiagnosticCommandImpl.getDiagnosticCommandMBean didn&#39;t return a DiagnosticCommandMBean instance&quot;);
480     }
481 
482     JavaValue result2(T_VOID);
483     JavaCallArguments args2(dcmd_mbean_h);
484 
485     JavaCalls::call_virtual(&amp;result2,
486             dcmd_mbean_klass,
487             vmSymbols::createDiagnosticFrameworkNotification_name(),
488             vmSymbols::void_method_signature(),
489             &amp;args2,
490             CHECK);
491   }
492 }
493 
494 bool DCmdFactory::_send_jmx_notification = false;
495 
496 DCmdFactory* DCmdFactory::factory(DCmdSource source, const char* name, size_t len) {
<span class="line-modified">497   MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
498   DCmdFactory* factory = _DCmdFactoryList;
499   while (factory != NULL) {
500     if (strlen(factory-&gt;name()) == len &amp;&amp;
501         strncmp(name, factory-&gt;name(), len) == 0) {
502       if(factory-&gt;export_flags() &amp; source) {
503         return factory;
504       } else {
505         return NULL;
506       }
507     }
508     factory = factory-&gt;_next;
509   }
510   return NULL;
511 }
512 
513 int DCmdFactory::register_DCmdFactory(DCmdFactory* factory) {
<span class="line-modified">514   MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
515   factory-&gt;_next = _DCmdFactoryList;
516   _DCmdFactoryList = factory;
517   if (_send_jmx_notification &amp;&amp; !factory-&gt;_hidden
518       &amp;&amp; (factory-&gt;_export_flags &amp; DCmd_Source_MBean)) {
519     DCmdFactory::push_jmx_notification_request();
520   }
521   return 0; // Actually, there&#39;s no checks for duplicates
522 }
523 
524 DCmd* DCmdFactory::create_local_DCmd(DCmdSource source, CmdLine &amp;line,
525                                      outputStream* out, TRAPS) {
526   DCmdFactory* f = factory(source, line.cmd_addr(), line.cmd_len());
527   if (f != NULL) {
528     if (!f-&gt;is_enabled()) {
529       THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
530                      f-&gt;disabled_message());
531     }
532     return f-&gt;create_resource_instance(out);
533   }
534   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
535              &quot;Unknown diagnostic command&quot;);
536 }
537 
538 GrowableArray&lt;const char*&gt;* DCmdFactory::DCmd_list(DCmdSource source) {
<span class="line-modified">539   MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
540   GrowableArray&lt;const char*&gt;* array = new GrowableArray&lt;const char*&gt;();
541   DCmdFactory* factory = _DCmdFactoryList;
542   while (factory != NULL) {
543     if (!factory-&gt;is_hidden() &amp;&amp; (factory-&gt;export_flags() &amp; source)) {
544       array-&gt;append(factory-&gt;name());
545     }
546     factory = factory-&gt;next();
547   }
548   return array;
549 }
550 
551 GrowableArray&lt;DCmdInfo*&gt;* DCmdFactory::DCmdInfo_list(DCmdSource source ) {
<span class="line-modified">552   MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
553   GrowableArray&lt;DCmdInfo*&gt;* array = new GrowableArray&lt;DCmdInfo*&gt;();
554   DCmdFactory* factory = _DCmdFactoryList;
555   while (factory != NULL) {
556     if (!factory-&gt;is_hidden() &amp;&amp; (factory-&gt;export_flags() &amp; source)) {
557       array-&gt;append(new DCmdInfo(factory-&gt;name(),
558                     factory-&gt;description(), factory-&gt;impact(),
559                     factory-&gt;permission(), factory-&gt;num_arguments(),
560                     factory-&gt;is_enabled()));
561     }
562     factory = factory-&gt;next();
563   }
564   return array;
565 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
420   _dcmdparser.print_help(output(), name);
421 }
422 
423 void DCmdWithParser::reset(TRAPS) {
424   _dcmdparser.reset(CHECK);
425 }
426 
427 void DCmdWithParser::cleanup() {
428   _dcmdparser.cleanup();
429 }
430 
431 GrowableArray&lt;const char*&gt;* DCmdWithParser::argument_name_array() const {
432   return _dcmdparser.argument_name_array();
433 }
434 
435 GrowableArray&lt;DCmdArgumentInfo*&gt;* DCmdWithParser::argument_info_array() const {
436   return _dcmdparser.argument_info_array();
437 }
438 
439 void DCmdFactory::push_jmx_notification_request() {
<span class="line-modified">440   MutexLocker ml(Notification_lock, Mutex::_no_safepoint_check_flag);</span>
441   _has_pending_jmx_notification = true;
<span class="line-modified">442   Notification_lock-&gt;notify_all();</span>
443 }
444 
445 void DCmdFactory::send_notification(TRAPS) {
446   DCmdFactory::send_notification_internal(THREAD);
447   // Clearing pending exception to avoid premature termination of
448   // the service thread
449   if (HAS_PENDING_EXCEPTION) {
450     CLEAR_PENDING_EXCEPTION;
451   }
452 }
453 void DCmdFactory::send_notification_internal(TRAPS) {
454   ResourceMark rm(THREAD);
455   HandleMark hm(THREAD);
456   bool notif = false;
457   {
<span class="line-modified">458     MutexLocker ml(THREAD, Notification_lock, Mutex::_no_safepoint_check_flag);</span>
459     notif = _has_pending_jmx_notification;
460     _has_pending_jmx_notification = false;
461   }
462   if (notif) {
463 
464     Klass* k = Management::com_sun_management_internal_DiagnosticCommandImpl_klass(CHECK);
465     InstanceKlass* dcmd_mbean_klass = InstanceKlass::cast(k);
466 
467     JavaValue result(T_OBJECT);
468     JavaCalls::call_static(&amp;result,
469             dcmd_mbean_klass,
470             vmSymbols::getDiagnosticCommandMBean_name(),
471             vmSymbols::getDiagnosticCommandMBean_signature(),
472             CHECK);
473 
474     instanceOop m = (instanceOop) result.get_jobject();
475     instanceHandle dcmd_mbean_h(THREAD, m);
476 
477     if (!dcmd_mbean_h-&gt;is_a(k)) {
478       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
479               &quot;DiagnosticCommandImpl.getDiagnosticCommandMBean didn&#39;t return a DiagnosticCommandMBean instance&quot;);
480     }
481 
482     JavaValue result2(T_VOID);
483     JavaCallArguments args2(dcmd_mbean_h);
484 
485     JavaCalls::call_virtual(&amp;result2,
486             dcmd_mbean_klass,
487             vmSymbols::createDiagnosticFrameworkNotification_name(),
488             vmSymbols::void_method_signature(),
489             &amp;args2,
490             CHECK);
491   }
492 }
493 
494 bool DCmdFactory::_send_jmx_notification = false;
495 
496 DCmdFactory* DCmdFactory::factory(DCmdSource source, const char* name, size_t len) {
<span class="line-modified">497   MutexLocker ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
498   DCmdFactory* factory = _DCmdFactoryList;
499   while (factory != NULL) {
500     if (strlen(factory-&gt;name()) == len &amp;&amp;
501         strncmp(name, factory-&gt;name(), len) == 0) {
502       if(factory-&gt;export_flags() &amp; source) {
503         return factory;
504       } else {
505         return NULL;
506       }
507     }
508     factory = factory-&gt;_next;
509   }
510   return NULL;
511 }
512 
513 int DCmdFactory::register_DCmdFactory(DCmdFactory* factory) {
<span class="line-modified">514   MutexLocker ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
515   factory-&gt;_next = _DCmdFactoryList;
516   _DCmdFactoryList = factory;
517   if (_send_jmx_notification &amp;&amp; !factory-&gt;_hidden
518       &amp;&amp; (factory-&gt;_export_flags &amp; DCmd_Source_MBean)) {
519     DCmdFactory::push_jmx_notification_request();
520   }
521   return 0; // Actually, there&#39;s no checks for duplicates
522 }
523 
524 DCmd* DCmdFactory::create_local_DCmd(DCmdSource source, CmdLine &amp;line,
525                                      outputStream* out, TRAPS) {
526   DCmdFactory* f = factory(source, line.cmd_addr(), line.cmd_len());
527   if (f != NULL) {
528     if (!f-&gt;is_enabled()) {
529       THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
530                      f-&gt;disabled_message());
531     }
532     return f-&gt;create_resource_instance(out);
533   }
534   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
535              &quot;Unknown diagnostic command&quot;);
536 }
537 
538 GrowableArray&lt;const char*&gt;* DCmdFactory::DCmd_list(DCmdSource source) {
<span class="line-modified">539   MutexLocker ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
540   GrowableArray&lt;const char*&gt;* array = new GrowableArray&lt;const char*&gt;();
541   DCmdFactory* factory = _DCmdFactoryList;
542   while (factory != NULL) {
543     if (!factory-&gt;is_hidden() &amp;&amp; (factory-&gt;export_flags() &amp; source)) {
544       array-&gt;append(factory-&gt;name());
545     }
546     factory = factory-&gt;next();
547   }
548   return array;
549 }
550 
551 GrowableArray&lt;DCmdInfo*&gt;* DCmdFactory::DCmdInfo_list(DCmdSource source ) {
<span class="line-modified">552   MutexLocker ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);</span>
553   GrowableArray&lt;DCmdInfo*&gt;* array = new GrowableArray&lt;DCmdInfo*&gt;();
554   DCmdFactory* factory = _DCmdFactoryList;
555   while (factory != NULL) {
556     if (!factory-&gt;is_hidden() &amp;&amp; (factory-&gt;export_flags() &amp; source)) {
557       array-&gt;append(new DCmdInfo(factory-&gt;name(),
558                     factory-&gt;description(), factory-&gt;impact(),
559                     factory-&gt;permission(), factory-&gt;num_arguments(),
560                     factory-&gt;is_enabled()));
561     }
562     factory = factory-&gt;next();
563   }
564   return array;
565 }
</pre>
</td>
</tr>
</table>
<center><a href="diagnosticCommand.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dtraceAttacher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/memTracker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memTracker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 42   };
 43   Tracker(enum TrackerType type) : _type(type) { }
 44   void record(address addr, size_t size) { }
 45  private:
 46   enum TrackerType  _type;
 47 };
 48 
 49 class MemTracker : AllStatic {
 50  public:
 51   static inline NMT_TrackingLevel tracking_level() { return NMT_off; }
 52   static inline void shutdown() { }
 53   static inline void init() { }
 54   static bool check_launcher_nmt_support(const char* value) { return true; }
 55   static bool verify_nmt_option() { return true; }
 56 
 57   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
 58     const NativeCallStack&amp; stack, NMT_TrackingLevel level) { return mem_base; }
 59   static inline size_t malloc_header_size(NMT_TrackingLevel level) { return 0; }
 60   static inline size_t malloc_header_size(void* memblock) { return 0; }
 61   static inline void* malloc_base(void* memblock) { return memblock; }
<span class="line-modified"> 62   static inline void* record_free(void* memblock) { return memblock; }</span>
 63 
 64   static inline void record_new_arena(MEMFLAGS flag) { }
 65   static inline void record_arena_free(MEMFLAGS flag) { }
<span class="line-modified"> 66   static inline void record_arena_size_change(int diff, MEMFLAGS flag) { }</span>
 67   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
 68                        MEMFLAGS flag = mtNone) { }
 69   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
 70     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) { }
 71   static inline void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack&amp; stack) { }
 72   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) { }
 73   static inline void record_thread_stack(void* addr, size_t size) { }
 74   static inline void release_thread_stack(void* addr, size_t size) { }
 75 
 76   static void final_report(outputStream*) { }
 77   static void error_report(outputStream*) { }
 78 };
 79 
 80 #else
 81 
 82 #include &quot;runtime/mutexLocker.hpp&quot;
 83 #include &quot;runtime/threadCritical.hpp&quot;
 84 #include &quot;services/mallocTracker.hpp&quot;

 85 #include &quot;services/virtualMemoryTracker.hpp&quot;
 86 
 87 extern volatile bool NMT_stack_walkable;
 88 
 89 #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ? \
 90                     NativeCallStack(0, true) : NativeCallStack::empty_stack())
 91 #define CALLER_PC  ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ?  \
 92                     NativeCallStack(1, true) : NativeCallStack::empty_stack())
 93 
 94 class MemBaseline;
 95 
 96 // Tracker is used for guarding &#39;release&#39; semantics of virtual memory operation, to avoid
 97 // the other thread obtains and records the same region that is just &#39;released&#39; by current
 98 // thread but before it can record the operation.
 99 class Tracker : public StackObj {
100  public:
101   enum TrackerType {
102      uncommit,
103      release
104   };
</pre>
<hr />
<pre>
139   // is used.
140   // If an incompatible launcher is used, NMT may not be
141   // able to start, even it is enabled by command line option.
142   // A warning message should be given if it is encountered.
143   static bool check_launcher_nmt_support(const char* value);
144 
145   // This method checks native memory tracking environment
146   // variable value passed by launcher.
147   // Launcher only obligated to pass native memory tracking
148   // option value, but not obligated to validate the value,
149   // and launcher has option to discard native memory tracking
150   // option from the command line once it sets up the environment
151   // variable, so NMT has to catch the bad value here.
152   static bool verify_nmt_option();
153 
154   // Transition the tracking level to specified level
155   static bool transition_to(NMT_TrackingLevel level);
156 
157   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
158     const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
<span class="line-modified">159     return MallocTracker::record_malloc(mem_base, size, flag, stack, level);</span>



160   }
161 
162   static inline size_t malloc_header_size(NMT_TrackingLevel level) {
163     return MallocTracker::malloc_header_size(level);
164   }
165 
166   static size_t malloc_header_size(void* memblock) {
167     if (tracking_level() != NMT_off) {
168       return MallocTracker::get_header_size(memblock);
169     }
170     return 0;
171   }
172 
173   // To malloc base address, which is the starting address
174   // of malloc tracking header if tracking is enabled.
175   // Otherwise, it returns the same address.
176   static void* malloc_base(void* memblock);
177 
178   // Record malloc free and return malloc base address
<span class="line-modified">179   static inline void* record_free(void* memblock) {</span>




180     return MallocTracker::record_free(memblock);
181   }
182 
183 
184   // Record creation of an arena
185   static inline void record_new_arena(MEMFLAGS flag) {
186     if (tracking_level() &lt; NMT_summary) return;
187     MallocTracker::record_new_arena(flag);
188   }
189 
190   // Record destruction of an arena
191   static inline void record_arena_free(MEMFLAGS flag) {
192     if (tracking_level() &lt; NMT_summary) return;
193     MallocTracker::record_arena_free(flag);
194   }
195 
196   // Record arena size change. Arena size is the size of all arena
197   // chuncks that backing up the arena.
<span class="line-modified">198   static inline void record_arena_size_change(int diff, MEMFLAGS flag) {</span>
199     if (tracking_level() &lt; NMT_summary) return;
200     MallocTracker::record_arena_size_change(diff, flag);
201   }
202 
203   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
204     MEMFLAGS flag = mtNone) {
205     if (tracking_level() &lt; NMT_summary) return;
206     if (addr != NULL) {
207       ThreadCritical tc;
208       // Recheck to avoid potential racing during NMT shutdown
209       if (tracking_level() &lt; NMT_summary) return;
210       VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);
211     }
212   }
213 
214   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
215     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) {
216     if (tracking_level() &lt; NMT_summary) return;
217     if (addr != NULL) {
218       ThreadCritical tc;
</pre>
<hr />
<pre>
224 
225   static inline void record_virtual_memory_commit(void* addr, size_t size,
226     const NativeCallStack&amp; stack) {
227     if (tracking_level() &lt; NMT_summary) return;
228     if (addr != NULL) {
229       ThreadCritical tc;
230       if (tracking_level() &lt; NMT_summary) return;
231       VirtualMemoryTracker::add_committed_region((address)addr, size, stack);
232     }
233   }
234 
235   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) {
236     if (tracking_level() &lt; NMT_summary) return;
237     if (addr != NULL) {
238       ThreadCritical tc;
239       if (tracking_level() &lt; NMT_summary) return;
240       VirtualMemoryTracker::set_reserved_region_type((address)addr, flag);
241     }
242   }
243 
<span class="line-modified">244 #ifdef _AIX</span>
<span class="line-removed">245   // See JDK-8202772 - temporarily disable thread stack tracking on AIX.</span>
<span class="line-removed">246   static inline void record_thread_stack(void* addr, size_t size) {}</span>
<span class="line-removed">247   static inline void release_thread_stack(void* addr, size_t size) {}</span>
<span class="line-removed">248 #else</span>
<span class="line-removed">249   static inline void record_thread_stack(void* addr, size_t size) {</span>
250     if (tracking_level() &lt; NMT_summary) return;
251     if (addr != NULL) {
<span class="line-modified">252       // uses thread stack malloc slot for book keeping number of threads</span>
<span class="line-removed">253       MallocMemorySummary::record_malloc(0, mtThreadStack);</span>
<span class="line-removed">254       record_virtual_memory_reserve(addr, size, CALLER_PC, mtThreadStack);</span>
255     }
256   }
257 
258   static inline void release_thread_stack(void* addr, size_t size) {
259     if (tracking_level() &lt; NMT_summary) return;
260     if (addr != NULL) {
<span class="line-modified">261       // uses thread stack malloc slot for book keeping number of threads</span>
<span class="line-removed">262       MallocMemorySummary::record_free(0, mtThreadStack);</span>
<span class="line-removed">263       ThreadCritical tc;</span>
<span class="line-removed">264       if (tracking_level() &lt; NMT_summary) return;</span>
<span class="line-removed">265       VirtualMemoryTracker::remove_released_region((address)addr, size);</span>
266     }
267   }
<span class="line-removed">268 #endif</span>
269 
270   // Query lock is used to synchronize the access to tracking data.
271   // So far, it is only used by JCmd query, but it may be used by
272   // other tools.
273   static inline Mutex* query_lock() {
274     assert(NMTQuery_lock != NULL, &quot;not initialized!&quot;);
275     return NMTQuery_lock;
276   }
277 
278   // Make a final report or report for hs_err file.
279   static void error_report(outputStream* output) {
280     if (tracking_level() &gt;= NMT_summary) {
281       report(true, output);  // just print summary for error case.
282     }
283    }
284 
<span class="line-modified">285   static void final_report(outputStream* output) {</span>
<span class="line-removed">286     NMT_TrackingLevel level = tracking_level();</span>
<span class="line-removed">287     if (level &gt;= NMT_summary) {</span>
<span class="line-removed">288       report(level == NMT_summary, output);</span>
<span class="line-removed">289     }</span>
<span class="line-removed">290   }</span>
<span class="line-removed">291 </span>
292 
293   // Stored baseline
294   static inline MemBaseline&amp; get_baseline() {
295     return _baseline;
296   }
297 
298   static NMT_TrackingLevel cmdline_tracking_level() {
299     return _cmdline_tracking_level;
300   }
301 
302   static void tuning_statistics(outputStream* out);
303 
304  private:
305   static NMT_TrackingLevel init_tracking_level();
306   static void report(bool summary_only, outputStream* output);
307 
308  private:
309   // Tracking level
310   static volatile NMT_TrackingLevel   _tracking_level;
311   // If NMT option value passed by launcher through environment
</pre>
</td>
<td>
<hr />
<pre>
 42   };
 43   Tracker(enum TrackerType type) : _type(type) { }
 44   void record(address addr, size_t size) { }
 45  private:
 46   enum TrackerType  _type;
 47 };
 48 
 49 class MemTracker : AllStatic {
 50  public:
 51   static inline NMT_TrackingLevel tracking_level() { return NMT_off; }
 52   static inline void shutdown() { }
 53   static inline void init() { }
 54   static bool check_launcher_nmt_support(const char* value) { return true; }
 55   static bool verify_nmt_option() { return true; }
 56 
 57   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
 58     const NativeCallStack&amp; stack, NMT_TrackingLevel level) { return mem_base; }
 59   static inline size_t malloc_header_size(NMT_TrackingLevel level) { return 0; }
 60   static inline size_t malloc_header_size(void* memblock) { return 0; }
 61   static inline void* malloc_base(void* memblock) { return memblock; }
<span class="line-modified"> 62   static inline void* record_free(void* memblock, NMT_TrackingLevel level) { return memblock; }</span>
 63 
 64   static inline void record_new_arena(MEMFLAGS flag) { }
 65   static inline void record_arena_free(MEMFLAGS flag) { }
<span class="line-modified"> 66   static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) { }</span>
 67   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
 68                        MEMFLAGS flag = mtNone) { }
 69   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
 70     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) { }
 71   static inline void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack&amp; stack) { }
 72   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) { }
 73   static inline void record_thread_stack(void* addr, size_t size) { }
 74   static inline void release_thread_stack(void* addr, size_t size) { }
 75 
 76   static void final_report(outputStream*) { }
 77   static void error_report(outputStream*) { }
 78 };
 79 
 80 #else
 81 
 82 #include &quot;runtime/mutexLocker.hpp&quot;
 83 #include &quot;runtime/threadCritical.hpp&quot;
 84 #include &quot;services/mallocTracker.hpp&quot;
<span class="line-added"> 85 #include &quot;services/threadStackTracker.hpp&quot;</span>
 86 #include &quot;services/virtualMemoryTracker.hpp&quot;
 87 
 88 extern volatile bool NMT_stack_walkable;
 89 
 90 #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ? \
 91                     NativeCallStack(0, true) : NativeCallStack::empty_stack())
 92 #define CALLER_PC  ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ?  \
 93                     NativeCallStack(1, true) : NativeCallStack::empty_stack())
 94 
 95 class MemBaseline;
 96 
 97 // Tracker is used for guarding &#39;release&#39; semantics of virtual memory operation, to avoid
 98 // the other thread obtains and records the same region that is just &#39;released&#39; by current
 99 // thread but before it can record the operation.
100 class Tracker : public StackObj {
101  public:
102   enum TrackerType {
103      uncommit,
104      release
105   };
</pre>
<hr />
<pre>
140   // is used.
141   // If an incompatible launcher is used, NMT may not be
142   // able to start, even it is enabled by command line option.
143   // A warning message should be given if it is encountered.
144   static bool check_launcher_nmt_support(const char* value);
145 
146   // This method checks native memory tracking environment
147   // variable value passed by launcher.
148   // Launcher only obligated to pass native memory tracking
149   // option value, but not obligated to validate the value,
150   // and launcher has option to discard native memory tracking
151   // option from the command line once it sets up the environment
152   // variable, so NMT has to catch the bad value here.
153   static bool verify_nmt_option();
154 
155   // Transition the tracking level to specified level
156   static bool transition_to(NMT_TrackingLevel level);
157 
158   static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
159     const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
<span class="line-modified">160     if (level != NMT_off) {</span>
<span class="line-added">161       return MallocTracker::record_malloc(mem_base, size, flag, stack, level);</span>
<span class="line-added">162     }</span>
<span class="line-added">163     return mem_base;</span>
164   }
165 
166   static inline size_t malloc_header_size(NMT_TrackingLevel level) {
167     return MallocTracker::malloc_header_size(level);
168   }
169 
170   static size_t malloc_header_size(void* memblock) {
171     if (tracking_level() != NMT_off) {
172       return MallocTracker::get_header_size(memblock);
173     }
174     return 0;
175   }
176 
177   // To malloc base address, which is the starting address
178   // of malloc tracking header if tracking is enabled.
179   // Otherwise, it returns the same address.
180   static void* malloc_base(void* memblock);
181 
182   // Record malloc free and return malloc base address
<span class="line-modified">183   static inline void* record_free(void* memblock, NMT_TrackingLevel level) {</span>
<span class="line-added">184     // Never turned on</span>
<span class="line-added">185     if (level == NMT_off || memblock == NULL) {</span>
<span class="line-added">186       return memblock;</span>
<span class="line-added">187     }</span>
188     return MallocTracker::record_free(memblock);
189   }
190 
191 
192   // Record creation of an arena
193   static inline void record_new_arena(MEMFLAGS flag) {
194     if (tracking_level() &lt; NMT_summary) return;
195     MallocTracker::record_new_arena(flag);
196   }
197 
198   // Record destruction of an arena
199   static inline void record_arena_free(MEMFLAGS flag) {
200     if (tracking_level() &lt; NMT_summary) return;
201     MallocTracker::record_arena_free(flag);
202   }
203 
204   // Record arena size change. Arena size is the size of all arena
205   // chuncks that backing up the arena.
<span class="line-modified">206   static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) {</span>
207     if (tracking_level() &lt; NMT_summary) return;
208     MallocTracker::record_arena_size_change(diff, flag);
209   }
210 
211   static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
212     MEMFLAGS flag = mtNone) {
213     if (tracking_level() &lt; NMT_summary) return;
214     if (addr != NULL) {
215       ThreadCritical tc;
216       // Recheck to avoid potential racing during NMT shutdown
217       if (tracking_level() &lt; NMT_summary) return;
218       VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, flag);
219     }
220   }
221 
222   static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
223     const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) {
224     if (tracking_level() &lt; NMT_summary) return;
225     if (addr != NULL) {
226       ThreadCritical tc;
</pre>
<hr />
<pre>
232 
233   static inline void record_virtual_memory_commit(void* addr, size_t size,
234     const NativeCallStack&amp; stack) {
235     if (tracking_level() &lt; NMT_summary) return;
236     if (addr != NULL) {
237       ThreadCritical tc;
238       if (tracking_level() &lt; NMT_summary) return;
239       VirtualMemoryTracker::add_committed_region((address)addr, size, stack);
240     }
241   }
242 
243   static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) {
244     if (tracking_level() &lt; NMT_summary) return;
245     if (addr != NULL) {
246       ThreadCritical tc;
247       if (tracking_level() &lt; NMT_summary) return;
248       VirtualMemoryTracker::set_reserved_region_type((address)addr, flag);
249     }
250   }
251 
<span class="line-modified">252   static void record_thread_stack(void* addr, size_t size) {</span>





253     if (tracking_level() &lt; NMT_summary) return;
254     if (addr != NULL) {
<span class="line-modified">255       ThreadStackTracker::new_thread_stack((address)addr, size, CALLER_PC);</span>


256     }
257   }
258 
259   static inline void release_thread_stack(void* addr, size_t size) {
260     if (tracking_level() &lt; NMT_summary) return;
261     if (addr != NULL) {
<span class="line-modified">262       ThreadStackTracker::delete_thread_stack((address)addr, size);</span>




263     }
264   }

265 
266   // Query lock is used to synchronize the access to tracking data.
267   // So far, it is only used by JCmd query, but it may be used by
268   // other tools.
269   static inline Mutex* query_lock() {
270     assert(NMTQuery_lock != NULL, &quot;not initialized!&quot;);
271     return NMTQuery_lock;
272   }
273 
274   // Make a final report or report for hs_err file.
275   static void error_report(outputStream* output) {
276     if (tracking_level() &gt;= NMT_summary) {
277       report(true, output);  // just print summary for error case.
278     }
279    }
280 
<span class="line-modified">281   static void final_report(outputStream* output);</span>






282 
283   // Stored baseline
284   static inline MemBaseline&amp; get_baseline() {
285     return _baseline;
286   }
287 
288   static NMT_TrackingLevel cmdline_tracking_level() {
289     return _cmdline_tracking_level;
290   }
291 
292   static void tuning_statistics(outputStream* out);
293 
294  private:
295   static NMT_TrackingLevel init_tracking_level();
296   static void report(bool summary_only, outputStream* output);
297 
298  private:
299   // Tracking level
300   static volatile NMT_TrackingLevel   _tracking_level;
301   // If NMT option value passed by launcher through environment
</pre>
</td>
</tr>
</table>
<center><a href="memTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
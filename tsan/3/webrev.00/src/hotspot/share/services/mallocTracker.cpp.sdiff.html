<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/mallocTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mallocSiteTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mallocTracker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/mallocTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 
<span class="line-removed"> 26 #include &quot;runtime/atomic.hpp&quot;</span>
 27 #include &quot;services/mallocSiteTable.hpp&quot;
 28 #include &quot;services/mallocTracker.hpp&quot;
 29 #include &quot;services/mallocTracker.inline.hpp&quot;
 30 #include &quot;services/memTracker.hpp&quot;
 31 
 32 size_t MallocMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(MallocMemorySnapshot, size_t)];
 33 
 34 // Total malloc&#39;d memory amount
 35 size_t MallocMemorySnapshot::total() const {
 36   size_t amount = 0;
 37   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 38     amount += _malloc[index].malloc_size();
 39   }
 40   amount += _tracking_header.size() + total_arena();
 41   return amount;
 42 }
 43 
 44 // Total malloc&#39;d memory used by arenas
 45 size_t MallocMemorySnapshot::total_arena() const {
 46   size_t amount = 0;
</pre>
<hr />
<pre>
102     return MallocSiteTable::initialize();
103   }
104   return true;
105 }
106 
107 bool MallocTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
108   assert(from != NMT_off, &quot;Can not transition from off state&quot;);
109   assert(to != NMT_off, &quot;Can not transition to off state&quot;);
110   assert (from != NMT_minimal, &quot;cannot transition from minimal state&quot;);
111 
112   if (from == NMT_detail) {
113     assert(to == NMT_minimal || to == NMT_summary, &quot;Just check&quot;);
114     MallocSiteTable::shutdown();
115   }
116   return true;
117 }
118 
119 // Record a malloc memory allocation
120 void* MallocTracker::record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,
121   const NativeCallStack&amp; stack, NMT_TrackingLevel level) {

122   void*         memblock;      // the address for user data
123   MallocHeader* header = NULL;
124 
125   if (malloc_base == NULL) {
126     return NULL;
127   }
128 
129   // Uses placement global new operator to initialize malloc header
130 
<span class="line-removed">131   if (level == NMT_off) {</span>
<span class="line-removed">132     return malloc_base;</span>
<span class="line-removed">133   }</span>
<span class="line-removed">134 </span>
135   header = ::new (malloc_base)MallocHeader(size, flags, stack, level);
136   memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));
137 
138   // The alignment check: 8 bytes alignment for 32 bit systems.
139   //                      16 bytes alignment for 64-bit systems.
140   assert(((size_t)memblock &amp; (sizeof(size_t) * 2 - 1)) == 0, &quot;Alignment check&quot;);
141 
142 #ifdef ASSERT
143   if (level &gt; NMT_minimal) {
144     // Read back
145     assert(get_size(memblock) == size,   &quot;Wrong size&quot;);
146     assert(get_flags(memblock) == flags, &quot;Wrong flags&quot;);
147   }
148 #endif
149 
150   return memblock;
151 }
152 
153 void* MallocTracker::record_free(void* memblock) {
<span class="line-modified">154   // Never turned on</span>
<span class="line-removed">155   if (MemTracker::tracking_level() == NMT_off ||</span>
<span class="line-removed">156       memblock == NULL) {</span>
<span class="line-removed">157     return memblock;</span>
<span class="line-removed">158   }</span>
159   MallocHeader* header = malloc_header(memblock);
160   header-&gt;release();
<span class="line-removed">161 </span>
162   return (void*)header;
163 }
<span class="line-removed">164 </span>
<span class="line-removed">165 </span>
</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
 25 

 26 #include &quot;services/mallocSiteTable.hpp&quot;
 27 #include &quot;services/mallocTracker.hpp&quot;
 28 #include &quot;services/mallocTracker.inline.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 
 31 size_t MallocMemorySummary::_snapshot[CALC_OBJ_SIZE_IN_TYPE(MallocMemorySnapshot, size_t)];
 32 
 33 // Total malloc&#39;d memory amount
 34 size_t MallocMemorySnapshot::total() const {
 35   size_t amount = 0;
 36   for (int index = 0; index &lt; mt_number_of_types; index ++) {
 37     amount += _malloc[index].malloc_size();
 38   }
 39   amount += _tracking_header.size() + total_arena();
 40   return amount;
 41 }
 42 
 43 // Total malloc&#39;d memory used by arenas
 44 size_t MallocMemorySnapshot::total_arena() const {
 45   size_t amount = 0;
</pre>
<hr />
<pre>
101     return MallocSiteTable::initialize();
102   }
103   return true;
104 }
105 
106 bool MallocTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
107   assert(from != NMT_off, &quot;Can not transition from off state&quot;);
108   assert(to != NMT_off, &quot;Can not transition to off state&quot;);
109   assert (from != NMT_minimal, &quot;cannot transition from minimal state&quot;);
110 
111   if (from == NMT_detail) {
112     assert(to == NMT_minimal || to == NMT_summary, &quot;Just check&quot;);
113     MallocSiteTable::shutdown();
114   }
115   return true;
116 }
117 
118 // Record a malloc memory allocation
119 void* MallocTracker::record_malloc(void* malloc_base, size_t size, MEMFLAGS flags,
120   const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
<span class="line-added">121   assert(level != NMT_off, &quot;precondition&quot;);</span>
122   void*         memblock;      // the address for user data
123   MallocHeader* header = NULL;
124 
125   if (malloc_base == NULL) {
126     return NULL;
127   }
128 
129   // Uses placement global new operator to initialize malloc header
130 




131   header = ::new (malloc_base)MallocHeader(size, flags, stack, level);
132   memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));
133 
134   // The alignment check: 8 bytes alignment for 32 bit systems.
135   //                      16 bytes alignment for 64-bit systems.
136   assert(((size_t)memblock &amp; (sizeof(size_t) * 2 - 1)) == 0, &quot;Alignment check&quot;);
137 
138 #ifdef ASSERT
139   if (level &gt; NMT_minimal) {
140     // Read back
141     assert(get_size(memblock) == size,   &quot;Wrong size&quot;);
142     assert(get_flags(memblock) == flags, &quot;Wrong flags&quot;);
143   }
144 #endif
145 
146   return memblock;
147 }
148 
149 void* MallocTracker::record_free(void* memblock) {
<span class="line-modified">150   assert(MemTracker::tracking_level() != NMT_off &amp;&amp; memblock != NULL, &quot;precondition&quot;);</span>




151   MallocHeader* header = malloc_header(memblock);
152   header-&gt;release();

153   return (void*)header;
154 }


</pre>
</td>
</tr>
</table>
<center><a href="mallocSiteTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mallocTracker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
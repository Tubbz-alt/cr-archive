<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nmtDCmd.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/threadService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,12 +27,14 @@</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/heapInspection.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/objArrayKlass.hpp&quot;</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;prims/jvmtiRawMonitor.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/objectMonitor.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,11 +97,11 @@</span>
  }
  
  void ThreadService::reset_peak_thread_count() {
    // Acquire the lock to update the peak thread count
    // to synchronize with thread addition and removal.
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Threads_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(Threads_lock);</span>
    _peak_threads_count-&gt;set_value(get_live_thread_count());
  }
  
  static bool is_hidden_thread(JavaThread *thread) {
    // hide VM internal or JVMTI agent threads
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,14 +216,14 @@</span>
      obj = (oop) wait_obj-&gt;object();
      assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
    } else {
      ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
      if (enter_obj != NULL) {
<span class="udiff-line-modified-removed">-       // thread is trying to enter() or raw_enter() an ObjectMonitor.</span>
<span class="udiff-line-modified-added">+       // thread is trying to enter() an ObjectMonitor.</span>
        obj = (oop) enter_obj-&gt;object();
<span class="udiff-line-added">+       assert(obj != NULL, &quot;ObjectMonitor should have an associated object!&quot;);</span>
      }
<span class="udiff-line-removed">-     // If obj == NULL, then ObjectMonitor is raw which doesn&#39;t count.</span>
    }
  
    Handle h(Thread::current(), obj);
    return h;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -351,17 +353,19 @@</span>
    if (stat != NULL) {
      stat-&gt;reset_time_stat();
    }
  }
  
<span class="udiff-line-modified-removed">- // Find deadlocks involving object monitors and concurrent locks if concurrent_locks is true</span>
<span class="udiff-line-modified-added">+ // Find deadlocks involving raw monitors, object monitors and concurrent locks</span>
<span class="udiff-line-added">+ // if concurrent_locks is true.</span>
  DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
  
    // This code was modified from the original Threads::find_deadlocks code.
    int globalDfn = 0, thisDfn;
    ObjectMonitor* waitingToLockMonitor = NULL;
<span class="udiff-line-added">+   JvmtiRawMonitor* waitingToLockRawMonitor = NULL;</span>
    oop waitingToLockBlocker = NULL;
    bool blocked_on_monitor = false;
    JavaThread *currentThread, *previousThread;
    int num_deadlocks = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,17 +392,34 @@</span>
      cycle-&gt;reset();
  
      // When there is a deadlock, all the monitors involved in the dependency
      // cycle must be contended and heavyweight. So we only care about the
      // heavyweight monitor a thread is waiting to lock.
<span class="udiff-line-modified-removed">-     waitingToLockMonitor = (ObjectMonitor*)jt-&gt;current_pending_monitor();</span>
<span class="udiff-line-modified-added">+     waitingToLockMonitor = jt-&gt;current_pending_monitor();</span>
<span class="udiff-line-added">+     // JVM TI raw monitors can also be involved in deadlocks, and we can be</span>
<span class="udiff-line-added">+     // waiting to lock both a raw monitor and ObjectMonitor at the same time.</span>
<span class="udiff-line-added">+     // It isn&#39;t clear how to make deadlock detection work correctly if that</span>
<span class="udiff-line-added">+     // happens.</span>
<span class="udiff-line-added">+     waitingToLockRawMonitor = jt-&gt;current_pending_raw_monitor();</span>
<span class="udiff-line-added">+ </span>
      if (concurrent_locks) {
        waitingToLockBlocker = jt-&gt;current_park_blocker();
      }
<span class="udiff-line-modified-removed">-     while (waitingToLockMonitor != NULL || waitingToLockBlocker != NULL) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     while (waitingToLockMonitor != NULL ||</span>
<span class="udiff-line-added">+            waitingToLockRawMonitor != NULL ||</span>
<span class="udiff-line-added">+            waitingToLockBlocker != NULL) {</span>
        cycle-&gt;add_thread(currentThread);
<span class="udiff-line-modified-removed">-       if (waitingToLockMonitor != NULL) {</span>
<span class="udiff-line-modified-added">+       // Give preference to the raw monitor</span>
<span class="udiff-line-added">+       if (waitingToLockRawMonitor != NULL) {</span>
<span class="udiff-line-added">+         Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="udiff-line-added">+         if (owner != NULL &amp;&amp; // the raw monitor could be released at any time</span>
<span class="udiff-line-added">+             owner-&gt;is_Java_thread()) {</span>
<span class="udiff-line-added">+           // only JavaThreads can be reported here</span>
<span class="udiff-line-added">+           currentThread = (JavaThread*) owner;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (waitingToLockMonitor != NULL) {</span>
          address currentOwner = (address)waitingToLockMonitor-&gt;owner();
          if (currentOwner != NULL) {
            currentThread = Threads::owning_thread_from_monitor_owner(t_list,
                                                                      currentOwner);
            if (currentThread == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -677,11 +698,11 @@</span>
      int len = frame-&gt;num_locked_monitors();
      GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
      for (int j = 0; j &lt; len; j++) {
        oop monitor = locked_monitors-&gt;at(j);
        assert(monitor != NULL, &quot;must be a Java object&quot;);
<span class="udiff-line-modified-removed">-       if (oopDesc::equals(monitor, object)) {</span>
<span class="udiff-line-modified-added">+       if (monitor == object) {</span>
          found = true;
          break;
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -890,14 +911,11 @@</span>
        }
      }
    }
  
    // Support for JSR-166 locks
<span class="udiff-line-modified-removed">-   if (JDK_Version::current().supports_thread_park_blocker() &amp;&amp;</span>
<span class="udiff-line-removed">-         (_thread_status == java_lang_Thread::PARKED ||</span>
<span class="udiff-line-removed">-          _thread_status == java_lang_Thread::PARKED_TIMED)) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   if (_thread_status == java_lang_Thread::PARKED || _thread_status == java_lang_Thread::PARKED_TIMED) {</span>
      _blocker_object = thread-&gt;current_park_blocker();
      if (_blocker_object != NULL &amp;&amp; _blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
        _blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(_blocker_object);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -948,41 +966,57 @@</span>
    st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
    st-&gt;print(&quot;=============================&quot;);
  
    JavaThread* currentThread;
    ObjectMonitor* waitingToLockMonitor;
<span class="udiff-line-added">+   JvmtiRawMonitor* waitingToLockRawMonitor;</span>
    oop waitingToLockBlocker;
    int len = _threads-&gt;length();
    for (int i = 0; i &lt; len; i++) {
      currentThread = _threads-&gt;at(i);
<span class="udiff-line-modified-removed">-     waitingToLockMonitor = (ObjectMonitor*)currentThread-&gt;current_pending_monitor();</span>
<span class="udiff-line-modified-added">+     waitingToLockMonitor = currentThread-&gt;current_pending_monitor();</span>
<span class="udiff-line-added">+     waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();</span>
      waitingToLockBlocker = currentThread-&gt;current_park_blocker();
      st-&gt;cr();
      st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
      const char* owner_desc = &quot;,\n  which is held by&quot;;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Note: As the JVM TI &quot;monitor contended enter&quot; event callback is executed after ObjectMonitor</span>
<span class="udiff-line-added">+     // sets the current pending monitor, it is possible to then see a pending raw monitor as well.</span>
<span class="udiff-line-added">+     if (waitingToLockRawMonitor != NULL) {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;  waiting to lock JVM TI raw monitor &quot; INTPTR_FORMAT, p2i(waitingToLockRawMonitor));</span>
<span class="udiff-line-added">+       Thread* owner = waitingToLockRawMonitor-&gt;owner();</span>
<span class="udiff-line-added">+       // Could be NULL as the raw monitor could be released at any time if held by non-JavaThread</span>
<span class="udiff-line-added">+       if (owner != NULL) {</span>
<span class="udiff-line-added">+         if (owner-&gt;is_Java_thread()) {</span>
<span class="udiff-line-added">+           currentThread = (JavaThread*) owner;</span>
<span class="udiff-line-added">+           st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           st-&gt;print_cr(&quot;,\n  which has now been released&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         st-&gt;print_cr(&quot;%s non-Java thread=&quot; PTR_FORMAT, owner_desc, p2i(owner));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if (waitingToLockMonitor != NULL) {
        st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
        oop obj = (oop)waitingToLockMonitor-&gt;object();
<span class="udiff-line-modified-removed">-       if (obj != NULL) {</span>
<span class="udiff-line-modified-removed">-         st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),</span>
<span class="udiff-line-removed">-                    obj-&gt;klass()-&gt;external_name());</span>
<span class="udiff-line-modified-added">+       st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),</span>
<span class="udiff-line-modified-added">+                  obj-&gt;klass()-&gt;external_name());</span>
  
<span class="udiff-line-modified-removed">-         if (!currentThread-&gt;current_pending_monitor_is_from_java()) {</span>
<span class="udiff-line-modified-removed">-           owner_desc = &quot;\n  in JNI, which is held by&quot;;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         // No Java object associated - a JVMTI raw monitor</span>
<span class="udiff-line-removed">-         owner_desc = &quot; (JVMTI raw monitor),\n  which is held by&quot;;</span>
<span class="udiff-line-modified-added">+       if (!currentThread-&gt;current_pending_monitor_is_from_java()) {</span>
<span class="udiff-line-modified-added">+         owner_desc = &quot;\n  in JNI, which is held by&quot;;</span>
        }
        currentThread = Threads::owning_thread_from_monitor_owner(t_list,
                                                                  (address)waitingToLockMonitor-&gt;owner());
        if (currentThread == NULL) {
          // The deadlock was detected at a safepoint so the JavaThread
          // that owns waitingToLockMonitor should be findable, but
          // if it is not findable, then the previous currentThread is
          // blocked permanently.
<span class="udiff-line-modified-removed">-         st-&gt;print(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,</span>
<span class="udiff-line-modified-added">+         st-&gt;print_cr(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,</span>
                    p2i(waitingToLockMonitor-&gt;owner()));
          continue;
        }
      } else {
        st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -992,14 +1026,13 @@</span>
               &quot;Must be an AbstractOwnableSynchronizer&quot;);
        oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
        currentThread = java_lang_Thread::thread(ownerObj);
        assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
      }
<span class="udiff-line-modified-removed">-     st-&gt;print(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
<span class="udiff-line-modified-added">+     st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());</span>
    }
  
<span class="udiff-line-removed">-   st-&gt;cr();</span>
    st-&gt;cr();
  
    // Print stack traces
    bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
    JavaMonitorsInStackTrace = true;
</pre>
<center><a href="nmtDCmd.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
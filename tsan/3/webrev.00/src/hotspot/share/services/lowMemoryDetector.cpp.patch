diff a/src/hotspot/share/services/lowMemoryDetector.cpp b/src/hotspot/share/services/lowMemoryDetector.cpp
--- a/src/hotspot/share/services/lowMemoryDetector.cpp
+++ b/src/hotspot/share/services/lowMemoryDetector.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -38,11 +38,11 @@
 
 volatile bool LowMemoryDetector::_enabled_for_collected_pools = false;
 volatile jint LowMemoryDetector::_disabled_count = 0;
 
 bool LowMemoryDetector::has_pending_requests() {
-  assert(Service_lock->owned_by_self(), "Must own Service_lock");
+  assert(Notification_lock->owned_by_self(), "Must own Notification_lock");
   bool has_requests = false;
   int num_memory_pools = MemoryService::num_memory_pools();
   for (int i = 0; i < num_memory_pools; i++) {
     MemoryPool* pool = MemoryService::get_memory_pool(i);
     SensorInfo* sensor = pool->usage_sensor();
@@ -60,11 +60,11 @@
 
 void LowMemoryDetector::process_sensor_changes(TRAPS) {
   ResourceMark rm(THREAD);
   HandleMark hm(THREAD);
 
-  // No need to hold Service_lock to call out to Java
+  // No need to hold Notification_lock to call out to Java
   int num_memory_pools = MemoryService::num_memory_pools();
   for (int i = 0; i < num_memory_pools; i++) {
     MemoryPool* pool = MemoryService::get_memory_pool(i);
     SensorInfo* sensor = pool->usage_sensor();
     SensorInfo* gc_sensor = pool->gc_usage_sensor();
@@ -78,11 +78,11 @@
 }
 
 // This method could be called from any Java threads
 // and also VMThread.
 void LowMemoryDetector::detect_low_memory() {
-  MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker ml(Notification_lock, Mutex::_no_safepoint_check_flag);
 
   bool has_pending_requests = false;
   int num_memory_pools = MemoryService::num_memory_pools();
   for (int i = 0; i < num_memory_pools; i++) {
     MemoryPool* pool = MemoryService::get_memory_pool(i);
@@ -96,11 +96,11 @@
       has_pending_requests = has_pending_requests || sensor->has_pending_requests();
     }
   }
 
   if (has_pending_requests) {
-    Service_lock->notify_all();
+    Notification_lock->notify_all();
   }
 }
 
 // This method could be called from any Java threads
 // and also VMThread.
@@ -111,18 +111,18 @@
       pool->usage_threshold()->high_threshold() == 0) {
     return;
   }
 
   {
-    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker ml(Notification_lock, Mutex::_no_safepoint_check_flag);
 
     MemoryUsage usage = pool->get_memory_usage();
     sensor->set_gauge_sensor_level(usage,
                                    pool->usage_threshold());
     if (sensor->has_pending_requests()) {
       // notify sensor state update
-      Service_lock->notify_all();
+      Notification_lock->notify_all();
     }
   }
 }
 
 // Only called by VMThread at GC time
@@ -133,18 +133,18 @@
       pool->gc_usage_threshold()->high_threshold() == 0) {
     return;
   }
 
   {
-    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker ml(Notification_lock, Mutex::_no_safepoint_check_flag);
 
     MemoryUsage usage = pool->get_last_collection_usage();
     sensor->set_counter_sensor_level(usage, pool->gc_usage_threshold());
 
     if (sensor->has_pending_requests()) {
       // notify sensor state update
-      Service_lock->notify_all();
+      Notification_lock->notify_all();
     }
   }
 }
 
 // recompute enabled flag
@@ -203,11 +203,11 @@
 // to the high threshold.
 //
 // If the current level is between high and low threshold, no change.
 //
 void SensorInfo::set_gauge_sensor_level(MemoryUsage usage, ThresholdSupport* high_low_threshold) {
-  assert(Service_lock->owned_by_self(), "Must own Service_lock");
+  assert(Notification_lock->owned_by_self(), "Must own Notification_lock");
   assert(high_low_threshold->is_high_threshold_supported(), "just checking");
 
   bool is_over_high = high_low_threshold->is_high_threshold_crossed(usage);
   bool is_below_low = high_low_threshold->is_low_threshold_crossed(usage);
 
@@ -258,11 +258,11 @@
 //      the sensor is currently on; or
 //  (2) the usage is crossing below the low threshold and
 //      the sensor will be on (i.e. sensor is currently off
 //      and has pending trigger requests).
 void SensorInfo::set_counter_sensor_level(MemoryUsage usage, ThresholdSupport* counter_threshold) {
-  assert(Service_lock->owned_by_self(), "Must own Service_lock");
+  assert(Notification_lock->owned_by_self(), "Must own Notification_lock");
   assert(counter_threshold->is_high_threshold_supported(), "just checking");
 
   bool is_over_high = counter_threshold->is_high_threshold_crossed(usage);
   bool is_below_low = counter_threshold->is_low_threshold_crossed(usage);
 
@@ -332,23 +332,23 @@
        CLEAR_PENDING_EXCEPTION;
      }
   }
 
   {
-    // Holds Service_lock and update the sensor state
-    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
+    // Holds Notification_lock and update the sensor state
+    MutexLocker ml(THREAD, Notification_lock, Mutex::_no_safepoint_check_flag);
     assert(_pending_trigger_count > 0, "Must have pending trigger");
     _sensor_on = true;
     _sensor_count += count;
     _pending_trigger_count = _pending_trigger_count - count;
   }
 }
 
 void SensorInfo::clear(int count, TRAPS) {
   {
-    // Holds Service_lock and update the sensor state
-    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
+    // Holds Notification_lock and update the sensor state
+    MutexLocker ml(THREAD, Notification_lock, Mutex::_no_safepoint_check_flag);
     if (_pending_clear_count == 0) {
       // Bail out if we lost a race to set_*_sensor_level() which may have
       // reactivated the sensor in the meantime because it was triggered again.
       return;
     }

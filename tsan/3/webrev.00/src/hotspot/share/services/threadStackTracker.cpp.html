<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/services/threadStackTracker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;runtime/threadCritical.hpp&quot;
 28 #include &quot;services/mallocTracker.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 #include &quot;services/virtualMemoryTracker.hpp&quot;
 31 #include &quot;services/threadStackTracker.hpp&quot;
 32 
 33 volatile size_t ThreadStackTracker::_thread_count = 0;
 34 SortedLinkedList&lt;SimpleThreadStackSite, ThreadStackTracker::compare_thread_stack_base&gt;* ThreadStackTracker::_simple_thread_stacks = NULL;
 35 
 36 bool ThreadStackTracker::late_initialize(NMT_TrackingLevel level) {
 37   if (level == NMT_detail &amp;&amp; !track_as_vm()) {
 38     _simple_thread_stacks = new (std::nothrow, ResourceObj::C_HEAP, mtNMT)
 39       SortedLinkedList&lt;SimpleThreadStackSite, ThreadStackTracker::compare_thread_stack_base&gt;();
 40     return (_simple_thread_stacks != NULL);
 41   }
 42   return true;
 43 }
 44 
 45 bool ThreadStackTracker::transition(NMT_TrackingLevel from, NMT_TrackingLevel to) {
 46   assert (from != NMT_minimal, &quot;cannot convert from the lowest tracking level to anything&quot;);
 47   if (to == NMT_minimal) {
 48     assert(from == NMT_summary || from == NMT_detail, &quot;Just check&quot;);
 49     ThreadCritical tc;
 50     if (_simple_thread_stacks != NULL) {
 51       delete _simple_thread_stacks;
 52       _simple_thread_stacks = NULL;
 53     }
 54   }
 55   return true;
 56 }
 57 
 58 int ThreadStackTracker::compare_thread_stack_base(const SimpleThreadStackSite&amp; s1, const SimpleThreadStackSite&amp; s2) {
 59   return s1.base() - s2.base();
 60 }
 61 
 62 void ThreadStackTracker::new_thread_stack(void* base, size_t size, const NativeCallStack&amp; stack) {
 63   assert(MemTracker::tracking_level() &gt;= NMT_summary, &quot;Must be&quot;);
 64   assert(base != NULL, &quot;Should have been filtered&quot;);
 65   if (track_as_vm()) {
 66     ThreadCritical tc;
 67     VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);
 68     _thread_count ++;
 69   } else {
 70     // Use a slot in mallocMemorySummary for thread stack bookkeeping
 71     MallocMemorySummary::record_malloc(size, mtThreadStack);
 72     if (MemTracker::tracking_level() == NMT_detail) {
 73       ThreadCritical tc;
 74       assert(_simple_thread_stacks != NULL, &quot;Must be initialized&quot;);
 75       SimpleThreadStackSite site((address)base, size, stack);
 76       _simple_thread_stacks-&gt;add(site);
 77     }
 78   }
 79 }
 80 
 81 void ThreadStackTracker::delete_thread_stack(void* base, size_t size) {
 82   assert(MemTracker::tracking_level() &gt;= NMT_summary, &quot;Must be&quot;);
 83   assert(base != NULL, &quot;Should have been filtered&quot;);
 84   if(track_as_vm()) {
 85     ThreadCritical tc;
 86     VirtualMemoryTracker::remove_released_region((address)base, size);
 87     _thread_count--;
 88   } else {
 89     // Use a slot in mallocMemorySummary for thread stack bookkeeping
 90     MallocMemorySummary::record_free(size, mtThreadStack);
 91     if (MemTracker::tracking_level() == NMT_detail) {
 92       ThreadCritical tc;
 93       assert(_simple_thread_stacks != NULL, &quot;Must be initialized&quot;);
 94       SimpleThreadStackSite site((address)base, size);
 95       bool removed = _simple_thread_stacks-&gt;remove(site);
 96       assert(removed, &quot;Must exist&quot;);
 97     }
 98   }
 99 }
100 
101 bool ThreadStackTracker::walk_simple_thread_stack_site(MallocSiteWalker* walker) {
102   if (!track_as_vm()) {
103     LinkedListImpl&lt;MallocSite&gt; _sites;
104     {
105       ThreadCritical tc;
106       assert(_simple_thread_stacks != NULL, &quot;Must be initialized&quot;);
107       LinkedListIterator&lt;SimpleThreadStackSite&gt; itr(_simple_thread_stacks-&gt;head());
108       const SimpleThreadStackSite* ts = itr.next();
109       // Consolidate sites and convert to MallocSites, so we can piggyback into
110       // malloc snapshot
111       while (ts != NULL) {
112         MallocSite site(*ts-&gt;call_stack(), mtThreadStack);
113         MallocSite* exist = _sites.find(site);
114         if (exist != NULL) {
115           exist-&gt;allocate(ts-&gt;size());
116         } else {
117           site.allocate(ts-&gt;size());
118           _sites.add(site);
119         }
120         ts = itr.next();
121       }
122     }
123 
124     // Piggyback to malloc snapshot
125     LinkedListIterator&lt;MallocSite&gt; site_itr(_sites.head());
126     const MallocSite* s = site_itr.next();
127     while (s != NULL) {
128       walker-&gt;do_malloc_site(s);
129       s = site_itr.next();
130     }
131   }
132   return true;
133 }
    </pre>
  </body>
</html>
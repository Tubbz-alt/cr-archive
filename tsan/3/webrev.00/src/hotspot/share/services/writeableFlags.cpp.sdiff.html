<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/writeableFlags.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="virtualMemoryTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../tsan/tsan.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/writeableFlags.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/arguments.hpp&quot;
 29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/jniHandles.hpp&quot;
 33 #include &quot;services/writeableFlags.hpp&quot;
 34 
 35 #define TEMP_BUF_SIZE 80
 36 
 37 static void buffer_concat(char* buffer, const char* src) {
 38   strncat(buffer, src, TEMP_BUF_SIZE - 1 - strlen(buffer));
 39 }
 40 
<span class="line-modified"> 41 static void print_flag_error_message_bounds(const char* name, char* buffer) {</span>
<span class="line-modified"> 42   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
 43   if (range != NULL) {
 44     buffer_concat(buffer, &quot;must have value in range &quot;);
 45 
 46     stringStream stream;
 47     range-&gt;print(&amp;stream);
 48     const char* range_string = stream.as_string();
 49     size_t j = strlen(buffer);
 50     for (size_t i=0; j&lt;TEMP_BUF_SIZE-1; i++) {
 51       if (range_string[i] == &#39;\0&#39;) {
 52         break;
 53       } else if (range_string[i] != &#39; &#39;) {
 54         buffer[j] = range_string[i];
 55         j++;
 56       }
 57     }
 58     buffer[j] = &#39;\0&#39;;
 59   }
 60 }
 61 
<span class="line-modified"> 62 static void print_flag_error_message_if_needed(JVMFlag::Error error, const char* name, FormatBuffer&lt;80&gt;&amp; err_msg) {</span>
 63   if (error == JVMFlag::SUCCESS) {
 64     return;
 65   }
 66 

 67   char buffer[TEMP_BUF_SIZE] = {&#39;\0&#39;};
 68   if ((error != JVMFlag::MISSING_NAME) &amp;&amp; (name != NULL)) {
 69     buffer_concat(buffer, name);
 70     buffer_concat(buffer, &quot; error: &quot;);
 71   } else {
 72     buffer_concat(buffer, &quot;Error: &quot;);
 73   }
 74   switch (error) {
 75     case JVMFlag::MISSING_NAME:
 76       buffer_concat(buffer, &quot;flag name is missing.&quot;); break;
 77     case JVMFlag::MISSING_VALUE:
 78       buffer_concat(buffer, &quot;parsing the textual form of the value.&quot;); break;
 79     case JVMFlag::NON_WRITABLE:
 80       buffer_concat(buffer, &quot;flag is not writeable.&quot;); break;
 81     case JVMFlag::OUT_OF_BOUNDS:
<span class="line-modified"> 82       if (name != NULL) { print_flag_error_message_bounds(name, buffer); } break;</span>
 83     case JVMFlag::VIOLATES_CONSTRAINT:
 84       buffer_concat(buffer, &quot;value violates its flag&#39;s constraint.&quot;); break;
 85     case JVMFlag::INVALID_FLAG:
 86       buffer_concat(buffer, &quot;there is no flag with the given name.&quot;); break;
 87     case JVMFlag::ERR_OTHER:
 88       buffer_concat(buffer, &quot;other, unspecified error related to setting the flag.&quot;); break;
 89     case JVMFlag::SUCCESS:
 90       break;
 91     default:
 92       break;
 93   }
 94 
 95   err_msg.print(&quot;%s&quot;, buffer);
 96 }
 97 
 98 // set a boolean global flag
 99 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
100   if ((strcasecmp(arg, &quot;true&quot;) == 0) || (*arg == &#39;1&#39; &amp;&amp; *(arg + 1) == 0)) {
101     return set_bool_flag(name, true, origin, err_msg);
102   } else if ((strcasecmp(arg, &quot;false&quot;) == 0) || (*arg == &#39;0&#39; &amp;&amp; *(arg + 1) == 0)) {
103     return set_bool_flag(name, false, origin, err_msg);
104   }
105   err_msg.print(&quot;flag value must be a boolean (1/0 or true/false)&quot;);
106   return JVMFlag::WRONG_FORMAT;
107 }
108 
109 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, bool value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">110   JVMFlag::Error err = JVMFlag::boolAtPut(name, &amp;value, origin);</span>
<span class="line-modified">111   print_flag_error_message_if_needed(err, name, err_msg);</span>

112   return err;
113 }
114 
115 // set a int global flag
116 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
117   int value;
118 
119   if (sscanf(arg, &quot;%d&quot;, &amp;value) == 1) {
120     return set_int_flag(name, value, origin, err_msg);
121   }
122   err_msg.print(&quot;flag value must be an integer&quot;);
123   return JVMFlag::WRONG_FORMAT;
124 }
125 
126 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, int value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">127   JVMFlag::Error err = JVMFlag::intAtPut(name, &amp;value, origin);</span>
<span class="line-modified">128   print_flag_error_message_if_needed(err, name, err_msg);</span>

129   return err;
130 }
131 
132 // set a uint global flag
133 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
134   uint value;
135 
136   if (sscanf(arg, &quot;%u&quot;, &amp;value) == 1) {
137     return set_uint_flag(name, value, origin, err_msg);
138   }
139   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
140   return JVMFlag::WRONG_FORMAT;
141 }
142 
143 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, uint value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">144   JVMFlag::Error err = JVMFlag::uintAtPut(name, &amp;value, origin);</span>
<span class="line-modified">145   print_flag_error_message_if_needed(err, name, err_msg);</span>

146   return err;
147 }
148 
149 // set a intx global flag
150 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
151   intx value;
152 
153   if (sscanf(arg, INTX_FORMAT, &amp;value) == 1) {
154     return set_intx_flag(name, value, origin, err_msg);
155   }
156   err_msg.print(&quot;flag value must be an integer&quot;);
157   return JVMFlag::WRONG_FORMAT;
158 }
159 
160 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, intx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">161   JVMFlag::Error err = JVMFlag::intxAtPut(name, &amp;value, origin);</span>
<span class="line-modified">162   print_flag_error_message_if_needed(err, name, err_msg);</span>

163   return err;
164 }
165 
166 // set a uintx global flag
167 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
168   uintx value;
169 
170   if (sscanf(arg, UINTX_FORMAT, &amp;value) == 1) {
171     return set_uintx_flag(name, value, origin, err_msg);
172   }
173   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
174   return JVMFlag::WRONG_FORMAT;
175 }
176 
177 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, uintx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">178   JVMFlag::Error err = JVMFlag::uintxAtPut(name, &amp;value, origin);</span>
<span class="line-modified">179   print_flag_error_message_if_needed(err, name, err_msg);</span>

180   return err;
181 }
182 
183 // set a uint64_t global flag
184 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
185   uint64_t value;
186 
187   if (sscanf(arg, UINT64_FORMAT, &amp;value) == 1) {
188     return set_uint64_t_flag(name, value, origin, err_msg);
189   }
190   err_msg.print(&quot;flag value must be an unsigned 64-bit integer&quot;);
191   return JVMFlag::WRONG_FORMAT;
192 }
193 
194 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, uint64_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">195   JVMFlag::Error err = JVMFlag::uint64_tAtPut(name, &amp;value, origin);</span>
<span class="line-modified">196   print_flag_error_message_if_needed(err, name, err_msg);</span>

197   return err;
198 }
199 
200 // set a size_t global flag
201 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
202   size_t value;
203 
204   if (sscanf(arg, SIZE_FORMAT, &amp;value) == 1) {
205     return set_size_t_flag(name, value, origin, err_msg);
206   }
207   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
208   return JVMFlag::WRONG_FORMAT;
209 }
210 
211 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, size_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">212   JVMFlag::Error err = JVMFlag::size_tAtPut(name, &amp;value, origin);</span>
<span class="line-modified">213   print_flag_error_message_if_needed(err, name, err_msg);</span>

214   return err;
215 }
216 
217 // set a double global flag
218 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
219   double value;
220 
221   if (sscanf(arg, &quot;%lf&quot;, &amp;value) == 1) {
222     return set_double_flag(name, value, origin, err_msg);
223   }
224   err_msg.print(&quot;flag value must be a double&quot;);
225   return JVMFlag::WRONG_FORMAT;
226 }
227 
228 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, double value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">229   JVMFlag::Error err = JVMFlag::doubleAtPut(name, &amp;value, origin);</span>
<span class="line-modified">230   print_flag_error_message_if_needed(err, name, err_msg);</span>

231   return err;
232 }
233 
234 // set a string global flag using value from AttachOperation
235 JVMFlag::Error WriteableFlags::set_ccstr_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">236   JVMFlag::Error err = JVMFlag::ccstrAtPut((char*)name, &amp;value, origin);</span>
<span class="line-modified">237   print_flag_error_message_if_needed(err, name, err_msg);</span>

238   return err;
239 }
240 
241 /* sets a writeable flag to the provided value
242  *
243  * - return status is one of the WriteableFlags::err enum values
244  * - an eventual error message will be generated to the provided err_msg buffer
245  */
246 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, const char* flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
247   return set_flag(flag_name, &amp;flag_value, set_flag_from_char, origin, err_msg);
248 }
249 
250 /* sets a writeable flag to the provided value
251  *
252  * - return status is one of the WriteableFlags::err enum values
253  * - an eventual error message will be generated to the provided err_msg buffer
254  */
255 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, jvalue flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
256   return set_flag(flag_name, &amp;flag_value, set_flag_from_jvalue, origin, err_msg);
257 }
258 
259 // a writeable flag setter accepting either &#39;jvalue&#39; or &#39;char *&#39; values
260 JVMFlag::Error WriteableFlags::set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*,const void*,JVMFlag::Flags,FormatBuffer&lt;80&gt;&amp;), JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
261   if (name == NULL) {
262     err_msg.print(&quot;flag name is missing&quot;);
263     return JVMFlag::MISSING_NAME;
264   }
265   if (value == NULL) {
266     err_msg.print(&quot;flag value is missing&quot;);
267     return JVMFlag::MISSING_VALUE;
268   }
269 
<span class="line-modified">270   JVMFlag* f = JVMFlag::find_flag((char*)name, strlen(name));</span>
271   if (f) {
272     // only writeable flags are allowed to be set
273     if (f-&gt;is_writeable()) {
274       return setter(f, value, origin, err_msg);
275     } else {
276       err_msg.print(&quot;only &#39;writeable&#39; flags can be set&quot;);
277       return JVMFlag::NON_WRITABLE;
278     }
279   }
280 
281   err_msg.print(&quot;flag %s does not exist&quot;, name);
282   return JVMFlag::INVALID_FLAG;
283 }
284 
285 // a writeable flag setter accepting &#39;char *&#39; values
286 JVMFlag::Error WriteableFlags::set_flag_from_char(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
287   char* flag_value = *(char**)value;
288   if (flag_value == NULL) {
289     err_msg.print(&quot;flag value is missing&quot;);
290     return JVMFlag::MISSING_VALUE;
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/arguments.hpp&quot;
 29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/jniHandles.hpp&quot;
 33 #include &quot;services/writeableFlags.hpp&quot;
 34 
 35 #define TEMP_BUF_SIZE 80
 36 
 37 static void buffer_concat(char* buffer, const char* src) {
 38   strncat(buffer, src, TEMP_BUF_SIZE - 1 - strlen(buffer));
 39 }
 40 
<span class="line-modified"> 41 static void print_flag_error_message_bounds(const JVMFlag* flag, char* buffer) {</span>
<span class="line-modified"> 42   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
 43   if (range != NULL) {
 44     buffer_concat(buffer, &quot;must have value in range &quot;);
 45 
 46     stringStream stream;
 47     range-&gt;print(&amp;stream);
 48     const char* range_string = stream.as_string();
 49     size_t j = strlen(buffer);
 50     for (size_t i=0; j&lt;TEMP_BUF_SIZE-1; i++) {
 51       if (range_string[i] == &#39;\0&#39;) {
 52         break;
 53       } else if (range_string[i] != &#39; &#39;) {
 54         buffer[j] = range_string[i];
 55         j++;
 56       }
 57     }
 58     buffer[j] = &#39;\0&#39;;
 59   }
 60 }
 61 
<span class="line-modified"> 62 static void print_flag_error_message_if_needed(JVMFlag::Error error, const JVMFlag* flag, FormatBuffer&lt;80&gt;&amp; err_msg) {</span>
 63   if (error == JVMFlag::SUCCESS) {
 64     return;
 65   }
 66 
<span class="line-added"> 67   const char* name = flag-&gt;_name;</span>
 68   char buffer[TEMP_BUF_SIZE] = {&#39;\0&#39;};
 69   if ((error != JVMFlag::MISSING_NAME) &amp;&amp; (name != NULL)) {
 70     buffer_concat(buffer, name);
 71     buffer_concat(buffer, &quot; error: &quot;);
 72   } else {
 73     buffer_concat(buffer, &quot;Error: &quot;);
 74   }
 75   switch (error) {
 76     case JVMFlag::MISSING_NAME:
 77       buffer_concat(buffer, &quot;flag name is missing.&quot;); break;
 78     case JVMFlag::MISSING_VALUE:
 79       buffer_concat(buffer, &quot;parsing the textual form of the value.&quot;); break;
 80     case JVMFlag::NON_WRITABLE:
 81       buffer_concat(buffer, &quot;flag is not writeable.&quot;); break;
 82     case JVMFlag::OUT_OF_BOUNDS:
<span class="line-modified"> 83       if (name != NULL) { print_flag_error_message_bounds(flag, buffer); } break;</span>
 84     case JVMFlag::VIOLATES_CONSTRAINT:
 85       buffer_concat(buffer, &quot;value violates its flag&#39;s constraint.&quot;); break;
 86     case JVMFlag::INVALID_FLAG:
 87       buffer_concat(buffer, &quot;there is no flag with the given name.&quot;); break;
 88     case JVMFlag::ERR_OTHER:
 89       buffer_concat(buffer, &quot;other, unspecified error related to setting the flag.&quot;); break;
 90     case JVMFlag::SUCCESS:
 91       break;
 92     default:
 93       break;
 94   }
 95 
 96   err_msg.print(&quot;%s&quot;, buffer);
 97 }
 98 
 99 // set a boolean global flag
100 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
101   if ((strcasecmp(arg, &quot;true&quot;) == 0) || (*arg == &#39;1&#39; &amp;&amp; *(arg + 1) == 0)) {
102     return set_bool_flag(name, true, origin, err_msg);
103   } else if ((strcasecmp(arg, &quot;false&quot;) == 0) || (*arg == &#39;0&#39; &amp;&amp; *(arg + 1) == 0)) {
104     return set_bool_flag(name, false, origin, err_msg);
105   }
106   err_msg.print(&quot;flag value must be a boolean (1/0 or true/false)&quot;);
107   return JVMFlag::WRONG_FORMAT;
108 }
109 
110 JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, bool value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">111   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">112   JVMFlag::Error err = JVMFlag::boolAtPut(flag, &amp;value, origin);</span>
<span class="line-added">113   print_flag_error_message_if_needed(err, flag, err_msg);</span>
114   return err;
115 }
116 
117 // set a int global flag
118 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
119   int value;
120 
121   if (sscanf(arg, &quot;%d&quot;, &amp;value) == 1) {
122     return set_int_flag(name, value, origin, err_msg);
123   }
124   err_msg.print(&quot;flag value must be an integer&quot;);
125   return JVMFlag::WRONG_FORMAT;
126 }
127 
128 JVMFlag::Error WriteableFlags::set_int_flag(const char* name, int value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">129   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">130   JVMFlag::Error err = JVMFlag::intAtPut(flag, &amp;value, origin);</span>
<span class="line-added">131   print_flag_error_message_if_needed(err, flag, err_msg);</span>
132   return err;
133 }
134 
135 // set a uint global flag
136 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
137   uint value;
138 
139   if (sscanf(arg, &quot;%u&quot;, &amp;value) == 1) {
140     return set_uint_flag(name, value, origin, err_msg);
141   }
142   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
143   return JVMFlag::WRONG_FORMAT;
144 }
145 
146 JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, uint value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">147   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">148   JVMFlag::Error err = JVMFlag::uintAtPut(flag, &amp;value, origin);</span>
<span class="line-added">149   print_flag_error_message_if_needed(err, flag, err_msg);</span>
150   return err;
151 }
152 
153 // set a intx global flag
154 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
155   intx value;
156 
157   if (sscanf(arg, INTX_FORMAT, &amp;value) == 1) {
158     return set_intx_flag(name, value, origin, err_msg);
159   }
160   err_msg.print(&quot;flag value must be an integer&quot;);
161   return JVMFlag::WRONG_FORMAT;
162 }
163 
164 JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, intx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">165   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">166   JVMFlag::Error err = JVMFlag::intxAtPut(flag, &amp;value, origin);</span>
<span class="line-added">167   print_flag_error_message_if_needed(err, flag, err_msg);</span>
168   return err;
169 }
170 
171 // set a uintx global flag
172 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
173   uintx value;
174 
175   if (sscanf(arg, UINTX_FORMAT, &amp;value) == 1) {
176     return set_uintx_flag(name, value, origin, err_msg);
177   }
178   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
179   return JVMFlag::WRONG_FORMAT;
180 }
181 
182 JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, uintx value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">183   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">184   JVMFlag::Error err = JVMFlag::uintxAtPut(flag, &amp;value, origin);</span>
<span class="line-added">185   print_flag_error_message_if_needed(err, flag, err_msg);</span>
186   return err;
187 }
188 
189 // set a uint64_t global flag
190 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
191   uint64_t value;
192 
193   if (sscanf(arg, UINT64_FORMAT, &amp;value) == 1) {
194     return set_uint64_t_flag(name, value, origin, err_msg);
195   }
196   err_msg.print(&quot;flag value must be an unsigned 64-bit integer&quot;);
197   return JVMFlag::WRONG_FORMAT;
198 }
199 
200 JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, uint64_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">201   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">202   JVMFlag::Error err = JVMFlag::uint64_tAtPut(flag, &amp;value, origin);</span>
<span class="line-added">203   print_flag_error_message_if_needed(err, flag, err_msg);</span>
204   return err;
205 }
206 
207 // set a size_t global flag
208 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
209   size_t value;
210 
211   if (sscanf(arg, SIZE_FORMAT, &amp;value) == 1) {
212     return set_size_t_flag(name, value, origin, err_msg);
213   }
214   err_msg.print(&quot;flag value must be an unsigned integer&quot;);
215   return JVMFlag::WRONG_FORMAT;
216 }
217 
218 JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, size_t value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">219   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">220   JVMFlag::Error err = JVMFlag::size_tAtPut(flag, &amp;value, origin);</span>
<span class="line-added">221   print_flag_error_message_if_needed(err, flag, err_msg);</span>
222   return err;
223 }
224 
225 // set a double global flag
226 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
227   double value;
228 
229   if (sscanf(arg, &quot;%lf&quot;, &amp;value) == 1) {
230     return set_double_flag(name, value, origin, err_msg);
231   }
232   err_msg.print(&quot;flag value must be a double&quot;);
233   return JVMFlag::WRONG_FORMAT;
234 }
235 
236 JVMFlag::Error WriteableFlags::set_double_flag(const char* name, double value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">237   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">238   JVMFlag::Error err = JVMFlag::doubleAtPut(flag, &amp;value, origin);</span>
<span class="line-added">239   print_flag_error_message_if_needed(err, flag, err_msg);</span>
240   return err;
241 }
242 
243 // set a string global flag using value from AttachOperation
244 JVMFlag::Error WriteableFlags::set_ccstr_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
<span class="line-modified">245   JVMFlag* flag = JVMFlag::find_flag(name);</span>
<span class="line-modified">246   JVMFlag::Error err = JVMFlag::ccstrAtPut(flag, &amp;value, origin);</span>
<span class="line-added">247   print_flag_error_message_if_needed(err, flag, err_msg);</span>
248   return err;
249 }
250 
251 /* sets a writeable flag to the provided value
252  *
253  * - return status is one of the WriteableFlags::err enum values
254  * - an eventual error message will be generated to the provided err_msg buffer
255  */
256 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, const char* flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
257   return set_flag(flag_name, &amp;flag_value, set_flag_from_char, origin, err_msg);
258 }
259 
260 /* sets a writeable flag to the provided value
261  *
262  * - return status is one of the WriteableFlags::err enum values
263  * - an eventual error message will be generated to the provided err_msg buffer
264  */
265 JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, jvalue flag_value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
266   return set_flag(flag_name, &amp;flag_value, set_flag_from_jvalue, origin, err_msg);
267 }
268 
269 // a writeable flag setter accepting either &#39;jvalue&#39; or &#39;char *&#39; values
270 JVMFlag::Error WriteableFlags::set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*,const void*,JVMFlag::Flags,FormatBuffer&lt;80&gt;&amp;), JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
271   if (name == NULL) {
272     err_msg.print(&quot;flag name is missing&quot;);
273     return JVMFlag::MISSING_NAME;
274   }
275   if (value == NULL) {
276     err_msg.print(&quot;flag value is missing&quot;);
277     return JVMFlag::MISSING_VALUE;
278   }
279 
<span class="line-modified">280   JVMFlag* f = JVMFlag::find_flag(name);</span>
281   if (f) {
282     // only writeable flags are allowed to be set
283     if (f-&gt;is_writeable()) {
284       return setter(f, value, origin, err_msg);
285     } else {
286       err_msg.print(&quot;only &#39;writeable&#39; flags can be set&quot;);
287       return JVMFlag::NON_WRITABLE;
288     }
289   }
290 
291   err_msg.print(&quot;flag %s does not exist&quot;, name);
292   return JVMFlag::INVALID_FLAG;
293 }
294 
295 // a writeable flag setter accepting &#39;char *&#39; values
296 JVMFlag::Error WriteableFlags::set_flag_from_char(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer&lt;80&gt;&amp; err_msg) {
297   char* flag_value = *(char**)value;
298   if (flag_value == NULL) {
299     err_msg.print(&quot;flag value is missing&quot;);
300     return JVMFlag::MISSING_VALUE;
</pre>
</td>
</tr>
</table>
<center><a href="virtualMemoryTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../tsan/tsan.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
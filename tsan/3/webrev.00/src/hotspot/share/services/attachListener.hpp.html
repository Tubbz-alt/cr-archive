<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/services/attachListener.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_SERVICES_ATTACHLISTENER_HPP
 26 #define SHARE_SERVICES_ATTACHLISTENER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;metaprogramming/isRegisteredEnum.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 
 36 // The AttachListener thread services a queue of operations that are enqueued
 37 // by client tools. Each operation is identified by a name and has up to 3
 38 // arguments. The operation name is mapped to a function which performs the
 39 // operation. The function is called with an outputStream which is can use to
 40 // write any result data (for examples the properties command serializes
 41 // properties names and values to the output stream). When the function
 42 // complets the result value and any result data is returned to the client
 43 // tool.
 44 
 45 class AttachOperation;
 46 
 47 typedef jint (*AttachOperationFunction)(AttachOperation* op, outputStream* out);
 48 
 49 struct AttachOperationFunctionInfo {
 50   const char* name;
 51   AttachOperationFunction func;
 52 };
 53 
 54 enum AttachListenerState {
 55   AL_NOT_INITIALIZED,
 56   AL_INITIALIZING,
 57   AL_INITIALIZED
 58 };
 59 
 60 template&lt;&gt; struct IsRegisteredEnum&lt;AttachListenerState&gt; : public TrueType {};
 61 
 62 class AttachListener: AllStatic {
 63  public:
 64   static void vm_start() NOT_SERVICES_RETURN;
 65   static void init()  NOT_SERVICES_RETURN;
 66   static void abort() NOT_SERVICES_RETURN;
 67 
 68   // invoke to perform clean-up tasks when all clients detach
 69   static void detachall() NOT_SERVICES_RETURN;
 70 
 71   // check unix domain socket file on filesystem
 72   static bool check_socket_file() NOT_SERVICES_RETURN_(false);
 73 
 74   // indicates if the Attach Listener needs to be created at startup
 75   static bool init_at_startup() NOT_SERVICES_RETURN_(false);
 76 
 77   // indicates if we have a trigger to start the Attach Listener
 78   static bool is_init_trigger() NOT_SERVICES_RETURN_(false);
 79 
 80 #if !INCLUDE_SERVICES
 81   static bool is_attach_supported()             { return false; }
 82 #else
 83 
 84  private:
 85   static volatile AttachListenerState _state;
 86 
 87  public:
 88   static void set_state(AttachListenerState new_state) {
 89     Atomic::store(&amp;_state, new_state);
 90   }
 91 
 92   static AttachListenerState get_state() {
 93     return Atomic::load(&amp;_state);
 94   }
 95 
 96   static AttachListenerState transit_state(AttachListenerState new_state,
 97                                            AttachListenerState cmp_state) {
 98     return Atomic::cmpxchg(&amp;_state, cmp_state, new_state);
 99   }
100 
101   static bool is_initialized() {
102     return Atomic::load(&amp;_state) == AL_INITIALIZED;
103   }
104 
105   static void set_initialized() {
106     Atomic::store(&amp;_state, AL_INITIALIZED);
107   }
108 
109   // indicates if this VM supports attach-on-demand
110   static bool is_attach_supported()             { return !DisableAttachMechanism; }
111 
112   // platform specific initialization
113   static int pd_init();
114 
115   // platform specific operation
116   static AttachOperationFunctionInfo* pd_find_operation(const char* name);
117 
118   // platform specific flag change
119   static jint pd_set_flag(AttachOperation* op, outputStream* out);
120 
121   // platform specific detachall
122   static void pd_detachall();
123 
124   // platform specific data dump
125   static void pd_data_dump();
126 
127   // dequeue the next operation
128   static AttachOperation* dequeue();
129 #endif // !INCLUDE_SERVICES
130 
131  private:
132   static bool has_init_error(TRAPS);
133 };
134 
135 #if INCLUDE_SERVICES
136 class AttachOperation: public CHeapObj&lt;mtInternal&gt; {
137  public:
138   enum {
139     name_length_max = 16,       // maximum length of  name
140     arg_length_max = 1024,      // maximum length of argument
141     arg_count_max = 3           // maximum number of arguments
142   };
143 
144   // name of special operation that can be enqueued when all
145   // clients detach
146   static char* detachall_operation_name() { return (char*)&quot;detachall&quot;; }
147 
148  private:
149   char _name[name_length_max+1];
150   char _arg[arg_count_max][arg_length_max+1];
151 
152  public:
153   const char* name() const                      { return _name; }
154 
155   // set the operation name
156   void set_name(const char* name) {
157     assert(strlen(name) &lt;= name_length_max, &quot;exceeds maximum name length&quot;);
158     size_t len = MIN2(strlen(name), (size_t)name_length_max);
159     memcpy(_name, name, len);
160     _name[len] = &#39;\0&#39;;
161   }
162 
163   // get an argument value
164   const char* arg(int i) const {
165     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
166     return _arg[i];
167   }
168 
169   // set an argument value
170   void set_arg(int i, char* arg) {
171     assert(i&gt;=0 &amp;&amp; i&lt;arg_count_max, &quot;invalid argument index&quot;);
172     if (arg == NULL) {
173       _arg[i][0] = &#39;\0&#39;;
174     } else {
175       assert(strlen(arg) &lt;= arg_length_max, &quot;exceeds maximum argument length&quot;);
176       size_t len = MIN2(strlen(arg), (size_t)arg_length_max);
177       memcpy(_arg[i], arg, len);
178       _arg[i][len] = &#39;\0&#39;;
179     }
180   }
181 
182   // create an operation of a given name
183   AttachOperation(const char* name) {
184     set_name(name);
185     for (int i=0; i&lt;arg_count_max; i++) {
186       set_arg(i, NULL);
187     }
188   }
189 
190   // complete operation by sending result code and any result data to the client
191   virtual void complete(jint result, bufferedStream* result_stream) = 0;
192 };
193 #endif // INCLUDE_SERVICES
194 
195 #endif // SHARE_SERVICES_ATTACHLISTENER_HPP
    </pre>
  </body>
</html>
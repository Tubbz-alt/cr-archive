<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/services/memTracker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memTracker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memTracker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -57,15 +57,15 @@</span>
    static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
      const NativeCallStack&amp; stack, NMT_TrackingLevel level) { return mem_base; }
    static inline size_t malloc_header_size(NMT_TrackingLevel level) { return 0; }
    static inline size_t malloc_header_size(void* memblock) { return 0; }
    static inline void* malloc_base(void* memblock) { return memblock; }
<span class="udiff-line-modified-removed">-   static inline void* record_free(void* memblock) { return memblock; }</span>
<span class="udiff-line-modified-added">+   static inline void* record_free(void* memblock, NMT_TrackingLevel level) { return memblock; }</span>
  
    static inline void record_new_arena(MEMFLAGS flag) { }
    static inline void record_arena_free(MEMFLAGS flag) { }
<span class="udiff-line-modified-removed">-   static inline void record_arena_size_change(int diff, MEMFLAGS flag) { }</span>
<span class="udiff-line-modified-added">+   static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) { }</span>
    static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
                         MEMFLAGS flag = mtNone) { }
    static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,
      const NativeCallStack&amp; stack, MEMFLAGS flag = mtNone) { }
    static inline void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack&amp; stack) { }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,10 +80,11 @@</span>
  #else
  
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/threadCritical.hpp&quot;
  #include &quot;services/mallocTracker.hpp&quot;
<span class="udiff-line-added">+ #include &quot;services/threadStackTracker.hpp&quot;</span>
  #include &quot;services/virtualMemoryTracker.hpp&quot;
  
  extern volatile bool NMT_stack_walkable;
  
  #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail &amp;&amp; NMT_stack_walkable) ? \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -154,11 +155,14 @@</span>
    // Transition the tracking level to specified level
    static bool transition_to(NMT_TrackingLevel level);
  
    static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,
      const NativeCallStack&amp; stack, NMT_TrackingLevel level) {
<span class="udiff-line-modified-removed">-     return MallocTracker::record_malloc(mem_base, size, flag, stack, level);</span>
<span class="udiff-line-modified-added">+     if (level != NMT_off) {</span>
<span class="udiff-line-added">+       return MallocTracker::record_malloc(mem_base, size, flag, stack, level);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return mem_base;</span>
    }
  
    static inline size_t malloc_header_size(NMT_TrackingLevel level) {
      return MallocTracker::malloc_header_size(level);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,11 +178,15 @@</span>
    // of malloc tracking header if tracking is enabled.
    // Otherwise, it returns the same address.
    static void* malloc_base(void* memblock);
  
    // Record malloc free and return malloc base address
<span class="udiff-line-modified-removed">-   static inline void* record_free(void* memblock) {</span>
<span class="udiff-line-modified-added">+   static inline void* record_free(void* memblock, NMT_TrackingLevel level) {</span>
<span class="udiff-line-added">+     // Never turned on</span>
<span class="udiff-line-added">+     if (level == NMT_off || memblock == NULL) {</span>
<span class="udiff-line-added">+       return memblock;</span>
<span class="udiff-line-added">+     }</span>
      return MallocTracker::record_free(memblock);
    }
  
  
    // Record creation of an arena
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,11 +201,11 @@</span>
      MallocTracker::record_arena_free(flag);
    }
  
    // Record arena size change. Arena size is the size of all arena
    // chuncks that backing up the arena.
<span class="udiff-line-modified-removed">-   static inline void record_arena_size_change(int diff, MEMFLAGS flag) {</span>
<span class="udiff-line-modified-added">+   static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) {</span>
      if (tracking_level() &lt; NMT_summary) return;
      MallocTracker::record_arena_size_change(diff, flag);
    }
  
    static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack&amp; stack,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,35 +247,23 @@</span>
        if (tracking_level() &lt; NMT_summary) return;
        VirtualMemoryTracker::set_reserved_region_type((address)addr, flag);
      }
    }
  
<span class="udiff-line-modified-removed">- #ifdef _AIX</span>
<span class="udiff-line-removed">-   // See JDK-8202772 - temporarily disable thread stack tracking on AIX.</span>
<span class="udiff-line-removed">-   static inline void record_thread_stack(void* addr, size_t size) {}</span>
<span class="udiff-line-removed">-   static inline void release_thread_stack(void* addr, size_t size) {}</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   static inline void record_thread_stack(void* addr, size_t size) {</span>
<span class="udiff-line-modified-added">+   static void record_thread_stack(void* addr, size_t size) {</span>
      if (tracking_level() &lt; NMT_summary) return;
      if (addr != NULL) {
<span class="udiff-line-modified-removed">-       // uses thread stack malloc slot for book keeping number of threads</span>
<span class="udiff-line-removed">-       MallocMemorySummary::record_malloc(0, mtThreadStack);</span>
<span class="udiff-line-removed">-       record_virtual_memory_reserve(addr, size, CALLER_PC, mtThreadStack);</span>
<span class="udiff-line-modified-added">+       ThreadStackTracker::new_thread_stack((address)addr, size, CALLER_PC);</span>
      }
    }
  
    static inline void release_thread_stack(void* addr, size_t size) {
      if (tracking_level() &lt; NMT_summary) return;
      if (addr != NULL) {
<span class="udiff-line-modified-removed">-       // uses thread stack malloc slot for book keeping number of threads</span>
<span class="udiff-line-removed">-       MallocMemorySummary::record_free(0, mtThreadStack);</span>
<span class="udiff-line-removed">-       ThreadCritical tc;</span>
<span class="udiff-line-removed">-       if (tracking_level() &lt; NMT_summary) return;</span>
<span class="udiff-line-removed">-       VirtualMemoryTracker::remove_released_region((address)addr, size);</span>
<span class="udiff-line-modified-added">+       ThreadStackTracker::delete_thread_stack((address)addr, size);</span>
      }
    }
<span class="udiff-line-removed">- #endif</span>
  
    // Query lock is used to synchronize the access to tracking data.
    // So far, it is only used by JCmd query, but it may be used by
    // other tools.
    static inline Mutex* query_lock() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -280,17 +276,11 @@</span>
      if (tracking_level() &gt;= NMT_summary) {
        report(true, output);  // just print summary for error case.
      }
     }
  
<span class="udiff-line-modified-removed">-   static void final_report(outputStream* output) {</span>
<span class="udiff-line-removed">-     NMT_TrackingLevel level = tracking_level();</span>
<span class="udiff-line-removed">-     if (level &gt;= NMT_summary) {</span>
<span class="udiff-line-removed">-       report(level == NMT_summary, output);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   static void final_report(outputStream* output);</span>
  
    // Stored baseline
    static inline MemBaseline&amp; get_baseline() {
      return _baseline;
    }
</pre>
<center><a href="memTracker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
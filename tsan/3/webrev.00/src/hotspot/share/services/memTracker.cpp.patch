diff a/src/hotspot/share/services/memTracker.cpp b/src/hotspot/share/services/memTracker.cpp
--- a/src/hotspot/share/services/memTracker.cpp
+++ b/src/hotspot/share/services/memTracker.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,17 +22,19 @@
  *
  */
 #include "precompiled.hpp"
 #include "jvm.h"
 
+#include "runtime/atomic.hpp"
 #include "runtime/orderAccess.hpp"
 #include "runtime/vmThread.hpp"
 #include "runtime/vmOperations.hpp"
 #include "services/memBaseline.hpp"
 #include "services/memReporter.hpp"
 #include "services/mallocTracker.inline.hpp"
 #include "services/memTracker.hpp"
+#include "services/threadStackTracker.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/defaultStream.hpp"
 #include "utilities/vmError.hpp"
 
 #ifdef _WINDOWS
@@ -90,11 +92,12 @@
 }
 
 void MemTracker::init() {
   NMT_TrackingLevel level = tracking_level();
   if (level >= NMT_summary) {
-    if (!VirtualMemoryTracker::late_initialize(level)) {
+    if (!VirtualMemoryTracker::late_initialize(level) ||
+        !ThreadStackTracker::late_initialize(level)) {
       shutdown();
       return;
     }
   }
 }
@@ -143,11 +146,11 @@
 
 
 // Shutdown can only be issued via JCmd, and NMT JCmd is serialized by lock
 void MemTracker::shutdown() {
   // We can only shutdown NMT to minimal tracking level if it is ever on.
-  if (tracking_level () > NMT_minimal) {
+  if (tracking_level() > NMT_minimal) {
     transition_to(NMT_minimal);
   }
 }
 
 bool MemTracker::transition_to(NMT_TrackingLevel level) {
@@ -162,18 +165,35 @@
     _tracking_level = level;
     // Make _tracking_level visible immediately.
     OrderAccess::fence();
     VirtualMemoryTracker::transition(current_level, level);
     MallocTracker::transition(current_level, level);
+    ThreadStackTracker::transition(current_level, level);
   } else {
     // Upgrading tracking level is not supported and has never been supported.
     // Allocating and deallocating malloc tracking structures is not thread safe and
     // leads to inconsistencies unless a lot coarser locks are added.
   }
   return true;
 }
 
+
+static volatile bool g_final_report_did_run = false;
+void MemTracker::final_report(outputStream* output) {
+  // This function is called during both error reporting and normal VM exit.
+  // However, it should only ever run once.  E.g. if the VM crashes after
+  // printing the final report during normal VM exit, it should not print
+  // the final report again. In addition, it should be guarded from
+  // recursive calls in case NMT reporting itself crashes.
+  if (Atomic::cmpxchg(&g_final_report_did_run, false, true) == false) {
+    NMT_TrackingLevel level = tracking_level();
+    if (level >= NMT_summary) {
+      report(level == NMT_summary, output);
+    }
+  }
+}
+
 void MemTracker::report(bool summary_only, outputStream* output) {
  assert(output != NULL, "No output stream");
   MemBaseline baseline;
   if (baseline.baseline(summary_only)) {
     if (summary_only) {
@@ -181,16 +201,13 @@
       rpt.report();
     } else {
       MemDetailReporter rpt(baseline, output);
       rpt.report();
       output->print("Metaspace:");
-      // Metadata reporting requires a safepoint, so avoid it if VM is not in good state.
-      assert(!VMError::fatal_error_in_progress(), "Do not report metadata in error report");
-      VM_PrintMetadata vmop(output, K,
-          MetaspaceUtils::rf_show_loaders |
-          MetaspaceUtils::rf_break_down_by_spacetype);
-      VMThread::execute(&vmop);
+      // The basic metaspace report avoids any locking and should be safe to
+      // be called at any time.
+      MetaspaceUtils::print_basic_report(output, K);
     }
   }
 }
 
 // This is a walker to gather malloc site hashtable statistics,

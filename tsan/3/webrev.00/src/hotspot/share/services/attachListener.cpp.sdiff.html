<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/attachListener.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/vm_version.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="attachListener.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/attachListener.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;

 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 32 #include &quot;prims/jvmtiExport.hpp&quot;
 33 #include &quot;runtime/arguments.hpp&quot;
 34 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/java.hpp&quot;
 38 #include &quot;runtime/javaCalls.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;services/attachListener.hpp&quot;
 41 #include &quot;services/diagnosticCommand.hpp&quot;
 42 #include &quot;services/heapDumper.hpp&quot;
 43 #include &quot;services/writeableFlags.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 #include &quot;utilities/formatBuffer.hpp&quot;
 46 
<span class="line-modified"> 47 volatile bool AttachListener::_initialized;</span>
 48 
 49 // Implementation of &quot;properties&quot; command.
 50 //
 51 // Invokes VMSupport.serializePropertiesToByteArray to serialize
 52 // the system properties into a byte array.
 53 
 54 static InstanceKlass* load_and_initialize_klass(Symbol* sh, TRAPS) {
 55   Klass* k = SystemDictionary::resolve_or_fail(sh, true, CHECK_NULL);
 56   InstanceKlass* ik = InstanceKlass::cast(k);
 57   if (ik-&gt;should_be_initialized()) {
 58     ik-&gt;initialize(CHECK_NULL);
 59   }
 60   return ik;
 61 }
 62 
 63 static jint get_properties(AttachOperation* op, outputStream* out, Symbol* serializePropertiesMethod) {
 64   Thread* THREAD = Thread::current();
 65   HandleMark hm;
 66 
 67   // load VMSupport
</pre>
<hr />
<pre>
219 //   arg1: &quot;-live&quot; or &quot;-all&quot;
220 jint dump_heap(AttachOperation* op, outputStream* out) {
221   const char* path = op-&gt;arg(0);
222   if (path == NULL || path[0] == &#39;\0&#39;) {
223     out-&gt;print_cr(&quot;No dump file specified&quot;);
224   } else {
225     bool live_objects_only = true;   // default is true to retain the behavior before this change is made
226     const char* arg1 = op-&gt;arg(1);
227     if (arg1 != NULL &amp;&amp; (strlen(arg1) &gt; 0)) {
228       if (strcmp(arg1, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg1, &quot;-live&quot;) != 0) {
229         out-&gt;print_cr(&quot;Invalid argument to dumpheap operation: %s&quot;, arg1);
230         return JNI_ERR;
231       }
232       live_objects_only = strcmp(arg1, &quot;-live&quot;) == 0;
233     }
234 
235     // Request a full GC before heap dump if live_objects_only = true
236     // This helps reduces the amount of unreachable objects in the dump
237     // and makes it easier to browse.
238     HeapDumper dumper(live_objects_only /* request GC */);
<span class="line-modified">239     int res = dumper.dump(op-&gt;arg(0));</span>
<span class="line-removed">240     if (res == 0) {</span>
<span class="line-removed">241       out-&gt;print_cr(&quot;Heap dump file created&quot;);</span>
<span class="line-removed">242     } else {</span>
<span class="line-removed">243       // heap dump failed</span>
<span class="line-removed">244       ResourceMark rm;</span>
<span class="line-removed">245       char* error = dumper.error_as_C_string();</span>
<span class="line-removed">246       if (error == NULL) {</span>
<span class="line-removed">247         out-&gt;print_cr(&quot;Dump failed - reason unknown&quot;);</span>
<span class="line-removed">248       } else {</span>
<span class="line-removed">249         out-&gt;print_cr(&quot;%s&quot;, error);</span>
<span class="line-removed">250       }</span>
<span class="line-removed">251     }</span>
252   }
253   return JNI_OK;
254 }
255 
256 // Implementation of &quot;inspectheap&quot; command
257 // See also: ClassHistogramDCmd class
258 //
259 // Input arguments :-
260 //   arg0: &quot;-live&quot; or &quot;-all&quot;
261 //   arg1: Name of the dump file or NULL
262 static jint heap_inspection(AttachOperation* op, outputStream* out) {
263   bool live_objects_only = true;   // default is true to retain the behavior before this change is made
264   outputStream* os = out;   // if path not specified or path is NULL, use out
265   fileStream* fs = NULL;
266   const char* arg0 = op-&gt;arg(0);
267   if (arg0 != NULL &amp;&amp; (strlen(arg0) &gt; 0)) {
268     if (strcmp(arg0, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg0, &quot;-live&quot;) != 0) {
269       out-&gt;print_cr(&quot;Invalid argument to inspectheap operation: %s&quot;, arg0);
270       return JNI_ERR;
271     }
</pre>
<hr />
<pre>
313       // if the flag is not manageable try to change it through
314       // the platform dependent implementation
315       return AttachListener::pd_set_flag(op, out);
316     } else {
317       out-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
318     }
319 
320     return JNI_ERR;
321   }
322   return JNI_OK;
323 }
324 
325 // Implementation of &quot;printflag&quot; command
326 // See also: PrintVMFlagsDCmd class
327 static jint print_flag(AttachOperation* op, outputStream* out) {
328   const char* name = NULL;
329   if ((name = op-&gt;arg(0)) == NULL) {
330     out-&gt;print_cr(&quot;flag name is missing&quot;);
331     return JNI_ERR;
332   }
<span class="line-modified">333   JVMFlag* f = JVMFlag::find_flag((char*)name, strlen(name));</span>
334   if (f) {
335     f-&gt;print_as_flag(out);
336     out-&gt;cr();
337   } else {
338     out-&gt;print_cr(&quot;no such flag &#39;%s&#39;&quot;, name);
339   }
340   return JNI_OK;
341 }
342 
343 // Table to map operation names to functions.
344 
345 // names must be of length &lt;= AttachOperation::name_length_max
346 static AttachOperationFunctionInfo funcs[] = {
347   { &quot;agentProperties&quot;,  get_agent_properties },
348   { &quot;datadump&quot;,         data_dump },
349   { &quot;dumpheap&quot;,         dump_heap },
350   { &quot;load&quot;,             load_agent },
351   { &quot;properties&quot;,       get_system_properties },
352   { &quot;threaddump&quot;,       thread_dump },
353   { &quot;inspectheap&quot;,      heap_inspection },
354   { &quot;setflag&quot;,          set_flag },
355   { &quot;printflag&quot;,        print_flag },
356   { &quot;jcmd&quot;,             jcmd },
357   { NULL,               NULL }
358 };
359 
360 
361 
362 // The Attach Listener threads services a queue. It dequeues an operation
363 // from the queue, examines the operation name (command), and dispatches
364 // to the corresponding function to perform the operation.
365 
366 static void attach_listener_thread_entry(JavaThread* thread, TRAPS) {
367   os::set_priority(thread, NearMaxPriority);
368 
369   assert(thread == Thread::current(), &quot;Must be&quot;);
370   assert(thread-&gt;stack_base() != NULL &amp;&amp; thread-&gt;stack_size() &gt; 0,
371          &quot;Should already be setup&quot;);
372 
373   if (AttachListener::pd_init() != 0) {

374     return;
375   }
376   AttachListener::set_initialized();
377 
378   for (;;) {
379     AttachOperation* op = AttachListener::dequeue();
380     if (op == NULL) {

381       return;   // dequeue failed or shutdown
382     }
383 
384     ResourceMark rm;
385     bufferedStream st;
386     jint res = JNI_OK;
387 
388     // handle special detachall operation
389     if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {
390       AttachListener::detachall();
391     } else if (!EnableDynamicAgentLoading &amp;&amp; strcmp(op-&gt;name(), &quot;load&quot;) == 0) {
392       st.print(&quot;Dynamic agent loading is not enabled. &quot;
393                &quot;Use -XX:+EnableDynamicAgentLoading to launch target VM.&quot;);
394       res = JNI_ERR;
395     } else {
396       // find the function to dispatch too
397       AttachOperationFunctionInfo* info = NULL;
398       for (int i=0; funcs[i].name != NULL; i++) {
399         const char* name = funcs[i].name;
400         assert(strlen(name) &lt;= AttachOperation::name_length_max, &quot;operation &lt;= name_length_max&quot;);
</pre>
<hr />
<pre>
404         }
405       }
406 
407       // check for platform dependent attach operation
408       if (info == NULL) {
409         info = AttachListener::pd_find_operation(op-&gt;name());
410       }
411 
412       if (info != NULL) {
413         // dispatch to the function that implements this operation
414         res = (info-&gt;func)(op, &amp;st);
415       } else {
416         st.print(&quot;Operation %s not recognized!&quot;, op-&gt;name());
417         res = JNI_ERR;
418       }
419     }
420 
421     // operation complete - send result and output to client
422     op-&gt;complete(res, &amp;st);
423   }


424 }
425 
426 bool AttachListener::has_init_error(TRAPS) {
427   if (HAS_PENDING_EXCEPTION) {
428     tty-&gt;print_cr(&quot;Exception in VM (AttachListener::init) : &quot;);
429     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
430     tty-&gt;cr();
431 
432     CLEAR_PENDING_EXCEPTION;
433 
434     return true;
435   } else {
436     return false;
437   }
438 }
439 
440 // Starts the Attach Listener thread
441 void AttachListener::init() {
442   EXCEPTION_MARK;
443 
444   const char thread_name[] = &quot;Attach Listener&quot;;
445   Handle string = java_lang_String::create_from_str(thread_name, THREAD);
446   if (has_init_error(THREAD)) {

447     return;
448   }
449 
450   // Initialize thread_oop to put it into the system threadGroup
451   Handle thread_group (THREAD, Universe::system_thread_group());
452   Handle thread_oop = JavaCalls::construct_new_instance(SystemDictionary::Thread_klass(),
453                        vmSymbols::threadgroup_string_void_signature(),
454                        thread_group,
455                        string,
456                        THREAD);
457   if (has_init_error(THREAD)) {

458     return;
459   }
460 
461   Klass* group = SystemDictionary::ThreadGroup_klass();
462   JavaValue result(T_VOID);
463   JavaCalls::call_special(&amp;result,
464                         thread_group,
465                         group,
466                         vmSymbols::add_method_name(),
467                         vmSymbols::thread_void_signature(),
468                         thread_oop,
469                         THREAD);
470   if (has_init_error(THREAD)) {

471     return;
472   }
473 
<span class="line-modified">474   { MutexLocker mu(Threads_lock);</span>
475     JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);
476 
477     // Check that thread and osthread were created
478     if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
479       vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
480                                     os::native_thread_creation_failed_msg());
481     }
482 
483     java_lang_Thread::set_thread(thread_oop(), listener_thread);
484     java_lang_Thread::set_daemon(thread_oop());
485 
486     listener_thread-&gt;set_threadObj(thread_oop());
487     Threads::add(listener_thread);
488     Thread::start(listener_thread);
489   }
490 }
491 
492 // Performs clean-up tasks on platforms where we can detect that the last
493 // client has detached
494 void AttachListener::detachall() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 30 #include &quot;memory/universe.hpp&quot;</span>
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 33 #include &quot;prims/jvmtiExport.hpp&quot;
 34 #include &quot;runtime/arguments.hpp&quot;
 35 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 36 #include &quot;runtime/globals.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 #include &quot;runtime/javaCalls.hpp&quot;
 40 #include &quot;runtime/os.hpp&quot;
 41 #include &quot;services/attachListener.hpp&quot;
 42 #include &quot;services/diagnosticCommand.hpp&quot;
 43 #include &quot;services/heapDumper.hpp&quot;
 44 #include &quot;services/writeableFlags.hpp&quot;
 45 #include &quot;utilities/debug.hpp&quot;
 46 #include &quot;utilities/formatBuffer.hpp&quot;
 47 
<span class="line-modified"> 48 volatile AttachListenerState AttachListener::_state = AL_NOT_INITIALIZED;</span>
 49 
 50 // Implementation of &quot;properties&quot; command.
 51 //
 52 // Invokes VMSupport.serializePropertiesToByteArray to serialize
 53 // the system properties into a byte array.
 54 
 55 static InstanceKlass* load_and_initialize_klass(Symbol* sh, TRAPS) {
 56   Klass* k = SystemDictionary::resolve_or_fail(sh, true, CHECK_NULL);
 57   InstanceKlass* ik = InstanceKlass::cast(k);
 58   if (ik-&gt;should_be_initialized()) {
 59     ik-&gt;initialize(CHECK_NULL);
 60   }
 61   return ik;
 62 }
 63 
 64 static jint get_properties(AttachOperation* op, outputStream* out, Symbol* serializePropertiesMethod) {
 65   Thread* THREAD = Thread::current();
 66   HandleMark hm;
 67 
 68   // load VMSupport
</pre>
<hr />
<pre>
220 //   arg1: &quot;-live&quot; or &quot;-all&quot;
221 jint dump_heap(AttachOperation* op, outputStream* out) {
222   const char* path = op-&gt;arg(0);
223   if (path == NULL || path[0] == &#39;\0&#39;) {
224     out-&gt;print_cr(&quot;No dump file specified&quot;);
225   } else {
226     bool live_objects_only = true;   // default is true to retain the behavior before this change is made
227     const char* arg1 = op-&gt;arg(1);
228     if (arg1 != NULL &amp;&amp; (strlen(arg1) &gt; 0)) {
229       if (strcmp(arg1, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg1, &quot;-live&quot;) != 0) {
230         out-&gt;print_cr(&quot;Invalid argument to dumpheap operation: %s&quot;, arg1);
231         return JNI_ERR;
232       }
233       live_objects_only = strcmp(arg1, &quot;-live&quot;) == 0;
234     }
235 
236     // Request a full GC before heap dump if live_objects_only = true
237     // This helps reduces the amount of unreachable objects in the dump
238     // and makes it easier to browse.
239     HeapDumper dumper(live_objects_only /* request GC */);
<span class="line-modified">240     dumper.dump(op-&gt;arg(0), out);</span>












241   }
242   return JNI_OK;
243 }
244 
245 // Implementation of &quot;inspectheap&quot; command
246 // See also: ClassHistogramDCmd class
247 //
248 // Input arguments :-
249 //   arg0: &quot;-live&quot; or &quot;-all&quot;
250 //   arg1: Name of the dump file or NULL
251 static jint heap_inspection(AttachOperation* op, outputStream* out) {
252   bool live_objects_only = true;   // default is true to retain the behavior before this change is made
253   outputStream* os = out;   // if path not specified or path is NULL, use out
254   fileStream* fs = NULL;
255   const char* arg0 = op-&gt;arg(0);
256   if (arg0 != NULL &amp;&amp; (strlen(arg0) &gt; 0)) {
257     if (strcmp(arg0, &quot;-all&quot;) != 0 &amp;&amp; strcmp(arg0, &quot;-live&quot;) != 0) {
258       out-&gt;print_cr(&quot;Invalid argument to inspectheap operation: %s&quot;, arg0);
259       return JNI_ERR;
260     }
</pre>
<hr />
<pre>
302       // if the flag is not manageable try to change it through
303       // the platform dependent implementation
304       return AttachListener::pd_set_flag(op, out);
305     } else {
306       out-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
307     }
308 
309     return JNI_ERR;
310   }
311   return JNI_OK;
312 }
313 
314 // Implementation of &quot;printflag&quot; command
315 // See also: PrintVMFlagsDCmd class
316 static jint print_flag(AttachOperation* op, outputStream* out) {
317   const char* name = NULL;
318   if ((name = op-&gt;arg(0)) == NULL) {
319     out-&gt;print_cr(&quot;flag name is missing&quot;);
320     return JNI_ERR;
321   }
<span class="line-modified">322   JVMFlag* f = JVMFlag::find_flag(name);</span>
323   if (f) {
324     f-&gt;print_as_flag(out);
325     out-&gt;cr();
326   } else {
327     out-&gt;print_cr(&quot;no such flag &#39;%s&#39;&quot;, name);
328   }
329   return JNI_OK;
330 }
331 
332 // Table to map operation names to functions.
333 
334 // names must be of length &lt;= AttachOperation::name_length_max
335 static AttachOperationFunctionInfo funcs[] = {
336   { &quot;agentProperties&quot;,  get_agent_properties },
337   { &quot;datadump&quot;,         data_dump },
338   { &quot;dumpheap&quot;,         dump_heap },
339   { &quot;load&quot;,             load_agent },
340   { &quot;properties&quot;,       get_system_properties },
341   { &quot;threaddump&quot;,       thread_dump },
342   { &quot;inspectheap&quot;,      heap_inspection },
343   { &quot;setflag&quot;,          set_flag },
344   { &quot;printflag&quot;,        print_flag },
345   { &quot;jcmd&quot;,             jcmd },
346   { NULL,               NULL }
347 };
348 
349 
350 
351 // The Attach Listener threads services a queue. It dequeues an operation
352 // from the queue, examines the operation name (command), and dispatches
353 // to the corresponding function to perform the operation.
354 
355 static void attach_listener_thread_entry(JavaThread* thread, TRAPS) {
356   os::set_priority(thread, NearMaxPriority);
357 
358   assert(thread == Thread::current(), &quot;Must be&quot;);
359   assert(thread-&gt;stack_base() != NULL &amp;&amp; thread-&gt;stack_size() &gt; 0,
360          &quot;Should already be setup&quot;);
361 
362   if (AttachListener::pd_init() != 0) {
<span class="line-added">363     AttachListener::set_state(AL_NOT_INITIALIZED);</span>
364     return;
365   }
366   AttachListener::set_initialized();
367 
368   for (;;) {
369     AttachOperation* op = AttachListener::dequeue();
370     if (op == NULL) {
<span class="line-added">371       AttachListener::set_state(AL_NOT_INITIALIZED);</span>
372       return;   // dequeue failed or shutdown
373     }
374 
375     ResourceMark rm;
376     bufferedStream st;
377     jint res = JNI_OK;
378 
379     // handle special detachall operation
380     if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {
381       AttachListener::detachall();
382     } else if (!EnableDynamicAgentLoading &amp;&amp; strcmp(op-&gt;name(), &quot;load&quot;) == 0) {
383       st.print(&quot;Dynamic agent loading is not enabled. &quot;
384                &quot;Use -XX:+EnableDynamicAgentLoading to launch target VM.&quot;);
385       res = JNI_ERR;
386     } else {
387       // find the function to dispatch too
388       AttachOperationFunctionInfo* info = NULL;
389       for (int i=0; funcs[i].name != NULL; i++) {
390         const char* name = funcs[i].name;
391         assert(strlen(name) &lt;= AttachOperation::name_length_max, &quot;operation &lt;= name_length_max&quot;);
</pre>
<hr />
<pre>
395         }
396       }
397 
398       // check for platform dependent attach operation
399       if (info == NULL) {
400         info = AttachListener::pd_find_operation(op-&gt;name());
401       }
402 
403       if (info != NULL) {
404         // dispatch to the function that implements this operation
405         res = (info-&gt;func)(op, &amp;st);
406       } else {
407         st.print(&quot;Operation %s not recognized!&quot;, op-&gt;name());
408         res = JNI_ERR;
409       }
410     }
411 
412     // operation complete - send result and output to client
413     op-&gt;complete(res, &amp;st);
414   }
<span class="line-added">415 </span>
<span class="line-added">416   ShouldNotReachHere();</span>
417 }
418 
419 bool AttachListener::has_init_error(TRAPS) {
420   if (HAS_PENDING_EXCEPTION) {
421     tty-&gt;print_cr(&quot;Exception in VM (AttachListener::init) : &quot;);
422     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
423     tty-&gt;cr();
424 
425     CLEAR_PENDING_EXCEPTION;
426 
427     return true;
428   } else {
429     return false;
430   }
431 }
432 
433 // Starts the Attach Listener thread
434 void AttachListener::init() {
435   EXCEPTION_MARK;
436 
437   const char thread_name[] = &quot;Attach Listener&quot;;
438   Handle string = java_lang_String::create_from_str(thread_name, THREAD);
439   if (has_init_error(THREAD)) {
<span class="line-added">440     set_state(AL_NOT_INITIALIZED);</span>
441     return;
442   }
443 
444   // Initialize thread_oop to put it into the system threadGroup
445   Handle thread_group (THREAD, Universe::system_thread_group());
446   Handle thread_oop = JavaCalls::construct_new_instance(SystemDictionary::Thread_klass(),
447                        vmSymbols::threadgroup_string_void_signature(),
448                        thread_group,
449                        string,
450                        THREAD);
451   if (has_init_error(THREAD)) {
<span class="line-added">452     set_state(AL_NOT_INITIALIZED);</span>
453     return;
454   }
455 
456   Klass* group = SystemDictionary::ThreadGroup_klass();
457   JavaValue result(T_VOID);
458   JavaCalls::call_special(&amp;result,
459                         thread_group,
460                         group,
461                         vmSymbols::add_method_name(),
462                         vmSymbols::thread_void_signature(),
463                         thread_oop,
464                         THREAD);
465   if (has_init_error(THREAD)) {
<span class="line-added">466     set_state(AL_NOT_INITIALIZED);</span>
467     return;
468   }
469 
<span class="line-modified">470   { MutexLocker mu(THREAD, Threads_lock);</span>
471     JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);
472 
473     // Check that thread and osthread were created
474     if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
475       vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
476                                     os::native_thread_creation_failed_msg());
477     }
478 
479     java_lang_Thread::set_thread(thread_oop(), listener_thread);
480     java_lang_Thread::set_daemon(thread_oop());
481 
482     listener_thread-&gt;set_threadObj(thread_oop());
483     Threads::add(listener_thread);
484     Thread::start(listener_thread);
485   }
486 }
487 
488 // Performs clean-up tasks on platforms where we can detect that the last
489 // client has detached
490 void AttachListener::detachall() {
</pre>
</td>
</tr>
</table>
<center><a href="../runtime/vm_version.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="attachListener.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
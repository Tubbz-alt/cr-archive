<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiCodeBlobEvents.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderExt.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/modules.hpp&quot;
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;interpreter/bytecodeStream.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;

  34 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logConfiguration.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;prims/jniCheck.hpp&quot;
  43 #include &quot;prims/jvm_misc.hpp&quot;
  44 #include &quot;prims/jvmtiAgentThread.hpp&quot;
  45 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
  46 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  47 #include &quot;prims/jvmtiExtensions.hpp&quot;
  48 #include &quot;prims/jvmtiGetLoadedClasses.hpp&quot;
  49 #include &quot;prims/jvmtiImpl.hpp&quot;
  50 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  51 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  52 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  53 #include &quot;prims/jvmtiTagMap.hpp&quot;
</pre>
<hr />
<pre>
  60 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  61 #include &quot;runtime/javaCalls.hpp&quot;
  62 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  63 #include &quot;runtime/jniHandles.inline.hpp&quot;
  64 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  65 #include &quot;runtime/osThread.hpp&quot;
  66 #include &quot;runtime/reflectionUtils.hpp&quot;
  67 #include &quot;runtime/signature.hpp&quot;
  68 #include &quot;runtime/thread.inline.hpp&quot;
  69 #include &quot;runtime/threadHeapSampler.hpp&quot;
  70 #include &quot;runtime/threadSMR.hpp&quot;
  71 #include &quot;runtime/timerTrace.hpp&quot;
  72 #include &quot;runtime/vframe.inline.hpp&quot;
  73 #include &quot;runtime/vmThread.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #if INCLUDE_TSAN
  76 #include &quot;tsan/tsan.hpp&quot;
  77 #endif  // INCLUDE_TSAN
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/preserveException.hpp&quot;

  80 
  81 
  82 #define FIXLATER 0 // REMOVE this when completed.
  83 
  84  // FIXLATER: hook into JvmtiTrace
  85 #define TraceJVMTICalls false
  86 
  87 JvmtiEnv::JvmtiEnv(jint version) : JvmtiEnvBase(version) {
  88 }
  89 
  90 JvmtiEnv::~JvmtiEnv() {
  91 }
  92 
  93 JvmtiEnv*
  94 JvmtiEnv::create_a_jvmti(jint version) {
  95   return new JvmtiEnv(version);
  96 }
  97 
  98 // VM operation class to copy jni function table at safepoint.
  99 // More than one java threads or jvmti agents may be reading/
</pre>
<hr />
<pre>
 431     if (ik-&gt;get_cached_class_file_bytes() == NULL) {
 432       // Not cached, we need to reconstitute the class file from the
 433       // VM representation. We don&#39;t attach the reconstituted class
 434       // bytes to the InstanceKlass here because they have not been
 435       // validated and we&#39;re not at a safepoint.
 436       JvmtiClassFileReconstituter reconstituter(ik);
 437       if (reconstituter.get_error() != JVMTI_ERROR_NONE) {
 438         return reconstituter.get_error();
 439       }
 440 
 441       class_definitions[index].class_byte_count = (jint)reconstituter.class_file_size();
 442       class_definitions[index].class_bytes      = (unsigned char*)
 443                                                        reconstituter.class_file_bytes();
 444     } else {
 445       // it is cached, get it from the cache
 446       class_definitions[index].class_byte_count = ik-&gt;get_cached_class_file_len();
 447       class_definitions[index].class_bytes      = ik-&gt;get_cached_class_file_bytes();
 448     }
 449     class_definitions[index].klass              = jcls;
 450   }

 451   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
 452   VMThread::execute(&amp;op);
<span class="line-modified"> 453   return (op.check_error());</span>






 454 } /* end RetransformClasses */
 455 
 456 
 457 // class_count - pre-checked to be greater than or equal to 0
 458 // class_definitions - pre-checked for NULL
 459 jvmtiError
 460 JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) {
 461 //TODO: add locking

 462   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
 463   VMThread::execute(&amp;op);
<span class="line-modified"> 464   return (op.check_error());</span>






 465 } /* end RedefineClasses */
 466 
 467 
 468   //
 469   // Object functions
 470   //
 471 
 472 // size_ptr - pre-checked for NULL
 473 jvmtiError
 474 JvmtiEnv::GetObjectSize(jobject object, jlong* size_ptr) {
 475   oop mirror = JNIHandles::resolve_external_guard(object);
 476   NULL_CHECK(mirror, JVMTI_ERROR_INVALID_OBJECT);
 477   *size_ptr = (jlong)Universe::heap()-&gt;obj_size(mirror) * wordSize;
 478   return JVMTI_ERROR_NONE;
 479 } /* end GetObjectSize */
 480 
 481   //
 482   // Method functions
 483   //
 484 
</pre>
<hr />
<pre>
 794   jvmtiError err = allocate(len, (unsigned char**)name_ptr);
 795   if (err == JVMTI_ERROR_NONE) {
 796     memcpy(*name_ptr, name, len);
 797   }
 798   return err;
 799 } /* end GetErrorName */
 800 
 801 
 802 jvmtiError
 803 JvmtiEnv::SetVerboseFlag(jvmtiVerboseFlag flag, jboolean value) {
 804   LogLevelType level = value == 0 ? LogLevel::Off : LogLevel::Info;
 805   switch (flag) {
 806   case JVMTI_VERBOSE_OTHER:
 807     // ignore
 808     break;
 809   case JVMTI_VERBOSE_CLASS:
 810     LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));
 811     LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));
 812     break;
 813   case JVMTI_VERBOSE_GC:
<span class="line-modified"> 814     if (value == 0) {</span>
<span class="line-removed"> 815       LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(gc));</span>
<span class="line-removed"> 816     } else {</span>
<span class="line-removed"> 817       LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));</span>
<span class="line-removed"> 818     }</span>
 819     break;
 820   case JVMTI_VERBOSE_JNI:
<span class="line-modified"> 821     PrintJNIResolving = value != 0;</span>

 822     break;
 823   default:
 824     return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 825   };
 826   return JVMTI_ERROR_NONE;
 827 } /* end SetVerboseFlag */
 828 
 829 
 830 // format_ptr - pre-checked for NULL
 831 jvmtiError
 832 JvmtiEnv::GetJLocationFormat(jvmtiJlocationFormat* format_ptr) {
 833   *format_ptr = JVMTI_JLOCATION_JVMBCI;
 834   return JVMTI_ERROR_NONE;
 835 } /* end GetJLocationFormat */
 836 
 837   //
 838   // Thread functions
 839   //
 840 
 841 // Threads_lock NOT held
</pre>
<hr />
<pre>
 864       if (thread_oop == NULL) {
 865         return err;
 866       }
 867       // We have a valid thread_oop so we can return some thread state.
 868     }
 869   }
 870 
 871   // get most state bits
 872   jint state = (jint)java_lang_Thread::get_thread_status(thread_oop);
 873 
 874   if (java_thread != NULL) {
 875     // We have a JavaThread* so add more state bits.
 876     JavaThreadState jts = java_thread-&gt;thread_state();
 877 
 878     if (java_thread-&gt;is_being_ext_suspended()) {
 879       state |= JVMTI_THREAD_STATE_SUSPENDED;
 880     }
 881     if (jts == _thread_in_native) {
 882       state |= JVMTI_THREAD_STATE_IN_NATIVE;
 883     }
<span class="line-modified"> 884     OSThread* osThread = java_thread-&gt;osthread();</span>
<span class="line-removed"> 885     if (osThread != NULL &amp;&amp; osThread-&gt;interrupted()) {</span>
 886       state |= JVMTI_THREAD_STATE_INTERRUPTED;
 887     }
 888   }
 889 
 890   *thread_state_ptr = state;
 891   return JVMTI_ERROR_NONE;
 892 } /* end GetThreadState */
 893 
 894 
 895 // thread_ptr - pre-checked for NULL
 896 jvmtiError
 897 JvmtiEnv::GetCurrentThread(jthread* thread_ptr) {
 898   JavaThread* current_thread  = JavaThread::current();
 899   *thread_ptr = (jthread)JNIHandles::make_local(current_thread, current_thread-&gt;threadObj());
 900   return JVMTI_ERROR_NONE;
 901 } /* end GetCurrentThread */
 902 
 903 
 904 // threads_count_ptr - pre-checked for NULL
 905 // threads_ptr - pre-checked for NULL
</pre>
<hr />
<pre>
 928   }
 929 
 930   jthread *jthreads  = new_jthreadArray(nthreads, thread_objs);
 931   NULL_CHECK(jthreads, JVMTI_ERROR_OUT_OF_MEMORY);
 932 
 933   *threads_ptr = jthreads;
 934   return JVMTI_ERROR_NONE;
 935 } /* end GetAllThreads */
 936 
 937 
 938 // Threads_lock NOT held, java_thread not protected by lock
 939 // java_thread - pre-checked
 940 jvmtiError
 941 JvmtiEnv::SuspendThread(JavaThread* java_thread) {
 942   // don&#39;t allow hidden thread suspend request.
 943   if (java_thread-&gt;is_hidden_from_external_view()) {
 944     return (JVMTI_ERROR_NONE);
 945   }
 946 
 947   {
<span class="line-modified"> 948     MutexLockerEx ml(java_thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
 949     if (java_thread-&gt;is_external_suspend()) {
 950       // don&#39;t allow nested external suspend requests.
 951       return (JVMTI_ERROR_THREAD_SUSPENDED);
 952     }
 953     if (java_thread-&gt;is_exiting()) { // thread is in the process of exiting
 954       return (JVMTI_ERROR_THREAD_NOT_ALIVE);
 955     }
 956     java_thread-&gt;set_external_suspend();
 957   }
 958 
 959   if (!JvmtiSuspendControl::suspend(java_thread)) {
 960     // the thread was in the process of exiting
 961     return (JVMTI_ERROR_THREAD_NOT_ALIVE);
 962   }
 963   return JVMTI_ERROR_NONE;
 964 } /* end SuspendThread */
 965 
 966 
 967 // request_count - pre-checked to be greater than or equal to 0
 968 // request_list - pre-checked for NULL
 969 // results - pre-checked for NULL
 970 jvmtiError
 971 JvmtiEnv::SuspendThreadList(jint request_count, const jthread* request_list, jvmtiError* results) {
 972   int needSafepoint = 0;  // &gt; 0 if we need a safepoint
 973   ThreadsListHandle tlh;
 974   for (int i = 0; i &lt; request_count; i++) {
 975     JavaThread *java_thread = NULL;
 976     jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), request_list[i], &amp;java_thread, NULL);
 977     if (err != JVMTI_ERROR_NONE) {
 978       results[i] = err;
 979       continue;
 980     }
 981     // don&#39;t allow hidden thread suspend request.
 982     if (java_thread-&gt;is_hidden_from_external_view()) {
 983       results[i] = JVMTI_ERROR_NONE;  // indicate successful suspend
 984       continue;
 985     }
 986 
 987     {
<span class="line-modified"> 988       MutexLockerEx ml(java_thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
 989       if (java_thread-&gt;is_external_suspend()) {
 990         // don&#39;t allow nested external suspend requests.
 991         results[i] = JVMTI_ERROR_THREAD_SUSPENDED;
 992         continue;
 993       }
 994       if (java_thread-&gt;is_exiting()) { // thread is in the process of exiting
 995         results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;
 996         continue;
 997       }
 998       java_thread-&gt;set_external_suspend();
 999     }
1000     if (java_thread-&gt;thread_state() == _thread_in_native) {
1001       // We need to try and suspend native threads here. Threads in
1002       // other states will self-suspend on their next transition.
1003       if (!JvmtiSuspendControl::suspend(java_thread)) {
1004         // The thread was in the process of exiting. Force another
1005         // safepoint to make sure that this thread transitions.
1006         needSafepoint++;
1007         results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;
1008         continue;
</pre>
<hr />
<pre>
1077 
1078 
1079 // Threads_lock NOT held, java_thread not protected by lock
1080 // java_thread - pre-checked
1081 jvmtiError
1082 JvmtiEnv::StopThread(JavaThread* java_thread, jobject exception) {
1083   oop e = JNIHandles::resolve_external_guard(exception);
1084   NULL_CHECK(e, JVMTI_ERROR_NULL_POINTER);
1085 
1086   JavaThread::send_async_exception(java_thread-&gt;threadObj(), e);
1087 
1088   return JVMTI_ERROR_NONE;
1089 
1090 } /* end StopThread */
1091 
1092 
1093 // Threads_lock NOT held
1094 // thread - NOT pre-checked
1095 jvmtiError
1096 JvmtiEnv::InterruptThread(jthread thread) {
<span class="line-removed">1097   // TODO: this is very similar to JVM_Interrupt(); share code in future</span>
1098   JavaThread* current_thread  = JavaThread::current();
1099   JavaThread* java_thread = NULL;
1100   ThreadsListHandle tlh(current_thread);
1101   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, NULL);
1102   if (err != JVMTI_ERROR_NONE) {
1103     return err;
1104   }
<span class="line-modified">1105 </span>
<span class="line-modified">1106   Thread::interrupt(java_thread);</span>




1107 
1108   return JVMTI_ERROR_NONE;
1109 } /* end InterruptThread */
1110 
1111 
1112 // Threads_lock NOT held
1113 // thread - NOT pre-checked
1114 // info_ptr - pre-checked for NULL
1115 jvmtiError
1116 JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
1117   ResourceMark rm;
1118   HandleMark hm;
1119 
1120   JavaThread* current_thread = JavaThread::current();
1121   ThreadsListHandle tlh(current_thread);
1122 
1123   // if thread is NULL the current thread is used
1124   oop thread_oop = NULL;
1125   if (thread == NULL) {
1126     thread_oop = current_thread-&gt;threadObj();
</pre>
<hr />
<pre>
1316     // We got an error code so we don&#39;t have a JavaThread *, but
1317     // only return an error from here if we didn&#39;t get a valid
1318     // thread_oop.
1319     if (thread_oop == NULL) {
1320       return err;
1321     }
1322     // We have a valid thread_oop.
1323   }
1324 
1325   if (java_thread != NULL) {
1326     // &#39;thread&#39; refers to an existing JavaThread.
1327     return JVMTI_ERROR_INVALID_THREAD;
1328   }
1329 
1330   if (priority &lt; JVMTI_THREAD_MIN_PRIORITY || priority &gt; JVMTI_THREAD_MAX_PRIORITY) {
1331     return JVMTI_ERROR_INVALID_PRIORITY;
1332   }
1333 
1334   Handle thread_hndl(current_thread, thread_oop);
1335   {
<span class="line-modified">1336     MutexLocker mu(Threads_lock); // grab Threads_lock</span>
1337 
1338     JvmtiAgentThread *new_thread = new JvmtiAgentThread(this, proc, arg);
1339 
1340     // At this point it may be possible that no osthread was created for the
1341     // JavaThread due to lack of memory.
1342     if (new_thread == NULL || new_thread-&gt;osthread() == NULL) {
1343       if (new_thread != NULL) {
1344         new_thread-&gt;smr_delete();
1345       }
1346       return JVMTI_ERROR_OUT_OF_MEMORY;
1347     }
1348 
1349     java_lang_Thread::set_thread(thread_hndl(), new_thread);
1350     java_lang_Thread::set_priority(thread_hndl(), (ThreadPriority)priority);
1351     java_lang_Thread::set_daemon(thread_hndl());
1352 
1353     new_thread-&gt;set_threadObj(thread_hndl());
1354     Threads::add(new_thread);
1355     Thread::start(new_thread);
1356   } // unlock Threads_lock
</pre>
<hr />
<pre>
3138       jvmti_table[i].slot = slot;
3139     }
3140   }
3141 
3142   // set results
3143   (*entry_count_ptr) = num_entries;
3144   (*table_ptr) = jvmti_table;
3145 
3146   return JVMTI_ERROR_NONE;
3147 } /* end GetLocalVariableTable */
3148 
3149 
3150 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method
3151 // bytecode_count_ptr - pre-checked for NULL
3152 // bytecodes_ptr - pre-checked for NULL
3153 jvmtiError
3154 JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {
3155   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
3156 
3157   HandleMark hm;
<span class="line-modified">3158   methodHandle method(method_oop);</span>
3159   jint size = (jint)method-&gt;code_size();
3160   jvmtiError err = allocate(size, bytecodes_ptr);
3161   if (err != JVMTI_ERROR_NONE) {
3162     return err;
3163   }
3164 
3165   (*bytecode_count_ptr) = size;
3166   // get byte codes
3167   JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);
3168 
3169   return JVMTI_ERROR_NONE;
3170 } /* end GetBytecodes */
3171 
3172 
3173 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method
3174 // is_native_ptr - pre-checked for NULL
3175 jvmtiError
3176 JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {
3177   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
3178   (*is_native_ptr) = method_oop-&gt;is_native();
</pre>
<hr />
<pre>
3220 
3221 // name - pre-checked for NULL
3222 // monitor_ptr - pre-checked for NULL
3223 jvmtiError
3224 JvmtiEnv::CreateRawMonitor(const char* name, jrawMonitorID* monitor_ptr) {
3225   JvmtiRawMonitor* rmonitor = new JvmtiRawMonitor(name);
3226   NULL_CHECK(rmonitor, JVMTI_ERROR_OUT_OF_MEMORY);
3227 
3228   *monitor_ptr = (jrawMonitorID)rmonitor;
3229 
3230   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(rmonitor));
3231 
3232   return JVMTI_ERROR_NONE;
3233 } /* end CreateRawMonitor */
3234 
3235 
3236 // rmonitor - pre-checked for validity
3237 jvmtiError
3238 JvmtiEnv::DestroyRawMonitor(JvmtiRawMonitor * rmonitor) {
3239   if (Threads::number_of_threads() == 0) {
<span class="line-modified">3240     // Remove this  monitor from pending raw monitors list</span>
3241     // if it has entered in onload or start phase.
3242     JvmtiPendingMonitors::destroy(rmonitor);
3243   } else {
3244     Thread* thread  = Thread::current();
<span class="line-modified">3245     if (rmonitor-&gt;is_entered(thread)) {</span>
3246       // The caller owns this monitor which we are about to destroy.
3247       // We exit the underlying synchronization object so that the
3248       // &quot;delete monitor&quot; call below can work without an assertion
3249       // failure on systems that don&#39;t like destroying synchronization
3250       // objects that are locked.
3251       int r;
<span class="line-modified">3252       intptr_t recursion = rmonitor-&gt;recursions();</span>
<span class="line-modified">3253       for (intptr_t i = 0; i &lt;= recursion; i++) {</span>
3254         TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
3255         r = rmonitor-&gt;raw_exit(thread);
<span class="line-modified">3256         assert(r == ObjectMonitor::OM_OK, &quot;raw_exit should have worked&quot;);</span>
<span class="line-modified">3257         if (r != ObjectMonitor::OM_OK) {  // robustness</span>
3258           return JVMTI_ERROR_INTERNAL;
3259         }
3260       }
3261     }
3262     if (rmonitor-&gt;owner() != NULL) {
3263       // The caller is trying to destroy a monitor that is locked by
3264       // someone else. While this is not forbidden by the JVMTI
3265       // spec, it will cause an assertion failure on systems that don&#39;t
3266       // like destroying synchronization objects that are locked.
3267       // We indicate a problem with the error return (and leak the
3268       // monitor&#39;s memory).
3269       return JVMTI_ERROR_NOT_MONITOR_OWNER;
3270     }
3271   }
3272 
3273   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(rmonitor));
3274   delete rmonitor;
3275 
3276   return JVMTI_ERROR_NONE;
3277 } /* end DestroyRawMonitor */
3278 
3279 
3280 // rmonitor - pre-checked for validity
3281 jvmtiError
3282 JvmtiEnv::RawMonitorEnter(JvmtiRawMonitor * rmonitor) {
3283   if (Threads::number_of_threads() == 0) {
<span class="line-modified">3284     // No JavaThreads exist so ObjectMonitor enter cannot be</span>
3285     // used, add this raw monitor to the pending list.
3286     // The pending monitors will be actually entered when
3287     // the VM is setup.
3288     // See transition_pending_raw_monitors in create_vm()
3289     // in thread.cpp.
3290     JvmtiPendingMonitors::enter(rmonitor);
3291   } else {
<span class="line-removed">3292     int r = 0;</span>
3293     Thread* thread = Thread::current();
<span class="line-removed">3294 </span>
3295     if (thread-&gt;is_Java_thread()) {
3296       JavaThread* current_thread = (JavaThread*)thread;
3297 
<span class="line-removed">3298 #ifdef PROPER_TRANSITIONS</span>
<span class="line-removed">3299       // Not really unknown but ThreadInVMfromNative does more than we want</span>
<span class="line-removed">3300       ThreadInVMfromUnknown __tiv;</span>
<span class="line-removed">3301       {</span>
<span class="line-removed">3302         ThreadBlockInVM __tbivm(current_thread);</span>
<span class="line-removed">3303         r = rmonitor-&gt;raw_enter(current_thread);</span>
<span class="line-removed">3304       }</span>
<span class="line-removed">3305 #else</span>
3306       /* Transition to thread_blocked without entering vm state          */
3307       /* This is really evil. Normally you can&#39;t undo _thread_blocked    */
3308       /* transitions like this because it would cause us to miss a       */
3309       /* safepoint but since the thread was already in _thread_in_native */
3310       /* the thread is not leaving a safepoint safe state and it will    */
3311       /* block when it tries to return from native. We can&#39;t safepoint   */
3312       /* block in here because we could deadlock the vmthread. Blech.    */
3313 
3314       JavaThreadState state = current_thread-&gt;thread_state();
3315       assert(state == _thread_in_native, &quot;Must be _thread_in_native&quot;);
3316       // frame should already be walkable since we are in native
3317       assert(!current_thread-&gt;has_last_Java_frame() ||
3318              current_thread-&gt;frame_anchor()-&gt;walkable(), &quot;Must be walkable&quot;);
3319       current_thread-&gt;set_thread_state(_thread_blocked);
3320 
<span class="line-modified">3321       r = rmonitor-&gt;raw_enter(current_thread);</span>
3322       // restore state, still at a safepoint safe state
3323       current_thread-&gt;set_thread_state(state);
<span class="line-removed">3324 </span>
<span class="line-removed">3325 #endif /* PROPER_TRANSITIONS */</span>
<span class="line-removed">3326       assert(r == ObjectMonitor::OM_OK, &quot;raw_enter should have worked&quot;);</span>
3327     } else {
<span class="line-modified">3328       if (thread-&gt;is_Named_thread()) {</span>
<span class="line-removed">3329         r = rmonitor-&gt;raw_enter(thread);</span>
<span class="line-removed">3330       } else {</span>
<span class="line-removed">3331         ShouldNotReachHere();</span>
<span class="line-removed">3332       }</span>
<span class="line-removed">3333     }</span>
<span class="line-removed">3334 </span>
<span class="line-removed">3335     if (r != ObjectMonitor::OM_OK) {  // robustness</span>
<span class="line-removed">3336       return JVMTI_ERROR_INTERNAL;</span>
3337     }
3338     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));
3339   }
3340   return JVMTI_ERROR_NONE;
3341 } /* end RawMonitorEnter */
3342 
3343 
3344 // rmonitor - pre-checked for validity
3345 jvmtiError
3346 JvmtiEnv::RawMonitorExit(JvmtiRawMonitor * rmonitor) {
3347   jvmtiError err = JVMTI_ERROR_NONE;
3348 
3349   if (Threads::number_of_threads() == 0) {
3350     // No JavaThreads exist so just remove this monitor from the pending list.
3351     // Bool value from exit is false if rmonitor is not in the list.
3352     if (!JvmtiPendingMonitors::exit(rmonitor)) {
3353       err = JVMTI_ERROR_NOT_MONITOR_OWNER;
3354     }
3355   } else {
<span class="line-removed">3356     int r = 0;</span>
3357     Thread* thread = Thread::current();
<span class="line-removed">3358 </span>
3359     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
<span class="line-modified">3360 </span>
<span class="line-modified">3361     if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">3362       JavaThread* current_thread = (JavaThread*)thread;</span>
<span class="line-removed">3363 #ifdef PROPER_TRANSITIONS</span>
<span class="line-removed">3364       // Not really unknown but ThreadInVMfromNative does more than we want</span>
<span class="line-removed">3365       ThreadInVMfromUnknown __tiv;</span>
<span class="line-removed">3366 #endif /* PROPER_TRANSITIONS */</span>
<span class="line-removed">3367       r = rmonitor-&gt;raw_exit(current_thread);</span>
<span class="line-removed">3368     } else {</span>
<span class="line-removed">3369       if (thread-&gt;is_Named_thread()) {</span>
<span class="line-removed">3370         r = rmonitor-&gt;raw_exit(thread);</span>
<span class="line-removed">3371       } else {</span>
<span class="line-removed">3372         ShouldNotReachHere();</span>
<span class="line-removed">3373       }</span>
<span class="line-removed">3374     }</span>
<span class="line-removed">3375 </span>
<span class="line-removed">3376     if (r == ObjectMonitor::OM_ILLEGAL_MONITOR_STATE) {</span>
3377       err = JVMTI_ERROR_NOT_MONITOR_OWNER;
<span class="line-removed">3378     } else {</span>
<span class="line-removed">3379       assert(r == ObjectMonitor::OM_OK, &quot;raw_exit should have worked&quot;);</span>
<span class="line-removed">3380       if (r != ObjectMonitor::OM_OK) {  // robustness</span>
<span class="line-removed">3381         err = JVMTI_ERROR_INTERNAL;</span>
<span class="line-removed">3382       }</span>
3383     }
3384   }
3385   return err;
3386 } /* end RawMonitorExit */
3387 
3388 
3389 // rmonitor - pre-checked for validity
3390 jvmtiError
3391 JvmtiEnv::RawMonitorWait(JvmtiRawMonitor * rmonitor, jlong millis) {
<span class="line-removed">3392   int r = 0;</span>
3393   Thread* thread = Thread::current();
3394 
3395   // A wait is modeled in Tsan as a simple release-acquire pair.
3396   // The matching release annotation is below.
3397   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
<span class="line-modified">3398 </span>
<span class="line-removed">3399   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">3400     JavaThread* current_thread = (JavaThread*)thread;</span>
<span class="line-removed">3401 #ifdef PROPER_TRANSITIONS</span>
<span class="line-removed">3402     // Not really unknown but ThreadInVMfromNative does more than we want</span>
<span class="line-removed">3403     ThreadInVMfromUnknown __tiv;</span>
<span class="line-removed">3404     {</span>
<span class="line-removed">3405       ThreadBlockInVM __tbivm(current_thread);</span>
<span class="line-removed">3406       r = rmonitor-&gt;raw_wait(millis, true, current_thread);</span>
<span class="line-removed">3407     }</span>
<span class="line-removed">3408 #else</span>
<span class="line-removed">3409     /* Transition to thread_blocked without entering vm state          */</span>
<span class="line-removed">3410     /* This is really evil. Normally you can&#39;t undo _thread_blocked    */</span>
<span class="line-removed">3411     /* transitions like this because it would cause us to miss a       */</span>
<span class="line-removed">3412     /* safepoint but since the thread was already in _thread_in_native */</span>
<span class="line-removed">3413     /* the thread is not leaving a safepoint safe state and it will    */</span>
<span class="line-removed">3414     /* block when it tries to return from native. We can&#39;t safepoint   */</span>
<span class="line-removed">3415     /* block in here because we could deadlock the vmthread. Blech.    */</span>
<span class="line-removed">3416 </span>
<span class="line-removed">3417     JavaThreadState state = current_thread-&gt;thread_state();</span>
<span class="line-removed">3418     assert(state == _thread_in_native, &quot;Must be _thread_in_native&quot;);</span>
<span class="line-removed">3419     // frame should already be walkable since we are in native</span>
<span class="line-removed">3420     assert(!current_thread-&gt;has_last_Java_frame() ||</span>
<span class="line-removed">3421            current_thread-&gt;frame_anchor()-&gt;walkable(), &quot;Must be walkable&quot;);</span>
<span class="line-removed">3422     current_thread-&gt;set_thread_state(_thread_blocked);</span>
<span class="line-removed">3423 </span>
<span class="line-removed">3424     r = rmonitor-&gt;raw_wait(millis, true, current_thread);</span>
<span class="line-removed">3425     // restore state, still at a safepoint safe state</span>
<span class="line-removed">3426     current_thread-&gt;set_thread_state(state);</span>
<span class="line-removed">3427 </span>
<span class="line-removed">3428 #endif /* PROPER_TRANSITIONS */</span>
<span class="line-removed">3429   } else {</span>
<span class="line-removed">3430     if (thread-&gt;is_Named_thread()) {</span>
<span class="line-removed">3431       r = rmonitor-&gt;raw_wait(millis, true, thread);</span>
<span class="line-removed">3432     } else {</span>
<span class="line-removed">3433       ShouldNotReachHere();</span>
<span class="line-removed">3434     }</span>
<span class="line-removed">3435   }</span>
<span class="line-removed">3436 </span>
<span class="line-removed">3437   // A wait is modeled in Tsan as a simple release-acquire pair.</span>
3438   // The matching acquire annotation is above.
3439   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));
3440 
3441   switch (r) {
<span class="line-modified">3442   case ObjectMonitor::OM_INTERRUPTED:</span>
3443     return JVMTI_ERROR_INTERRUPT;
<span class="line-modified">3444   case ObjectMonitor::OM_ILLEGAL_MONITOR_STATE:</span>
3445     return JVMTI_ERROR_NOT_MONITOR_OWNER;


3446   }
<span class="line-removed">3447   assert(r == ObjectMonitor::OM_OK, &quot;raw_wait should have worked&quot;);</span>
<span class="line-removed">3448   if (r != ObjectMonitor::OM_OK) {  // robustness</span>
<span class="line-removed">3449     return JVMTI_ERROR_INTERNAL;</span>
<span class="line-removed">3450   }</span>
<span class="line-removed">3451 </span>
<span class="line-removed">3452   return JVMTI_ERROR_NONE;</span>
3453 } /* end RawMonitorWait */
3454 
3455 
3456 // rmonitor - pre-checked for validity
3457 jvmtiError
3458 JvmtiEnv::RawMonitorNotify(JvmtiRawMonitor * rmonitor) {
<span class="line-removed">3459   int r = 0;</span>
3460   Thread* thread = Thread::current();

3461 
<span class="line-modified">3462   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">3463     JavaThread* current_thread = (JavaThread*)thread;</span>
<span class="line-removed">3464     // Not really unknown but ThreadInVMfromNative does more than we want</span>
<span class="line-removed">3465     ThreadInVMfromUnknown __tiv;</span>
<span class="line-removed">3466     r = rmonitor-&gt;raw_notify(current_thread);</span>
<span class="line-removed">3467   } else {</span>
<span class="line-removed">3468     if (thread-&gt;is_Named_thread()) {</span>
<span class="line-removed">3469       r = rmonitor-&gt;raw_notify(thread);</span>
<span class="line-removed">3470     } else {</span>
<span class="line-removed">3471       ShouldNotReachHere();</span>
<span class="line-removed">3472     }</span>
<span class="line-removed">3473   }</span>
<span class="line-removed">3474 </span>
<span class="line-removed">3475   if (r == ObjectMonitor::OM_ILLEGAL_MONITOR_STATE) {</span>
3476     return JVMTI_ERROR_NOT_MONITOR_OWNER;
3477   }
<span class="line-removed">3478   assert(r == ObjectMonitor::OM_OK, &quot;raw_notify should have worked&quot;);</span>
<span class="line-removed">3479   if (r != ObjectMonitor::OM_OK) {  // robustness</span>
<span class="line-removed">3480     return JVMTI_ERROR_INTERNAL;</span>
<span class="line-removed">3481   }</span>
<span class="line-removed">3482 </span>
3483   return JVMTI_ERROR_NONE;
3484 } /* end RawMonitorNotify */
3485 
3486 
3487 // rmonitor - pre-checked for validity
3488 jvmtiError
3489 JvmtiEnv::RawMonitorNotifyAll(JvmtiRawMonitor * rmonitor) {
<span class="line-removed">3490   int r = 0;</span>
3491   Thread* thread = Thread::current();

3492 
<span class="line-modified">3493   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">3494     JavaThread* current_thread = (JavaThread*)thread;</span>
<span class="line-removed">3495     ThreadInVMfromUnknown __tiv;</span>
<span class="line-removed">3496     r = rmonitor-&gt;raw_notifyAll(current_thread);</span>
<span class="line-removed">3497   } else {</span>
<span class="line-removed">3498     if (thread-&gt;is_Named_thread()) {</span>
<span class="line-removed">3499       r = rmonitor-&gt;raw_notifyAll(thread);</span>
<span class="line-removed">3500     } else {</span>
<span class="line-removed">3501       ShouldNotReachHere();</span>
<span class="line-removed">3502     }</span>
<span class="line-removed">3503   }</span>
<span class="line-removed">3504 </span>
<span class="line-removed">3505   if (r == ObjectMonitor::OM_ILLEGAL_MONITOR_STATE) {</span>
3506     return JVMTI_ERROR_NOT_MONITOR_OWNER;
3507   }
<span class="line-removed">3508   assert(r == ObjectMonitor::OM_OK, &quot;raw_notifyAll should have worked&quot;);</span>
<span class="line-removed">3509   if (r != ObjectMonitor::OM_OK) {  // robustness</span>
<span class="line-removed">3510     return JVMTI_ERROR_INTERNAL;</span>
<span class="line-removed">3511   }</span>
<span class="line-removed">3512 </span>
3513   return JVMTI_ERROR_NONE;
3514 } /* end RawMonitorNotifyAll */
3515 
3516 
3517   //
3518   // JNI Function Interception functions
3519   //
3520 
3521 
3522 // function_table - pre-checked for NULL
3523 jvmtiError
3524 JvmtiEnv::SetJNIFunctionTable(const jniNativeInterface* function_table) {
3525   // Copy jni function table at safepoint.
3526   VM_JNIFunctionTableCopier copier(function_table);
3527   VMThread::execute(&amp;copier);
3528 
3529   return JVMTI_ERROR_NONE;
3530 } /* end SetJNIFunctionTable */
3531 
3532 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderExt.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/modules.hpp&quot;
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;interpreter/bytecodeStream.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">  34 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  35 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  36 #include &quot;logging/log.hpp&quot;
  37 #include &quot;logging/logConfiguration.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;oops/instanceKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;prims/jniCheck.hpp&quot;
  44 #include &quot;prims/jvm_misc.hpp&quot;
  45 #include &quot;prims/jvmtiAgentThread.hpp&quot;
  46 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
  47 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  48 #include &quot;prims/jvmtiExtensions.hpp&quot;
  49 #include &quot;prims/jvmtiGetLoadedClasses.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  52 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  53 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  54 #include &quot;prims/jvmtiTagMap.hpp&quot;
</pre>
<hr />
<pre>
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/javaCalls.hpp&quot;
  63 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  66 #include &quot;runtime/osThread.hpp&quot;
  67 #include &quot;runtime/reflectionUtils.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/threadHeapSampler.hpp&quot;
  71 #include &quot;runtime/threadSMR.hpp&quot;
  72 #include &quot;runtime/timerTrace.hpp&quot;
  73 #include &quot;runtime/vframe.inline.hpp&quot;
  74 #include &quot;runtime/vmThread.hpp&quot;
  75 #include &quot;services/threadService.hpp&quot;
  76 #if INCLUDE_TSAN
  77 #include &quot;tsan/tsan.hpp&quot;
  78 #endif  // INCLUDE_TSAN
  79 #include &quot;utilities/exceptions.hpp&quot;
  80 #include &quot;utilities/preserveException.hpp&quot;
<span class="line-added">  81 #include &quot;utilities/utf8.hpp&quot;</span>
  82 
  83 
  84 #define FIXLATER 0 // REMOVE this when completed.
  85 
  86  // FIXLATER: hook into JvmtiTrace
  87 #define TraceJVMTICalls false
  88 
  89 JvmtiEnv::JvmtiEnv(jint version) : JvmtiEnvBase(version) {
  90 }
  91 
  92 JvmtiEnv::~JvmtiEnv() {
  93 }
  94 
  95 JvmtiEnv*
  96 JvmtiEnv::create_a_jvmti(jint version) {
  97   return new JvmtiEnv(version);
  98 }
  99 
 100 // VM operation class to copy jni function table at safepoint.
 101 // More than one java threads or jvmti agents may be reading/
</pre>
<hr />
<pre>
 433     if (ik-&gt;get_cached_class_file_bytes() == NULL) {
 434       // Not cached, we need to reconstitute the class file from the
 435       // VM representation. We don&#39;t attach the reconstituted class
 436       // bytes to the InstanceKlass here because they have not been
 437       // validated and we&#39;re not at a safepoint.
 438       JvmtiClassFileReconstituter reconstituter(ik);
 439       if (reconstituter.get_error() != JVMTI_ERROR_NONE) {
 440         return reconstituter.get_error();
 441       }
 442 
 443       class_definitions[index].class_byte_count = (jint)reconstituter.class_file_size();
 444       class_definitions[index].class_bytes      = (unsigned char*)
 445                                                        reconstituter.class_file_bytes();
 446     } else {
 447       // it is cached, get it from the cache
 448       class_definitions[index].class_byte_count = ik-&gt;get_cached_class_file_len();
 449       class_definitions[index].class_bytes      = ik-&gt;get_cached_class_file_bytes();
 450     }
 451     class_definitions[index].klass              = jcls;
 452   }
<span class="line-added"> 453   EventRetransformClasses event;</span>
 454   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
 455   VMThread::execute(&amp;op);
<span class="line-modified"> 456   jvmtiError error = op.check_error();</span>
<span class="line-added"> 457   if (error == JVMTI_ERROR_NONE) {</span>
<span class="line-added"> 458     event.set_classCount(class_count);</span>
<span class="line-added"> 459     event.set_redefinitionId(op.id());</span>
<span class="line-added"> 460     event.commit();</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462   return error;</span>
 463 } /* end RetransformClasses */
 464 
 465 
 466 // class_count - pre-checked to be greater than or equal to 0
 467 // class_definitions - pre-checked for NULL
 468 jvmtiError
 469 JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) {
 470 //TODO: add locking
<span class="line-added"> 471   EventRedefineClasses event;</span>
 472   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
 473   VMThread::execute(&amp;op);
<span class="line-modified"> 474   jvmtiError error = op.check_error();</span>
<span class="line-added"> 475   if (error == JVMTI_ERROR_NONE) {</span>
<span class="line-added"> 476     event.set_classCount(class_count);</span>
<span class="line-added"> 477     event.set_redefinitionId(op.id());</span>
<span class="line-added"> 478     event.commit();</span>
<span class="line-added"> 479   }</span>
<span class="line-added"> 480   return error;</span>
 481 } /* end RedefineClasses */
 482 
 483 
 484   //
 485   // Object functions
 486   //
 487 
 488 // size_ptr - pre-checked for NULL
 489 jvmtiError
 490 JvmtiEnv::GetObjectSize(jobject object, jlong* size_ptr) {
 491   oop mirror = JNIHandles::resolve_external_guard(object);
 492   NULL_CHECK(mirror, JVMTI_ERROR_INVALID_OBJECT);
 493   *size_ptr = (jlong)Universe::heap()-&gt;obj_size(mirror) * wordSize;
 494   return JVMTI_ERROR_NONE;
 495 } /* end GetObjectSize */
 496 
 497   //
 498   // Method functions
 499   //
 500 
</pre>
<hr />
<pre>
 810   jvmtiError err = allocate(len, (unsigned char**)name_ptr);
 811   if (err == JVMTI_ERROR_NONE) {
 812     memcpy(*name_ptr, name, len);
 813   }
 814   return err;
 815 } /* end GetErrorName */
 816 
 817 
 818 jvmtiError
 819 JvmtiEnv::SetVerboseFlag(jvmtiVerboseFlag flag, jboolean value) {
 820   LogLevelType level = value == 0 ? LogLevel::Off : LogLevel::Info;
 821   switch (flag) {
 822   case JVMTI_VERBOSE_OTHER:
 823     // ignore
 824     break;
 825   case JVMTI_VERBOSE_CLASS:
 826     LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));
 827     LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));
 828     break;
 829   case JVMTI_VERBOSE_GC:
<span class="line-modified"> 830     LogConfiguration::configure_stdout(level, true, LOG_TAGS(gc));</span>




 831     break;
 832   case JVMTI_VERBOSE_JNI:
<span class="line-modified"> 833     level = value == 0 ? LogLevel::Off : LogLevel::Debug;</span>
<span class="line-added"> 834     LogConfiguration::configure_stdout(level, true, LOG_TAGS(jni, resolve));</span>
 835     break;
 836   default:
 837     return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 838   };
 839   return JVMTI_ERROR_NONE;
 840 } /* end SetVerboseFlag */
 841 
 842 
 843 // format_ptr - pre-checked for NULL
 844 jvmtiError
 845 JvmtiEnv::GetJLocationFormat(jvmtiJlocationFormat* format_ptr) {
 846   *format_ptr = JVMTI_JLOCATION_JVMBCI;
 847   return JVMTI_ERROR_NONE;
 848 } /* end GetJLocationFormat */
 849 
 850   //
 851   // Thread functions
 852   //
 853 
 854 // Threads_lock NOT held
</pre>
<hr />
<pre>
 877       if (thread_oop == NULL) {
 878         return err;
 879       }
 880       // We have a valid thread_oop so we can return some thread state.
 881     }
 882   }
 883 
 884   // get most state bits
 885   jint state = (jint)java_lang_Thread::get_thread_status(thread_oop);
 886 
 887   if (java_thread != NULL) {
 888     // We have a JavaThread* so add more state bits.
 889     JavaThreadState jts = java_thread-&gt;thread_state();
 890 
 891     if (java_thread-&gt;is_being_ext_suspended()) {
 892       state |= JVMTI_THREAD_STATE_SUSPENDED;
 893     }
 894     if (jts == _thread_in_native) {
 895       state |= JVMTI_THREAD_STATE_IN_NATIVE;
 896     }
<span class="line-modified"> 897     if (java_thread-&gt;is_interrupted(false)) {</span>

 898       state |= JVMTI_THREAD_STATE_INTERRUPTED;
 899     }
 900   }
 901 
 902   *thread_state_ptr = state;
 903   return JVMTI_ERROR_NONE;
 904 } /* end GetThreadState */
 905 
 906 
 907 // thread_ptr - pre-checked for NULL
 908 jvmtiError
 909 JvmtiEnv::GetCurrentThread(jthread* thread_ptr) {
 910   JavaThread* current_thread  = JavaThread::current();
 911   *thread_ptr = (jthread)JNIHandles::make_local(current_thread, current_thread-&gt;threadObj());
 912   return JVMTI_ERROR_NONE;
 913 } /* end GetCurrentThread */
 914 
 915 
 916 // threads_count_ptr - pre-checked for NULL
 917 // threads_ptr - pre-checked for NULL
</pre>
<hr />
<pre>
 940   }
 941 
 942   jthread *jthreads  = new_jthreadArray(nthreads, thread_objs);
 943   NULL_CHECK(jthreads, JVMTI_ERROR_OUT_OF_MEMORY);
 944 
 945   *threads_ptr = jthreads;
 946   return JVMTI_ERROR_NONE;
 947 } /* end GetAllThreads */
 948 
 949 
 950 // Threads_lock NOT held, java_thread not protected by lock
 951 // java_thread - pre-checked
 952 jvmtiError
 953 JvmtiEnv::SuspendThread(JavaThread* java_thread) {
 954   // don&#39;t allow hidden thread suspend request.
 955   if (java_thread-&gt;is_hidden_from_external_view()) {
 956     return (JVMTI_ERROR_NONE);
 957   }
 958 
 959   {
<span class="line-modified"> 960     MutexLocker ml(java_thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
 961     if (java_thread-&gt;is_external_suspend()) {
 962       // don&#39;t allow nested external suspend requests.
 963       return (JVMTI_ERROR_THREAD_SUSPENDED);
 964     }
 965     if (java_thread-&gt;is_exiting()) { // thread is in the process of exiting
 966       return (JVMTI_ERROR_THREAD_NOT_ALIVE);
 967     }
 968     java_thread-&gt;set_external_suspend();
 969   }
 970 
 971   if (!JvmtiSuspendControl::suspend(java_thread)) {
 972     // the thread was in the process of exiting
 973     return (JVMTI_ERROR_THREAD_NOT_ALIVE);
 974   }
 975   return JVMTI_ERROR_NONE;
 976 } /* end SuspendThread */
 977 
 978 
 979 // request_count - pre-checked to be greater than or equal to 0
 980 // request_list - pre-checked for NULL
 981 // results - pre-checked for NULL
 982 jvmtiError
 983 JvmtiEnv::SuspendThreadList(jint request_count, const jthread* request_list, jvmtiError* results) {
 984   int needSafepoint = 0;  // &gt; 0 if we need a safepoint
 985   ThreadsListHandle tlh;
 986   for (int i = 0; i &lt; request_count; i++) {
 987     JavaThread *java_thread = NULL;
 988     jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), request_list[i], &amp;java_thread, NULL);
 989     if (err != JVMTI_ERROR_NONE) {
 990       results[i] = err;
 991       continue;
 992     }
 993     // don&#39;t allow hidden thread suspend request.
 994     if (java_thread-&gt;is_hidden_from_external_view()) {
 995       results[i] = JVMTI_ERROR_NONE;  // indicate successful suspend
 996       continue;
 997     }
 998 
 999     {
<span class="line-modified">1000       MutexLocker ml(java_thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
1001       if (java_thread-&gt;is_external_suspend()) {
1002         // don&#39;t allow nested external suspend requests.
1003         results[i] = JVMTI_ERROR_THREAD_SUSPENDED;
1004         continue;
1005       }
1006       if (java_thread-&gt;is_exiting()) { // thread is in the process of exiting
1007         results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;
1008         continue;
1009       }
1010       java_thread-&gt;set_external_suspend();
1011     }
1012     if (java_thread-&gt;thread_state() == _thread_in_native) {
1013       // We need to try and suspend native threads here. Threads in
1014       // other states will self-suspend on their next transition.
1015       if (!JvmtiSuspendControl::suspend(java_thread)) {
1016         // The thread was in the process of exiting. Force another
1017         // safepoint to make sure that this thread transitions.
1018         needSafepoint++;
1019         results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;
1020         continue;
</pre>
<hr />
<pre>
1089 
1090 
1091 // Threads_lock NOT held, java_thread not protected by lock
1092 // java_thread - pre-checked
1093 jvmtiError
1094 JvmtiEnv::StopThread(JavaThread* java_thread, jobject exception) {
1095   oop e = JNIHandles::resolve_external_guard(exception);
1096   NULL_CHECK(e, JVMTI_ERROR_NULL_POINTER);
1097 
1098   JavaThread::send_async_exception(java_thread-&gt;threadObj(), e);
1099 
1100   return JVMTI_ERROR_NONE;
1101 
1102 } /* end StopThread */
1103 
1104 
1105 // Threads_lock NOT held
1106 // thread - NOT pre-checked
1107 jvmtiError
1108 JvmtiEnv::InterruptThread(jthread thread) {

1109   JavaThread* current_thread  = JavaThread::current();
1110   JavaThread* java_thread = NULL;
1111   ThreadsListHandle tlh(current_thread);
1112   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, NULL);
1113   if (err != JVMTI_ERROR_NONE) {
1114     return err;
1115   }
<span class="line-modified">1116   // Really this should be a Java call to Thread.interrupt to ensure the same</span>
<span class="line-modified">1117   // semantics, however historically this has not been done for some reason.</span>
<span class="line-added">1118   // So we continue with that (which means we don&#39;t interact with any Java-level</span>
<span class="line-added">1119   // Interruptible object) but we must set the Java-level interrupted state.</span>
<span class="line-added">1120   java_lang_Thread::set_interrupted(JNIHandles::resolve(thread), true);</span>
<span class="line-added">1121   java_thread-&gt;interrupt();</span>
1122 
1123   return JVMTI_ERROR_NONE;
1124 } /* end InterruptThread */
1125 
1126 
1127 // Threads_lock NOT held
1128 // thread - NOT pre-checked
1129 // info_ptr - pre-checked for NULL
1130 jvmtiError
1131 JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
1132   ResourceMark rm;
1133   HandleMark hm;
1134 
1135   JavaThread* current_thread = JavaThread::current();
1136   ThreadsListHandle tlh(current_thread);
1137 
1138   // if thread is NULL the current thread is used
1139   oop thread_oop = NULL;
1140   if (thread == NULL) {
1141     thread_oop = current_thread-&gt;threadObj();
</pre>
<hr />
<pre>
1331     // We got an error code so we don&#39;t have a JavaThread *, but
1332     // only return an error from here if we didn&#39;t get a valid
1333     // thread_oop.
1334     if (thread_oop == NULL) {
1335       return err;
1336     }
1337     // We have a valid thread_oop.
1338   }
1339 
1340   if (java_thread != NULL) {
1341     // &#39;thread&#39; refers to an existing JavaThread.
1342     return JVMTI_ERROR_INVALID_THREAD;
1343   }
1344 
1345   if (priority &lt; JVMTI_THREAD_MIN_PRIORITY || priority &gt; JVMTI_THREAD_MAX_PRIORITY) {
1346     return JVMTI_ERROR_INVALID_PRIORITY;
1347   }
1348 
1349   Handle thread_hndl(current_thread, thread_oop);
1350   {
<span class="line-modified">1351     MutexLocker mu(current_thread, Threads_lock); // grab Threads_lock</span>
1352 
1353     JvmtiAgentThread *new_thread = new JvmtiAgentThread(this, proc, arg);
1354 
1355     // At this point it may be possible that no osthread was created for the
1356     // JavaThread due to lack of memory.
1357     if (new_thread == NULL || new_thread-&gt;osthread() == NULL) {
1358       if (new_thread != NULL) {
1359         new_thread-&gt;smr_delete();
1360       }
1361       return JVMTI_ERROR_OUT_OF_MEMORY;
1362     }
1363 
1364     java_lang_Thread::set_thread(thread_hndl(), new_thread);
1365     java_lang_Thread::set_priority(thread_hndl(), (ThreadPriority)priority);
1366     java_lang_Thread::set_daemon(thread_hndl());
1367 
1368     new_thread-&gt;set_threadObj(thread_hndl());
1369     Threads::add(new_thread);
1370     Thread::start(new_thread);
1371   } // unlock Threads_lock
</pre>
<hr />
<pre>
3153       jvmti_table[i].slot = slot;
3154     }
3155   }
3156 
3157   // set results
3158   (*entry_count_ptr) = num_entries;
3159   (*table_ptr) = jvmti_table;
3160 
3161   return JVMTI_ERROR_NONE;
3162 } /* end GetLocalVariableTable */
3163 
3164 
3165 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method
3166 // bytecode_count_ptr - pre-checked for NULL
3167 // bytecodes_ptr - pre-checked for NULL
3168 jvmtiError
3169 JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {
3170   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
3171 
3172   HandleMark hm;
<span class="line-modified">3173   methodHandle method(Thread::current(), method_oop);</span>
3174   jint size = (jint)method-&gt;code_size();
3175   jvmtiError err = allocate(size, bytecodes_ptr);
3176   if (err != JVMTI_ERROR_NONE) {
3177     return err;
3178   }
3179 
3180   (*bytecode_count_ptr) = size;
3181   // get byte codes
3182   JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);
3183 
3184   return JVMTI_ERROR_NONE;
3185 } /* end GetBytecodes */
3186 
3187 
3188 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method
3189 // is_native_ptr - pre-checked for NULL
3190 jvmtiError
3191 JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {
3192   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);
3193   (*is_native_ptr) = method_oop-&gt;is_native();
</pre>
<hr />
<pre>
3235 
3236 // name - pre-checked for NULL
3237 // monitor_ptr - pre-checked for NULL
3238 jvmtiError
3239 JvmtiEnv::CreateRawMonitor(const char* name, jrawMonitorID* monitor_ptr) {
3240   JvmtiRawMonitor* rmonitor = new JvmtiRawMonitor(name);
3241   NULL_CHECK(rmonitor, JVMTI_ERROR_OUT_OF_MEMORY);
3242 
3243   *monitor_ptr = (jrawMonitorID)rmonitor;
3244 
3245   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(rmonitor));
3246 
3247   return JVMTI_ERROR_NONE;
3248 } /* end CreateRawMonitor */
3249 
3250 
3251 // rmonitor - pre-checked for validity
3252 jvmtiError
3253 JvmtiEnv::DestroyRawMonitor(JvmtiRawMonitor * rmonitor) {
3254   if (Threads::number_of_threads() == 0) {
<span class="line-modified">3255     // Remove this monitor from pending raw monitors list</span>
3256     // if it has entered in onload or start phase.
3257     JvmtiPendingMonitors::destroy(rmonitor);
3258   } else {
3259     Thread* thread  = Thread::current();
<span class="line-modified">3260     if (rmonitor-&gt;owner() == thread) {</span>
3261       // The caller owns this monitor which we are about to destroy.
3262       // We exit the underlying synchronization object so that the
3263       // &quot;delete monitor&quot; call below can work without an assertion
3264       // failure on systems that don&#39;t like destroying synchronization
3265       // objects that are locked.
3266       int r;
<span class="line-modified">3267       int recursion = rmonitor-&gt;recursions();</span>
<span class="line-modified">3268       for (int i = 0; i &lt;= recursion; i++) {</span>
3269         TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
3270         r = rmonitor-&gt;raw_exit(thread);
<span class="line-modified">3271         assert(r == JvmtiRawMonitor::M_OK, &quot;raw_exit should have worked&quot;);</span>
<span class="line-modified">3272         if (r != JvmtiRawMonitor::M_OK) {  // robustness</span>
3273           return JVMTI_ERROR_INTERNAL;
3274         }
3275       }
3276     }
3277     if (rmonitor-&gt;owner() != NULL) {
3278       // The caller is trying to destroy a monitor that is locked by
3279       // someone else. While this is not forbidden by the JVMTI
3280       // spec, it will cause an assertion failure on systems that don&#39;t
3281       // like destroying synchronization objects that are locked.
3282       // We indicate a problem with the error return (and leak the
3283       // monitor&#39;s memory).
3284       return JVMTI_ERROR_NOT_MONITOR_OWNER;
3285     }
3286   }
3287 
3288   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(rmonitor));
3289   delete rmonitor;
3290 
3291   return JVMTI_ERROR_NONE;
3292 } /* end DestroyRawMonitor */
3293 
3294 
3295 // rmonitor - pre-checked for validity
3296 jvmtiError
3297 JvmtiEnv::RawMonitorEnter(JvmtiRawMonitor * rmonitor) {
3298   if (Threads::number_of_threads() == 0) {
<span class="line-modified">3299     // No JavaThreads exist so JvmtiRawMonitor enter cannot be</span>
3300     // used, add this raw monitor to the pending list.
3301     // The pending monitors will be actually entered when
3302     // the VM is setup.
3303     // See transition_pending_raw_monitors in create_vm()
3304     // in thread.cpp.
3305     JvmtiPendingMonitors::enter(rmonitor);
3306   } else {

3307     Thread* thread = Thread::current();

3308     if (thread-&gt;is_Java_thread()) {
3309       JavaThread* current_thread = (JavaThread*)thread;
3310 








3311       /* Transition to thread_blocked without entering vm state          */
3312       /* This is really evil. Normally you can&#39;t undo _thread_blocked    */
3313       /* transitions like this because it would cause us to miss a       */
3314       /* safepoint but since the thread was already in _thread_in_native */
3315       /* the thread is not leaving a safepoint safe state and it will    */
3316       /* block when it tries to return from native. We can&#39;t safepoint   */
3317       /* block in here because we could deadlock the vmthread. Blech.    */
3318 
3319       JavaThreadState state = current_thread-&gt;thread_state();
3320       assert(state == _thread_in_native, &quot;Must be _thread_in_native&quot;);
3321       // frame should already be walkable since we are in native
3322       assert(!current_thread-&gt;has_last_Java_frame() ||
3323              current_thread-&gt;frame_anchor()-&gt;walkable(), &quot;Must be walkable&quot;);
3324       current_thread-&gt;set_thread_state(_thread_blocked);
3325 
<span class="line-modified">3326       rmonitor-&gt;raw_enter(current_thread);</span>
3327       // restore state, still at a safepoint safe state
3328       current_thread-&gt;set_thread_state(state);



3329     } else {
<span class="line-modified">3330       rmonitor-&gt;raw_enter(thread);</span>








3331     }
3332     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));
3333   }
3334   return JVMTI_ERROR_NONE;
3335 } /* end RawMonitorEnter */
3336 
3337 
3338 // rmonitor - pre-checked for validity
3339 jvmtiError
3340 JvmtiEnv::RawMonitorExit(JvmtiRawMonitor * rmonitor) {
3341   jvmtiError err = JVMTI_ERROR_NONE;
3342 
3343   if (Threads::number_of_threads() == 0) {
3344     // No JavaThreads exist so just remove this monitor from the pending list.
3345     // Bool value from exit is false if rmonitor is not in the list.
3346     if (!JvmtiPendingMonitors::exit(rmonitor)) {
3347       err = JVMTI_ERROR_NOT_MONITOR_OWNER;
3348     }
3349   } else {

3350     Thread* thread = Thread::current();

3351     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
<span class="line-modified">3352     int r = rmonitor-&gt;raw_exit(thread);</span>
<span class="line-modified">3353     if (r == JvmtiRawMonitor::M_ILLEGAL_MONITOR_STATE) {</span>















3354       err = JVMTI_ERROR_NOT_MONITOR_OWNER;





3355     }
3356   }
3357   return err;
3358 } /* end RawMonitorExit */
3359 
3360 
3361 // rmonitor - pre-checked for validity
3362 jvmtiError
3363 JvmtiEnv::RawMonitorWait(JvmtiRawMonitor * rmonitor, jlong millis) {

3364   Thread* thread = Thread::current();
3365 
3366   // A wait is modeled in Tsan as a simple release-acquire pair.
3367   // The matching release annotation is below.
3368   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));
<span class="line-modified">3369   int r = rmonitor-&gt;raw_wait(millis, thread);</span>







































3370   // The matching acquire annotation is above.
3371   TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));
3372 
3373   switch (r) {
<span class="line-modified">3374   case JvmtiRawMonitor::M_INTERRUPTED:</span>
3375     return JVMTI_ERROR_INTERRUPT;
<span class="line-modified">3376   case JvmtiRawMonitor::M_ILLEGAL_MONITOR_STATE:</span>
3377     return JVMTI_ERROR_NOT_MONITOR_OWNER;
<span class="line-added">3378   default:</span>
<span class="line-added">3379     return JVMTI_ERROR_NONE;</span>
3380   }






3381 } /* end RawMonitorWait */
3382 
3383 
3384 // rmonitor - pre-checked for validity
3385 jvmtiError
3386 JvmtiEnv::RawMonitorNotify(JvmtiRawMonitor * rmonitor) {

3387   Thread* thread = Thread::current();
<span class="line-added">3388   int r = rmonitor-&gt;raw_notify(thread);</span>
3389 
<span class="line-modified">3390   if (r == JvmtiRawMonitor::M_ILLEGAL_MONITOR_STATE) {</span>













3391     return JVMTI_ERROR_NOT_MONITOR_OWNER;
3392   }





3393   return JVMTI_ERROR_NONE;
3394 } /* end RawMonitorNotify */
3395 
3396 
3397 // rmonitor - pre-checked for validity
3398 jvmtiError
3399 JvmtiEnv::RawMonitorNotifyAll(JvmtiRawMonitor * rmonitor) {

3400   Thread* thread = Thread::current();
<span class="line-added">3401   int r = rmonitor-&gt;raw_notifyAll(thread);</span>
3402 
<span class="line-modified">3403   if (r == JvmtiRawMonitor::M_ILLEGAL_MONITOR_STATE) {</span>












3404     return JVMTI_ERROR_NOT_MONITOR_OWNER;
3405   }





3406   return JVMTI_ERROR_NONE;
3407 } /* end RawMonitorNotifyAll */
3408 
3409 
3410   //
3411   // JNI Function Interception functions
3412   //
3413 
3414 
3415 // function_table - pre-checked for NULL
3416 jvmtiError
3417 JvmtiEnv::SetJNIFunctionTable(const jniNativeInterface* function_table) {
3418   // Copy jni function table at safepoint.
3419   VM_JNIFunctionTableCopier copier(function_table);
3420   VMThread::execute(&amp;copier);
3421 
3422   return JVMTI_ERROR_NONE;
3423 } /* end SetJNIFunctionTable */
3424 
3425 
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiCodeBlobEvents.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
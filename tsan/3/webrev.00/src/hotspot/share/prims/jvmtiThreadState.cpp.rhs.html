<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
 29 #include &quot;prims/jvmtiImpl.hpp&quot;
 30 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
 31 #include &quot;runtime/safepointVerifiers.hpp&quot;
 32 #include &quot;runtime/vframe.hpp&quot;
 33 
 34 // marker for when the stack depth has been reset and is now unknown.
 35 // any negative number would work but small ones might obscure an
 36 // underrun error.
 37 static const int UNKNOWN_STACK_DEPTH = -99;
 38 
 39 ///////////////////////////////////////////////////////////////
 40 //
 41 // class JvmtiThreadState
 42 //
 43 // Instances of JvmtiThreadState hang off of each thread.
 44 // Thread local storage for JVMTI.
 45 //
 46 
 47 JvmtiThreadState *JvmtiThreadState::_head = NULL;
 48 
 49 JvmtiThreadState::JvmtiThreadState(JavaThread* thread)
 50   : _thread_event_enable() {
 51   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
 52   _thread               = thread;
 53   _exception_state      = ES_CLEARED;
 54   _debuggable           = true;
 55   _hide_single_stepping = false;
 56   _hide_level           = 0;
 57   _pending_step_for_popframe = false;
 58   _class_being_redefined = NULL;
 59   _class_load_kind = jvmti_class_load_kind_load;
 60   _head_env_thread_state = NULL;
 61   _dynamic_code_event_collector = NULL;
 62   _vm_object_alloc_event_collector = NULL;
 63   _sampled_object_alloc_event_collector = NULL;
 64   _the_class_for_redefinition_verification = NULL;
 65   _scratch_class_for_redefinition_verification = NULL;
 66   _cur_stack_depth = UNKNOWN_STACK_DEPTH;
 67 
 68   // JVMTI ForceEarlyReturn support
 69   _pending_step_for_earlyret = false;
 70   _earlyret_state = earlyret_inactive;
 71   _earlyret_tos = ilgl;
 72   _earlyret_value.j = 0L;
 73   _earlyret_oop = NULL;
 74 
<a name="2" id="anc2"></a><span class="line-added"> 75   _jvmti_event_queue = NULL;</span>
<span class="line-added"> 76 </span>
 77   // add all the JvmtiEnvThreadState to the new JvmtiThreadState
 78   {
 79     JvmtiEnvIterator it;
 80     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
 81       if (env-&gt;is_valid()) {
 82         add_env(env);
 83       }
 84     }
 85   }
 86 
 87   // link us into the list
 88   {
 89     // The thread state list manipulation code must not have safepoints.
 90     // See periodic_clean_up().
 91     debug_only(NoSafepointVerifier nosafepoint;)
 92 
 93     _prev = NULL;
 94     _next = _head;
 95     if (_head != NULL) {
 96       _head-&gt;_prev = this;
 97     }
 98     _head = this;
 99   }
100 
101   // set this as the state for the thread
102   thread-&gt;set_jvmti_thread_state(this);
103 }
104 
105 
106 JvmtiThreadState::~JvmtiThreadState()   {
107   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
108 
109   // clear this as the state for the thread
110   get_thread()-&gt;set_jvmti_thread_state(NULL);
111 
112   // zap our env thread states
113   {
114     JvmtiEnvBase::entering_dying_thread_env_iteration();
115     JvmtiEnvThreadStateIterator it(this);
116     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ) {
117       JvmtiEnvThreadState* zap = ets;
118       ets = it.next(ets);
119       delete zap;
120     }
121     JvmtiEnvBase::leaving_dying_thread_env_iteration();
122   }
123 
124   // remove us from the list
125   {
126     // The thread state list manipulation code must not have safepoints.
127     // See periodic_clean_up().
128     debug_only(NoSafepointVerifier nosafepoint;)
129 
130     if (_prev == NULL) {
131       assert(_head == this, &quot;sanity check&quot;);
132       _head = _next;
133     } else {
134       assert(_head != this, &quot;sanity check&quot;);
135       _prev-&gt;_next = _next;
136     }
137     if (_next != NULL) {
138       _next-&gt;_prev = _prev;
139     }
140     _next = NULL;
141     _prev = NULL;
142   }
143 }
144 
145 
146 void
147 JvmtiThreadState::periodic_clean_up() {
148   assert(SafepointSynchronize::is_at_safepoint(), &quot;at safepoint&quot;);
149 
150   // This iteration is initialized with &quot;_head&quot; instead of &quot;JvmtiThreadState::first()&quot;
151   // because the latter requires the JvmtiThreadState_lock.
152   // This iteration is safe at a safepoint as well, see the NoSafepointVerifier
153   // asserts at all list manipulation sites.
154   for (JvmtiThreadState *state = _head; state != NULL; state = state-&gt;next()) {
155     // For each environment thread state corresponding to an invalid environment
156     // unlink it from the list and deallocate it.
157     JvmtiEnvThreadStateIterator it(state);
158     JvmtiEnvThreadState* previous_ets = NULL;
159     JvmtiEnvThreadState* ets = it.first();
160     while (ets != NULL) {
161       if (ets-&gt;get_env()-&gt;is_valid()) {
162         previous_ets = ets;
163         ets = it.next(ets);
164       } else {
165         // This one isn&#39;t valid, remove it from the list and deallocate it
166         JvmtiEnvThreadState* defunct_ets = ets;
167         ets = ets-&gt;next();
168         if (previous_ets == NULL) {
169           assert(state-&gt;head_env_thread_state() == defunct_ets, &quot;sanity check&quot;);
170           state-&gt;set_head_env_thread_state(ets);
171         } else {
172           previous_ets-&gt;set_next(ets);
173         }
174         delete defunct_ets;
175       }
176     }
177   }
178 }
179 
180 void JvmtiThreadState::add_env(JvmtiEnvBase *env) {
181   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
182 
183   JvmtiEnvThreadState *new_ets = new JvmtiEnvThreadState(_thread, env);
184   // add this environment thread state to the end of the list (order is important)
185   {
186     // list deallocation (which occurs at a safepoint) cannot occur simultaneously
187     debug_only(NoSafepointVerifier nosafepoint;)
188 
189     JvmtiEnvThreadStateIterator it(this);
190     JvmtiEnvThreadState* previous_ets = NULL;
191     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
192       previous_ets = ets;
193     }
194     if (previous_ets == NULL) {
195       set_head_env_thread_state(new_ets);
196     } else {
197       previous_ets-&gt;set_next(new_ets);
198     }
199   }
200 }
201 
202 
203 
204 
205 void JvmtiThreadState::enter_interp_only_mode() {
206   assert(_thread-&gt;get_interp_only_mode() == 0, &quot;entering interp only when mode not zero&quot;);
207   _thread-&gt;increment_interp_only_mode();
208 }
209 
210 
211 void JvmtiThreadState::leave_interp_only_mode() {
212   assert(_thread-&gt;get_interp_only_mode() == 1, &quot;leaving interp only when mode not one&quot;);
213   _thread-&gt;decrement_interp_only_mode();
214 }
215 
216 
217 // Helper routine used in several places
218 int JvmtiThreadState::count_frames() {
219   guarantee(SafepointSynchronize::is_at_safepoint() ||
220     (JavaThread *)Thread::current() == get_thread(),
221     &quot;must be current thread or at safepoint&quot;);
222 
223   if (!get_thread()-&gt;has_last_Java_frame()) return 0;  // no Java frames
224 
225   ResourceMark rm;
226   RegisterMap reg_map(get_thread());
227   javaVFrame *jvf = get_thread()-&gt;last_java_vframe(&amp;reg_map);
228   int n = 0;
229   while (jvf != NULL) {
230     Method* method = jvf-&gt;method();
231     jvf = jvf-&gt;java_sender();
232     n++;
233   }
234   return n;
235 }
236 
237 
238 void JvmtiThreadState::invalidate_cur_stack_depth() {
239   guarantee(SafepointSynchronize::is_at_safepoint() ||
240     (JavaThread *)Thread::current() == get_thread(),
241     &quot;must be current thread or at safepoint&quot;);
242 
243   _cur_stack_depth = UNKNOWN_STACK_DEPTH;
244 }
245 
246 void JvmtiThreadState::incr_cur_stack_depth() {
247   guarantee(JavaThread::current() == get_thread(), &quot;must be current thread&quot;);
248 
249   if (!is_interp_only_mode()) {
250     _cur_stack_depth = UNKNOWN_STACK_DEPTH;
251   }
252   if (_cur_stack_depth != UNKNOWN_STACK_DEPTH) {
253     ++_cur_stack_depth;
254   }
255 }
256 
257 void JvmtiThreadState::decr_cur_stack_depth() {
258   guarantee(JavaThread::current() == get_thread(), &quot;must be current thread&quot;);
259 
260   if (!is_interp_only_mode()) {
261     _cur_stack_depth = UNKNOWN_STACK_DEPTH;
262   }
263   if (_cur_stack_depth != UNKNOWN_STACK_DEPTH) {
264     --_cur_stack_depth;
265     assert(_cur_stack_depth &gt;= 0, &quot;incr/decr_cur_stack_depth mismatch&quot;);
266   }
267 }
268 
269 int JvmtiThreadState::cur_stack_depth() {
270   guarantee(SafepointSynchronize::is_at_safepoint() ||
271     (JavaThread *)Thread::current() == get_thread(),
272     &quot;must be current thread or at safepoint&quot;);
273 
274   if (!is_interp_only_mode() || _cur_stack_depth == UNKNOWN_STACK_DEPTH) {
275     _cur_stack_depth = count_frames();
276   } else {
277     // heavy weight assert
278     assert(_cur_stack_depth == count_frames(),
279            &quot;cur_stack_depth out of sync&quot;);
280   }
281   return _cur_stack_depth;
282 }
283 
284 bool JvmtiThreadState::may_be_walked() {
285   return (get_thread()-&gt;is_being_ext_suspended() || (JavaThread::current() == get_thread()));
286 }
287 
288 
289 void JvmtiThreadState::process_pending_step_for_popframe() {
290   // We are single stepping as the last part of the PopFrame() dance
291   // so we have some house keeping to do.
292 
293   JavaThread *thr = get_thread();
294   if (thr-&gt;popframe_condition() != JavaThread::popframe_inactive) {
295     // If the popframe_condition field is not popframe_inactive, then
296     // we missed all of the popframe_field cleanup points:
297     //
298     // - unpack_frames() was not called (nothing to deopt)
299     // - remove_activation_preserving_args_entry() was not called
300     //   (did not get suspended in a call_vm() family call and did
301     //   not complete a call_vm() family call on the way here)
302     thr-&gt;clear_popframe_condition();
303   }
304 
305   // clearing the flag indicates we are done with the PopFrame() dance
306   clr_pending_step_for_popframe();
307 
308   // If exception was thrown in this frame, need to reset jvmti thread state.
309   // Single stepping may not get enabled correctly by the agent since
310   // exception state is passed in MethodExit event which may be sent at some
311   // time in the future. JDWP agent ignores MethodExit events if caused by
312   // an exception.
313   //
314   if (is_exception_detected()) {
315     clear_exception_state();
316   }
317   // If step is pending for popframe then it may not be
318   // a repeat step. The new_bci and method_id is same as current_bci
319   // and current method_id after pop and step for recursive calls.
320   // Force the step by clearing the last location.
321   JvmtiEnvThreadStateIterator it(this);
322   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
323     ets-&gt;clear_current_location();
324   }
325 }
326 
327 
328 // Class:     JvmtiThreadState
329 // Function:  update_for_pop_top_frame
330 // Description:
331 //   This function removes any frame pop notification request for
332 //   the top frame and invalidates both the current stack depth and
333 //   all cached frameIDs.
334 //
335 // Called by: PopFrame
336 //
337 void JvmtiThreadState::update_for_pop_top_frame() {
338   if (is_interp_only_mode()) {
339     // remove any frame pop notification request for the top frame
340     // in any environment
341     int popframe_number = cur_stack_depth();
342     {
343       JvmtiEnvThreadStateIterator it(this);
344       for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
345         if (ets-&gt;is_frame_pop(popframe_number)) {
346           ets-&gt;clear_frame_pop(popframe_number);
347         }
348       }
349     }
350     // force stack depth to be recalculated
351     invalidate_cur_stack_depth();
352   } else {
353     assert(!is_enabled(JVMTI_EVENT_FRAME_POP), &quot;Must have no framepops set&quot;);
354   }
355 }
356 
357 
358 void JvmtiThreadState::process_pending_step_for_earlyret() {
359   // We are single stepping as the last part of the ForceEarlyReturn
360   // dance so we have some house keeping to do.
361 
362   if (is_earlyret_pending()) {
363     // If the earlyret_state field is not earlyret_inactive, then
364     // we missed all of the earlyret_field cleanup points:
365     //
366     // - remove_activation() was not called
367     //   (did not get suspended in a call_vm() family call and did
368     //   not complete a call_vm() family call on the way here)
369     //
370     // One legitimate way for us to miss all the cleanup points is
371     // if we got here right after handling a compiled return. If that
372     // is the case, then we consider our return from compiled code to
373     // complete the ForceEarlyReturn request and we clear the condition.
374     clr_earlyret_pending();
375     set_earlyret_oop(NULL);
376     clr_earlyret_value();
377   }
378 
379   // clearing the flag indicates we are done with
380   // the ForceEarlyReturn() dance
381   clr_pending_step_for_earlyret();
382 
383   // If exception was thrown in this frame, need to reset jvmti thread state.
384   // Single stepping may not get enabled correctly by the agent since
385   // exception state is passed in MethodExit event which may be sent at some
386   // time in the future. JDWP agent ignores MethodExit events if caused by
387   // an exception.
388   //
389   if (is_exception_detected()) {
390     clear_exception_state();
391   }
392   // If step is pending for earlyret then it may not be a repeat step.
393   // The new_bci and method_id is same as current_bci and current
394   // method_id after earlyret and step for recursive calls.
395   // Force the step by clearing the last location.
396   JvmtiEnvThreadStateIterator it(this);
397   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
398     ets-&gt;clear_current_location();
399   }
400 }
401 
<a name="3" id="anc3"></a><span class="line-modified">402 void JvmtiThreadState::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
403   f-&gt;do_oop((oop*) &amp;_earlyret_oop);
<a name="4" id="anc4"></a><span class="line-added">404 </span>
<span class="line-added">405   // Keep nmethods from unloading on the event queue</span>
<span class="line-added">406   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">407     _jvmti_event_queue-&gt;oops_do(f, cf);</span>
<span class="line-added">408   }</span>
<span class="line-added">409 }</span>
<span class="line-added">410 </span>
<span class="line-added">411 void JvmtiThreadState::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added">412   // Keep nmethods from unloading on the event queue</span>
<span class="line-added">413   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">414     _jvmti_event_queue-&gt;nmethods_do(cf);</span>
<span class="line-added">415   }</span>
<span class="line-added">416 }</span>
<span class="line-added">417 </span>
<span class="line-added">418 // Thread local event queue.</span>
<span class="line-added">419 void JvmtiThreadState::enqueue_event(JvmtiDeferredEvent* event) {</span>
<span class="line-added">420   if (_jvmti_event_queue == NULL) {</span>
<span class="line-added">421     _jvmti_event_queue = new JvmtiDeferredEventQueue();</span>
<span class="line-added">422   }</span>
<span class="line-added">423   // copy the event</span>
<span class="line-added">424   _jvmti_event_queue-&gt;enqueue(*event);</span>
<span class="line-added">425 }</span>
<span class="line-added">426 </span>
<span class="line-added">427 void JvmtiThreadState::post_events(JvmtiEnv* env) {</span>
<span class="line-added">428   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">429     _jvmti_event_queue-&gt;post(env);  // deletes each queue node</span>
<span class="line-added">430     delete _jvmti_event_queue;</span>
<span class="line-added">431     _jvmti_event_queue = NULL;</span>
<span class="line-added">432   }</span>
<span class="line-added">433 }</span>
<span class="line-added">434 </span>
<span class="line-added">435 void JvmtiThreadState::run_nmethod_entry_barriers() {</span>
<span class="line-added">436   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">437     _jvmti_event_queue-&gt;run_nmethod_entry_barriers();</span>
<span class="line-added">438   }</span>
439 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
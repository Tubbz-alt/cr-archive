<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/resolvedMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeLookup.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="resolvedMethodTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/resolvedMethodTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;


 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;

 30 #include &quot;oops/access.inline.hpp&quot;
<span class="line-removed"> 31 #include &quot;oops/oop.inline.hpp&quot;</span>
 32 #include &quot;oops/method.hpp&quot;
<span class="line-modified"> 33 #include &quot;oops/symbol.hpp&quot;</span>
 34 #include &quot;oops/weakHandle.inline.hpp&quot;
 35 #include &quot;prims/resolvedMethodTable.hpp&quot;

 36 #include &quot;runtime/handles.inline.hpp&quot;

 37 #include &quot;runtime/mutexLocker.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-modified"> 39 #include &quot;utilities/hashtable.inline.hpp&quot;</span>


 40 #include &quot;utilities/macros.hpp&quot;
 41 




 42 
<span class="line-modified"> 43 oop ResolvedMethodEntry::object() {</span>
<span class="line-removed"> 44   return literal().resolve();</span>
<span class="line-removed"> 45 }</span>
 46 
<span class="line-modified"> 47 oop ResolvedMethodEntry::object_no_keepalive() {</span>
<span class="line-modified"> 48   // The AS_NO_KEEPALIVE peeks at the oop without keeping it alive.</span>
<span class="line-modified"> 49   // This is dangerous in general but is okay if the loaded oop does</span>
<span class="line-modified"> 50   // not leak out past a thread transition where a safepoint can happen.</span>
<span class="line-removed"> 51   // A subsequent oop_load without AS_NO_KEEPALIVE (the object() accessor)</span>
<span class="line-removed"> 52   // keeps the oop alive before doing so.</span>
<span class="line-removed"> 53   return literal().peek();</span>
 54 }
 55 
<span class="line-modified"> 56 ResolvedMethodTable::ResolvedMethodTable()</span>
<span class="line-modified"> 57   : Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;(_table_size, sizeof(ResolvedMethodEntry)) { }</span>
 58 
<span class="line-modified"> 59 oop ResolvedMethodTable::lookup(int index, unsigned int hash, Method* method) {</span>
<span class="line-modified"> 60   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>
<span class="line-modified"> 61   for (ResolvedMethodEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {</span>
<span class="line-modified"> 62     if (p-&gt;hash() == hash) {</span>
 63 
<span class="line-modified"> 64       // Peek the object to check if it is the right target.</span>
<span class="line-modified"> 65       oop target = p-&gt;object_no_keepalive();</span>
<span class="line-modified"> 66 </span>
<span class="line-modified"> 67       // The method is in the table as a target already</span>
<span class="line-modified"> 68       if (target != NULL &amp;&amp; java_lang_invoke_ResolvedMethodName::vmtarget(target) == method) {</span>
<span class="line-removed"> 69         ResourceMark rm;</span>
<span class="line-removed"> 70         log_debug(membername, table) (&quot;ResolvedMethod entry found for %s index %d&quot;,</span>
<span class="line-removed"> 71                                        method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="line-removed"> 72         // The object() accessor makes sure the target object is kept alive before</span>
<span class="line-removed"> 73         // leaking out.</span>
<span class="line-removed"> 74         return p-&gt;object();</span>
<span class="line-removed"> 75       }</span>
 76     }



 77   }
<span class="line-removed"> 78   return NULL;</span>
<span class="line-removed"> 79 }</span>
 80 
<span class="line-modified"> 81 unsigned int ResolvedMethodTable::compute_hash(Method* method) {</span>
<span class="line-modified"> 82   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="line-modified"> 83   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="line-modified"> 84   return name_hash ^ signature_hash;</span>
<span class="line-modified"> 85 }</span>









 86 

 87 
<span class="line-modified"> 88 oop ResolvedMethodTable::lookup(Method* method) {</span>
<span class="line-modified"> 89   unsigned int hash = compute_hash(method);</span>
<span class="line-modified"> 90   int index = hash_to_index(hash);</span>
<span class="line-modified"> 91   return lookup(index, hash, method);</span>



 92 }
 93 
<span class="line-modified"> 94 oop ResolvedMethodTable::basic_add(Method* method, Handle rmethod_name) {</span>
<span class="line-modified"> 95   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>

 96 
<span class="line-modified"> 97   unsigned int hash = compute_hash(method);</span>
<span class="line-modified"> 98   int index = hash_to_index(hash);</span>




 99 
<span class="line-modified">100   // One was added while aquiring the lock</span>
<span class="line-modified">101   oop entry = lookup(index, hash, method);</span>
<span class="line-modified">102   if (entry != NULL) {</span>
<span class="line-modified">103     return entry;</span>


104   }
















105 
<span class="line-removed">106   ClassLoaderWeakHandle w = ClassLoaderWeakHandle::create(rmethod_name);</span>
<span class="line-removed">107   ResolvedMethodEntry* p = (ResolvedMethodEntry*) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::new_entry(hash, w);</span>
<span class="line-removed">108   Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::add_entry(index, p);</span>
<span class="line-removed">109   ResourceMark rm;</span>
<span class="line-removed">110   log_debug(membername, table) (&quot;ResolvedMethod entry added for %s index %d&quot;,</span>
<span class="line-removed">111                                  method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="line-removed">112   return rmethod_name();</span>
<span class="line-removed">113 }</span>
114 
<span class="line-modified">115 ResolvedMethodTable* ResolvedMethodTable::_the_table = NULL;</span>

































116 
<span class="line-modified">117 oop ResolvedMethodTable::find_method(Method* method) {</span>
<span class="line-modified">118   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">119   oop entry = _the_table-&gt;lookup(method);</span>
<span class="line-modified">120   return entry;</span>



121 }
122 
<span class="line-modified">123 oop ResolvedMethodTable::add_method(const methodHandle&amp; m, Handle resolved_method_name) {</span>
<span class="line-modified">124   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">125   DEBUG_ONLY(NoSafepointVerifier nsv);</span>


126 
<span class="line-modified">127   Method* method = m();</span>
<span class="line-modified">128   // Check if method has been redefined while taking out ResolvedMethodTable_lock, if so</span>
<span class="line-modified">129   // use new method.  The old method won&#39;t be deallocated because it&#39;s passed in as a Handle.</span>
<span class="line-modified">130   if (method-&gt;is_old()) {</span>
<span class="line-modified">131     // Replace method with redefined version</span>
<span class="line-modified">132     InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-modified">133     method = holder-&gt;method_with_idnum(method-&gt;method_idnum());</span>
<span class="line-modified">134     if (method == NULL) {</span>
<span class="line-modified">135       // Replace deleted method with NSME.</span>
<span class="line-removed">136       method = Universe::throw_no_such_method_error();</span>
137     }
<span class="line-removed">138     java_lang_invoke_ResolvedMethodName::set_vmtarget(resolved_method_name(), method);</span>
139   }
<span class="line-modified">140   // Set flag in class to indicate this InstanceKlass has entries in the table</span>
<span class="line-modified">141   // to avoid walking table during redefinition if none of the redefined classes</span>
<span class="line-modified">142   // have any membernames in the table.</span>
<span class="line-modified">143   method-&gt;method_holder()-&gt;set_has_resolved_methods();</span>

144 
<span class="line-modified">145   return _the_table-&gt;basic_add(method, resolved_method_name);</span>


146 }
147 
<span class="line-modified">148 // Removing entries</span>
<span class="line-modified">149 int ResolvedMethodTable::_total_oops_removed = 0;</span>

150 
<span class="line-modified">151 // There are no dead entries at start</span>
<span class="line-modified">152 bool ResolvedMethodTable::_dead_entries = false;</span>

153 
<span class="line-modified">154 void ResolvedMethodTable::trigger_cleanup() {</span>
<span class="line-modified">155   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">156   _dead_entries = true;</span>























157   Service_lock-&gt;notify_all();
158 }
159 
<span class="line-modified">160 // Serially invoke removed unused oops from the table.</span>
<span class="line-modified">161 // This is done by the ServiceThread after being notified on class unloading</span>
<span class="line-modified">162 void ResolvedMethodTable::unlink() {</span>
<span class="line-modified">163   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">164   int _oops_removed = 0;</span>
<span class="line-modified">165   int _oops_counted = 0;</span>
<span class="line-modified">166   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="line-modified">167     ResolvedMethodEntry** p = _the_table-&gt;bucket_addr(i);</span>
<span class="line-modified">168     ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="line-modified">169     while (entry != NULL) {</span>
<span class="line-modified">170       _oops_counted++;</span>
<span class="line-modified">171       oop l = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">172       if (l != NULL) {</span>
<span class="line-modified">173         p = entry-&gt;next_addr();</span>
<span class="line-modified">174       } else {</span>
<span class="line-modified">175         // Entry has been removed.</span>
<span class="line-modified">176         _oops_removed++;</span>
<span class="line-modified">177         if (log_is_enabled(Debug, membername, table)) {</span>
<span class="line-modified">178           log_debug(membername, table) (&quot;ResolvedMethod entry removed for index %d&quot;, i);</span>
<span class="line-modified">179         }</span>
<span class="line-modified">180         entry-&gt;literal().release();</span>
<span class="line-modified">181         *p = entry-&gt;next();</span>
<span class="line-modified">182         _the_table-&gt;free_entry(entry);</span>

183       }
<span class="line-modified">184       // get next entry</span>
<span class="line-modified">185       entry = (ResolvedMethodEntry*)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::make_ptr(*p);</span>
























186     }
187   }
<span class="line-modified">188   log_debug(membername, table) (&quot;ResolvedMethod entries counted %d removed %d&quot;,</span>
<span class="line-modified">189                                 _oops_counted, _oops_removed);</span>
<span class="line-modified">190   _total_oops_removed += _oops_removed;</span>
<span class="line-modified">191   _dead_entries = false;</span>
<span class="line-modified">192 }</span>
<span class="line-modified">193 </span>
<span class="line-modified">194 #ifndef PRODUCT</span>
<span class="line-modified">195 void ResolvedMethodTable::print() {</span>
<span class="line-modified">196   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">197   for (int i = 0; i &lt; table_size(); ++i) {</span>
<span class="line-modified">198     ResolvedMethodEntry* entry = bucket(i);</span>
<span class="line-modified">199     while (entry != NULL) {</span>
<span class="line-modified">200       tty-&gt;print(&quot;%d : &quot;, i);</span>
<span class="line-modified">201       oop rmethod_name = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">202       if (rmethod_name != NULL) {</span>
<span class="line-removed">203         rmethod_name-&gt;print();</span>
<span class="line-removed">204         Method* m = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(rmethod_name);</span>
<span class="line-removed">205         m-&gt;print();</span>
206       }
<span class="line-modified">207       entry = entry-&gt;next();</span>
208     }

209   }

















210 }
<span class="line-removed">211 #endif // PRODUCT</span>
212 
213 #if INCLUDE_JVMTI


































214 // It is called at safepoint only for RedefineClasses
215 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
216   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
217   // For each entry in RMT, change to new method
<span class="line-modified">218   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="line-modified">219     for (ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="line-modified">220          entry != NULL;</span>
<span class="line-modified">221          entry = entry-&gt;next()) {</span>
<span class="line-modified">222 </span>
<span class="line-modified">223       oop mem_name = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">224       // except ones removed</span>
<span class="line-modified">225       if (mem_name == NULL) {</span>
<span class="line-modified">226         continue;</span>
<span class="line-modified">227       }</span>
<span class="line-modified">228       Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="line-modified">229 </span>
<span class="line-modified">230       if (old_method-&gt;is_old()) {</span>
<span class="line-modified">231 </span>
<span class="line-removed">232         Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="line-removed">233                               Universe::throw_no_such_method_error() :</span>
<span class="line-removed">234                               old_method-&gt;get_new_method();</span>
<span class="line-removed">235         java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="line-removed">236 </span>
<span class="line-removed">237         ResourceMark rm;</span>
<span class="line-removed">238         if (!(*trace_name_printed)) {</span>
<span class="line-removed">239           log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-removed">240            *trace_name_printed = true;</span>
<span class="line-removed">241         }</span>
<span class="line-removed">242         log_debug(redefine, class, update, constantpool)</span>
<span class="line-removed">243           (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="line-removed">244            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="line-removed">245       }</span>
246     }












247   }
248 }
<span class="line-removed">249 #endif // INCLUDE_JVMTI</span>
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
<span class="line-added"> 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="line-added"> 28 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/access.inline.hpp&quot;

 34 #include &quot;oops/method.hpp&quot;
<span class="line-modified"> 35 #include &quot;oops/oop.inline.hpp&quot;</span>
 36 #include &quot;oops/weakHandle.inline.hpp&quot;
 37 #include &quot;prims/resolvedMethodTable.hpp&quot;
<span class="line-added"> 38 #include &quot;runtime/atomic.hpp&quot;</span>
 39 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added"> 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-modified"> 43 #include &quot;runtime/timerTrace.hpp&quot;</span>
<span class="line-added"> 44 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;</span>
<span class="line-added"> 45 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;</span>
 46 #include &quot;utilities/macros.hpp&quot;
 47 
<span class="line-added"> 48 // 2^24 is max size</span>
<span class="line-added"> 49 static const size_t END_SIZE = 24;</span>
<span class="line-added"> 50 // If a chain gets to 32 something might be wrong</span>
<span class="line-added"> 51 static const size_t GROW_HINT = 32;</span>
 52 
<span class="line-modified"> 53 static const size_t ResolvedMethodTableSizeLog = 10;</span>


 54 
<span class="line-modified"> 55 unsigned int method_hash(const Method* method) {</span>
<span class="line-modified"> 56   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="line-modified"> 57   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="line-modified"> 58   return name_hash ^ signature_hash;</span>



 59 }
 60 
<span class="line-modified"> 61 typedef ConcurrentHashTable&lt;ResolvedMethodTableConfig,</span>
<span class="line-modified"> 62                             mtClass&gt; ResolvedMethodTableHash;</span>
 63 
<span class="line-modified"> 64 class ResolvedMethodTableConfig : public AllStatic {</span>
<span class="line-modified"> 65  private:</span>
<span class="line-modified"> 66  public:</span>
<span class="line-modified"> 67   typedef WeakHandle&lt;vm_resolved_method_table_data&gt; Value;</span>
 68 
<span class="line-modified"> 69   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
<span class="line-modified"> 70     oop val_oop = value.peek();</span>
<span class="line-modified"> 71     if (val_oop == NULL) {</span>
<span class="line-modified"> 72       *is_dead = true;</span>
<span class="line-modified"> 73       return 0;</span>







 74     }
<span class="line-added"> 75     *is_dead = false;</span>
<span class="line-added"> 76     Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="line-added"> 77     return method_hash(method);</span>
 78   }


 79 
<span class="line-modified"> 80   // We use default allocation/deallocation but counted</span>
<span class="line-modified"> 81   static void* allocate_node(size_t size, Value const&amp; value) {</span>
<span class="line-modified"> 82     ResolvedMethodTable::item_added();</span>
<span class="line-modified"> 83     return AllocateHeap(size, mtClass);</span>
<span class="line-modified"> 84   }</span>
<span class="line-added"> 85   static void free_node(void* memory, Value const&amp; value) {</span>
<span class="line-added"> 86     value.release();</span>
<span class="line-added"> 87     FreeHeap(memory);</span>
<span class="line-added"> 88     ResolvedMethodTable::item_removed();</span>
<span class="line-added"> 89   }</span>
<span class="line-added"> 90 };</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92 static ResolvedMethodTableHash* _local_table           = NULL;</span>
<span class="line-added"> 93 static size_t                   _current_size          = (size_t)1 &lt;&lt; ResolvedMethodTableSizeLog;</span>
 94 
<span class="line-added"> 95 volatile bool            ResolvedMethodTable::_has_work              = false;</span>
 96 
<span class="line-modified"> 97 volatile size_t          _items_count           = 0;</span>
<span class="line-modified"> 98 volatile size_t          _uncleaned_items_count = 0;</span>
<span class="line-modified"> 99 </span>
<span class="line-modified">100 void ResolvedMethodTable::create_table() {</span>
<span class="line-added">101   _local_table  = new ResolvedMethodTableHash(ResolvedMethodTableSizeLog, END_SIZE, GROW_HINT);</span>
<span class="line-added">102   log_trace(membername, table)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-added">103                                _current_size, ResolvedMethodTableSizeLog);</span>
104 }
105 
<span class="line-modified">106 size_t ResolvedMethodTable::table_size() {</span>
<span class="line-modified">107   return (size_t)1 &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="line-added">108 }</span>
109 
<span class="line-modified">110 class ResolvedMethodTableLookup : StackObj {</span>
<span class="line-modified">111  private:</span>
<span class="line-added">112   Thread*       _thread;</span>
<span class="line-added">113   uintx         _hash;</span>
<span class="line-added">114   const Method* _method;</span>
<span class="line-added">115   Handle        _found;</span>
116 
<span class="line-modified">117  public:</span>
<span class="line-modified">118   ResolvedMethodTableLookup(Thread* thread, uintx hash, const Method* key)</span>
<span class="line-modified">119     : _thread(thread), _hash(hash), _method(key) {</span>
<span class="line-modified">120   }</span>
<span class="line-added">121   uintx get_hash() const {</span>
<span class="line-added">122     return _hash;</span>
123   }
<span class="line-added">124   bool equals(WeakHandle&lt;vm_resolved_method_table_data&gt;* value, bool* is_dead) {</span>
<span class="line-added">125     oop val_oop = value-&gt;peek();</span>
<span class="line-added">126     if (val_oop == NULL) {</span>
<span class="line-added">127       // dead oop, mark this hash dead for cleaning</span>
<span class="line-added">128       *is_dead = true;</span>
<span class="line-added">129       return false;</span>
<span class="line-added">130     }</span>
<span class="line-added">131     bool equals = _method == java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="line-added">132     if (!equals) {</span>
<span class="line-added">133       return false;</span>
<span class="line-added">134     }</span>
<span class="line-added">135     // Need to resolve weak handle and Handleize through possible safepoint.</span>
<span class="line-added">136     _found = Handle(_thread, value-&gt;resolve());</span>
<span class="line-added">137     return true;</span>
<span class="line-added">138   }</span>
<span class="line-added">139 };</span>
140 








141 
<span class="line-modified">142 class ResolvedMethodGet : public StackObj {</span>
<span class="line-added">143   Thread*       _thread;</span>
<span class="line-added">144   const Method* _method;</span>
<span class="line-added">145   Handle        _return;</span>
<span class="line-added">146 public:</span>
<span class="line-added">147   ResolvedMethodGet(Thread* thread, const Method* method) : _thread(thread), _method(method) {}</span>
<span class="line-added">148   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">149     oop result = val-&gt;resolve();</span>
<span class="line-added">150     assert(result != NULL, &quot;Result should be reachable&quot;);</span>
<span class="line-added">151     _return = Handle(_thread, result);</span>
<span class="line-added">152     log_get();</span>
<span class="line-added">153   }</span>
<span class="line-added">154   oop get_res_oop() {</span>
<span class="line-added">155     return _return();</span>
<span class="line-added">156   }</span>
<span class="line-added">157   void log_get() {</span>
<span class="line-added">158     LogTarget(Trace, membername, table) log;</span>
<span class="line-added">159     if (log.is_enabled()) {</span>
<span class="line-added">160       ResourceMark rm;</span>
<span class="line-added">161       log.print(&quot;ResolvedMethod entry found for %s&quot;,</span>
<span class="line-added">162                 _method-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">163     }</span>
<span class="line-added">164   }</span>
<span class="line-added">165 };</span>
<span class="line-added">166 </span>
<span class="line-added">167 oop ResolvedMethodTable::find_method(const Method* method) {</span>
<span class="line-added">168   Thread* thread = Thread::current();</span>
<span class="line-added">169 </span>
<span class="line-added">170   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="line-added">171   ResolvedMethodGet rmg(thread, method);</span>
<span class="line-added">172   _local_table-&gt;get(thread, lookup, rmg);</span>
<span class="line-added">173 </span>
<span class="line-added">174   return rmg.get_res_oop();</span>
<span class="line-added">175 }</span>
176 
<span class="line-modified">177 static void log_insert(const Method* method) {</span>
<span class="line-modified">178   LogTarget(Debug, membername, table) log;</span>
<span class="line-modified">179   if (log.is_enabled()) {</span>
<span class="line-modified">180     ResourceMark rm;</span>
<span class="line-added">181     log.print(&quot;ResolvedMethod entry added for %s&quot;,</span>
<span class="line-added">182               method-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">183   }</span>
184 }
185 
<span class="line-modified">186 oop ResolvedMethodTable::add_method(const Method* method, Handle rmethod_name) {</span>
<span class="line-modified">187   Thread* thread = Thread::current();</span>
<span class="line-modified">188 </span>
<span class="line-added">189   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="line-added">190   ResolvedMethodGet rmg(thread, method);</span>
191 
<span class="line-modified">192   while (true) {</span>
<span class="line-modified">193     if (_local_table-&gt;get(thread, lookup, rmg)) {</span>
<span class="line-modified">194       return rmg.get_res_oop();</span>
<span class="line-modified">195     }</span>
<span class="line-modified">196     WeakHandle&lt;vm_resolved_method_table_data&gt; wh = WeakHandle&lt;vm_resolved_method_table_data&gt;::create(rmethod_name);</span>
<span class="line-modified">197     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.</span>
<span class="line-modified">198     if (_local_table-&gt;insert(thread, lookup, wh)) {</span>
<span class="line-modified">199       log_insert(method);</span>
<span class="line-modified">200       return wh.resolve();</span>

201     }

202   }
<span class="line-modified">203 }</span>
<span class="line-modified">204 </span>
<span class="line-modified">205 void ResolvedMethodTable::item_added() {</span>
<span class="line-modified">206   Atomic::inc(&amp;_items_count);</span>
<span class="line-added">207 }</span>
208 
<span class="line-modified">209 void ResolvedMethodTable::item_removed() {</span>
<span class="line-added">210   Atomic::dec(&amp;_items_count);</span>
<span class="line-added">211   log_trace(membername, table) (&quot;ResolvedMethod entry removed&quot;);</span>
212 }
213 
<span class="line-modified">214 double ResolvedMethodTable::get_load_factor() {</span>
<span class="line-modified">215   return (double)_items_count/_current_size;</span>
<span class="line-added">216 }</span>
217 
<span class="line-modified">218 double ResolvedMethodTable::get_dead_factor() {</span>
<span class="line-modified">219   return (double)_uncleaned_items_count/_current_size;</span>
<span class="line-added">220 }</span>
221 
<span class="line-modified">222 static const double PREF_AVG_LIST_LEN = 2.0;</span>
<span class="line-modified">223 // If we have as many dead items as 50% of the number of bucket</span>
<span class="line-modified">224 static const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;</span>
<span class="line-added">225 </span>
<span class="line-added">226 void ResolvedMethodTable::check_concurrent_work() {</span>
<span class="line-added">227   if (_has_work) {</span>
<span class="line-added">228     return;</span>
<span class="line-added">229   }</span>
<span class="line-added">230 </span>
<span class="line-added">231   double load_factor = get_load_factor();</span>
<span class="line-added">232   double dead_factor = get_dead_factor();</span>
<span class="line-added">233   // We should clean/resize if we have more dead than alive,</span>
<span class="line-added">234   // more items than preferred load factor or</span>
<span class="line-added">235   // more dead items than water mark.</span>
<span class="line-added">236   if ((dead_factor &gt; load_factor) ||</span>
<span class="line-added">237       (load_factor &gt; PREF_AVG_LIST_LEN) ||</span>
<span class="line-added">238       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {</span>
<span class="line-added">239     log_debug(membername, table)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,</span>
<span class="line-added">240                                  load_factor, dead_factor);</span>
<span class="line-added">241     trigger_concurrent_work();</span>
<span class="line-added">242   }</span>
<span class="line-added">243 }</span>
<span class="line-added">244 </span>
<span class="line-added">245 void ResolvedMethodTable::trigger_concurrent_work() {</span>
<span class="line-added">246   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">247   _has_work = true;</span>
248   Service_lock-&gt;notify_all();
249 }
250 
<span class="line-modified">251 void ResolvedMethodTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-modified">252   _has_work = false;</span>
<span class="line-modified">253   double load_factor = get_load_factor();</span>
<span class="line-modified">254   log_debug(membername, table)(&quot;Concurrent work, live factor: %g&quot;, load_factor);</span>
<span class="line-modified">255   // We prefer growing, since that also removes dead items</span>
<span class="line-modified">256   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {</span>
<span class="line-modified">257     grow(jt);</span>
<span class="line-modified">258   } else {</span>
<span class="line-modified">259     clean_dead_entries(jt);</span>
<span class="line-modified">260   }</span>
<span class="line-modified">261 }</span>
<span class="line-modified">262 </span>
<span class="line-modified">263 void ResolvedMethodTable::grow(JavaThread* jt) {</span>
<span class="line-modified">264   ResolvedMethodTableHash::GrowTask gt(_local_table);</span>
<span class="line-modified">265   if (!gt.prepare(jt)) {</span>
<span class="line-modified">266     return;</span>
<span class="line-modified">267   }</span>
<span class="line-modified">268   log_trace(membername, table)(&quot;Started to grow&quot;);</span>
<span class="line-modified">269   {</span>
<span class="line-modified">270     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="line-modified">271     while (gt.do_task(jt)) {</span>
<span class="line-modified">272       gt.pause(jt);</span>
<span class="line-modified">273       {</span>
<span class="line-added">274         ThreadBlockInVM tbivm(jt);</span>
275       }
<span class="line-modified">276       gt.cont(jt);</span>
<span class="line-modified">277     }</span>
<span class="line-added">278   }</span>
<span class="line-added">279   gt.done(jt);</span>
<span class="line-added">280   _current_size = table_size();</span>
<span class="line-added">281   log_info(membername, table)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);</span>
<span class="line-added">282 }</span>
<span class="line-added">283 </span>
<span class="line-added">284 struct ResolvedMethodTableDoDelete : StackObj {</span>
<span class="line-added">285   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">286     /* do nothing */</span>
<span class="line-added">287   }</span>
<span class="line-added">288 };</span>
<span class="line-added">289 </span>
<span class="line-added">290 struct ResolvedMethodTableDeleteCheck : StackObj {</span>
<span class="line-added">291   long _count;</span>
<span class="line-added">292   long _item;</span>
<span class="line-added">293   ResolvedMethodTableDeleteCheck() : _count(0), _item(0) {}</span>
<span class="line-added">294   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">295     ++_item;</span>
<span class="line-added">296     oop tmp = val-&gt;peek();</span>
<span class="line-added">297     if (tmp == NULL) {</span>
<span class="line-added">298       ++_count;</span>
<span class="line-added">299       return true;</span>
<span class="line-added">300     } else {</span>
<span class="line-added">301       return false;</span>
302     }
303   }
<span class="line-modified">304 };</span>
<span class="line-modified">305 </span>
<span class="line-modified">306 void ResolvedMethodTable::clean_dead_entries(JavaThread* jt) {</span>
<span class="line-modified">307   ResolvedMethodTableHash::BulkDeleteTask bdt(_local_table);</span>
<span class="line-modified">308   if (!bdt.prepare(jt)) {</span>
<span class="line-modified">309     return;</span>
<span class="line-modified">310   }</span>
<span class="line-modified">311   ResolvedMethodTableDeleteCheck stdc;</span>
<span class="line-modified">312   ResolvedMethodTableDoDelete stdd;</span>
<span class="line-modified">313   {</span>
<span class="line-modified">314     TraceTime timer(&quot;Clean&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="line-modified">315     while(bdt.do_task(jt, stdc, stdd)) {</span>
<span class="line-modified">316       bdt.pause(jt);</span>
<span class="line-modified">317       {</span>
<span class="line-modified">318         ThreadBlockInVM tbivm(jt);</span>



319       }
<span class="line-modified">320       bdt.cont(jt);</span>
321     }
<span class="line-added">322     bdt.done(jt);</span>
323   }
<span class="line-added">324   log_info(membername, table)(&quot;Cleaned %ld of %ld&quot;, stdc._count, stdc._item);</span>
<span class="line-added">325 }</span>
<span class="line-added">326 void ResolvedMethodTable::reset_dead_counter() {</span>
<span class="line-added">327   _uncleaned_items_count = 0;</span>
<span class="line-added">328 }</span>
<span class="line-added">329 </span>
<span class="line-added">330 void ResolvedMethodTable::inc_dead_counter(size_t ndead) {</span>
<span class="line-added">331   size_t total = Atomic::add(&amp;_uncleaned_items_count, ndead);</span>
<span class="line-added">332   log_trace(membername, table)(</span>
<span class="line-added">333      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,</span>
<span class="line-added">334      _uncleaned_items_count, ndead, total);</span>
<span class="line-added">335 }</span>
<span class="line-added">336 </span>
<span class="line-added">337 // After the parallel walk this method must be called to trigger</span>
<span class="line-added">338 // cleaning. Note it might trigger a resize instead.</span>
<span class="line-added">339 void ResolvedMethodTable::finish_dead_counter() {</span>
<span class="line-added">340   check_concurrent_work();</span>
341 }

342 
343 #if INCLUDE_JVMTI
<span class="line-added">344 class AdjustMethodEntries : public StackObj {</span>
<span class="line-added">345   bool* _trace_name_printed;</span>
<span class="line-added">346 public:</span>
<span class="line-added">347   AdjustMethodEntries(bool* trace_name_printed) : _trace_name_printed(trace_name_printed) {};</span>
<span class="line-added">348   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* entry) {</span>
<span class="line-added">349     oop mem_name = entry-&gt;peek();</span>
<span class="line-added">350     if (mem_name == NULL) {</span>
<span class="line-added">351       // Removed</span>
<span class="line-added">352       return true;</span>
<span class="line-added">353     }</span>
<span class="line-added">354 </span>
<span class="line-added">355     Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="line-added">356 </span>
<span class="line-added">357     if (old_method-&gt;is_old()) {</span>
<span class="line-added">358 </span>
<span class="line-added">359       Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="line-added">360                             Universe::throw_no_such_method_error() :</span>
<span class="line-added">361                             old_method-&gt;get_new_method();</span>
<span class="line-added">362       java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="line-added">363 </span>
<span class="line-added">364       ResourceMark rm;</span>
<span class="line-added">365       if (!(*_trace_name_printed)) {</span>
<span class="line-added">366         log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-added">367          *_trace_name_printed = true;</span>
<span class="line-added">368       }</span>
<span class="line-added">369       log_debug(redefine, class, update, constantpool)</span>
<span class="line-added">370         (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="line-added">371          new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="line-added">372     }</span>
<span class="line-added">373 </span>
<span class="line-added">374     return true;</span>
<span class="line-added">375   }</span>
<span class="line-added">376 };</span>
<span class="line-added">377 </span>
378 // It is called at safepoint only for RedefineClasses
379 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
380   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
381   // For each entry in RMT, change to new method
<span class="line-modified">382   AdjustMethodEntries adjust(trace_name_printed);</span>
<span class="line-modified">383   _local_table-&gt;do_safepoint_scan(adjust);</span>
<span class="line-modified">384 }</span>
<span class="line-modified">385 #endif // INCLUDE_JVMTI</span>
<span class="line-modified">386 </span>
<span class="line-modified">387 // Verification</span>
<span class="line-modified">388 class VerifyResolvedMethod : StackObj {</span>
<span class="line-modified">389  public:</span>
<span class="line-modified">390   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-modified">391     oop obj = val-&gt;peek();</span>
<span class="line-modified">392     if (obj != NULL) {</span>
<span class="line-modified">393       Method* method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(obj);</span>
<span class="line-modified">394       guarantee(method-&gt;is_method(), &quot;Must be&quot;);</span>
<span class="line-modified">395       guarantee(!method-&gt;is_old(), &quot;Must be&quot;);</span>














396     }
<span class="line-added">397     return true;</span>
<span class="line-added">398   };</span>
<span class="line-added">399 };</span>
<span class="line-added">400 </span>
<span class="line-added">401 size_t ResolvedMethodTable::items_count() {</span>
<span class="line-added">402   return _items_count;</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
<span class="line-added">405 void ResolvedMethodTable::verify() {</span>
<span class="line-added">406   VerifyResolvedMethod vcs;</span>
<span class="line-added">407   if (!_local_table-&gt;try_scan(Thread::current(), vcs)) {</span>
<span class="line-added">408     log_info(membername, table)(&quot;verify unavailable at this moment&quot;);</span>
409   }
410 }

</pre>
</td>
</tr>
</table>
<center><a href="nativeLookup.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="resolvedMethodTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
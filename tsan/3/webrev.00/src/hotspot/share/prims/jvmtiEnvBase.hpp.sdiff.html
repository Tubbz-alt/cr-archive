<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnvBase.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEventController.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnvBase.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIENVBASE_HPP
 26 #define SHARE_PRIMS_JVMTIENVBASE_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;prims/jvmtiThreadState.hpp&quot;
 32 #include &quot;oops/oopHandle.hpp&quot;

 33 #include &quot;runtime/fieldDescriptor.hpp&quot;
 34 #include &quot;runtime/frame.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 
 40 //
 41 // Forward Declarations
 42 //
 43 
 44 class JvmtiEnv;
 45 class JvmtiThreadState;
 46 class JvmtiRawMonitor; // for jvmtiEnv.hpp
 47 class JvmtiEventControllerPrivate;
 48 class JvmtiTagMap;
 49 
 50 
 51 
 52 // One JvmtiEnv object is created per jvmti attachment;
</pre>
<hr />
<pre>
 81   static void entering_dying_thread_env_iteration() { ++_dying_thread_env_iteration_count; }
 82   static void leaving_dying_thread_env_iteration()  { --_dying_thread_env_iteration_count; }
 83   static bool is_inside_dying_thread_env_iteration(){ return _dying_thread_env_iteration_count &gt; 0; }
 84 
 85  private:
 86 
 87   enum {
 88       JVMTI_MAGIC    = 0x71EE,
 89       DISPOSED_MAGIC = 0xDEFC,
 90       BAD_MAGIC      = 0xDEAD
 91   };
 92 
 93   jvmtiEnv _jvmti_external;
 94   jint _magic;
 95   jint _version;  // version value passed to JNI GetEnv()
 96   JvmtiEnvBase* _next;
 97   bool _is_retransformable;
 98   const void *_env_local_storage;     // per env agent allocated data.
 99   jvmtiEventCallbacks _event_callbacks;
100   jvmtiExtEventCallbacks _ext_event_callbacks;
<span class="line-modified">101   JvmtiTagMap* _tag_map;</span>
102   JvmtiEnvEventEnable _env_event_enable;
103   jvmtiCapabilities _current_capabilities;
104   jvmtiCapabilities _prohibited_capabilities;
105   volatile bool _class_file_load_hook_ever_enabled;
106   static volatile bool _needs_clean_up;
107   char** _native_method_prefixes;
108   int    _native_method_prefix_count;
109 
110  protected:
111   JvmtiEnvBase(jint version);
112   ~JvmtiEnvBase();
113   void dispose();
114   void env_dispose();
115 
116   void set_env_local_storage(const void* data)     { _env_local_storage = data; }
117   const void* get_env_local_storage()              { return _env_local_storage; }
118 
119   void record_class_file_load_hook_enabled();
120   void record_first_time_class_file_load_hook_enabled();
121 
</pre>
<hr />
<pre>
236            event_type &lt;= JVMTI_MAX_EVENT_TYPE_VAL, &quot;checking&quot;);
237     return ((void**)&amp;_event_callbacks)[event_type-JVMTI_MIN_EVENT_TYPE_VAL] != NULL;
238   }
239 
240   jvmtiEventCallbacks* callbacks() {
241     return &amp;_event_callbacks;
242   }
243 
244   jvmtiExtEventCallbacks* ext_callbacks() {
245     return &amp;_ext_event_callbacks;
246   }
247 
248   void set_tag_map(JvmtiTagMap* tag_map) {
249     _tag_map = tag_map;
250   }
251 
252   JvmtiTagMap* tag_map() {
253     return _tag_map;
254   }
255 







256 
257   // return true if event is enabled globally or for any thread
258   // True only if there is a callback for it.
259   bool is_enabled(jvmtiEvent event_type) {
260     return _env_event_enable.is_enabled(event_type);
261   }
262 
263 // Random Utilities
264 
265  protected:
266   // helper methods for creating arrays of global JNI Handles from local Handles
267   // allocated into environment specific storage
268   jobject * new_jobjectArray(int length, Handle *handles);
269   jthread * new_jthreadArray(int length, Handle *handles);
270   jthreadGroup * new_jthreadGroupArray(int length, Handle *handles);
271 
272   // convert to a jni jclass from a non-null Klass*
273   jclass get_jni_class_non_null(Klass* k);
274 
275   jint count_locked_objects(JavaThread *java_thread, Handle hobj);
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIENVBASE_HPP
 26 #define SHARE_PRIMS_JVMTIENVBASE_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;prims/jvmtiThreadState.hpp&quot;
 32 #include &quot;oops/oopHandle.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/atomic.hpp&quot;</span>
 34 #include &quot;runtime/fieldDescriptor.hpp&quot;
 35 #include &quot;runtime/frame.hpp&quot;
 36 #include &quot;runtime/thread.hpp&quot;
 37 #include &quot;runtime/vmOperations.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 #include &quot;utilities/macros.hpp&quot;
 40 
 41 //
 42 // Forward Declarations
 43 //
 44 
 45 class JvmtiEnv;
 46 class JvmtiThreadState;
 47 class JvmtiRawMonitor; // for jvmtiEnv.hpp
 48 class JvmtiEventControllerPrivate;
 49 class JvmtiTagMap;
 50 
 51 
 52 
 53 // One JvmtiEnv object is created per jvmti attachment;
</pre>
<hr />
<pre>
 82   static void entering_dying_thread_env_iteration() { ++_dying_thread_env_iteration_count; }
 83   static void leaving_dying_thread_env_iteration()  { --_dying_thread_env_iteration_count; }
 84   static bool is_inside_dying_thread_env_iteration(){ return _dying_thread_env_iteration_count &gt; 0; }
 85 
 86  private:
 87 
 88   enum {
 89       JVMTI_MAGIC    = 0x71EE,
 90       DISPOSED_MAGIC = 0xDEFC,
 91       BAD_MAGIC      = 0xDEAD
 92   };
 93 
 94   jvmtiEnv _jvmti_external;
 95   jint _magic;
 96   jint _version;  // version value passed to JNI GetEnv()
 97   JvmtiEnvBase* _next;
 98   bool _is_retransformable;
 99   const void *_env_local_storage;     // per env agent allocated data.
100   jvmtiEventCallbacks _event_callbacks;
101   jvmtiExtEventCallbacks _ext_event_callbacks;
<span class="line-modified">102   JvmtiTagMap* volatile _tag_map;</span>
103   JvmtiEnvEventEnable _env_event_enable;
104   jvmtiCapabilities _current_capabilities;
105   jvmtiCapabilities _prohibited_capabilities;
106   volatile bool _class_file_load_hook_ever_enabled;
107   static volatile bool _needs_clean_up;
108   char** _native_method_prefixes;
109   int    _native_method_prefix_count;
110 
111  protected:
112   JvmtiEnvBase(jint version);
113   ~JvmtiEnvBase();
114   void dispose();
115   void env_dispose();
116 
117   void set_env_local_storage(const void* data)     { _env_local_storage = data; }
118   const void* get_env_local_storage()              { return _env_local_storage; }
119 
120   void record_class_file_load_hook_enabled();
121   void record_first_time_class_file_load_hook_enabled();
122 
</pre>
<hr />
<pre>
237            event_type &lt;= JVMTI_MAX_EVENT_TYPE_VAL, &quot;checking&quot;);
238     return ((void**)&amp;_event_callbacks)[event_type-JVMTI_MIN_EVENT_TYPE_VAL] != NULL;
239   }
240 
241   jvmtiEventCallbacks* callbacks() {
242     return &amp;_event_callbacks;
243   }
244 
245   jvmtiExtEventCallbacks* ext_callbacks() {
246     return &amp;_ext_event_callbacks;
247   }
248 
249   void set_tag_map(JvmtiTagMap* tag_map) {
250     _tag_map = tag_map;
251   }
252 
253   JvmtiTagMap* tag_map() {
254     return _tag_map;
255   }
256 
<span class="line-added">257   JvmtiTagMap* tag_map_acquire() {</span>
<span class="line-added">258     return Atomic::load_acquire(&amp;_tag_map);</span>
<span class="line-added">259   }</span>
<span class="line-added">260 </span>
<span class="line-added">261   void release_set_tag_map(JvmtiTagMap* tag_map) {</span>
<span class="line-added">262     Atomic::release_store(&amp;_tag_map, tag_map);</span>
<span class="line-added">263   }</span>
264 
265   // return true if event is enabled globally or for any thread
266   // True only if there is a callback for it.
267   bool is_enabled(jvmtiEvent event_type) {
268     return _env_event_enable.is_enabled(event_type);
269   }
270 
271 // Random Utilities
272 
273  protected:
274   // helper methods for creating arrays of global JNI Handles from local Handles
275   // allocated into environment specific storage
276   jobject * new_jobjectArray(int length, Handle *handles);
277   jthread * new_jthreadArray(int length, Handle *handles);
278   jthreadGroup * new_jthreadGroupArray(int length, Handle *handles);
279 
280   // convert to a jni jclass from a non-null Klass*
281   jclass get_jni_class_non_null(Klass* k);
282 
283   jint count_locked_objects(JavaThread *java_thread, Handle hobj);
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEventController.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvmtiRawMonitor.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRawMonitor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRawMonitor.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,78 +23,122 @@</span>
   */
  
  #ifndef SHARE_PRIMS_JVMTIRAWMONITOR_HPP
  #define SHARE_PRIMS_JVMTIRAWMONITOR_HPP
  
<span class="udiff-line-modified-removed">- #include &quot;runtime/objectMonitor.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;memory/allocation.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/park.hpp&quot;</span>
  #include &quot;utilities/growableArray.hpp&quot;
  
  //
  // class JvmtiRawMonitor
  //
  // Used by JVMTI methods: All RawMonitor methods (CreateRawMonitor, EnterRawMonitor, etc.)
  //
<span class="udiff-line-modified-removed">- // Wrapper for ObjectMonitor class that saves the Monitor&#39;s name</span>
<span class="udiff-line-modified-added">+ // A simplified version of the ObjectMonitor code.</span>
  //
  
<span class="udiff-line-modified-removed">- class JvmtiRawMonitor : public ObjectMonitor  {</span>
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-   int           _magic;</span>
<span class="udiff-line-modified-removed">-   char *        _name;</span>
<span class="udiff-line-modified-added">+ class JvmtiRawMonitor : public CHeapObj&lt;mtSynchronizer&gt;  {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Helper class to allow Threads to be linked into queues.</span>
<span class="udiff-line-modified-added">+   // This is a stripped down version of ObjectWaiter.</span>
<span class="udiff-line-added">+   class QNode : public StackObj {</span>
<span class="udiff-line-added">+     friend class JvmtiRawMonitor;</span>
<span class="udiff-line-added">+     enum TStates { TS_READY, TS_RUN, TS_WAIT, TS_ENTER };</span>
<span class="udiff-line-added">+     QNode* volatile _next;</span>
<span class="udiff-line-added">+     QNode* volatile _prev;</span>
<span class="udiff-line-added">+     ParkEvent* _event;</span>
<span class="udiff-line-added">+     volatile int _notified;</span>
<span class="udiff-line-added">+     volatile TStates _t_state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     QNode(Thread* thread);</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Thread* volatile _owner;      // pointer to owning thread</span>
<span class="udiff-line-added">+   volatile int _recursions;     // recursion count, 0 for first entry</span>
<span class="udiff-line-added">+   QNode* volatile _entry_list;  // Threads blocked on entry or reentry.</span>
<span class="udiff-line-added">+                                 // The list is actually composed of nodes,</span>
<span class="udiff-line-added">+                                 // acting as proxies for Threads.</span>
<span class="udiff-line-added">+   QNode* volatile _wait_set;    // Threads wait()ing on the monitor</span>
<span class="udiff-line-added">+   volatile jint _waiters;       // number of waiting threads</span>
<span class="udiff-line-added">+   int _magic;</span>
<span class="udiff-line-added">+   char* _name;</span>
    // JVMTI_RM_MAGIC is set in contructor and unset in destructor.
    enum { JVMTI_RM_MAGIC = (int)((&#39;T&#39; &lt;&lt; 24) | (&#39;I&#39; &lt;&lt; 16) | (&#39;R&#39; &lt;&lt; 8) | &#39;M&#39;) };
  
<span class="udiff-line-modified-removed">-   int       SimpleEnter (Thread * Self) ;</span>
<span class="udiff-line-modified-removed">-   int       SimpleExit  (Thread * Self) ;</span>
<span class="udiff-line-modified-removed">-   int       SimpleWait  (Thread * Self, jlong millis) ;</span>
<span class="udiff-line-removed">-   int       SimpleNotify (Thread * Self, bool All) ;</span>
<span class="udiff-line-modified-added">+   // Helpers for queue management isolation</span>
<span class="udiff-line-modified-added">+   void enqueue_waiter(QNode&amp; node);</span>
<span class="udiff-line-modified-added">+   void dequeue_waiter(QNode&amp; node);</span>
  
<span class="udiff-line-modified-removed">- public:</span>
<span class="udiff-line-modified-removed">-   JvmtiRawMonitor(const char *name);</span>
<span class="udiff-line-modified-added">+   // Mostly low-level implementation routines</span>
<span class="udiff-line-modified-added">+   void simple_enter(Thread* self);</span>
<span class="udiff-line-added">+   void simple_exit(Thread* self);</span>
<span class="udiff-line-added">+   int simple_wait(Thread* self, jlong millis);</span>
<span class="udiff-line-added">+   void simple_notify(Thread* self, bool all);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // return codes</span>
<span class="udiff-line-added">+   enum {</span>
<span class="udiff-line-added">+     M_OK,                    // no error</span>
<span class="udiff-line-added">+     M_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException</span>
<span class="udiff-line-added">+     M_INTERRUPTED            // Thread.interrupt()</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Non-aborting operator new</span>
<span class="udiff-line-added">+   void* operator new(size_t size) throw() {</span>
<span class="udiff-line-added">+     return CHeapObj::operator new(size, std::nothrow);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   JvmtiRawMonitor(const char* name);</span>
    ~JvmtiRawMonitor();
<span class="udiff-line-modified-removed">-   int       raw_enter(TRAPS);</span>
<span class="udiff-line-modified-removed">-   int       raw_exit(TRAPS);</span>
<span class="udiff-line-modified-removed">-   int       raw_wait(jlong millis, bool interruptable, TRAPS);</span>
<span class="udiff-line-modified-removed">-   int       raw_notify(TRAPS);</span>
<span class="udiff-line-modified-removed">-   int       raw_notifyAll(TRAPS);</span>
<span class="udiff-line-modified-removed">-   int            magic()   { return _magic;  }</span>
<span class="udiff-line-modified-removed">-   const char *get_name()   { return _name; }</span>
<span class="udiff-line-modified-removed">-   bool        is_valid();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   Thread* owner() const { return _owner; }</span>
<span class="udiff-line-modified-added">+   void set_owner(Thread* owner) { _owner = owner; }</span>
<span class="udiff-line-modified-added">+   int recursions() const { return _recursions; }</span>
<span class="udiff-line-modified-added">+   void raw_enter(Thread* self);</span>
<span class="udiff-line-modified-added">+   int raw_exit(Thread* self);</span>
<span class="udiff-line-modified-added">+   int raw_wait(jlong millis, Thread* self);</span>
<span class="udiff-line-modified-added">+   int raw_notify(Thread* self);</span>
<span class="udiff-line-added">+   int raw_notifyAll(Thread* self);</span>
<span class="udiff-line-added">+   int magic() const { return _magic; }</span>
<span class="udiff-line-added">+   const char* get_name() const { return _name; }</span>
<span class="udiff-line-added">+   bool is_valid();</span>
  };
  
  // Onload pending raw monitors
  // Class is used to cache onload or onstart monitor enter
  // which will transition into real monitor when
  // VM is fully initialized.
  class JvmtiPendingMonitors : public AllStatic {
  
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-   static GrowableArray&lt;JvmtiRawMonitor*&gt; *_monitors; // Cache raw monitor enter</span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-modified-added">+   static GrowableArray&lt;JvmtiRawMonitor*&gt;* _monitors; // Cache raw monitor enter</span>
  
    inline static GrowableArray&lt;JvmtiRawMonitor*&gt;* monitors() { return _monitors; }
  
    static void dispose() {
      delete monitors();
    }
  
<span class="udiff-line-modified-removed">- public:</span>
<span class="udiff-line-modified-removed">-   static void enter(JvmtiRawMonitor *monitor) {</span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   static void enter(JvmtiRawMonitor* monitor) {</span>
      monitors()-&gt;append(monitor);
    }
  
    static int count() {
      return monitors()-&gt;length();
    }
  
<span class="udiff-line-modified-removed">-   static void destroy(JvmtiRawMonitor *monitor) {</span>
<span class="udiff-line-modified-added">+   static void destroy(JvmtiRawMonitor* monitor) {</span>
      while (monitors()-&gt;contains(monitor)) {
        monitors()-&gt;remove(monitor);
      }
    }
  
    // Return false if monitor is not found in the list.
<span class="udiff-line-modified-removed">-   static bool exit(JvmtiRawMonitor *monitor) {</span>
<span class="udiff-line-modified-added">+   static bool exit(JvmtiRawMonitor* monitor) {</span>
      if (monitors()-&gt;contains(monitor)) {
        monitors()-&gt;remove(monitor);
        return true;
      } else {
        return false;
</pre>
<center><a href="jvmtiRawMonitor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
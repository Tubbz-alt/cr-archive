<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodComparator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,24 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
<span class="line-modified">! #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-new-header">--- 23,27 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/objArrayKlass.hpp&quot;</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
<span class="line-modified">! #include &quot;runtime/deoptimization.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,11 ***</span>
    return NULL;
  }
  
  oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
    assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
<span class="line-modified">!   methodHandle m = info.resolved_method();</span>
    assert(m.not_null(), &quot;null method handle&quot;);
    InstanceKlass* m_klass = m-&gt;method_holder();
    assert(m_klass != NULL, &quot;null holder for method handle&quot;);
    int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
    int vmindex = Method::invalid_vtable_index;
<span class="line-new-header">--- 220,11 ---</span>
    return NULL;
  }
  
  oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
    assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
<span class="line-modified">!   methodHandle m(Thread::current(), info.resolved_method());</span>
    assert(m.not_null(), &quot;null method handle&quot;);
    InstanceKlass* m_klass = m-&gt;method_holder();
    assert(m_klass != NULL, &quot;null holder for method handle&quot;);
    int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
    int vmindex = Method::invalid_vtable_index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,11 ***</span>
    if (m-&gt;caller_sensitive()) {
      flags |= CALLER_SENSITIVE;
    }
  
    Handle resolved_method = info.resolved_method_name();
<span class="line-modified">!   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m(),</span>
           &quot;Should not change after link resolution&quot;);
  
    oop mname_oop = mname();
    java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
    java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
<span class="line-new-header">--- 317,11 ---</span>
    if (m-&gt;caller_sensitive()) {
      flags |= CALLER_SENSITIVE;
    }
  
    Handle resolved_method = info.resolved_method_name();
<span class="line-modified">!   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),</span>
           &quot;Should not change after link resolution&quot;);
  
    oop mname_oop = mname();
    java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
    java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,16 ***</span>
  }
  
  // convert the external string or reflective type to an internal signature
  Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
    if (java_lang_invoke_MethodType::is_instance(type_str)) {
<span class="line-modified">!     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found, THREAD);</span>
    } else if (java_lang_Class::is_instance(type_str)) {
<span class="line-modified">!     return java_lang_Class::as_signature(type_str, false, THREAD);</span>
    } else if (java_lang_String::is_instance_inlined(type_str)) {
      if (intern_if_not_found) {
<span class="line-modified">!       return java_lang_String::as_symbol(type_str, THREAD);</span>
      } else {
        return java_lang_String::as_symbol_or_null(type_str);
      }
    } else {
      THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
<span class="line-new-header">--- 517,16 ---</span>
  }
  
  // convert the external string or reflective type to an internal signature
  Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
    if (java_lang_invoke_MethodType::is_instance(type_str)) {
<span class="line-modified">!     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found);</span>
    } else if (java_lang_Class::is_instance(type_str)) {
<span class="line-modified">!     return java_lang_Class::as_signature(type_str, false);</span>
    } else if (java_lang_String::is_instance_inlined(type_str)) {
      if (intern_if_not_found) {
<span class="line-modified">!       return java_lang_String::as_symbol(type_str);</span>
      } else {
        return java_lang_String::as_symbol_or_null(type_str);
      }
    } else {
      THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,25 ***</span>
  enum { OBJ_SIG_LEN = 18 };
  
  bool MethodHandles::is_basic_type_signature(Symbol* sig) {
    assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
    assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
<span class="line-modified">!   const int len = sig-&gt;utf8_length();</span>
<span class="line-modified">!   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified">!     switch (sig-&gt;char_at(i)) {</span>
<span class="line-removed">-     case &#39;L&#39;:</span>
        // only java/lang/Object is valid here
<span class="line-modified">!       if (sig-&gt;index_of_at(i, OBJ_SIG, OBJ_SIG_LEN) != i)</span>
          return false;
<span class="line-modified">!       i += OBJ_SIG_LEN-1;  //-1 because of i++ in loop</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     case &#39;(&#39;: case &#39;)&#39;: case &#39;V&#39;:</span>
<span class="line-modified">!     case &#39;I&#39;: case &#39;J&#39;: case &#39;F&#39;: case &#39;D&#39;:</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     //case &#39;[&#39;:</span>
<span class="line-modified">!     //case &#39;Z&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;S&#39;:</span>
      default:
        return false;
      }
    }
    return true;
  }
<span class="line-new-header">--- 537,25 ---</span>
  enum { OBJ_SIG_LEN = 18 };
  
  bool MethodHandles::is_basic_type_signature(Symbol* sig) {
    assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
    assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
<span class="line-modified">!   for (SignatureStream ss(sig, sig-&gt;starts_with(JVM_SIGNATURE_FUNC)); !ss.is_done(); ss.next()) {</span>
<span class="line-modified">!     switch (ss.type()) {</span>
<span class="line-modified">!     case T_OBJECT:</span>
        // only java/lang/Object is valid here
<span class="line-modified">!       if (strncmp((char*) ss.raw_bytes(), OBJ_SIG, OBJ_SIG_LEN) != 0)</span>
          return false;
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case T_VOID:</span>
<span class="line-modified">!     case T_INT:</span>
<span class="line-modified">!     case T_LONG:</span>
<span class="line-modified">!     case T_FLOAT:</span>
<span class="line-modified">!     case T_DOUBLE:</span>
<span class="line-modified">!       break;</span>
      default:
<span class="line-added">+       // subword types (T_BYTE etc.), Q-descriptors, arrays</span>
        return false;
      }
    }
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,118 ***</span>
    if (sig == NULL) {
      return sig;
    } else if (is_basic_type_signature(sig)) {
      sig-&gt;increment_refcount();
      return sig;  // that was easy
<span class="line-modified">!   } else if (sig-&gt;char_at(0) != &#39;(&#39;) {</span>
<span class="line-modified">!     BasicType bt = char2type(sig-&gt;char_at(0));</span>
      if (is_subword_type(bt)) {
        bsig = vmSymbols::int_signature();
      } else {
<span class="line-modified">!       assert(bt == T_OBJECT || bt == T_ARRAY, &quot;is_basic_type_signature was false&quot;);</span>
        bsig = vmSymbols::object_signature();
      }
    } else {
      ResourceMark rm;
      stringStream buffer(128);
<span class="line-modified">!     buffer.put(&#39;(&#39;);</span>
      int arg_pos = 0, keep_arg_pos = -1;
      if (keep_last_arg)
        keep_arg_pos = ArgumentCount(sig).size() - 1;
      for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
        BasicType bt = ss.type();
        size_t this_arg_pos = buffer.size();
        if (ss.at_return_type()) {
<span class="line-modified">!         buffer.put(&#39;)&#39;);</span>
        }
        if (arg_pos == keep_arg_pos) {
          buffer.write((char*) ss.raw_bytes(),
                       (int)   ss.raw_length());
<span class="line-modified">!       } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
          buffer.write(OBJ_SIG, OBJ_SIG_LEN);
        } else {
          if (is_subword_type(bt))
            bt = T_INT;
          buffer.put(type2char(bt));
        }
        arg_pos++;
      }
      const char* sigstr =       buffer.base();
      int         siglen = (int) buffer.size();
<span class="line-modified">!     bsig = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
    }
    assert(is_basic_type_signature(bsig) ||
           // detune assert in case the injected argument is not a basic type:
           keep_last_arg, &quot;&quot;);
    return bsig;
  }
  
  void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
<span class="line-modified">!                                                      Symbol* sig,</span>
<span class="line-removed">-                                                      bool keep_arrays,</span>
<span class="line-removed">-                                                      bool keep_basic_names) {</span>
    st = st ? st : tty;
<span class="line-removed">-   int len  = sig-&gt;utf8_length();</span>
<span class="line-removed">-   int array = 0;</span>
    bool prev_type = false;
<span class="line-modified">!   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified">!     char ch = sig-&gt;char_at(i);</span>
<span class="line-modified">!     switch (ch) {</span>
<span class="line-modified">!     case &#39;(&#39;: case &#39;)&#39;:</span>
<span class="line-modified">!       prev_type = false;</span>
<span class="line-modified">!       st-&gt;put(ch);</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     case &#39;[&#39;:</span>
<span class="line-modified">!       if (!keep_basic_names &amp;&amp; keep_arrays)</span>
<span class="line-modified">!         st-&gt;put(ch);</span>
<span class="line-modified">!       array++;</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     case &#39;L&#39;:</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-modified">!         int start = i+1, slash = start;</span>
<span class="line-removed">-         while (++i &lt; len &amp;&amp; (ch = sig-&gt;char_at(i)) != &#39;;&#39;) {</span>
<span class="line-removed">-           if (ch == &#39;/&#39; || ch == &#39;.&#39; || ch == &#39;$&#39;)  slash = i+1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (slash &lt; i)  start = slash;</span>
<span class="line-removed">-         if (!keep_basic_names) {</span>
<span class="line-removed">-           st-&gt;put(&#39;L&#39;);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           for (int j = start; j &lt; i; j++)</span>
<span class="line-removed">-             st-&gt;put(sig-&gt;char_at(j));</span>
<span class="line-removed">-           prev_type = true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         if (array &amp;&amp; char2type(ch) != T_ILLEGAL &amp;&amp; !keep_arrays) {</span>
<span class="line-removed">-           ch = &#39;[&#39;;</span>
<span class="line-removed">-           array = 0;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-removed">-         const char* n = NULL;</span>
<span class="line-removed">-         if (keep_basic_names)</span>
<span class="line-removed">-           n = type2name(char2type(ch));</span>
<span class="line-removed">-         if (n == NULL) {</span>
<span class="line-removed">-           // unknown letter, or we don&#39;t want to know its name</span>
<span class="line-removed">-           st-&gt;put(ch);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           st-&gt;print(&quot;%s&quot;, n);</span>
<span class="line-removed">-           prev_type = true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Switch break goes here to take care of array suffix:</span>
<span class="line-removed">-     if (prev_type) {</span>
<span class="line-removed">-       while (array &gt; 0) {</span>
<span class="line-removed">-         st-&gt;print(&quot;[]&quot;);</span>
<span class="line-removed">-         --array;</span>
<span class="line-removed">-       }</span>
      }
<span class="line-removed">-     array = 0;</span>
    }
  }
  
  
  
<span class="line-new-header">--- 565,74 ---</span>
    if (sig == NULL) {
      return sig;
    } else if (is_basic_type_signature(sig)) {
      sig-&gt;increment_refcount();
      return sig;  // that was easy
<span class="line-modified">!   } else if (!sig-&gt;starts_with(JVM_SIGNATURE_FUNC)) {</span>
<span class="line-modified">!     BasicType bt = Signature::basic_type(sig);</span>
      if (is_subword_type(bt)) {
        bsig = vmSymbols::int_signature();
      } else {
<span class="line-modified">!       assert(is_reference_type(bt), &quot;is_basic_type_signature was false&quot;);</span>
        bsig = vmSymbols::object_signature();
      }
    } else {
      ResourceMark rm;
      stringStream buffer(128);
<span class="line-modified">!     buffer.put(JVM_SIGNATURE_FUNC);</span>
      int arg_pos = 0, keep_arg_pos = -1;
      if (keep_last_arg)
        keep_arg_pos = ArgumentCount(sig).size() - 1;
      for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
        BasicType bt = ss.type();
        size_t this_arg_pos = buffer.size();
        if (ss.at_return_type()) {
<span class="line-modified">!         buffer.put(JVM_SIGNATURE_ENDFUNC);</span>
        }
        if (arg_pos == keep_arg_pos) {
          buffer.write((char*) ss.raw_bytes(),
                       (int)   ss.raw_length());
<span class="line-modified">!       } else if (is_reference_type(bt)) {</span>
          buffer.write(OBJ_SIG, OBJ_SIG_LEN);
        } else {
          if (is_subword_type(bt))
            bt = T_INT;
          buffer.put(type2char(bt));
        }
        arg_pos++;
      }
      const char* sigstr =       buffer.base();
      int         siglen = (int) buffer.size();
<span class="line-modified">!     bsig = SymbolTable::new_symbol(sigstr, siglen);</span>
    }
    assert(is_basic_type_signature(bsig) ||
           // detune assert in case the injected argument is not a basic type:
           keep_last_arg, &quot;&quot;);
    return bsig;
  }
  
  void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
<span class="line-modified">!                                                      Symbol* sig) {</span>
    st = st ? st : tty;
    bool prev_type = false;
<span class="line-modified">!   bool is_method = (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC);</span>
<span class="line-modified">!   if (is_method)  st-&gt;put(JVM_SIGNATURE_FUNC);</span>
<span class="line-modified">!   for (SignatureStream ss(sig, is_method); !ss.is_done(); ss.next()) {</span>
<span class="line-modified">!     if (ss.at_return_type())</span>
<span class="line-modified">!       st-&gt;put(JVM_SIGNATURE_ENDFUNC);</span>
<span class="line-modified">!     else if (prev_type)</span>
<span class="line-modified">!       st-&gt;put(&#39;,&#39;);</span>
<span class="line-modified">!     const char* cp = (const char*) ss.raw_bytes();</span>
<span class="line-modified">!     if (ss.is_array()) {</span>
<span class="line-modified">!       st-&gt;put(JVM_SIGNATURE_ARRAY);</span>
<span class="line-modified">!       if (ss.array_prefix_length() == 1)</span>
<span class="line-modified">!         st-&gt;put(cp[1]);</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         st-&gt;put(JVM_SIGNATURE_CLASS);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       st-&gt;put(cp[0]);</span>
      }
    }
  }
  
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,11 ***</span>
    return StringTable::lookup(s);
  }
  
  oop MethodHandles::field_signature_type_or_null(Symbol* s) {
    if (s == NULL)  return NULL;
<span class="line-modified">!   BasicType bt = FieldType::basic_type(s);</span>
    if (is_java_primitive(bt)) {
      assert(s-&gt;utf8_length() == 1, &quot;&quot;);
      return java_lang_Class::primitive_mirror(bt);
    }
    // Here are some more short cuts for common types.
<span class="line-new-header">--- 645,11 ---</span>
    return StringTable::lookup(s);
  }
  
  oop MethodHandles::field_signature_type_or_null(Symbol* s) {
    if (s == NULL)  return NULL;
<span class="line-modified">!   BasicType bt = Signature::basic_type(s);</span>
    if (is_java_primitive(bt)) {
      assert(s-&gt;utf8_length() == 1, &quot;&quot;);
      return java_lang_Class::primitive_mirror(bt);
    }
    // Here are some more short cuts for common types.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 972,12 ***</span>
  
    if (name != NULL) {
      if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
    }
    if (sig != NULL) {
<span class="line-modified">!     if (sig-&gt;utf8_length() == 0)  return 0; // a match is not possible</span>
<span class="line-removed">-     if (sig-&gt;char_at(0) == &#39;(&#39;)</span>
        match_flags &amp;= ~(IS_FIELD | IS_TYPE);
      else
        match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);
    }
  
<span class="line-new-header">--- 931,11 ---</span>
  
    if (name != NULL) {
      if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
    }
    if (sig != NULL) {
<span class="line-modified">!     if (sig-&gt;starts_with(JVM_SIGNATURE_FUNC))</span>
        match_flags &amp;= ~(IS_FIELD | IS_TYPE);
      else
        match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 998,11 ***</span>
        } else if (rfill &lt; rlimit) {
          Handle result(thread, results-&gt;obj_at(rfill++));
          if (!java_lang_invoke_MemberName::is_instance(result()))
            return -99;  // caller bug!
          oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
<span class="line-modified">!         if (!oopDesc::equals(saved, result()))</span>
            results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
        } else if (++overflow &gt;= overflow_limit) {
          match_flags = 0; break; // got tired of looking at overflow
        }
      }
<span class="line-new-header">--- 956,11 ---</span>
        } else if (rfill &lt; rlimit) {
          Handle result(thread, results-&gt;obj_at(rfill++));
          if (!java_lang_invoke_MemberName::is_instance(result()))
            return -99;  // caller bug!
          oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
<span class="line-modified">!         if (saved != result())</span>
            results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
        } else if (++overflow &gt;= overflow_limit) {
          match_flags = 0; break; // got tired of looking at overflow
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,11 ***</span>
          Handle result(thread, results-&gt;obj_at(rfill++));
          if (!java_lang_invoke_MemberName::is_instance(result()))
            return -99;  // caller bug!
          CallInfo info(m, NULL, CHECK_0);
          oop saved = MethodHandles::init_method_MemberName(result, info);
<span class="line-modified">!         if (!oopDesc::equals(saved, result()))</span>
            results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
        } else if (++overflow &gt;= overflow_limit) {
          match_flags = 0; break; // got tired of looking at overflow
        }
      }
<span class="line-new-header">--- 1008,11 ---</span>
          Handle result(thread, results-&gt;obj_at(rfill++));
          if (!java_lang_invoke_MemberName::is_instance(result()))
            return -99;  // caller bug!
          CallInfo info(m, NULL, CHECK_0);
          oop saved = MethodHandles::init_method_MemberName(result, info);
<span class="line-modified">!         if (saved != result())</span>
            results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
        } else if (++overflow &gt;= overflow_limit) {
          match_flags = 0; break; // got tired of looking at overflow
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,20 ***</span>
  
    int marked = 0;
    CallSiteDepChange changes(call_site, target);
    {
      NoSafepointVerifier nsv;
<span class="line-modified">!     MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
      oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
      marked = deps.mark_dependent_nmethods(changes);
    }
    if (marked &gt; 0) {
      // At least one nmethod has been marked for deoptimization.
<span class="line-modified">!     VM_Deoptimize op;</span>
<span class="line-removed">-     VMThread::execute(&amp;op);</span>
    }
  }
  
  void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
    if (TraceMethodHandles) {
<span class="line-new-header">--- 1054,19 ---</span>
  
    int marked = 0;
    CallSiteDepChange changes(call_site, target);
    {
      NoSafepointVerifier nsv;
<span class="line-modified">!     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
      oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
      marked = deps.mark_dependent_nmethods(changes);
    }
    if (marked &gt; 0) {
      // At least one nmethod has been marked for deoptimization.
<span class="line-modified">!     Deoptimization::deoptimize_all_marked();</span>
    }
  }
  
  void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
    if (TraceMethodHandles) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1384,11 ***</span>
  JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
    Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
    Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu(Compile_lock, thread);</span>
      MethodHandles::flush_dependent_nmethods(call_site, target);
      java_lang_invoke_CallSite::set_target(call_site(), target());
    }
  }
  JVM_END
<span class="line-new-header">--- 1341,11 ---</span>
  JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
    Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
    Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu(thread, Compile_lock);</span>
      MethodHandles::flush_dependent_nmethods(call_site, target);
      java_lang_invoke_CallSite::set_target(call_site(), target());
    }
  }
  JVM_END
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1396,11 ***</span>
  JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
    Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
    Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu(Compile_lock, thread);</span>
      MethodHandles::flush_dependent_nmethods(call_site, target);
      java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
    }
  }
  JVM_END
<span class="line-new-header">--- 1353,11 ---</span>
  JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
    Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
    Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu(thread, Compile_lock);</span>
      MethodHandles::flush_dependent_nmethods(call_site, target);
      java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
    }
  }
  JVM_END
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1452,11 ***</span>
            }
          case -2:  // type
            {
              Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
              Handle th;
<span class="line-modified">!             if (type-&gt;char_at(0) == &#39;(&#39;) {</span>
                th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
              } else {
                th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
              }
              pseudo_arg = th();
<span class="line-new-header">--- 1409,11 ---</span>
            }
          case -2:  // type
            {
              Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
              Handle th;
<span class="line-modified">!             if (type-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
                th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
              } else {
                th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
              }
              pseudo_arg = th();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,23 ***</span>
  // deallocate their dependency information.
  JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
    Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu1(Compile_lock, thread);</span>
  
      int marked = 0;
      {
        NoSafepointVerifier nsv;
<span class="line-modified">!       MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
        marked = deps.remove_all_dependents();
      }
      if (marked &gt; 0) {
        // At least one nmethod has been marked for deoptimization
<span class="line-modified">!       VM_Deoptimize op;</span>
<span class="line-removed">-       VMThread::execute(&amp;op);</span>
      }
    }
  }
  JVM_END
  
<span class="line-new-header">--- 1447,22 ---</span>
  // deallocate their dependency information.
  JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
    Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
    {
      // Walk all nmethods depending on this call site.
<span class="line-modified">!     MutexLocker mu1(thread, Compile_lock);</span>
  
      int marked = 0;
      {
        NoSafepointVerifier nsv;
<span class="line-modified">!       MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
        marked = deps.remove_all_dependents();
      }
      if (marked &gt; 0) {
        // At least one nmethod has been marked for deoptimization
<span class="line-modified">!       Deoptimization::deoptimize_all_marked();</span>
      }
    }
  }
  JVM_END
  
</pre>
<center><a href="methodComparator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
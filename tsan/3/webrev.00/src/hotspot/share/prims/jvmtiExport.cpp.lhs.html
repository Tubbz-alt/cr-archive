<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiExport.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
<a name="2" id="anc2"></a>
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;code/nmethod.hpp&quot;
  29 #include &quot;code/pcDesc.hpp&quot;
  30 #include &quot;code/scopeDesc.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  33 #include &quot;logging/log.hpp&quot;
  34 #include &quot;logging/logStream.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;oops/objArrayOop.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  41 #include &quot;prims/jvmtiEventController.hpp&quot;
  42 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  43 #include &quot;prims/jvmtiExport.hpp&quot;
  44 #include &quot;prims/jvmtiImpl.hpp&quot;
  45 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  46 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  47 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  48 #include &quot;prims/jvmtiTagMap.hpp&quot;
  49 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  50 #include &quot;runtime/arguments.hpp&quot;
  51 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  54 #include &quot;runtime/javaCalls.hpp&quot;
  55 #include &quot;runtime/jniHandles.inline.hpp&quot;
  56 #include &quot;runtime/objectMonitor.hpp&quot;
  57 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  58 #include &quot;runtime/os.inline.hpp&quot;
  59 #include &quot;runtime/safepointVerifiers.hpp&quot;
<a name="4" id="anc4"></a>
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadSMR.hpp&quot;
  62 #include &quot;runtime/vframe.inline.hpp&quot;
  63 #include &quot;utilities/macros.hpp&quot;
  64 
  65 #ifdef JVMTI_TRACE
  66 #define EVT_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_SENT) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  67 #define EVT_TRIG_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_TRIGGER) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  68 #else
  69 #define EVT_TRIG_TRACE(evt,out)
  70 #define EVT_TRACE(evt,out)
  71 #endif
  72 
  73 ///////////////////////////////////////////////////////////////
  74 //
  75 // JvmtiEventTransition
  76 //
  77 // TO DO --
  78 //  more handle purging
  79 
  80 // Use this for JavaThreads and state is  _thread_in_vm.
  81 class JvmtiJavaThreadEventTransition : StackObj {
  82 private:
  83   ResourceMark _rm;
  84   ThreadToNativeFromVM _transition;
  85   HandleMark _hm;
  86 
  87 public:
  88   JvmtiJavaThreadEventTransition(JavaThread *thread) :
  89     _rm(),
  90     _transition(thread),
  91     _hm(thread)  {};
  92 };
  93 
  94 // For JavaThreads which are not in _thread_in_vm state
  95 // and other system threads use this.
  96 class JvmtiThreadEventTransition : StackObj {
  97 private:
  98   ResourceMark _rm;
  99   HandleMark _hm;
 100   JavaThreadState _saved_state;
 101   JavaThread *_jthread;
 102 
 103 public:
 104   JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm() {
 105     if (thread-&gt;is_Java_thread()) {
 106        _jthread = (JavaThread *)thread;
 107        _saved_state = _jthread-&gt;thread_state();
 108        if (_saved_state == _thread_in_Java) {
 109          ThreadStateTransition::transition_from_java(_jthread, _thread_in_native);
 110        } else {
 111          ThreadStateTransition::transition(_jthread, _saved_state, _thread_in_native);
 112        }
 113     } else {
 114       _jthread = NULL;
 115     }
 116   }
 117 
 118   ~JvmtiThreadEventTransition() {
 119     if (_jthread != NULL)
 120       ThreadStateTransition::transition_from_native(_jthread, _saved_state);
 121   }
 122 };
 123 
 124 
 125 ///////////////////////////////////////////////////////////////
 126 //
 127 // JvmtiEventMark
 128 //
 129 
 130 class JvmtiEventMark : public StackObj {
 131 private:
 132   JavaThread *_thread;
 133   JNIEnv* _jni_env;
 134   JvmtiThreadState::ExceptionState _saved_exception_state;
 135 #if 0
 136   JNIHandleBlock* _hblock;
 137 #endif
 138 
 139 public:
 140   JvmtiEventMark(JavaThread *thread) :  _thread(thread),
 141                                         _jni_env(thread-&gt;jni_environment()),
 142                                         _saved_exception_state(JvmtiThreadState::ES_CLEARED) {
 143 #if 0
 144     _hblock = thread-&gt;active_handles();
 145     _hblock-&gt;clear_thoroughly(); // so we can be safe
 146 #else
 147     // we want to use the code above - but that needs the JNIHandle changes - later...
 148     // for now, steal JNI push local frame code
 149     JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
 150     // we are before an event.
 151     // Save current jvmti thread exception state.
 152     if (state != NULL) {
 153       _saved_exception_state = state-&gt;get_exception_state();
 154     }
 155 
 156     JNIHandleBlock* old_handles = thread-&gt;active_handles();
 157     JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 158     assert(new_handles != NULL, &quot;should not be NULL&quot;);
 159     new_handles-&gt;set_pop_frame_link(old_handles);
 160     thread-&gt;set_active_handles(new_handles);
 161 #endif
 162     assert(thread == JavaThread::current(), &quot;thread must be current!&quot;);
 163     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
 164   };
 165 
 166   ~JvmtiEventMark() {
 167 #if 0
 168     _hblock-&gt;clear(); // for consistency with future correct behavior
 169 #else
 170     // we want to use the code above - but that needs the JNIHandle changes - later...
 171     // for now, steal JNI pop local frame code
 172     JNIHandleBlock* old_handles = _thread-&gt;active_handles();
 173     JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 174     assert(new_handles != NULL, &quot;should not be NULL&quot;);
 175     _thread-&gt;set_active_handles(new_handles);
 176     // Note that we set the pop_frame_link to NULL explicitly, otherwise
 177     // the release_block call will release the blocks.
 178     old_handles-&gt;set_pop_frame_link(NULL);
 179     JNIHandleBlock::release_block(old_handles, _thread); // may block
 180 #endif
 181 
 182     JvmtiThreadState* state = _thread-&gt;jvmti_thread_state();
 183     // we are continuing after an event.
 184     if (state != NULL) {
 185       // Restore the jvmti thread exception state.
 186       state-&gt;restore_exception_state(_saved_exception_state);
 187     }
 188   }
 189 
 190 #if 0
 191   jobject to_jobject(oop obj) { return obj == NULL? NULL : _hblock-&gt;allocate_handle_fast(obj); }
 192 #else
 193   // we want to use the code above - but that needs the JNIHandle changes - later...
 194   // for now, use regular make_local
 195   jobject to_jobject(oop obj) { return JNIHandles::make_local(_thread,obj); }
 196 #endif
 197 
 198   jclass to_jclass(Klass* klass) { return (klass == NULL ? NULL : (jclass)to_jobject(klass-&gt;java_mirror())); }
 199 
 200   jmethodID to_jmethodID(const methodHandle&amp; method) { return method-&gt;jmethod_id(); }
 201 
 202   JNIEnv* jni_env() { return _jni_env; }
 203 };
 204 
 205 class JvmtiThreadEventMark : public JvmtiEventMark {
 206 private:
 207   jthread _jt;
 208 
 209 public:
 210   JvmtiThreadEventMark(JavaThread *thread) :
 211     JvmtiEventMark(thread) {
 212     _jt = (jthread)(to_jobject(thread-&gt;threadObj()));
 213   };
 214  jthread jni_thread() { return _jt; }
 215 };
 216 
 217 class JvmtiClassEventMark : public JvmtiThreadEventMark {
 218 private:
 219   jclass _jc;
 220 
 221 public:
 222   JvmtiClassEventMark(JavaThread *thread, Klass* klass) :
 223     JvmtiThreadEventMark(thread) {
 224     _jc = to_jclass(klass);
 225   };
 226   jclass jni_class() { return _jc; }
 227 };
 228 
 229 class JvmtiMethodEventMark : public JvmtiThreadEventMark {
 230 private:
 231   jmethodID _mid;
 232 
 233 public:
 234   JvmtiMethodEventMark(JavaThread *thread, const methodHandle&amp; method) :
 235     JvmtiThreadEventMark(thread),
 236     _mid(to_jmethodID(method)) {};
 237   jmethodID jni_methodID() { return _mid; }
 238 };
 239 
 240 class JvmtiLocationEventMark : public JvmtiMethodEventMark {
 241 private:
 242   jlocation _loc;
 243 
 244 public:
 245   JvmtiLocationEventMark(JavaThread *thread, const methodHandle&amp; method, address location) :
 246     JvmtiMethodEventMark(thread, method),
 247     _loc(location - method-&gt;code_base()) {};
 248   jlocation location() { return _loc; }
 249 };
 250 
 251 class JvmtiExceptionEventMark : public JvmtiLocationEventMark {
 252 private:
 253   jobject _exc;
 254 
 255 public:
 256   JvmtiExceptionEventMark(JavaThread *thread, const methodHandle&amp; method, address location, Handle exception) :
 257     JvmtiLocationEventMark(thread, method, location),
 258     _exc(to_jobject(exception())) {};
 259   jobject exception() { return _exc; }
 260 };
 261 
 262 class JvmtiClassFileLoadEventMark : public JvmtiThreadEventMark {
 263 private:
 264   const char *_class_name;
 265   jobject _jloader;
 266   jobject _protection_domain;
 267   jclass  _class_being_redefined;
 268 
 269 public:
 270   JvmtiClassFileLoadEventMark(JavaThread *thread, Symbol* name,
 271      Handle class_loader, Handle prot_domain, Klass* class_being_redefined) : JvmtiThreadEventMark(thread) {
 272       _class_name = name != NULL? name-&gt;as_utf8() : NULL;
 273       _jloader = (jobject)to_jobject(class_loader());
 274       _protection_domain = (jobject)to_jobject(prot_domain());
 275       if (class_being_redefined == NULL) {
 276         _class_being_redefined = NULL;
 277       } else {
 278         _class_being_redefined = (jclass)to_jclass(class_being_redefined);
 279       }
 280   };
 281   const char *class_name() {
 282     return _class_name;
 283   }
 284   jobject jloader() {
 285     return _jloader;
 286   }
 287   jobject protection_domain() {
 288     return _protection_domain;
 289   }
 290   jclass class_being_redefined() {
 291     return _class_being_redefined;
 292   }
 293 };
 294 
 295 //////////////////////////////////////////////////////////////////////////////
 296 
 297 int               JvmtiExport::_field_access_count                        = 0;
 298 int               JvmtiExport::_field_modification_count                  = 0;
 299 
 300 bool              JvmtiExport::_can_access_local_variables                = false;
 301 bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
 302 bool              JvmtiExport::_can_modify_any_class                      = false;
 303 bool              JvmtiExport::_can_walk_any_space                        = false;
 304 
<a name="5" id="anc5"></a><span class="line-modified"> 305 bool              JvmtiExport::_has_redefined_a_class                     = false;</span>
 306 bool              JvmtiExport::_all_dependencies_are_recorded             = false;
 307 
 308 //
 309 // field access management
 310 //
 311 
 312 // interpreter generator needs the address of the counter
 313 address JvmtiExport::get_field_access_count_addr() {
 314   // We don&#39;t grab a lock because we don&#39;t want to
 315   // serialize field access between all threads. This means that a
 316   // thread on another processor can see the wrong count value and
 317   // may either miss making a needed call into post_field_access()
 318   // or will make an unneeded call into post_field_access(). We pay
 319   // this price to avoid slowing down the VM when we aren&#39;t watching
 320   // field accesses.
 321   // Other access/mutation safe by virtue of being in VM state.
 322   return (address)(&amp;_field_access_count);
 323 }
 324 
 325 //
 326 // field modification management
 327 //
 328 
 329 // interpreter generator needs the address of the counter
 330 address JvmtiExport::get_field_modification_count_addr() {
 331   // We don&#39;t grab a lock because we don&#39;t
 332   // want to serialize field modification between all threads. This
 333   // means that a thread on another processor can see the wrong
 334   // count value and may either miss making a needed call into
 335   // post_field_modification() or will make an unneeded call into
 336   // post_field_modification(). We pay this price to avoid slowing
 337   // down the VM when we aren&#39;t watching field modifications.
 338   // Other access/mutation safe by virtue of being in VM state.
 339   return (address)(&amp;_field_modification_count);
 340 }
 341 
 342 
 343 ///////////////////////////////////////////////////////////////
 344 // Functions needed by java.lang.instrument for starting up javaagent.
 345 ///////////////////////////////////////////////////////////////
 346 
 347 jint
 348 JvmtiExport::get_jvmti_interface(JavaVM *jvm, void **penv, jint version) {
 349   // The JVMTI_VERSION_INTERFACE_JVMTI part of the version number
 350   // has already been validated in JNI GetEnv().
 351   int major, minor, micro;
 352 
 353   // micro version doesn&#39;t matter here (yet?)
 354   decode_version_values(version, &amp;major, &amp;minor, &amp;micro);
 355   switch (major) {
 356     case 1:
 357       switch (minor) {
 358         case 0:  // version 1.0.&lt;micro&gt; is recognized
 359         case 1:  // version 1.1.&lt;micro&gt; is recognized
 360         case 2:  // version 1.2.&lt;micro&gt; is recognized
 361           break;
 362 
 363         default:
 364           return JNI_EVERSION;  // unsupported minor version number
 365       }
 366       break;
 367     case 9:
 368       switch (minor) {
 369         case 0:  // version 9.0.&lt;micro&gt; is recognized
 370           break;
 371         default:
 372           return JNI_EVERSION;  // unsupported minor version number
 373       }
 374       break;
 375     case 11:
 376       switch (minor) {
 377         case 0:  // version 11.0.&lt;micro&gt; is recognized
 378           break;
 379         default:
 380           return JNI_EVERSION;  // unsupported minor version number
 381       }
 382       break;
 383     default:
<a name="6" id="anc6"></a><span class="line-modified"> 384       return JNI_EVERSION;  // unsupported major version number</span>



 385   }
 386 
 387   if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
 388     JavaThread* current_thread = JavaThread::current();
 389     // transition code: native to VM
 390     ThreadInVMfromNative __tiv(current_thread);
 391     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
 392     debug_only(VMNativeEntryWrapper __vew;)
 393 
 394     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 395     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 396     return JNI_OK;
 397 
 398   } else if (JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
 399     // not live, no thread to transition
 400     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 401     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 402     return JNI_OK;
 403 
 404   } else {
 405     // Called at the wrong time
 406     *penv = NULL;
 407     return JNI_EDETACHED;
 408   }
 409 }
 410 
 411 void
 412 JvmtiExport::add_default_read_edges(Handle h_module, TRAPS) {
 413   if (!Universe::is_module_initialized()) {
 414     return; // extra safety
 415   }
 416   assert(!h_module.is_null(), &quot;module should always be set&quot;);
 417 
 418   // Invoke the transformedByAgent method
 419   JavaValue result(T_VOID);
 420   JavaCalls::call_static(&amp;result,
 421                          SystemDictionary::module_Modules_klass(),
 422                          vmSymbols::transformedByAgent_name(),
 423                          vmSymbols::transformedByAgent_signature(),
 424                          h_module,
 425                          THREAD);
 426 
 427   if (HAS_PENDING_EXCEPTION) {
 428     LogTarget(Trace, jvmti) log;
 429     LogStream log_stream(log);
 430     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 431     log_stream.cr();
 432     CLEAR_PENDING_EXCEPTION;
 433     return;
 434   }
 435 }
 436 
 437 jvmtiError
 438 JvmtiExport::add_module_reads(Handle module, Handle to_module, TRAPS) {
 439   if (!Universe::is_module_initialized()) {
 440     return JVMTI_ERROR_NONE; // extra safety
 441   }
 442   assert(!module.is_null(), &quot;module should always be set&quot;);
 443   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 444 
 445   // Invoke the addReads method
 446   JavaValue result(T_VOID);
 447   JavaCalls::call_static(&amp;result,
 448                          SystemDictionary::module_Modules_klass(),
 449                          vmSymbols::addReads_name(),
 450                          vmSymbols::addReads_signature(),
 451                          module,
 452                          to_module,
 453                          THREAD);
 454 
 455   if (HAS_PENDING_EXCEPTION) {
 456     LogTarget(Trace, jvmti) log;
 457     LogStream log_stream(log);
 458     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 459     log_stream.cr();
 460     CLEAR_PENDING_EXCEPTION;
 461     return JVMTI_ERROR_INTERNAL;
 462   }
 463   return JVMTI_ERROR_NONE;
 464 }
 465 
 466 jvmtiError
 467 JvmtiExport::add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS) {
 468   if (!Universe::is_module_initialized()) {
 469     return JVMTI_ERROR_NONE; // extra safety
 470   }
 471   assert(!module.is_null(), &quot;module should always be set&quot;);
 472   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 473   assert(!pkg_name.is_null(), &quot;pkg_name should always be set&quot;);
 474 
 475   // Invoke the addExports method
 476   JavaValue result(T_VOID);
 477   JavaCalls::call_static(&amp;result,
 478                          SystemDictionary::module_Modules_klass(),
 479                          vmSymbols::addExports_name(),
 480                          vmSymbols::addExports_signature(),
 481                          module,
 482                          pkg_name,
 483                          to_module,
 484                          THREAD);
 485 
 486   if (HAS_PENDING_EXCEPTION) {
 487     Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 488     LogTarget(Trace, jvmti) log;
 489     LogStream log_stream(log);
 490     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 491     log_stream.cr();
 492     CLEAR_PENDING_EXCEPTION;
 493     if (ex_name == vmSymbols::java_lang_IllegalArgumentException()) {
 494       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 495     }
 496     return JVMTI_ERROR_INTERNAL;
 497   }
 498   return JVMTI_ERROR_NONE;
 499 }
 500 
 501 jvmtiError
 502 JvmtiExport::add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS) {
 503   if (!Universe::is_module_initialized()) {
 504     return JVMTI_ERROR_NONE; // extra safety
 505   }
 506   assert(!module.is_null(), &quot;module should always be set&quot;);
 507   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 508   assert(!pkg_name.is_null(), &quot;pkg_name should always be set&quot;);
 509 
 510   // Invoke the addOpens method
 511   JavaValue result(T_VOID);
 512   JavaCalls::call_static(&amp;result,
 513                          SystemDictionary::module_Modules_klass(),
 514                          vmSymbols::addOpens_name(),
 515                          vmSymbols::addExports_signature(),
 516                          module,
 517                          pkg_name,
 518                          to_module,
 519                          THREAD);
 520 
 521   if (HAS_PENDING_EXCEPTION) {
 522     Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 523     LogTarget(Trace, jvmti) log;
 524     LogStream log_stream(log);
 525     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 526     log_stream.cr();
 527     CLEAR_PENDING_EXCEPTION;
 528     if (ex_name == vmSymbols::java_lang_IllegalArgumentException()) {
 529       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 530     }
 531     return JVMTI_ERROR_INTERNAL;
 532   }
 533   return JVMTI_ERROR_NONE;
 534 }
 535 
 536 jvmtiError
 537 JvmtiExport::add_module_uses(Handle module, Handle service, TRAPS) {
 538   if (!Universe::is_module_initialized()) {
 539     return JVMTI_ERROR_NONE; // extra safety
 540   }
 541   assert(!module.is_null(), &quot;module should always be set&quot;);
 542   assert(!service.is_null(), &quot;service should always be set&quot;);
 543 
 544   // Invoke the addUses method
 545   JavaValue result(T_VOID);
 546   JavaCalls::call_static(&amp;result,
 547                          SystemDictionary::module_Modules_klass(),
 548                          vmSymbols::addUses_name(),
 549                          vmSymbols::addUses_signature(),
 550                          module,
 551                          service,
 552                          THREAD);
 553 
 554   if (HAS_PENDING_EXCEPTION) {
 555     LogTarget(Trace, jvmti) log;
 556     LogStream log_stream(log);
 557     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 558     log_stream.cr();
 559     CLEAR_PENDING_EXCEPTION;
 560     return JVMTI_ERROR_INTERNAL;
 561   }
 562   return JVMTI_ERROR_NONE;
 563 }
 564 
 565 jvmtiError
 566 JvmtiExport::add_module_provides(Handle module, Handle service, Handle impl_class, TRAPS) {
 567   if (!Universe::is_module_initialized()) {
 568     return JVMTI_ERROR_NONE; // extra safety
 569   }
 570   assert(!module.is_null(), &quot;module should always be set&quot;);
 571   assert(!service.is_null(), &quot;service should always be set&quot;);
 572   assert(!impl_class.is_null(), &quot;impl_class should always be set&quot;);
 573 
 574   // Invoke the addProvides method
 575   JavaValue result(T_VOID);
 576   JavaCalls::call_static(&amp;result,
 577                          SystemDictionary::module_Modules_klass(),
 578                          vmSymbols::addProvides_name(),
 579                          vmSymbols::addProvides_signature(),
 580                          module,
 581                          service,
 582                          impl_class,
 583                          THREAD);
 584 
 585   if (HAS_PENDING_EXCEPTION) {
 586     LogTarget(Trace, jvmti) log;
 587     LogStream log_stream(log);
 588     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 589     log_stream.cr();
 590     CLEAR_PENDING_EXCEPTION;
 591     return JVMTI_ERROR_INTERNAL;
 592   }
 593   return JVMTI_ERROR_NONE;
 594 }
 595 
 596 void
 597 JvmtiExport::decode_version_values(jint version, int * major, int * minor,
 598                                    int * micro) {
 599   *major = (version &amp; JVMTI_VERSION_MASK_MAJOR) &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 600   *minor = (version &amp; JVMTI_VERSION_MASK_MINOR) &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 601   *micro = (version &amp; JVMTI_VERSION_MASK_MICRO) &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 602 }
 603 
 604 void JvmtiExport::enter_primordial_phase() {
 605   JvmtiEnvBase::set_phase(JVMTI_PHASE_PRIMORDIAL);
 606 }
 607 
 608 void JvmtiExport::enter_early_start_phase() {
 609   set_early_vmstart_recorded(true);
 610 }
 611 
 612 void JvmtiExport::enter_start_phase() {
 613   JvmtiEnvBase::set_phase(JVMTI_PHASE_START);
 614 }
 615 
 616 void JvmtiExport::enter_onload_phase() {
 617   JvmtiEnvBase::set_phase(JVMTI_PHASE_ONLOAD);
 618 }
 619 
 620 void JvmtiExport::enter_live_phase() {
 621   JvmtiEnvBase::set_phase(JVMTI_PHASE_LIVE);
 622 }
 623 
 624 //
 625 // JVMTI events that the VM posts to the debugger and also startup agent
 626 // and call the agent&#39;s premain() for java.lang.instrument.
 627 //
 628 
 629 void JvmtiExport::post_early_vm_start() {
 630   EVT_TRIG_TRACE(JVMTI_EVENT_VM_START, (&quot;Trg Early VM start event triggered&quot; ));
 631 
 632   // can now enable some events
 633   JvmtiEventController::vm_start();
 634 
 635   JvmtiEnvIterator it;
 636   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 637     // Only early vmstart envs post early VMStart event
 638     if (env-&gt;early_vmstart_env() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_VM_START)) {
 639       EVT_TRACE(JVMTI_EVENT_VM_START, (&quot;Evt Early VM start event sent&quot; ));
 640       JavaThread *thread  = JavaThread::current();
 641       JvmtiThreadEventMark jem(thread);
 642       JvmtiJavaThreadEventTransition jet(thread);
 643       jvmtiEventVMStart callback = env-&gt;callbacks()-&gt;VMStart;
 644       if (callback != NULL) {
 645         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 646       }
 647     }
 648   }
 649 }
 650 
 651 void JvmtiExport::post_vm_start() {
 652   EVT_TRIG_TRACE(JVMTI_EVENT_VM_START, (&quot;Trg VM start event triggered&quot; ));
 653 
 654   // can now enable some events
 655   JvmtiEventController::vm_start();
 656 
 657   JvmtiEnvIterator it;
 658   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 659     // Early vmstart envs do not post normal VMStart event
 660     if (!env-&gt;early_vmstart_env() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_VM_START)) {
 661       EVT_TRACE(JVMTI_EVENT_VM_START, (&quot;Evt VM start event sent&quot; ));
 662 
 663       JavaThread *thread  = JavaThread::current();
 664       JvmtiThreadEventMark jem(thread);
 665       JvmtiJavaThreadEventTransition jet(thread);
 666       jvmtiEventVMStart callback = env-&gt;callbacks()-&gt;VMStart;
 667       if (callback != NULL) {
 668         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 669       }
 670     }
 671   }
 672 }
 673 
 674 
 675 void JvmtiExport::post_vm_initialized() {
 676   EVT_TRIG_TRACE(JVMTI_EVENT_VM_INIT, (&quot;Trg VM init event triggered&quot; ));
 677 
 678   // can now enable events
 679   JvmtiEventController::vm_init();
 680 
 681   JvmtiEnvIterator it;
 682   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 683     if (env-&gt;is_enabled(JVMTI_EVENT_VM_INIT)) {
 684       EVT_TRACE(JVMTI_EVENT_VM_INIT, (&quot;Evt VM init event sent&quot; ));
 685 
 686       JavaThread *thread  = JavaThread::current();
 687       JvmtiThreadEventMark jem(thread);
 688       JvmtiJavaThreadEventTransition jet(thread);
 689       jvmtiEventVMInit callback = env-&gt;callbacks()-&gt;VMInit;
 690       if (callback != NULL) {
 691         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
 692       }
 693     }
 694   }
 695 }
 696 
 697 
 698 void JvmtiExport::post_vm_death() {
 699   EVT_TRIG_TRACE(JVMTI_EVENT_VM_DEATH, (&quot;Trg VM death event triggered&quot; ));
 700 
 701   JvmtiEnvIterator it;
 702   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 703     if (env-&gt;is_enabled(JVMTI_EVENT_VM_DEATH)) {
 704       EVT_TRACE(JVMTI_EVENT_VM_DEATH, (&quot;Evt VM death event sent&quot; ));
 705 
 706       JavaThread *thread  = JavaThread::current();
 707       JvmtiEventMark jem(thread);
 708       JvmtiJavaThreadEventTransition jet(thread);
 709       jvmtiEventVMDeath callback = env-&gt;callbacks()-&gt;VMDeath;
 710       if (callback != NULL) {
 711         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 712       }
 713     }
 714   }
 715 
 716   JvmtiEnvBase::set_phase(JVMTI_PHASE_DEAD);
 717   JvmtiEventController::vm_death();
 718 }
 719 
 720 char**
 721 JvmtiExport::get_all_native_method_prefixes(int* count_ptr) {
 722   // Have to grab JVMTI thread state lock to be sure environment doesn&#39;t
 723   // go away while we iterate them.  No locks during VM bring-up.
 724   if (Threads::number_of_threads() == 0 || SafepointSynchronize::is_at_safepoint()) {
 725     return JvmtiEnvBase::get_all_native_method_prefixes(count_ptr);
 726   } else {
 727     MutexLocker mu(JvmtiThreadState_lock);
 728     return JvmtiEnvBase::get_all_native_method_prefixes(count_ptr);
 729   }
 730 }
 731 
 732 // Convert an external thread reference to a JavaThread found on the
 733 // specified ThreadsList. The ThreadsListHandle in the caller &quot;protects&quot;
 734 // the returned JavaThread *.
 735 //
 736 // If thread_oop_p is not NULL, then the caller wants to use the oop
 737 // after this call so the oop is returned. On success, *jt_pp is set
 738 // to the converted JavaThread * and JVMTI_ERROR_NONE is returned.
 739 // On error, returns various JVMTI_ERROR_* values.
 740 //
 741 jvmtiError
 742 JvmtiExport::cv_external_thread_to_JavaThread(ThreadsList * t_list,
 743                                               jthread thread,
 744                                               JavaThread ** jt_pp,
 745                                               oop * thread_oop_p) {
 746   assert(t_list != NULL, &quot;must have a ThreadsList&quot;);
 747   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 748   // thread_oop_p is optional so no assert()
 749 
 750   oop thread_oop = JNIHandles::resolve_external_guard(thread);
 751   if (thread_oop == NULL) {
 752     // NULL jthread, GC&#39;ed jthread or a bad JNI handle.
 753     return JVMTI_ERROR_INVALID_THREAD;
 754   }
 755   // Looks like an oop at this point.
 756 
 757   if (!thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
 758     // The oop is not a java.lang.Thread.
 759     return JVMTI_ERROR_INVALID_THREAD;
 760   }
 761   // Looks like a java.lang.Thread oop at this point.
 762 
 763   if (thread_oop_p != NULL) {
 764     // Return the oop to the caller; the caller may still want
 765     // the oop even if this function returns an error.
 766     *thread_oop_p = thread_oop;
 767   }
 768 
 769   JavaThread * java_thread = java_lang_Thread::thread(thread_oop);
 770   if (java_thread == NULL) {
 771     // The java.lang.Thread does not contain a JavaThread * so it has
 772     // not yet run or it has died.
 773     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 774   }
 775   // Looks like a live JavaThread at this point.
 776 
 777   // We do not check the EnableThreadSMRExtraValidityChecks option
 778   // for this includes() call because JVM/TI&#39;s spec is tighter.
 779   if (!t_list-&gt;includes(java_thread)) {
 780     // Not on the JavaThreads list so it is not alive.
 781     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 782   }
 783 
 784   // Return a live JavaThread that is &quot;protected&quot; by the
 785   // ThreadsListHandle in the caller.
 786   *jt_pp = java_thread;
 787 
 788   return JVMTI_ERROR_NONE;
 789 }
 790 
 791 // Convert an oop to a JavaThread found on the specified ThreadsList.
 792 // The ThreadsListHandle in the caller &quot;protects&quot; the returned
 793 // JavaThread *.
 794 //
 795 // On success, *jt_pp is set to the converted JavaThread * and
 796 // JVMTI_ERROR_NONE is returned. On error, returns various
 797 // JVMTI_ERROR_* values.
 798 //
 799 jvmtiError
 800 JvmtiExport::cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
 801                                   JavaThread ** jt_pp) {
 802   assert(t_list != NULL, &quot;must have a ThreadsList&quot;);
 803   assert(thread_oop != NULL, &quot;must have an oop&quot;);
 804   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 805 
 806   if (!thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
 807     // The oop is not a java.lang.Thread.
 808     return JVMTI_ERROR_INVALID_THREAD;
 809   }
 810   // Looks like a java.lang.Thread oop at this point.
 811 
 812   JavaThread * java_thread = java_lang_Thread::thread(thread_oop);
 813   if (java_thread == NULL) {
 814     // The java.lang.Thread does not contain a JavaThread * so it has
 815     // not yet run or it has died.
 816     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 817   }
 818   // Looks like a live JavaThread at this point.
 819 
 820   // We do not check the EnableThreadSMRExtraValidityChecks option
 821   // for this includes() call because JVM/TI&#39;s spec is tighter.
 822   if (!t_list-&gt;includes(java_thread)) {
 823     // Not on the JavaThreads list so it is not alive.
 824     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 825   }
 826 
 827   // Return a live JavaThread that is &quot;protected&quot; by the
 828   // ThreadsListHandle in the caller.
 829   *jt_pp = java_thread;
 830 
 831   return JVMTI_ERROR_NONE;
 832 }
 833 
 834 class JvmtiClassFileLoadHookPoster : public StackObj {
 835  private:
 836   Symbol*            _h_name;
 837   Handle               _class_loader;
 838   Handle               _h_protection_domain;
 839   unsigned char **     _data_ptr;
 840   unsigned char **     _end_ptr;
 841   JavaThread *         _thread;
 842   jint                 _curr_len;
 843   unsigned char *      _curr_data;
 844   JvmtiEnv *           _curr_env;
 845   JvmtiCachedClassFileData ** _cached_class_file_ptr;
 846   JvmtiThreadState *   _state;
 847   Klass*               _class_being_redefined;
 848   JvmtiClassLoadKind   _load_kind;
 849   bool                 _has_been_modified;
 850 
 851  public:
 852   inline JvmtiClassFileLoadHookPoster(Symbol* h_name, Handle class_loader,
 853                                       Handle h_protection_domain,
 854                                       unsigned char **data_ptr, unsigned char **end_ptr,
 855                                       JvmtiCachedClassFileData **cache_ptr) {
 856     _h_name = h_name;
 857     _class_loader = class_loader;
 858     _h_protection_domain = h_protection_domain;
 859     _data_ptr = data_ptr;
 860     _end_ptr = end_ptr;
 861     _thread = JavaThread::current();
 862     _curr_len = *end_ptr - *data_ptr;
 863     _curr_data = *data_ptr;
 864     _curr_env = NULL;
 865     _cached_class_file_ptr = cache_ptr;
 866     _has_been_modified = false;
 867 
 868     _state = _thread-&gt;jvmti_thread_state();
 869     if (_state != NULL) {
 870       _class_being_redefined = _state-&gt;get_class_being_redefined();
 871       _load_kind = _state-&gt;get_class_load_kind();
 872       Klass* klass = (_class_being_redefined == NULL) ? NULL : _class_being_redefined;
 873       if (_load_kind != jvmti_class_load_kind_load &amp;&amp; klass != NULL) {
 874         ModuleEntry* module_entry = InstanceKlass::cast(klass)-&gt;module();
 875         assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
 876         if (module_entry-&gt;is_named() &amp;&amp;
 877             module_entry-&gt;module() != NULL &amp;&amp;
 878             !module_entry-&gt;has_default_read_edges()) {
 879           if (!module_entry-&gt;set_has_default_read_edges()) {
 880             // We won a potential race.
 881             // Add read edges to the unnamed modules of the bootstrap and app class loaders
 882             Handle class_module(_thread, module_entry-&gt;module()); // Obtain j.l.r.Module
 883             JvmtiExport::add_default_read_edges(class_module, _thread);
 884           }
 885         }
 886       }
 887       // Clear class_being_redefined flag here. The action
 888       // from agent handler could generate a new class file load
 889       // hook event and if it is not cleared the new event generated
 890       // from regular class file load could have this stale redefined
 891       // class handle info.
 892       _state-&gt;clear_class_being_redefined();
 893     } else {
 894       // redefine and retransform will always set the thread state
 895       _class_being_redefined = NULL;
 896       _load_kind = jvmti_class_load_kind_load;
 897     }
 898   }
 899 
 900   void post() {
 901     post_all_envs();
 902     copy_modified_data();
 903   }
 904 
 905   bool has_been_modified() { return _has_been_modified; }
 906 
 907  private:
 908   void post_all_envs() {
 909     if (_load_kind != jvmti_class_load_kind_retransform) {
 910       // for class load and redefine,
 911       // call the non-retransformable agents
 912       JvmtiEnvIterator it;
 913       for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 914         if (!env-&gt;is_retransformable() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
 915           // non-retransformable agents cannot retransform back,
 916           // so no need to cache the original class file bytes
 917           post_to_env(env, false);
 918         }
 919       }
 920     }
 921     JvmtiEnvIterator it;
 922     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 923       // retransformable agents get all events
 924       if (env-&gt;is_retransformable() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
 925         // retransformable agents need to cache the original class file
 926         // bytes if changes are made via the ClassFileLoadHook
 927         post_to_env(env, true);
 928       }
 929     }
 930   }
 931 
 932   void post_to_env(JvmtiEnv* env, bool caching_needed) {
 933     if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL &amp;&amp; !env-&gt;early_class_hook_env()) {
 934       return;
 935     }
 936     unsigned char *new_data = NULL;
 937     jint new_len = 0;
 938     JvmtiClassFileLoadEventMark jem(_thread, _h_name, _class_loader,
 939                                     _h_protection_domain,
 940                                     _class_being_redefined);
 941     JvmtiJavaThreadEventTransition jet(_thread);
 942     jvmtiEventClassFileLoadHook callback = env-&gt;callbacks()-&gt;ClassFileLoadHook;
 943     if (callback != NULL) {
 944       (*callback)(env-&gt;jvmti_external(), jem.jni_env(),
 945                   jem.class_being_redefined(),
 946                   jem.jloader(), jem.class_name(),
 947                   jem.protection_domain(),
 948                   _curr_len, _curr_data,
 949                   &amp;new_len, &amp;new_data);
 950     }
 951     if (new_data != NULL) {
 952       // this agent has modified class data.
 953       _has_been_modified = true;
 954       if (caching_needed &amp;&amp; *_cached_class_file_ptr == NULL) {
 955         // data has been changed by the new retransformable agent
 956         // and it hasn&#39;t already been cached, cache it
 957         JvmtiCachedClassFileData *p;
 958         p = (JvmtiCachedClassFileData *)os::malloc(
 959           offset_of(JvmtiCachedClassFileData, data) + _curr_len, mtInternal);
 960         if (p == NULL) {
 961           vm_exit_out_of_memory(offset_of(JvmtiCachedClassFileData, data) + _curr_len,
 962             OOM_MALLOC_ERROR,
 963             &quot;unable to allocate cached copy of original class bytes&quot;);
 964         }
 965         p-&gt;length = _curr_len;
 966         memcpy(p-&gt;data, _curr_data, _curr_len);
 967         *_cached_class_file_ptr = p;
 968       }
 969 
 970       if (_curr_data != *_data_ptr) {
 971         // curr_data is previous agent modified class data.
 972         // And this has been changed by the new agent so
 973         // we can delete it now.
 974         _curr_env-&gt;Deallocate(_curr_data);
 975       }
 976 
 977       // Class file data has changed by the current agent.
 978       _curr_data = new_data;
 979       _curr_len = new_len;
 980       // Save the current agent env we need this to deallocate the
 981       // memory allocated by this agent.
 982       _curr_env = env;
 983     }
 984   }
 985 
 986   void copy_modified_data() {
 987     // if one of the agent has modified class file data.
 988     // Copy modified class data to new resources array.
 989     if (_curr_data != *_data_ptr) {
 990       *_data_ptr = NEW_RESOURCE_ARRAY(u1, _curr_len);
 991       memcpy(*_data_ptr, _curr_data, _curr_len);
 992       *_end_ptr = *_data_ptr + _curr_len;
 993       _curr_env-&gt;Deallocate(_curr_data);
 994     }
 995   }
 996 };
 997 
 998 bool JvmtiExport::is_early_phase() {
 999   return JvmtiEnvBase::get_phase() &lt;= JVMTI_PHASE_PRIMORDIAL;
1000 }
1001 
1002 bool JvmtiExport::has_early_class_hook_env() {
1003   JvmtiEnvIterator it;
1004   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1005     if (env-&gt;early_class_hook_env()) {
1006       return true;
1007     }
1008   }
1009   return false;
1010 }
1011 
1012 bool JvmtiExport::_should_post_class_file_load_hook = false;
1013 
1014 // this entry is for class file load hook on class load, redefine and retransform
1015 bool JvmtiExport::post_class_file_load_hook(Symbol* h_name,
1016                                             Handle class_loader,
1017                                             Handle h_protection_domain,
1018                                             unsigned char **data_ptr,
1019                                             unsigned char **end_ptr,
1020                                             JvmtiCachedClassFileData **cache_ptr) {
1021   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1022     return false;
1023   }
1024 
1025   JvmtiClassFileLoadHookPoster poster(h_name, class_loader,
1026                                       h_protection_domain,
1027                                       data_ptr, end_ptr,
1028                                       cache_ptr);
1029   poster.post();
1030   return poster.has_been_modified();
1031 }
1032 
1033 void JvmtiExport::report_unsupported(bool on) {
1034   // If any JVMTI service is turned on, we need to exit before native code
1035   // tries to access nonexistant services.
1036   if (on) {
1037     vm_exit_during_initialization(&quot;Java Kernel does not support JVMTI.&quot;);
1038   }
1039 }
1040 
1041 
1042 static inline Klass* oop_to_klass(oop obj) {
1043   Klass* k = obj-&gt;klass();
1044 
1045   // if the object is a java.lang.Class then return the java mirror
1046   if (k == SystemDictionary::Class_klass()) {
1047     if (!java_lang_Class::is_primitive(obj)) {
1048       k = java_lang_Class::as_Klass(obj);
1049       assert(k != NULL, &quot;class for non-primitive mirror must exist&quot;);
1050     }
1051   }
1052   return k;
1053 }
1054 
1055 class JvmtiObjectAllocEventMark : public JvmtiClassEventMark  {
1056  private:
1057    jobject _jobj;
1058    jlong    _size;
1059  public:
1060    JvmtiObjectAllocEventMark(JavaThread *thread, oop obj) : JvmtiClassEventMark(thread, oop_to_klass(obj)) {
1061      _jobj = (jobject)to_jobject(obj);
1062      _size = Universe::heap()-&gt;obj_size(obj) * wordSize;
1063    };
1064    jobject jni_jobject() { return _jobj; }
1065    jlong size() { return _size; }
1066 };
1067 
1068 class JvmtiCompiledMethodLoadEventMark : public JvmtiMethodEventMark {
1069  private:
1070   jint _code_size;
1071   const void *_code_data;
1072   jint _map_length;
1073   jvmtiAddrLocationMap *_map;
1074   const void *_compile_info;
1075  public:
1076   JvmtiCompiledMethodLoadEventMark(JavaThread *thread, nmethod *nm, void* compile_info_ptr = NULL)
1077           : JvmtiMethodEventMark(thread,methodHandle(thread, nm-&gt;method())) {
1078     _code_data = nm-&gt;insts_begin();
1079     _code_size = nm-&gt;insts_size();
1080     _compile_info = compile_info_ptr; // Set void pointer of compiledMethodLoad Event. Default value is NULL.
1081     JvmtiCodeBlobEvents::build_jvmti_addr_location_map(nm, &amp;_map, &amp;_map_length);
1082   }
1083   ~JvmtiCompiledMethodLoadEventMark() {
1084      FREE_C_HEAP_ARRAY(jvmtiAddrLocationMap, _map);
1085   }
1086 
1087   jint code_size() { return _code_size; }
1088   const void *code_data() { return _code_data; }
1089   jint map_length() { return _map_length; }
1090   const jvmtiAddrLocationMap* map() { return _map; }
1091   const void *compile_info() { return _compile_info; }
1092 };
1093 
1094 
1095 
1096 class JvmtiMonitorEventMark : public JvmtiThreadEventMark {
1097 private:
1098   jobject _jobj;
1099 public:
1100   JvmtiMonitorEventMark(JavaThread *thread, oop object)
1101           : JvmtiThreadEventMark(thread){
1102      _jobj = to_jobject(object);
1103   }
1104   jobject jni_object() { return _jobj; }
1105 };
1106 
1107 ///////////////////////////////////////////////////////////////
1108 //
1109 // pending CompiledMethodUnload support
1110 //
1111 
1112 void JvmtiExport::post_compiled_method_unload(
1113        jmethodID method, const void *code_begin) {
1114   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1115     return;
1116   }
1117   JavaThread* thread = JavaThread::current();
1118   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_UNLOAD,
1119                  (&quot;[%s] method compile unload event triggered&quot;,
1120                   JvmtiTrace::safe_get_thread_name(thread)));
1121 
1122   // post the event for each environment that has this event enabled.
1123   JvmtiEnvIterator it;
1124   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1125     if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_UNLOAD)) {
1126       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1127         continue;
1128       }
1129       EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_UNLOAD,
1130                 (&quot;[%s] class compile method unload event sent jmethodID &quot; PTR_FORMAT,
1131                  JvmtiTrace::safe_get_thread_name(thread), p2i(method)));
1132 
1133       ResourceMark rm(thread);
1134 
1135       JvmtiEventMark jem(thread);
1136       JvmtiJavaThreadEventTransition jet(thread);
1137       jvmtiEventCompiledMethodUnload callback = env-&gt;callbacks()-&gt;CompiledMethodUnload;
1138       if (callback != NULL) {
1139         (*callback)(env-&gt;jvmti_external(), method, code_begin);
1140       }
1141     }
1142   }
1143 }
1144 
1145 ///////////////////////////////////////////////////////////////
1146 //
1147 // JvmtiExport
1148 //
1149 
1150 void JvmtiExport::post_raw_breakpoint(JavaThread *thread, Method* method, address location) {
1151   HandleMark hm(thread);
1152   methodHandle mh(thread, method);
1153 
1154   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1155   if (state == NULL) {
1156     return;
1157   }
1158   EVT_TRIG_TRACE(JVMTI_EVENT_BREAKPOINT, (&quot;[%s] Trg Breakpoint triggered&quot;,
1159                       JvmtiTrace::safe_get_thread_name(thread)));
1160   JvmtiEnvThreadStateIterator it(state);
1161   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1162     ets-&gt;compare_and_set_current_location(mh(), location, JVMTI_EVENT_BREAKPOINT);
1163     if (!ets-&gt;breakpoint_posted() &amp;&amp; ets-&gt;is_enabled(JVMTI_EVENT_BREAKPOINT)) {
1164       ThreadState old_os_state = thread-&gt;osthread()-&gt;get_state();
1165       thread-&gt;osthread()-&gt;set_state(BREAKPOINTED);
1166       EVT_TRACE(JVMTI_EVENT_BREAKPOINT, (&quot;[%s] Evt Breakpoint sent %s.%s @ &quot; INTX_FORMAT,
1167                      JvmtiTrace::safe_get_thread_name(thread),
1168                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1169                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1170                      location - mh()-&gt;code_base() ));
1171 
1172       JvmtiEnv *env = ets-&gt;get_env();
1173       JvmtiLocationEventMark jem(thread, mh, location);
1174       JvmtiJavaThreadEventTransition jet(thread);
1175       jvmtiEventBreakpoint callback = env-&gt;callbacks()-&gt;Breakpoint;
1176       if (callback != NULL) {
1177         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1178                     jem.jni_methodID(), jem.location());
1179       }
1180 
1181       ets-&gt;set_breakpoint_posted();
1182       thread-&gt;osthread()-&gt;set_state(old_os_state);
1183     }
1184   }
1185 }
1186 
1187 //////////////////////////////////////////////////////////////////////////////
1188 
1189 bool              JvmtiExport::_can_get_source_debug_extension            = false;
1190 bool              JvmtiExport::_can_maintain_original_method_order        = false;
1191 bool              JvmtiExport::_can_post_interpreter_events               = false;
1192 bool              JvmtiExport::_can_post_on_exceptions                    = false;
1193 bool              JvmtiExport::_can_post_breakpoint                       = false;
1194 bool              JvmtiExport::_can_post_field_access                     = false;
1195 bool              JvmtiExport::_can_post_field_modification               = false;
1196 bool              JvmtiExport::_can_post_method_entry                     = false;
1197 bool              JvmtiExport::_can_post_method_exit                      = false;
1198 bool              JvmtiExport::_can_pop_frame                             = false;
1199 bool              JvmtiExport::_can_force_early_return                    = false;
<a name="7" id="anc7"></a>
1200 
1201 bool              JvmtiExport::_early_vmstart_recorded                    = false;
1202 
1203 bool              JvmtiExport::_should_post_single_step                   = false;
1204 bool              JvmtiExport::_should_post_field_access                  = false;
1205 bool              JvmtiExport::_should_post_field_modification            = false;
1206 bool              JvmtiExport::_should_post_class_load                    = false;
1207 bool              JvmtiExport::_should_post_class_prepare                 = false;
1208 bool              JvmtiExport::_should_post_class_unload                  = false;
1209 bool              JvmtiExport::_should_post_thread_life                   = false;
1210 bool              JvmtiExport::_should_clean_up_heap_objects              = false;
1211 bool              JvmtiExport::_should_post_native_method_bind            = false;
1212 bool              JvmtiExport::_should_post_dynamic_code_generated        = false;
1213 bool              JvmtiExport::_should_post_data_dump                     = false;
1214 bool              JvmtiExport::_should_post_compiled_method_load          = false;
1215 bool              JvmtiExport::_should_post_compiled_method_unload        = false;
1216 bool              JvmtiExport::_should_post_monitor_contended_enter       = false;
1217 bool              JvmtiExport::_should_post_monitor_contended_entered     = false;
1218 bool              JvmtiExport::_should_post_monitor_wait                  = false;
1219 bool              JvmtiExport::_should_post_monitor_waited                = false;
1220 bool              JvmtiExport::_should_post_garbage_collection_start      = false;
1221 bool              JvmtiExport::_should_post_garbage_collection_finish     = false;
1222 bool              JvmtiExport::_should_post_object_free                   = false;
1223 bool              JvmtiExport::_should_post_resource_exhausted            = false;
1224 bool              JvmtiExport::_should_post_vm_object_alloc               = false;
1225 bool              JvmtiExport::_should_post_sampled_object_alloc          = false;
1226 bool              JvmtiExport::_should_post_on_exceptions                 = false;
1227 
1228 ////////////////////////////////////////////////////////////////////////////////////////////////
1229 
1230 
1231 //
1232 // JVMTI single step management
1233 //
1234 void JvmtiExport::at_single_stepping_point(JavaThread *thread, Method* method, address location) {
1235   assert(JvmtiExport::should_post_single_step(), &quot;must be single stepping&quot;);
1236 
1237   HandleMark hm(thread);
1238   methodHandle mh(thread, method);
1239 
1240   // update information about current location and post a step event
1241   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1242   if (state == NULL) {
1243     return;
1244   }
1245   EVT_TRIG_TRACE(JVMTI_EVENT_SINGLE_STEP, (&quot;[%s] Trg Single Step triggered&quot;,
1246                       JvmtiTrace::safe_get_thread_name(thread)));
1247   if (!state-&gt;hide_single_stepping()) {
1248     if (state-&gt;is_pending_step_for_popframe()) {
1249       state-&gt;process_pending_step_for_popframe();
1250     }
1251     if (state-&gt;is_pending_step_for_earlyret()) {
1252       state-&gt;process_pending_step_for_earlyret();
1253     }
1254     JvmtiExport::post_single_step(thread, mh(), location);
1255   }
1256 }
1257 
1258 
1259 void JvmtiExport::expose_single_stepping(JavaThread *thread) {
1260   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1261   if (state != NULL) {
1262     state-&gt;clear_hide_single_stepping();
1263   }
1264 }
1265 
1266 
1267 bool JvmtiExport::hide_single_stepping(JavaThread *thread) {
1268   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1269   if (state != NULL &amp;&amp; state-&gt;is_enabled(JVMTI_EVENT_SINGLE_STEP)) {
1270     state-&gt;set_hide_single_stepping();
1271     return true;
1272   } else {
1273     return false;
1274   }
1275 }
1276 
1277 void JvmtiExport::post_class_load(JavaThread *thread, Klass* klass) {
1278   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1279     return;
1280   }
1281   HandleMark hm(thread);
1282 
1283   EVT_TRIG_TRACE(JVMTI_EVENT_CLASS_LOAD, (&quot;[%s] Trg Class Load triggered&quot;,
1284                       JvmtiTrace::safe_get_thread_name(thread)));
1285   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1286   if (state == NULL) {
1287     return;
1288   }
1289   JvmtiEnvThreadStateIterator it(state);
1290   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1291     if (ets-&gt;is_enabled(JVMTI_EVENT_CLASS_LOAD)) {
1292       JvmtiEnv *env = ets-&gt;get_env();
1293       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1294         continue;
1295       }
1296       EVT_TRACE(JVMTI_EVENT_CLASS_LOAD, (&quot;[%s] Evt Class Load sent %s&quot;,
1297                                          JvmtiTrace::safe_get_thread_name(thread),
1298                                          klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1299       JvmtiClassEventMark jem(thread, klass);
1300       JvmtiJavaThreadEventTransition jet(thread);
1301       jvmtiEventClassLoad callback = env-&gt;callbacks()-&gt;ClassLoad;
1302       if (callback != NULL) {
1303         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1304       }
1305     }
1306   }
1307 }
1308 
1309 
1310 void JvmtiExport::post_class_prepare(JavaThread *thread, Klass* klass) {
1311   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1312     return;
1313   }
1314   HandleMark hm(thread);
1315 
1316   EVT_TRIG_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Trg Class Prepare triggered&quot;,
1317                       JvmtiTrace::safe_get_thread_name(thread)));
1318   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1319   if (state == NULL) {
1320     return;
1321   }
1322   JvmtiEnvThreadStateIterator it(state);
1323   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1324     if (ets-&gt;is_enabled(JVMTI_EVENT_CLASS_PREPARE)) {
1325       JvmtiEnv *env = ets-&gt;get_env();
1326       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1327         continue;
1328       }
1329       EVT_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Evt Class Prepare sent %s&quot;,
1330                                             JvmtiTrace::safe_get_thread_name(thread),
1331                                             klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1332       JvmtiClassEventMark jem(thread, klass);
1333       JvmtiJavaThreadEventTransition jet(thread);
1334       jvmtiEventClassPrepare callback = env-&gt;callbacks()-&gt;ClassPrepare;
1335       if (callback != NULL) {
1336         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1337       }
1338     }
1339   }
1340 }
1341 
1342 void JvmtiExport::post_class_unload(Klass* klass) {
1343   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1344     return;
1345   }
<a name="8" id="anc8"></a><span class="line-modified">1346   Thread *thread = Thread::current();</span>















1347   HandleMark hm(thread);
1348 
1349   EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
1350   if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<a name="9" id="anc9"></a><span class="line-removed">1351     assert(thread-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
<span class="line-removed">1352 </span>
<span class="line-removed">1353     // get JavaThread for whom we are proxy</span>
<span class="line-removed">1354     Thread *calling_thread = ((VMThread *)thread)-&gt;vm_operation()-&gt;calling_thread();</span>
<span class="line-removed">1355     if (!calling_thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">1356       // cannot post an event to a non-JavaThread</span>
<span class="line-removed">1357       return;</span>
<span class="line-removed">1358     }</span>
<span class="line-removed">1359     JavaThread *real_thread = (JavaThread *)calling_thread;</span>
1360 
1361     JvmtiEnvIterator it;
1362     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1363       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1364         continue;
1365       }
1366       if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<a name="10" id="anc10"></a><span class="line-modified">1367         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;,</span>
<span class="line-removed">1368                   klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370         // do everything manually, since this is a proxy - needs special care</span>
<span class="line-removed">1371         JNIEnv* jni_env = real_thread-&gt;jni_environment();</span>
<span class="line-removed">1372         jthread jt = (jthread)JNIHandles::make_local(real_thread, real_thread-&gt;threadObj());</span>
<span class="line-removed">1373         jclass jk = (jclass)JNIHandles::make_local(real_thread, klass-&gt;java_mirror());</span>
<span class="line-removed">1374 </span>
<span class="line-removed">1375         // Before we call the JVMTI agent, we have to set the state in the</span>
<span class="line-removed">1376         // thread for which we are proxying.</span>
<span class="line-removed">1377         JavaThreadState prev_state = real_thread-&gt;thread_state();</span>
<span class="line-removed">1378         assert(((Thread *)real_thread)-&gt;is_ConcurrentGC_thread() ||</span>
<span class="line-removed">1379                (real_thread-&gt;is_Java_thread() &amp;&amp; prev_state == _thread_blocked),</span>
<span class="line-removed">1380                &quot;should be ConcurrentGCThread or JavaThread at safepoint&quot;);</span>
<span class="line-removed">1381         real_thread-&gt;set_thread_state(_thread_in_native);</span>
1382 
<a name="11" id="anc11"></a>

1383         jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
1384         if (callback != NULL) {
<a name="12" id="anc12"></a><span class="line-modified">1385           (*callback)(env-&gt;jvmti_external(), jni_env, jt, jk);</span>
1386         }
<a name="13" id="anc13"></a><span class="line-removed">1387 </span>
<span class="line-removed">1388         assert(real_thread-&gt;thread_state() == _thread_in_native,</span>
<span class="line-removed">1389                &quot;JavaThread should be in native&quot;);</span>
<span class="line-removed">1390         real_thread-&gt;set_thread_state(prev_state);</span>
<span class="line-removed">1391 </span>
<span class="line-removed">1392         JNIHandles::destroy_local(jk);</span>
<span class="line-removed">1393         JNIHandles::destroy_local(jt);</span>
1394       }
1395     }
1396   }
1397 }
1398 
1399 
1400 void JvmtiExport::post_thread_start(JavaThread *thread) {
1401   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1402     return;
1403   }
1404   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
1405 
1406   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Trg Thread Start event triggered&quot;,
1407                       JvmtiTrace::safe_get_thread_name(thread)));
1408 
1409   // do JVMTI thread initialization (if needed)
1410   JvmtiEventController::thread_started(thread);
1411 
1412   // Do not post thread start event for hidden java thread.
1413   if (JvmtiEventController::is_enabled(JVMTI_EVENT_THREAD_START) &amp;&amp;
1414       !thread-&gt;is_hidden_from_external_view()) {
1415     JvmtiEnvIterator it;
1416     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1417       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1418         continue;
1419       }
1420       if (env-&gt;is_enabled(JVMTI_EVENT_THREAD_START)) {
1421         EVT_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Evt Thread Start event sent&quot;,
1422                      JvmtiTrace::safe_get_thread_name(thread) ));
1423 
1424         JvmtiThreadEventMark jem(thread);
1425         JvmtiJavaThreadEventTransition jet(thread);
1426         jvmtiEventThreadStart callback = env-&gt;callbacks()-&gt;ThreadStart;
1427         if (callback != NULL) {
1428           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
1429         }
1430       }
1431     }
1432   }
1433 }
1434 
1435 
1436 void JvmtiExport::post_thread_end(JavaThread *thread) {
1437   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1438     return;
1439   }
1440   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_END, (&quot;[%s] Trg Thread End event triggered&quot;,
1441                       JvmtiTrace::safe_get_thread_name(thread)));
1442 
1443   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1444   if (state == NULL) {
1445     return;
1446   }
1447 
1448   // Do not post thread end event for hidden java thread.
1449   if (state-&gt;is_enabled(JVMTI_EVENT_THREAD_END) &amp;&amp;
1450       !thread-&gt;is_hidden_from_external_view()) {
1451 
1452     JvmtiEnvThreadStateIterator it(state);
1453     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1454       if (ets-&gt;is_enabled(JVMTI_EVENT_THREAD_END)) {
1455         JvmtiEnv *env = ets-&gt;get_env();
1456         if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1457           continue;
1458         }
1459         EVT_TRACE(JVMTI_EVENT_THREAD_END, (&quot;[%s] Evt Thread End event sent&quot;,
1460                      JvmtiTrace::safe_get_thread_name(thread) ));
1461 
1462         JvmtiThreadEventMark jem(thread);
1463         JvmtiJavaThreadEventTransition jet(thread);
1464         jvmtiEventThreadEnd callback = env-&gt;callbacks()-&gt;ThreadEnd;
1465         if (callback != NULL) {
1466           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
1467         }
1468       }
1469     }
1470   }
1471 }
1472 
1473 void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {
1474   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at safepoint&quot;);
1475   assert(env-&gt;is_enabled(JVMTI_EVENT_OBJECT_FREE), &quot;checking&quot;);
1476 
1477   EVT_TRIG_TRACE(JVMTI_EVENT_OBJECT_FREE, (&quot;[?] Trg Object Free triggered&quot; ));
1478   EVT_TRACE(JVMTI_EVENT_OBJECT_FREE, (&quot;[?] Evt Object Free sent&quot;));
1479 
1480   jvmtiEventObjectFree callback = env-&gt;callbacks()-&gt;ObjectFree;
1481   if (callback != NULL) {
1482     (*callback)(env-&gt;jvmti_external(), tag);
1483   }
1484 }
1485 
1486 void JvmtiExport::post_resource_exhausted(jint resource_exhausted_flags, const char* description) {
1487 
1488   JavaThread *thread  = JavaThread::current();
1489 
1490   // JDK-8213834: handlers of ResourceExhausted may attempt some analysis
1491   // which often requires running java.
1492   // This will cause problems on threads not able to run java, e.g. compiler
1493   // threads. To forestall these problems, we therefore suppress sending this
1494   // event from threads which are not able to run java.
1495   if (!thread-&gt;can_call_java()) {
1496     return;
1497   }
1498 
1499   EVT_TRIG_TRACE(JVMTI_EVENT_RESOURCE_EXHAUSTED, (&quot;Trg resource exhausted event triggered&quot; ));
1500 
1501   JvmtiEnvIterator it;
1502   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1503     if (env-&gt;is_enabled(JVMTI_EVENT_RESOURCE_EXHAUSTED)) {
1504       EVT_TRACE(JVMTI_EVENT_RESOURCE_EXHAUSTED, (&quot;Evt resource exhausted event sent&quot; ));
1505 
1506       JvmtiThreadEventMark jem(thread);
1507       JvmtiJavaThreadEventTransition jet(thread);
1508       jvmtiEventResourceExhausted callback = env-&gt;callbacks()-&gt;ResourceExhausted;
1509       if (callback != NULL) {
1510         (*callback)(env-&gt;jvmti_external(), jem.jni_env(),
1511                     resource_exhausted_flags, NULL, description);
1512       }
1513     }
1514   }
1515 }
1516 
1517 void JvmtiExport::post_method_entry(JavaThread *thread, Method* method, frame current_frame) {
1518   HandleMark hm(thread);
1519   methodHandle mh(thread, method);
1520 
1521   EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_ENTRY, (&quot;[%s] Trg Method Entry triggered %s.%s&quot;,
1522                      JvmtiTrace::safe_get_thread_name(thread),
1523                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1524                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1525 
1526   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1527   if (state == NULL || !state-&gt;is_interp_only_mode()) {
1528     // for any thread that actually wants method entry, interp_only_mode is set
1529     return;
1530   }
1531 
1532   state-&gt;incr_cur_stack_depth();
1533 
1534   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_ENTRY)) {
1535     JvmtiEnvThreadStateIterator it(state);
1536     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1537       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_ENTRY)) {
1538         EVT_TRACE(JVMTI_EVENT_METHOD_ENTRY, (&quot;[%s] Evt Method Entry sent %s.%s&quot;,
1539                                              JvmtiTrace::safe_get_thread_name(thread),
1540                                              (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1541                                              (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1542 
1543         JvmtiEnv *env = ets-&gt;get_env();
1544         JvmtiMethodEventMark jem(thread, mh);
1545         JvmtiJavaThreadEventTransition jet(thread);
1546         jvmtiEventMethodEntry callback = env-&gt;callbacks()-&gt;MethodEntry;
1547         if (callback != NULL) {
1548           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_methodID());
1549         }
1550       }
1551     }
1552   }
1553 }
1554 
1555 void JvmtiExport::post_method_exit(JavaThread *thread, Method* method, frame current_frame) {
1556   HandleMark hm(thread);
1557   methodHandle mh(thread, method);
1558 
1559   EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Trg Method Exit triggered %s.%s&quot;,
1560                      JvmtiTrace::safe_get_thread_name(thread),
1561                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1562                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1563 
1564   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1565   if (state == NULL || !state-&gt;is_interp_only_mode()) {
1566     // for any thread that actually wants method exit, interp_only_mode is set
1567     return;
1568   }
1569 
1570   // return a flag when a method terminates by throwing an exception
1571   // i.e. if an exception is thrown and it&#39;s not caught by the current method
1572   bool exception_exit = state-&gt;is_exception_detected() &amp;&amp; !state-&gt;is_exception_caught();
1573 
1574 
1575   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1576     Handle result;
1577     jvalue value;
1578     value.j = 0L;
1579 
1580     // if the method hasn&#39;t been popped because of an exception then we populate
1581     // the return_value parameter for the callback. At this point we only have
1582     // the address of a &quot;raw result&quot; and we just call into the interpreter to
1583     // convert this into a jvalue.
1584     if (!exception_exit) {
1585       oop oop_result;
1586       BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
<a name="14" id="anc14"></a><span class="line-modified">1587       if (type == T_OBJECT || type == T_ARRAY) {</span>
1588         result = Handle(thread, oop_result);
1589       }
1590     }
1591 
1592     JvmtiEnvThreadStateIterator it(state);
1593     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1594       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1595         EVT_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Evt Method Exit sent %s.%s&quot;,
1596                                             JvmtiTrace::safe_get_thread_name(thread),
1597                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1598                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1599 
1600         JvmtiEnv *env = ets-&gt;get_env();
1601         JvmtiMethodEventMark jem(thread, mh);
1602         if (result.not_null()) {
1603           value.l = JNIHandles::make_local(thread, result());
1604         }
1605         JvmtiJavaThreadEventTransition jet(thread);
1606         jvmtiEventMethodExit callback = env-&gt;callbacks()-&gt;MethodExit;
1607         if (callback != NULL) {
1608           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1609                       jem.jni_methodID(), exception_exit,  value);
1610         }
1611       }
1612     }
1613   }
1614 
1615   JvmtiEnvThreadStateIterator it(state);
1616   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1617     if (ets-&gt;has_frame_pops()) {
1618       int cur_frame_number = state-&gt;cur_stack_depth();
1619 
1620       if (ets-&gt;is_frame_pop(cur_frame_number)) {
1621         // we have a NotifyFramePop entry for this frame.
1622         // now check that this env/thread wants this event
1623         if (ets-&gt;is_enabled(JVMTI_EVENT_FRAME_POP)) {
1624           EVT_TRACE(JVMTI_EVENT_FRAME_POP, (&quot;[%s] Evt Frame Pop sent %s.%s&quot;,
1625                                             JvmtiTrace::safe_get_thread_name(thread),
1626                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1627                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1628 
1629           // we also need to issue a frame pop event for this frame
1630           JvmtiEnv *env = ets-&gt;get_env();
1631           JvmtiMethodEventMark jem(thread, mh);
1632           JvmtiJavaThreadEventTransition jet(thread);
1633           jvmtiEventFramePop callback = env-&gt;callbacks()-&gt;FramePop;
1634           if (callback != NULL) {
1635             (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1636                         jem.jni_methodID(), exception_exit);
1637           }
1638         }
1639         // remove the frame&#39;s entry
1640         ets-&gt;clear_frame_pop(cur_frame_number);
1641       }
1642     }
1643   }
1644 
1645   state-&gt;decr_cur_stack_depth();
1646 }
1647 
1648 
1649 // Todo: inline this for optimization
1650 void JvmtiExport::post_single_step(JavaThread *thread, Method* method, address location) {
1651   HandleMark hm(thread);
1652   methodHandle mh(thread, method);
1653 
1654   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1655   if (state == NULL) {
1656     return;
1657   }
1658   JvmtiEnvThreadStateIterator it(state);
1659   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1660     ets-&gt;compare_and_set_current_location(mh(), location, JVMTI_EVENT_SINGLE_STEP);
1661     if (!ets-&gt;single_stepping_posted() &amp;&amp; ets-&gt;is_enabled(JVMTI_EVENT_SINGLE_STEP)) {
1662       EVT_TRACE(JVMTI_EVENT_SINGLE_STEP, (&quot;[%s] Evt Single Step sent %s.%s @ &quot; INTX_FORMAT,
1663                     JvmtiTrace::safe_get_thread_name(thread),
1664                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1665                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1666                     location - mh()-&gt;code_base() ));
1667 
1668       JvmtiEnv *env = ets-&gt;get_env();
1669       JvmtiLocationEventMark jem(thread, mh, location);
1670       JvmtiJavaThreadEventTransition jet(thread);
1671       jvmtiEventSingleStep callback = env-&gt;callbacks()-&gt;SingleStep;
1672       if (callback != NULL) {
1673         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1674                     jem.jni_methodID(), jem.location());
1675       }
1676 
1677       ets-&gt;set_single_stepping_posted();
1678     }
1679   }
1680 }
1681 
1682 void JvmtiExport::post_exception_throw(JavaThread *thread, Method* method, address location, oop exception) {
1683   HandleMark hm(thread);
1684   methodHandle mh(thread, method);
1685   Handle exception_handle(thread, exception);
1686 
1687   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1688   if (state == NULL) {
1689     return;
1690   }
1691 
1692   EVT_TRIG_TRACE(JVMTI_EVENT_EXCEPTION, (&quot;[%s] Trg Exception thrown triggered&quot;,
1693                       JvmtiTrace::safe_get_thread_name(thread)));
1694   if (!state-&gt;is_exception_detected()) {
1695     state-&gt;set_exception_detected();
1696     JvmtiEnvThreadStateIterator it(state);
1697     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1698       if (ets-&gt;is_enabled(JVMTI_EVENT_EXCEPTION) &amp;&amp; (exception != NULL)) {
1699 
1700         EVT_TRACE(JVMTI_EVENT_EXCEPTION,
1701                      (&quot;[%s] Evt Exception thrown sent %s.%s @ &quot; INTX_FORMAT,
1702                       JvmtiTrace::safe_get_thread_name(thread),
1703                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1704                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1705                       location - mh()-&gt;code_base() ));
1706 
1707         JvmtiEnv *env = ets-&gt;get_env();
1708         JvmtiExceptionEventMark jem(thread, mh, location, exception_handle);
1709 
1710         // It&#39;s okay to clear these exceptions here because we duplicate
1711         // this lookup in InterpreterRuntime::exception_handler_for_exception.
1712         EXCEPTION_MARK;
1713 
1714         bool should_repeat;
1715         vframeStream st(thread);
1716         assert(!st.at_end(), &quot;cannot be at end&quot;);
1717         Method* current_method = NULL;
1718         // A GC may occur during the Method::fast_exception_handler_bci_for()
1719         // call below if it needs to load the constraint class. Using a
1720         // methodHandle to keep the &#39;current_method&#39; from being deallocated
1721         // if GC happens.
1722         methodHandle current_mh = methodHandle(thread, current_method);
1723         int current_bci = -1;
1724         do {
1725           current_method = st.method();
1726           current_mh = methodHandle(thread, current_method);
1727           current_bci = st.bci();
1728           do {
1729             should_repeat = false;
1730             Klass* eh_klass = exception_handle()-&gt;klass();
1731             current_bci = Method::fast_exception_handler_bci_for(
1732               current_mh, eh_klass, current_bci, THREAD);
1733             if (HAS_PENDING_EXCEPTION) {
1734               exception_handle = Handle(thread, PENDING_EXCEPTION);
1735               CLEAR_PENDING_EXCEPTION;
1736               should_repeat = true;
1737             }
1738           } while (should_repeat &amp;&amp; (current_bci != -1));
1739           st.next();
1740         } while ((current_bci &lt; 0) &amp;&amp; (!st.at_end()));
1741 
1742         jmethodID catch_jmethodID;
1743         if (current_bci &lt; 0) {
1744           catch_jmethodID = 0;
1745           current_bci = 0;
1746         } else {
1747           catch_jmethodID = jem.to_jmethodID(current_mh);
1748         }
1749 
1750         JvmtiJavaThreadEventTransition jet(thread);
1751         jvmtiEventException callback = env-&gt;callbacks()-&gt;Exception;
1752         if (callback != NULL) {
1753           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1754                       jem.jni_methodID(), jem.location(),
1755                       jem.exception(),
1756                       catch_jmethodID, current_bci);
1757         }
1758       }
1759     }
1760   }
1761 
1762   // frames may get popped because of this throw, be safe - invalidate cached depth
1763   state-&gt;invalidate_cur_stack_depth();
1764 }
1765 
1766 
1767 void JvmtiExport::notice_unwind_due_to_exception(JavaThread *thread, Method* method, address location, oop exception, bool in_handler_frame) {
1768   HandleMark hm(thread);
1769   methodHandle mh(thread, method);
1770   Handle exception_handle(thread, exception);
1771 
1772   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1773   if (state == NULL) {
1774     return;
1775   }
1776   EVT_TRIG_TRACE(JVMTI_EVENT_EXCEPTION_CATCH,
1777                     (&quot;[%s] Trg unwind_due_to_exception triggered %s.%s @ %s&quot; INTX_FORMAT &quot; - %s&quot;,
1778                      JvmtiTrace::safe_get_thread_name(thread),
1779                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1780                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1781                      location==0? &quot;no location:&quot; : &quot;&quot;,
1782                      location==0? 0 : location - mh()-&gt;code_base(),
1783                      in_handler_frame? &quot;in handler frame&quot; : &quot;not handler frame&quot; ));
1784 
1785   if (state-&gt;is_exception_detected()) {
1786 
1787     state-&gt;invalidate_cur_stack_depth();
1788     if (!in_handler_frame) {
1789       // Not in exception handler.
1790       if(state-&gt;is_interp_only_mode()) {
1791         // method exit and frame pop events are posted only in interp mode.
1792         // When these events are enabled code should be in running in interp mode.
1793         JvmtiExport::post_method_exit(thread, method, thread-&gt;last_frame());
1794         // The cached cur_stack_depth might have changed from the
1795         // operations of frame pop or method exit. We are not 100% sure
1796         // the cached cur_stack_depth is still valid depth so invalidate
1797         // it.
1798         state-&gt;invalidate_cur_stack_depth();
1799       }
1800     } else {
1801       // In exception handler frame. Report exception catch.
1802       assert(location != NULL, &quot;must be a known location&quot;);
1803       // Update cur_stack_depth - the frames above the current frame
1804       // have been unwound due to this exception:
1805       assert(!state-&gt;is_exception_caught(), &quot;exception must not be caught yet.&quot;);
1806       state-&gt;set_exception_caught();
1807 
1808       JvmtiEnvThreadStateIterator it(state);
1809       for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1810         if (ets-&gt;is_enabled(JVMTI_EVENT_EXCEPTION_CATCH) &amp;&amp; (exception_handle() != NULL)) {
1811           EVT_TRACE(JVMTI_EVENT_EXCEPTION_CATCH,
1812                      (&quot;[%s] Evt ExceptionCatch sent %s.%s @ &quot; INTX_FORMAT,
1813                       JvmtiTrace::safe_get_thread_name(thread),
1814                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1815                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1816                       location - mh()-&gt;code_base() ));
1817 
1818           JvmtiEnv *env = ets-&gt;get_env();
1819           JvmtiExceptionEventMark jem(thread, mh, location, exception_handle);
1820           JvmtiJavaThreadEventTransition jet(thread);
1821           jvmtiEventExceptionCatch callback = env-&gt;callbacks()-&gt;ExceptionCatch;
1822           if (callback != NULL) {
1823             (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1824                       jem.jni_methodID(), jem.location(),
1825                       jem.exception());
1826           }
1827         }
1828       }
1829     }
1830   }
1831 }
1832 
1833 oop JvmtiExport::jni_GetField_probe(JavaThread *thread, jobject jobj, oop obj,
1834                                     Klass* klass, jfieldID fieldID, bool is_static) {
1835   if (*((int *)get_field_access_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1836     // At least one field access watch is set so we have more work
1837     // to do. This wrapper is used by entry points that allow us
1838     // to create handles in post_field_access_by_jni().
1839     post_field_access_by_jni(thread, obj, klass, fieldID, is_static);
1840     // event posting can block so refetch oop if we were passed a jobj
1841     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1842   }
1843   return obj;
1844 }
1845 
1846 oop JvmtiExport::jni_GetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,
1847                                        Klass* klass, jfieldID fieldID, bool is_static) {
1848   if (*((int *)get_field_access_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1849     // At least one field access watch is set so we have more work
1850     // to do. This wrapper is used by &quot;quick&quot; entry points that don&#39;t
1851     // allow us to create handles in post_field_access_by_jni(). We
1852     // override that with a ResetNoHandleMark.
1853     ResetNoHandleMark rnhm;
1854     post_field_access_by_jni(thread, obj, klass, fieldID, is_static);
1855     // event posting can block so refetch oop if we were passed a jobj
1856     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1857   }
1858   return obj;
1859 }
1860 
1861 void JvmtiExport::post_field_access_by_jni(JavaThread *thread, oop obj,
1862                                            Klass* klass, jfieldID fieldID, bool is_static) {
1863   // We must be called with a Java context in order to provide reasonable
1864   // values for the klazz, method, and location fields. The callers of this
1865   // function don&#39;t make the call unless there is a Java context.
1866   assert(thread-&gt;has_last_Java_frame(), &quot;must be called with a Java context&quot;);
1867 
1868   ResourceMark rm;
1869   fieldDescriptor fd;
1870   // if get_field_descriptor finds fieldID to be invalid, then we just bail
1871   bool valid_fieldID = JvmtiEnv::get_field_descriptor(klass, fieldID, &amp;fd);
1872   assert(valid_fieldID == true,&quot;post_field_access_by_jni called with invalid fieldID&quot;);
1873   if (!valid_fieldID) return;
1874   // field accesses are not watched so bail
1875   if (!fd.is_field_access_watched()) return;
1876 
1877   HandleMark hm(thread);
1878   Handle h_obj;
1879   if (!is_static) {
1880     // non-static field accessors have an object, but we need a handle
1881     assert(obj != NULL, &quot;non-static needs an object&quot;);
1882     h_obj = Handle(thread, obj);
1883   }
1884   post_field_access(thread,
1885                     thread-&gt;last_frame().interpreter_frame_method(),
1886                     thread-&gt;last_frame().interpreter_frame_bcp(),
1887                     klass, h_obj, fieldID);
1888 }
1889 
1890 void JvmtiExport::post_field_access(JavaThread *thread, Method* method,
1891   address location, Klass* field_klass, Handle object, jfieldID field) {
1892 
1893   HandleMark hm(thread);
1894   methodHandle mh(thread, method);
1895 
1896   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1897   if (state == NULL) {
1898     return;
1899   }
1900   EVT_TRIG_TRACE(JVMTI_EVENT_FIELD_ACCESS, (&quot;[%s] Trg Field Access event triggered&quot;,
1901                       JvmtiTrace::safe_get_thread_name(thread)));
1902   JvmtiEnvThreadStateIterator it(state);
1903   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1904     if (ets-&gt;is_enabled(JVMTI_EVENT_FIELD_ACCESS)) {
1905       EVT_TRACE(JVMTI_EVENT_FIELD_ACCESS, (&quot;[%s] Evt Field Access event sent %s.%s @ &quot; INTX_FORMAT,
1906                      JvmtiTrace::safe_get_thread_name(thread),
1907                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1908                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1909                      location - mh()-&gt;code_base() ));
1910 
1911       JvmtiEnv *env = ets-&gt;get_env();
1912       JvmtiLocationEventMark jem(thread, mh, location);
1913       jclass field_jclass = jem.to_jclass(field_klass);
1914       jobject field_jobject = jem.to_jobject(object());
1915       JvmtiJavaThreadEventTransition jet(thread);
1916       jvmtiEventFieldAccess callback = env-&gt;callbacks()-&gt;FieldAccess;
1917       if (callback != NULL) {
1918         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1919                     jem.jni_methodID(), jem.location(),
1920                     field_jclass, field_jobject, field);
1921       }
1922     }
1923   }
1924 }
1925 
1926 oop JvmtiExport::jni_SetField_probe(JavaThread *thread, jobject jobj, oop obj,
1927                                     Klass* klass, jfieldID fieldID, bool is_static,
1928                                     char sig_type, jvalue *value) {
1929   if (*((int *)get_field_modification_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1930     // At least one field modification watch is set so we have more work
1931     // to do. This wrapper is used by entry points that allow us
1932     // to create handles in post_field_modification_by_jni().
1933     post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);
1934     // event posting can block so refetch oop if we were passed a jobj
1935     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1936   }
1937   return obj;
1938 }
1939 
1940 oop JvmtiExport::jni_SetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,
1941                                        Klass* klass, jfieldID fieldID, bool is_static,
1942                                        char sig_type, jvalue *value) {
1943   if (*((int *)get_field_modification_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1944     // At least one field modification watch is set so we have more work
1945     // to do. This wrapper is used by &quot;quick&quot; entry points that don&#39;t
1946     // allow us to create handles in post_field_modification_by_jni(). We
1947     // override that with a ResetNoHandleMark.
1948     ResetNoHandleMark rnhm;
1949     post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);
1950     // event posting can block so refetch oop if we were passed a jobj
1951     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1952   }
1953   return obj;
1954 }
1955 
1956 void JvmtiExport::post_field_modification_by_jni(JavaThread *thread, oop obj,
1957                                                  Klass* klass, jfieldID fieldID, bool is_static,
1958                                                  char sig_type, jvalue *value) {
1959   // We must be called with a Java context in order to provide reasonable
1960   // values for the klazz, method, and location fields. The callers of this
1961   // function don&#39;t make the call unless there is a Java context.
1962   assert(thread-&gt;has_last_Java_frame(), &quot;must be called with Java context&quot;);
1963 
1964   ResourceMark rm;
1965   fieldDescriptor fd;
1966   // if get_field_descriptor finds fieldID to be invalid, then we just bail
1967   bool valid_fieldID = JvmtiEnv::get_field_descriptor(klass, fieldID, &amp;fd);
1968   assert(valid_fieldID == true,&quot;post_field_modification_by_jni called with invalid fieldID&quot;);
1969   if (!valid_fieldID) return;
1970   // field modifications are not watched so bail
1971   if (!fd.is_field_modification_watched()) return;
1972 
1973   HandleMark hm(thread);
1974 
1975   Handle h_obj;
1976   if (!is_static) {
1977     // non-static field accessors have an object, but we need a handle
1978     assert(obj != NULL, &quot;non-static needs an object&quot;);
1979     h_obj = Handle(thread, obj);
1980   }
1981   post_field_modification(thread,
1982                           thread-&gt;last_frame().interpreter_frame_method(),
1983                           thread-&gt;last_frame().interpreter_frame_bcp(),
1984                           klass, h_obj, fieldID, sig_type, value);
1985 }
1986 
1987 void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
1988   address location, Klass* field_klass, Handle object, jfieldID field,
1989   char sig_type, jvalue *value) {
1990 
<a name="15" id="anc15"></a><span class="line-modified">1991   if (sig_type == &#39;I&#39; || sig_type == &#39;Z&#39; || sig_type == &#39;B&#39; || sig_type == &#39;C&#39; || sig_type == &#39;S&#39;) {</span>


1992     // &#39;I&#39; instructions are used for byte, char, short and int.
1993     // determine which it really is, and convert
1994     fieldDescriptor fd;
1995     bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
1996     // should be found (if not, leave as is)
1997     if (found) {
1998       jint ival = value-&gt;i;
1999       // convert value from int to appropriate type
2000       switch (fd.field_type()) {
2001       case T_BOOLEAN:
<a name="16" id="anc16"></a><span class="line-modified">2002         sig_type = &#39;Z&#39;;</span>
2003         value-&gt;i = 0; // clear it
2004         value-&gt;z = (jboolean)ival;
2005         break;
2006       case T_BYTE:
<a name="17" id="anc17"></a><span class="line-modified">2007         sig_type = &#39;B&#39;;</span>
2008         value-&gt;i = 0; // clear it
2009         value-&gt;b = (jbyte)ival;
2010         break;
2011       case T_CHAR:
<a name="18" id="anc18"></a><span class="line-modified">2012         sig_type = &#39;C&#39;;</span>
2013         value-&gt;i = 0; // clear it
2014         value-&gt;c = (jchar)ival;
2015         break;
2016       case T_SHORT:
<a name="19" id="anc19"></a><span class="line-modified">2017         sig_type = &#39;S&#39;;</span>
2018         value-&gt;i = 0; // clear it
2019         value-&gt;s = (jshort)ival;
2020         break;
2021       case T_INT:
2022         // nothing to do
2023         break;
2024       default:
2025         // this is an integer instruction, should be one of above
2026         ShouldNotReachHere();
2027         break;
2028       }
2029     }
2030   }
2031 
<a name="20" id="anc20"></a><span class="line-modified">2032   assert(sig_type != &#39;[&#39;, &quot;array should have sig_type == &#39;L&#39;&quot;);</span>
2033   bool handle_created = false;
2034 
2035   // convert oop to JNI handle.
<a name="21" id="anc21"></a><span class="line-modified">2036   if (sig_type == &#39;L&#39;) {</span>
2037     handle_created = true;
2038     value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
2039   }
2040 
2041   post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
2042 
2043   // Destroy the JNI handle allocated above.
2044   if (handle_created) {
2045     JNIHandles::destroy_local(value-&gt;l);
2046   }
2047 }
2048 
2049 void JvmtiExport::post_field_modification(JavaThread *thread, Method* method,
2050   address location, Klass* field_klass, Handle object, jfieldID field,
2051   char sig_type, jvalue *value_ptr) {
2052 
2053   HandleMark hm(thread);
2054   methodHandle mh(thread, method);
2055 
2056   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2057   if (state == NULL) {
2058     return;
2059   }
2060   EVT_TRIG_TRACE(JVMTI_EVENT_FIELD_MODIFICATION,
2061                      (&quot;[%s] Trg Field Modification event triggered&quot;,
2062                       JvmtiTrace::safe_get_thread_name(thread)));
2063 
2064   JvmtiEnvThreadStateIterator it(state);
2065   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2066     if (ets-&gt;is_enabled(JVMTI_EVENT_FIELD_MODIFICATION)) {
2067       EVT_TRACE(JVMTI_EVENT_FIELD_MODIFICATION,
2068                    (&quot;[%s] Evt Field Modification event sent %s.%s @ &quot; INTX_FORMAT,
2069                     JvmtiTrace::safe_get_thread_name(thread),
2070                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
2071                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
2072                     location - mh()-&gt;code_base() ));
2073 
2074       JvmtiEnv *env = ets-&gt;get_env();
2075       JvmtiLocationEventMark jem(thread, mh, location);
2076       jclass field_jclass = jem.to_jclass(field_klass);
2077       jobject field_jobject = jem.to_jobject(object());
2078       JvmtiJavaThreadEventTransition jet(thread);
2079       jvmtiEventFieldModification callback = env-&gt;callbacks()-&gt;FieldModification;
2080       if (callback != NULL) {
2081         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2082                     jem.jni_methodID(), jem.location(),
2083                     field_jclass, field_jobject, field, sig_type, *value_ptr);
2084       }
2085     }
2086   }
2087 }
2088 
2089 void JvmtiExport::post_native_method_bind(Method* method, address* function_ptr) {
2090   JavaThread* thread = JavaThread::current();
2091   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
2092 
2093   HandleMark hm(thread);
2094   methodHandle mh(thread, method);
2095 
2096   EVT_TRIG_TRACE(JVMTI_EVENT_NATIVE_METHOD_BIND, (&quot;[%s] Trg Native Method Bind event triggered&quot;,
2097                       JvmtiTrace::safe_get_thread_name(thread)));
2098 
2099   if (JvmtiEventController::is_enabled(JVMTI_EVENT_NATIVE_METHOD_BIND)) {
2100     JvmtiEnvIterator it;
2101     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2102       if (env-&gt;is_enabled(JVMTI_EVENT_NATIVE_METHOD_BIND)) {
2103         EVT_TRACE(JVMTI_EVENT_NATIVE_METHOD_BIND, (&quot;[%s] Evt Native Method Bind event sent&quot;,
2104                      JvmtiTrace::safe_get_thread_name(thread) ));
2105 
2106         JvmtiMethodEventMark jem(thread, mh);
2107         JvmtiJavaThreadEventTransition jet(thread);
2108         JNIEnv* jni_env = (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) ? NULL : jem.jni_env();
2109         jvmtiEventNativeMethodBind callback = env-&gt;callbacks()-&gt;NativeMethodBind;
2110         if (callback != NULL) {
2111           (*callback)(env-&gt;jvmti_external(), jni_env, jem.jni_thread(),
2112                       jem.jni_methodID(), (void*)(*function_ptr), (void**)function_ptr);
2113         }
2114       }
2115     }
2116   }
2117 }
2118 
2119 // Returns a record containing inlining information for the given nmethod
2120 jvmtiCompiledMethodLoadInlineRecord* create_inline_record(nmethod* nm) {
2121   jint numstackframes = 0;
2122   jvmtiCompiledMethodLoadInlineRecord* record = (jvmtiCompiledMethodLoadInlineRecord*)NEW_RESOURCE_OBJ(jvmtiCompiledMethodLoadInlineRecord);
2123   record-&gt;header.kind = JVMTI_CMLR_INLINE_INFO;
2124   record-&gt;header.next = NULL;
2125   record-&gt;header.majorinfoversion = JVMTI_CMLR_MAJOR_VERSION_1;
2126   record-&gt;header.minorinfoversion = JVMTI_CMLR_MINOR_VERSION_0;
2127   record-&gt;numpcs = 0;
2128   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2129    if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2130    record-&gt;numpcs++;
2131   }
2132   record-&gt;pcinfo = (PCStackInfo*)(NEW_RESOURCE_ARRAY(PCStackInfo, record-&gt;numpcs));
2133   int scope = 0;
2134   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2135     if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2136     void* pc_address = (void*)p-&gt;real_pc(nm);
2137     assert(pc_address != NULL, &quot;pc_address must be non-null&quot;);
2138     record-&gt;pcinfo[scope].pc = pc_address;
2139     numstackframes=0;
2140     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2141       numstackframes++;
2142     }
2143     assert(numstackframes != 0, &quot;numstackframes must be nonzero.&quot;);
2144     record-&gt;pcinfo[scope].methods = (jmethodID *)NEW_RESOURCE_ARRAY(jmethodID, numstackframes);
2145     record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
2146     record-&gt;pcinfo[scope].numstackframes = numstackframes;
2147     int stackframe = 0;
2148     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2149       // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
<a name="22" id="anc22"></a><span class="line-modified">2150       assert(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);</span>
2151       record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
2152       record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
2153       stackframe++;
2154     }
2155     scope++;
2156   }
2157   return record;
2158 }
2159 
2160 void JvmtiExport::post_compiled_method_load(nmethod *nm) {
<a name="23" id="anc23"></a>
2161   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
2162     return;
2163   }
2164   JavaThread* thread = JavaThread::current();
2165 
2166   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,
2167                  (&quot;[%s] method compile load event triggered&quot;,
2168                  JvmtiTrace::safe_get_thread_name(thread)));
2169 
2170   JvmtiEnvIterator it;
2171   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
<a name="24" id="anc24"></a><span class="line-modified">2172     if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
<span class="line-removed">2173       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {</span>
<span class="line-removed">2174         continue;</span>
<span class="line-removed">2175       }</span>
<span class="line-removed">2176       EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">2177                 (&quot;[%s] class compile method load event sent %s.%s  &quot;,</span>
<span class="line-removed">2178                 JvmtiTrace::safe_get_thread_name(thread),</span>
<span class="line-removed">2179                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),</span>
<span class="line-removed">2180                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));</span>
<span class="line-removed">2181       ResourceMark rm(thread);</span>
<span class="line-removed">2182       HandleMark hm(thread);</span>
<span class="line-removed">2183 </span>
<span class="line-removed">2184       // Add inlining information</span>
<span class="line-removed">2185       jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);</span>
<span class="line-removed">2186       // Pass inlining information through the void pointer</span>
<span class="line-removed">2187       JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);</span>
<span class="line-removed">2188       JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-removed">2189       jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-removed">2190       if (callback != NULL) {</span>
<span class="line-removed">2191         (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),</span>
<span class="line-removed">2192                     jem.code_size(), jem.code_data(), jem.map_length(),</span>
<span class="line-removed">2193                     jem.map(), jem.compile_info());</span>
<span class="line-removed">2194       }</span>
<span class="line-removed">2195     }</span>
2196   }
2197 }
2198 
<a name="25" id="anc25"></a><span class="line-removed">2199 </span>
2200 // post a COMPILED_METHOD_LOAD event for a given environment
<a name="26" id="anc26"></a><span class="line-modified">2201 void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-modified">2202                                             const void *code_begin, const jint map_length,</span>
<span class="line-modified">2203                                             const jvmtiAddrLocationMap* map)</span>
<span class="line-modified">2204 {</span>
<span class="line-modified">2205   if (env-&gt;phase() &lt;= JVMTI_PHASE_PRIMORDIAL) {</span>

2206     return;
2207   }
2208   JavaThread* thread = JavaThread::current();
<a name="27" id="anc27"></a><span class="line-removed">2209   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">2210                  (&quot;[%s] method compile load event triggered (by GenerateEvents)&quot;,</span>
<span class="line-removed">2211                  JvmtiTrace::safe_get_thread_name(thread)));</span>
<span class="line-removed">2212   if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
2213 
<a name="28" id="anc28"></a><span class="line-modified">2214     EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-modified">2215               (&quot;[%s] class compile method load event sent (by GenerateEvents), jmethodID=&quot; PTR_FORMAT,</span>
<span class="line-modified">2216                JvmtiTrace::safe_get_thread_name(thread), p2i(method)));</span>




2217 
<a name="29" id="anc29"></a><span class="line-modified">2218     JvmtiEventMark jem(thread);</span>
<span class="line-modified">2219     JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-modified">2220     jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-modified">2221     if (callback != NULL) {</span>
<span class="line-modified">2222       (*callback)(env-&gt;jvmti_external(), method,</span>
<span class="line-modified">2223                   length, code_begin, map_length,</span>
<span class="line-modified">2224                   map, NULL);</span>
<span class="line-modified">2225     }</span>
<span class="line-removed">2226   }</span>
2227 }
2228 
2229 void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
2230   assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
2231 
2232   JavaThread* thread = JavaThread::current();
2233   // In theory everyone coming thru here is in_vm but we need to be certain
2234   // because a callee will do a vm-&gt;native transition
2235   ThreadInVMfromUnknown __tiv;
2236 
2237   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2238                  (&quot;[%s] method dynamic code generated event triggered&quot;,
2239                  JvmtiTrace::safe_get_thread_name(thread)));
2240   JvmtiEnvIterator it;
2241   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2242     if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2243       EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2244                 (&quot;[%s] dynamic code generated event sent for %s&quot;,
2245                 JvmtiTrace::safe_get_thread_name(thread), name));
2246       JvmtiEventMark jem(thread);
2247       JvmtiJavaThreadEventTransition jet(thread);
2248       jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2249       jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2250       if (callback != NULL) {
2251         (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2252       }
2253     }
2254   }
2255 }
2256 
2257 void JvmtiExport::post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) {
2258   jvmtiPhase phase = JvmtiEnv::get_phase();
2259   if (phase == JVMTI_PHASE_PRIMORDIAL || phase == JVMTI_PHASE_START) {
2260     post_dynamic_code_generated_internal(name, code_begin, code_end);
2261   } else {
2262     // It may not be safe to post the event from this thread.  Defer all
2263     // postings to the service thread so that it can perform them in a safe
2264     // context and in-order.
<a name="30" id="anc30"></a><span class="line-removed">2265     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
2266     JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
2267         name, code_begin, code_end);
<a name="31" id="anc31"></a><span class="line-modified">2268     JvmtiDeferredEventQueue::enqueue(event);</span>
2269   }
2270 }
2271 
2272 
2273 // post a DYNAMIC_CODE_GENERATED event for a given environment
2274 // used by GenerateEvents
2275 void JvmtiExport::post_dynamic_code_generated(JvmtiEnv* env, const char *name,
2276                                               const void *code_begin, const void *code_end)
2277 {
2278   JavaThread* thread = JavaThread::current();
2279   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2280                  (&quot;[%s] dynamic code generated event triggered (by GenerateEvents)&quot;,
2281                   JvmtiTrace::safe_get_thread_name(thread)));
2282   if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2283     EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2284               (&quot;[%s] dynamic code generated event sent for %s&quot;,
2285                JvmtiTrace::safe_get_thread_name(thread), name));
2286     JvmtiEventMark jem(thread);
2287     JvmtiJavaThreadEventTransition jet(thread);
2288     jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2289     jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2290     if (callback != NULL) {
2291       (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2292     }
2293   }
2294 }
2295 
2296 // post a DynamicCodeGenerated event while holding locks in the VM.
2297 void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
2298                                                                   address code_begin, address code_end)
2299 {
2300   // register the stub with the current dynamic code event collector
<a name="32" id="anc32"></a><span class="line-modified">2301   JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());</span>


2302   // state can only be NULL if the current thread is exiting which
2303   // should not happen since we&#39;re trying to post an event
2304   guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
2305   JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
2306   guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
2307   collector-&gt;register_stub(name, code_begin, code_end);
2308 }
2309 
2310 // Collect all the vm internally allocated objects which are visible to java world
2311 void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
2312   Thread* thread = Thread::current_or_null();
2313   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2314     // Can not take safepoint here.
2315     NoSafepointVerifier no_sfpt;
<a name="33" id="anc33"></a><span class="line-modified">2316     // Can not take safepoint here so can not use state_for to get</span>
2317     // jvmti thread state.
2318     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2319     if (state != NULL) {
2320       // state is non NULL when VMObjectAllocEventCollector is enabled.
2321       JvmtiVMObjectAllocEventCollector *collector;
2322       collector = state-&gt;get_vm_object_alloc_event_collector();
2323       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2324         // Don&#39;t record classes as these will be notified via the ClassLoad
2325         // event.
2326         if (obj-&gt;klass() != SystemDictionary::Class_klass()) {
2327           collector-&gt;record_allocation(obj);
2328         }
2329       }
2330     }
2331   }
2332 }
2333 
2334 // Collect all the sampled allocated objects.
2335 void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
2336   Thread* thread = Thread::current_or_null();
2337   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2338     // Can not take safepoint here.
2339     NoSafepointVerifier no_sfpt;
<a name="34" id="anc34"></a><span class="line-modified">2340     // Can not take safepoint here so can not use state_for to get</span>
2341     // jvmti thread state.
2342     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2343     if (state != NULL) {
2344       // state is non NULL when SampledObjectAllocEventCollector is enabled.
2345       JvmtiSampledObjectAllocEventCollector *collector;
2346       collector = state-&gt;get_sampled_object_alloc_event_collector();
2347 
2348       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2349         collector-&gt;record_allocation(obj);
2350       }
2351     }
2352   }
2353 }
2354 
2355 void JvmtiExport::post_garbage_collection_finish() {
2356   Thread *thread = Thread::current(); // this event is posted from VM-Thread.
2357   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2358                  (&quot;[%s] garbage collection finish event triggered&quot;,
2359                   JvmtiTrace::safe_get_thread_name(thread)));
2360   JvmtiEnvIterator it;
2361   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2362     if (env-&gt;is_enabled(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) {
2363       EVT_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2364                 (&quot;[%s] garbage collection finish event sent&quot;,
2365                  JvmtiTrace::safe_get_thread_name(thread)));
2366       JvmtiThreadEventTransition jet(thread);
2367       // JNIEnv is NULL here because this event is posted from VM Thread
2368       jvmtiEventGarbageCollectionFinish callback = env-&gt;callbacks()-&gt;GarbageCollectionFinish;
2369       if (callback != NULL) {
2370         (*callback)(env-&gt;jvmti_external());
2371       }
2372     }
2373   }
2374 }
2375 
2376 void JvmtiExport::post_garbage_collection_start() {
2377   Thread* thread = Thread::current(); // this event is posted from vm-thread.
2378   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_START,
2379                  (&quot;[%s] garbage collection start event triggered&quot;,
2380                   JvmtiTrace::safe_get_thread_name(thread)));
2381   JvmtiEnvIterator it;
2382   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2383     if (env-&gt;is_enabled(JVMTI_EVENT_GARBAGE_COLLECTION_START)) {
2384       EVT_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_START,
2385                 (&quot;[%s] garbage collection start event sent&quot;,
2386                  JvmtiTrace::safe_get_thread_name(thread)));
2387       JvmtiThreadEventTransition jet(thread);
2388       // JNIEnv is NULL here because this event is posted from VM Thread
2389       jvmtiEventGarbageCollectionStart callback = env-&gt;callbacks()-&gt;GarbageCollectionStart;
2390       if (callback != NULL) {
2391         (*callback)(env-&gt;jvmti_external());
2392       }
2393     }
2394   }
2395 }
2396 
2397 void JvmtiExport::post_data_dump() {
2398   Thread *thread = Thread::current();
2399   EVT_TRIG_TRACE(JVMTI_EVENT_DATA_DUMP_REQUEST,
2400                  (&quot;[%s] data dump request event triggered&quot;,
2401                   JvmtiTrace::safe_get_thread_name(thread)));
2402   JvmtiEnvIterator it;
2403   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2404     if (env-&gt;is_enabled(JVMTI_EVENT_DATA_DUMP_REQUEST)) {
2405       EVT_TRACE(JVMTI_EVENT_DATA_DUMP_REQUEST,
2406                 (&quot;[%s] data dump request event sent&quot;,
2407                  JvmtiTrace::safe_get_thread_name(thread)));
2408      JvmtiThreadEventTransition jet(thread);
2409      // JNIEnv is NULL here because this event is posted from VM Thread
2410      jvmtiEventDataDumpRequest callback = env-&gt;callbacks()-&gt;DataDumpRequest;
2411      if (callback != NULL) {
2412        (*callback)(env-&gt;jvmti_external());
2413      }
2414     }
2415   }
2416 }
2417 
2418 void JvmtiExport::post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) {
2419   oop object = (oop)obj_mntr-&gt;object();
2420   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2421   if (state == NULL) {
2422     return;
2423   }
2424 
2425   HandleMark hm(thread);
2426   Handle h(thread, object);
2427 
2428   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
2429                      (&quot;[%s] monitor contended enter event triggered&quot;,
2430                       JvmtiTrace::safe_get_thread_name(thread)));
2431 
2432   JvmtiEnvThreadStateIterator it(state);
2433   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2434     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_CONTENDED_ENTER)) {
2435       EVT_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
2436                    (&quot;[%s] monitor contended enter event sent&quot;,
2437                     JvmtiTrace::safe_get_thread_name(thread)));
2438       JvmtiMonitorEventMark  jem(thread, h());
2439       JvmtiEnv *env = ets-&gt;get_env();
2440       JvmtiThreadEventTransition jet(thread);
2441       jvmtiEventMonitorContendedEnter callback = env-&gt;callbacks()-&gt;MonitorContendedEnter;
2442       if (callback != NULL) {
2443         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_object());
2444       }
2445     }
2446   }
2447 }
2448 
2449 void JvmtiExport::post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) {
2450   oop object = (oop)obj_mntr-&gt;object();
2451   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2452   if (state == NULL) {
2453     return;
2454   }
2455 
2456   HandleMark hm(thread);
2457   Handle h(thread, object);
2458 
2459   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
2460                      (&quot;[%s] monitor contended entered event triggered&quot;,
2461                       JvmtiTrace::safe_get_thread_name(thread)));
2462 
2463   JvmtiEnvThreadStateIterator it(state);
2464   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2465     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)) {
2466       EVT_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
2467                    (&quot;[%s] monitor contended enter event sent&quot;,
2468                     JvmtiTrace::safe_get_thread_name(thread)));
2469       JvmtiMonitorEventMark  jem(thread, h());
2470       JvmtiEnv *env = ets-&gt;get_env();
2471       JvmtiThreadEventTransition jet(thread);
2472       jvmtiEventMonitorContendedEntered callback = env-&gt;callbacks()-&gt;MonitorContendedEntered;
2473       if (callback != NULL) {
2474         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_object());
2475       }
2476     }
2477   }
2478 }
2479 
2480 void JvmtiExport::post_monitor_wait(JavaThread *thread, oop object,
2481                                           jlong timeout) {
2482   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2483   if (state == NULL) {
2484     return;
2485   }
2486 
2487   HandleMark hm(thread);
2488   Handle h(thread, object);
2489 
2490   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_WAIT,
2491                      (&quot;[%s] monitor wait event triggered&quot;,
2492                       JvmtiTrace::safe_get_thread_name(thread)));
2493 
2494   JvmtiEnvThreadStateIterator it(state);
2495   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2496     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_WAIT)) {
2497       EVT_TRACE(JVMTI_EVENT_MONITOR_WAIT,
2498                    (&quot;[%s] monitor wait event sent&quot;,
2499                     JvmtiTrace::safe_get_thread_name(thread)));
2500       JvmtiMonitorEventMark  jem(thread, h());
2501       JvmtiEnv *env = ets-&gt;get_env();
2502       JvmtiThreadEventTransition jet(thread);
2503       jvmtiEventMonitorWait callback = env-&gt;callbacks()-&gt;MonitorWait;
2504       if (callback != NULL) {
2505         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2506                     jem.jni_object(), timeout);
2507       }
2508     }
2509   }
2510 }
2511 
2512 void JvmtiExport::post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) {
2513   oop object = (oop)obj_mntr-&gt;object();
2514   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2515   if (state == NULL) {
2516     return;
2517   }
2518 
2519   HandleMark hm(thread);
2520   Handle h(thread, object);
2521 
2522   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_WAITED,
2523                      (&quot;[%s] monitor waited event triggered&quot;,
2524                       JvmtiTrace::safe_get_thread_name(thread)));
2525 
2526   JvmtiEnvThreadStateIterator it(state);
2527   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2528     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_WAITED)) {
2529       EVT_TRACE(JVMTI_EVENT_MONITOR_WAITED,
2530                    (&quot;[%s] monitor waited event sent&quot;,
2531                     JvmtiTrace::safe_get_thread_name(thread)));
2532       JvmtiMonitorEventMark  jem(thread, h());
2533       JvmtiEnv *env = ets-&gt;get_env();
2534       JvmtiThreadEventTransition jet(thread);
2535       jvmtiEventMonitorWaited callback = env-&gt;callbacks()-&gt;MonitorWaited;
2536       if (callback != NULL) {
2537         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2538                     jem.jni_object(), timed_out);
2539       }
2540     }
2541   }
2542 }
2543 
2544 void JvmtiExport::post_vm_object_alloc(JavaThread *thread, oop object) {
2545   EVT_TRIG_TRACE(JVMTI_EVENT_VM_OBJECT_ALLOC, (&quot;[%s] Trg vm object alloc triggered&quot;,
2546                       JvmtiTrace::safe_get_thread_name(thread)));
2547   if (object == NULL) {
2548     return;
2549   }
2550   HandleMark hm(thread);
2551   Handle h(thread, object);
2552   JvmtiEnvIterator it;
2553   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2554     if (env-&gt;is_enabled(JVMTI_EVENT_VM_OBJECT_ALLOC)) {
2555       EVT_TRACE(JVMTI_EVENT_VM_OBJECT_ALLOC, (&quot;[%s] Evt vmobject alloc sent %s&quot;,
2556                                          JvmtiTrace::safe_get_thread_name(thread),
2557                                          object==NULL? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2558 
2559       JvmtiObjectAllocEventMark jem(thread, h());
2560       JvmtiJavaThreadEventTransition jet(thread);
2561       jvmtiEventVMObjectAlloc callback = env-&gt;callbacks()-&gt;VMObjectAlloc;
2562       if (callback != NULL) {
2563         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2564                     jem.jni_jobject(), jem.jni_class(), jem.size());
2565       }
2566     }
2567   }
2568 }
2569 
2570 void JvmtiExport::post_sampled_object_alloc(JavaThread *thread, oop object) {
2571   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2572   if (state == NULL) {
2573     return;
2574   }
2575 
2576   EVT_TRIG_TRACE(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,
2577                  (&quot;[%s] Trg sampled object alloc triggered&quot;,
2578                   JvmtiTrace::safe_get_thread_name(thread)));
2579   if (object == NULL) {
2580     return;
2581   }
2582   HandleMark hm(thread);
2583   Handle h(thread, object);
2584 
2585   JvmtiEnvThreadStateIterator it(state);
2586   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2587     if (ets-&gt;is_enabled(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC)) {
2588       EVT_TRACE(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,
2589                 (&quot;[%s] Evt sampled object alloc sent %s&quot;,
2590                  JvmtiTrace::safe_get_thread_name(thread),
2591                  object == NULL ? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2592 
2593       JvmtiEnv *env = ets-&gt;get_env();
2594       JvmtiObjectAllocEventMark jem(thread, h());
2595       JvmtiJavaThreadEventTransition jet(thread);
2596       jvmtiEventSampledObjectAlloc callback = env-&gt;callbacks()-&gt;SampledObjectAlloc;
2597       if (callback != NULL) {
2598         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2599                     jem.jni_jobject(), jem.jni_class(), jem.size());
2600       }
2601     }
2602   }
2603 }
2604 
2605 ////////////////////////////////////////////////////////////////////////////////////////////////
2606 
2607 void JvmtiExport::cleanup_thread(JavaThread* thread) {
2608   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
<a name="35" id="anc35"></a><span class="line-modified">2609   MutexLocker mu(JvmtiThreadState_lock);</span>
2610 
2611   if (thread-&gt;jvmti_thread_state() != NULL) {
2612     // This has to happen after the thread state is removed, which is
2613     // why it is not in post_thread_end_event like its complement
2614     // Maybe both these functions should be rolled into the posts?
2615     JvmtiEventController::thread_ended(thread);
2616   }
2617 }
2618 
2619 void JvmtiExport::clear_detected_exception(JavaThread* thread) {
2620   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
2621 
2622   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
2623   if (state != NULL) {
2624     state-&gt;clear_exception_state();
2625   }
2626 }
2627 
2628 void JvmtiExport::oops_do(OopClosure* f) {
<a name="36" id="anc36"></a><span class="line-removed">2629   JvmtiCurrentBreakpoints::oops_do(f);</span>
2630   JvmtiObjectAllocEventCollector::oops_do_for_all_threads(f);
2631 }
2632 
2633 void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
2634   JvmtiTagMap::weak_oops_do(is_alive, f);
2635 }
2636 
<a name="37" id="anc37"></a><span class="line-removed">2637 void JvmtiExport::gc_epilogue() {</span>
<span class="line-removed">2638   JvmtiCurrentBreakpoints::gc_epilogue();</span>
<span class="line-removed">2639 }</span>
<span class="line-removed">2640 </span>
2641 // Onload raw monitor transition.
2642 void JvmtiExport::transition_pending_onload_raw_monitors() {
2643   JvmtiPendingMonitors::transition_raw_monitors();
2644 }
2645 
2646 ////////////////////////////////////////////////////////////////////////////////////////////////
2647 #if INCLUDE_SERVICES
2648 // Attach is disabled if SERVICES is not included
2649 
2650 // type for the Agent_OnAttach entry point
2651 extern &quot;C&quot; {
2652   typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);
2653 }
2654 
2655 jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,
2656                                      const char *options, outputStream* st) {
2657   char ebuf[1024] = {0};
2658   char buffer[JVM_MAXPATHLEN];
2659   void* library = NULL;
2660   jint result = JNI_ERR;
2661   const char *on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;
2662   size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);
2663 
2664   // The abs paramter should be &quot;true&quot; or &quot;false&quot;
2665   bool is_absolute_path = (absParam != NULL) &amp;&amp; (strcmp(absParam,&quot;true&quot;)==0);
2666 
2667   // Initially marked as invalid. It will be set to valid if we can find the agent
2668   AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, NULL);
2669 
2670   // Check for statically linked in agent. If not found then if the path is
2671   // absolute we attempt to load the library. Otherwise we try to load it
2672   // from the standard dll directory.
2673 
2674   if (!os::find_builtin_agent(agent_lib, on_attach_symbols, num_symbol_entries)) {
2675     if (is_absolute_path) {
2676       library = os::dll_load(agent, ebuf, sizeof ebuf);
2677     } else {
2678       // Try to load the agent from the standard dll directory
2679       if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),
2680                              agent)) {
2681         library = os::dll_load(buffer, ebuf, sizeof ebuf);
2682       }
2683       if (library == NULL) {
2684         // not found - try OS default library path
2685         if (os::dll_build_name(buffer, sizeof(buffer), agent)) {
2686           library = os::dll_load(buffer, ebuf, sizeof ebuf);
2687         }
2688       }
2689     }
2690     if (library != NULL) {
2691       agent_lib-&gt;set_os_lib(library);
2692       agent_lib-&gt;set_valid();
2693     }
2694   }
2695   // If the library was loaded then we attempt to invoke the Agent_OnAttach
2696   // function
2697   if (agent_lib-&gt;valid()) {
2698     // Lookup the Agent_OnAttach function
2699     OnAttachEntry_t on_attach_entry = NULL;
2700     on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,
2701        os::find_agent_function(agent_lib, false, on_attach_symbols, num_symbol_entries));
2702     if (on_attach_entry == NULL) {
2703       // Agent_OnAttach missing - unload library
2704       if (!agent_lib-&gt;is_static_lib()) {
2705         os::dll_unload(library);
2706       }
2707       st-&gt;print_cr(&quot;%s is not available in %s&quot;,
2708                    on_attach_symbols[0], agent_lib-&gt;name());
2709       delete agent_lib;
2710     } else {
2711       // Invoke the Agent_OnAttach function
2712       JavaThread* THREAD = JavaThread::current();
2713       {
2714         extern struct JavaVM_ main_vm;
2715         JvmtiThreadEventMark jem(THREAD);
2716         JvmtiJavaThreadEventTransition jet(THREAD);
2717 
2718         result = (*on_attach_entry)(&amp;main_vm, (char*)options, NULL);
2719       }
2720 
2721       // Agent_OnAttach may have used JNI
2722       if (HAS_PENDING_EXCEPTION) {
2723         CLEAR_PENDING_EXCEPTION;
2724       }
2725 
2726       // If OnAttach returns JNI_OK then we add it to the list of
2727       // agent libraries so that we can call Agent_OnUnload later.
2728       if (result == JNI_OK) {
2729         Arguments::add_loaded_agent(agent_lib);
2730       } else {
2731         delete agent_lib;
2732       }
2733 
2734       // Agent_OnAttach executed so completion status is JNI_OK
2735       st-&gt;print_cr(&quot;return code: %d&quot;, result);
2736       result = JNI_OK;
2737     }
2738   } else {
2739     st-&gt;print_cr(&quot;%s was not loaded.&quot;, agent);
2740     if (*ebuf != &#39;\0&#39;) {
2741       st-&gt;print_cr(&quot;%s&quot;, ebuf);
2742     }
2743   }
2744   return result;
2745 }
2746 
2747 #endif // INCLUDE_SERVICES
2748 ////////////////////////////////////////////////////////////////////////////////////////////////
2749 
2750 // Setup current current thread for event collection.
2751 void JvmtiEventCollector::setup_jvmti_thread_state() {
2752   // set this event collector to be the current one.
2753   JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());
2754   // state can only be NULL if the current thread is exiting which
2755   // should not happen since we&#39;re trying to configure for event collection
2756   guarantee(state != NULL, &quot;exiting thread called setup_jvmti_thread_state&quot;);
2757   if (is_vm_object_alloc_event()) {
2758     JvmtiVMObjectAllocEventCollector *prev = state-&gt;get_vm_object_alloc_event_collector();
2759 
2760     // If we have a previous collector and it is disabled, it means this allocation came from a
2761     // callback induced VM Object allocation, do not register this collector then.
2762     if (prev &amp;&amp; !prev-&gt;is_enabled()) {
2763       return;
2764     }
2765     _prev = prev;
2766     state-&gt;set_vm_object_alloc_event_collector((JvmtiVMObjectAllocEventCollector *)this);
2767   } else if (is_dynamic_code_event()) {
2768     _prev = state-&gt;get_dynamic_code_event_collector();
2769     state-&gt;set_dynamic_code_event_collector((JvmtiDynamicCodeEventCollector *)this);
2770   } else if (is_sampled_object_alloc_event()) {
2771     JvmtiSampledObjectAllocEventCollector *prev = state-&gt;get_sampled_object_alloc_event_collector();
2772 
2773     if (prev) {
2774       // JvmtiSampledObjectAllocEventCollector wants only one active collector
2775       // enabled. This allows to have a collector detect a user code requiring
2776       // a sample in the callback.
2777       return;
2778     }
2779     state-&gt;set_sampled_object_alloc_event_collector((JvmtiSampledObjectAllocEventCollector*) this);
2780   }
2781 
2782   _unset_jvmti_thread_state = true;
2783 }
2784 
2785 // Unset current event collection in this thread and reset it with previous
2786 // collector.
2787 void JvmtiEventCollector::unset_jvmti_thread_state() {
2788   if (!_unset_jvmti_thread_state) {
2789     return;
2790   }
2791 
2792   JvmtiThreadState* state = JavaThread::current()-&gt;jvmti_thread_state();
2793   if (state != NULL) {
2794     // restore the previous event collector (if any)
2795     if (is_vm_object_alloc_event()) {
2796       if (state-&gt;get_vm_object_alloc_event_collector() == this) {
2797         state-&gt;set_vm_object_alloc_event_collector((JvmtiVMObjectAllocEventCollector *)_prev);
2798       } else {
2799         // this thread&#39;s jvmti state was created during the scope of
2800         // the event collector.
2801       }
2802     } else if (is_dynamic_code_event()) {
2803       if (state-&gt;get_dynamic_code_event_collector() == this) {
2804         state-&gt;set_dynamic_code_event_collector((JvmtiDynamicCodeEventCollector *)_prev);
2805       } else {
2806         // this thread&#39;s jvmti state was created during the scope of
2807         // the event collector.
2808       }
2809     } else if (is_sampled_object_alloc_event()) {
2810       if (state-&gt;get_sampled_object_alloc_event_collector() == this) {
2811         state-&gt;set_sampled_object_alloc_event_collector((JvmtiSampledObjectAllocEventCollector*)_prev);
2812       } else {
2813         // this thread&#39;s jvmti state was created during the scope of
2814         // the event collector.
2815       }
2816     }
2817   }
2818 }
2819 
2820 // create the dynamic code event collector
2821 JvmtiDynamicCodeEventCollector::JvmtiDynamicCodeEventCollector() : _code_blobs(NULL) {
2822   if (JvmtiExport::should_post_dynamic_code_generated()) {
2823     setup_jvmti_thread_state();
2824   }
2825 }
2826 
2827 // iterate over any code blob descriptors collected and post a
2828 // DYNAMIC_CODE_GENERATED event to the profiler.
2829 JvmtiDynamicCodeEventCollector::~JvmtiDynamicCodeEventCollector() {
2830   assert(!JavaThread::current()-&gt;owns_locks(), &quot;all locks must be released to post deferred events&quot;);
2831  // iterate over any code blob descriptors that we collected
2832  if (_code_blobs != NULL) {
2833    for (int i=0; i&lt;_code_blobs-&gt;length(); i++) {
2834      JvmtiCodeBlobDesc* blob = _code_blobs-&gt;at(i);
2835      JvmtiExport::post_dynamic_code_generated(blob-&gt;name(), blob-&gt;code_begin(), blob-&gt;code_end());
2836      FreeHeap(blob);
2837    }
2838    delete _code_blobs;
2839  }
2840  unset_jvmti_thread_state();
2841 }
2842 
2843 // register a stub
2844 void JvmtiDynamicCodeEventCollector::register_stub(const char* name, address start, address end) {
2845  if (_code_blobs == NULL) {
2846    _code_blobs = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiCodeBlobDesc*&gt;(1,true);
2847  }
2848  _code_blobs-&gt;append(new JvmtiCodeBlobDesc(name, start, end));
2849 }
2850 
2851 // Setup current thread to record vm allocated objects.
2852 JvmtiObjectAllocEventCollector::JvmtiObjectAllocEventCollector() :
2853     _allocated(NULL), _enable(false), _post_callback(NULL) {
2854 }
2855 
2856 // Post vm_object_alloc event for vm allocated objects visible to java
2857 // world.
2858 void JvmtiObjectAllocEventCollector::generate_call_for_allocated() {
2859   if (_allocated) {
2860     set_enabled(false);
2861     for (int i = 0; i &lt; _allocated-&gt;length(); i++) {
2862       oop obj = _allocated-&gt;at(i);
2863       _post_callback(JavaThread::current(), obj);
2864     }
2865     delete _allocated, _allocated = NULL;
2866   }
2867 }
2868 
2869 void JvmtiObjectAllocEventCollector::record_allocation(oop obj) {
2870   assert(is_enabled(), &quot;Object alloc event collector is not enabled&quot;);
2871   if (_allocated == NULL) {
2872     _allocated = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(1, true);
2873   }
2874   _allocated-&gt;push(obj);
2875 }
2876 
2877 // GC support.
2878 void JvmtiObjectAllocEventCollector::oops_do(OopClosure* f) {
2879   if (_allocated) {
2880     for(int i = _allocated-&gt;length() - 1; i &gt;= 0; i--) {
2881       if (_allocated-&gt;at(i) != NULL) {
2882         f-&gt;do_oop(_allocated-&gt;adr_at(i));
2883       }
2884     }
2885   }
2886 }
2887 
2888 void JvmtiObjectAllocEventCollector::oops_do_for_all_threads(OopClosure* f) {
2889   // no-op if jvmti not enabled
2890   if (!JvmtiEnv::environments_might_exist()) {
2891     return;
2892   }
2893 
2894   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jthr = jtiwh.next(); ) {
2895     JvmtiThreadState *state = jthr-&gt;jvmti_thread_state();
2896     if (state != NULL) {
2897       JvmtiObjectAllocEventCollector *collector;
2898       collector = state-&gt;get_vm_object_alloc_event_collector();
2899       while (collector != NULL) {
2900         collector-&gt;oops_do(f);
2901         collector = (JvmtiObjectAllocEventCollector*) collector-&gt;get_prev();
2902       }
2903 
2904       collector = state-&gt;get_sampled_object_alloc_event_collector();
2905       while (collector != NULL) {
2906         collector-&gt;oops_do(f);
2907         collector = (JvmtiObjectAllocEventCollector*) collector-&gt;get_prev();
2908       }
2909     }
2910   }
2911 }
2912 
2913 
2914 // Disable collection of VMObjectAlloc events
2915 NoJvmtiVMObjectAllocMark::NoJvmtiVMObjectAllocMark() : _collector(NULL) {
2916   // a no-op if VMObjectAlloc event is not enabled
2917   if (!JvmtiExport::should_post_vm_object_alloc()) {
2918     return;
2919   }
2920   Thread* thread = Thread::current_or_null();
2921   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2922     JavaThread* current_thread = (JavaThread*)thread;
2923     JvmtiThreadState *state = current_thread-&gt;jvmti_thread_state();
2924     if (state != NULL) {
2925       JvmtiVMObjectAllocEventCollector *collector;
2926       collector = state-&gt;get_vm_object_alloc_event_collector();
2927       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2928         _collector = collector;
2929         _collector-&gt;set_enabled(false);
2930       }
2931     }
2932   }
2933 }
2934 
2935 // Re-Enable collection of VMObjectAlloc events (if previously enabled)
2936 NoJvmtiVMObjectAllocMark::~NoJvmtiVMObjectAllocMark() {
2937   if (was_enabled()) {
2938     _collector-&gt;set_enabled(true);
2939   }
2940 };
2941 
2942 // Setup current thread to record vm allocated objects.
2943 JvmtiVMObjectAllocEventCollector::JvmtiVMObjectAllocEventCollector() {
2944   if (JvmtiExport::should_post_vm_object_alloc()) {
2945     _enable = true;
2946     setup_jvmti_thread_state();
2947     _post_callback = JvmtiExport::post_vm_object_alloc;
2948   }
2949 }
2950 
2951 JvmtiVMObjectAllocEventCollector::~JvmtiVMObjectAllocEventCollector() {
2952   if (_enable) {
2953     generate_call_for_allocated();
2954   }
2955   unset_jvmti_thread_state();
2956 }
2957 
2958 bool JvmtiSampledObjectAllocEventCollector::object_alloc_is_safe_to_sample() {
2959   Thread* thread = Thread::current();
2960   // Really only sample allocations if this is a JavaThread and not the compiler
2961   // thread.
2962   if (!thread-&gt;is_Java_thread() || thread-&gt;is_Compiler_thread()) {
2963     return false;
2964   }
2965 
2966   if (MultiArray_lock-&gt;owner() == thread) {
2967     return false;
2968   }
2969   return true;
2970 }
2971 
2972 // Setup current thread to record sampled allocated objects.
2973 JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector() {
2974   if (JvmtiExport::should_post_sampled_object_alloc()) {
2975     if (!object_alloc_is_safe_to_sample()) {
2976       return;
2977     }
2978 
2979     _enable = true;
2980     setup_jvmti_thread_state();
2981     _post_callback = JvmtiExport::post_sampled_object_alloc;
2982   }
2983 }
2984 
2985 JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector() {
2986   if (!_enable) {
2987     return;
2988   }
2989 
2990   generate_call_for_allocated();
2991   unset_jvmti_thread_state();
2992 
2993   // Unset the sampling collector as present in assertion mode only.
2994   assert(Thread::current()-&gt;is_Java_thread(),
2995          &quot;Should always be in a Java thread&quot;);
2996 }
2997 
2998 JvmtiGCMarker::JvmtiGCMarker() {
2999   // if there aren&#39;t any JVMTI environments then nothing to do
3000   if (!JvmtiEnv::environments_might_exist()) {
3001     return;
3002   }
3003 
3004   if (JvmtiExport::should_post_garbage_collection_start()) {
3005     JvmtiExport::post_garbage_collection_start();
3006   }
3007 
3008   if (SafepointSynchronize::is_at_safepoint()) {
3009     // Do clean up tasks that need to be done at a safepoint
3010     JvmtiEnvBase::check_for_periodic_clean_up();
3011   }
3012 }
3013 
3014 JvmtiGCMarker::~JvmtiGCMarker() {
3015   // if there aren&#39;t any JVMTI environments then nothing to do
3016   if (!JvmtiEnv::environments_might_exist()) {
3017     return;
3018   }
3019 
3020   // JVMTI notify gc finish
3021   if (JvmtiExport::should_post_garbage_collection_finish()) {
3022     JvmtiExport::post_garbage_collection_finish();
3023   }
3024 }
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
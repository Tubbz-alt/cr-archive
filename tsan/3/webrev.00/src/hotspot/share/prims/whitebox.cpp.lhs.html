<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
<a name="2" id="anc2"></a>
  33 #include &quot;code/codeCache.hpp&quot;
<a name="3" id="anc3"></a>
  34 #include &quot;compiler/methodMatcher.hpp&quot;
  35 #include &quot;compiler/directivesParser.hpp&quot;
  36 #include &quot;gc/shared/gcConfig.hpp&quot;
<a name="4" id="anc4"></a>
  37 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  38 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
<a name="5" id="anc5"></a>
  39 #include &quot;memory/heapShared.inline.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/metadataFactory.hpp&quot;
  42 #include &quot;memory/iterator.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;oops/array.hpp&quot;
<a name="6" id="anc6"></a>
  47 #include &quot;oops/constantPool.inline.hpp&quot;
  48 #include &quot;oops/method.inline.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  55 #include &quot;prims/whitebox.inline.hpp&quot;
  56 #include &quot;runtime/arguments.hpp&quot;
<a name="7" id="anc7"></a><span class="line-modified">  57 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  58 #include &quot;runtime/deoptimization.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/handshake.hpp&quot;
  64 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/sweeper.hpp&quot;
  69 #include &quot;runtime/thread.hpp&quot;
  70 #include &quot;runtime/threadSMR.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;services/memoryService.hpp&quot;
  73 #include &quot;utilities/align.hpp&quot;
  74 #include &quot;utilities/debug.hpp&quot;
  75 #include &quot;utilities/elfFile.hpp&quot;
  76 #include &quot;utilities/exceptions.hpp&quot;
  77 #include &quot;utilities/macros.hpp&quot;
  78 #if INCLUDE_CDS
  79 #include &quot;prims/cdsoffsets.hpp&quot;
  80 #endif // INCLUDE_CDS
  81 #if INCLUDE_G1GC
<a name="8" id="anc8"></a>
  82 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  83 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  84 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  85 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  86 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  87 #endif // INCLUDE_G1GC
  88 #if INCLUDE_PARALLELGC
  89 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  90 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  91 #endif // INCLUDE_PARALLELGC
  92 #if INCLUDE_NMT
  93 #include &quot;services/mallocSiteTable.hpp&quot;
  94 #include &quot;services/memTracker.hpp&quot;
  95 #include &quot;utilities/nativeCallStack.hpp&quot;
  96 #endif // INCLUDE_NMT
  97 #if INCLUDE_AOT
  98 #include &quot;aot/aotLoader.hpp&quot;
  99 #endif // INCLUDE_AOT
 100 
 101 #ifdef LINUX
 102 #include &quot;osContainer_linux.hpp&quot;
 103 #endif
 104 
 105 #define SIZE_T_MAX_VALUE ((size_t) -1)
 106 
 107 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 108   do {                                                                 \
 109     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 110     THREAD-&gt;clear_pending_jni_exception_check();                       \
 111     if (HAS_PENDING_EXCEPTION) {                                       \
 112       return(value);                                                   \
 113     }                                                                  \
 114   } while (0)
 115 
 116 #define CHECK_JNI_EXCEPTION(env)                                       \
 117   do {                                                                 \
 118     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 119     THREAD-&gt;clear_pending_jni_exception_check();                       \
 120     if (HAS_PENDING_EXCEPTION) {                                       \
 121       return;                                                          \
 122     }                                                                  \
 123   } while (0)
 124 
 125 bool WhiteBox::_used = false;
 126 volatile bool WhiteBox::compilation_locked = false;
 127 
 128 class VM_WhiteBoxOperation : public VM_Operation {
 129  public:
 130   VM_WhiteBoxOperation()                         { }
 131   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 132   bool allow_nested_vm_operations() const        { return true; }
 133 };
 134 
 135 
 136 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 137   return (jlong)(void*)JNIHandles::resolve(obj);
 138 WB_END
 139 
 140 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 141   return heapOopSize;
 142 WB_END
 143 
 144 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 145   return os::vm_page_size();
 146 WB_END
 147 
 148 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 149   return os::vm_allocation_granularity();
 150 WB_END
 151 
 152 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 153   return os::large_page_size();
 154 WB_END
 155 
 156 class WBIsKlassAliveClosure : public LockedClassesDo {
 157     Symbol* _name;
<a name="9" id="anc9"></a><span class="line-modified"> 158     bool _found;</span>
 159 public:
<a name="10" id="anc10"></a><span class="line-modified"> 160     WBIsKlassAliveClosure(Symbol* name) : _name(name), _found(false) {}</span>
 161 
 162     void do_klass(Klass* k) {
<a name="11" id="anc11"></a><span class="line-removed"> 163       if (_found) return;</span>
 164       Symbol* ksym = k-&gt;name();
 165       if (ksym-&gt;fast_compare(_name) == 0) {
<a name="12" id="anc12"></a><span class="line-modified"> 166         _found = true;</span>
 167       }
 168     }
 169 
<a name="13" id="anc13"></a><span class="line-modified"> 170     bool found() const {</span>
<span class="line-modified"> 171         return _found;</span>
 172     }
 173 };
 174 
<a name="14" id="anc14"></a><span class="line-modified"> 175 WB_ENTRY(jboolean, WB_IsClassAlive(JNIEnv* env, jobject target, jstring name))</span>
 176   oop h_name = JNIHandles::resolve(name);
 177   if (h_name == NULL) return false;
<a name="15" id="anc15"></a><span class="line-modified"> 178   Symbol* sym = java_lang_String::as_symbol(h_name, CHECK_false);</span>
 179   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 180 
 181   WBIsKlassAliveClosure closure(sym);
 182   ClassLoaderDataGraph::classes_do(&amp;closure);
 183 
<a name="16" id="anc16"></a><span class="line-modified"> 184   return closure.found();</span>

 185 WB_END
 186 
 187 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 188   oop h_name = JNIHandles::resolve(name);
 189   if (h_name == NULL) return false;
<a name="17" id="anc17"></a><span class="line-modified"> 190   Symbol* sym = java_lang_String::as_symbol(h_name, CHECK_0);</span>
 191   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 192   return (jint)sym-&gt;refcount();
 193 WB_END
 194 
 195 
 196 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 197 #if INCLUDE_JVMTI
 198   ResourceMark rm;
 199   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 200   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 201   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 202   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 203 #endif
 204 }
 205 WB_END
 206 
 207 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 208 #if INCLUDE_JVMTI
 209   ResourceMark rm;
 210   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 211   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 212   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 213   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 214 #endif
 215 }
 216 WB_END
 217 
 218 
 219 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 220   return (jlong)Arguments::max_heap_for_compressed_oops();
 221 }
 222 WB_END
 223 
 224 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
<a name="18" id="anc18"></a><span class="line-modified"> 225   CollectorPolicy * p = Universe::heap()-&gt;collector_policy();</span>
<span class="line-modified"> 226   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot;</span>
<span class="line-modified"> 227     SIZE_FORMAT &quot; Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,</span>
<span class="line-modified"> 228     p-&gt;min_heap_byte_size(), p-&gt;initial_heap_byte_size(), p-&gt;max_heap_byte_size(),</span>
<span class="line-modified"> 229     p-&gt;space_alignment(), p-&gt;heap_alignment());</span>


 230 }
 231 WB_END
 232 
 233 #ifndef PRODUCT
 234 // Forward declaration
 235 void TestReservedSpace_test();
 236 void TestReserveMemorySpecial_test();
 237 void TestVirtualSpace_test();
<a name="19" id="anc19"></a><span class="line-removed"> 238 void TestMetaspaceUtils_test();</span>
 239 #endif
 240 
 241 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 242 #ifndef PRODUCT
 243   TestReservedSpace_test();
 244   TestReserveMemorySpecial_test();
 245   TestVirtualSpace_test();
<a name="20" id="anc20"></a><span class="line-removed"> 246   TestMetaspaceUtils_test();</span>
 247 #endif
 248 WB_END
 249 
 250 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 251   size_t granularity = os::vm_allocation_granularity();
 252   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 253   VirtualSpace vs;
 254   vs.initialize(rhs, 50 * granularity);
 255 
 256   // Check if constraints are complied
 257   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
<a name="21" id="anc21"></a><span class="line-modified"> 258          Universe::narrow_oop_base() != NULL &amp;&amp;</span>
<span class="line-modified"> 259          Universe::narrow_oop_use_implicit_null_checks() )) {</span>
 260     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 261                   &quot;\tUseCompressedOops is %d\n&quot;
 262                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
<a name="22" id="anc22"></a><span class="line-modified"> 263                   &quot;\tUniverse::narrow_oop_base() is &quot; PTR_FORMAT &quot;\n&quot;</span>
<span class="line-modified"> 264                   &quot;\tUniverse::narrow_oop_use_implicit_null_checks() is %d&quot;,</span>
 265                   UseCompressedOops,
 266                   p2i(rhs.base()),
<a name="23" id="anc23"></a><span class="line-modified"> 267                   p2i(Universe::narrow_oop_base()),</span>
<span class="line-modified"> 268                   Universe::narrow_oop_use_implicit_null_checks());</span>
 269     return;
 270   }
 271   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 272   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 273                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 274 WB_END
 275 
 276 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 277                                            size_t magnitude, size_t iterations) {
 278   size_t granularity = os::vm_allocation_granularity();
 279   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 280   VirtualSpace vs;
 281   if (!vs.initialize(rhs, 0)) {
 282     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 283     return 3;
 284   }
 285 
 286   int seed = os::random();
 287   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 288   os::init_random(seed);
 289 
 290   for (size_t i = 0; i &lt; iterations; i++) {
 291 
 292     // Whether we will shrink or grow
 293     bool shrink = os::random() % 2L == 0;
 294 
 295     // Get random delta to resize virtual space
 296     size_t delta = (size_t)os::random() % magnitude;
 297 
 298     // If we are about to shrink virtual space below zero, then expand instead
 299     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 300       shrink = false;
 301     }
 302 
 303     // Resizing by delta
 304     if (shrink) {
 305       vs.shrink_by(delta);
 306     } else {
 307       // If expanding fails expand_by will silently return false
 308       vs.expand_by(delta, true);
 309     }
 310   }
 311   return 0;
 312 }
 313 
 314 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 315         jlong reserved_space_size, jlong magnitude, jlong iterations))
 316   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 317                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 318                 iterations);
 319   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 320     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 321     return 1;
 322   }
 323 
 324   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 325   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 326   if (sizeof(size_t) &lt; sizeof(jlong)) {
 327     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 328     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 329         || iterations &gt; size_t_max_value) {
 330       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 331       return 2;
 332     }
 333   }
 334 
 335   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 336                                         (size_t) magnitude, (size_t) iterations);
 337 WB_END
 338 
 339 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 340   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 341 WB_END
 342 
 343 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 344   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 345 WB_END
 346 
 347 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 348   return GCConfig::is_gc_selected_ergonomically();
 349 WB_END
 350 
 351 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 352   oop p = JNIHandles::resolve(obj);
 353 #if INCLUDE_G1GC
 354   if (UseG1GC) {
 355     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 356     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 357     if (hr == NULL) {
 358       return false;
 359     }
 360     return !(hr-&gt;is_young());
 361   }
 362 #endif
 363 #if INCLUDE_PARALLELGC
 364   if (UseParallelGC) {
 365     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 366     return !psh-&gt;is_in_young(p);
 367   }
 368 #endif
 369 #if INCLUDE_ZGC
 370   if (UseZGC) {
 371     return Universe::heap()-&gt;is_in(p);
 372   }
 373 #endif
 374   GenCollectedHeap* gch = GenCollectedHeap::heap();
 375   return !gch-&gt;is_in_young(p);
 376 WB_END
 377 
 378 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 379   oop p = JNIHandles::resolve(obj);
 380   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 381 WB_END
 382 
 383 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
<a name="24" id="anc24"></a><span class="line-modified"> 384   size_t alignment = Universe::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
<span class="line-removed"> 385   return (jlong)alignment;</span>
 386 WB_END
 387 
 388 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
<a name="25" id="anc25"></a><span class="line-modified"> 389   size_t alignment = Universe::heap()-&gt;collector_policy()-&gt;heap_alignment();</span>
<span class="line-removed"> 390   return (jlong)alignment;</span>
 391 WB_END
 392 
 393 WB_ENTRY(jboolean, WB_SupportsConcurrentGCPhaseControl(JNIEnv* env, jobject o))
 394   return Universe::heap()-&gt;supports_concurrent_phase_control();
 395 WB_END
 396 
 397 WB_ENTRY(jboolean, WB_RequestConcurrentGCPhase(JNIEnv* env, jobject o, jstring name))
 398   Handle h_name(THREAD, JNIHandles::resolve(name));
 399   ResourceMark rm;
 400   const char* c_name = java_lang_String::as_utf8_string(h_name());
 401   return Universe::heap()-&gt;request_concurrent_phase(c_name);
 402 WB_END
 403 
 404 #if INCLUDE_G1GC
 405 
 406 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 407   if (UseG1GC) {
 408     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 409     oop result = JNIHandles::resolve(obj);
 410     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 411     return hr-&gt;is_humongous();
 412   }
 413   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 414 WB_END
 415 
 416 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 417   if (UseG1GC) {
 418     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 419     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 420     return hr-&gt;is_humongous();
 421   }
 422   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 423 WB_END
 424 
 425 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 426   if (UseG1GC) {
 427     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 428     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 429     return hr-&gt;is_free();
 430   }
 431   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 432 WB_END
 433 
 434 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 435   if (UseG1GC) {
 436     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 437     size_t nr = g1h-&gt;max_regions();
 438     return (jlong)nr;
 439   }
 440   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 441 WB_END
 442 
 443 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 444   if (UseG1GC) {
 445     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 446     size_t nr = g1h-&gt;num_free_regions();
 447     return (jlong)nr;
 448   }
 449   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 450 WB_END
 451 
 452 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 453   if (UseG1GC) {
 454     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 455     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 456   }
 457   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 458 WB_END
 459 
 460 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 461   if (UseG1GC) {
 462     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 463     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 464       g1h-&gt;collect(GCCause::_wb_conc_mark);
 465       return true;
 466     }
 467     return false;
 468   }
 469   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 470 WB_END
 471 
 472 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 473   if (UseG1GC) {
 474     return (jint)HeapRegion::GrainBytes;
 475   }
 476   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 477 WB_END
 478 
 479 #endif // INCLUDE_G1GC
 480 
 481 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 482 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 483 #if INCLUDE_G1GC
 484   if (UseG1GC) {
 485     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 486     if (g1h-&gt;is_heterogeneous_heap()) {
 487       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 488       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 489     } else {
 490       return (jlong)g1h-&gt;base();
 491     }
 492   }
 493 #endif // INCLUDE_G1GC
 494 #if INCLUDE_PARALLELGC
 495   if (UseParallelGC) {
 496     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 497     if (AllocateOldGenAt != NULL) {
 498       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 499       return (jlong)reserved.start();
 500     } else {
 501       return (jlong)ps_heap-&gt;base();
 502     }
 503   }
 504 #endif // INCLUDE_PARALLELGC
 505   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 506 WB_END
 507 
 508 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 509 #if INCLUDE_G1GC
 510   if (UseG1GC) {
 511     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 512     if (g1h-&gt;is_heterogeneous_heap()) {
 513       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 514       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 515     } else {
<a name="26" id="anc26"></a><span class="line-modified"> 516       return (jlong)g1h-&gt;base() + g1h-&gt;collector_policy()-&gt;max_heap_byte_size();</span>
 517     }
 518   }
 519 #endif // INCLUDE_G1GC
 520 #if INCLUDE_PARALLELGC
 521   if (UseParallelGC) {
 522     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 523     if (AllocateOldGenAt != NULL) {
 524       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 525       return (jlong)reserved.end();
 526     } else {
 527       return (jlong)ps_heap-&gt;reserved_region().end();
 528     }
 529   }
 530 #endif // INCLUDE_PARALLELGC
 531   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 532 WB_END
 533 
 534 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 535 #if INCLUDE_G1GC
 536   if (UseG1GC) {
 537     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 538     if (g1h-&gt;is_heterogeneous_heap()) {
 539       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 540       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 541     } else {
 542       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 543     }
 544   }
 545 #endif // INCLUDE_G1GC
 546 #if INCLUDE_PARALLELGC
 547   if (UseParallelGC) {
 548     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 549     if (AllocateOldGenAt != NULL) {
 550       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 551       return (jlong)reserved.start();
 552     } else {
 553       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 554     }
 555   }
 556 #endif // INCLUDE_PARALLELGC
 557   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 558 WB_END
 559 
 560 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 561 #if INCLUDE_G1GC
 562   if (UseG1GC) {
 563     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 564     if (g1h-&gt;is_heterogeneous_heap()) {
 565       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 566       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 567     } else {
 568       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 569     }
 570   }
 571 #endif // INCLUDE_G1GC
 572 #if INCLUDE_PARALLELGC
 573   if (UseParallelGC) {
 574     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 575     if (AllocateOldGenAt != NULL) {
 576       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 577       return (jlong)reserved.end();
 578       } else {
 579       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 580     }
 581   }
 582 #endif // INCLUDE_PARALLELGC
 583   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 584 WB_END
 585 
 586 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 587 
 588 #if INCLUDE_PARALLELGC
 589 
 590 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 591   if (UseParallelGC) {
 592     return ParallelScavengeHeap::heap()-&gt;gens()-&gt;virtual_spaces()-&gt;alignment();
 593   }
 594   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 595 WB_END
 596 
 597 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 598   if (UseParallelGC) {
<a name="27" id="anc27"></a><span class="line-modified"> 599     return ParallelScavengeHeap::heap()-&gt;generation_alignment();</span>
 600   }
 601   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 602 WB_END
 603 
 604 #endif // INCLUDE_PARALLELGC
 605 
 606 #if INCLUDE_G1GC
 607 
 608 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 609   if (UseG1GC) {
 610     ResourceMark rm(THREAD);
 611     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 612     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 613     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 614     return JNIHandles::make_local(env, h());
 615   }
 616   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 617 WB_END
 618 
<a name="28" id="anc28"></a>






















 619 class OldRegionsLivenessClosure: public HeapRegionClosure {
 620 
 621  private:
 622   const int _liveness;
 623   size_t _total_count;
 624   size_t _total_memory;
 625   size_t _total_memory_to_free;
 626 
 627  public:
 628   OldRegionsLivenessClosure(int liveness) :
 629     _liveness(liveness),
 630     _total_count(0),
 631     _total_memory(0),
 632     _total_memory_to_free(0) { }
 633 
 634     size_t total_count() { return _total_count; }
 635     size_t total_memory() { return _total_memory; }
 636     size_t total_memory_to_free() { return _total_memory_to_free; }
 637 
 638   bool do_heap_region(HeapRegion* r) {
 639     if (r-&gt;is_old()) {
 640       size_t prev_live = r-&gt;marked_bytes();
 641       size_t live = r-&gt;live_bytes();
 642       size_t size = r-&gt;used();
 643       size_t reg_size = HeapRegion::GrainBytes;
 644       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 645         _total_memory += size;
 646         ++_total_count;
 647         if (size == reg_size) {
 648         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 649         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 650           _total_memory_to_free += size - prev_live;
 651         }
 652       }
 653     }
 654     return false;
 655   }
 656 };
 657 
 658 
 659 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 660   if (!UseG1GC) {
 661     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 662   }
 663   if (liveness &lt; 0) {
 664     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 665   }
 666 
 667   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 668   OldRegionsLivenessClosure rli(liveness);
 669   g1h-&gt;heap_region_iterate(&amp;rli);
 670 
 671   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 672   result-&gt;long_at_put(0, rli.total_count());
 673   result-&gt;long_at_put(1, rli.total_memory());
 674   result-&gt;long_at_put(2, rli.total_memory_to_free());
 675   return (jlongArray) JNIHandles::make_local(env, result);
 676 WB_END
 677 
 678 #endif // INCLUDE_G1GC
 679 
 680 #if INCLUDE_NMT
 681 // Alloc memory using the test memory type so that we can use that to see if
 682 // NMT picks it up correctly
 683 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 684   jlong addr = 0;
 685   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 686   return addr;
 687 WB_END
 688 
 689 // Alloc memory with pseudo call stack. The test can create psudo malloc
 690 // allocation site to stress the malloc tracking.
 691 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 692   address pc = (address)(size_t)pseudo_stack;
 693   NativeCallStack stack(&amp;pc, 1);
 694   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 695 WB_END
 696 
 697 // Alloc memory with pseudo call stack and specific memory type.
 698 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 699   address pc = (address)(size_t)pseudo_stack;
 700   NativeCallStack stack(&amp;pc, 1);
 701   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 702 WB_END
 703 
 704 // Free the memory allocated by NMTAllocTest
 705 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 706   os::free((void*)(uintptr_t)mem);
 707 WB_END
 708 
 709 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 710   jlong addr = 0;
 711 
 712   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 713   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 714 
 715   return addr;
 716 WB_END
 717 
 718 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 719   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 720   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 721 
 722   return addr;
 723 WB_END
 724 
 725 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 726   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 727   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 728 WB_END
 729 
 730 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 731   os::uncommit_memory((char *)(uintptr_t)addr, size);
 732 WB_END
 733 
 734 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 735   os::release_memory((char *)(uintptr_t)addr, size);
 736 WB_END
 737 
 738 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 739   // Test that we can downgrade NMT levels but not upgrade them.
 740   if (MemTracker::tracking_level() == NMT_off) {
 741     MemTracker::transition_to(NMT_off);
 742     return MemTracker::tracking_level() == NMT_off;
 743   } else {
 744     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 745     MemTracker::transition_to(NMT_summary);
 746     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 747 
 748     // Can&#39;t go to detail once NMT is set to summary.
 749     MemTracker::transition_to(NMT_detail);
 750     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 751 
 752     // Shutdown sets tracking level to minimal.
 753     MemTracker::shutdown();
 754     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 755 
 756     // Once the tracking level is minimal, we cannot increase to summary.
 757     // The code ignores this request instead of asserting because if the malloc site
 758     // table overflows in another thread, it tries to change the code to summary.
 759     MemTracker::transition_to(NMT_summary);
 760     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 761 
 762     // Really can never go up to detail, verify that the code would never do this.
 763     MemTracker::transition_to(NMT_detail);
 764     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 765     return MemTracker::tracking_level() == NMT_minimal;
 766   }
 767 WB_END
 768 
 769 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 770   int hash_size = MallocSiteTable::hash_buckets();
 771   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 772   return (jint)hash_size;
 773 WB_END
<a name="29" id="anc29"></a>














 774 #endif // INCLUDE_NMT
 775 
 776 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 777   assert(method != NULL, &quot;method should not be null&quot;);
 778   ThreadToNativeFromVM ttn(thread);
 779   return env-&gt;FromReflectedMethod(method);
 780 }
 781 
 782 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 783 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 784  private:
 785   int _result;
 786   const bool _make_not_entrant;
 787  public:
 788   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 789         _result(0), _make_not_entrant(make_not_entrant) { }
 790   int  result() const { return _result; }
 791 
 792   void doit() {
 793     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 794       if (t-&gt;has_last_Java_frame()) {
<a name="30" id="anc30"></a><span class="line-modified"> 795         for (StackFrameStream fst(t, UseBiasedLocking); !fst.is_done(); fst.next()) {</span>
 796           frame* f = fst.current();
 797           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
<a name="31" id="anc31"></a><span class="line-modified"> 798             RegisterMap* reg_map = fst.register_map();</span>
<span class="line-removed"> 799             Deoptimization::deoptimize(t, *f, reg_map);</span>
 800             if (_make_not_entrant) {
 801                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 802                 assert(cm != NULL, &quot;sanity check&quot;);
 803                 cm-&gt;make_not_entrant();
 804             }
 805             ++_result;
 806           }
 807         }
 808       }
 809     }
 810   }
 811 };
 812 
 813 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 814   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 815   VMThread::execute(&amp;op);
 816   return op.result();
 817 WB_END
 818 
 819 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
<a name="32" id="anc32"></a><span class="line-removed"> 820   MutexLockerEx mu(Compile_lock);</span>
 821   CodeCache::mark_all_nmethods_for_deoptimization();
<a name="33" id="anc33"></a><span class="line-modified"> 822   VM_Deoptimize op;</span>
<span class="line-removed"> 823   VMThread::execute(&amp;op);</span>
 824 WB_END
 825 
 826 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 827   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 828   int result = 0;
 829   CHECK_JNI_EXCEPTION_(env, result);
<a name="34" id="anc34"></a><span class="line-modified"> 830   MutexLockerEx mu(Compile_lock);</span>
 831   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 832   if (is_osr) {
 833     result += mh-&gt;mark_osr_nmethods();
 834   } else if (mh-&gt;code() != NULL) {
 835     mh-&gt;code()-&gt;mark_for_deoptimization();
 836     ++result;
 837   }
 838   result += CodeCache::mark_for_deoptimization(mh());
 839   if (result &gt; 0) {
<a name="35" id="anc35"></a><span class="line-modified"> 840     VM_Deoptimize op;</span>
<span class="line-removed"> 841     VMThread::execute(&amp;op);</span>
 842   }
 843   return result;
 844 WB_END
 845 
 846 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 847   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 848   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<a name="36" id="anc36"></a><span class="line-modified"> 849   MutexLockerEx mu(Compile_lock);</span>
 850   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 851   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 852   if (code == NULL) {
 853     return JNI_FALSE;
 854   }
 855   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 856 WB_END
 857 
 858 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 859   if (method == NULL || comp_level &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {
 860     return false;
 861   }
 862   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 863   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<a name="37" id="anc37"></a><span class="line-modified"> 864   MutexLockerEx mu(Compile_lock);</span>
 865   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 866   if (is_osr) {
 867     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 868   } else {
 869     return CompilationPolicy::can_be_compiled(mh, comp_level);
 870   }
 871 WB_END
 872 
 873 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 874   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 875   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<a name="38" id="anc38"></a><span class="line-modified"> 876   MutexLockerEx mu(Compile_lock);</span>
 877   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 878   return mh-&gt;queued_for_compilation();
 879 WB_END
 880 
 881 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 882   if (compLevel &lt; CompLevel_none || compLevel &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {
 883     return false; // Intrinsic is not available on a non-existent compilation level.
 884   }
 885   jmethodID method_id, compilation_context_id;
 886   method_id = reflected_method_to_jmid(thread, env, method);
 887   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 888   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 889 
 890   DirectiveSet* directive;
 891   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 892   assert(comp != NULL, &quot;compiler not available&quot;);
 893   if (compilation_context != NULL) {
 894     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 895     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 896     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 897     directive = DirectivesStack::getMatchingDirective(cch, comp);
 898   } else {
 899     // Calling with NULL matches default directive
 900     directive = DirectivesStack::getDefaultDirective(comp);
 901   }
 902   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 903   DirectivesStack::release(directive);
 904   return result;
 905 WB_END
 906 
 907 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 908   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 909   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 910   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 911   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 912   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 913 WB_END
 914 
 915 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 916   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 917   CHECK_JNI_EXCEPTION(env);
 918   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 919   if (is_osr) {
<a name="39" id="anc39"></a><span class="line-modified"> 920     mh-&gt;set_not_osr_compilable(comp_level, true /* report */, &quot;WhiteBox&quot;);</span>
 921   } else {
<a name="40" id="anc40"></a><span class="line-modified"> 922     mh-&gt;set_not_compilable(comp_level, true /* report */, &quot;WhiteBox&quot;);</span>
 923   }
 924 WB_END
 925 
 926 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 927   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 928   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 929   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 930   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 931   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 932 WB_END
 933 
 934 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 935   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 936   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 937   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 938   bool result = mh-&gt;dont_inline();
 939   mh-&gt;set_dont_inline(value == JNI_TRUE);
 940   return result;
 941 WB_END
 942 
 943 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
 944   if (comp_level == CompLevel_any) {
 945     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
 946         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
 947   } else {
 948     return CompileBroker::queue_size(comp_level);
 949   }
 950 WB_END
 951 
 952 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 953   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 954   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 955   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 956   bool result = mh-&gt;force_inline();
 957   mh-&gt;set_force_inline(value == JNI_TRUE);
 958   return result;
 959 WB_END
 960 
 961 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
 962   // Screen for unavailable/bad comp level or null method
 963   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
 964   if (method == NULL) {
 965     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
 966     return false;
 967   }
 968   if (comp_level &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {
 969     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
 970     return false;
 971   }
 972   if (comp == NULL) {
 973     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
 974     return false;
 975   }
 976 
 977   // Check if compilation is blocking
 978   methodHandle mh(THREAD, method);
 979   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
 980   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
 981   DirectivesStack::release(directive);
 982 
 983   // Compile method and check result
 984   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
<a name="41" id="anc41"></a><span class="line-modified"> 985   MutexLockerEx mu(Compile_lock);</span>
 986   bool is_queued = mh-&gt;queued_for_compilation();
 987   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
 988     return true;
 989   }
 990   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
 991   mh-&gt;print_short_name(tty);
 992   tty-&gt;cr();
 993   if (is_blocking &amp;&amp; is_queued) {
 994     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
 995   }
 996   return false;
 997 }
 998 
 999 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1000   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1001   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1002   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1003 WB_END
1004 
1005 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1006   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1007   Method* clinit = ik-&gt;class_initializer();
1008   if (clinit == NULL) {
1009     return false;
1010   }
1011   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1012 WB_END
1013 
1014 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1015   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1016   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1017 
1018   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1019   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1020   bool result = directive-&gt;PrintAssemblyOption;
1021   DirectivesStack::release(directive);
1022 
1023   return result;
1024 WB_END
1025 
1026 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1027   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1028   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1029 
1030   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1031 
<a name="42" id="anc42"></a><span class="line-modified">1032   ResourceMark rm;</span>
1033   const char* error_msg = NULL;
1034   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1035   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1036 
1037   if (m == NULL) {
1038     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1039     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1040     return -1; // Pattern failed
1041   }
1042 
1043   // Pattern works - now check if it matches
1044   int result;
1045   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1046     result = 2; // Force inline match
1047   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1048     result = 1; // Dont inline match
1049   } else {
1050     result = 0; // No match
1051   }
1052   delete m;
1053   return result;
1054 WB_END
1055 
1056 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1057   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1058   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1059 
1060   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1061 
1062   ResourceMark rm;
1063   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1064 
1065   const char* error_msg = NULL;
1066 
1067   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1068   if (m == NULL) {
1069     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1070     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1071     return -1;
1072   }
1073 
1074   // Pattern works - now check if it matches
1075   int result = m-&gt;matches(mh);
1076   delete m;
1077   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1078   return result;
1079 WB_END
1080 
<a name="43" id="anc43"></a>

















1081 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1082   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1083   CHECK_JNI_EXCEPTION(env);
1084   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
<a name="44" id="anc44"></a><span class="line-modified">1085   MutexLockerEx mu(Compile_lock);</span>
1086   MethodData* mdo = mh-&gt;method_data();
1087   MethodCounters* mcs = mh-&gt;method_counters();
1088 
1089   if (mdo != NULL) {
1090     mdo-&gt;init();
<a name="45" id="anc45"></a><span class="line-modified">1091     ResourceMark rm;</span>
1092     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1093     for (int i = 0; i &lt; arg_count; i++) {
1094       mdo-&gt;set_arg_modified(i, 0);
1095     }
<a name="46" id="anc46"></a><span class="line-modified">1096     MutexLockerEx mu(mdo-&gt;extra_data_lock());</span>
1097     mdo-&gt;clean_method_data(/*always_clean*/true);
1098   }
1099 
1100   mh-&gt;clear_not_c1_compilable();
1101   mh-&gt;clear_not_c2_compilable();
1102   mh-&gt;clear_not_c2_osr_compilable();
1103   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1104   if (mcs != NULL) {
1105     mcs-&gt;backedge_counter()-&gt;init();
1106     mcs-&gt;invocation_counter()-&gt;init();
1107     mcs-&gt;set_interpreter_invocation_count(0);
1108     mcs-&gt;set_interpreter_throwout_count(0);
1109 
1110 #ifdef TIERED
1111     mcs-&gt;set_rate(0.0F);
1112     mh-&gt;set_prev_event_count(0);
1113     mh-&gt;set_prev_time(0);
1114 #endif
1115   }
1116 WB_END
1117 
1118 template &lt;typename T&gt;
<a name="47" id="anc47"></a><span class="line-modified">1119 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const char*, T*, bool, bool)) {</span>
1120   if (name == NULL) {
1121     return false;
1122   }
1123   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1124   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1125   CHECK_JNI_EXCEPTION_(env, false);
<a name="48" id="anc48"></a><span class="line-modified">1126   JVMFlag::Error result = (*TAt)(flag_name, value, true, true);</span>

1127   env-&gt;ReleaseStringUTFChars(name, flag_name);
1128   return (result == JVMFlag::SUCCESS);
1129 }
1130 
1131 template &lt;typename T&gt;
<a name="49" id="anc49"></a><span class="line-modified">1132 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(const char*, T*, JVMFlag::Flags)) {</span>
1133   if (name == NULL) {
1134     return false;
1135   }
1136   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1137   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1138   CHECK_JNI_EXCEPTION_(env, false);
<a name="50" id="anc50"></a><span class="line-modified">1139   JVMFlag::Error result = (*TAtPut)(flag_name, value, JVMFlag::INTERNAL);</span>

1140   env-&gt;ReleaseStringUTFChars(name, flag_name);
1141   return (result == JVMFlag::SUCCESS);
1142 }
1143 
1144 template &lt;typename T&gt;
1145 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1146   ResourceMark rm(thread);
1147   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1148   CHECK_JNI_EXCEPTION_(env, NULL);
1149   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1150         vmSymbols::valueOf_name()-&gt;as_C_string(),
1151         sig-&gt;as_C_string());
1152   CHECK_JNI_EXCEPTION_(env, NULL);
1153   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1154   CHECK_JNI_EXCEPTION_(env, NULL);
1155   return result;
1156 }
1157 
1158 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1159   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1160 }
1161 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1162   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1163 }
1164 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1165   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1166 }
1167 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1168   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1169 }*/
1170 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1171   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1172 }
1173 
<a name="51" id="anc51"></a><span class="line-modified">1174 static JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {</span>
1175   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1176   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1177   CHECK_JNI_EXCEPTION_(env, NULL);
<a name="52" id="anc52"></a><span class="line-modified">1178   JVMFlag* result = JVMFlag::find_flag(flag_name, strlen(flag_name), true, true);</span>
1179   env-&gt;ReleaseStringUTFChars(name, flag_name);
1180   return result;
1181 }
1182 
1183 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
<a name="53" id="anc53"></a><span class="line-modified">1184   JVMFlag* flag = getVMFlag(thread, env, name);</span>
1185   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1186 WB_END
1187 
1188 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
<a name="54" id="anc54"></a><span class="line-modified">1189   JVMFlag* flag = getVMFlag(thread, env, name);</span>
1190   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1191 WB_END
1192 
1193 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1194   bool result;
1195   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1196     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1197     return booleanBox(thread, env, result);
1198   }
1199   return NULL;
1200 WB_END
1201 
1202 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1203   int result;
1204   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1205     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1206     return longBox(thread, env, result);
1207   }
1208   return NULL;
1209 WB_END
1210 
1211 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1212   uint result;
1213   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1214     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1215     return longBox(thread, env, result);
1216   }
1217   return NULL;
1218 WB_END
1219 
1220 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1221   intx result;
1222   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1223     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1224     return longBox(thread, env, result);
1225   }
1226   return NULL;
1227 WB_END
1228 
1229 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1230   uintx result;
1231   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1232     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1233     return longBox(thread, env, result);
1234   }
1235   return NULL;
1236 WB_END
1237 
1238 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1239   uint64_t result;
1240   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1241     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1242     return longBox(thread, env, result);
1243   }
1244   return NULL;
1245 WB_END
1246 
1247 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1248   size_t result;
1249   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1250     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1251     return longBox(thread, env, result);
1252   }
1253   return NULL;
1254 WB_END
1255 
1256 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1257   double result;
1258   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1259     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1260     return doubleBox(thread, env, result);
1261   }
1262   return NULL;
1263 WB_END
1264 
1265 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1266   ccstr ccstrResult;
1267   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1268     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1269     jstring result = env-&gt;NewStringUTF(ccstrResult);
1270     CHECK_JNI_EXCEPTION_(env, NULL);
1271     return result;
1272   }
1273   return NULL;
1274 WB_END
1275 
1276 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1277   bool result = value == JNI_TRUE ? true : false;
1278   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1279 WB_END
1280 
1281 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1282   int result = value;
1283   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1284 WB_END
1285 
1286 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1287   uint result = value;
1288   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1289 WB_END
1290 
1291 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1292   intx result = value;
1293   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1294 WB_END
1295 
1296 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1297   uintx result = value;
1298   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1299 WB_END
1300 
1301 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1302   uint64_t result = value;
1303   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1304 WB_END
1305 
1306 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1307   size_t result = value;
1308   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1309 WB_END
1310 
1311 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1312   double result = value;
1313   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1314 WB_END
1315 
1316 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1317   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1318   const char* ccstrValue;
1319   if (value == NULL) {
1320     ccstrValue = NULL;
1321   }
1322   else {
1323     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1324     CHECK_JNI_EXCEPTION(env);
1325   }
1326   ccstr ccstrResult = ccstrValue;
1327   bool needFree;
1328   {
1329     ThreadInVMfromNative ttvfn(thread); // back to VM
1330     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1331   }
1332   if (value != NULL) {
1333     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1334   }
1335   if (needFree) {
1336     FREE_C_HEAP_ARRAY(char, ccstrResult);
1337   }
1338 WB_END
1339 
1340 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1341   WhiteBox::compilation_locked = true;
1342 WB_END
1343 
1344 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
<a name="55" id="anc55"></a><span class="line-modified">1345   MonitorLockerEx mo(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
1346   WhiteBox::compilation_locked = false;
1347   mo.notify_all();
1348 WB_END
1349 
1350 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1351   // Force a code cache sweep and block until it finished
1352   NMethodSweeper::force_sweep();
1353 WB_END
1354 
1355 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1356   ResourceMark rm(THREAD);
1357   int len;
1358   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1359   return (StringTable::lookup(name, len) != NULL);
1360 WB_END
1361 
1362 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1363   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1364   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1365 #if INCLUDE_G1GC
1366   if (UseG1GC) {
1367     // Needs to be cleared explicitly for G1
1368     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1369   }
1370 #endif // INCLUDE_G1GC
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1374   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1375 WB_END
1376 
1377 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1378   // static+volatile in order to force the read to happen
1379   // (not be eliminated by the compiler)
1380   static char c;
1381   static volatile char* p;
1382 
1383   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1384   if (p == NULL) {
1385     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1386   }
1387 
1388   c = *p;
1389 WB_END
1390 
1391 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1392   const char* features = VM_Version::features_string();
1393   ThreadToNativeFromVM ttn(thread);
1394   jstring features_string = env-&gt;NewStringUTF(features);
1395 
1396   CHECK_JNI_EXCEPTION_(env, NULL);
1397 
1398   return features_string;
1399 WB_END
1400 
1401 int WhiteBox::get_blob_type(const CodeBlob* code) {
1402   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1403   if (code-&gt;is_aot()) {
1404     return -1;
1405   }
1406   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1407 }
1408 
1409 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1410   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1411   return CodeCache::get_code_heap(blob_type);
1412 }
1413 
1414 struct CodeBlobStub {
1415   CodeBlobStub(const CodeBlob* blob) :
1416       name(os::strdup(blob-&gt;name())),
1417       size(blob-&gt;size()),
1418       blob_type(WhiteBox::get_blob_type(blob)),
1419       address((jlong) blob) { }
1420   ~CodeBlobStub() { os::free((void*) name); }
1421   const char* const name;
1422   const jint        size;
1423   const jint        blob_type;
1424   const jlong       address;
1425 };
1426 
1427 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1428   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1429   CHECK_JNI_EXCEPTION_(env, NULL);
1430   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1431 
1432   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1433   CHECK_JNI_EXCEPTION_(env, NULL);
1434   env-&gt;SetObjectArrayElement(result, 0, name);
1435 
1436   jobject obj = integerBox(thread, env, cb-&gt;size);
1437   CHECK_JNI_EXCEPTION_(env, NULL);
1438   env-&gt;SetObjectArrayElement(result, 1, obj);
1439 
1440   obj = integerBox(thread, env, cb-&gt;blob_type);
1441   CHECK_JNI_EXCEPTION_(env, NULL);
1442   env-&gt;SetObjectArrayElement(result, 2, obj);
1443 
1444   obj = longBox(thread, env, cb-&gt;address);
1445   CHECK_JNI_EXCEPTION_(env, NULL);
1446   env-&gt;SetObjectArrayElement(result, 3, obj);
1447 
1448   return result;
1449 }
1450 
1451 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1452   ResourceMark rm(THREAD);
1453   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1454   CHECK_JNI_EXCEPTION_(env, NULL);
1455   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1456   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1457   jobjectArray result = NULL;
1458   if (code == NULL) {
1459     return result;
1460   }
1461   int comp_level = code-&gt;comp_level();
1462   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1463 
1464   ThreadToNativeFromVM ttn(thread);
1465   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1466   CHECK_JNI_EXCEPTION_(env, NULL);
1467   result = env-&gt;NewObjectArray(5, clazz, NULL);
1468   if (result == NULL) {
1469     return result;
1470   }
1471 
1472   CodeBlobStub stub(code);
1473   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1474   CHECK_JNI_EXCEPTION_(env, NULL);
1475   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1476 
1477   jobject level = integerBox(thread, env, comp_level);
1478   CHECK_JNI_EXCEPTION_(env, NULL);
1479   env-&gt;SetObjectArrayElement(result, 1, level);
1480 
1481   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1482   CHECK_JNI_EXCEPTION_(env, NULL);
1483   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1484   env-&gt;SetObjectArrayElement(result, 2, insts);
1485 
1486   jobject id = integerBox(thread, env, code-&gt;compile_id());
1487   CHECK_JNI_EXCEPTION_(env, NULL);
1488   env-&gt;SetObjectArrayElement(result, 3, id);
1489 
1490   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1491   CHECK_JNI_EXCEPTION_(env, NULL);
1492   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1493 
1494   return result;
1495 WB_END
1496 
1497 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1498   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1499   BufferBlob* blob;
1500   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1501   if (full_size &lt; size) {
1502     full_size += align_up(size - full_size, oopSize);
1503   }
1504   {
<a name="56" id="anc56"></a><span class="line-modified">1505     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1506     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1507     if (blob != NULL) {
1508       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1509     }
1510   }
1511   // Track memory usage statistic after releasing CodeCache_lock
1512   MemoryService::track_code_cache_memory_usage();
1513   return blob;
1514 }
1515 
1516 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1517   if (size &lt; 0) {
1518     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1519       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1520   }
1521   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1522 WB_END
1523 
1524 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1525   if (addr == 0) {
1526     return;
1527   }
1528   BufferBlob::free((BufferBlob*) addr);
1529 WB_END
1530 
1531 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1532   ResourceMark rm;
1533   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1534   {
<a name="57" id="anc57"></a><span class="line-modified">1535     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1536     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1537     if (heap == NULL) {
1538       return NULL;
1539     }
1540     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1541          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1542       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1543       new (stub) CodeBlobStub(cb);
1544       blobs.append(stub);
1545     }
1546   }
1547   ThreadToNativeFromVM ttn(thread);
1548   jobjectArray result = NULL;
1549   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1550   CHECK_JNI_EXCEPTION_(env, NULL);
1551   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1552   CHECK_JNI_EXCEPTION_(env, NULL);
1553   if (result == NULL) {
1554     return result;
1555   }
1556   int i = 0;
1557   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1558        it != blobs.end(); ++it) {
1559     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1560     CHECK_JNI_EXCEPTION_(env, NULL);
1561     env-&gt;SetObjectArrayElement(result, i, obj);
1562     CHECK_JNI_EXCEPTION_(env, NULL);
1563     ++i;
1564   }
1565   return result;
1566 WB_END
1567 
1568 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1569   return CompileBroker::get_compilation_activity_mode();
1570 WB_END
1571 
1572 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1573   if (addr == 0) {
1574     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1575       &quot;WB_GetCodeBlob: addr is null&quot;);
1576   }
1577   ThreadToNativeFromVM ttn(thread);
1578   CodeBlobStub stub((CodeBlob*) addr);
1579   return codeBlob2objectArray(thread, env, &amp;stub);
1580 WB_END
1581 
1582 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1583   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1584   CHECK_JNI_EXCEPTION_(env, 0);
1585   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1586   return (jlong) mh-&gt;method_data();
1587 WB_END
1588 
1589 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1590   return (jlong) Thread::current()-&gt;stack_size();
1591 WB_END
1592 
1593 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1594   JavaThread* t = JavaThread::current();
1595   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1596 WB_END
1597 
1598 
1599 int WhiteBox::array_bytes_to_length(size_t bytes) {
1600   return Array&lt;u1&gt;::bytes_to_length(bytes);
1601 }
1602 
1603 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1604   if (size &lt; 0) {
1605     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1606         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1607   }
1608 
1609   oop class_loader_oop = JNIHandles::resolve(class_loader);
1610   ClassLoaderData* cld = class_loader_oop != NULL
1611       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1612       : ClassLoaderData::the_null_class_loader_data();
1613 
1614   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1615 
1616   return (jlong)(uintptr_t)metadata;
1617 WB_END
1618 
1619 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1620   oop class_loader_oop = JNIHandles::resolve(class_loader);
1621   ClassLoaderData* cld = class_loader_oop != NULL
1622       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1623       : ClassLoaderData::the_null_class_loader_data();
1624 
1625   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1626 WB_END
1627 
1628 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1629                                 jstring version, jstring location, jobjectArray packages))
1630   ResourceMark rm(THREAD);
1631 
1632   objArrayOop packages_oop = objArrayOop(JNIHandles::resolve(packages));
1633   objArrayHandle packages_h(THREAD, packages_oop);
1634   int num_packages = (packages_h == NULL ? 0 : packages_h-&gt;length());
1635 
1636   char** pkgs = NULL;
1637   if (num_packages &gt; 0) {
1638     pkgs = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char*, num_packages);
1639     for (int x = 0; x &lt; num_packages; x++) {
1640       oop pkg_str = packages_h-&gt;obj_at(x);
1641       if (pkg_str == NULL || !pkg_str-&gt;is_a(SystemDictionary::String_klass())) {
1642         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1643                   err_msg(&quot;Bad package name&quot;));
1644       }
1645       pkgs[x] = java_lang_String::as_utf8_string(pkg_str);
1646     }
1647   }
1648   Modules::define_module(module, is_open, version, location, (const char* const*)pkgs, num_packages, CHECK);
1649 WB_END
1650 
1651 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1652   ResourceMark rm(THREAD);
1653   char* package_name = NULL;
1654   if (package != NULL) {
1655       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1656   }
1657   Modules::add_module_exports_qualified(from_module, package_name, to_module, CHECK);
1658 WB_END
1659 
1660 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1661   ResourceMark rm(THREAD);
1662   char* package_name = NULL;
1663   if (package != NULL) {
1664       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1665   }
1666   Modules::add_module_exports_to_all_unnamed(module, package_name, CHECK);
1667 WB_END
1668 
1669 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1670   ResourceMark rm(THREAD);
1671   char* package_name = NULL;
1672   if (package != NULL) {
1673       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1674   }
1675   Modules::add_module_exports(module, package_name, NULL, CHECK);
1676 WB_END
1677 
1678 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1679   Modules::add_reads_module(from_module, source_module, CHECK);
1680 WB_END
1681 
1682 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1683   if (inc &lt; 0) {
1684     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1685         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1686   }
1687 
1688   jlong max_size_t = (jlong) ((size_t) -1);
1689   if (inc &gt; max_size_t) {
1690     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1691         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1692   }
1693 
1694   size_t new_cap_until_GC = 0;
1695   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1696   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1697   if (!success) {
1698     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1699                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1700                 &quot;due to contention with another thread&quot;);
1701   }
1702   return (jlong) new_cap_until_GC;
1703 WB_END
1704 
1705 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1706   return (jlong) MetaspaceGC::capacity_until_GC();
1707 WB_END
1708 
<a name="58" id="anc58"></a><span class="line-removed">1709 WB_ENTRY(jboolean, WB_MetaspaceShouldConcurrentCollect(JNIEnv* env, jobject wb))</span>
<span class="line-removed">1710   return MetaspaceGC::should_concurrent_collect();</span>
<span class="line-removed">1711 WB_END</span>
<span class="line-removed">1712 </span>
1713 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1714   return (jlong)Metaspace::reserve_alignment();
1715 WB_END
1716 
1717 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
<a name="59" id="anc59"></a><span class="line-modified">1718   Monitor::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?</span>
<span class="line-modified">1719                                            Monitor::_safepoint_check_always :</span>
<span class="line-modified">1720                                            Monitor::_safepoint_check_never;</span>
<span class="line-modified">1721   MutexLockerEx ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),</span>
<span class="line-modified">1722                    attemptedNoSafepointValue == JNI_TRUE);</span>

















1723 WB_END
1724 
1725 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1726   oop obj_oop = JNIHandles::resolve(obj);
<a name="60" id="anc60"></a><span class="line-modified">1727   return (jboolean) obj_oop-&gt;mark()-&gt;has_monitor();</span>
1728 WB_END
1729 
1730 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1731   VM_ForceSafepoint force_safepoint_op;
1732   VMThread::execute(&amp;force_safepoint_op);
1733 WB_END
1734 
1735 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1736   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1737   return (jlong) ik-&gt;constants();
1738 WB_END
1739 
1740 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1741   return ConstantPool::CPCACHE_INDEX_TAG;
1742 WB_END
1743 
1744 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1745   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1746   ConstantPool* cp = ik-&gt;constants();
1747   if (cp-&gt;cache() == NULL) {
1748       return -1;
1749   }
1750   return cp-&gt;cache()-&gt;length();
1751 WB_END
1752 
1753 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1754   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1755   ConstantPool* cp = ik-&gt;constants();
1756   if (cp-&gt;cache() == NULL) {
1757     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1758   }
1759   jint cpci = index;
1760   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1761   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1762     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1763   }
1764   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1765   return cpi;
1766 WB_END
1767 
1768 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1769   return ConstantPool::encode_invokedynamic_index(index);
1770 WB_END
1771 
1772 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1773   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1774   VMThread::execute(&amp;clear_ics);
1775 WB_END
1776 
1777 template &lt;typename T&gt;
1778 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1779   assert(value != NULL, &quot;sanity&quot;);
1780   if (method == NULL || name == NULL) {
1781     return false;
1782   }
1783   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1784   CHECK_JNI_EXCEPTION_(env, false);
1785   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1786   // can&#39;t be in VM when we call JNI
1787   ThreadToNativeFromVM ttnfv(thread);
1788   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1789   CHECK_JNI_EXCEPTION_(env, false);
1790   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1791   env-&gt;ReleaseStringUTFChars(name, flag_name);
1792   return result;
1793 }
1794 
1795 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1796   bool result;
1797   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1798     // can&#39;t be in VM when we call JNI
1799     ThreadToNativeFromVM ttnfv(thread);
1800     return booleanBox(thread, env, result);
1801   }
1802   return NULL;
1803 WB_END
1804 
1805 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1806   intx result;
1807   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1808     // can&#39;t be in VM when we call JNI
1809     ThreadToNativeFromVM ttnfv(thread);
1810     return longBox(thread, env, result);
1811   }
1812   return NULL;
1813 WB_END
1814 
1815 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1816   uintx result;
1817   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1818     // can&#39;t be in VM when we call JNI
1819     ThreadToNativeFromVM ttnfv(thread);
1820     return longBox(thread, env, result);
1821   }
1822   return NULL;
1823 WB_END
1824 
1825 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1826   double result;
1827   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1828     // can&#39;t be in VM when we call JNI
1829     ThreadToNativeFromVM ttnfv(thread);
1830     return doubleBox(thread, env, result);
1831   }
1832   return NULL;
1833 WB_END
1834 
1835 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1836   ccstr ccstrResult;
1837   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1838     // can&#39;t be in VM when we call JNI
1839     ThreadToNativeFromVM ttnfv(thread);
1840     jstring result = env-&gt;NewStringUTF(ccstrResult);
1841     CHECK_JNI_EXCEPTION_(env, NULL);
1842     return result;
1843   }
1844   return NULL;
1845 WB_END
1846 
1847 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1848   const char* p = Arguments::get_default_shared_archive_path();
1849   ThreadToNativeFromVM ttn(thread);
1850   jstring path_string = env-&gt;NewStringUTF(p);
1851 
1852   CHECK_JNI_EXCEPTION_(env, NULL);
1853 
1854   return path_string;
1855 WB_END
1856 
1857 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1858   return UseSharedSpaces;
1859 WB_END
1860 
<a name="61" id="anc61"></a>



1861 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1862   oop obj_oop = JNIHandles::resolve(obj);
1863   return HeapShared::is_archived_object(obj_oop);
1864 WB_END
1865 
1866 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1867   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1868 WB_END
1869 
1870 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
1871   return !HeapShared::closed_archive_heap_region_mapped();
1872 WB_END
1873 
1874 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
1875   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1876   if (k-&gt;is_instance_klass()) {
1877     InstanceKlass *ik = InstanceKlass::cast(k);
1878     ConstantPool *cp = ik-&gt;constants();
1879     objArrayOop refs =  cp-&gt;resolved_references();
1880     return (jobject)JNIHandles::make_local(env, refs);
1881   } else {
1882     return NULL;
1883   }
1884 WB_END
1885 
<a name="62" id="anc62"></a>








1886 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
1887   return HeapShared::open_archive_heap_region_mapped();
1888 WB_END
1889 
1890 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
1891 #if INCLUDE_CDS
1892 # ifdef _LP64
1893     if (!UseCompressedOops || !UseCompressedClassPointers) {
1894       // On 64-bit VMs, CDS is supported only with compressed oops/pointers
1895       return false;
1896     }
1897 # endif // _LP64
1898   return true;
1899 #else
1900   return false;
1901 #endif // INCLUDE_CDS
1902 WB_END
1903 
<a name="63" id="anc63"></a>







1904 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
1905   return HeapShared::is_heap_object_archiving_allowed();
1906 WB_END
1907 
1908 
1909 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
1910 #if INCLUDE_JFR
1911   return true;
1912 #else
1913   return false;
1914 #endif // INCLUDE_JFR
1915 WB_END
1916 
1917 #if INCLUDE_CDS
1918 
1919 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
1920   ResourceMark rm;
1921   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
1922   int result = CDSOffsets::find_offset(c_name);
1923   return (jint)result;
1924 WB_END
1925 
1926 #endif // INCLUDE_CDS
1927 
1928 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
<a name="64" id="anc64"></a><span class="line-modified">1929   class TraceSelfClosure : public ThreadClosure {</span>
1930     jint _num_threads_completed;
1931 
1932     void do_thread(Thread* th) {
1933       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
1934       JavaThread* jt = (JavaThread*)th;
1935       ResourceMark rm;
1936 
1937       jt-&gt;print_on(tty);
1938       jt-&gt;print_stack_on(tty);
1939       tty-&gt;cr();
1940       Atomic::inc(&amp;_num_threads_completed);
1941     }
1942 
1943   public:
<a name="65" id="anc65"></a><span class="line-modified">1944     TraceSelfClosure() : _num_threads_completed(0) {}</span>
1945 
1946     jint num_threads_completed() const { return _num_threads_completed; }
1947   };
1948   TraceSelfClosure tsc;
1949 
1950   if (all_threads) {
1951     Handshake::execute(&amp;tsc);
1952   } else {
1953     oop thread_oop = JNIHandles::resolve(thread_handle);
1954     if (thread_oop != NULL) {
1955       JavaThread* target = java_lang_Thread::thread(thread_oop);
1956       Handshake::execute(&amp;tsc, target);
1957     }
1958   }
1959   return tsc.num_threads_completed();
1960 WB_END
1961 
1962 //Some convenience methods to deal with objects from java
1963 int WhiteBox::offset_for_field(const char* field_name, oop object,
1964     Symbol* signature_symbol) {
1965   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
1966   Thread* THREAD = Thread::current();
1967 
1968   //Get the class of our object
1969   Klass* arg_klass = object-&gt;klass();
1970   //Turn it into an instance-klass
1971   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
1972 
1973   //Create symbols to look for in the class
<a name="66" id="anc66"></a><span class="line-modified">1974   TempNewSymbol name_symbol = SymbolTable::lookup(field_name, (int) strlen(field_name),</span>
<span class="line-removed">1975       THREAD);</span>
1976 
1977   //To be filled in with an offset of the field we&#39;re looking for
1978   fieldDescriptor fd;
1979 
1980   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
1981   if (res == NULL) {
1982     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
1983         name_symbol-&gt;as_C_string());
1984     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
1985   }
1986 
1987   //fetch the field at the offset we&#39;ve found
1988   int dest_offset = fd.offset();
1989 
1990   return dest_offset;
1991 }
1992 
1993 
1994 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
1995   int offset = offset_for_field(field_name, object,
1996       vmSymbols::string_signature());
1997   oop string = object-&gt;obj_field(offset);
1998   if (string == NULL) {
1999     return NULL;
2000   }
2001   const char* ret = java_lang_String::as_utf8_string(string);
2002   return ret;
2003 }
2004 
2005 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2006   int offset =
2007       offset_for_field(field_name, object, vmSymbols::bool_signature());
2008   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2009   return ret;
2010 }
2011 
2012 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2013   ResourceMark rm;
2014   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2015 
2016   //  one by one registration natives for exception catching
2017   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2018   CHECK_JNI_EXCEPTION(env);
2019   for (int i = 0, n = method_count; i &lt; n; ++i) {
2020     // Skip dummy entries
2021     if (method_array[i].fnPtr == NULL) continue;
2022     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2023       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2024       if (throwable_obj != NULL) {
2025         env-&gt;ExceptionClear();
2026         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2027           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2028           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2029           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2030               method_array[i].name, method_array[i].signature);
2031         }
2032       } else {
2033         // Registration failed unexpectedly.
2034         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2035             method_array[i].name, method_array[i].signature);
2036         env-&gt;UnregisterNatives(wbclass);
2037         break;
2038       }
2039     }
2040   }
2041 }
2042 
2043 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2044   // can&#39;t be in VM when we call JNI
2045   ThreadToNativeFromVM ttnfv(thread);
2046   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2047   CHECK_JNI_EXCEPTION_(env, 0);
2048   int ret;
2049   {
2050     ThreadInVMfromNative ttvfn(thread); // back to VM
2051     ret = DirectivesParser::parse_string(dir, tty);
2052   }
2053   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2054   // -1 for error parsing directive. Return 0 as number of directives added.
2055   if (ret == -1) {
2056     ret = 0;
2057   }
2058   return (jint) ret;
2059 WB_END
2060 
2061 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2062   DirectivesStack::pop(count);
2063 WB_END
2064 
2065 // Checks that the library libfile has the noexecstack bit set.
2066 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2067   jboolean ret = false;
2068 #ifdef LINUX
2069   // Can&#39;t be in VM when we call JNI.
2070   ThreadToNativeFromVM ttnfv(thread);
2071   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2072   CHECK_JNI_EXCEPTION_(env, 0);
2073   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2074   env-&gt;ReleaseStringUTFChars(libfile, lf);
2075 #endif
2076   return ret;
2077 WB_END
2078 
2079 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2080   LINUX_ONLY(return OSContainer::is_containerized();)
2081   return false;
2082 WB_END
2083 
2084 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2085   os::print_os_info(tty);
2086 WB_END
2087 
2088 // Elf decoder
2089 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2090 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2091   ElfFile::_do_not_cache_elf_section = true;
2092 #endif
2093 WB_END
2094 
<a name="67" id="anc67"></a><span class="line-modified">2095 WB_ENTRY(jint, WB_ResolvedMethodRemovedCount(JNIEnv* env, jobject o))</span>
<span class="line-modified">2096   return (jint) ResolvedMethodTable::removed_entries_count();</span>
2097 WB_END
2098 
2099 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2100   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2101 WB_END
2102 
2103 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2104   jint result = 0;
2105 #if INCLUDE_AOT
2106   result = (jint) AOTLoader::heaps_count();
2107 #endif
2108   return result;
2109 WB_END
2110 
<a name="68" id="anc68"></a>





2111 #define CC (char*)
2112 
2113 static JNINativeMethod methods[] = {
2114   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2115   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2116   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2117   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2118   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2119   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2120   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2121   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2122   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
<a name="69" id="anc69"></a><span class="line-modified">2123   {CC&quot;isClassAlive0&quot;,                    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsClassAlive      },</span>
2124   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2125   {CC&quot;parseCommandLine0&quot;,
2126       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2127       (void*) &amp;WB_ParseCommandLine
2128   },
2129   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2130                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2131   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2132                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2133   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2134       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2135   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2136   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2137   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2138   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2139 #if INCLUDE_CDS
2140   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2141 #endif
2142 #if INCLUDE_G1GC
2143   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2144   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2145   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2146   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2147   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2148   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2149   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2150   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2151   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2152                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
<a name="70" id="anc70"></a>

2153   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2154 #endif // INCLUDE_G1GC
2155 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2156   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2157   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2158   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2159   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2160 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2161 #if INCLUDE_PARALLELGC
2162   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2163   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2164 #endif
2165 #if INCLUDE_NMT
2166   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2167   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2168   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2169   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2170   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2171   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2172   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2173   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2174   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2175   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2176   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
<a name="71" id="anc71"></a>


2177 #endif // INCLUDE_NMT
2178   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2179   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2180   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2181                                                       (void*)&amp;WB_DeoptimizeMethod  },
2182   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2183                                                       (void*)&amp;WB_IsMethodCompiled  },
2184   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2185                                                       (void*)&amp;WB_IsMethodCompilable},
2186   {CC&quot;isMethodQueuedForCompilation0&quot;,
2187       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2188   {CC&quot;isIntrinsicAvailable0&quot;,
2189       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2190                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2191   {CC&quot;makeMethodNotCompilable0&quot;,
2192       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2193   {CC&quot;testSetDontInlineMethod0&quot;,
2194       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2195   {CC&quot;getMethodCompilationLevel0&quot;,
2196       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2197   {CC&quot;getMethodEntryBci0&quot;,
2198       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2199   {CC&quot;getCompileQueueSize&quot;,
2200       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2201   {CC&quot;testSetForceInlineMethod0&quot;,
2202       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2203   {CC&quot;enqueueMethodForCompilation0&quot;,
2204       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2205   {CC&quot;enqueueInitializerForCompilation0&quot;,
2206       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
<a name="72" id="anc72"></a>

2207   {CC&quot;clearMethodState0&quot;,
2208       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2209   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2210   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2211   {CC&quot;matchesMethod&quot;,
2212       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2213                                                       (void*)&amp;WB_MatchesMethod},
2214   {CC&quot;matchesInline&quot;,
2215       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2216                                                       (void*)&amp;WB_MatchesInline},
2217   {CC&quot;shouldPrintAssembly&quot;,
2218         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2219                                                         (void*)&amp;WB_ShouldPrintAssembly},
2220 
2221   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2222   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2223   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2224   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2225   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2226   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2227   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2228   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2229   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2230   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2231   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2232                                                       (void*)&amp;WB_SetStringVMFlag},
2233   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2234                                                       (void*)&amp;WB_GetBooleanVMFlag},
2235   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2236                                                       (void*)&amp;WB_GetIntVMFlag},
2237   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2238                                                       (void*)&amp;WB_GetUintVMFlag},
2239   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2240                                                       (void*)&amp;WB_GetIntxVMFlag},
2241   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2242                                                       (void*)&amp;WB_GetUintxVMFlag},
2243   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2244                                                       (void*)&amp;WB_GetUint64VMFlag},
2245   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2246                                                       (void*)&amp;WB_GetSizeTVMFlag},
2247   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2248                                                       (void*)&amp;WB_GetDoubleVMFlag},
2249   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2250                                                       (void*)&amp;WB_GetStringVMFlag},
2251   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2252   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2253   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2254   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2255   {CC&quot;allocateMetaspace&quot;,
2256      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2257   {CC&quot;freeMetaspace&quot;,
2258      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2259   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2260   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
<a name="73" id="anc73"></a><span class="line-removed">2261   {CC&quot;metaspaceShouldConcurrentCollect&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_MetaspaceShouldConcurrentCollect },</span>
2262   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2263   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2264   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2265                                                       (void*)&amp;WB_GetNMethod         },
2266   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2267   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2268   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2269   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2270   {CC&quot;getCompilationActivityMode&quot;,
2271                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2272   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2273                                                       (void*)&amp;WB_GetMethodData      },
2274   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2275   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2276   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2277   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2278                                                       (void*)&amp;WB_DefineModule },
2279   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2280                                                       (void*)&amp;WB_AddModuleExports },
2281   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2282                                                       (void*)&amp;WB_AddReadsModule },
2283   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2284                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2285   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2286                                                       (void*)&amp;WB_AddModuleExportsToAll },
2287   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
<a name="74" id="anc74"></a>
2288   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2289   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2290   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2291   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2292   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2293   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2294       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2295   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2296       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2297   {CC&quot;getMethodBooleanOption&quot;,
2298       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2299                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2300   {CC&quot;getMethodIntxOption&quot;,
2301       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2302                                                       (void*)&amp;WB_GetMethodIntxOption},
2303   {CC&quot;getMethodUintxOption&quot;,
2304       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2305                                                       (void*)&amp;WB_GetMethodUintxOption},
2306   {CC&quot;getMethodDoubleOption&quot;,
2307       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2308                                                       (void*)&amp;WB_GetMethodDoubleOption},
2309   {CC&quot;getMethodStringOption&quot;,
2310       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2311                                                       (void*)&amp;WB_GetMethodStringOption},
2312   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2313                                                       (void*)&amp;WB_GetDefaultArchivePath},
2314   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2315   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2316   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2317   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2318   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
<a name="75" id="anc75"></a>
2319   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2320   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2321   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
<a name="76" id="anc76"></a><span class="line-modified">2322   {CC&quot;isJavaHeapArchiveSupported&quot;,      CC&quot;()Z&quot;,      (void*)&amp;WB_IsJavaHeapArchiveSupported },</span>


2323 
2324   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2325   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2326   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2327                                                       (void*)&amp;WB_AddCompilerDirective },
2328   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2329   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2330   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2331   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
2332   {CC&quot;supportsConcurrentGCPhaseControl&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_SupportsConcurrentGCPhaseControl},
2333   {CC&quot;requestConcurrentGCPhase0&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2334                                                       (void*)&amp;WB_RequestConcurrentGCPhase},
2335   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2336                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2337   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
2338   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2339   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
<a name="77" id="anc77"></a><span class="line-modified">2340   {CC&quot;resolvedMethodRemovedCount&quot;,     CC&quot;()I&quot;,       (void*)&amp;WB_ResolvedMethodRemovedCount },</span>
2341   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2342   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
<a name="78" id="anc78"></a>
2343 };
2344 
2345 
2346 #undef CC
2347 
2348 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2349   {
2350     if (WhiteBoxAPI) {
2351       // Make sure that wbclass is loaded by the null classloader
2352       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2353       Handle loader(THREAD, ik-&gt;class_loader());
2354       if (loader.is_null()) {
2355         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2356         WhiteBox::set_used();
2357       }
2358     }
2359   }
2360 JVM_END
<a name="79" id="anc79"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="79" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeBlob.hpp&quot;
 27 #include &quot;code/codeCache.hpp&quot;
 28 #include &quot;code/scopeDesc.hpp&quot;
 29 #include &quot;code/vtableStubs.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
 34 #include &quot;prims/jvmtiExport.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;
 37 
 38 // Support class to collect a list of the non-nmethod CodeBlobs in
 39 // the CodeCache.
 40 //
 41 // This class actually creates a list of JvmtiCodeBlobDesc - each JvmtiCodeBlobDesc
 42 // describes a single CodeBlob in the CodeCache. Note that collection is
 43 // done to a static list - this is because CodeCache::blobs_do is defined
 44 // as void CodeCache::blobs_do(void f(CodeBlob* nm)) and hence requires
 45 // a C or static method.
 46 //
 47 // Usage :-
 48 //
 49 // CodeBlobCollector collector;
 50 //
 51 // collector.collect();
 52 // JvmtiCodeBlobDesc* blob = collector.first();
 53 // while (blob != NULL) {
 54 //   :
 55 //   blob = collector.next();
 56 // }
 57 //
 58 
 59 class CodeBlobCollector : StackObj {
 60  private:
 61   GrowableArray&lt;JvmtiCodeBlobDesc*&gt;* _code_blobs;   // collected blobs
 62   int _pos;                                         // iterator position
 63 
 64   // used during a collection
 65   static GrowableArray&lt;JvmtiCodeBlobDesc*&gt;* _global_code_blobs;
 66   static void do_blob(CodeBlob* cb);
 67   static void do_vtable_stub(VtableStub* vs);
 68  public:
 69   CodeBlobCollector() {
 70     _code_blobs = NULL;
 71     _pos = -1;
 72   }
 73   ~CodeBlobCollector() {
 74     if (_code_blobs != NULL) {
 75       for (int i=0; i&lt;_code_blobs-&gt;length(); i++) {
 76         FreeHeap(_code_blobs-&gt;at(i));
 77       }
 78       delete _code_blobs;
 79     }
 80   }
 81 
 82   // collect list of code blobs in the cache
 83   void collect();
 84 
 85   // iteration support - return first code blob
 86   JvmtiCodeBlobDesc* first() {
 87     assert(_code_blobs != NULL, &quot;not collected&quot;);
 88     if (_code_blobs-&gt;length() == 0) {
 89       return NULL;
 90     }
 91     _pos = 0;
 92     return _code_blobs-&gt;at(0);
 93   }
 94 
 95   // iteration support - return next code blob
 96   JvmtiCodeBlobDesc* next() {
 97     assert(_pos &gt;= 0, &quot;iteration not started&quot;);
 98     if (_pos+1 &gt;= _code_blobs-&gt;length()) {
 99       return NULL;
100     }
101     return _code_blobs-&gt;at(++_pos);
102   }
103 
104 };
105 
106 // used during collection
107 GrowableArray&lt;JvmtiCodeBlobDesc*&gt;* CodeBlobCollector::_global_code_blobs;
108 
109 
110 // called for each CodeBlob in the CodeCache
111 //
112 // This function filters out nmethods as it is only interested in
113 // other CodeBlobs. This function also filters out CodeBlobs that have
114 // a duplicate starting address as previous blobs. This is needed to
115 // handle the case where multiple stubs are generated into a single
116 // BufferBlob.
117 
118 void CodeBlobCollector::do_blob(CodeBlob* cb) {
119 
120   // ignore nmethods
121   if (cb-&gt;is_nmethod()) {
122     return;
123   }
124   // exclude VtableStubs, which are processed separately
125   if (cb-&gt;is_buffer_blob() &amp;&amp; strcmp(cb-&gt;name(), &quot;vtable chunks&quot;) == 0) {
126     return;
127   }
128 
129   // check if this starting address has been seen already - the
130   // assumption is that stubs are inserted into the list before the
131   // enclosing BufferBlobs.
132   address addr = cb-&gt;code_begin();
133   for (int i=0; i&lt;_global_code_blobs-&gt;length(); i++) {
134     JvmtiCodeBlobDesc* scb = _global_code_blobs-&gt;at(i);
135     if (addr == scb-&gt;code_begin()) {
136       return;
137     }
138   }
139 
140   // record the CodeBlob details as a JvmtiCodeBlobDesc
141   JvmtiCodeBlobDesc* scb = new JvmtiCodeBlobDesc(cb-&gt;name(), cb-&gt;code_begin(), cb-&gt;code_end());
142   _global_code_blobs-&gt;append(scb);
143 }
144 
145 // called for each VtableStub in VtableStubs
146 
147 void CodeBlobCollector::do_vtable_stub(VtableStub* vs) {
148     JvmtiCodeBlobDesc* scb = new JvmtiCodeBlobDesc(vs-&gt;is_vtable_stub() ? &quot;vtable stub&quot; : &quot;itable stub&quot;,
149                                                    vs-&gt;code_begin(), vs-&gt;code_end());
150     _global_code_blobs-&gt;append(scb);
151 }
152 
153 // collects a list of CodeBlobs in the CodeCache.
154 //
155 // The created list is growable array of JvmtiCodeBlobDesc - each one describes
156 // a CodeBlob. Note that the list is static - this is because CodeBlob::blobs_do
157 // requires a a C or static function so we can&#39;t use an instance function. This
158 // isn&#39;t a problem as the iteration is serial anyway as we need the CodeCache_lock
159 // to iterate over the code cache.
160 //
161 // Note that the CodeBlobs in the CodeCache will include BufferBlobs that may
162 // contain multiple stubs. As a profiler is interested in the stubs rather than
163 // the enclosing container we first iterate over the stub code descriptors so
164 // that the stubs go into the list first. do_blob will then filter out the
165 // enclosing blobs if the starting address of the enclosing blobs matches the
166 // starting address of first stub generated in the enclosing blob.
167 
168 void CodeBlobCollector::collect() {
169   assert_locked_or_safepoint(CodeCache_lock);
170   assert(_global_code_blobs == NULL, &quot;checking&quot;);
171 
172   // create the global list
173   _global_code_blobs = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiCodeBlobDesc*&gt;(50,true);
174 
175   // iterate over the stub code descriptors and put them in the list first.
176   for (StubCodeDesc* desc = StubCodeDesc::first(); desc != NULL; desc = StubCodeDesc::next(desc)) {
177     _global_code_blobs-&gt;append(new JvmtiCodeBlobDesc(desc-&gt;name(), desc-&gt;begin(), desc-&gt;end()));
178   }
179 
180   // Vtable stubs are not described with StubCodeDesc,
181   // process them separately
182   VtableStubs::vtable_stub_do(do_vtable_stub);
183 
184   // next iterate over all the non-nmethod code blobs and add them to
185   // the list - as noted above this will filter out duplicates and
186   // enclosing blobs.
187   CodeCache::blobs_do(do_blob);
188 
189   // make the global list the instance list so that it can be used
190   // for other iterations.
191   _code_blobs = _global_code_blobs;
192   _global_code_blobs = NULL;
193 }
194 
195 
196 // Generate a DYNAMIC_CODE_GENERATED event for each non-nmethod code blob.
197 
198 jvmtiError JvmtiCodeBlobEvents::generate_dynamic_code_events(JvmtiEnv* env) {
199   CodeBlobCollector collector;
200 
201   // First collect all the code blobs.  This has to be done in a
202   // single pass over the code cache with CodeCache_lock held because
203   // there isn&#39;t any safe way to iterate over regular CodeBlobs since
204   // they can be freed at any point.
205   {
206     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
207     collector.collect();
208   }
209 
210   // iterate over the collected list and post an event for each blob
211   JvmtiCodeBlobDesc* blob = collector.first();
212   while (blob != NULL) {
213     JvmtiExport::post_dynamic_code_generated(env, blob-&gt;name(), blob-&gt;code_begin(), blob-&gt;code_end());
214     blob = collector.next();
215   }
216   return JVMTI_ERROR_NONE;
217 }
218 
219 
220 // Generate a COMPILED_METHOD_LOAD event for each nnmethod
221 jvmtiError JvmtiCodeBlobEvents::generate_compiled_method_load_events(JvmtiEnv* env) {
222   HandleMark hm;
223 
224   // Walk the CodeCache notifying for live nmethods.  The code cache
225   // may be changing while this is happening which is ok since newly
226   // created nmethod will notify normally and nmethods which are freed
227   // can be safely skipped.
228   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
229   // Iterate over non-profiled and profiled nmethods
230   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
231   while(iter.next()) {
232     nmethod* current = iter.method();
233     // Lock the nmethod so it can&#39;t be freed
234     nmethodLocker nml(current);
235 
236     // Don&#39;t hold the lock over the notify or jmethodID creation
237     MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
238     current-&gt;get_and_cache_jmethod_id();
239     JvmtiExport::post_compiled_method_load(current);
240   }
241   return JVMTI_ERROR_NONE;
242 }
243 
244 
245 // create a C-heap allocated address location map for an nmethod
246 void JvmtiCodeBlobEvents::build_jvmti_addr_location_map(nmethod *nm,
247                                                         jvmtiAddrLocationMap** map_ptr,
248                                                         jint *map_length_ptr)
249 {
250   ResourceMark rm;
251   jvmtiAddrLocationMap* map = NULL;
252   jint map_length = 0;
253 
254 
255   // Generate line numbers using PcDesc and ScopeDesc info
256   methodHandle mh(nm-&gt;method());
257 
258   if (!mh-&gt;is_native()) {
259     PcDesc *pcd;
260     int pcds_in_method;
261 
262     pcds_in_method = (nm-&gt;scopes_pcs_end() - nm-&gt;scopes_pcs_begin());
263     map = NEW_C_HEAP_ARRAY(jvmtiAddrLocationMap, pcds_in_method, mtInternal);
264 
265     address scopes_data = nm-&gt;scopes_data_begin();
266     for( pcd = nm-&gt;scopes_pcs_begin(); pcd &lt; nm-&gt;scopes_pcs_end(); ++pcd ) {
267       ScopeDesc sc0(nm, pcd-&gt;scope_decode_offset(), pcd-&gt;should_reexecute(), pcd-&gt;rethrow_exception(), pcd-&gt;return_oop());
268       ScopeDesc *sd  = &amp;sc0;
269       while( !sd-&gt;is_top() ) { sd = sd-&gt;sender(); }
270       int bci = sd-&gt;bci();
271       if (bci &gt;= 0) {
272         assert(map_length &lt; pcds_in_method, &quot;checking&quot;);
273         map[map_length].start_address = (const void*)pcd-&gt;real_pc(nm);
274         map[map_length].location = bci;
275         ++map_length;
276       }
277     }
278   }
279 
280   *map_ptr = map;
281   *map_length_ptr = map_length;
282 }
    </pre>
  </body>
</html>
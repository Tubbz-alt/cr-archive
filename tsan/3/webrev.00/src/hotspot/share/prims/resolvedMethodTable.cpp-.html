<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/resolvedMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/access.inline.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/symbol.hpp&quot;
 34 #include &quot;oops/weakHandle.inline.hpp&quot;
 35 #include &quot;prims/resolvedMethodTable.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/mutexLocker.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
 39 #include &quot;utilities/hashtable.inline.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 
 42 
 43 oop ResolvedMethodEntry::object() {
 44   return literal().resolve();
 45 }
 46 
 47 oop ResolvedMethodEntry::object_no_keepalive() {
 48   // The AS_NO_KEEPALIVE peeks at the oop without keeping it alive.
 49   // This is dangerous in general but is okay if the loaded oop does
 50   // not leak out past a thread transition where a safepoint can happen.
 51   // A subsequent oop_load without AS_NO_KEEPALIVE (the object() accessor)
 52   // keeps the oop alive before doing so.
 53   return literal().peek();
 54 }
 55 
 56 ResolvedMethodTable::ResolvedMethodTable()
 57   : Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;(_table_size, sizeof(ResolvedMethodEntry)) { }
 58 
 59 oop ResolvedMethodTable::lookup(int index, unsigned int hash, Method* method) {
 60   assert_locked_or_safepoint(ResolvedMethodTable_lock);
 61   for (ResolvedMethodEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
 62     if (p-&gt;hash() == hash) {
 63 
 64       // Peek the object to check if it is the right target.
 65       oop target = p-&gt;object_no_keepalive();
 66 
 67       // The method is in the table as a target already
 68       if (target != NULL &amp;&amp; java_lang_invoke_ResolvedMethodName::vmtarget(target) == method) {
 69         ResourceMark rm;
 70         log_debug(membername, table) (&quot;ResolvedMethod entry found for %s index %d&quot;,
 71                                        method-&gt;name_and_sig_as_C_string(), index);
 72         // The object() accessor makes sure the target object is kept alive before
 73         // leaking out.
 74         return p-&gt;object();
 75       }
 76     }
 77   }
 78   return NULL;
 79 }
 80 
 81 unsigned int ResolvedMethodTable::compute_hash(Method* method) {
 82   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();
 83   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();
 84   return name_hash ^ signature_hash;
 85 }
 86 
 87 
 88 oop ResolvedMethodTable::lookup(Method* method) {
 89   unsigned int hash = compute_hash(method);
 90   int index = hash_to_index(hash);
 91   return lookup(index, hash, method);
 92 }
 93 
 94 oop ResolvedMethodTable::basic_add(Method* method, Handle rmethod_name) {
 95   assert_locked_or_safepoint(ResolvedMethodTable_lock);
 96 
 97   unsigned int hash = compute_hash(method);
 98   int index = hash_to_index(hash);
 99 
100   // One was added while aquiring the lock
101   oop entry = lookup(index, hash, method);
102   if (entry != NULL) {
103     return entry;
104   }
105 
106   ClassLoaderWeakHandle w = ClassLoaderWeakHandle::create(rmethod_name);
107   ResolvedMethodEntry* p = (ResolvedMethodEntry*) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::new_entry(hash, w);
108   Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::add_entry(index, p);
109   ResourceMark rm;
110   log_debug(membername, table) (&quot;ResolvedMethod entry added for %s index %d&quot;,
111                                  method-&gt;name_and_sig_as_C_string(), index);
112   return rmethod_name();
113 }
114 
115 ResolvedMethodTable* ResolvedMethodTable::_the_table = NULL;
116 
117 oop ResolvedMethodTable::find_method(Method* method) {
118   MutexLocker ml(ResolvedMethodTable_lock);
119   oop entry = _the_table-&gt;lookup(method);
120   return entry;
121 }
122 
123 oop ResolvedMethodTable::add_method(const methodHandle&amp; m, Handle resolved_method_name) {
124   MutexLocker ml(ResolvedMethodTable_lock);
125   DEBUG_ONLY(NoSafepointVerifier nsv);
126 
127   Method* method = m();
128   // Check if method has been redefined while taking out ResolvedMethodTable_lock, if so
129   // use new method.  The old method won&#39;t be deallocated because it&#39;s passed in as a Handle.
130   if (method-&gt;is_old()) {
131     // Replace method with redefined version
132     InstanceKlass* holder = method-&gt;method_holder();
133     method = holder-&gt;method_with_idnum(method-&gt;method_idnum());
134     if (method == NULL) {
135       // Replace deleted method with NSME.
136       method = Universe::throw_no_such_method_error();
137     }
138     java_lang_invoke_ResolvedMethodName::set_vmtarget(resolved_method_name(), method);
139   }
140   // Set flag in class to indicate this InstanceKlass has entries in the table
141   // to avoid walking table during redefinition if none of the redefined classes
142   // have any membernames in the table.
143   method-&gt;method_holder()-&gt;set_has_resolved_methods();
144 
145   return _the_table-&gt;basic_add(method, resolved_method_name);
146 }
147 
148 // Removing entries
149 int ResolvedMethodTable::_total_oops_removed = 0;
150 
151 // There are no dead entries at start
152 bool ResolvedMethodTable::_dead_entries = false;
153 
154 void ResolvedMethodTable::trigger_cleanup() {
155   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
156   _dead_entries = true;
157   Service_lock-&gt;notify_all();
158 }
159 
160 // Serially invoke removed unused oops from the table.
161 // This is done by the ServiceThread after being notified on class unloading
162 void ResolvedMethodTable::unlink() {
163   MutexLocker ml(ResolvedMethodTable_lock);
164   int _oops_removed = 0;
165   int _oops_counted = 0;
166   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {
167     ResolvedMethodEntry** p = _the_table-&gt;bucket_addr(i);
168     ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);
169     while (entry != NULL) {
170       _oops_counted++;
171       oop l = entry-&gt;object_no_keepalive();
172       if (l != NULL) {
173         p = entry-&gt;next_addr();
174       } else {
175         // Entry has been removed.
176         _oops_removed++;
177         if (log_is_enabled(Debug, membername, table)) {
178           log_debug(membername, table) (&quot;ResolvedMethod entry removed for index %d&quot;, i);
179         }
180         entry-&gt;literal().release();
181         *p = entry-&gt;next();
182         _the_table-&gt;free_entry(entry);
183       }
184       // get next entry
185       entry = (ResolvedMethodEntry*)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::make_ptr(*p);
186     }
187   }
188   log_debug(membername, table) (&quot;ResolvedMethod entries counted %d removed %d&quot;,
189                                 _oops_counted, _oops_removed);
190   _total_oops_removed += _oops_removed;
191   _dead_entries = false;
192 }
193 
194 #ifndef PRODUCT
195 void ResolvedMethodTable::print() {
196   MutexLocker ml(ResolvedMethodTable_lock);
197   for (int i = 0; i &lt; table_size(); ++i) {
198     ResolvedMethodEntry* entry = bucket(i);
199     while (entry != NULL) {
200       tty-&gt;print(&quot;%d : &quot;, i);
201       oop rmethod_name = entry-&gt;object_no_keepalive();
202       if (rmethod_name != NULL) {
203         rmethod_name-&gt;print();
204         Method* m = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(rmethod_name);
205         m-&gt;print();
206       }
207       entry = entry-&gt;next();
208     }
209   }
210 }
211 #endif // PRODUCT
212 
213 #if INCLUDE_JVMTI
214 // It is called at safepoint only for RedefineClasses
215 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
216   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
217   // For each entry in RMT, change to new method
218   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {
219     for (ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);
220          entry != NULL;
221          entry = entry-&gt;next()) {
222 
223       oop mem_name = entry-&gt;object_no_keepalive();
224       // except ones removed
225       if (mem_name == NULL) {
226         continue;
227       }
228       Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);
229 
230       if (old_method-&gt;is_old()) {
231 
232         Method* new_method = (old_method-&gt;is_deleted()) ?
233                               Universe::throw_no_such_method_error() :
234                               old_method-&gt;get_new_method();
235         java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);
236 
237         ResourceMark rm;
238         if (!(*trace_name_printed)) {
239           log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());
240            *trace_name_printed = true;
241         }
242         log_debug(redefine, class, update, constantpool)
243           (&quot;ResolvedMethod method update: %s(%s)&quot;,
244            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
245       }
246     }
247   }
248 }
249 #endif // INCLUDE_JVMTI
    </pre>
  </body>
</html>
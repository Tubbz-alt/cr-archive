<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnvBase.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnvBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;

  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;

  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;oops/objArrayKlass.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;oops/oopHandle.inline.hpp&quot;
  34 #include &quot;prims/jvmtiEnvBase.hpp&quot;
  35 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  36 #include &quot;prims/jvmtiExtensions.hpp&quot;
  37 #include &quot;prims/jvmtiImpl.hpp&quot;
  38 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  39 #include &quot;prims/jvmtiTagMap.hpp&quot;
  40 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  41 #include &quot;runtime/biasedLocking.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/handles.inline.hpp&quot;
  45 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  46 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/objectMonitor.hpp&quot;
</pre>
<hr />
<pre>
 641   }
 642   return ret;
 643 }
 644 
 645 
 646 
 647 jvmtiError
 648 JvmtiEnvBase::get_current_contended_monitor(JavaThread *calling_thread, JavaThread *java_thread, jobject *monitor_ptr) {
 649 #ifdef ASSERT
 650   uint32_t debug_bits = 0;
 651 #endif
 652   assert((SafepointSynchronize::is_at_safepoint() ||
 653           java_thread-&gt;is_thread_fully_suspended(false, &amp;debug_bits)),
 654          &quot;at safepoint or target thread is suspended&quot;);
 655   oop obj = NULL;
 656   ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 657   if (mon == NULL) {
 658     // thread is not doing an Object.wait() call
 659     mon = java_thread-&gt;current_pending_monitor();
 660     if (mon != NULL) {
<span class="line-modified"> 661       // The thread is trying to enter() or raw_enter() an ObjectMonitor.</span>
 662       obj = (oop)mon-&gt;object();
<span class="line-modified"> 663       // If obj == NULL, then ObjectMonitor is raw which doesn&#39;t count</span>
<span class="line-removed"> 664       // as contended for this API</span>
 665     }
 666     // implied else: no contended ObjectMonitor
 667   } else {
 668     // thread is doing an Object.wait() call
 669     obj = (oop)mon-&gt;object();
 670     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 671   }
 672 
 673   if (obj == NULL) {
 674     *monitor_ptr = NULL;
 675   } else {
 676     HandleMark hm;
 677     Handle     hobj(Thread::current(), obj);
 678     *monitor_ptr = jni_reference(calling_thread, hobj);
 679   }
 680   return JVMTI_ERROR_NONE;
 681 }
 682 
 683 
 684 jvmtiError
</pre>
<hr />
<pre>
 942     oop mirror = JNIHandles::resolve_external_guard(object);
 943     NULL_CHECK(mirror, JVMTI_ERROR_INVALID_OBJECT);
 944     NULL_CHECK(info_ptr, JVMTI_ERROR_NULL_POINTER);
 945 
 946     hobj = Handle(current_thread, mirror);
 947   }
 948 
 949   JavaThread *owning_thread = NULL;
 950   ObjectMonitor *mon = NULL;
 951   jvmtiMonitorUsage ret = {
 952       NULL, 0, 0, NULL, 0, NULL
 953   };
 954 
 955   uint32_t debug_bits = 0;
 956   // first derive the object&#39;s owner and entry_count (if any)
 957   {
 958     // Revoke any biases before querying the mark word
 959     if (at_safepoint) {
 960       BiasedLocking::revoke_at_safepoint(hobj);
 961     } else {
<span class="line-modified"> 962       BiasedLocking::revoke_and_rebias(hobj, false, calling_thread);</span>
 963     }
 964 
 965     address owner = NULL;
 966     {
<span class="line-modified"> 967       markOop mark = hobj()-&gt;mark();</span>
 968 
<span class="line-modified"> 969       if (!mark-&gt;has_monitor()) {</span>
 970         // this object has a lightweight monitor
 971 
<span class="line-modified"> 972         if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 973           owner = (address)mark-&gt;locker(); // save the address of the Lock word</span>
 974         }
 975         // implied else: no owner
 976       } else {
 977         // this object has a heavyweight monitor
<span class="line-modified"> 978         mon = mark-&gt;monitor();</span>
 979 
 980         // The owner field of a heavyweight monitor may be NULL for no
 981         // owner, a JavaThread * or it may still be the address of the
 982         // Lock word in a JavaThread&#39;s stack. A monitor can be inflated
 983         // by a non-owning JavaThread, but only the owning JavaThread
 984         // can change the owner field from the Lock word to the
 985         // JavaThread * and it may not have done that yet.
 986         owner = (address)mon-&gt;owner();
 987       }
 988     }
 989 
 990     if (owner != NULL) {
 991       // Use current thread since function can be called from a
 992       // JavaThread or the VMThread.
 993       ThreadsListHandle tlh;
 994       // This monitor is owned so we have to find the owning JavaThread.
 995       owning_thread = Threads::owning_thread_from_monitor_owner(tlh.list(), owner);
 996       // Cannot assume (owning_thread != NULL) here because this function
 997       // may not have been called at a safepoint and the owning_thread
 998       // might not be suspended.
</pre>
<hr />
<pre>
1065       // we have contending and/or waiting threads
1066       HandleMark hm;
1067       // Use current thread since function can be called from a
1068       // JavaThread or the VMThread.
1069       ThreadsListHandle tlh;
1070       if (nWant &gt; 0) {
1071         // we have contending threads
1072         ResourceMark rm;
1073         // get_pending_threads returns only java thread so we do not need to
1074         // check for non java threads.
1075         GrowableArray&lt;JavaThread*&gt;* wantList = Threads::get_pending_threads(tlh.list(), nWant, (address)mon);
1076         if (wantList-&gt;length() &lt; nWant) {
1077           // robustness: the pending list has gotten smaller
1078           nWant = wantList-&gt;length();
1079         }
1080         for (int i = 0; i &lt; nWant; i++) {
1081           JavaThread *pending_thread = wantList-&gt;at(i);
1082           // If the monitor has no owner, then a non-suspended contending
1083           // thread could potentially change the state of the monitor by
1084           // entering it. The JVM/TI spec doesn&#39;t allow this.
<span class="line-modified">1085           if (owning_thread == NULL &amp;&amp; !at_safepoint &amp;</span>
1086               !pending_thread-&gt;is_thread_fully_suspended(true, &amp;debug_bits)) {
1087             if (ret.owner != NULL) {
1088               destroy_jni_reference(calling_thread, ret.owner);
1089             }
1090             for (int j = 0; j &lt; i; j++) {
1091               destroy_jni_reference(calling_thread, ret.waiters[j]);
1092             }
1093             deallocate((unsigned char*)ret.waiters);
1094             deallocate((unsigned char*)ret.notify_waiters);
1095             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1096           }
1097           Handle th(current_thread, pending_thread-&gt;threadObj());
1098           ret.waiters[i] = (jthread)jni_reference(calling_thread, th);
1099         }
1100       }
1101       if (nWait &gt; 0) {
1102         // we have threads in Object.wait()
1103         int offset = nWant;  // add after any contending threads
1104         ObjectWaiter *waiter = mon-&gt;first_waiter();
1105         for (int i = 0, j = 0; i &lt; nWait; i++) {
</pre>
<hr />
<pre>
1197   jvmtiStackInfo *infop = &amp;(node-&gt;info);
1198   node-&gt;next = head();
1199   set_head(node);
1200   infop-&gt;frame_count = 0;
1201   infop-&gt;thread = jt;
1202 
1203   if (thread_oop != NULL) {
1204     // get most state bits
1205     state = (jint)java_lang_Thread::get_thread_status(thread_oop);
1206   }
1207 
1208   if (thr != NULL) {    // add more state bits if there is a JavaThead to query
1209     // same as is_being_ext_suspended() but without locking
1210     if (thr-&gt;is_ext_suspended() || thr-&gt;is_external_suspend()) {
1211       state |= JVMTI_THREAD_STATE_SUSPENDED;
1212     }
1213     JavaThreadState jts = thr-&gt;thread_state();
1214     if (jts == _thread_in_native) {
1215       state |= JVMTI_THREAD_STATE_IN_NATIVE;
1216     }
<span class="line-modified">1217     OSThread* osThread = thr-&gt;osthread();</span>
<span class="line-removed">1218     if (osThread != NULL &amp;&amp; osThread-&gt;interrupted()) {</span>
1219       state |= JVMTI_THREAD_STATE_INTERRUPTED;
1220     }
1221   }
1222   infop-&gt;state = state;
1223 
1224   if (thr != NULL &amp;&amp; (state &amp; JVMTI_THREAD_STATE_ALIVE) != 0) {
1225     infop-&gt;frame_buffer = NEW_RESOURCE_ARRAY(jvmtiFrameInfo, max_frame_count());
1226     env()-&gt;get_stack_trace(thr, 0, max_frame_count(),
1227                            infop-&gt;frame_buffer, &amp;(infop-&gt;frame_count));
1228   } else {
1229     infop-&gt;frame_buffer = NULL;
1230     infop-&gt;frame_count = 0;
1231   }
1232   _frame_count_total += infop-&gt;frame_count;
1233 }
1234 
1235 // Based on the stack information in the linked list, allocate memory
1236 // block to return and fill it from the info in the linked list.
1237 void
1238 VM_GetMultipleStackTraces::allocate_and_fill_stacks(jint thread_count) {
</pre>
<hr />
<pre>
1344   // Get information about method return type
1345   Symbol* signature = jvf-&gt;method()-&gt;signature();
1346 
1347   ResultTypeFinder rtf(signature);
1348   TosState fr_tos = as_TosState(rtf.type());
1349   if (fr_tos != tos) {
1350     if (tos != itos || (fr_tos != btos &amp;&amp; fr_tos != ztos &amp;&amp; fr_tos != ctos &amp;&amp; fr_tos != stos)) {
1351       return JVMTI_ERROR_TYPE_MISMATCH;
1352     }
1353   }
1354 
1355   // Check that the jobject class matches the return type signature.
1356   jobject jobj = value.l;
1357   if (tos == atos &amp;&amp; jobj != NULL) { // NULL reference is allowed
1358     Handle ob_h(current_thread, JNIHandles::resolve_external_guard(jobj));
1359     NULL_CHECK(ob_h, JVMTI_ERROR_INVALID_OBJECT);
1360     Klass* ob_k = ob_h()-&gt;klass();
1361     NULL_CHECK(ob_k, JVMTI_ERROR_INVALID_OBJECT);
1362 
1363     // Method return type signature.
<span class="line-modified">1364     char* ty_sign = 1 + strchr(signature-&gt;as_C_string(), &#39;)&#39;);</span>
1365 
1366     if (!VM_GetOrSetLocal::is_assignable(ty_sign, ob_k, current_thread)) {
1367       return JVMTI_ERROR_TYPE_MISMATCH;
1368     }
1369     *ret_ob_h = ob_h;
1370   }
1371   return JVMTI_ERROR_NONE;
1372 } /* end check_top_frame */
1373 
1374 
1375 // ForceEarlyReturn&lt;type&gt; follows the PopFrame approach in many aspects.
1376 // Main difference is on the last stage in the interpreter.
1377 // The PopFrame stops method execution to continue execution
1378 // from the same method call instruction.
1379 // The ForceEarlyReturn forces return from method so the execution
1380 // continues at the bytecode following the method call.
1381 
1382 // Threads_lock NOT held, java_thread not protected by lock
1383 // java_thread - pre-checked
1384 
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
<span class="line-added">  27 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
<span class="line-added">  30 #include &quot;memory/iterator.hpp&quot;</span>
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;oops/objArrayKlass.hpp&quot;
  33 #include &quot;oops/objArrayOop.hpp&quot;
  34 #include &quot;oops/oop.inline.hpp&quot;
  35 #include &quot;oops/oopHandle.inline.hpp&quot;
  36 #include &quot;prims/jvmtiEnvBase.hpp&quot;
  37 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  38 #include &quot;prims/jvmtiExtensions.hpp&quot;
  39 #include &quot;prims/jvmtiImpl.hpp&quot;
  40 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  41 #include &quot;prims/jvmtiTagMap.hpp&quot;
  42 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  43 #include &quot;runtime/biasedLocking.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/objectMonitor.hpp&quot;
</pre>
<hr />
<pre>
 643   }
 644   return ret;
 645 }
 646 
 647 
 648 
 649 jvmtiError
 650 JvmtiEnvBase::get_current_contended_monitor(JavaThread *calling_thread, JavaThread *java_thread, jobject *monitor_ptr) {
 651 #ifdef ASSERT
 652   uint32_t debug_bits = 0;
 653 #endif
 654   assert((SafepointSynchronize::is_at_safepoint() ||
 655           java_thread-&gt;is_thread_fully_suspended(false, &amp;debug_bits)),
 656          &quot;at safepoint or target thread is suspended&quot;);
 657   oop obj = NULL;
 658   ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 659   if (mon == NULL) {
 660     // thread is not doing an Object.wait() call
 661     mon = java_thread-&gt;current_pending_monitor();
 662     if (mon != NULL) {
<span class="line-modified"> 663       // The thread is trying to enter() an ObjectMonitor.</span>
 664       obj = (oop)mon-&gt;object();
<span class="line-modified"> 665       assert(obj != NULL, &quot;ObjectMonitor should have a valid object!&quot;);</span>

 666     }
 667     // implied else: no contended ObjectMonitor
 668   } else {
 669     // thread is doing an Object.wait() call
 670     obj = (oop)mon-&gt;object();
 671     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 672   }
 673 
 674   if (obj == NULL) {
 675     *monitor_ptr = NULL;
 676   } else {
 677     HandleMark hm;
 678     Handle     hobj(Thread::current(), obj);
 679     *monitor_ptr = jni_reference(calling_thread, hobj);
 680   }
 681   return JVMTI_ERROR_NONE;
 682 }
 683 
 684 
 685 jvmtiError
</pre>
<hr />
<pre>
 943     oop mirror = JNIHandles::resolve_external_guard(object);
 944     NULL_CHECK(mirror, JVMTI_ERROR_INVALID_OBJECT);
 945     NULL_CHECK(info_ptr, JVMTI_ERROR_NULL_POINTER);
 946 
 947     hobj = Handle(current_thread, mirror);
 948   }
 949 
 950   JavaThread *owning_thread = NULL;
 951   ObjectMonitor *mon = NULL;
 952   jvmtiMonitorUsage ret = {
 953       NULL, 0, 0, NULL, 0, NULL
 954   };
 955 
 956   uint32_t debug_bits = 0;
 957   // first derive the object&#39;s owner and entry_count (if any)
 958   {
 959     // Revoke any biases before querying the mark word
 960     if (at_safepoint) {
 961       BiasedLocking::revoke_at_safepoint(hobj);
 962     } else {
<span class="line-modified"> 963       BiasedLocking::revoke(hobj, calling_thread);</span>
 964     }
 965 
 966     address owner = NULL;
 967     {
<span class="line-modified"> 968       markWord mark = hobj()-&gt;mark();</span>
 969 
<span class="line-modified"> 970       if (!mark.has_monitor()) {</span>
 971         // this object has a lightweight monitor
 972 
<span class="line-modified"> 973         if (mark.has_locker()) {</span>
<span class="line-modified"> 974           owner = (address)mark.locker(); // save the address of the Lock word</span>
 975         }
 976         // implied else: no owner
 977       } else {
 978         // this object has a heavyweight monitor
<span class="line-modified"> 979         mon = mark.monitor();</span>
 980 
 981         // The owner field of a heavyweight monitor may be NULL for no
 982         // owner, a JavaThread * or it may still be the address of the
 983         // Lock word in a JavaThread&#39;s stack. A monitor can be inflated
 984         // by a non-owning JavaThread, but only the owning JavaThread
 985         // can change the owner field from the Lock word to the
 986         // JavaThread * and it may not have done that yet.
 987         owner = (address)mon-&gt;owner();
 988       }
 989     }
 990 
 991     if (owner != NULL) {
 992       // Use current thread since function can be called from a
 993       // JavaThread or the VMThread.
 994       ThreadsListHandle tlh;
 995       // This monitor is owned so we have to find the owning JavaThread.
 996       owning_thread = Threads::owning_thread_from_monitor_owner(tlh.list(), owner);
 997       // Cannot assume (owning_thread != NULL) here because this function
 998       // may not have been called at a safepoint and the owning_thread
 999       // might not be suspended.
</pre>
<hr />
<pre>
1066       // we have contending and/or waiting threads
1067       HandleMark hm;
1068       // Use current thread since function can be called from a
1069       // JavaThread or the VMThread.
1070       ThreadsListHandle tlh;
1071       if (nWant &gt; 0) {
1072         // we have contending threads
1073         ResourceMark rm;
1074         // get_pending_threads returns only java thread so we do not need to
1075         // check for non java threads.
1076         GrowableArray&lt;JavaThread*&gt;* wantList = Threads::get_pending_threads(tlh.list(), nWant, (address)mon);
1077         if (wantList-&gt;length() &lt; nWant) {
1078           // robustness: the pending list has gotten smaller
1079           nWant = wantList-&gt;length();
1080         }
1081         for (int i = 0; i &lt; nWant; i++) {
1082           JavaThread *pending_thread = wantList-&gt;at(i);
1083           // If the monitor has no owner, then a non-suspended contending
1084           // thread could potentially change the state of the monitor by
1085           // entering it. The JVM/TI spec doesn&#39;t allow this.
<span class="line-modified">1086           if (owning_thread == NULL &amp;&amp; !at_safepoint &amp;&amp;</span>
1087               !pending_thread-&gt;is_thread_fully_suspended(true, &amp;debug_bits)) {
1088             if (ret.owner != NULL) {
1089               destroy_jni_reference(calling_thread, ret.owner);
1090             }
1091             for (int j = 0; j &lt; i; j++) {
1092               destroy_jni_reference(calling_thread, ret.waiters[j]);
1093             }
1094             deallocate((unsigned char*)ret.waiters);
1095             deallocate((unsigned char*)ret.notify_waiters);
1096             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1097           }
1098           Handle th(current_thread, pending_thread-&gt;threadObj());
1099           ret.waiters[i] = (jthread)jni_reference(calling_thread, th);
1100         }
1101       }
1102       if (nWait &gt; 0) {
1103         // we have threads in Object.wait()
1104         int offset = nWant;  // add after any contending threads
1105         ObjectWaiter *waiter = mon-&gt;first_waiter();
1106         for (int i = 0, j = 0; i &lt; nWait; i++) {
</pre>
<hr />
<pre>
1198   jvmtiStackInfo *infop = &amp;(node-&gt;info);
1199   node-&gt;next = head();
1200   set_head(node);
1201   infop-&gt;frame_count = 0;
1202   infop-&gt;thread = jt;
1203 
1204   if (thread_oop != NULL) {
1205     // get most state bits
1206     state = (jint)java_lang_Thread::get_thread_status(thread_oop);
1207   }
1208 
1209   if (thr != NULL) {    // add more state bits if there is a JavaThead to query
1210     // same as is_being_ext_suspended() but without locking
1211     if (thr-&gt;is_ext_suspended() || thr-&gt;is_external_suspend()) {
1212       state |= JVMTI_THREAD_STATE_SUSPENDED;
1213     }
1214     JavaThreadState jts = thr-&gt;thread_state();
1215     if (jts == _thread_in_native) {
1216       state |= JVMTI_THREAD_STATE_IN_NATIVE;
1217     }
<span class="line-modified">1218     if (thr-&gt;is_interrupted(false)) {</span>

1219       state |= JVMTI_THREAD_STATE_INTERRUPTED;
1220     }
1221   }
1222   infop-&gt;state = state;
1223 
1224   if (thr != NULL &amp;&amp; (state &amp; JVMTI_THREAD_STATE_ALIVE) != 0) {
1225     infop-&gt;frame_buffer = NEW_RESOURCE_ARRAY(jvmtiFrameInfo, max_frame_count());
1226     env()-&gt;get_stack_trace(thr, 0, max_frame_count(),
1227                            infop-&gt;frame_buffer, &amp;(infop-&gt;frame_count));
1228   } else {
1229     infop-&gt;frame_buffer = NULL;
1230     infop-&gt;frame_count = 0;
1231   }
1232   _frame_count_total += infop-&gt;frame_count;
1233 }
1234 
1235 // Based on the stack information in the linked list, allocate memory
1236 // block to return and fill it from the info in the linked list.
1237 void
1238 VM_GetMultipleStackTraces::allocate_and_fill_stacks(jint thread_count) {
</pre>
<hr />
<pre>
1344   // Get information about method return type
1345   Symbol* signature = jvf-&gt;method()-&gt;signature();
1346 
1347   ResultTypeFinder rtf(signature);
1348   TosState fr_tos = as_TosState(rtf.type());
1349   if (fr_tos != tos) {
1350     if (tos != itos || (fr_tos != btos &amp;&amp; fr_tos != ztos &amp;&amp; fr_tos != ctos &amp;&amp; fr_tos != stos)) {
1351       return JVMTI_ERROR_TYPE_MISMATCH;
1352     }
1353   }
1354 
1355   // Check that the jobject class matches the return type signature.
1356   jobject jobj = value.l;
1357   if (tos == atos &amp;&amp; jobj != NULL) { // NULL reference is allowed
1358     Handle ob_h(current_thread, JNIHandles::resolve_external_guard(jobj));
1359     NULL_CHECK(ob_h, JVMTI_ERROR_INVALID_OBJECT);
1360     Klass* ob_k = ob_h()-&gt;klass();
1361     NULL_CHECK(ob_k, JVMTI_ERROR_INVALID_OBJECT);
1362 
1363     // Method return type signature.
<span class="line-modified">1364     char* ty_sign = 1 + strchr(signature-&gt;as_C_string(), JVM_SIGNATURE_ENDFUNC);</span>
1365 
1366     if (!VM_GetOrSetLocal::is_assignable(ty_sign, ob_k, current_thread)) {
1367       return JVMTI_ERROR_TYPE_MISMATCH;
1368     }
1369     *ret_ob_h = ob_h;
1370   }
1371   return JVMTI_ERROR_NONE;
1372 } /* end check_top_frame */
1373 
1374 
1375 // ForceEarlyReturn&lt;type&gt; follows the PopFrame approach in many aspects.
1376 // Main difference is on the last stage in the interpreter.
1377 // The PopFrame stops method execution to continue execution
1378 // from the same method call instruction.
1379 // The ForceEarlyReturn forces return from method so the execution
1380 // continues at the bytecode following the method call.
1381 
1382 // Threads_lock NOT held, java_thread not protected by lock
1383 // java_thread - pre-checked
1384 
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
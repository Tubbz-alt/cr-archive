<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/resolvedMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
<a name="1" id="anc1"></a>

 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
 30 #include &quot;oops/access.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 31 #include &quot;oops/oop.inline.hpp&quot;</span>
 32 #include &quot;oops/method.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 33 #include &quot;oops/symbol.hpp&quot;</span>
 34 #include &quot;oops/weakHandle.inline.hpp&quot;
 35 #include &quot;prims/resolvedMethodTable.hpp&quot;
<a name="5" id="anc5"></a>
 36 #include &quot;runtime/handles.inline.hpp&quot;
<a name="6" id="anc6"></a>
 37 #include &quot;runtime/mutexLocker.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
<a name="7" id="anc7"></a><span class="line-modified"> 39 #include &quot;utilities/hashtable.inline.hpp&quot;</span>


 40 #include &quot;utilities/macros.hpp&quot;
 41 
<a name="8" id="anc8"></a>



 42 
<a name="9" id="anc9"></a><span class="line-modified"> 43 oop ResolvedMethodEntry::object() {</span>
<span class="line-removed"> 44   return literal().resolve();</span>
<span class="line-removed"> 45 }</span>
 46 
<a name="10" id="anc10"></a><span class="line-modified"> 47 oop ResolvedMethodEntry::object_no_keepalive() {</span>
<span class="line-modified"> 48   // The AS_NO_KEEPALIVE peeks at the oop without keeping it alive.</span>
<span class="line-modified"> 49   // This is dangerous in general but is okay if the loaded oop does</span>
<span class="line-modified"> 50   // not leak out past a thread transition where a safepoint can happen.</span>
<span class="line-removed"> 51   // A subsequent oop_load without AS_NO_KEEPALIVE (the object() accessor)</span>
<span class="line-removed"> 52   // keeps the oop alive before doing so.</span>
<span class="line-removed"> 53   return literal().peek();</span>
 54 }
 55 
<a name="11" id="anc11"></a><span class="line-modified"> 56 ResolvedMethodTable::ResolvedMethodTable()</span>
<span class="line-modified"> 57   : Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;(_table_size, sizeof(ResolvedMethodEntry)) { }</span>
 58 
<a name="12" id="anc12"></a><span class="line-modified"> 59 oop ResolvedMethodTable::lookup(int index, unsigned int hash, Method* method) {</span>
<span class="line-modified"> 60   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>
<span class="line-modified"> 61   for (ResolvedMethodEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {</span>
<span class="line-modified"> 62     if (p-&gt;hash() == hash) {</span>
 63 
<a name="13" id="anc13"></a><span class="line-modified"> 64       // Peek the object to check if it is the right target.</span>
<span class="line-modified"> 65       oop target = p-&gt;object_no_keepalive();</span>
<span class="line-modified"> 66 </span>
<span class="line-modified"> 67       // The method is in the table as a target already</span>
<span class="line-modified"> 68       if (target != NULL &amp;&amp; java_lang_invoke_ResolvedMethodName::vmtarget(target) == method) {</span>
<span class="line-removed"> 69         ResourceMark rm;</span>
<span class="line-removed"> 70         log_debug(membername, table) (&quot;ResolvedMethod entry found for %s index %d&quot;,</span>
<span class="line-removed"> 71                                        method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="line-removed"> 72         // The object() accessor makes sure the target object is kept alive before</span>
<span class="line-removed"> 73         // leaking out.</span>
<span class="line-removed"> 74         return p-&gt;object();</span>
<span class="line-removed"> 75       }</span>
 76     }
<a name="14" id="anc14"></a>


 77   }
<a name="15" id="anc15"></a><span class="line-removed"> 78   return NULL;</span>
<span class="line-removed"> 79 }</span>
 80 
<a name="16" id="anc16"></a><span class="line-modified"> 81 unsigned int ResolvedMethodTable::compute_hash(Method* method) {</span>
<span class="line-modified"> 82   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="line-modified"> 83   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="line-modified"> 84   return name_hash ^ signature_hash;</span>
<span class="line-modified"> 85 }</span>









 86 
<a name="17" id="anc17"></a>
 87 
<a name="18" id="anc18"></a><span class="line-modified"> 88 oop ResolvedMethodTable::lookup(Method* method) {</span>
<span class="line-modified"> 89   unsigned int hash = compute_hash(method);</span>
<span class="line-modified"> 90   int index = hash_to_index(hash);</span>
<span class="line-modified"> 91   return lookup(index, hash, method);</span>



 92 }
 93 
<a name="19" id="anc19"></a><span class="line-modified"> 94 oop ResolvedMethodTable::basic_add(Method* method, Handle rmethod_name) {</span>
<span class="line-modified"> 95   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>

 96 
<a name="20" id="anc20"></a><span class="line-modified"> 97   unsigned int hash = compute_hash(method);</span>
<span class="line-modified"> 98   int index = hash_to_index(hash);</span>




 99 
<a name="21" id="anc21"></a><span class="line-modified">100   // One was added while aquiring the lock</span>
<span class="line-modified">101   oop entry = lookup(index, hash, method);</span>
<span class="line-modified">102   if (entry != NULL) {</span>
<span class="line-modified">103     return entry;</span>


104   }
<a name="22" id="anc22"></a>















105 
<a name="23" id="anc23"></a><span class="line-removed">106   ClassLoaderWeakHandle w = ClassLoaderWeakHandle::create(rmethod_name);</span>
<span class="line-removed">107   ResolvedMethodEntry* p = (ResolvedMethodEntry*) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::new_entry(hash, w);</span>
<span class="line-removed">108   Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::add_entry(index, p);</span>
<span class="line-removed">109   ResourceMark rm;</span>
<span class="line-removed">110   log_debug(membername, table) (&quot;ResolvedMethod entry added for %s index %d&quot;,</span>
<span class="line-removed">111                                  method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="line-removed">112   return rmethod_name();</span>
<span class="line-removed">113 }</span>
114 
<a name="24" id="anc24"></a><span class="line-modified">115 ResolvedMethodTable* ResolvedMethodTable::_the_table = NULL;</span>

































116 
<a name="25" id="anc25"></a><span class="line-modified">117 oop ResolvedMethodTable::find_method(Method* method) {</span>
<span class="line-modified">118   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">119   oop entry = _the_table-&gt;lookup(method);</span>
<span class="line-modified">120   return entry;</span>



121 }
122 
<a name="26" id="anc26"></a><span class="line-modified">123 oop ResolvedMethodTable::add_method(const methodHandle&amp; m, Handle resolved_method_name) {</span>
<span class="line-modified">124   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">125   DEBUG_ONLY(NoSafepointVerifier nsv);</span>


126 
<a name="27" id="anc27"></a><span class="line-modified">127   Method* method = m();</span>
<span class="line-modified">128   // Check if method has been redefined while taking out ResolvedMethodTable_lock, if so</span>
<span class="line-modified">129   // use new method.  The old method won&#39;t be deallocated because it&#39;s passed in as a Handle.</span>
<span class="line-modified">130   if (method-&gt;is_old()) {</span>
<span class="line-modified">131     // Replace method with redefined version</span>
<span class="line-modified">132     InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-modified">133     method = holder-&gt;method_with_idnum(method-&gt;method_idnum());</span>
<span class="line-modified">134     if (method == NULL) {</span>
<span class="line-modified">135       // Replace deleted method with NSME.</span>
<span class="line-removed">136       method = Universe::throw_no_such_method_error();</span>
137     }
<a name="28" id="anc28"></a><span class="line-removed">138     java_lang_invoke_ResolvedMethodName::set_vmtarget(resolved_method_name(), method);</span>
139   }
<a name="29" id="anc29"></a><span class="line-modified">140   // Set flag in class to indicate this InstanceKlass has entries in the table</span>
<span class="line-modified">141   // to avoid walking table during redefinition if none of the redefined classes</span>
<span class="line-modified">142   // have any membernames in the table.</span>
<span class="line-modified">143   method-&gt;method_holder()-&gt;set_has_resolved_methods();</span>

144 
<a name="30" id="anc30"></a><span class="line-modified">145   return _the_table-&gt;basic_add(method, resolved_method_name);</span>


146 }
147 
<a name="31" id="anc31"></a><span class="line-modified">148 // Removing entries</span>
<span class="line-modified">149 int ResolvedMethodTable::_total_oops_removed = 0;</span>

150 
<a name="32" id="anc32"></a><span class="line-modified">151 // There are no dead entries at start</span>
<span class="line-modified">152 bool ResolvedMethodTable::_dead_entries = false;</span>

153 
<a name="33" id="anc33"></a><span class="line-modified">154 void ResolvedMethodTable::trigger_cleanup() {</span>
<span class="line-modified">155   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">156   _dead_entries = true;</span>























157   Service_lock-&gt;notify_all();
158 }
159 
<a name="34" id="anc34"></a><span class="line-modified">160 // Serially invoke removed unused oops from the table.</span>
<span class="line-modified">161 // This is done by the ServiceThread after being notified on class unloading</span>
<span class="line-modified">162 void ResolvedMethodTable::unlink() {</span>
<span class="line-modified">163   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">164   int _oops_removed = 0;</span>
<span class="line-modified">165   int _oops_counted = 0;</span>
<span class="line-modified">166   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="line-modified">167     ResolvedMethodEntry** p = _the_table-&gt;bucket_addr(i);</span>
<span class="line-modified">168     ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="line-modified">169     while (entry != NULL) {</span>
<span class="line-modified">170       _oops_counted++;</span>
<span class="line-modified">171       oop l = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">172       if (l != NULL) {</span>
<span class="line-modified">173         p = entry-&gt;next_addr();</span>
<span class="line-modified">174       } else {</span>
<span class="line-modified">175         // Entry has been removed.</span>
<span class="line-modified">176         _oops_removed++;</span>
<span class="line-modified">177         if (log_is_enabled(Debug, membername, table)) {</span>
<span class="line-modified">178           log_debug(membername, table) (&quot;ResolvedMethod entry removed for index %d&quot;, i);</span>
<span class="line-modified">179         }</span>
<span class="line-modified">180         entry-&gt;literal().release();</span>
<span class="line-modified">181         *p = entry-&gt;next();</span>
<span class="line-modified">182         _the_table-&gt;free_entry(entry);</span>

183       }
<a name="35" id="anc35"></a><span class="line-modified">184       // get next entry</span>
<span class="line-modified">185       entry = (ResolvedMethodEntry*)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::make_ptr(*p);</span>
























186     }
187   }
<a name="36" id="anc36"></a><span class="line-modified">188   log_debug(membername, table) (&quot;ResolvedMethod entries counted %d removed %d&quot;,</span>
<span class="line-modified">189                                 _oops_counted, _oops_removed);</span>
<span class="line-modified">190   _total_oops_removed += _oops_removed;</span>
<span class="line-modified">191   _dead_entries = false;</span>
<span class="line-modified">192 }</span>
<span class="line-modified">193 </span>
<span class="line-modified">194 #ifndef PRODUCT</span>
<span class="line-modified">195 void ResolvedMethodTable::print() {</span>
<span class="line-modified">196   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="line-modified">197   for (int i = 0; i &lt; table_size(); ++i) {</span>
<span class="line-modified">198     ResolvedMethodEntry* entry = bucket(i);</span>
<span class="line-modified">199     while (entry != NULL) {</span>
<span class="line-modified">200       tty-&gt;print(&quot;%d : &quot;, i);</span>
<span class="line-modified">201       oop rmethod_name = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">202       if (rmethod_name != NULL) {</span>
<span class="line-removed">203         rmethod_name-&gt;print();</span>
<span class="line-removed">204         Method* m = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(rmethod_name);</span>
<span class="line-removed">205         m-&gt;print();</span>
206       }
<a name="37" id="anc37"></a><span class="line-modified">207       entry = entry-&gt;next();</span>
208     }
<a name="38" id="anc38"></a>
209   }
<a name="39" id="anc39"></a>
















210 }
<a name="40" id="anc40"></a><span class="line-removed">211 #endif // PRODUCT</span>
212 
213 #if INCLUDE_JVMTI
<a name="41" id="anc41"></a>

































214 // It is called at safepoint only for RedefineClasses
215 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
216   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
217   // For each entry in RMT, change to new method
<a name="42" id="anc42"></a><span class="line-modified">218   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="line-modified">219     for (ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="line-modified">220          entry != NULL;</span>
<span class="line-modified">221          entry = entry-&gt;next()) {</span>
<span class="line-modified">222 </span>
<span class="line-modified">223       oop mem_name = entry-&gt;object_no_keepalive();</span>
<span class="line-modified">224       // except ones removed</span>
<span class="line-modified">225       if (mem_name == NULL) {</span>
<span class="line-modified">226         continue;</span>
<span class="line-modified">227       }</span>
<span class="line-modified">228       Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="line-modified">229 </span>
<span class="line-modified">230       if (old_method-&gt;is_old()) {</span>
<span class="line-modified">231 </span>
<span class="line-removed">232         Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="line-removed">233                               Universe::throw_no_such_method_error() :</span>
<span class="line-removed">234                               old_method-&gt;get_new_method();</span>
<span class="line-removed">235         java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="line-removed">236 </span>
<span class="line-removed">237         ResourceMark rm;</span>
<span class="line-removed">238         if (!(*trace_name_printed)) {</span>
<span class="line-removed">239           log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-removed">240            *trace_name_printed = true;</span>
<span class="line-removed">241         }</span>
<span class="line-removed">242         log_debug(redefine, class, update, constantpool)</span>
<span class="line-removed">243           (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="line-removed">244            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="line-removed">245       }</span>
246     }
<a name="43" id="anc43"></a>











247   }
248 }
<a name="44" id="anc44"></a><span class="line-removed">249 #endif // INCLUDE_JVMTI</span>
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
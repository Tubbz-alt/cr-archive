<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
334   jint length;
335   unsigned char data[1];
336 };
337 
338 class VM_RedefineClasses: public VM_Operation {
339  private:
340   // These static fields are needed by ClassLoaderDataGraph::classes_do()
341   // facility and the CheckClass and AdjustAndCleanMetadata helpers.
342   static Array&lt;Method*&gt;* _old_methods;
343   static Array&lt;Method*&gt;* _new_methods;
344   static Method**        _matching_old_methods;
345   static Method**        _matching_new_methods;
346   static Method**        _deleted_methods;
347   static Method**        _added_methods;
348   static int             _matching_methods_length;
349   static int             _deleted_methods_length;
350   static int             _added_methods_length;
351   static bool            _has_redefined_Object;
352   static bool            _has_null_class_loader;
353 



354   // The instance fields are used to pass information from
355   // doit_prologue() to doit() and doit_epilogue().
356   Klass*                      _the_class;
357   jint                        _class_count;
358   const jvmtiClassDefinition *_class_defs;  // ptr to _class_count defs
359 
360   // This operation is used by both RedefineClasses and
361   // RetransformClasses.  Indicate which.
362   JvmtiClassLoadKind          _class_load_kind;
363 
364   // _index_map_count is just an optimization for knowing if
365   // _index_map_p contains any entries.
366   int                         _index_map_count;
367   intArray *                  _index_map_p;
368 
369   // _operands_index_map_count is just an optimization for knowing if
370   // _operands_index_map_p contains any entries.
371   int                         _operands_cur_length;
372   int                         _operands_index_map_count;
373   intArray *                  _operands_index_map_p;
374 
375   // ptr to _class_count scratch_classes
376   InstanceKlass**             _scratch_classes;
377   jvmtiError                  _res;
378 
379   // Set if any of the InstanceKlasses have entries in the ResolvedMethodTable
380   // to avoid walking after redefinition if the redefined classes do not
381   // have any entries.
382   bool _any_class_has_resolved_methods;
383 
384   // Performance measurement support. These timers do not cover all
385   // the work done for JVM/TI RedefineClasses() but they do cover
386   // the heavy lifting.
387   elapsedTimer  _timer_rsc_phase1;
388   elapsedTimer  _timer_rsc_phase2;
389   elapsedTimer  _timer_vm_op_prologue;
390 



391   // These routines are roughly in call order unless otherwise noted.
392 
393   // Load the caller&#39;s new class definition(s) into _scratch_classes.
394   // Constant pool merging work is done here as needed. Also calls
395   // compare_and_normalize_class_versions() to verify the class
396   // definition(s).
397   jvmtiError load_new_class_versions(TRAPS);
398 
399   // Verify that the caller provided class definition(s) that meet
400   // the restrictions of RedefineClasses. Normalize the order of
401   // overloaded methods as needed.
402   jvmtiError compare_and_normalize_class_versions(
403     InstanceKlass* the_class, InstanceKlass* scratch_class);
404 
405   // Figure out which new methods match old methods in name and signature,
406   // which methods have been added, and which are no longer present
407   void compute_added_deleted_matching_methods();
408 
409   // Change jmethodIDs to point to the new methods
<span class="line-modified">410   void update_jmethod_ids();</span>
411 
412   // In addition to marking methods as old and/or obsolete, this routine
413   // counts the number of methods that are EMCP (Equivalent Module Constant Pool).
414   int check_methods_and_mark_as_obsolete();
415   void transfer_old_native_function_registrations(InstanceKlass* the_class);
416 
417   // Install the redefinition of a class
418   void redefine_single_class(jclass the_jclass,
419     InstanceKlass* scratch_class_oop, TRAPS);
420 
421   void swap_annotations(InstanceKlass* new_class,
422                         InstanceKlass* scratch_class);
423 
424   // Increment the classRedefinedCount field in the specific InstanceKlass
425   // and in all direct and indirect subclasses.
426   void increment_class_counter(InstanceKlass *ik, TRAPS);
427 
428   // Support for constant pool merging (these routines are in alpha order):
429   void append_entry(const constantPoolHandle&amp; scratch_cp, int scratch_i,
430     constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
</pre>
<hr />
<pre>
455   bool rewrite_cp_refs_in_annotations_typeArray(
456     AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS);
457   bool rewrite_cp_refs_in_class_annotations(
458     InstanceKlass* scratch_class, TRAPS);
459   bool rewrite_cp_refs_in_element_value(
460     AnnotationArray* class_annotations, int &amp;byte_i_ref, TRAPS);
461   bool rewrite_cp_refs_in_type_annotations_typeArray(
462     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
463     const char * location_mesg, TRAPS);
464   bool rewrite_cp_refs_in_type_annotation_struct(
465     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
466     const char * location_mesg, TRAPS);
467   bool skip_type_annotation_target(
468     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
469     const char * location_mesg, TRAPS);
470   bool skip_type_annotation_type_path(
471     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS);
472   bool rewrite_cp_refs_in_fields_annotations(
473     InstanceKlass* scratch_class, TRAPS);
474   bool rewrite_cp_refs_in_nest_attributes(InstanceKlass* scratch_class);

475   void rewrite_cp_refs_in_method(methodHandle method,
476     methodHandle * new_method_p, TRAPS);
477   bool rewrite_cp_refs_in_methods(InstanceKlass* scratch_class, TRAPS);
478   bool rewrite_cp_refs_in_methods_annotations(
479     InstanceKlass* scratch_class, TRAPS);
480   bool rewrite_cp_refs_in_methods_default_annotations(
481     InstanceKlass* scratch_class, TRAPS);
482   bool rewrite_cp_refs_in_methods_parameter_annotations(
483     InstanceKlass* scratch_class, TRAPS);
484   bool rewrite_cp_refs_in_class_type_annotations(
485     InstanceKlass* scratch_class, TRAPS);
486   bool rewrite_cp_refs_in_fields_type_annotations(
487     InstanceKlass* scratch_class, TRAPS);
488   bool rewrite_cp_refs_in_methods_type_annotations(
489     InstanceKlass* scratch_class, TRAPS);
490   void rewrite_cp_refs_in_stack_map_table(const methodHandle&amp; method, TRAPS);
491   void rewrite_cp_refs_in_verification_type_info(
492          address&amp; stackmap_addr_ref, address stackmap_end, u2 frame_i,
493          u1 frame_size, TRAPS);
494   void set_new_constant_pool(ClassLoaderData* loader_data,
495          InstanceKlass* scratch_class,
496          constantPoolHandle scratch_cp, int scratch_cp_length, TRAPS);
497 
498   void flush_dependent_code();
499   void mark_dependent_code(InstanceKlass* ik);
500 
501   // lock classes to redefine since constant pool merging isn&#39;t thread safe.
502   void lock_classes();
503   void unlock_classes();
504 


505   static void dump_methods();
506 
507   // Check that there are no old or obsolete methods
508   class CheckClass : public KlassClosure {
509     Thread* _thread;
510    public:
511     CheckClass(Thread* t) : _thread(t) {}
512     void do_klass(Klass* k);
513   };
514 
515   // Unevolving classes may point to methods of the_class directly
516   // from their constant pool caches, itables, and/or vtables. We
517   // use the ClassLoaderDataGraph::classes_do() facility and this helper
518   // to fix up these pointers and clean MethodData out.
519   class AdjustAndCleanMetadata : public KlassClosure {
520     Thread* _thread;
521    public:
522     AdjustAndCleanMetadata(Thread* t) : _thread(t) {}
523     void do_klass(Klass* k);
524   };
525 
526  public:
527   VM_RedefineClasses(jint class_count,
528                      const jvmtiClassDefinition *class_defs,
529                      JvmtiClassLoadKind class_load_kind);
530   VMOp_Type type() const { return VMOp_RedefineClasses; }
531   bool doit_prologue();
532   void doit();
533   void doit_epilogue();
534 
535   bool allow_nested_vm_operations() const        { return true; }
536   jvmtiError check_error()                       { return _res; }

537 
538   // Modifiable test must be shared between IsModifiableClass query
539   // and redefine implementation
540   static bool is_modifiable_class(oop klass_mirror);
541 
542   static jint get_cached_class_file_len(JvmtiCachedClassFileData *cache) {
543     return cache == NULL ? 0 : cache-&gt;length;
544   }
545   static unsigned char * get_cached_class_file_bytes(JvmtiCachedClassFileData *cache) {
546     return cache == NULL ? NULL : cache-&gt;data;
547   }
548 
549   // Error printing
550   void print_on_error(outputStream* st) const;
551 };
552 #endif // SHARE_PRIMS_JVMTIREDEFINECLASSES_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
334   jint length;
335   unsigned char data[1];
336 };
337 
338 class VM_RedefineClasses: public VM_Operation {
339  private:
340   // These static fields are needed by ClassLoaderDataGraph::classes_do()
341   // facility and the CheckClass and AdjustAndCleanMetadata helpers.
342   static Array&lt;Method*&gt;* _old_methods;
343   static Array&lt;Method*&gt;* _new_methods;
344   static Method**        _matching_old_methods;
345   static Method**        _matching_new_methods;
346   static Method**        _deleted_methods;
347   static Method**        _added_methods;
348   static int             _matching_methods_length;
349   static int             _deleted_methods_length;
350   static int             _added_methods_length;
351   static bool            _has_redefined_Object;
352   static bool            _has_null_class_loader;
353 
<span class="line-added">354   // Used by JFR to group class redefininition events together.</span>
<span class="line-added">355   static u8              _id_counter;</span>
<span class="line-added">356 </span>
357   // The instance fields are used to pass information from
358   // doit_prologue() to doit() and doit_epilogue().
359   Klass*                      _the_class;
360   jint                        _class_count;
361   const jvmtiClassDefinition *_class_defs;  // ptr to _class_count defs
362 
363   // This operation is used by both RedefineClasses and
364   // RetransformClasses.  Indicate which.
365   JvmtiClassLoadKind          _class_load_kind;
366 
367   // _index_map_count is just an optimization for knowing if
368   // _index_map_p contains any entries.
369   int                         _index_map_count;
370   intArray *                  _index_map_p;
371 
372   // _operands_index_map_count is just an optimization for knowing if
373   // _operands_index_map_p contains any entries.
374   int                         _operands_cur_length;
375   int                         _operands_index_map_count;
376   intArray *                  _operands_index_map_p;
377 
378   // ptr to _class_count scratch_classes
379   InstanceKlass**             _scratch_classes;
380   jvmtiError                  _res;
381 
382   // Set if any of the InstanceKlasses have entries in the ResolvedMethodTable
383   // to avoid walking after redefinition if the redefined classes do not
384   // have any entries.
385   bool _any_class_has_resolved_methods;
386 
387   // Performance measurement support. These timers do not cover all
388   // the work done for JVM/TI RedefineClasses() but they do cover
389   // the heavy lifting.
390   elapsedTimer  _timer_rsc_phase1;
391   elapsedTimer  _timer_rsc_phase2;
392   elapsedTimer  _timer_vm_op_prologue;
393 
<span class="line-added">394   // Redefinition id used by JFR</span>
<span class="line-added">395   u8 _id;</span>
<span class="line-added">396 </span>
397   // These routines are roughly in call order unless otherwise noted.
398 
399   // Load the caller&#39;s new class definition(s) into _scratch_classes.
400   // Constant pool merging work is done here as needed. Also calls
401   // compare_and_normalize_class_versions() to verify the class
402   // definition(s).
403   jvmtiError load_new_class_versions(TRAPS);
404 
405   // Verify that the caller provided class definition(s) that meet
406   // the restrictions of RedefineClasses. Normalize the order of
407   // overloaded methods as needed.
408   jvmtiError compare_and_normalize_class_versions(
409     InstanceKlass* the_class, InstanceKlass* scratch_class);
410 
411   // Figure out which new methods match old methods in name and signature,
412   // which methods have been added, and which are no longer present
413   void compute_added_deleted_matching_methods();
414 
415   // Change jmethodIDs to point to the new methods
<span class="line-modified">416   void update_jmethod_ids(Thread* thread);</span>
417 
418   // In addition to marking methods as old and/or obsolete, this routine
419   // counts the number of methods that are EMCP (Equivalent Module Constant Pool).
420   int check_methods_and_mark_as_obsolete();
421   void transfer_old_native_function_registrations(InstanceKlass* the_class);
422 
423   // Install the redefinition of a class
424   void redefine_single_class(jclass the_jclass,
425     InstanceKlass* scratch_class_oop, TRAPS);
426 
427   void swap_annotations(InstanceKlass* new_class,
428                         InstanceKlass* scratch_class);
429 
430   // Increment the classRedefinedCount field in the specific InstanceKlass
431   // and in all direct and indirect subclasses.
432   void increment_class_counter(InstanceKlass *ik, TRAPS);
433 
434   // Support for constant pool merging (these routines are in alpha order):
435   void append_entry(const constantPoolHandle&amp; scratch_cp, int scratch_i,
436     constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
</pre>
<hr />
<pre>
461   bool rewrite_cp_refs_in_annotations_typeArray(
462     AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS);
463   bool rewrite_cp_refs_in_class_annotations(
464     InstanceKlass* scratch_class, TRAPS);
465   bool rewrite_cp_refs_in_element_value(
466     AnnotationArray* class_annotations, int &amp;byte_i_ref, TRAPS);
467   bool rewrite_cp_refs_in_type_annotations_typeArray(
468     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
469     const char * location_mesg, TRAPS);
470   bool rewrite_cp_refs_in_type_annotation_struct(
471     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
472     const char * location_mesg, TRAPS);
473   bool skip_type_annotation_target(
474     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
475     const char * location_mesg, TRAPS);
476   bool skip_type_annotation_type_path(
477     AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS);
478   bool rewrite_cp_refs_in_fields_annotations(
479     InstanceKlass* scratch_class, TRAPS);
480   bool rewrite_cp_refs_in_nest_attributes(InstanceKlass* scratch_class);
<span class="line-added">481   bool rewrite_cp_refs_in_record_attribute(InstanceKlass* scratch_class, TRAPS);</span>
482   void rewrite_cp_refs_in_method(methodHandle method,
483     methodHandle * new_method_p, TRAPS);
484   bool rewrite_cp_refs_in_methods(InstanceKlass* scratch_class, TRAPS);
485   bool rewrite_cp_refs_in_methods_annotations(
486     InstanceKlass* scratch_class, TRAPS);
487   bool rewrite_cp_refs_in_methods_default_annotations(
488     InstanceKlass* scratch_class, TRAPS);
489   bool rewrite_cp_refs_in_methods_parameter_annotations(
490     InstanceKlass* scratch_class, TRAPS);
491   bool rewrite_cp_refs_in_class_type_annotations(
492     InstanceKlass* scratch_class, TRAPS);
493   bool rewrite_cp_refs_in_fields_type_annotations(
494     InstanceKlass* scratch_class, TRAPS);
495   bool rewrite_cp_refs_in_methods_type_annotations(
496     InstanceKlass* scratch_class, TRAPS);
497   void rewrite_cp_refs_in_stack_map_table(const methodHandle&amp; method, TRAPS);
498   void rewrite_cp_refs_in_verification_type_info(
499          address&amp; stackmap_addr_ref, address stackmap_end, u2 frame_i,
500          u1 frame_size, TRAPS);
501   void set_new_constant_pool(ClassLoaderData* loader_data,
502          InstanceKlass* scratch_class,
503          constantPoolHandle scratch_cp, int scratch_cp_length, TRAPS);
504 
505   void flush_dependent_code();
506   void mark_dependent_code(InstanceKlass* ik);
507 
508   // lock classes to redefine since constant pool merging isn&#39;t thread safe.
509   void lock_classes();
510   void unlock_classes();
511 
<span class="line-added">512   u8 next_id();</span>
<span class="line-added">513 </span>
514   static void dump_methods();
515 
516   // Check that there are no old or obsolete methods
517   class CheckClass : public KlassClosure {
518     Thread* _thread;
519    public:
520     CheckClass(Thread* t) : _thread(t) {}
521     void do_klass(Klass* k);
522   };
523 
524   // Unevolving classes may point to methods of the_class directly
525   // from their constant pool caches, itables, and/or vtables. We
526   // use the ClassLoaderDataGraph::classes_do() facility and this helper
527   // to fix up these pointers and clean MethodData out.
528   class AdjustAndCleanMetadata : public KlassClosure {
529     Thread* _thread;
530    public:
531     AdjustAndCleanMetadata(Thread* t) : _thread(t) {}
532     void do_klass(Klass* k);
533   };
534 
535  public:
536   VM_RedefineClasses(jint class_count,
537                      const jvmtiClassDefinition *class_defs,
538                      JvmtiClassLoadKind class_load_kind);
539   VMOp_Type type() const { return VMOp_RedefineClasses; }
540   bool doit_prologue();
541   void doit();
542   void doit_epilogue();
543 
544   bool allow_nested_vm_operations() const        { return true; }
545   jvmtiError check_error()                       { return _res; }
<span class="line-added">546   u8 id()                                        { return _id; }</span>
547 
548   // Modifiable test must be shared between IsModifiableClass query
549   // and redefine implementation
550   static bool is_modifiable_class(oop klass_mirror);
551 
552   static jint get_cached_class_file_len(JvmtiCachedClassFileData *cache) {
553     return cache == NULL ? 0 : cache-&gt;length;
554   }
555   static unsigned char * get_cached_class_file_bytes(JvmtiCachedClassFileData *cache) {
556     return cache == NULL ? NULL : cache-&gt;data;
557   }
558 
559   // Error printing
560   void print_on_error(outputStream* st) const;
561 };
562 #endif // SHARE_PRIMS_JVMTIREDEFINECLASSES_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
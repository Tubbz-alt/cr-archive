<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvmtiRawMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #if INCLUDE_TSAN
 33 #include &quot;tsan/tsan.hpp&quot;
 34 #endif  // INCLUDE_TSAN
 35 
 36 GrowableArray&lt;JvmtiRawMonitor*&gt; *JvmtiPendingMonitors::_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1,true);
 37 
 38 void JvmtiPendingMonitors::transition_raw_monitors() {
 39   assert((Threads::number_of_threads()==1),
 40          &quot;Java thread has not created yet or more than one java thread \
 41 is running. Raw monitor transition will not work&quot;);
 42   JavaThread *current_java_thread = JavaThread::current();
 43   assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
 44   {
 45     ThreadBlockInVM __tbivm(current_java_thread);
 46     for(int i=0; i&lt; count(); i++) {
 47       JvmtiRawMonitor *rmonitor = monitors()-&gt;at(i);
 48       int r = rmonitor-&gt;raw_enter(current_java_thread);
 49       assert(r == ObjectMonitor::OM_OK, &quot;raw_enter should have worked&quot;);
 50       TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));
 51     }
 52   }
 53   // pending monitors are converted to real monitor so delete them all.
 54   dispose();
 55 }
 56 
 57 //
 58 // class JvmtiRawMonitor
 59 //
 60 
 61 JvmtiRawMonitor::JvmtiRawMonitor(const char *name) {
 62 #ifdef ASSERT
 63   _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
 64 #else
 65   _name = NULL;
 66 #endif
 67   _magic = JVMTI_RM_MAGIC;
 68 }
 69 
 70 JvmtiRawMonitor::~JvmtiRawMonitor() {
 71 #ifdef ASSERT
 72   FreeHeap(_name);
 73 #endif
 74   _magic = 0;
 75 }
 76 
 77 
 78 bool
 79 JvmtiRawMonitor::is_valid() {
 80   int value = 0;
 81 
 82   // This object might not be a JvmtiRawMonitor so we can&#39;t assume
 83   // the _magic field is properly aligned. Get the value in a safe
 84   // way and then check against JVMTI_RM_MAGIC.
 85 
 86   switch (sizeof(_magic)) {
 87   case 2:
 88     value = Bytes::get_native_u2((address)&amp;_magic);
 89     break;
 90 
 91   case 4:
 92     value = Bytes::get_native_u4((address)&amp;_magic);
 93     break;
 94 
 95   case 8:
 96     value = Bytes::get_native_u8((address)&amp;_magic);
 97     break;
 98 
 99   default:
100     guarantee(false, &quot;_magic field is an unexpected size&quot;);
101   }
102 
103   return value == JVMTI_RM_MAGIC;
104 }
105 
106 // -------------------------------------------------------------------------
107 // The raw monitor subsystem is entirely distinct from normal
108 // java-synchronization or jni-synchronization.  raw monitors are not
109 // associated with objects.  They can be implemented in any manner
110 // that makes sense.  The original implementors decided to piggy-back
111 // the raw-monitor implementation on the existing Java objectMonitor mechanism.
112 // This flaw needs to fixed.  We should reimplement raw monitors as sui-generis.
113 // Specifically, we should not implement raw monitors via java monitors.
114 // Time permitting, we should disentangle and deconvolve the two implementations
115 // and move the resulting raw monitor implementation over to the JVMTI directories.
116 // Ideally, the raw monitor implementation would be built on top of
117 // park-unpark and nothing else.
118 //
119 // raw monitors are used mainly by JVMTI
120 // The raw monitor implementation borrows the ObjectMonitor structure,
121 // but the operators are degenerate and extremely simple.
122 //
123 // Mixed use of a single objectMonitor instance -- as both a raw monitor
124 // and a normal java monitor -- is not permissible.
125 //
126 // Note that we use the single RawMonitor_lock to protect queue operations for
127 // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
128 // is deprecated and rare, this is not of concern.  The RawMonitor_lock can not
129 // be held indefinitely.  The critical sections must be short and bounded.
130 //
131 // -------------------------------------------------------------------------
132 
133 int JvmtiRawMonitor::SimpleEnter (Thread * Self) {
134   for (;;) {
135     if (Atomic::replace_if_null(Self, &amp;_owner)) {
136        return OS_OK ;
137     }
138 
139     ObjectWaiter Node (Self) ;
140     Self-&gt;_ParkEvent-&gt;reset() ;     // strictly optional
141     Node.TState = ObjectWaiter::TS_ENTER ;
142 
143     RawMonitor_lock-&gt;lock_without_safepoint_check() ;
144     Node._next  = _EntryList ;
145     _EntryList  = &amp;Node ;
146     OrderAccess::fence() ;
147     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;_owner)) {
148         _EntryList = Node._next ;
149         RawMonitor_lock-&gt;unlock() ;
150         return OS_OK ;
151     }
152     RawMonitor_lock-&gt;unlock() ;
153     while (Node.TState == ObjectWaiter::TS_ENTER) {
154        Self-&gt;_ParkEvent-&gt;park() ;
155     }
156   }
157 }
158 
159 int JvmtiRawMonitor::SimpleExit (Thread * Self) {
160   guarantee (_owner == Self, &quot;invariant&quot;) ;
161   OrderAccess::release_store(&amp;_owner, (void*)NULL) ;
162   OrderAccess::fence() ;
163   if (_EntryList == NULL) return OS_OK ;
164   ObjectWaiter * w ;
165 
166   RawMonitor_lock-&gt;lock_without_safepoint_check() ;
167   w = _EntryList ;
168   if (w != NULL) {
169       _EntryList = w-&gt;_next ;
170   }
171   RawMonitor_lock-&gt;unlock() ;
172   if (w != NULL) {
173       guarantee (w -&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;
174       ParkEvent * ev = w-&gt;_event ;
175       w-&gt;TState = ObjectWaiter::TS_RUN ;
176       OrderAccess::fence() ;
177       ev-&gt;unpark() ;
178   }
179   return OS_OK ;
180 }
181 
182 int JvmtiRawMonitor::SimpleWait (Thread * Self, jlong millis) {
183   guarantee (_owner == Self  , &quot;invariant&quot;) ;
184   guarantee (_recursions == 0, &quot;invariant&quot;) ;
185 
186   ObjectWaiter Node (Self) ;
187   Node._notified = 0 ;
188   Node.TState    = ObjectWaiter::TS_WAIT ;
189 
190   RawMonitor_lock-&gt;lock_without_safepoint_check() ;
191   Node._next     = _WaitSet ;
192   _WaitSet       = &amp;Node ;
193   RawMonitor_lock-&gt;unlock() ;
194 
195   SimpleExit (Self) ;
196   guarantee (_owner != Self, &quot;invariant&quot;) ;
197 
198   int ret = OS_OK ;
199   if (millis &lt;= 0) {
200     Self-&gt;_ParkEvent-&gt;park();
201   } else {
202     ret = Self-&gt;_ParkEvent-&gt;park(millis);
203   }
204 
205   // If thread still resides on the waitset then unlink it.
206   // Double-checked locking -- the usage is safe in this context
207   // as we TState is volatile and the lock-unlock operators are
208   // serializing (barrier-equivalent).
209 
210   if (Node.TState == ObjectWaiter::TS_WAIT) {
211     RawMonitor_lock-&gt;lock_without_safepoint_check() ;
212     if (Node.TState == ObjectWaiter::TS_WAIT) {
213       // Simple O(n) unlink, but performance isn&#39;t critical here.
214       ObjectWaiter * p ;
215       ObjectWaiter * q = NULL ;
216       for (p = _WaitSet ; p != &amp;Node; p = p-&gt;_next) {
217          q = p ;
218       }
219       guarantee (p == &amp;Node, &quot;invariant&quot;) ;
220       if (q == NULL) {
221         guarantee (p == _WaitSet, &quot;invariant&quot;) ;
222         _WaitSet = p-&gt;_next ;
223       } else {
224         guarantee (p == q-&gt;_next, &quot;invariant&quot;) ;
225         q-&gt;_next = p-&gt;_next ;
226       }
227       Node.TState = ObjectWaiter::TS_RUN ;
228     }
229     RawMonitor_lock-&gt;unlock() ;
230   }
231 
232   guarantee (Node.TState == ObjectWaiter::TS_RUN, &quot;invariant&quot;) ;
233   SimpleEnter (Self) ;
234 
235   guarantee (_owner == Self, &quot;invariant&quot;) ;
236   guarantee (_recursions == 0, &quot;invariant&quot;) ;
237   return ret ;
238 }
239 
240 int JvmtiRawMonitor::SimpleNotify (Thread * Self, bool All) {
241   guarantee (_owner == Self, &quot;invariant&quot;) ;
242   if (_WaitSet == NULL) return OS_OK ;
243 
244   // We have two options:
245   // A. Transfer the threads from the WaitSet to the EntryList
246   // B. Remove the thread from the WaitSet and unpark() it.
247   //
248   // We use (B), which is crude and results in lots of futile
249   // context switching.  In particular (B) induces lots of contention.
250 
251   ParkEvent * ev = NULL ;       // consider using a small auto array ...
252   RawMonitor_lock-&gt;lock_without_safepoint_check() ;
253   for (;;) {
254       ObjectWaiter * w = _WaitSet ;
255       if (w == NULL) break ;
256       _WaitSet = w-&gt;_next ;
257       if (ev != NULL) { ev-&gt;unpark(); ev = NULL; }
258       ev = w-&gt;_event ;
259       OrderAccess::loadstore() ;
260       w-&gt;TState = ObjectWaiter::TS_RUN ;
261       OrderAccess::storeload();
262       if (!All) break ;
263   }
264   RawMonitor_lock-&gt;unlock() ;
265   if (ev != NULL) ev-&gt;unpark();
266   return OS_OK ;
267 }
268 
269 // Any JavaThread will enter here with state _thread_blocked
270 int JvmtiRawMonitor::raw_enter(TRAPS) {
271   void * Contended ;
272 
273   // don&#39;t enter raw monitor if thread is being externally suspended, it will
274   // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
275   JavaThread * jt = (JavaThread *)THREAD;
276   if (THREAD-&gt;is_Java_thread()) {
277     jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
278     while (jt-&gt;is_external_suspend()) {
279       jt-&gt;SR_lock()-&gt;unlock();
280       jt-&gt;java_suspend_self();
281       jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
282     }
283     // guarded by SR_lock to avoid racing with new external suspend requests.
284     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);
285     jt-&gt;SR_lock()-&gt;unlock();
286   } else {
287     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);
288   }
289 
290   if (Contended == THREAD) {
291      _recursions ++ ;
292      return OM_OK ;
293   }
294 
295   if (Contended == NULL) {
296      guarantee (_owner == THREAD, &quot;invariant&quot;) ;
297      guarantee (_recursions == 0, &quot;invariant&quot;) ;
298      return OM_OK ;
299   }
300 
301   THREAD-&gt;set_current_pending_monitor(this);
302 
303   if (!THREAD-&gt;is_Java_thread()) {
304      // No other non-Java threads besides VM thread would acquire
305      // a raw monitor.
306      assert(THREAD-&gt;is_VM_thread(), &quot;must be VM thread&quot;);
307      SimpleEnter (THREAD) ;
308    } else {
309      guarantee (jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;
310      for (;;) {
311        jt-&gt;set_suspend_equivalent();
312        // cleared by handle_special_suspend_equivalent_condition() or
313        // java_suspend_self()
314        SimpleEnter (THREAD) ;
315 
316        // were we externally suspended while we were waiting?
317        if (!jt-&gt;handle_special_suspend_equivalent_condition()) break ;
318 
319        // This thread was externally suspended
320        //
321        // This logic isn&#39;t needed for JVMTI raw monitors,
322        // but doesn&#39;t hurt just in case the suspend rules change. This
323            // logic is needed for the JvmtiRawMonitor.wait() reentry phase.
324            // We have reentered the contended monitor, but while we were
325            // waiting another thread suspended us. We don&#39;t want to reenter
326            // the monitor while suspended because that would surprise the
327            // thread that suspended us.
328            //
329            // Drop the lock -
330        SimpleExit (THREAD) ;
331 
332            jt-&gt;java_suspend_self();
333          }
334 
335      assert(_owner == THREAD, &quot;Fatal error with monitor owner!&quot;);
336      assert(_recursions == 0, &quot;Fatal error with monitor recursions!&quot;);
337   }
338 
339   THREAD-&gt;set_current_pending_monitor(NULL);
340   guarantee (_recursions == 0, &quot;invariant&quot;) ;
341   return OM_OK;
342 }
343 
344 // Used mainly for JVMTI raw monitor implementation
345 // Also used for JvmtiRawMonitor::wait().
346 int JvmtiRawMonitor::raw_exit(TRAPS) {
347   if (THREAD != _owner) {
348     return OM_ILLEGAL_MONITOR_STATE;
349   }
350   if (_recursions &gt; 0) {
351     --_recursions ;
352     return OM_OK ;
353   }
354 
355   void * List = _EntryList ;
356   SimpleExit (THREAD) ;
357 
358   return OM_OK;
359 }
360 
361 // Used for JVMTI raw monitor implementation.
362 // All JavaThreads will enter here with state _thread_blocked
363 
364 int JvmtiRawMonitor::raw_wait(jlong millis, bool interruptible, TRAPS) {
365   if (THREAD != _owner) {
366     return OM_ILLEGAL_MONITOR_STATE;
367   }
368 
369   // To avoid spurious wakeups we reset the parkevent -- This is strictly optional.
370   // The caller must be able to tolerate spurious returns from raw_wait().
371   THREAD-&gt;_ParkEvent-&gt;reset() ;
372   OrderAccess::fence() ;
373 
374   // check interrupt event
375   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {
376     return OM_INTERRUPTED;
377   }
378 
379   intptr_t save = _recursions ;
380   _recursions = 0 ;
381   _waiters ++ ;
382   if (THREAD-&gt;is_Java_thread()) {
383     guarantee (((JavaThread *) THREAD)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;
384     ((JavaThread *)THREAD)-&gt;set_suspend_equivalent();
385   }
386   int rv = SimpleWait (THREAD, millis) ;
387   _recursions = save ;
388   _waiters -- ;
389 
390   guarantee (THREAD == _owner, &quot;invariant&quot;) ;
391   if (THREAD-&gt;is_Java_thread()) {
392      JavaThread * jSelf = (JavaThread *) THREAD ;
393      for (;;) {
394         if (!jSelf-&gt;handle_special_suspend_equivalent_condition()) break ;
395         SimpleExit (THREAD) ;
396         jSelf-&gt;java_suspend_self();
397         SimpleEnter (THREAD) ;
398         jSelf-&gt;set_suspend_equivalent() ;
399      }
400   }
401   guarantee (THREAD == _owner, &quot;invariant&quot;) ;
402 
403   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {
404     return OM_INTERRUPTED;
405   }
406   return OM_OK ;
407 }
408 
409 int JvmtiRawMonitor::raw_notify(TRAPS) {
410   if (THREAD != _owner) {
411     return OM_ILLEGAL_MONITOR_STATE;
412   }
413   SimpleNotify (THREAD, false) ;
414   return OM_OK;
415 }
416 
417 int JvmtiRawMonitor::raw_notifyAll(TRAPS) {
418   if (THREAD != _owner) {
419     return OM_ILLEGAL_MONITOR_STATE;
420   }
421   SimpleNotify (THREAD, true) ;
422   return OM_OK;
423 }
    </pre>
  </body>
</html>
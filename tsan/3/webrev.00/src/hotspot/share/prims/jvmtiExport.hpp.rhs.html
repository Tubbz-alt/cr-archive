<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiExport.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIEXPORT_HPP
 26 #define SHARE_PRIMS_JVMTIEXPORT_HPP
 27 
 28 #include &quot;jvmtifiles/jvmti.h&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/iterator.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;oops/oopsHierarchy.hpp&quot;
 33 #include &quot;runtime/frame.hpp&quot;
 34 #include &quot;runtime/handles.hpp&quot;
 35 #include &quot;utilities/globalDefinitions.hpp&quot;
 36 #include &quot;utilities/growableArray.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
 39 // Must be included after jvmti.h.
 40 #include &quot;jvmticmlr.h&quot;
 41 
 42 // Forward declarations
 43 
 44 class JvmtiEventControllerPrivate;
 45 class JvmtiManageCapabilities;
 46 class JvmtiEnv;
 47 class JvmtiThreadState;
 48 
 49 #define JVMTI_SUPPORT_FLAG(key)                                           \
 50   private:                                                                \
 51   static bool  _##key;                                                    \
 52   public:                                                                 \
 53   inline static void set_##key(bool on) {                                 \
 54     JVMTI_ONLY(_##key = (on != 0));                                       \
 55     NOT_JVMTI(report_unsupported(on));                                    \
 56   }                                                                       \
 57   inline static bool key() {                                              \
 58     JVMTI_ONLY(return _##key);                                            \
 59     NOT_JVMTI(return false);                                              \
 60   }
 61 
 62 
 63 // This class contains the JVMTI interface for the rest of hotspot.
 64 //
 65 class JvmtiExport : public AllStatic {
 66   friend class VMStructs;
 67   friend class CompileReplay;
 68 
 69  private:
 70 
 71 #if INCLUDE_JVMTI
 72   static int         _field_access_count;
 73   static int         _field_modification_count;
 74 
 75   static bool        _can_access_local_variables;
 76   static bool        _can_hotswap_or_post_breakpoint;
 77   static bool        _can_modify_any_class;
 78   static bool        _can_walk_any_space;
 79 #endif // INCLUDE_JVMTI
 80 
 81   JVMTI_SUPPORT_FLAG(can_get_source_debug_extension)
 82   JVMTI_SUPPORT_FLAG(can_maintain_original_method_order)
 83   JVMTI_SUPPORT_FLAG(can_post_interpreter_events)
 84   JVMTI_SUPPORT_FLAG(can_post_on_exceptions)
 85   JVMTI_SUPPORT_FLAG(can_post_breakpoint)
 86   JVMTI_SUPPORT_FLAG(can_post_field_access)
 87   JVMTI_SUPPORT_FLAG(can_post_field_modification)
 88   JVMTI_SUPPORT_FLAG(can_post_method_entry)
 89   JVMTI_SUPPORT_FLAG(can_post_method_exit)
 90   JVMTI_SUPPORT_FLAG(can_pop_frame)
 91   JVMTI_SUPPORT_FLAG(can_force_early_return)
 92 
 93   JVMTI_SUPPORT_FLAG(early_vmstart_recorded)
<a name="1" id="anc1"></a><span class="line-added"> 94   JVMTI_SUPPORT_FLAG(can_get_owned_monitor_info) // includes can_get_owned_monitor_stack_depth_info</span>
 95 
 96   friend class JvmtiEventControllerPrivate;  // should only modify these flags
 97   JVMTI_SUPPORT_FLAG(should_post_single_step)
 98   JVMTI_SUPPORT_FLAG(should_post_field_access)
 99   JVMTI_SUPPORT_FLAG(should_post_field_modification)
100   JVMTI_SUPPORT_FLAG(should_post_class_load)
101   JVMTI_SUPPORT_FLAG(should_post_class_prepare)
102   JVMTI_SUPPORT_FLAG(should_post_class_unload)
103   JVMTI_SUPPORT_FLAG(should_post_native_method_bind)
104   JVMTI_SUPPORT_FLAG(should_post_compiled_method_load)
105   JVMTI_SUPPORT_FLAG(should_post_compiled_method_unload)
106   JVMTI_SUPPORT_FLAG(should_post_dynamic_code_generated)
107   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_enter)
108   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_entered)
109   JVMTI_SUPPORT_FLAG(should_post_monitor_wait)
110   JVMTI_SUPPORT_FLAG(should_post_monitor_waited)
111   JVMTI_SUPPORT_FLAG(should_post_data_dump)
112   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_start)
113   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_finish)
114   JVMTI_SUPPORT_FLAG(should_post_on_exceptions)
115 
116   // ------ the below maybe don&#39;t have to be (but are for now)
117   // fixed conditions here ------------
118   // any events can be enabled
119   JVMTI_SUPPORT_FLAG(should_post_thread_life)
120   JVMTI_SUPPORT_FLAG(should_post_object_free)
121   JVMTI_SUPPORT_FLAG(should_post_resource_exhausted)
122 
123   // we are holding objects on the heap - need to talk to GC - e.g.
124   // breakpoint info
125   JVMTI_SUPPORT_FLAG(should_clean_up_heap_objects)
126   JVMTI_SUPPORT_FLAG(should_post_vm_object_alloc)
127   JVMTI_SUPPORT_FLAG(should_post_sampled_object_alloc)
128 
129   // If flag cannot be implemented, give an error if on=true
130   static void report_unsupported(bool on);
131 
132   // these should only be called by the friend class
133   friend class JvmtiManageCapabilities;
134   inline static void set_can_modify_any_class(bool on) {
135     JVMTI_ONLY(_can_modify_any_class = (on != 0);)
136   }
137   inline static void set_can_access_local_variables(bool on) {
138     JVMTI_ONLY(_can_access_local_variables = (on != 0);)
139   }
140   inline static void set_can_hotswap_or_post_breakpoint(bool on) {
141     JVMTI_ONLY(_can_hotswap_or_post_breakpoint = (on != 0);)
142   }
143   inline static void set_can_walk_any_space(bool on) {
144     JVMTI_ONLY(_can_walk_any_space = (on != 0);)
145   }
146 
147   enum {
148     JVMTI_VERSION_MASK   = 0x70000000,
149     JVMTI_VERSION_VALUE  = 0x30000000,
150     JVMDI_VERSION_VALUE  = 0x20000000
151   };
152 
153   static void post_field_modification(JavaThread *thread, Method* method, address location,
154                                       Klass* field_klass, Handle object, jfieldID field,
155                                       char sig_type, jvalue *value);
156 
157 
158   // posts a DynamicCodeGenerated event (internal/private implementation).
159   // The public post_dynamic_code_generated* functions make use of the
160   // internal implementation.  Also called from JvmtiDeferredEvent::post()
161   static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
162 
<a name="2" id="anc2"></a><span class="line-added">163   static void post_class_unload_internal(const char *name) NOT_JVMTI_RETURN;</span>
164  private:
165 
166   // GenerateEvents support to allow posting of CompiledMethodLoad and
167   // DynamicCodeGenerated events for a given environment.
168   friend class JvmtiCodeBlobEvents;
169 
<a name="3" id="anc3"></a>


170   static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
171                                           const void *code_end) NOT_JVMTI_RETURN;
172 
173   // This flag indicates whether RedefineClasses() has ever redefined
174   // one or more classes during the lifetime of the VM. The flag should
175   // only be set by the friend class and can be queried by other sub
176   // systems as needed to relax invariant checks.
<a name="4" id="anc4"></a><span class="line-modified">177   static uint64_t _redefinition_count;</span>
178   friend class VM_RedefineClasses;
<a name="5" id="anc5"></a><span class="line-modified">179   inline static void increment_redefinition_count() {</span>
<span class="line-modified">180     JVMTI_ONLY(_redefinition_count++;)</span>
181   }
182   // Flag to indicate if the compiler has recorded all dependencies. When the
183   // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
184   // records all dependencies from startup. However if the capability is first
185   // enabled some time later then the dependencies recorded by the compiler
186   // are incomplete. This flag is used by RedefineClasses to know if the
187   // dependency information is complete or not.
188   static bool _all_dependencies_are_recorded;
189 
190  public:
191   inline static bool has_redefined_a_class() {
<a name="6" id="anc6"></a><span class="line-modified">192     JVMTI_ONLY(return _redefinition_count != 0);</span>
193     NOT_JVMTI(return false);
194   }
195 
<a name="7" id="anc7"></a><span class="line-added">196   // Only set in safepoint, so no memory ordering needed.</span>
<span class="line-added">197   inline static uint64_t redefinition_count() {</span>
<span class="line-added">198     JVMTI_ONLY(return _redefinition_count);</span>
<span class="line-added">199     NOT_JVMTI(return 0);</span>
<span class="line-added">200   }</span>
<span class="line-added">201 </span>
202   inline static bool all_dependencies_are_recorded() {
203     return _all_dependencies_are_recorded;
204   }
205 
206   inline static void set_all_dependencies_are_recorded(bool on) {
207     _all_dependencies_are_recorded = (on != 0);
208   }
209 
210   // Add read edges to the unnamed modules of the bootstrap and app class loaders
211   static void add_default_read_edges(Handle h_module, TRAPS) NOT_JVMTI_RETURN;
212 
213   // Add a read edge to the module
214   static jvmtiError add_module_reads(Handle module, Handle to_module, TRAPS);
215 
216   // Updates a module to export a package
217   static jvmtiError add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS);
218 
219   // Updates a module to open a package
220   static jvmtiError add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS);
221 
222   // Add a used service to the module
223   static jvmtiError add_module_uses(Handle module, Handle service, TRAPS);
224 
225   // Add a service provider to the module
226   static jvmtiError add_module_provides(Handle module, Handle service, Handle impl_class, TRAPS);
227 
228   // let JVMTI know that the JVM_OnLoad code is running
229   static void enter_onload_phase() NOT_JVMTI_RETURN;
230 
231   // let JVMTI know that the VM isn&#39;t up yet (and JVM_OnLoad code isn&#39;t running)
232   static void enter_primordial_phase() NOT_JVMTI_RETURN;
233 
234   // let JVMTI know that the VM isn&#39;t up yet but JNI is live
235   static void enter_early_start_phase() NOT_JVMTI_RETURN;
236   static void enter_start_phase() NOT_JVMTI_RETURN;
237 
238   // let JVMTI know that the VM is fully up and running now
239   static void enter_live_phase() NOT_JVMTI_RETURN;
240 
241   // ------ can_* conditions (below) are set at OnLoad and never changed ------------
242   inline static bool can_modify_any_class()                       {
243     JVMTI_ONLY(return _can_modify_any_class);
244     NOT_JVMTI(return false);
245   }
246   inline static bool can_access_local_variables()                 {
247     JVMTI_ONLY(return _can_access_local_variables);
248     NOT_JVMTI(return false);
249   }
250   inline static bool can_hotswap_or_post_breakpoint()             {
251     JVMTI_ONLY(return _can_hotswap_or_post_breakpoint);
252     NOT_JVMTI(return false);
253   }
254   inline static bool can_walk_any_space()                         {
255     JVMTI_ONLY(return _can_walk_any_space);
256     NOT_JVMTI(return false);
257   }
258 
259   // field access management
260   static address  get_field_access_count_addr() NOT_JVMTI_RETURN_(0);
261 
262   // field modification management
263   static address  get_field_modification_count_addr() NOT_JVMTI_RETURN_(0);
264 
265   // -----------------
266 
267   static bool is_jvmti_version(jint version)                      {
268     JVMTI_ONLY(return (version &amp; JVMTI_VERSION_MASK) == JVMTI_VERSION_VALUE);
269     NOT_JVMTI(return false);
270   }
271   static bool is_jvmdi_version(jint version)                      {
272     JVMTI_ONLY(return (version &amp; JVMTI_VERSION_MASK) == JVMDI_VERSION_VALUE);
273     NOT_JVMTI(return false);
274   }
275   static jint get_jvmti_interface(JavaVM *jvm, void **penv, jint version) NOT_JVMTI_RETURN_(0);
276   static void decode_version_values(jint version, int * major, int * minor,
277                                     int * micro) NOT_JVMTI_RETURN;
278 
279   // single stepping management methods
280   static void at_single_stepping_point(JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
281   static void expose_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN;
282   static bool hide_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN_(false);
283 
284   // Methods that notify the debugger that something interesting has happened in the VM.
285   static void post_early_vm_start        () NOT_JVMTI_RETURN;
286   static void post_vm_start              () NOT_JVMTI_RETURN;
287   static void post_vm_initialized        () NOT_JVMTI_RETURN;
288   static void post_vm_death              () NOT_JVMTI_RETURN;
289 
290   static void post_single_step           (JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
291   static void post_raw_breakpoint        (JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
292 
293   static void post_exception_throw       (JavaThread *thread, Method* method, address location, oop exception) NOT_JVMTI_RETURN;
294   static void notice_unwind_due_to_exception (JavaThread *thread, Method* method, address location, oop exception, bool in_handler_frame) NOT_JVMTI_RETURN;
295 
296   static oop jni_GetField_probe          (JavaThread *thread, jobject jobj,
297     oop obj, Klass* klass, jfieldID fieldID, bool is_static)
298     NOT_JVMTI_RETURN_(NULL);
299   static oop jni_GetField_probe_nh       (JavaThread *thread, jobject jobj,
300     oop obj, Klass* klass, jfieldID fieldID, bool is_static)
301     NOT_JVMTI_RETURN_(NULL);
302   static void post_field_access_by_jni   (JavaThread *thread, oop obj,
303     Klass* klass, jfieldID fieldID, bool is_static) NOT_JVMTI_RETURN;
304   static void post_field_access          (JavaThread *thread, Method* method,
305     address location, Klass* field_klass, Handle object, jfieldID field) NOT_JVMTI_RETURN;
306   static oop jni_SetField_probe          (JavaThread *thread, jobject jobj,
307     oop obj, Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
308     jvalue *value) NOT_JVMTI_RETURN_(NULL);
309   static oop jni_SetField_probe_nh       (JavaThread *thread, jobject jobj,
310     oop obj, Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
311     jvalue *value) NOT_JVMTI_RETURN_(NULL);
312   static void post_field_modification_by_jni(JavaThread *thread, oop obj,
313     Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
314     jvalue *value);
315   static void post_raw_field_modification(JavaThread *thread, Method* method,
316     address location, Klass* field_klass, Handle object, jfieldID field,
317     char sig_type, jvalue *value) NOT_JVMTI_RETURN;
318 
319   static void post_method_entry          (JavaThread *thread, Method* method, frame current_frame) NOT_JVMTI_RETURN;
320   static void post_method_exit           (JavaThread *thread, Method* method, frame current_frame) NOT_JVMTI_RETURN;
321 
322   static void post_class_load            (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
323   static void post_class_unload          (Klass* klass) NOT_JVMTI_RETURN;
324   static void post_class_prepare         (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
325 
326   static void post_thread_start          (JavaThread *thread) NOT_JVMTI_RETURN;
327   static void post_thread_end            (JavaThread *thread) NOT_JVMTI_RETURN;
328 
329   // Support for java.lang.instrument agent loading.
330   static bool _should_post_class_file_load_hook;
331   inline static void set_should_post_class_file_load_hook(bool on)     { _should_post_class_file_load_hook = on;  }
332   inline static bool should_post_class_file_load_hook()           {
333     JVMTI_ONLY(return _should_post_class_file_load_hook);
334     NOT_JVMTI(return false;)
335   }
336   static bool is_early_phase() NOT_JVMTI_RETURN_(false);
337   static bool has_early_class_hook_env() NOT_JVMTI_RETURN_(false);
338   // Return true if the class was modified by the hook.
339   static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
340                                         Handle h_protection_domain,
341                                         unsigned char **data_ptr, unsigned char **end_ptr,
342                                         JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
343   static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;
<a name="8" id="anc8"></a><span class="line-added">344   static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;</span>
345   static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
346   static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
347 
348   // used to post a CompiledMethodUnload event
349   static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
350 
351   // similiar to post_dynamic_code_generated except that it can be used to
352   // post a DynamicCodeGenerated event while holding locks in the VM. Any event
353   // posted using this function is recorded by the enclosing event collector
354   // -- JvmtiDynamicCodeEventCollector.
355   static void post_dynamic_code_generated_while_holding_locks(const char* name, address code_begin, address code_end) NOT_JVMTI_RETURN;
356 
357   static void post_garbage_collection_finish() NOT_JVMTI_RETURN;
358   static void post_garbage_collection_start() NOT_JVMTI_RETURN;
359   static void post_data_dump() NOT_JVMTI_RETURN;
360   static void post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
361   static void post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
362   static void post_monitor_wait(JavaThread *thread, oop obj, jlong timeout) NOT_JVMTI_RETURN;
363   static void post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) NOT_JVMTI_RETURN;
364   static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;
365   static void post_resource_exhausted(jint resource_exhausted_flags, const char* detail) NOT_JVMTI_RETURN;
366   static void record_vm_internal_object_allocation(oop object) NOT_JVMTI_RETURN;
367   // Post objects collected by vm_object_alloc_event_collector.
368   static void post_vm_object_alloc(JavaThread *thread, oop object) NOT_JVMTI_RETURN;
369   // Collects vm internal objects for later event posting.
370   inline static void vm_object_alloc_event_collector(oop object) {
371     if (should_post_vm_object_alloc()) {
372       record_vm_internal_object_allocation(object);
373     }
374   }
375 
376   static void record_sampled_internal_object_allocation(oop object) NOT_JVMTI_RETURN;
377   // Post objects collected by sampled_object_alloc_event_collector.
378   static void post_sampled_object_alloc(JavaThread *thread, oop object) NOT_JVMTI_RETURN;
379 
380   // Collects vm internal objects for later event posting.
381   inline static void sampled_object_alloc_event_collector(oop object) {
382     if (should_post_sampled_object_alloc()) {
383       record_sampled_internal_object_allocation(object);
384     }
385   }
386 
387   inline static void post_array_size_exhausted() {
388     if (should_post_resource_exhausted()) {
389       post_resource_exhausted(JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
390                               &quot;Requested array size exceeds VM limit&quot;);
391     }
392   }
393 
394   static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
395   static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
396 
397   static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
398   static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;
<a name="9" id="anc9"></a>
399 
400   static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
401 
402 #if INCLUDE_SERVICES
403   // attach support
404   static jint load_agent_library(const char *agent, const char *absParam, const char *options, outputStream* out) NOT_JVMTI_RETURN_(JNI_ERR);
405 #endif
406 
407   // SetNativeMethodPrefix support
408   static char** get_all_native_method_prefixes(int* count_ptr) NOT_JVMTI_RETURN_(NULL);
409 
410   // JavaThread lifecycle support:
411   static jvmtiError cv_external_thread_to_JavaThread(ThreadsList * t_list,
412                                                      jthread thread,
413                                                      JavaThread ** jt_pp,
414                                                      oop * thread_oop_p);
415   static jvmtiError cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
416                                          JavaThread ** jt_pp);
417 };
418 
419 // Support class used by JvmtiDynamicCodeEventCollector and others. It
420 // describes a single code blob by name and address range.
421 class JvmtiCodeBlobDesc : public CHeapObj&lt;mtInternal&gt; {
422  private:
423   char _name[64];
424   address _code_begin;
425   address _code_end;
426 
427  public:
428   JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
429     assert(name != NULL, &quot;all code blobs must be named&quot;);
<a name="10" id="anc10"></a><span class="line-modified">430     strncpy(_name, name, sizeof(_name) - 1);</span>
431     _name[sizeof(_name)-1] = &#39;\0&#39;;
432     _code_begin = code_begin;
433     _code_end = code_end;
434   }
435   char* name()                  { return _name; }
436   address code_begin()          { return _code_begin; }
437   address code_end()            { return _code_end; }
438 };
439 
440 // JvmtiEventCollector is a helper class to setup thread for
441 // event collection.
442 class JvmtiEventCollector : public StackObj {
443  private:
444   JvmtiEventCollector* _prev;  // Save previous one to support nested event collector.
445   bool _unset_jvmti_thread_state;
446 
447  public:
448   JvmtiEventCollector() : _prev(NULL), _unset_jvmti_thread_state(false) {}
449 
450   void setup_jvmti_thread_state(); // Set this collector in current thread, returns if success.
451   void unset_jvmti_thread_state(); // Reset previous collector in current thread.
452   virtual bool is_dynamic_code_event()   { return false; }
453   virtual bool is_vm_object_alloc_event(){ return false; }
454   virtual bool is_sampled_object_alloc_event(){ return false; }
455   JvmtiEventCollector *get_prev()        { return _prev; }
456 };
457 
458 // A JvmtiDynamicCodeEventCollector is a helper class for the JvmtiExport
459 // interface. It collects &quot;dynamic code generated&quot; events that are posted
460 // while holding locks. When the event collector goes out of scope the
461 // events will be posted.
462 //
463 // Usage :-
464 //
465 // {
466 //   JvmtiDynamicCodeEventCollector event_collector;
467 //   :
468 //   { MutexLocker ml(...)
469 //     :
470 //     JvmtiExport::post_dynamic_code_generated_while_holding_locks(...)
471 //   }
472 //   // event collector goes out of scope =&gt; post events to profiler.
473 // }
474 
475 class JvmtiDynamicCodeEventCollector : public JvmtiEventCollector {
476  private:
477   GrowableArray&lt;JvmtiCodeBlobDesc*&gt;* _code_blobs;           // collected code blob events
478 
479   friend class JvmtiExport;
480   void register_stub(const char* name, address start, address end);
481 
482  public:
483   JvmtiDynamicCodeEventCollector()  NOT_JVMTI_RETURN;
484   ~JvmtiDynamicCodeEventCollector() NOT_JVMTI_RETURN;
485   bool is_dynamic_code_event()   { return true; }
486 
487 };
488 
489 // Used as a base class for object allocation collection and then posting
490 // the allocations to any event notification callbacks.
491 //
492 class JvmtiObjectAllocEventCollector : public JvmtiEventCollector {
493  protected:
494   GrowableArray&lt;oop&gt;* _allocated;      // field to record collected allocated object oop.
495   bool _enable;                   // This flag is enabled in constructor if set up in the thread state
496                                   // and disabled in destructor before posting event. To avoid
497                                   // collection of objects allocated while running java code inside
498                                   // agent post_X_object_alloc() event handler.
499   void (*_post_callback)(JavaThread*, oop); // what callback to use when destroying the collector.
500 
501   //GC support
502   void oops_do(OopClosure* f);
503 
504   friend class JvmtiExport;
505 
506   // Record allocated object oop.
507   inline void record_allocation(oop obj);
508 
509   //GC support
510   static void oops_do_for_all_threads(OopClosure* f);
511 
512  public:
513   JvmtiObjectAllocEventCollector()  NOT_JVMTI_RETURN;
514 
515   void generate_call_for_allocated();
516 
517   bool is_enabled()                 { return _enable; }
518   void set_enabled(bool on)         { _enable = on; }
519 };
520 
521 // Used to record vm internally allocated object oops and post
522 // vm object alloc event for objects visible to java world.
523 // Constructor enables JvmtiThreadState flag and all vm allocated
524 // objects are recorded in a growable array. When destructor is
525 // called the vm object alloc event is posted for each object
526 // visible to java world.
527 // See jvm.cpp file for its usage.
528 //
529 class JvmtiVMObjectAllocEventCollector : public JvmtiObjectAllocEventCollector {
530  public:
531   JvmtiVMObjectAllocEventCollector()  NOT_JVMTI_RETURN;
532   ~JvmtiVMObjectAllocEventCollector()  NOT_JVMTI_RETURN;
533   virtual bool is_vm_object_alloc_event()   { return true; }
534 };
535 
536 // Used to record sampled allocated object oops and post
537 // sampled object alloc event.
538 // Constructor enables JvmtiThreadState flag and all sampled allocated
539 // objects are recorded in a growable array. When destructor is
540 // called the sampled object alloc event is posted for each sampled object.
541 // See jvm.cpp file for its usage.
542 //
543 class JvmtiSampledObjectAllocEventCollector : public JvmtiObjectAllocEventCollector {
544  public:
545   JvmtiSampledObjectAllocEventCollector()  NOT_JVMTI_RETURN;
546   ~JvmtiSampledObjectAllocEventCollector()  NOT_JVMTI_RETURN;
547   bool is_sampled_object_alloc_event()    { return true; }
548   static bool object_alloc_is_safe_to_sample() NOT_JVMTI_RETURN_(false);
549 };
550 
551 // Marker class to disable the posting of VMObjectAlloc events
552 // within its scope.
553 //
554 // Usage :-
555 //
556 // {
557 //   NoJvmtiVMObjectAllocMark njm;
558 //   :
559 //   // VMObjAlloc event will not be posted
560 //   JvmtiExport::vm_object_alloc_event_collector(obj);
561 //   :
562 // }
563 
564 class NoJvmtiVMObjectAllocMark : public StackObj {
565  private:
566   // enclosing collector if enabled, NULL otherwise
567   JvmtiVMObjectAllocEventCollector *_collector;
568 
569   bool was_enabled()    { return _collector != NULL; }
570 
571  public:
572   NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;
573   ~NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;
574 };
575 
576 
577 // Base class for reporting GC events to JVMTI.
578 class JvmtiGCMarker : public StackObj {
579  public:
580   JvmtiGCMarker() NOT_JVMTI_RETURN;
581   ~JvmtiGCMarker() NOT_JVMTI_RETURN;
582 };
583 
584 // JvmtiHideSingleStepping is a helper class for hiding
585 // internal single step events.
586 class JvmtiHideSingleStepping : public StackObj {
587  private:
588   bool         _single_step_hidden;
589   JavaThread * _thread;
590 
591  public:
592   JvmtiHideSingleStepping(JavaThread * thread) {
593     assert(thread != NULL, &quot;sanity check&quot;);
594 
595     _single_step_hidden = false;
596     _thread = thread;
597     if (JvmtiExport::should_post_single_step()) {
598       _single_step_hidden = JvmtiExport::hide_single_stepping(_thread);
599     }
600   }
601 
602   ~JvmtiHideSingleStepping() {
603     if (_single_step_hidden) {
604       JvmtiExport::expose_single_stepping(_thread);
605     }
606   }
607 };
608 
609 #endif // SHARE_PRIMS_JVMTIEXPORT_HPP
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
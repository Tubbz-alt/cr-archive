diff a/src/hotspot/share/prims/nativeLookup.cpp b/src/hotspot/share/prims/nativeLookup.cpp
--- a/src/hotspot/share/prims/nativeLookup.cpp
+++ b/src/hotspot/share/prims/nativeLookup.cpp
@@ -22,29 +22,33 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "classfile/javaClasses.hpp"
+#include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "logging/log.hpp"
+#include "logging/logTag.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
-#include "memory/universe.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/symbol.hpp"
 #include "prims/jvm_misc.hpp"
 #include "prims/nativeLookup.hpp"
 #include "prims/unsafe.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/handles.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/signature.hpp"
 #include "utilities/macros.hpp"
+#include "utilities/utf8.hpp"
 #if INCLUDE_JFR
 #include "jfr/jfr.hpp"
 #endif
 
 static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
@@ -102,11 +106,11 @@
   stringStream st;
   Symbol* signature = method->signature();
   st.print("__");
   // find ')'
   int end;
-  for (end = 0; end < signature->utf8_length() && signature->char_at(end) != ')'; end++);
+  for (end = 0; end < signature->utf8_length() && signature->char_at(end) != JVM_SIGNATURE_ENDFUNC; end++);
   // skip first '('
   mangle_name_on(&st, signature, 1, end);
   return st.as_string();
 }
 
@@ -135,11 +139,11 @@
 #if INCLUDE_JFR
   { CC"Java_jdk_jfr_internal_JVM_registerNatives",                 NULL, FN_PTR(jfr_register_natives)            },
 #endif
 };
 
-static address lookup_special_native(char* jni_name) {
+static address lookup_special_native(const char* jni_name) {
   int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
   for (int i = 0; i < count; i++) {
     // NB: To ignore the jni prefix and jni postfix strstr is used matching.
     if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
       return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
@@ -148,17 +152,12 @@
   return NULL;
 }
 
 address NativeLookup::lookup_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, bool os_style, bool& in_base_library, TRAPS) {
   address entry;
-  // Compute complete JNI name for style
-  stringStream st;
-  if (os_style) os::print_jni_name_prefix_on(&st, args_size);
-  st.print_raw(pure_name);
-  st.print_raw(long_name);
-  if (os_style) os::print_jni_name_suffix_on(&st, args_size);
-  char* jni_name = st.as_string();
+  const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);
+
 
   // If the loader is null we have a system class, so we attempt a lookup in
   // the native Java library. This takes care of any bootstrapping problems.
   // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find
   // gets found the first time around - otherwise an infinite loop can occure. This is
@@ -202,44 +201,30 @@
   }
 
   return entry;
 }
 
-
-address NativeLookup::lookup_critical_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, bool os_style) {
-  if (!method->has_native_function()) {
-    return NULL;
+const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style) {
+  stringStream st;
+  if (os_style) {
+    os::print_jni_name_prefix_on(&st, args_size);
   }
 
-  address current_entry = method->native_function();
-
-  char dll_name[JVM_MAXPATHLEN];
-  int offset;
-  if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &offset)) {
-    char ebuf[32];
-    void* dll = os::dll_load(dll_name, ebuf, sizeof(ebuf));
-    if (dll != NULL) {
-      // Compute complete JNI name for style
-      stringStream st;
-      if (os_style) os::print_jni_name_prefix_on(&st, args_size);
-      st.print_raw(pure_name);
-      st.print_raw(long_name);
-      if (os_style) os::print_jni_name_suffix_on(&st, args_size);
-      char* jni_name = st.as_string();
-      address critical_entry = (address)os::dll_lookup(dll, jni_name);
-      // Close the handle to avoid keeping the library alive if the native method holder is unloaded.
-      // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon
-      // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper
-      // that calls 'critical_entry' becomes unreachable and is unloaded as well.
-      os::dll_unload(dll);
-      return critical_entry;
-    }
+  st.print_raw(pure_name);
+  st.print_raw(long_name);
+  if (os_style) {
+    os::print_jni_name_suffix_on(&st, args_size);
   }
 
-  return NULL;
+  return st.as_string();
 }
 
+address NativeLookup::lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style) {
+  const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);
+  assert(dll != NULL, "dll must be loaded");
+  return (address)os::dll_lookup(dll, jni_name);
+}
 
 // Check all the formats of native implementation name to see if there is one
 // for the specified method.
 address NativeLookup::lookup_entry(const methodHandle& method, bool& in_base_library, TRAPS) {
   address entry = NULL;
@@ -274,59 +259,96 @@
 }
 
 // Check all the formats of native implementation name to see if there is one
 // for the specified method.
 address NativeLookup::lookup_critical_entry(const methodHandle& method) {
-  if (!CriticalJNINatives) return NULL;
+  assert(CriticalJNINatives, "or should not be here");
 
   if (method->is_synchronized() ||
       !method->is_static()) {
     // Only static non-synchronized methods are allowed
     return NULL;
   }
 
   ResourceMark rm;
-  address entry = NULL;
 
   Symbol* signature = method->signature();
   for (int end = 0; end < signature->utf8_length(); end++) {
     if (signature->char_at(end) == 'L') {
       // Don't allow object types
       return NULL;
     }
   }
 
-  // Compute critical name
-  char* critical_name = critical_jni_name(method);
-
   // Compute argument size
   int args_size = method->size_of_parameters();
   for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
     if (ss.is_array()) {
       args_size += T_INT_size; // array length parameter
     }
   }
 
+  // dll handling requires I/O. Don't do that while in _thread_in_vm (safepoint may get requested).
+  ThreadToNativeFromVM thread_in_native(JavaThread::current());
+
+  void* dll = dll_load(method);
+  address entry = NULL;
+
+  if (dll != NULL) {
+    entry = lookup_critical_style(dll, method, args_size);
+    // Close the handle to avoid keeping the library alive if the native method holder is unloaded.
+    // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon
+    // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper
+    // that calls 'critical_entry' becomes unreachable and is unloaded as well.
+    os::dll_unload(dll);
+  }
+
+  return entry; // NULL indicates not found
+}
+
+void* NativeLookup::dll_load(const methodHandle& method) {
+  if (method->has_native_function()) {
+
+    address current_entry = method->native_function();
+
+    char dll_name[JVM_MAXPATHLEN];
+    int offset;
+    if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &offset)) {
+      char ebuf[32];
+      return os::dll_load(dll_name, ebuf, sizeof(ebuf));
+    }
+  }
+
+  return NULL;
+}
+
+address NativeLookup::lookup_critical_style(void* dll, const methodHandle& method, int args_size) {
+  address entry = NULL;
+  const char* critical_name = critical_jni_name(method);
+
   // 1) Try JNI short style
-  entry = lookup_critical_style(method, critical_name, "",        args_size, true);
-  if (entry != NULL) return entry;
+  entry = lookup_critical_style(dll, critical_name, "",        args_size, true);
+  if (entry != NULL) {
+    return entry;
+  }
 
-  // Compute long name
-  char* long_name = long_jni_name(method);
+  const char* long_name = long_jni_name(method);
 
   // 2) Try JNI long style
-  entry = lookup_critical_style(method, critical_name, long_name, args_size, true);
-  if (entry != NULL) return entry;
+  entry = lookup_critical_style(dll, critical_name, long_name, args_size, true);
+  if (entry != NULL) {
+    return entry;
+  }
 
   // 3) Try JNI short style without os prefix/suffix
-  entry = lookup_critical_style(method, critical_name, "",        args_size, false);
-  if (entry != NULL) return entry;
+  entry = lookup_critical_style(dll, critical_name, "",        args_size, false);
+  if (entry != NULL) {
+    return entry;
+  }
 
   // 4) Try JNI long style without os prefix/suffix
-  entry = lookup_critical_style(method, critical_name, long_name, args_size, false);
-
-  return entry; // NULL indicates not found
+  return lookup_critical_style(dll, critical_name, long_name, args_size, false);
 }
 
 // Check if there are any JVM TI prefixes which have been applied to the native method name.
 // If any are found, remove them before attemping the look up of the
 // native implementation again.
@@ -356,11 +378,11 @@
       Klass* k = method->method_holder();
       Method* wrapper_method = k->lookup_method(wrapper_symbol, method->signature());
       if (wrapper_method != NULL && !wrapper_method->is_native()) {
         // we found a wrapper method, use its native entry
         method->set_is_prefixed_native();
-        return lookup_entry(wrapper_method, in_base_library, THREAD);
+        return lookup_entry(methodHandle(THREAD, wrapper_method), in_base_library, THREAD);
       }
     }
   }
 #endif // INCLUDE_JVMTI
   return NULL;
@@ -377,37 +399,40 @@
   // JVM TI prefixes which have been applied to the native method name.
   entry = lookup_entry_prefixed(method, in_base_library, THREAD);
   if (entry != NULL) return entry;
 
   // Native function not found, throw UnsatisfiedLinkError
-  THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(),
-              method->name_and_sig_as_C_string());
+  stringStream ss;
+  ss.print("'");
+  method->print_external_name(&ss);
+  ss.print("'");
+  THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(), ss.as_string());
 }
 
 
 address NativeLookup::lookup(const methodHandle& method, bool& in_base_library, TRAPS) {
   if (!method->has_native_function()) {
     address entry = lookup_base(method, in_base_library, CHECK_NULL);
     method->set_native_function(entry,
       Method::native_bind_event_is_interesting);
     // -verbose:jni printing
-    if (PrintJNIResolving) {
+    if (log_is_enabled(Debug, jni, resolve)) {
       ResourceMark rm(THREAD);
-      tty->print_cr("[Dynamic-linking native method %s.%s ... JNI]",
-        method->method_holder()->external_name(),
-        method->name()->as_C_string());
+      log_debug(jni, resolve)("[Dynamic-linking native method %s.%s ... JNI]",
+                              method->method_holder()->external_name(),
+                              method->name()->as_C_string());
     }
   }
   return method->native_function();
 }
 
 address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
   EXCEPTION_MARK;
   bool in_base_library = true;  // SharedRuntime inits some math methods.
-  TempNewSymbol c_name = SymbolTable::new_symbol(class_name,  CATCH);
-  TempNewSymbol m_name = SymbolTable::new_symbol(method_name, CATCH);
-  TempNewSymbol s_name = SymbolTable::new_symbol(signature,   CATCH);
+  TempNewSymbol c_name = SymbolTable::new_symbol(class_name);
+  TempNewSymbol m_name = SymbolTable::new_symbol(method_name);
+  TempNewSymbol s_name = SymbolTable::new_symbol(signature);
 
   // Find the class
   Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
   InstanceKlass* klass  = InstanceKlass::cast(k);
 

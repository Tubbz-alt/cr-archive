<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/methodComparator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;oops/constantPool.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;prims/methodComparator.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 BytecodeStream *MethodComparator::_s_old;
 36 BytecodeStream *MethodComparator::_s_new;
 37 ConstantPool* MethodComparator::_old_cp;
 38 ConstantPool* MethodComparator::_new_cp;
 39 
 40 bool MethodComparator::methods_EMCP(Method* old_method, Method* new_method) {
 41   if (old_method-&gt;code_size() != new_method-&gt;code_size())
 42     return false;
 43   if (check_stack_and_locals_size(old_method, new_method) != 0) {
 44     if (log_is_enabled(Debug, redefine, class, methodcomparator)) {
 45       ResourceMark rm;
 46       log_debug(redefine, class, methodcomparator)
 47         (&quot;Methods %s non-comparable with diagnosis %d&quot;,
 48          old_method-&gt;name()-&gt;as_C_string(), check_stack_and_locals_size(old_method, new_method));
 49     }
 50     return false;
 51   }
 52 
 53   _old_cp = old_method-&gt;constants();
 54   _new_cp = new_method-&gt;constants();
 55   Thread* THREAD = Thread::current();
 56   BytecodeStream s_old(methodHandle(THREAD, old_method));
 57   BytecodeStream s_new(methodHandle(THREAD, new_method));
 58   _s_old = &amp;s_old;
 59   _s_new = &amp;s_new;
 60   Bytecodes::Code c_old, c_new;
 61 
 62   while ((c_old = s_old.next()) &gt;= 0) {
 63     if ((c_new = s_new.next()) &lt; 0 || c_old != c_new)
 64       return false;
 65 
 66     if (! args_same(c_old, c_new))
 67       return false;
 68   }
 69   return true;
 70 }
 71 
 72 bool MethodComparator::args_same(Bytecodes::Code c_old, Bytecodes::Code c_new) {
 73   // BytecodeStream returns the correct standard Java bytecodes for various &quot;fast&quot;
 74   // bytecode versions, so we don&#39;t have to bother about them here..
 75   switch (c_old) {
 76   case Bytecodes::_new            : // fall through
 77   case Bytecodes::_anewarray      : // fall through
 78   case Bytecodes::_multianewarray : // fall through
 79   case Bytecodes::_checkcast      : // fall through
 80   case Bytecodes::_instanceof     : {
 81     u2 cpi_old = _s_old-&gt;get_index_u2();
 82     u2 cpi_new = _s_new-&gt;get_index_u2();
 83     if ((_old_cp-&gt;klass_at_noresolve(cpi_old) != _new_cp-&gt;klass_at_noresolve(cpi_new)))
 84         return false;
 85     if (c_old == Bytecodes::_multianewarray &amp;&amp;
 86         *(jbyte*)(_s_old-&gt;bcp() + 3) != *(jbyte*)(_s_new-&gt;bcp() + 3))
 87       return false;
 88     break;
 89   }
 90 
 91   case Bytecodes::_getstatic       : // fall through
 92   case Bytecodes::_putstatic       : // fall through
 93   case Bytecodes::_getfield        : // fall through
 94   case Bytecodes::_putfield        : // fall through
 95   case Bytecodes::_invokevirtual   : // fall through
 96   case Bytecodes::_invokespecial   : // fall through
 97   case Bytecodes::_invokestatic    : // fall through
 98   case Bytecodes::_invokeinterface : {
 99     int cpci_old = _s_old-&gt;get_index_u2_cpcache();
100     int cpci_new = _s_new-&gt;get_index_u2_cpcache();
101     // Check if the names of classes, field/method names and signatures at these indexes
102     // are the same. Indices which are really into constantpool cache (rather than constant
103     // pool itself) are accepted by the constantpool query routines below.
104     if ((_old_cp-&gt;klass_ref_at_noresolve(cpci_old) != _new_cp-&gt;klass_ref_at_noresolve(cpci_new)) ||
105         (_old_cp-&gt;name_ref_at(cpci_old) != _new_cp-&gt;name_ref_at(cpci_new)) ||
106         (_old_cp-&gt;signature_ref_at(cpci_old) != _new_cp-&gt;signature_ref_at(cpci_new)))
107       return false;
108     break;
109   }
110   case Bytecodes::_invokedynamic: {
111     int cpci_old = _s_old-&gt;get_index_u4();
112     int cpci_new = _s_new-&gt;get_index_u4();
113 
114     // Check if the names of classes, field/method names and signatures at these indexes
115     // are the same. Indices which are really into constantpool cache (rather than constant
116     // pool itself) are accepted by the constantpool query routines below.
117     if ((_old_cp-&gt;name_ref_at(cpci_old) != _new_cp-&gt;name_ref_at(cpci_new)) ||
118         (_old_cp-&gt;signature_ref_at(cpci_old) != _new_cp-&gt;signature_ref_at(cpci_new)))
119       return false;
120 
121     // Translate object indexes to constant pool cache indexes.
122     cpci_old = _old_cp-&gt;invokedynamic_cp_cache_index(cpci_old);
123     cpci_new = _new_cp-&gt;invokedynamic_cp_cache_index(cpci_new);
124 
125     int cpi_old = _old_cp-&gt;cache()-&gt;entry_at(cpci_old)-&gt;constant_pool_index();
126     int cpi_new = _new_cp-&gt;cache()-&gt;entry_at(cpci_new)-&gt;constant_pool_index();
127     int bsm_old = _old_cp-&gt;bootstrap_method_ref_index_at(cpi_old);
128     int bsm_new = _new_cp-&gt;bootstrap_method_ref_index_at(cpi_new);
129     if (!pool_constants_same(bsm_old, bsm_new))
130       return false;
131     int cnt_old = _old_cp-&gt;bootstrap_argument_count_at(cpi_old);
132     int cnt_new = _new_cp-&gt;bootstrap_argument_count_at(cpi_new);
133     if (cnt_old != cnt_new)
134       return false;
135     for (int arg_i = 0; arg_i &lt; cnt_old; arg_i++) {
136       int idx_old = _old_cp-&gt;bootstrap_argument_index_at(cpi_old, arg_i);
137       int idx_new = _new_cp-&gt;bootstrap_argument_index_at(cpi_new, arg_i);
138       if (!pool_constants_same(idx_old, idx_new))
139         return false;
140     }
141     break;
142   }
143 
144   case Bytecodes::_ldc   : // fall through
145   case Bytecodes::_ldc_w : {
146     Bytecode_loadconstant ldc_old(_s_old-&gt;method(), _s_old-&gt;bci());
147     Bytecode_loadconstant ldc_new(_s_new-&gt;method(), _s_new-&gt;bci());
148     int cpi_old = ldc_old.pool_index();
149     int cpi_new = ldc_new.pool_index();
150     if (!pool_constants_same(cpi_old, cpi_new))
151       return false;
152     break;
153   }
154 
155   case Bytecodes::_ldc2_w : {
156     u2 cpi_old = _s_old-&gt;get_index_u2();
157     u2 cpi_new = _s_new-&gt;get_index_u2();
158     constantTag tag_old = _old_cp-&gt;tag_at(cpi_old);
159     constantTag tag_new = _new_cp-&gt;tag_at(cpi_new);
160     if (tag_old.value() != tag_new.value())
161       return false;
162     if (tag_old.is_long()) {
163       if (_old_cp-&gt;long_at(cpi_old) != _new_cp-&gt;long_at(cpi_new))
164         return false;
165     } else {
166       // Use jlong_cast to compare the bits rather than numerical values.
167       // This makes a difference for NaN constants.
168       if (jlong_cast(_old_cp-&gt;double_at(cpi_old)) != jlong_cast(_new_cp-&gt;double_at(cpi_new)))
169         return false;
170     }
171     break;
172   }
173 
174   case Bytecodes::_bipush :
175     if (_s_old-&gt;bcp()[1] != _s_new-&gt;bcp()[1])
176       return false;
177     break;
178 
179   case Bytecodes::_sipush    :
180     if (_s_old-&gt;get_index_u2() != _s_new-&gt;get_index_u2())
181       return false;
182     break;
183 
184   case Bytecodes::_aload  : // fall through
185   case Bytecodes::_astore : // fall through
186   case Bytecodes::_dload  : // fall through
187   case Bytecodes::_dstore : // fall through
188   case Bytecodes::_fload  : // fall through
189   case Bytecodes::_fstore : // fall through
190   case Bytecodes::_iload  : // fall through
191   case Bytecodes::_istore : // fall through
192   case Bytecodes::_lload  : // fall through
193   case Bytecodes::_lstore : // fall through
194   case Bytecodes::_ret    :
195     if (_s_old-&gt;is_wide() != _s_new-&gt;is_wide())
196       return false;
197     if (_s_old-&gt;get_index() != _s_new-&gt;get_index())
198       return false;
199     break;
200 
201   case Bytecodes::_goto      : // fall through
202   case Bytecodes::_if_acmpeq : // fall through
203   case Bytecodes::_if_acmpne : // fall through
204   case Bytecodes::_if_icmpeq : // fall through
205   case Bytecodes::_if_icmpne : // fall through
206   case Bytecodes::_if_icmplt : // fall through
207   case Bytecodes::_if_icmpge : // fall through
208   case Bytecodes::_if_icmpgt : // fall through
209   case Bytecodes::_if_icmple : // fall through
210   case Bytecodes::_ifeq      : // fall through
211   case Bytecodes::_ifne      : // fall through
212   case Bytecodes::_iflt      : // fall through
213   case Bytecodes::_ifge      : // fall through
214   case Bytecodes::_ifgt      : // fall through
215   case Bytecodes::_ifle      : // fall through
216   case Bytecodes::_ifnonnull : // fall through
217   case Bytecodes::_ifnull    : // fall through
218   case Bytecodes::_jsr       : {
219     int old_ofs = _s_old-&gt;bytecode().get_offset_s2(c_old);
220     int new_ofs = _s_new-&gt;bytecode().get_offset_s2(c_new);
221     if (old_ofs != new_ofs)
222       return false;
223     break;
224   }
225 
226   case Bytecodes::_iinc :
227     if (_s_old-&gt;is_wide() != _s_new-&gt;is_wide())
228       return false;
229     if (! _s_old-&gt;is_wide()) {
230       // We could use get_index_u1 and get_constant_u1, but it&#39;s simpler to grab both bytes at once:
231       if (Bytes::get_Java_u2(_s_old-&gt;bcp() + 1) != Bytes::get_Java_u2(_s_new-&gt;bcp() + 1))
232         return false;
233     } else {
234       // We could use get_index_u2 and get_constant_u2, but it&#39;s simpler to grab all four bytes at once:
235       if (Bytes::get_Java_u4(_s_old-&gt;bcp() + 1) != Bytes::get_Java_u4(_s_new-&gt;bcp() + 1))
236         return false;
237     }
238     break;
239 
240   case Bytecodes::_goto_w : // fall through
241   case Bytecodes::_jsr_w  : {
242     int old_ofs = _s_old-&gt;bytecode().get_offset_s4(c_old);
243     int new_ofs = _s_new-&gt;bytecode().get_offset_s4(c_new);
244     if (old_ofs != new_ofs)
245       return false;
246     break;
247   }
248 
249   case Bytecodes::_lookupswitch : // fall through
250   case Bytecodes::_tableswitch  : {
251     int len_old = _s_old-&gt;instruction_size();
252     int len_new = _s_new-&gt;instruction_size();
253     if (len_old != len_new)
254       return false;
255     if (memcmp(_s_old-&gt;bcp(), _s_new-&gt;bcp(), len_old) != 0)
256       return false;
257     break;
258   }
259 
260   default:
261     break;
262   }
263 
264   return true;
265 }
266 
267 bool MethodComparator::pool_constants_same(int cpi_old, int cpi_new) {
268   constantTag tag_old = _old_cp-&gt;tag_at(cpi_old);
269   constantTag tag_new = _new_cp-&gt;tag_at(cpi_new);
270   if (tag_old.is_int() || tag_old.is_float()) {
271     if (tag_old.value() != tag_new.value())
272       return false;
273     if (tag_old.is_int()) {
274       if (_old_cp-&gt;int_at(cpi_old) != _new_cp-&gt;int_at(cpi_new))
275         return false;
276     } else {
277       // Use jint_cast to compare the bits rather than numerical values.
278       // This makes a difference for NaN constants.
279       if (jint_cast(_old_cp-&gt;float_at(cpi_old)) != jint_cast(_new_cp-&gt;float_at(cpi_new)))
280         return false;
281     }
282   } else if (tag_old.is_string() &amp;&amp; tag_new.is_string()) {
283     if (strcmp(_old_cp-&gt;string_at_noresolve(cpi_old),
284                _new_cp-&gt;string_at_noresolve(cpi_new)) != 0)
285       return false;
286     if (_old_cp-&gt;is_pseudo_string_at(cpi_old) || _new_cp-&gt;is_pseudo_string_at(cpi_new))
287       return (_old_cp-&gt;is_pseudo_string_at(cpi_old) == _new_cp-&gt;is_pseudo_string_at(cpi_new));
288   } else if (tag_old.is_klass() || tag_old.is_unresolved_klass()) {
289     // tag_old should be klass - 4881222
290     if (! (tag_new.is_unresolved_klass() || tag_new.is_klass()))
291       return false;
292     if (_old_cp-&gt;klass_at_noresolve(cpi_old) !=
293         _new_cp-&gt;klass_at_noresolve(cpi_new))
294       return false;
295   } else if (tag_old.is_method_type() &amp;&amp; tag_new.is_method_type()) {
296     int mti_old = _old_cp-&gt;method_type_index_at(cpi_old);
297     int mti_new = _new_cp-&gt;method_type_index_at(cpi_new);
298     if ((_old_cp-&gt;symbol_at(mti_old) != _new_cp-&gt;symbol_at(mti_new)))
299       return false;
300   } else if (tag_old.is_method_handle() &amp;&amp; tag_new.is_method_handle()) {
301     if (_old_cp-&gt;method_handle_ref_kind_at(cpi_old) !=
302         _new_cp-&gt;method_handle_ref_kind_at(cpi_new))
303       return false;
304     int mhi_old = _old_cp-&gt;method_handle_index_at(cpi_old);
305     int mhi_new = _new_cp-&gt;method_handle_index_at(cpi_new);
306     if ((_old_cp-&gt;uncached_klass_ref_at_noresolve(mhi_old) != _new_cp-&gt;uncached_klass_ref_at_noresolve(mhi_new)) ||
307         (_old_cp-&gt;uncached_name_ref_at(mhi_old) != _new_cp-&gt;uncached_name_ref_at(mhi_new)) ||
308         (_old_cp-&gt;uncached_signature_ref_at(mhi_old) != _new_cp-&gt;uncached_signature_ref_at(mhi_new)))
309       return false;
310   } else {
311     return false;  // unknown tag
312   }
313   return true;
314 }
315 
316 
317 int MethodComparator::check_stack_and_locals_size(Method* old_method, Method* new_method) {
318   if (old_method-&gt;max_stack() != new_method-&gt;max_stack()) {
319     return 1;
320   } else if (old_method-&gt;max_locals() != new_method-&gt;max_locals()) {
321     return 2;
322   } else if (old_method-&gt;size_of_parameters() != new_method-&gt;size_of_parameters()) {
323     return 3;
324   } else return 0;
325 }
    </pre>
  </body>
</html>
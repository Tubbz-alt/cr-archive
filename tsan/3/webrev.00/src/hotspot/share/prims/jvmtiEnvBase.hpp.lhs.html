<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiEnvBase.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIENVBASE_HPP
 26 #define SHARE_PRIMS_JVMTIENVBASE_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;prims/jvmtiThreadState.hpp&quot;
 32 #include &quot;oops/oopHandle.hpp&quot;
<a name="1" id="anc1"></a>
 33 #include &quot;runtime/fieldDescriptor.hpp&quot;
 34 #include &quot;runtime/frame.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 
 40 //
 41 // Forward Declarations
 42 //
 43 
 44 class JvmtiEnv;
 45 class JvmtiThreadState;
 46 class JvmtiRawMonitor; // for jvmtiEnv.hpp
 47 class JvmtiEventControllerPrivate;
 48 class JvmtiTagMap;
 49 
 50 
 51 
 52 // One JvmtiEnv object is created per jvmti attachment;
 53 // done via JNI GetEnv() call. Multiple attachments are
 54 // allowed in jvmti.
 55 
 56 class JvmtiEnvBase : public CHeapObj&lt;mtInternal&gt; {
 57 
 58  private:
 59 
 60 #if INCLUDE_JVMTI
 61   static JvmtiEnvBase*     _head_environment;  // head of environment list
 62 #endif // INCLUDE_JVMTI
 63 
 64   static bool              _globally_initialized;
 65   static jvmtiPhase        _phase;
 66   static volatile int      _dying_thread_env_iteration_count;
 67 
 68  public:
 69 
 70   enum {
 71     JDK15_JVMTI_VERSION = JVMTI_VERSION_1_0 +  33,  /* version: 1.0.33  */
 72     JDK16_JVMTI_VERSION = JVMTI_VERSION_1_1 + 102,  /* version: 1.1.102 */
 73     JDK17_JVMTI_VERSION = JVMTI_VERSION_1_2 +   2   /* version: 1.2.2   */
 74   };
 75 
 76   static jvmtiPhase  get_phase()                    { return _phase; }
 77   static jvmtiPhase  get_phase(jvmtiEnv* env)       { return ((JvmtiEnvBase*)JvmtiEnv_from_jvmti_env(env))-&gt;phase(); }
 78   static void  set_phase(jvmtiPhase phase)          { _phase = phase; }
 79   static bool is_vm_live()                          { return _phase == JVMTI_PHASE_LIVE; }
 80 
 81   static void entering_dying_thread_env_iteration() { ++_dying_thread_env_iteration_count; }
 82   static void leaving_dying_thread_env_iteration()  { --_dying_thread_env_iteration_count; }
 83   static bool is_inside_dying_thread_env_iteration(){ return _dying_thread_env_iteration_count &gt; 0; }
 84 
 85  private:
 86 
 87   enum {
 88       JVMTI_MAGIC    = 0x71EE,
 89       DISPOSED_MAGIC = 0xDEFC,
 90       BAD_MAGIC      = 0xDEAD
 91   };
 92 
 93   jvmtiEnv _jvmti_external;
 94   jint _magic;
 95   jint _version;  // version value passed to JNI GetEnv()
 96   JvmtiEnvBase* _next;
 97   bool _is_retransformable;
 98   const void *_env_local_storage;     // per env agent allocated data.
 99   jvmtiEventCallbacks _event_callbacks;
100   jvmtiExtEventCallbacks _ext_event_callbacks;
<a name="2" id="anc2"></a><span class="line-modified">101   JvmtiTagMap* _tag_map;</span>
102   JvmtiEnvEventEnable _env_event_enable;
103   jvmtiCapabilities _current_capabilities;
104   jvmtiCapabilities _prohibited_capabilities;
105   volatile bool _class_file_load_hook_ever_enabled;
106   static volatile bool _needs_clean_up;
107   char** _native_method_prefixes;
108   int    _native_method_prefix_count;
109 
110  protected:
111   JvmtiEnvBase(jint version);
112   ~JvmtiEnvBase();
113   void dispose();
114   void env_dispose();
115 
116   void set_env_local_storage(const void* data)     { _env_local_storage = data; }
117   const void* get_env_local_storage()              { return _env_local_storage; }
118 
119   void record_class_file_load_hook_enabled();
120   void record_first_time_class_file_load_hook_enabled();
121 
122   char** get_native_method_prefixes()              { return _native_method_prefixes; }
123   int    get_native_method_prefix_count()          { return _native_method_prefix_count; }
124   jvmtiError set_native_method_prefixes(jint prefix_count, char** prefixes);
125 
126  private:
127   friend class JvmtiEventControllerPrivate;
128   void initialize();
129   void set_event_callbacks(const jvmtiEventCallbacks* callbacks, jint size_of_callbacks);
130   static void globally_initialize();
131   static void periodic_clean_up();
132 
133   friend class JvmtiEnvIterator;
134   JvmtiEnv* next_environment()                     { return (JvmtiEnv*)_next; }
135   void set_next_environment(JvmtiEnvBase* env)     { _next = env; }
136   static JvmtiEnv* head_environment()              {
137     JVMTI_ONLY(return (JvmtiEnv*)_head_environment);
138     NOT_JVMTI(return NULL);
139   }
140 
141  public:
142 
143   jvmtiPhase  phase();
144   bool is_valid();
145 
146   bool use_version_1_0_semantics();  // agent asked for version 1.0
147   bool use_version_1_1_semantics();  // agent asked for version 1.1
148   bool use_version_1_2_semantics();  // agent asked for version 1.2
149 
150   bool is_retransformable()                        { return _is_retransformable; }
151 
152   static ByteSize jvmti_external_offset() {
153     return byte_offset_of(JvmtiEnvBase, _jvmti_external);
154   };
155 
156   static JvmtiEnv* JvmtiEnv_from_jvmti_env(jvmtiEnv *env) {
157     return (JvmtiEnv*)((intptr_t)env - in_bytes(jvmti_external_offset()));
158   };
159 
160   jvmtiCapabilities *get_capabilities()             { return &amp;_current_capabilities; }
161 
162   jvmtiCapabilities *get_prohibited_capabilities()  { return &amp;_prohibited_capabilities; }
163 
164   bool early_class_hook_env() {
165     return get_capabilities()-&gt;can_generate_early_class_hook_events != 0
166         &amp;&amp; get_capabilities()-&gt;can_generate_all_class_hook_events != 0;
167   }
168 
169   bool early_vmstart_env() {
170     return get_capabilities()-&gt;can_generate_early_vmstart != 0;
171   }
172 
173   static char** get_all_native_method_prefixes(int* count_ptr);
174 
175   // This test will answer true when all environments have been disposed and some have
176   // not yet been deallocated.  As a result, this test should only be used as an
177   // optimization for the no environment case.
178   static bool environments_might_exist() {
179     return head_environment() != NULL;
180   }
181 
182   static void check_for_periodic_clean_up();
183 
184   JvmtiEnvEventEnable *env_event_enable() {
185     return &amp;_env_event_enable;
186   }
187 
188   jvmtiError allocate(jlong size, unsigned char** mem_ptr) {
189     if (size &lt; 0) {
190       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
191     }
192     if (size == 0) {
193       *mem_ptr = NULL;
194     } else {
195       *mem_ptr = (unsigned char *)os::malloc((size_t)size, mtInternal);
196       if (*mem_ptr == NULL) {
197         return JVMTI_ERROR_OUT_OF_MEMORY;
198       }
199     }
200     return JVMTI_ERROR_NONE;
201   }
202 
203   jvmtiError deallocate(unsigned char* mem) {
204     if (mem != NULL) {
205       os::free(mem);
206     }
207     return JVMTI_ERROR_NONE;
208   }
209 
210 
211   // Memory functions
212   unsigned char* jvmtiMalloc(jlong size);  // don&#39;t use this - call allocate
213 
214   // method to create a local handle
215   jobject jni_reference(Handle hndl);
216 
217   // method to create a local handle.
218   // This function allows caller to specify which
219   // threads local handle table to use.
220   jobject jni_reference(JavaThread *thread, Handle hndl);
221 
222   // method to destroy a local handle
223   void destroy_jni_reference(jobject jobj);
224 
225   // method to destroy a local handle.
226   // This function allows caller to specify which
227   // threads local handle table to use.
228   void destroy_jni_reference(JavaThread *thread, jobject jobj);
229 
230   jvmtiEnv* jvmti_external() { return &amp;_jvmti_external; };
231 
232 // Event Dispatch
233 
234   bool has_callback(jvmtiEvent event_type) {
235     assert(event_type &gt;= JVMTI_MIN_EVENT_TYPE_VAL &amp;&amp;
236            event_type &lt;= JVMTI_MAX_EVENT_TYPE_VAL, &quot;checking&quot;);
237     return ((void**)&amp;_event_callbacks)[event_type-JVMTI_MIN_EVENT_TYPE_VAL] != NULL;
238   }
239 
240   jvmtiEventCallbacks* callbacks() {
241     return &amp;_event_callbacks;
242   }
243 
244   jvmtiExtEventCallbacks* ext_callbacks() {
245     return &amp;_ext_event_callbacks;
246   }
247 
248   void set_tag_map(JvmtiTagMap* tag_map) {
249     _tag_map = tag_map;
250   }
251 
252   JvmtiTagMap* tag_map() {
253     return _tag_map;
254   }
255 
<a name="3" id="anc3"></a>






256 
257   // return true if event is enabled globally or for any thread
258   // True only if there is a callback for it.
259   bool is_enabled(jvmtiEvent event_type) {
260     return _env_event_enable.is_enabled(event_type);
261   }
262 
263 // Random Utilities
264 
265  protected:
266   // helper methods for creating arrays of global JNI Handles from local Handles
267   // allocated into environment specific storage
268   jobject * new_jobjectArray(int length, Handle *handles);
269   jthread * new_jthreadArray(int length, Handle *handles);
270   jthreadGroup * new_jthreadGroupArray(int length, Handle *handles);
271 
272   // convert to a jni jclass from a non-null Klass*
273   jclass get_jni_class_non_null(Klass* k);
274 
275   jint count_locked_objects(JavaThread *java_thread, Handle hobj);
276   jvmtiError get_locked_objects_in_frame(JavaThread *calling_thread,
277                                    JavaThread* java_thread,
278                                    javaVFrame *jvf,
279                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list,
280                                    jint depth);
281   vframe* vframeFor(JavaThread* java_thread, jint depth);
282 
283  public:
284   // get a field descriptor for the specified class and field
285   static bool get_field_descriptor(Klass* k, jfieldID field, fieldDescriptor* fd);
286 
287   // JVMTI API helper functions which are called at safepoint or thread is suspended.
288   jvmtiError get_frame_count(JvmtiThreadState *state, jint *count_ptr);
289   jvmtiError get_frame_location(JavaThread* java_thread, jint depth,
290                                               jmethodID* method_ptr, jlocation* location_ptr);
291   jvmtiError get_object_monitor_usage(JavaThread *calling_thread,
292                                                     jobject object, jvmtiMonitorUsage* info_ptr);
293   jvmtiError get_stack_trace(JavaThread *java_thread,
294                                            jint stack_depth, jint max_count,
295                                            jvmtiFrameInfo* frame_buffer, jint* count_ptr);
296   jvmtiError get_current_contended_monitor(JavaThread *calling_thread,
297                                                          JavaThread *java_thread,
298                                                          jobject *monitor_ptr);
299   jvmtiError get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread,
300                           GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors_list);
301   jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,
302                              jvalue value, TosState tos, Handle* ret_ob_h);
303   jvmtiError force_early_return(JavaThread* java_thread, jvalue value, TosState tos);
304 };
305 
306 // This class is the only safe means of iterating through environments.
307 // Note that this iteratation includes invalid environments pending
308 // deallocation -- in fact, some uses depend on this behavior.
309 
310 class JvmtiEnvIterator : public StackObj {
311  private:
312   bool _entry_was_marked;
313  public:
314   JvmtiEnvIterator() {
315     if (Threads::number_of_threads() == 0) {
316       _entry_was_marked = false; // we are single-threaded, no need
317     } else {
318       Thread::current()-&gt;entering_jvmti_env_iteration();
319       _entry_was_marked = true;
320     }
321   }
322   ~JvmtiEnvIterator() {
323     if (_entry_was_marked) {
324       Thread::current()-&gt;leaving_jvmti_env_iteration();
325     }
326   }
327   JvmtiEnv* first()                 { return JvmtiEnvBase::head_environment(); }
328   JvmtiEnv* next(JvmtiEnvBase* env) { return env-&gt;next_environment(); }
329 };
330 
331 // VM operation to update for pop top frame.
332 class VM_UpdateForPopTopFrame : public VM_Operation {
333 private:
334   JvmtiThreadState* _state;
335   jvmtiError _result;
336 
337 public:
338   VM_UpdateForPopTopFrame(JvmtiThreadState* state) {
339     _state = state;
340     _result = JVMTI_ERROR_NONE;
341   }
342   VMOp_Type type() const { return VMOp_UpdateForPopTopFrame; }
343   jvmtiError result() { return _result; }
344   void doit();
345 };
346 
347 // VM operation to set frame pop.
348 class VM_SetFramePop : public VM_Operation {
349 private:
350   JvmtiEnv *_env;
351   JvmtiThreadState* _state;
352   jint _depth;
353   jvmtiError _result;
354 
355 public:
356   VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {
357     _env = env;
358     _state = state;
359     _depth = depth;
360     _result = JVMTI_ERROR_NONE;
361   }
362   // Nested operation must be allowed for the VM_EnterInterpOnlyMode that is
363   // called from the JvmtiEventControllerPrivate::recompute_thread_enabled.
364   bool allow_nested_vm_operations() const { return true; }
365   VMOp_Type type() const { return VMOp_SetFramePop; }
366   jvmtiError result() { return _result; }
367   void doit();
368 };
369 
370 
371 // VM operation to get monitor information with stack depth.
372 class VM_GetOwnedMonitorInfo : public VM_Operation {
373 private:
374   JvmtiEnv *_env;
375   JavaThread* _calling_thread;
376   JavaThread *_java_thread;
377   jvmtiError _result;
378   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
379 
380 public:
381   VM_GetOwnedMonitorInfo(JvmtiEnv* env, JavaThread* calling_thread,
382                                    JavaThread* java_thread,
383                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitor_list) {
384     _env = env;
385     _calling_thread = calling_thread;
386     _java_thread = java_thread;
387     _owned_monitors_list = owned_monitor_list;
388     _result = JVMTI_ERROR_NONE;
389   }
390   VMOp_Type type() const { return VMOp_GetOwnedMonitorInfo; }
391   void doit();
392   jvmtiError result() { return _result; }
393 };
394 
395 
396 // VM operation to get object monitor usage.
397 class VM_GetObjectMonitorUsage : public VM_Operation {
398 private:
399   JvmtiEnv *_env;
400   jobject _object;
401   JavaThread* _calling_thread;
402   jvmtiMonitorUsage* _info_ptr;
403   jvmtiError _result;
404 
405 public:
406   VM_GetObjectMonitorUsage(JvmtiEnv *env, JavaThread* calling_thread, jobject object, jvmtiMonitorUsage* info_ptr) {
407     _env = env;
408     _object = object;
409     _calling_thread = calling_thread;
410     _info_ptr = info_ptr;
411   }
412   VMOp_Type type() const { return VMOp_GetObjectMonitorUsage; }
413   jvmtiError result() { return _result; }
414   void doit() {
415     _result = ((JvmtiEnvBase*) _env)-&gt;get_object_monitor_usage(_calling_thread, _object, _info_ptr);
416   }
417 
418 };
419 
420 // VM operation to get current contended monitor.
421 class VM_GetCurrentContendedMonitor : public VM_Operation {
422 private:
423   JvmtiEnv *_env;
424   JavaThread *_calling_thread;
425   JavaThread *_java_thread;
426   jobject *_owned_monitor_ptr;
427   jvmtiError _result;
428 
429 public:
430   VM_GetCurrentContendedMonitor(JvmtiEnv *env, JavaThread *calling_thread, JavaThread *java_thread, jobject *mon_ptr) {
431     _env = env;
432     _calling_thread = calling_thread;
433     _java_thread = java_thread;
434     _owned_monitor_ptr = mon_ptr;
435   }
436   VMOp_Type type() const { return VMOp_GetCurrentContendedMonitor; }
437   jvmtiError result() { return _result; }
438   void doit();
439 };
440 
441 // VM operation to get stack trace at safepoint.
442 class VM_GetStackTrace : public VM_Operation {
443 private:
444   JvmtiEnv *_env;
445   JavaThread *_java_thread;
446   jint _start_depth;
447   jint _max_count;
448   jvmtiFrameInfo *_frame_buffer;
449   jint *_count_ptr;
450   jvmtiError _result;
451 
452 public:
453   VM_GetStackTrace(JvmtiEnv *env, JavaThread *java_thread,
454                    jint start_depth, jint max_count,
455                    jvmtiFrameInfo* frame_buffer, jint* count_ptr) {
456     _env = env;
457     _java_thread = java_thread;
458     _start_depth = start_depth;
459     _max_count = max_count;
460     _frame_buffer = frame_buffer;
461     _count_ptr = count_ptr;
462   }
463   jvmtiError result() { return _result; }
464   VMOp_Type type() const { return VMOp_GetStackTrace; }
465   void doit();
466 };
467 
468 // forward declaration
469 struct StackInfoNode;
470 
471 // VM operation to get stack trace at safepoint.
472 class VM_GetMultipleStackTraces : public VM_Operation {
473 private:
474   JvmtiEnv *_env;
475   jint _max_frame_count;
476   jvmtiStackInfo *_stack_info;
477   jvmtiError _result;
478   int _frame_count_total;
479   struct StackInfoNode *_head;
480 
481   JvmtiEnvBase *env()                 { return (JvmtiEnvBase *)_env; }
482   jint max_frame_count()              { return _max_frame_count; }
483   struct StackInfoNode *head()        { return _head; }
484   void set_head(StackInfoNode *head)  { _head = head; }
485 
486 protected:
487   void set_result(jvmtiError result)  { _result = result; }
488   void fill_frames(jthread jt, JavaThread *thr, oop thread_oop);
489   void allocate_and_fill_stacks(jint thread_count);
490 
491 public:
492   VM_GetMultipleStackTraces(JvmtiEnv *env, jint max_frame_count) {
493     _env = env;
494     _max_frame_count = max_frame_count;
495     _frame_count_total = 0;
496     _head = NULL;
497     _result = JVMTI_ERROR_NONE;
498   }
499   VMOp_Type type() const             { return VMOp_GetMultipleStackTraces; }
500   jvmtiStackInfo *stack_info()       { return _stack_info; }
501   jvmtiError result()                { return _result; }
502 };
503 
504 
505 // VM operation to get stack trace at safepoint.
506 class VM_GetAllStackTraces : public VM_GetMultipleStackTraces {
507 private:
508   JavaThread *_calling_thread;
509   jint _final_thread_count;
510 
511 public:
512   VM_GetAllStackTraces(JvmtiEnv *env, JavaThread *calling_thread,
513                        jint max_frame_count)
514       : VM_GetMultipleStackTraces(env, max_frame_count) {
515     _calling_thread = calling_thread;
516   }
517   VMOp_Type type() const          { return VMOp_GetAllStackTraces; }
518   void doit();
519   jint final_thread_count()       { return _final_thread_count; }
520 };
521 
522 // VM operation to get stack trace at safepoint.
523 class VM_GetThreadListStackTraces : public VM_GetMultipleStackTraces {
524 private:
525   jint _thread_count;
526   const jthread* _thread_list;
527 
528 public:
529   VM_GetThreadListStackTraces(JvmtiEnv *env, jint thread_count, const jthread* thread_list, jint max_frame_count)
530       : VM_GetMultipleStackTraces(env, max_frame_count) {
531     _thread_count = thread_count;
532     _thread_list = thread_list;
533   }
534   VMOp_Type type() const { return VMOp_GetThreadListStackTraces; }
535   void doit();
536 };
537 
538 
539 // VM operation to count stack frames at safepoint.
540 class VM_GetFrameCount : public VM_Operation {
541 private:
542   JvmtiEnv *_env;
543   JvmtiThreadState *_state;
544   jint *_count_ptr;
545   jvmtiError _result;
546 
547 public:
548   VM_GetFrameCount(JvmtiEnv *env, JvmtiThreadState *state, jint *count_ptr) {
549     _env = env;
550     _state = state;
551     _count_ptr = count_ptr;
552   }
553   VMOp_Type type() const { return VMOp_GetFrameCount; }
554   jvmtiError result()    { return _result; }
555   void doit();
556 };
557 
558 // VM operation to frame location at safepoint.
559 class VM_GetFrameLocation : public VM_Operation {
560 private:
561   JvmtiEnv *_env;
562   JavaThread* _java_thread;
563   jint _depth;
564   jmethodID* _method_ptr;
565   jlocation* _location_ptr;
566   jvmtiError _result;
567 
568 public:
569   VM_GetFrameLocation(JvmtiEnv *env, JavaThread* java_thread, jint depth,
570                       jmethodID* method_ptr, jlocation* location_ptr) {
571     _env = env;
572     _java_thread = java_thread;
573     _depth = depth;
574     _method_ptr = method_ptr;
575     _location_ptr = location_ptr;
576   }
577   VMOp_Type type() const { return VMOp_GetFrameLocation; }
578   jvmtiError result()    { return _result; }
579   void doit();
580 };
581 
582 
583 // ResourceTracker
584 //
585 // ResourceTracker works a little like a ResourceMark. All allocates
586 // using the resource tracker are recorded. If an allocate using the
587 // resource tracker fails the destructor will free any resources
588 // that were allocated using the tracker.
589 // The motive for this class is to avoid messy error recovery code
590 // in situations where multiple allocations are done in sequence. If
591 // the second or subsequent allocation fails it avoids any code to
592 // release memory allocated in the previous calls.
593 //
594 // Usage :-
595 //   ResourceTracker rt(env);
596 //   :
597 //   err = rt.allocate(1024, &amp;ptr);
598 
599 class ResourceTracker : public StackObj {
600  private:
601   JvmtiEnv* _env;
602   GrowableArray&lt;unsigned char*&gt; *_allocations;
603   bool _failed;
604  public:
605   ResourceTracker(JvmtiEnv* env);
606   ~ResourceTracker();
607   jvmtiError allocate(jlong size, unsigned char** mem_ptr);
608   unsigned char* allocate(jlong size);
609   char* strdup(const char* str);
610 };
611 
612 
613 // Jvmti monitor closure to collect off stack monitors.
614 class JvmtiMonitorClosure: public MonitorClosure {
615  private:
616   JavaThread *_java_thread;
617   JavaThread *_calling_thread;
618   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
619   jvmtiError _error;
620   JvmtiEnvBase *_env;
621 
622  public:
623   JvmtiMonitorClosure(JavaThread* thread, JavaThread *calling_thread,
624                       GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors,
625                       JvmtiEnvBase *env) {
626     _java_thread = thread;
627     _calling_thread = calling_thread;
628     _owned_monitors_list = owned_monitors;
629     _error = JVMTI_ERROR_NONE;
630     _env = env;
631   }
632   void do_monitor(ObjectMonitor* mon);
633   jvmtiError error() { return _error;}
634 };
635 
636 
637 // Jvmti module closure to collect all modules loaded to the system.
638 class JvmtiModuleClosure : public StackObj {
639 private:
640   static GrowableArray&lt;OopHandle&gt; *_tbl; // Protected with Module_lock
641 
642   static void do_module(ModuleEntry* entry);
643 public:
644   jvmtiError get_all_modules(JvmtiEnv* env, jint* module_count_ptr, jobject** modules_ptr);
645 };
646 
647 #endif // SHARE_PRIMS_JVMTIENVBASE_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/prims/jvmtiThreadState.cpp b/src/hotspot/share/prims/jvmtiThreadState.cpp
--- a/src/hotspot/share/prims/jvmtiThreadState.cpp
+++ b/src/hotspot/share/prims/jvmtiThreadState.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -70,10 +70,12 @@
   _earlyret_state = earlyret_inactive;
   _earlyret_tos = ilgl;
   _earlyret_value.j = 0L;
   _earlyret_oop = NULL;
 
+  _jvmti_event_queue = NULL;
+
   // add all the JvmtiEnvThreadState to the new JvmtiThreadState
   {
     JvmtiEnvIterator it;
     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
       if (env->is_valid()) {
@@ -395,8 +397,43 @@
   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
     ets->clear_current_location();
   }
 }
 
-void JvmtiThreadState::oops_do(OopClosure* f) {
+void JvmtiThreadState::oops_do(OopClosure* f, CodeBlobClosure* cf) {
   f->do_oop((oop*) &_earlyret_oop);
+
+  // Keep nmethods from unloading on the event queue
+  if (_jvmti_event_queue != NULL) {
+    _jvmti_event_queue->oops_do(f, cf);
+  }
+}
+
+void JvmtiThreadState::nmethods_do(CodeBlobClosure* cf) {
+  // Keep nmethods from unloading on the event queue
+  if (_jvmti_event_queue != NULL) {
+    _jvmti_event_queue->nmethods_do(cf);
+  }
+}
+
+// Thread local event queue.
+void JvmtiThreadState::enqueue_event(JvmtiDeferredEvent* event) {
+  if (_jvmti_event_queue == NULL) {
+    _jvmti_event_queue = new JvmtiDeferredEventQueue();
+  }
+  // copy the event
+  _jvmti_event_queue->enqueue(*event);
+}
+
+void JvmtiThreadState::post_events(JvmtiEnv* env) {
+  if (_jvmti_event_queue != NULL) {
+    _jvmti_event_queue->post(env);  // deletes each queue node
+    delete _jvmti_event_queue;
+    _jvmti_event_queue = NULL;
+  }
+}
+
+void JvmtiThreadState::run_nmethod_entry_barriers() {
+  if (_jvmti_event_queue != NULL) {
+    _jvmti_event_queue->run_nmethod_entry_barriers();
+  }
 }

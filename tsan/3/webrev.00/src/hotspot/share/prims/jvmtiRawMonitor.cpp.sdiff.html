<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRawMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiManageCapabilities.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRawMonitor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRawMonitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #if INCLUDE_TSAN
 33 #include &quot;tsan/tsan.hpp&quot;
 34 #endif  // INCLUDE_TSAN
 35 
<span class="line-modified"> 36 GrowableArray&lt;JvmtiRawMonitor*&gt; *JvmtiPendingMonitors::_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1,true);</span>






 37 
 38 void JvmtiPendingMonitors::transition_raw_monitors() {
 39   assert((Threads::number_of_threads()==1),
<span class="line-modified"> 40          &quot;Java thread has not created yet or more than one java thread \</span>
<span class="line-modified"> 41 is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified"> 42   JavaThread *current_java_thread = JavaThread::current();</span>
 43   assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<span class="line-modified"> 44   {</span>
<span class="line-modified"> 45     ThreadBlockInVM __tbivm(current_java_thread);</span>
<span class="line-modified"> 46     for(int i=0; i&lt; count(); i++) {</span>
<span class="line-modified"> 47       JvmtiRawMonitor *rmonitor = monitors()-&gt;at(i);</span>
<span class="line-removed"> 48       int r = rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-removed"> 49       assert(r == ObjectMonitor::OM_OK, &quot;raw_enter should have worked&quot;);</span>
<span class="line-removed"> 50       TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>
<span class="line-removed"> 51     }</span>
 52   }
 53   // pending monitors are converted to real monitor so delete them all.
 54   dispose();
 55 }
 56 
 57 //
 58 // class JvmtiRawMonitor
 59 //
 60 
<span class="line-modified"> 61 JvmtiRawMonitor::JvmtiRawMonitor(const char *name) {</span>






 62 #ifdef ASSERT
 63   _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);
<span class="line-removed"> 64 #else</span>
<span class="line-removed"> 65   _name = NULL;</span>
 66 #endif
<span class="line-removed"> 67   _magic = JVMTI_RM_MAGIC;</span>
 68 }
 69 
 70 JvmtiRawMonitor::~JvmtiRawMonitor() {
 71 #ifdef ASSERT
 72   FreeHeap(_name);
 73 #endif
 74   _magic = 0;
 75 }
 76 
 77 
 78 bool
 79 JvmtiRawMonitor::is_valid() {
 80   int value = 0;
 81 
 82   // This object might not be a JvmtiRawMonitor so we can&#39;t assume
 83   // the _magic field is properly aligned. Get the value in a safe
 84   // way and then check against JVMTI_RM_MAGIC.
 85 
 86   switch (sizeof(_magic)) {
 87   case 2:
 88     value = Bytes::get_native_u2((address)&amp;_magic);
 89     break;
 90 
 91   case 4:
 92     value = Bytes::get_native_u4((address)&amp;_magic);
 93     break;
 94 
 95   case 8:
 96     value = Bytes::get_native_u8((address)&amp;_magic);
 97     break;
 98 
 99   default:
100     guarantee(false, &quot;_magic field is an unexpected size&quot;);
101   }
102 
103   return value == JVMTI_RM_MAGIC;
104 }
105 
106 // -------------------------------------------------------------------------
<span class="line-modified">107 // The raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">108 // java-synchronization or jni-synchronization.  raw monitors are not</span>
109 // associated with objects.  They can be implemented in any manner
110 // that makes sense.  The original implementors decided to piggy-back
<span class="line-modified">111 // the raw-monitor implementation on the existing Java objectMonitor mechanism.</span>
<span class="line-modified">112 // This flaw needs to fixed.  We should reimplement raw monitors as sui-generis.</span>
<span class="line-removed">113 // Specifically, we should not implement raw monitors via java monitors.</span>
<span class="line-removed">114 // Time permitting, we should disentangle and deconvolve the two implementations</span>
<span class="line-removed">115 // and move the resulting raw monitor implementation over to the JVMTI directories.</span>
<span class="line-removed">116 // Ideally, the raw monitor implementation would be built on top of</span>
<span class="line-removed">117 // park-unpark and nothing else.</span>
<span class="line-removed">118 //</span>
<span class="line-removed">119 // raw monitors are used mainly by JVMTI</span>
<span class="line-removed">120 // The raw monitor implementation borrows the ObjectMonitor structure,</span>
<span class="line-removed">121 // but the operators are degenerate and extremely simple.</span>
<span class="line-removed">122 //</span>
<span class="line-removed">123 // Mixed use of a single objectMonitor instance -- as both a raw monitor</span>
<span class="line-removed">124 // and a normal java monitor -- is not permissible.</span>
125 //
126 // Note that we use the single RawMonitor_lock to protect queue operations for
127 // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<span class="line-modified">128 // is deprecated and rare, this is not of concern.  The RawMonitor_lock can not</span>
129 // be held indefinitely.  The critical sections must be short and bounded.
130 //
131 // -------------------------------------------------------------------------
132 
<span class="line-modified">133 int JvmtiRawMonitor::SimpleEnter (Thread * Self) {</span>
134   for (;;) {
<span class="line-modified">135     if (Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">136        return OS_OK ;</span>
137     }
138 
<span class="line-modified">139     ObjectWaiter Node (Self) ;</span>
<span class="line-modified">140     Self-&gt;_ParkEvent-&gt;reset() ;     // strictly optional</span>
<span class="line-modified">141     Node.TState = ObjectWaiter::TS_ENTER ;</span>
<span class="line-modified">142 </span>
<span class="line-modified">143     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">144     Node._next  = _EntryList ;</span>
<span class="line-modified">145     _EntryList  = &amp;Node ;</span>
<span class="line-modified">146     OrderAccess::fence() ;</span>
<span class="line-modified">147     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="line-modified">148         _EntryList = Node._next ;</span>
<span class="line-modified">149         RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">150         return OS_OK ;</span>
151     }
<span class="line-modified">152     RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">153     while (Node.TState == ObjectWaiter::TS_ENTER) {</span>
<span class="line-modified">154        Self-&gt;_ParkEvent-&gt;park() ;</span>
155     }
156   }
157 }
158 
<span class="line-modified">159 int JvmtiRawMonitor::SimpleExit (Thread * Self) {</span>
<span class="line-modified">160   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">161   OrderAccess::release_store(&amp;_owner, (void*)NULL) ;</span>
<span class="line-modified">162   OrderAccess::fence() ;</span>
<span class="line-modified">163   if (_EntryList == NULL) return OS_OK ;</span>
<span class="line-modified">164   ObjectWaiter * w ;</span>

165 
<span class="line-modified">166   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">167   w = _EntryList ;</span>
168   if (w != NULL) {
<span class="line-modified">169       _EntryList = w-&gt;_next ;</span>
170   }
<span class="line-modified">171   RawMonitor_lock-&gt;unlock() ;</span>
172   if (w != NULL) {
<span class="line-modified">173       guarantee (w -&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;</span>
<span class="line-modified">174       ParkEvent * ev = w-&gt;_event ;</span>
<span class="line-modified">175       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">176       OrderAccess::fence() ;</span>
<span class="line-modified">177       ev-&gt;unpark() ;</span>





178   }
<span class="line-modified">179   return OS_OK ;</span>
180 }
181 
<span class="line-modified">182 int JvmtiRawMonitor::SimpleWait (Thread * Self, jlong millis) {</span>
<span class="line-modified">183   guarantee (_owner == Self  , &quot;invariant&quot;) ;</span>
<span class="line-modified">184   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">185 </span>
<span class="line-modified">186   ObjectWaiter Node (Self) ;</span>
<span class="line-modified">187   Node._notified = 0 ;</span>
<span class="line-modified">188   Node.TState    = ObjectWaiter::TS_WAIT ;</span>
<span class="line-modified">189 </span>
<span class="line-removed">190   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-removed">191   Node._next     = _WaitSet ;</span>
<span class="line-removed">192   _WaitSet       = &amp;Node ;</span>
<span class="line-removed">193   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-removed">194 </span>
<span class="line-removed">195   SimpleExit (Self) ;</span>
<span class="line-removed">196   guarantee (_owner != Self, &quot;invariant&quot;) ;</span>
<span class="line-removed">197 </span>
<span class="line-removed">198   int ret = OS_OK ;</span>
<span class="line-removed">199   if (millis &lt;= 0) {</span>
<span class="line-removed">200     Self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-removed">201   } else {</span>
<span class="line-removed">202     ret = Self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-removed">203   }</span>
204 

205   // If thread still resides on the waitset then unlink it.
206   // Double-checked locking -- the usage is safe in this context
<span class="line-modified">207   // as we TState is volatile and the lock-unlock operators are</span>
208   // serializing (barrier-equivalent).
209 
<span class="line-modified">210   if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
<span class="line-modified">211     RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
<span class="line-modified">212     if (Node.TState == ObjectWaiter::TS_WAIT) {</span>
213       // Simple O(n) unlink, but performance isn&#39;t critical here.
<span class="line-modified">214       ObjectWaiter * p ;</span>
<span class="line-modified">215       ObjectWaiter * q = NULL ;</span>
<span class="line-modified">216       for (p = _WaitSet ; p != &amp;Node; p = p-&gt;_next) {</span>
<span class="line-modified">217          q = p ;</span>
218       }
<span class="line-modified">219       guarantee (p == &amp;Node, &quot;invariant&quot;) ;</span>
220       if (q == NULL) {
<span class="line-modified">221         guarantee (p == _WaitSet, &quot;invariant&quot;) ;</span>
<span class="line-modified">222         _WaitSet = p-&gt;_next ;</span>
223       } else {
<span class="line-modified">224         guarantee (p == q-&gt;_next, &quot;invariant&quot;) ;</span>
<span class="line-modified">225         q-&gt;_next = p-&gt;_next ;</span>
226       }
<span class="line-modified">227       Node.TState = ObjectWaiter::TS_RUN ;</span>
228     }
<span class="line-modified">229     RawMonitor_lock-&gt;unlock() ;</span>
230   }
231 
<span class="line-modified">232   guarantee (Node.TState == ObjectWaiter::TS_RUN, &quot;invariant&quot;) ;</span>
<span class="line-modified">233   SimpleEnter (Self) ;</span>














































234 
<span class="line-modified">235   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">236   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">237   return ret ;</span>




238 }
239 
<span class="line-modified">240 int JvmtiRawMonitor::SimpleNotify (Thread * Self, bool All) {</span>
<span class="line-modified">241   guarantee (_owner == Self, &quot;invariant&quot;) ;</span>
<span class="line-modified">242   if (_WaitSet == NULL) return OS_OK ;</span>


243 
244   // We have two options:
<span class="line-modified">245   // A. Transfer the threads from the WaitSet to the EntryList</span>
<span class="line-modified">246   // B. Remove the thread from the WaitSet and unpark() it.</span>
247   //
248   // We use (B), which is crude and results in lots of futile
249   // context switching.  In particular (B) induces lots of contention.
250 
<span class="line-modified">251   ParkEvent * ev = NULL ;       // consider using a small auto array ...</span>
<span class="line-modified">252   RawMonitor_lock-&gt;lock_without_safepoint_check() ;</span>
253   for (;;) {
<span class="line-modified">254       ObjectWaiter * w = _WaitSet ;</span>
<span class="line-modified">255       if (w == NULL) break ;</span>
<span class="line-modified">256       _WaitSet = w-&gt;_next ;</span>
<span class="line-modified">257       if (ev != NULL) { ev-&gt;unpark(); ev = NULL; }</span>
<span class="line-modified">258       ev = w-&gt;_event ;</span>
<span class="line-modified">259       OrderAccess::loadstore() ;</span>
<span class="line-modified">260       w-&gt;TState = ObjectWaiter::TS_RUN ;</span>
<span class="line-modified">261       OrderAccess::storeload();</span>
<span class="line-modified">262       if (!All) break ;</span>





263   }
<span class="line-modified">264   RawMonitor_lock-&gt;unlock() ;</span>
<span class="line-modified">265   if (ev != NULL) ev-&gt;unpark();</span>
<span class="line-modified">266   return OS_OK ;</span>


267 }
268 
269 // Any JavaThread will enter here with state _thread_blocked
<span class="line-modified">270 int JvmtiRawMonitor::raw_enter(TRAPS) {</span>
<span class="line-modified">271   void * Contended ;</span>
<span class="line-modified">272 </span>
273   // don&#39;t enter raw monitor if thread is being externally suspended, it will
274   // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<span class="line-modified">275   JavaThread * jt = (JavaThread *)THREAD;</span>
<span class="line-modified">276   if (THREAD-&gt;is_Java_thread()) {</span>
277     jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
278     while (jt-&gt;is_external_suspend()) {
279       jt-&gt;SR_lock()-&gt;unlock();
280       jt-&gt;java_suspend_self();
281       jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
282     }
283     // guarded by SR_lock to avoid racing with new external suspend requests.
<span class="line-modified">284     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
285     jt-&gt;SR_lock()-&gt;unlock();
286   } else {
<span class="line-modified">287     Contended = Atomic::cmpxchg(THREAD, &amp;_owner, (void*)NULL);</span>
288   }
289 
<span class="line-modified">290   if (Contended == THREAD) {</span>
<span class="line-modified">291      _recursions ++ ;</span>
<span class="line-modified">292      return OM_OK ;</span>
293   }
294 
<span class="line-modified">295   if (Contended == NULL) {</span>
<span class="line-modified">296      guarantee (_owner == THREAD, &quot;invariant&quot;) ;</span>
<span class="line-modified">297      guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">298      return OM_OK ;</span>
299   }
300 
<span class="line-modified">301   THREAD-&gt;set_current_pending_monitor(this);</span>
<span class="line-modified">302 </span>
<span class="line-modified">303   if (!THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">304      // No other non-Java threads besides VM thread would acquire</span>
<span class="line-modified">305      // a raw monitor.</span>
<span class="line-modified">306      assert(THREAD-&gt;is_VM_thread(), &quot;must be VM thread&quot;);</span>
<span class="line-modified">307      SimpleEnter (THREAD) ;</span>
<span class="line-modified">308    } else {</span>
<span class="line-modified">309      guarantee (jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">310      for (;;) {</span>
<span class="line-modified">311        jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">312        // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">313        // java_suspend_self()</span>
<span class="line-modified">314        SimpleEnter (THREAD) ;</span>
<span class="line-modified">315 </span>
<span class="line-modified">316        // were we externally suspended while we were waiting?</span>
<span class="line-modified">317        if (!jt-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">318 </span>
<span class="line-modified">319        // This thread was externally suspended</span>
<span class="line-modified">320        //</span>
<span class="line-modified">321        // This logic isn&#39;t needed for JVMTI raw monitors,</span>
<span class="line-modified">322        // but doesn&#39;t hurt just in case the suspend rules change. This</span>
<span class="line-modified">323            // logic is needed for the JvmtiRawMonitor.wait() reentry phase.</span>
<span class="line-modified">324            // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">325            // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">326            // the monitor while suspended because that would surprise the</span>
<span class="line-modified">327            // thread that suspended us.</span>
<span class="line-modified">328            //</span>
<span class="line-removed">329            // Drop the lock -</span>
<span class="line-removed">330        SimpleExit (THREAD) ;</span>
<span class="line-removed">331 </span>
<span class="line-removed">332            jt-&gt;java_suspend_self();</span>
<span class="line-removed">333          }</span>
<span class="line-removed">334 </span>
<span class="line-removed">335      assert(_owner == THREAD, &quot;Fatal error with monitor owner!&quot;);</span>
<span class="line-removed">336      assert(_recursions == 0, &quot;Fatal error with monitor recursions!&quot;);</span>
337   }
338 
<span class="line-modified">339   THREAD-&gt;set_current_pending_monitor(NULL);</span>
<span class="line-modified">340   guarantee (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified">341   return OM_OK;</span>

342 }
343 
<span class="line-modified">344 // Used mainly for JVMTI raw monitor implementation</span>
<span class="line-modified">345 // Also used for JvmtiRawMonitor::wait().</span>
<span class="line-modified">346 int JvmtiRawMonitor::raw_exit(TRAPS) {</span>
<span class="line-removed">347   if (THREAD != _owner) {</span>
<span class="line-removed">348     return OM_ILLEGAL_MONITOR_STATE;</span>
349   }
350   if (_recursions &gt; 0) {
<span class="line-modified">351     --_recursions ;</span>
<span class="line-modified">352     return OM_OK ;</span>

353   }
354 
<span class="line-modified">355   void * List = _EntryList ;</span>
<span class="line-removed">356   SimpleExit (THREAD) ;</span>
<span class="line-removed">357 </span>
<span class="line-removed">358   return OM_OK;</span>
359 }
360 
<span class="line-modified">361 // Used for JVMTI raw monitor implementation.</span>
<span class="line-modified">362 // All JavaThreads will enter here with state _thread_blocked</span>
<span class="line-modified">363 </span>
<span class="line-removed">364 int JvmtiRawMonitor::raw_wait(jlong millis, bool interruptible, TRAPS) {</span>
<span class="line-removed">365   if (THREAD != _owner) {</span>
<span class="line-removed">366     return OM_ILLEGAL_MONITOR_STATE;</span>
367   }
368 
<span class="line-modified">369   // To avoid spurious wakeups we reset the parkevent -- This is strictly optional.</span>
<span class="line-removed">370   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-removed">371   THREAD-&gt;_ParkEvent-&gt;reset() ;</span>
<span class="line-removed">372   OrderAccess::fence() ;</span>
<span class="line-removed">373 </span>
<span class="line-removed">374   // check interrupt event</span>
<span class="line-removed">375   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">376     return OM_INTERRUPTED;</span>
<span class="line-removed">377   }</span>
378 
<span class="line-modified">379   intptr_t save = _recursions ;</span>
<span class="line-modified">380   _recursions = 0 ;</span>
<span class="line-modified">381   _waiters ++ ;</span>
<span class="line-modified">382   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">383     guarantee (((JavaThread *) THREAD)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;) ;</span>
<span class="line-modified">384     ((JavaThread *)THREAD)-&gt;set_suspend_equivalent();</span>
<span class="line-modified">385   }</span>
<span class="line-modified">386   int rv = SimpleWait (THREAD, millis) ;</span>
<span class="line-modified">387   _recursions = save ;</span>
<span class="line-modified">388   _waiters -- ;</span>
<span class="line-modified">389 </span>
<span class="line-modified">390   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
<span class="line-modified">391   if (THREAD-&gt;is_Java_thread()) {</span>
<span class="line-modified">392      JavaThread * jSelf = (JavaThread *) THREAD ;</span>
<span class="line-modified">393      for (;;) {</span>
<span class="line-modified">394         if (!jSelf-&gt;handle_special_suspend_equivalent_condition()) break ;</span>
<span class="line-modified">395         SimpleExit (THREAD) ;</span>
<span class="line-modified">396         jSelf-&gt;java_suspend_self();</span>
<span class="line-modified">397         SimpleEnter (THREAD) ;</span>
<span class="line-modified">398         jSelf-&gt;set_suspend_equivalent() ;</span>
<span class="line-modified">399      }</span>






















400   }
<span class="line-removed">401   guarantee (THREAD == _owner, &quot;invariant&quot;) ;</span>
402 
<span class="line-modified">403   if (interruptible &amp;&amp; Thread::is_interrupted(THREAD, true)) {</span>
<span class="line-removed">404     return OM_INTERRUPTED;</span>
<span class="line-removed">405   }</span>
<span class="line-removed">406   return OM_OK ;</span>
407 }
408 
<span class="line-modified">409 int JvmtiRawMonitor::raw_notify(TRAPS) {</span>
<span class="line-modified">410   if (THREAD != _owner) {</span>
<span class="line-modified">411     return OM_ILLEGAL_MONITOR_STATE;</span>
412   }
<span class="line-modified">413   SimpleNotify (THREAD, false) ;</span>
<span class="line-modified">414   return OM_OK;</span>
415 }
416 
<span class="line-modified">417 int JvmtiRawMonitor::raw_notifyAll(TRAPS) {</span>
<span class="line-modified">418   if (THREAD != _owner) {</span>
<span class="line-modified">419     return OM_ILLEGAL_MONITOR_STATE;</span>
420   }
<span class="line-modified">421   SimpleNotify (THREAD, true) ;</span>
<span class="line-modified">422   return OM_OK;</span>
423 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #if INCLUDE_TSAN
 33 #include &quot;tsan/tsan.hpp&quot;
 34 #endif  // INCLUDE_TSAN
 35 
<span class="line-modified"> 36 JvmtiRawMonitor::QNode::QNode(Thread* thread) : _next(NULL), _prev(NULL),</span>
<span class="line-added"> 37                                                 _event(thread-&gt;_ParkEvent),</span>
<span class="line-added"> 38                                                 _notified(0), _t_state(TS_RUN) {</span>
<span class="line-added"> 39 }</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 GrowableArray&lt;JvmtiRawMonitor*&gt;* JvmtiPendingMonitors::_monitors =</span>
<span class="line-added"> 42   new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JvmtiRawMonitor*&gt;(1, true);</span>
 43 
 44 void JvmtiPendingMonitors::transition_raw_monitors() {
 45   assert((Threads::number_of_threads()==1),
<span class="line-modified"> 46          &quot;Java thread has not been created yet or more than one java thread &quot;</span>
<span class="line-modified"> 47          &quot;is running. Raw monitor transition will not work&quot;);</span>
<span class="line-modified"> 48   JavaThread* current_java_thread = JavaThread::current();</span>
 49   assert(current_java_thread-&gt;thread_state() == _thread_in_vm, &quot;Must be in vm&quot;);
<span class="line-modified"> 50   for (int i = 0; i &lt; count(); i++) {</span>
<span class="line-modified"> 51     JvmtiRawMonitor* rmonitor = monitors()-&gt;at(i);</span>
<span class="line-modified"> 52     rmonitor-&gt;raw_enter(current_java_thread);</span>
<span class="line-modified"> 53     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));</span>




 54   }
 55   // pending monitors are converted to real monitor so delete them all.
 56   dispose();
 57 }
 58 
 59 //
 60 // class JvmtiRawMonitor
 61 //
 62 
<span class="line-modified"> 63 JvmtiRawMonitor::JvmtiRawMonitor(const char* name) : _owner(NULL),</span>
<span class="line-added"> 64                                                      _recursions(0),</span>
<span class="line-added"> 65                                                      _entry_list(NULL),</span>
<span class="line-added"> 66                                                      _wait_set(NULL),</span>
<span class="line-added"> 67                                                      _waiters(0),</span>
<span class="line-added"> 68                                                      _magic(JVMTI_RM_MAGIC),</span>
<span class="line-added"> 69                                                      _name(NULL) {</span>
 70 #ifdef ASSERT
 71   _name = strcpy(NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtInternal), name);


 72 #endif

 73 }
 74 
 75 JvmtiRawMonitor::~JvmtiRawMonitor() {
 76 #ifdef ASSERT
 77   FreeHeap(_name);
 78 #endif
 79   _magic = 0;
 80 }
 81 
 82 
 83 bool
 84 JvmtiRawMonitor::is_valid() {
 85   int value = 0;
 86 
 87   // This object might not be a JvmtiRawMonitor so we can&#39;t assume
 88   // the _magic field is properly aligned. Get the value in a safe
 89   // way and then check against JVMTI_RM_MAGIC.
 90 
 91   switch (sizeof(_magic)) {
 92   case 2:
 93     value = Bytes::get_native_u2((address)&amp;_magic);
 94     break;
 95 
 96   case 4:
 97     value = Bytes::get_native_u4((address)&amp;_magic);
 98     break;
 99 
100   case 8:
101     value = Bytes::get_native_u8((address)&amp;_magic);
102     break;
103 
104   default:
105     guarantee(false, &quot;_magic field is an unexpected size&quot;);
106   }
107 
108   return value == JVMTI_RM_MAGIC;
109 }
110 
111 // -------------------------------------------------------------------------
<span class="line-modified">112 // The JVMTI raw monitor subsystem is entirely distinct from normal</span>
<span class="line-modified">113 // java-synchronization or jni-synchronization.  JVMTI raw monitors are not</span>
114 // associated with objects.  They can be implemented in any manner
115 // that makes sense.  The original implementors decided to piggy-back
<span class="line-modified">116 // the raw-monitor implementation on the existing Java ObjectMonitor mechanism.</span>
<span class="line-modified">117 // Now we just use a simplified form of that ObjectMonitor code.</span>












118 //
119 // Note that we use the single RawMonitor_lock to protect queue operations for
120 // _all_ raw monitors.  This is a scalability impediment, but since raw monitor usage
<span class="line-modified">121 // is fairly rare, this is not of concern.  The RawMonitor_lock can not</span>
122 // be held indefinitely.  The critical sections must be short and bounded.
123 //
124 // -------------------------------------------------------------------------
125 
<span class="line-modified">126 void JvmtiRawMonitor::simple_enter(Thread* self) {</span>
127   for (;;) {
<span class="line-modified">128     if (Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">129       return;</span>
130     }
131 
<span class="line-modified">132     QNode node(self);</span>
<span class="line-modified">133     self-&gt;_ParkEvent-&gt;reset();     // strictly optional</span>
<span class="line-modified">134     node._t_state = QNode::TS_ENTER;</span>
<span class="line-modified">135 </span>
<span class="line-modified">136     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">137     node._next = _entry_list;</span>
<span class="line-modified">138     _entry_list = &amp;node;</span>
<span class="line-modified">139     OrderAccess::fence();</span>
<span class="line-modified">140     if (_owner == NULL &amp;&amp; Atomic::replace_if_null(&amp;_owner, self)) {</span>
<span class="line-modified">141       _entry_list = node._next;</span>
<span class="line-modified">142       RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">143       return;</span>
144     }
<span class="line-modified">145     RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">146     while (node._t_state == QNode::TS_ENTER) {</span>
<span class="line-modified">147       self-&gt;_ParkEvent-&gt;park();</span>
148     }
149   }
150 }
151 
<span class="line-modified">152 void JvmtiRawMonitor::simple_exit(Thread* self) {</span>
<span class="line-modified">153   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">154   Atomic::release_store(&amp;_owner, (Thread*)NULL);</span>
<span class="line-modified">155   OrderAccess::fence();</span>
<span class="line-modified">156   if (_entry_list == NULL) {</span>
<span class="line-modified">157     return;</span>
<span class="line-added">158   }</span>
159 
<span class="line-modified">160   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">161   QNode* w = _entry_list;</span>
162   if (w != NULL) {
<span class="line-modified">163     _entry_list = w-&gt;_next;</span>
164   }
<span class="line-modified">165   RawMonitor_lock-&gt;unlock();</span>
166   if (w != NULL) {
<span class="line-modified">167     guarantee(w -&gt;_t_state == QNode::TS_ENTER, &quot;invariant&quot;);</span>
<span class="line-modified">168     // Once we set _t_state to TS_RUN the waiting thread can complete</span>
<span class="line-modified">169     // simple_enter and &#39;w&#39; is pointing into random stack space. So we have</span>
<span class="line-modified">170     // to ensure we extract the ParkEvent (which is in type-stable memory)</span>
<span class="line-modified">171     // before we set the state, and then don&#39;t access &#39;w&#39;.</span>
<span class="line-added">172     ParkEvent* ev = w-&gt;_event;</span>
<span class="line-added">173     OrderAccess::loadstore();</span>
<span class="line-added">174     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">175     OrderAccess::fence();</span>
<span class="line-added">176     ev-&gt;unpark();</span>
177   }
<span class="line-modified">178   return;</span>
179 }
180 
<span class="line-modified">181 inline void JvmtiRawMonitor::enqueue_waiter(QNode&amp; node) {</span>
<span class="line-modified">182   node._notified = 0;</span>
<span class="line-modified">183   node._t_state = QNode::TS_WAIT;</span>
<span class="line-modified">184   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">185   node._next = _wait_set;</span>
<span class="line-modified">186   _wait_set = &amp;node;</span>
<span class="line-modified">187   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">188 }</span>














189 
<span class="line-added">190 inline void JvmtiRawMonitor::dequeue_waiter(QNode&amp; node) {</span>
191   // If thread still resides on the waitset then unlink it.
192   // Double-checked locking -- the usage is safe in this context
<span class="line-modified">193   // as _t_state is volatile and the lock-unlock operators are</span>
194   // serializing (barrier-equivalent).
195 
<span class="line-modified">196   if (node._t_state == QNode::TS_WAIT) {</span>
<span class="line-modified">197     RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">198     if (node._t_state == QNode::TS_WAIT) {</span>
199       // Simple O(n) unlink, but performance isn&#39;t critical here.
<span class="line-modified">200       QNode* p;</span>
<span class="line-modified">201       QNode* q = NULL;</span>
<span class="line-modified">202       for (p = _wait_set; p != &amp;node; p = p-&gt;_next) {</span>
<span class="line-modified">203         q = p;</span>
204       }
<span class="line-modified">205       guarantee(p == &amp;node, &quot;invariant&quot;);</span>
206       if (q == NULL) {
<span class="line-modified">207         guarantee (p == _wait_set, &quot;invariant&quot;);</span>
<span class="line-modified">208         _wait_set = p-&gt;_next;</span>
209       } else {
<span class="line-modified">210         guarantee(p == q-&gt;_next, &quot;invariant&quot;);</span>
<span class="line-modified">211         q-&gt;_next = p-&gt;_next;</span>
212       }
<span class="line-modified">213       node._t_state = QNode::TS_RUN;</span>
214     }
<span class="line-modified">215     RawMonitor_lock-&gt;unlock();</span>
216   }
217 
<span class="line-modified">218   guarantee(node._t_state == QNode::TS_RUN, &quot;invariant&quot;);</span>
<span class="line-modified">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 // simple_wait is not quite so simple as we have to deal with the interaction</span>
<span class="line-added">222 // with the Thread interrupt state, which resides in the java.lang.Thread object.</span>
<span class="line-added">223 // That state must only be accessed while _thread_in_vm and requires proper thread-state</span>
<span class="line-added">224 // transitions. However, we cannot perform such transitions whilst we hold the RawMonitor,</span>
<span class="line-added">225 // else we can deadlock with the VMThread (which may also use RawMonitors as part of</span>
<span class="line-added">226 // executing various callbacks).</span>
<span class="line-added">227 // Returns M_OK usually, but M_INTERRUPTED if the thread is a JavaThread and was</span>
<span class="line-added">228 // interrupted.</span>
<span class="line-added">229 int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {</span>
<span class="line-added">230   guarantee(_owner == self  , &quot;invariant&quot;);</span>
<span class="line-added">231   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">232 </span>
<span class="line-added">233   QNode node(self);</span>
<span class="line-added">234   enqueue_waiter(node);</span>
<span class="line-added">235 </span>
<span class="line-added">236   simple_exit(self);</span>
<span class="line-added">237   guarantee(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">238 </span>
<span class="line-added">239   int ret = M_OK;</span>
<span class="line-added">240   if (self-&gt;is_Java_thread()) {</span>
<span class="line-added">241     JavaThread* jt = (JavaThread*) self;</span>
<span class="line-added">242     // Transition to VM so we can check interrupt state</span>
<span class="line-added">243     ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">244     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">245         ret = M_INTERRUPTED;</span>
<span class="line-added">246     } else {</span>
<span class="line-added">247       ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">248       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">249       if (millis &lt;= 0) {</span>
<span class="line-added">250         self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">251       } else {</span>
<span class="line-added">252         self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">253       }</span>
<span class="line-added">254       // Return to VM before post-check of interrupt state</span>
<span class="line-added">255     }</span>
<span class="line-added">256     if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">257       ret = M_INTERRUPTED;</span>
<span class="line-added">258     }</span>
<span class="line-added">259   } else {</span>
<span class="line-added">260     if (millis &lt;= 0) {</span>
<span class="line-added">261       self-&gt;_ParkEvent-&gt;park();</span>
<span class="line-added">262     } else {</span>
<span class="line-added">263       self-&gt;_ParkEvent-&gt;park(millis);</span>
<span class="line-added">264     }</span>
<span class="line-added">265   }</span>
266 
<span class="line-modified">267   dequeue_waiter(node);</span>
<span class="line-modified">268 </span>
<span class="line-modified">269   simple_enter(self);</span>
<span class="line-added">270   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">271   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-added">272 </span>
<span class="line-added">273   return ret;</span>
274 }
275 
<span class="line-modified">276 void JvmtiRawMonitor::simple_notify(Thread* self, bool all) {</span>
<span class="line-modified">277   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">278   if (_wait_set == NULL) {</span>
<span class="line-added">279     return;</span>
<span class="line-added">280   }</span>
281 
282   // We have two options:
<span class="line-modified">283   // A. Transfer the threads from the _wait_set to the _entry_list</span>
<span class="line-modified">284   // B. Remove the thread from the _wait_set and unpark() it.</span>
285   //
286   // We use (B), which is crude and results in lots of futile
287   // context switching.  In particular (B) induces lots of contention.
288 
<span class="line-modified">289   ParkEvent* ev = NULL;       // consider using a small auto array ...</span>
<span class="line-modified">290   RawMonitor_lock-&gt;lock_without_safepoint_check();</span>
291   for (;;) {
<span class="line-modified">292     QNode* w = _wait_set;</span>
<span class="line-modified">293     if (w == NULL) break;</span>
<span class="line-modified">294     _wait_set = w-&gt;_next;</span>
<span class="line-modified">295     if (ev != NULL) {</span>
<span class="line-modified">296       ev-&gt;unpark();</span>
<span class="line-modified">297       ev = NULL;</span>
<span class="line-modified">298     }</span>
<span class="line-modified">299     ev = w-&gt;_event;</span>
<span class="line-modified">300     OrderAccess::loadstore();</span>
<span class="line-added">301     w-&gt;_t_state = QNode::TS_RUN;</span>
<span class="line-added">302     OrderAccess::storeload();</span>
<span class="line-added">303     if (!all) {</span>
<span class="line-added">304       break;</span>
<span class="line-added">305     }</span>
306   }
<span class="line-modified">307   RawMonitor_lock-&gt;unlock();</span>
<span class="line-modified">308   if (ev != NULL) {</span>
<span class="line-modified">309     ev-&gt;unpark();</span>
<span class="line-added">310   }</span>
<span class="line-added">311   return;</span>
312 }
313 
314 // Any JavaThread will enter here with state _thread_blocked
<span class="line-modified">315 void JvmtiRawMonitor::raw_enter(Thread* self) {</span>
<span class="line-modified">316   void* contended;</span>
<span class="line-modified">317   JavaThread* jt = NULL;</span>
318   // don&#39;t enter raw monitor if thread is being externally suspended, it will
319   // surprise the suspender if a &quot;suspended&quot; thread can still enter monitor
<span class="line-modified">320   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">321     jt = (JavaThread*)self;</span>
322     jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
323     while (jt-&gt;is_external_suspend()) {
324       jt-&gt;SR_lock()-&gt;unlock();
325       jt-&gt;java_suspend_self();
326       jt-&gt;SR_lock()-&gt;lock_without_safepoint_check();
327     }
328     // guarded by SR_lock to avoid racing with new external suspend requests.
<span class="line-modified">329     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, jt);</span>
330     jt-&gt;SR_lock()-&gt;unlock();
331   } else {
<span class="line-modified">332     contended = Atomic::cmpxchg(&amp;_owner, (Thread*)NULL, self);</span>
333   }
334 
<span class="line-modified">335   if (contended == self) {</span>
<span class="line-modified">336     _recursions++;</span>
<span class="line-modified">337     return;</span>
338   }
339 
<span class="line-modified">340   if (contended == NULL) {</span>
<span class="line-modified">341     guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-modified">342     guarantee(_recursions == 0, &quot;invariant&quot;);</span>
<span class="line-modified">343     return;</span>
344   }
345 
<span class="line-modified">346   self-&gt;set_current_pending_raw_monitor(this);</span>
<span class="line-modified">347 </span>
<span class="line-modified">348   if (!self-&gt;is_Java_thread()) {</span>
<span class="line-modified">349     simple_enter(self);</span>
<span class="line-modified">350   } else {</span>
<span class="line-modified">351     guarantee(jt-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;);</span>
<span class="line-modified">352     for (;;) {</span>
<span class="line-modified">353       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">354       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-modified">355       // java_suspend_self()</span>
<span class="line-modified">356       simple_enter(jt);</span>
<span class="line-modified">357 </span>
<span class="line-modified">358       // were we externally suspended while we were waiting?</span>
<span class="line-modified">359       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">360         break;</span>
<span class="line-modified">361       }</span>
<span class="line-modified">362 </span>
<span class="line-modified">363       // This thread was externally suspended</span>
<span class="line-modified">364       // We have reentered the contended monitor, but while we were</span>
<span class="line-modified">365       // waiting another thread suspended us. We don&#39;t want to reenter</span>
<span class="line-modified">366       // the monitor while suspended because that would surprise the</span>
<span class="line-modified">367       // thread that suspended us.</span>
<span class="line-modified">368       //</span>
<span class="line-modified">369       // Drop the lock</span>
<span class="line-modified">370       simple_exit(jt);</span>
<span class="line-modified">371 </span>
<span class="line-modified">372       jt-&gt;java_suspend_self();</span>
<span class="line-modified">373     }</span>








374   }
375 
<span class="line-modified">376   self-&gt;set_current_pending_raw_monitor(NULL);</span>
<span class="line-modified">377 </span>
<span class="line-modified">378   guarantee(_owner == self, &quot;invariant&quot;);</span>
<span class="line-added">379   guarantee(_recursions == 0, &quot;invariant&quot;);</span>
380 }
381 
<span class="line-modified">382 int JvmtiRawMonitor::raw_exit(Thread* self) {</span>
<span class="line-modified">383   if (self != _owner) {</span>
<span class="line-modified">384     return M_ILLEGAL_MONITOR_STATE;</span>


385   }
386   if (_recursions &gt; 0) {
<span class="line-modified">387     _recursions--;</span>
<span class="line-modified">388   } else {</span>
<span class="line-added">389     simple_exit(self);</span>
390   }
391 
<span class="line-modified">392   return M_OK;</span>



393 }
394 
<span class="line-modified">395 int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {</span>
<span class="line-modified">396   if (self != _owner) {</span>
<span class="line-modified">397     return M_ILLEGAL_MONITOR_STATE;</span>



398   }
399 
<span class="line-modified">400   int ret = M_OK;</span>








401 
<span class="line-modified">402   // To avoid spurious wakeups we reset the parkevent. This is strictly optional.</span>
<span class="line-modified">403   // The caller must be able to tolerate spurious returns from raw_wait().</span>
<span class="line-modified">404   self-&gt;_ParkEvent-&gt;reset();</span>
<span class="line-modified">405   OrderAccess::fence();</span>
<span class="line-modified">406 </span>
<span class="line-modified">407   intptr_t save = _recursions;</span>
<span class="line-modified">408   _recursions = 0;</span>
<span class="line-modified">409   _waiters++;</span>
<span class="line-modified">410   ret = simple_wait(self, millis);</span>
<span class="line-modified">411   _recursions = save;</span>
<span class="line-modified">412   _waiters--;</span>
<span class="line-modified">413 </span>
<span class="line-modified">414   guarantee(self == _owner, &quot;invariant&quot;);</span>
<span class="line-modified">415 </span>
<span class="line-modified">416   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">417     JavaThread* jt = (JavaThread*)self;</span>
<span class="line-modified">418     for (;;) {</span>
<span class="line-modified">419       jt-&gt;set_suspend_equivalent();</span>
<span class="line-modified">420       if (!jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">421         break;</span>
<span class="line-modified">422       } else {</span>
<span class="line-added">423         // We&#39;ve been suspended whilst waiting and so we have to</span>
<span class="line-added">424         // relinquish the raw monitor until we are resumed. Of course</span>
<span class="line-added">425         // after reacquiring we have to re-check for suspension again.</span>
<span class="line-added">426         // Suspension requires we are _thread_blocked, and we also have to</span>
<span class="line-added">427         // recheck for being interrupted.</span>
<span class="line-added">428         simple_exit(jt);</span>
<span class="line-added">429         {</span>
<span class="line-added">430           ThreadInVMfromNative tivm(jt);</span>
<span class="line-added">431           {</span>
<span class="line-added">432             ThreadBlockInVM tbivm(jt);</span>
<span class="line-added">433             jt-&gt;java_suspend_self();</span>
<span class="line-added">434           }</span>
<span class="line-added">435           if (jt-&gt;is_interrupted(true)) {</span>
<span class="line-added">436             ret = M_INTERRUPTED;</span>
<span class="line-added">437           }</span>
<span class="line-added">438         }</span>
<span class="line-added">439         simple_enter(jt);</span>
<span class="line-added">440       }</span>
<span class="line-added">441     }</span>
<span class="line-added">442     guarantee(jt == _owner, &quot;invariant&quot;);</span>
<span class="line-added">443   } else {</span>
<span class="line-added">444     assert(ret != M_INTERRUPTED, &quot;Only JavaThreads can be interrupted&quot;);</span>
445   }

446 
<span class="line-modified">447   return ret;</span>



448 }
449 
<span class="line-modified">450 int JvmtiRawMonitor::raw_notify(Thread* self) {</span>
<span class="line-modified">451   if (self != _owner) {</span>
<span class="line-modified">452     return M_ILLEGAL_MONITOR_STATE;</span>
453   }
<span class="line-modified">454   simple_notify(self, false);</span>
<span class="line-modified">455   return M_OK;</span>
456 }
457 
<span class="line-modified">458 int JvmtiRawMonitor::raw_notifyAll(Thread* self) {</span>
<span class="line-modified">459   if (self != _owner) {</span>
<span class="line-modified">460     return M_ILLEGAL_MONITOR_STATE;</span>
461   }
<span class="line-modified">462   simple_notify(self, true);</span>
<span class="line-modified">463   return M_OK;</span>
464 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiManageCapabilities.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRawMonitor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
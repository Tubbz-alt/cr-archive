<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiClassFileReconstituter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;oops/fieldStreams.hpp&quot;</span>


 29 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/signature.hpp&quot;
 32 #include &quot;utilities/bytes.hpp&quot;
 33 
 34 // FIXME: add Deprecated attribute
 35 // FIXME: fix Synthetic attribute
 36 // FIXME: per Serguei, add error return handling for ConstantPool::copy_cpool_bytes()
 37 
 38 JvmtiConstantPoolReconstituter::JvmtiConstantPoolReconstituter(InstanceKlass* ik) {
 39   set_error(JVMTI_ERROR_NONE);
 40   _ik = ik;
 41   _cpool = constantPoolHandle(Thread::current(), ik-&gt;constants());
 42   _symmap = new SymbolHashMap();
 43   _classmap = new SymbolHashMap();
 44   _cpool_size = _cpool-&gt;hash_entries_to(_symmap, _classmap);
 45   if (_cpool_size == 0) {
 46     set_error(JVMTI_ERROR_OUT_OF_MEMORY);
 47   } else if (_cpool_size &lt; 0) {
 48     set_error(JVMTI_ERROR_INTERNAL);
 49   }
 50 }
 51 
 52 // Write the field information portion of ClassFile structure
 53 // JVMSpec|     u2 fields_count;
 54 // JVMSpec|     field_info fields[fields_count];
 55 void JvmtiClassFileReconstituter::write_field_infos() {
 56   HandleMark hm(thread());
 57   Array&lt;AnnotationArray*&gt;* fields_anno = ik()-&gt;fields_annotations();
 58   Array&lt;AnnotationArray*&gt;* fields_type_anno = ik()-&gt;fields_type_annotations();
 59 
 60   // Compute the real number of Java fields
 61   int java_fields = ik()-&gt;java_fields_count();
 62 
 63   write_u2(java_fields);
 64   for (JavaFieldStream fs(ik()); !fs.done(); fs.next()) {
 65     AccessFlags access_flags = fs.access_flags();
 66     int name_index = fs.name_index();
 67     int signature_index = fs.signature_index();
 68     int initial_value_index = fs.initval_index();
 69     guarantee(name_index != 0 &amp;&amp; signature_index != 0, &quot;bad constant pool index for field&quot;);
 70     // int offset = ik()-&gt;field_offset( index );
 71     int generic_signature_index = fs.generic_signature_index();
 72     AnnotationArray* anno = fields_anno == NULL ? NULL : fields_anno-&gt;at(fs.index());
 73     AnnotationArray* type_anno = fields_type_anno == NULL ? NULL : fields_type_anno-&gt;at(fs.index());
 74 
 75     // JVMSpec|   field_info {
 76     // JVMSpec|         u2 access_flags;
 77     // JVMSpec|         u2 name_index;
 78     // JVMSpec|         u2 descriptor_index;
 79     // JVMSpec|         u2 attributes_count;
 80     // JVMSpec|         attribute_info attributes[attributes_count];
 81     // JVMSpec|   }
 82 
 83     write_u2(access_flags.as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
 84     write_u2(name_index);
 85     write_u2(signature_index);
 86     int attr_count = 0;
 87     if (initial_value_index != 0) {
 88       ++attr_count;
 89     }
 90     if (access_flags.is_synthetic()) {
 91       // ++attr_count;
 92     }
 93     if (generic_signature_index != 0) {
 94       ++attr_count;
 95     }
 96     if (anno != NULL) {
 97       ++attr_count;     // has RuntimeVisibleAnnotations attribute
 98     }
 99     if (type_anno != NULL) {
100       ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
101     }
102 
103     write_u2(attr_count);
104 
105     if (initial_value_index != 0) {
106       write_attribute_name_index(&quot;ConstantValue&quot;);
107       write_u4(2); //length always 2
108       write_u2(initial_value_index);
109     }
110     if (access_flags.is_synthetic()) {
111       // write_synthetic_attribute();
112     }
113     if (generic_signature_index != 0) {
114       write_signature_attribute(generic_signature_index);
115     }
116     if (anno != NULL) {
117       write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
118     }
119     if (type_anno != NULL) {
120       write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
121     }
122   }
123 }
124 
125 // Write Code attribute
126 // JVMSpec|   Code_attribute {
127 // JVMSpec|     u2 attribute_name_index;
128 // JVMSpec|     u4 attribute_length;
129 // JVMSpec|     u2 max_stack;
130 // JVMSpec|     u2 max_locals;
131 // JVMSpec|     u4 code_length;
132 // JVMSpec|     u1 code[code_length];
133 // JVMSpec|     u2 exception_table_length;
134 // JVMSpec|     {       u2 start_pc;
135 // JVMSpec|             u2 end_pc;
136 // JVMSpec|             u2  handler_pc;
137 // JVMSpec|             u2  catch_type;
138 // JVMSpec|     }       exception_table[exception_table_length];
139 // JVMSpec|     u2 attributes_count;
140 // JVMSpec|     attribute_info attributes[attributes_count];
141 // JVMSpec|   }
142 void JvmtiClassFileReconstituter::write_code_attribute(const methodHandle&amp; method) {
143   ConstMethod* const_method = method-&gt;constMethod();
144   u2 line_num_cnt = 0;
145   int stackmap_len = 0;
146   int local_variable_table_length = 0;
147   int local_variable_type_table_length = 0;
148 
149   // compute number and length of attributes
150   int attr_count = 0;
151   int attr_size = 0;
152   if (const_method-&gt;has_linenumber_table()) {
153     line_num_cnt = line_number_table_entries(method);
154     if (line_num_cnt != 0) {
155       ++attr_count;
156       // Compute the complete size of the line number table attribute:
157       //      LineNumberTable_attribute {
158       //        u2 attribute_name_index;
159       //        u4 attribute_length;
160       //        u2 line_number_table_length;
161       //        {  u2 start_pc;
162       //           u2 line_number;
163       //        } line_number_table[line_number_table_length];
164       //      }
165       attr_size += 2 + 4 + 2 + line_num_cnt * (2 + 2);
166     }
167   }
168   if (method-&gt;has_stackmap_table()) {
169     stackmap_len = method-&gt;stackmap_data()-&gt;length();
170     if (stackmap_len != 0) {
171       ++attr_count;
172       // Compute the  size of the stack map table attribute (VM stores raw):
173       //      StackMapTable_attribute {
174       //        u2 attribute_name_index;
175       //        u4 attribute_length;
176       //        u2 number_of_entries;
177       //        stack_map_frame_entries[number_of_entries];
178       //      }
179       attr_size += 2 + 4 + stackmap_len;
180     }
181   }
182   if (method-&gt;has_localvariable_table()) {
183     local_variable_table_length = method-&gt;localvariable_table_length();
184     if (local_variable_table_length != 0) {
185       ++attr_count;
186       // Compute the size of the local variable table attribute (VM stores raw):
187       // LocalVariableTable_attribute {
188       //   u2 attribute_name_index;
189       //   u4 attribute_length;
190       //   u2 local_variable_table_length;
191       //   {
192       //     u2 start_pc;
193       //     u2 length;
194       //     u2 name_index;
195       //     u2 descriptor_index;
196       //     u2 index;
197       //   }
198       attr_size += 2 + 4 + 2 + local_variable_table_length * (2 + 2 + 2 + 2 + 2);
199 
200       // Local variables with generic signatures must have LVTT entries
201       LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
202       for (int idx = 0; idx &lt; local_variable_table_length; idx++) {
203         if (elem[idx].signature_cp_index != 0) {
204           local_variable_type_table_length++;
205         }
206       }
207 
208       if (local_variable_type_table_length != 0) {
209         ++attr_count;
210         // Compute the size of the local variable type table attribute (VM stores raw):
211         // LocalVariableTypeTable_attribute {
212         //   u2 attribute_name_index;
213         //   u4 attribute_length;
214         //   u2 local_variable_type_table_length;
215         //   {
216         //     u2 start_pc;
217         //     u2 length;
218         //     u2 name_index;
219         //     u2 signature_index;
220         //     u2 index;
221         //   }
222         attr_size += 2 + 4 + 2 + local_variable_type_table_length * (2 + 2 + 2 + 2 + 2);
223       }
224     }
225   }
226 
227   ExceptionTable exception_table(method());
228   int exception_table_length = exception_table.length();
229   int code_size = const_method-&gt;code_size();
230   int size =
231     2+2+4 +                                // max_stack, max_locals, code_length
232     code_size +                            // code
233     2 +                                    // exception_table_length
234     (2+2+2+2) * exception_table_length +   // exception_table
235     2 +                                    // attributes_count
236     attr_size;                             // attributes
237 
238   write_attribute_name_index(&quot;Code&quot;);
239   write_u4(size);
240   write_u2(method-&gt;verifier_max_stack());
241   write_u2(method-&gt;max_locals());
242   write_u4(code_size);
243   copy_bytecodes(method, (unsigned char*)writeable_address(code_size));
244   write_u2(exception_table_length);
245   for (int index = 0; index &lt; exception_table_length; index++) {
246     write_u2(exception_table.start_pc(index));
247     write_u2(exception_table.end_pc(index));
248     write_u2(exception_table.handler_pc(index));
249     write_u2(exception_table.catch_type_index(index));
250   }
251   write_u2(attr_count);
252   if (line_num_cnt != 0) {
253     write_line_number_table_attribute(method, line_num_cnt);
254   }
255   if (stackmap_len != 0) {
256     write_stackmap_table_attribute(method, stackmap_len);
257   }
258   if (local_variable_table_length != 0) {
259     write_local_variable_table_attribute(method, local_variable_table_length);
260   }
261   if (local_variable_type_table_length != 0) {
262     write_local_variable_type_table_attribute(method, local_variable_type_table_length);
263   }
264 }
265 
266 // Write Exceptions attribute
267 // JVMSpec|   Exceptions_attribute {
268 // JVMSpec|     u2 attribute_name_index;
269 // JVMSpec|     u4 attribute_length;
270 // JVMSpec|     u2 number_of_exceptions;
271 // JVMSpec|     u2 exception_index_table[number_of_exceptions];
272 // JVMSpec|   }
273 void JvmtiClassFileReconstituter::write_exceptions_attribute(ConstMethod* const_method) {
274   CheckedExceptionElement* checked_exceptions = const_method-&gt;checked_exceptions_start();
275   int checked_exceptions_length = const_method-&gt;checked_exceptions_length();
276   int size =
277     2 +                                    // number_of_exceptions
278     2 * checked_exceptions_length;         // exception_index_table
279 
280   write_attribute_name_index(&quot;Exceptions&quot;);
281   write_u4(size);
282   write_u2(checked_exceptions_length);
283   for (int index = 0; index &lt; checked_exceptions_length; index++) {
284     write_u2(checked_exceptions[index].class_cp_index);
285   }
286 }
287 
288 // Write SourceFile attribute
289 // JVMSpec|   SourceFile_attribute {
290 // JVMSpec|     u2 attribute_name_index;
291 // JVMSpec|     u4 attribute_length;
292 // JVMSpec|     u2 sourcefile_index;
293 // JVMSpec|   }
294 void JvmtiClassFileReconstituter::write_source_file_attribute() {
295   assert(ik()-&gt;source_file_name() != NULL, &quot;caller must check&quot;);
296 
297   write_attribute_name_index(&quot;SourceFile&quot;);
298   write_u4(2);  // always length 2
299   write_u2(symbol_to_cpool_index(ik()-&gt;source_file_name()));
300 }
301 
302 // Write SourceDebugExtension attribute
303 // JSR45|   SourceDebugExtension_attribute {
304 // JSR45|       u2 attribute_name_index;
305 // JSR45|       u4 attribute_length;
306 // JSR45|       u1 debug_extension[attribute_length];
307 // JSR45|   }
308 void JvmtiClassFileReconstituter::write_source_debug_extension_attribute() {
309   assert(ik()-&gt;source_debug_extension() != NULL, &quot;caller must check&quot;);
310 
311   write_attribute_name_index(&quot;SourceDebugExtension&quot;);
312   int len = (int)strlen(ik()-&gt;source_debug_extension());
313   write_u4(len);
314   u1* ext = (u1*)ik()-&gt;source_debug_extension();
315   for (int i=0; i&lt;len; i++) {
316     write_u1(ext[i]);
317   }
318 }
319 
320 // Write (generic) Signature attribute
321 // JVMSpec|   Signature_attribute {
322 // JVMSpec|     u2 attribute_name_index;
323 // JVMSpec|     u4 attribute_length;
324 // JVMSpec|     u2 signature_index;
325 // JVMSpec|   }
326 void JvmtiClassFileReconstituter::write_signature_attribute(u2 generic_signature_index) {
327   write_attribute_name_index(&quot;Signature&quot;);
328   write_u4(2);  // always length 2
329   write_u2(generic_signature_index);
330 }
331 
332 // Compute the number of entries in the InnerClasses attribute
333 u2 JvmtiClassFileReconstituter::inner_classes_attribute_length() {
334   InnerClassesIterator iter(ik());
335   return iter.length();
336 }
337 
338 // Write an annotation attribute.  The VM stores them in raw form, so all we need
339 // to do is add the attrubute name and fill in the length.
340 // JSR202|   *Annotations_attribute {
341 // JSR202|     u2 attribute_name_index;
342 // JSR202|     u4 attribute_length;
343 // JSR202|     ...
344 // JSR202|   }
345 void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,
346                                                               AnnotationArray* annos) {
347   u4 length = annos-&gt;length();
348   write_attribute_name_index(attr_name);
349   write_u4(length);
350   memcpy(writeable_address(length), annos-&gt;adr_at(0), length);
351 }
352 
353 //  BootstrapMethods_attribute {
354 //    u2 attribute_name_index;
355 //    u4 attribute_length;
356 //    u2 num_bootstrap_methods;
357 //    {   u2 bootstrap_method_ref;
358 //        u2 num_bootstrap_arguments;
359 //        u2 bootstrap_arguments[num_bootstrap_arguments];
360 //    } bootstrap_methods[num_bootstrap_methods];
361 //  }
362 void JvmtiClassFileReconstituter::write_bootstrapmethod_attribute() {
363   Array&lt;u2&gt;* operands = cpool()-&gt;operands();
364   write_attribute_name_index(&quot;BootstrapMethods&quot;);
365   int num_bootstrap_methods = ConstantPool::operand_array_length(operands);
366 
367   // calculate length of attribute
368   int length = sizeof(u2); // num_bootstrap_methods
369   for (int n = 0; n &lt; num_bootstrap_methods; n++) {
370     u2 num_bootstrap_arguments = cpool()-&gt;operand_argument_count_at(n);
371     length += sizeof(u2); // bootstrap_method_ref
372     length += sizeof(u2); // num_bootstrap_arguments
373     length += sizeof(u2) * num_bootstrap_arguments; // bootstrap_arguments[num_bootstrap_arguments]
374   }
375   write_u4(length);
376 
377   // write attribute
378   write_u2(num_bootstrap_methods);
379   for (int n = 0; n &lt; num_bootstrap_methods; n++) {
380     u2 bootstrap_method_ref = cpool()-&gt;operand_bootstrap_method_ref_index_at(n);
381     u2 num_bootstrap_arguments = cpool()-&gt;operand_argument_count_at(n);
382     write_u2(bootstrap_method_ref);
383     write_u2(num_bootstrap_arguments);
384     for (int arg = 0; arg &lt; num_bootstrap_arguments; arg++) {
385       u2 bootstrap_argument = cpool()-&gt;operand_argument_index_at(n, arg);
386       write_u2(bootstrap_argument);
387     }
388   }
389 }
390 
391 //  NestHost_attribute {
392 //    u2 attribute_name_index;
393 //    u4 attribute_length;
394 //    u2 host_class_index;
395 //  }
396 void JvmtiClassFileReconstituter::write_nest_host_attribute() {
397   int length = sizeof(u2);
398   int host_class_index = ik()-&gt;nest_host_index();
399 
400   write_attribute_name_index(&quot;NestHost&quot;);
401   write_u4(length);
402   write_u2(host_class_index);
403 }
404 
405 //  NestMembers_attribute {
406 //    u2 attribute_name_index;
407 //    u4 attribute_length;
408 //    u2 number_of_classes;
409 //    u2 classes[number_of_classes];
410 //  }
411 void JvmtiClassFileReconstituter::write_nest_members_attribute() {
412   Array&lt;u2&gt;* nest_members = ik()-&gt;nest_members();
413   int number_of_classes = nest_members-&gt;length();
414   int length = sizeof(u2) * (1 + number_of_classes);
415 
416   write_attribute_name_index(&quot;NestMembers&quot;);
417   write_u4(length);
418   write_u2(number_of_classes);
419   for (int i = 0; i &lt; number_of_classes; i++) {
420     u2 class_cp_index = nest_members-&gt;at(i);
421     write_u2(class_cp_index);
422   }
423 }
424 
<a name="3" id="anc3"></a>


















































425 
426 // Write InnerClasses attribute
427 // JVMSpec|   InnerClasses_attribute {
428 // JVMSpec|     u2 attribute_name_index;
429 // JVMSpec|     u4 attribute_length;
430 // JVMSpec|     u2 number_of_classes;
431 // JVMSpec|     {  u2 inner_class_info_index;
432 // JVMSpec|        u2 outer_class_info_index;
433 // JVMSpec|        u2 inner_name_index;
434 // JVMSpec|        u2 inner_class_access_flags;
435 // JVMSpec|     } classes[number_of_classes];
436 // JVMSpec|   }
437 void JvmtiClassFileReconstituter::write_inner_classes_attribute(int length) {
438   InnerClassesIterator iter(ik());
439   guarantee(iter.length() != 0 &amp;&amp; iter.length() == length,
440             &quot;caller must check&quot;);
441   u2 entry_count = length / InstanceKlass::inner_class_next_offset;
442   u4 size = 2 + entry_count * (2+2+2+2);
443 
444   write_attribute_name_index(&quot;InnerClasses&quot;);
445   write_u4(size);
446   write_u2(entry_count);
447   for (; !iter.done(); iter.next()) {
448     write_u2(iter.inner_class_info_index());
449     write_u2(iter.outer_class_info_index());
450     write_u2(iter.inner_name_index());
451     write_u2(iter.inner_access_flags());
452   }
453 }
454 
455 // Write Synthetic attribute
456 // JVMSpec|   Synthetic_attribute {
457 // JVMSpec|     u2 attribute_name_index;
458 // JVMSpec|     u4 attribute_length;
459 // JVMSpec|   }
460 void JvmtiClassFileReconstituter::write_synthetic_attribute() {
461   write_attribute_name_index(&quot;Synthetic&quot;);
462   write_u4(0); //length always zero
463 }
464 
465 // Compute size of LineNumberTable
466 u2 JvmtiClassFileReconstituter::line_number_table_entries(const methodHandle&amp; method) {
467   // The line number table is compressed so we don&#39;t know how big it is until decompressed.
468   // Decompression is really fast so we just do it twice.
469   u2 num_entries = 0;
470   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
471   while (stream.read_pair()) {
472     num_entries++;
473   }
474   return num_entries;
475 }
476 
477 // Write LineNumberTable attribute
478 // JVMSpec|   LineNumberTable_attribute {
479 // JVMSpec|     u2 attribute_name_index;
480 // JVMSpec|     u4 attribute_length;
481 // JVMSpec|     u2 line_number_table_length;
482 // JVMSpec|     {  u2 start_pc;
483 // JVMSpec|        u2 line_number;
484 // JVMSpec|     } line_number_table[line_number_table_length];
485 // JVMSpec|   }
486 void JvmtiClassFileReconstituter::write_line_number_table_attribute(const methodHandle&amp; method,
487                                                                     u2 num_entries) {
488 
489   write_attribute_name_index(&quot;LineNumberTable&quot;);
490   write_u4(2 + num_entries * (2 + 2));
491   write_u2(num_entries);
492 
493   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
494   while (stream.read_pair()) {
495     write_u2(stream.bci());
496     write_u2(stream.line());
497   }
498 }
499 
500 // Write LocalVariableTable attribute
501 // JVMSpec|   LocalVariableTable_attribute {
502 // JVMSpec|     u2 attribute_name_index;
503 // JVMSpec|     u4 attribute_length;
504 // JVMSpec|     u2 local_variable_table_length;
505 // JVMSpec|     {  u2 start_pc;
506 // JVMSpec|       u2 length;
507 // JVMSpec|       u2 name_index;
508 // JVMSpec|       u2 descriptor_index;
509 // JVMSpec|       u2 index;
510 // JVMSpec|     } local_variable_table[local_variable_table_length];
511 // JVMSpec|   }
512 void JvmtiClassFileReconstituter::write_local_variable_table_attribute(const methodHandle&amp; method, u2 num_entries) {
513     write_attribute_name_index(&quot;LocalVariableTable&quot;);
514     write_u4(2 + num_entries * (2 + 2 + 2 + 2 + 2));
515     write_u2(num_entries);
516 
517     assert(method-&gt;localvariable_table_length() == num_entries, &quot;just checking&quot;);
518 
519     LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
520     for (int j=0; j&lt;method-&gt;localvariable_table_length(); j++) {
521       write_u2(elem-&gt;start_bci);
522       write_u2(elem-&gt;length);
523       write_u2(elem-&gt;name_cp_index);
524       write_u2(elem-&gt;descriptor_cp_index);
525       write_u2(elem-&gt;slot);
526       elem++;
527     }
528 }
529 
530 // Write LocalVariableTypeTable attribute
531 // JVMSpec|   LocalVariableTypeTable_attribute {
532 // JVMSpec|     u2 attribute_name_index;
533 // JVMSpec|     u4 attribute_length;
534 // JVMSpec|     u2 local_variable_type_table_length;
535 // JVMSpec|     { u2 start_pc;
536 // JVMSpec|       u2 length;
537 // JVMSpec|       u2 name_index;
538 // JVMSpec|       u2 signature_index;
539 // JVMSpec|       u2 index;
540 // JVMSpec|     } local_variable_type_table[local_variable_type_table_length];
541 // JVMSpec|   }
542 void JvmtiClassFileReconstituter::write_local_variable_type_table_attribute(const methodHandle&amp; method, u2 num_entries) {
543     write_attribute_name_index(&quot;LocalVariableTypeTable&quot;);
544     write_u4(2 + num_entries * (2 + 2 + 2 + 2 + 2));
545     write_u2(num_entries);
546 
547     LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
548     for (int j=0; j&lt;method-&gt;localvariable_table_length(); j++) {
549       if (elem-&gt;signature_cp_index &gt; 0) {
550         // Local variable has a generic signature - write LVTT attribute entry
551         write_u2(elem-&gt;start_bci);
552         write_u2(elem-&gt;length);
553         write_u2(elem-&gt;name_cp_index);
554         write_u2(elem-&gt;signature_cp_index);
555         write_u2(elem-&gt;slot);
556         num_entries--;
557       }
558       elem++;
559     }
560     assert(num_entries == 0, &quot;just checking&quot;);
561 }
562 
563 // Write stack map table attribute
564 // JSR-202|   StackMapTable_attribute {
565 // JSR-202|     u2 attribute_name_index;
566 // JSR-202|     u4 attribute_length;
567 // JSR-202|     u2 number_of_entries;
568 // JSR-202|     stack_map_frame_entries[number_of_entries];
569 // JSR-202|   }
570 void JvmtiClassFileReconstituter::write_stackmap_table_attribute(const methodHandle&amp; method,
571                                                                  int stackmap_len) {
572 
573   write_attribute_name_index(&quot;StackMapTable&quot;);
574   write_u4(stackmap_len);
575   memcpy(
576     writeable_address(stackmap_len),
577     (void*)(method-&gt;stackmap_data()-&gt;adr_at(0)),
578     stackmap_len);
579 }
580 
581 // Write one method_info structure
582 // JVMSpec|   method_info {
583 // JVMSpec|     u2 access_flags;
584 // JVMSpec|     u2 name_index;
585 // JVMSpec|     u2 descriptor_index;
586 // JVMSpec|     u2 attributes_count;
587 // JVMSpec|     attribute_info attributes[attributes_count];
588 // JVMSpec|   }
589 void JvmtiClassFileReconstituter::write_method_info(const methodHandle&amp; method) {
590   AccessFlags access_flags = method-&gt;access_flags();
591   ConstMethod* const_method = method-&gt;constMethod();
592   u2 generic_signature_index = const_method-&gt;generic_signature_index();
593   AnnotationArray* anno = method-&gt;annotations();
594   AnnotationArray* param_anno = method-&gt;parameter_annotations();
595   AnnotationArray* default_anno = method-&gt;annotation_default();
596   AnnotationArray* type_anno = method-&gt;type_annotations();
597 
598   // skip generated default interface methods
599   if (method-&gt;is_overpass()) {
600     return;
601   }
602 
603   write_u2(access_flags.get_flags() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
604   write_u2(const_method-&gt;name_index());
605   write_u2(const_method-&gt;signature_index());
606 
607   // write attributes in the same order javac does, so we can test with byte for
608   // byte comparison
609   int attr_count = 0;
610   if (const_method-&gt;code_size() != 0) {
611     ++attr_count;     // has Code attribute
612   }
613   if (const_method-&gt;has_checked_exceptions()) {
614     ++attr_count;     // has Exceptions attribute
615   }
616   if (default_anno != NULL) {
617     ++attr_count;     // has AnnotationDefault attribute
618   }
619   // Deprecated attribute would go here
620   if (access_flags.is_synthetic()) { // FIXME
621     // ++attr_count;
622   }
623   if (generic_signature_index != 0) {
624     ++attr_count;
625   }
626   if (anno != NULL) {
627     ++attr_count;     // has RuntimeVisibleAnnotations attribute
628   }
629   if (param_anno != NULL) {
630     ++attr_count;     // has RuntimeVisibleParameterAnnotations attribute
631   }
632   if (type_anno != NULL) {
633     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
634   }
635 
636   write_u2(attr_count);
637   if (const_method-&gt;code_size() &gt; 0) {
638     write_code_attribute(method);
639   }
640   if (const_method-&gt;has_checked_exceptions()) {
641     write_exceptions_attribute(const_method);
642   }
643   if (default_anno != NULL) {
644     write_annotations_attribute(&quot;AnnotationDefault&quot;, default_anno);
645   }
646   // Deprecated attribute would go here
647   if (access_flags.is_synthetic()) {
648     // write_synthetic_attribute();
649   }
650   if (generic_signature_index != 0) {
651     write_signature_attribute(generic_signature_index);
652   }
653   if (anno != NULL) {
654     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
655   }
656   if (param_anno != NULL) {
657     write_annotations_attribute(&quot;RuntimeVisibleParameterAnnotations&quot;, param_anno);
658   }
659   if (type_anno != NULL) {
660     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
661   }
662 }
663 
664 // Write the class attributes portion of ClassFile structure
665 // JVMSpec|     u2 attributes_count;
666 // JVMSpec|     attribute_info attributes[attributes_count];
667 void JvmtiClassFileReconstituter::write_class_attributes() {
668   u2 inner_classes_length = inner_classes_attribute_length();
669   Symbol* generic_signature = ik()-&gt;generic_signature();
670   AnnotationArray* anno = ik()-&gt;class_annotations();
671   AnnotationArray* type_anno = ik()-&gt;class_type_annotations();
672 
673   int attr_count = 0;
674   if (generic_signature != NULL) {
675     ++attr_count;
676   }
677   if (ik()-&gt;source_file_name() != NULL) {
678     ++attr_count;
679   }
680   if (ik()-&gt;source_debug_extension() != NULL) {
681     ++attr_count;
682   }
683   if (inner_classes_length &gt; 0) {
684     ++attr_count;
685   }
686   if (anno != NULL) {
687     ++attr_count;     // has RuntimeVisibleAnnotations attribute
688   }
689   if (type_anno != NULL) {
690     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
691   }
692   if (cpool()-&gt;operands() != NULL) {
693     ++attr_count;
694   }
695   if (ik()-&gt;nest_host_index() != 0) {
696     ++attr_count;
697   }
698   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
699     ++attr_count;
700   }
<a name="4" id="anc4"></a>


701 
702   write_u2(attr_count);
703 
704   if (generic_signature != NULL) {
705     write_signature_attribute(symbol_to_cpool_index(generic_signature));
706   }
707   if (ik()-&gt;source_file_name() != NULL) {
708     write_source_file_attribute();
709   }
710   if (ik()-&gt;source_debug_extension() != NULL) {
711     write_source_debug_extension_attribute();
712   }
713   if (inner_classes_length &gt; 0) {
714     write_inner_classes_attribute(inner_classes_length);
715   }
716   if (anno != NULL) {
717     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
718   }
719   if (type_anno != NULL) {
720     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
721   }
722   if (cpool()-&gt;operands() != NULL) {
723     write_bootstrapmethod_attribute();
724   }
725   if (ik()-&gt;nest_host_index() != 0) {
726     write_nest_host_attribute();
727   }
728   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
729     write_nest_members_attribute();
730   }
<a name="5" id="anc5"></a>


731 }
732 
733 // Write the method information portion of ClassFile structure
734 // JVMSpec|     u2 methods_count;
735 // JVMSpec|     method_info methods[methods_count];
736 void JvmtiClassFileReconstituter::write_method_infos() {
737   HandleMark hm(thread());
738   Array&lt;Method*&gt;* methods = ik()-&gt;methods();
739   int num_methods = methods-&gt;length();
740   int num_overpass = 0;
741 
742   // count the generated default interface methods
743   // these will not be re-created by write_method_info
744   // and should not be included in the total count
745   for (int index = 0; index &lt; num_methods; index++) {
746     Method* method = methods-&gt;at(index);
747     if (method-&gt;is_overpass()) {
748       num_overpass++;
749     }
750   }
751 
752   write_u2(num_methods - num_overpass);
753   if (JvmtiExport::can_maintain_original_method_order()) {
754     int index;
755     int original_index;
756     intArray method_order(num_methods, num_methods, 0);
757 
758     // invert the method order mapping
759     for (index = 0; index &lt; num_methods; index++) {
760       original_index = ik()-&gt;method_ordering()-&gt;at(index);
761       assert(original_index &gt;= 0 &amp;&amp; original_index &lt; num_methods,
762              &quot;invalid original method index&quot;);
763       method_order.at_put(original_index, index);
764     }
765 
766     // write in original order
767     for (original_index = 0; original_index &lt; num_methods; original_index++) {
768       index = method_order.at(original_index);
769       methodHandle method(thread(), methods-&gt;at(index));
770       write_method_info(method);
771     }
772   } else {
773     // method order not preserved just dump the method infos
774     for (int index = 0; index &lt; num_methods; index++) {
775       methodHandle method(thread(), methods-&gt;at(index));
776       write_method_info(method);
777     }
778   }
779 }
780 
781 void JvmtiClassFileReconstituter::write_class_file_format() {
782   ReallocMark();
783 
784   // JVMSpec|   ClassFile {
785   // JVMSpec|           u4 magic;
786   write_u4(0xCAFEBABE);
787 
788   // JVMSpec|           u2 minor_version;
789   // JVMSpec|           u2 major_version;
790   write_u2(ik()-&gt;minor_version());
791   u2 major = ik()-&gt;major_version();
792   write_u2(major);
793 
794   // JVMSpec|           u2 constant_pool_count;
795   // JVMSpec|           cp_info constant_pool[constant_pool_count-1];
796   write_u2(cpool()-&gt;length());
797   copy_cpool_bytes(writeable_address(cpool_size()));
798 
799   // JVMSpec|           u2 access_flags;
800   write_u2(ik()-&gt;access_flags().get_flags() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS);
801 
802   // JVMSpec|           u2 this_class;
803   // JVMSpec|           u2 super_class;
804   write_u2(class_symbol_to_cpool_index(ik()-&gt;name()));
805   Klass* super_class = ik()-&gt;super();
806   write_u2(super_class == NULL? 0 :  // zero for java.lang.Object
807                 class_symbol_to_cpool_index(super_class-&gt;name()));
808 
809   // JVMSpec|           u2 interfaces_count;
810   // JVMSpec|           u2 interfaces[interfaces_count];
811   Array&lt;InstanceKlass*&gt;* interfaces =  ik()-&gt;local_interfaces();
812   int num_interfaces = interfaces-&gt;length();
813   write_u2(num_interfaces);
814   for (int index = 0; index &lt; num_interfaces; index++) {
815     HandleMark hm(thread());
816     InstanceKlass* iik = interfaces-&gt;at(index);
817     write_u2(class_symbol_to_cpool_index(iik-&gt;name()));
818   }
819 
820   // JVMSpec|           u2 fields_count;
821   // JVMSpec|           field_info fields[fields_count];
822   write_field_infos();
823 
824   // JVMSpec|           u2 methods_count;
825   // JVMSpec|           method_info methods[methods_count];
826   write_method_infos();
827 
828   // JVMSpec|           u2 attributes_count;
829   // JVMSpec|           attribute_info attributes[attributes_count];
830   // JVMSpec|   } /* end ClassFile 8?
831   write_class_attributes();
832 }
833 
834 address JvmtiClassFileReconstituter::writeable_address(size_t size) {
835   size_t used_size = _buffer_ptr - _buffer;
836   if (size + used_size &gt;= _buffer_size) {
837     // compute the new buffer size: must be at least twice as big as before
838     // plus whatever new is being used; then convert to nice clean block boundary
839     size_t new_buffer_size = (size + _buffer_size*2 + 1) / initial_buffer_size
840                                                          * initial_buffer_size;
841 
842     // VM goes belly-up if the memory isn&#39;t available, so cannot do OOM processing
843     _buffer = REALLOC_RESOURCE_ARRAY(u1, _buffer, _buffer_size, new_buffer_size);
844     _buffer_size = new_buffer_size;
845     _buffer_ptr = _buffer + used_size;
846   }
847   u1* ret_ptr = _buffer_ptr;
848   _buffer_ptr += size;
849   return ret_ptr;
850 }
851 
852 void JvmtiClassFileReconstituter::write_attribute_name_index(const char* name) {
853   TempNewSymbol sym = SymbolTable::probe(name, (int)strlen(name));
854   assert(sym != NULL, &quot;attribute name symbol not found&quot;);
855   u2 attr_name_index = symbol_to_cpool_index(sym);
856   assert(attr_name_index != 0, &quot;attribute name symbol not in constant pool&quot;);
857   write_u2(attr_name_index);
858 }
859 
860 void JvmtiClassFileReconstituter::write_u1(u1 x) {
861   *writeable_address(1) = x;
862 }
863 
864 void JvmtiClassFileReconstituter::write_u2(u2 x) {
865   Bytes::put_Java_u2(writeable_address(2), x);
866 }
867 
868 void JvmtiClassFileReconstituter::write_u4(u4 x) {
869   Bytes::put_Java_u4(writeable_address(4), x);
870 }
871 
872 void JvmtiClassFileReconstituter::write_u8(u8 x) {
873   Bytes::put_Java_u8(writeable_address(8), x);
874 }
875 
876 void JvmtiClassFileReconstituter::copy_bytecodes(const methodHandle&amp; mh,
877                                                  unsigned char* bytecodes) {
878   // use a BytecodeStream to iterate over the bytecodes. JVM/fast bytecodes
879   // and the breakpoint bytecode are converted to their original bytecodes.
880 
881   BytecodeStream bs(mh);
882 
883   unsigned char* p = bytecodes;
884   Bytecodes::Code code;
885   bool is_rewritten = mh-&gt;method_holder()-&gt;is_rewritten();
886 
887   while ((code = bs.next()) &gt;= 0) {
888     assert(Bytecodes::is_java_code(code), &quot;sanity check&quot;);
889     assert(code != Bytecodes::_breakpoint, &quot;sanity check&quot;);
890 
891     // length of bytecode (mnemonic + operands)
892     address bcp = bs.bcp();
893     int     len = bs.instruction_size();
894     assert(len &gt; 0, &quot;length must be &gt; 0&quot;);
895 
896     // copy the bytecodes
897     *p = (unsigned char) (bs.is_wide()? Bytecodes::_wide : code);
898     if (len &gt; 1) {
899       memcpy(p+1, bcp+1, len-1);
900     }
901 
902     // During linking the get/put and invoke instructions are rewritten
903     // with an index into the constant pool cache. The original constant
904     // pool index must be returned to caller.  Rewrite the index.
905     if (is_rewritten &amp;&amp; len &gt; 1) {
906       bool is_wide = false;
907       switch (code) {
908       case Bytecodes::_getstatic       :  // fall through
909       case Bytecodes::_putstatic       :  // fall through
910       case Bytecodes::_getfield        :  // fall through
911       case Bytecodes::_putfield        :  // fall through
912       case Bytecodes::_invokevirtual   :  // fall through
913       case Bytecodes::_invokespecial   :  // fall through
914       case Bytecodes::_invokestatic    :  // fall through
915       case Bytecodes::_invokedynamic   :  // fall through
916       case Bytecodes::_invokeinterface : {
917         assert(len == 3 ||
918                (code == Bytecodes::_invokeinterface &amp;&amp; len == 5) ||
919                (code == Bytecodes::_invokedynamic   &amp;&amp; len == 5),
920                &quot;sanity check&quot;);
921 
922         int cpci = Bytes::get_native_u2(bcp+1);
923         bool is_invokedynamic = (code == Bytecodes::_invokedynamic);
924         ConstantPoolCacheEntry* entry;
925         if (is_invokedynamic) {
926           cpci = Bytes::get_native_u4(bcp+1);
927           entry = mh-&gt;constants()-&gt;invokedynamic_cp_cache_entry_at(cpci);
928         } else {
929         // cache cannot be pre-fetched since some classes won&#39;t have it yet
930           entry = mh-&gt;constants()-&gt;cache()-&gt;entry_at(cpci);
931         }
932         int i = entry-&gt;constant_pool_index();
933         assert(i &lt; mh-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
934         Bytes::put_Java_u2((address)(p+1), (u2)i);     // java byte ordering
935         if (is_invokedynamic)  *(p+3) = *(p+4) = 0;
936         break;
937       }
938       case Bytecodes::_ldc_w:
939         is_wide = true; // fall through
940       case Bytecodes::_ldc: {
941         if (bs.raw_code() == Bytecodes::_fast_aldc || bs.raw_code() == Bytecodes::_fast_aldc_w) {
942           int cpci = is_wide ? Bytes::get_native_u2(bcp+1) : (u1)(*(bcp+1));
943           int i = mh-&gt;constants()-&gt;object_to_cp_index(cpci);
944           assert(i &lt; mh-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
945           if (is_wide) {
946             Bytes::put_Java_u2((address)(p+1), (u2)i);     // java byte ordering
947           } else {
948             *(p+1) = (u1)i;
949           }
950         }
951         break;
952         }
953       default:
954         break;
955       }
956     }
957 
958     p += len;
959   }
960 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiExport.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiExport.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExtensions.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiExport.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 89,10 ***</span>
<span class="line-new-header">--- 89,11 ---</span>
    JVMTI_SUPPORT_FLAG(can_post_method_exit)
    JVMTI_SUPPORT_FLAG(can_pop_frame)
    JVMTI_SUPPORT_FLAG(can_force_early_return)
  
    JVMTI_SUPPORT_FLAG(early_vmstart_recorded)
<span class="line-added">+   JVMTI_SUPPORT_FLAG(can_get_owned_monitor_info) // includes can_get_owned_monitor_stack_depth_info</span>
  
    friend class JvmtiEventControllerPrivate;  // should only modify these flags
    JVMTI_SUPPORT_FLAG(should_post_single_step)
    JVMTI_SUPPORT_FLAG(should_post_field_access)
    JVMTI_SUPPORT_FLAG(should_post_field_modification)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,30 ***</span>
    // posts a DynamicCodeGenerated event (internal/private implementation).
    // The public post_dynamic_code_generated* functions make use of the
    // internal implementation.  Also called from JvmtiDeferredEvent::post()
    static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
  
   private:
  
    // GenerateEvents support to allow posting of CompiledMethodLoad and
    // DynamicCodeGenerated events for a given environment.
    friend class JvmtiCodeBlobEvents;
  
<span class="line-removed">-   static void post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-removed">-                                         const void *code_begin, const jint map_length,</span>
<span class="line-removed">-                                         const jvmtiAddrLocationMap* map) NOT_JVMTI_RETURN;</span>
    static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
                                            const void *code_end) NOT_JVMTI_RETURN;
  
    // This flag indicates whether RedefineClasses() has ever redefined
    // one or more classes during the lifetime of the VM. The flag should
    // only be set by the friend class and can be queried by other sub
    // systems as needed to relax invariant checks.
<span class="line-modified">!   static bool _has_redefined_a_class;</span>
    friend class VM_RedefineClasses;
<span class="line-modified">!   inline static void set_has_redefined_a_class() {</span>
<span class="line-modified">!     JVMTI_ONLY(_has_redefined_a_class = true;)</span>
    }
    // Flag to indicate if the compiler has recorded all dependencies. When the
    // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
    // records all dependencies from startup. However if the capability is first
    // enabled some time later then the dependencies recorded by the compiler
<span class="line-new-header">--- 158,28 ---</span>
    // posts a DynamicCodeGenerated event (internal/private implementation).
    // The public post_dynamic_code_generated* functions make use of the
    // internal implementation.  Also called from JvmtiDeferredEvent::post()
    static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
  
<span class="line-added">+   static void post_class_unload_internal(const char *name) NOT_JVMTI_RETURN;</span>
   private:
  
    // GenerateEvents support to allow posting of CompiledMethodLoad and
    // DynamicCodeGenerated events for a given environment.
    friend class JvmtiCodeBlobEvents;
  
    static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
                                            const void *code_end) NOT_JVMTI_RETURN;
  
    // This flag indicates whether RedefineClasses() has ever redefined
    // one or more classes during the lifetime of the VM. The flag should
    // only be set by the friend class and can be queried by other sub
    // systems as needed to relax invariant checks.
<span class="line-modified">!   static uint64_t _redefinition_count;</span>
    friend class VM_RedefineClasses;
<span class="line-modified">!   inline static void increment_redefinition_count() {</span>
<span class="line-modified">!     JVMTI_ONLY(_redefinition_count++;)</span>
    }
    // Flag to indicate if the compiler has recorded all dependencies. When the
    // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
    // records all dependencies from startup. However if the capability is first
    // enabled some time later then the dependencies recorded by the compiler
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,14 ***</span>
    // dependency information is complete or not.
    static bool _all_dependencies_are_recorded;
  
   public:
    inline static bool has_redefined_a_class() {
<span class="line-modified">!     JVMTI_ONLY(return _has_redefined_a_class);</span>
      NOT_JVMTI(return false);
    }
  
    inline static bool all_dependencies_are_recorded() {
      return _all_dependencies_are_recorded;
    }
  
    inline static void set_all_dependencies_are_recorded(bool on) {
<span class="line-new-header">--- 187,20 ---</span>
    // dependency information is complete or not.
    static bool _all_dependencies_are_recorded;
  
   public:
    inline static bool has_redefined_a_class() {
<span class="line-modified">!     JVMTI_ONLY(return _redefinition_count != 0);</span>
      NOT_JVMTI(return false);
    }
  
<span class="line-added">+   // Only set in safepoint, so no memory ordering needed.</span>
<span class="line-added">+   inline static uint64_t redefinition_count() {</span>
<span class="line-added">+     JVMTI_ONLY(return _redefinition_count);</span>
<span class="line-added">+     NOT_JVMTI(return 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    inline static bool all_dependencies_are_recorded() {
      return _all_dependencies_are_recorded;
    }
  
    inline static void set_all_dependencies_are_recorded(bool on) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,10 ***</span>
<span class="line-new-header">--- 339,11 ---</span>
    static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
                                          Handle h_protection_domain,
                                          unsigned char **data_ptr, unsigned char **end_ptr,
                                          JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
    static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;
<span class="line-added">+   static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;</span>
    static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
    static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
  
    // used to post a CompiledMethodUnload event
    static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
    static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
    static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
  
    static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
    static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;
<span class="line-removed">-   static void gc_epilogue() NOT_JVMTI_RETURN;</span>
  
    static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
  
  #if INCLUDE_SERVICES
    // attach support
<span class="line-new-header">--- 394,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,11 ***</span>
    address _code_end;
  
   public:
    JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
      assert(name != NULL, &quot;all code blobs must be named&quot;);
<span class="line-modified">!     strncpy(_name, name, sizeof(_name));</span>
      _name[sizeof(_name)-1] = &#39;\0&#39;;
      _code_begin = code_begin;
      _code_end = code_end;
    }
    char* name()                  { return _name; }
<span class="line-new-header">--- 425,11 ---</span>
    address _code_end;
  
   public:
    JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
      assert(name != NULL, &quot;all code blobs must be named&quot;);
<span class="line-modified">!     strncpy(_name, name, sizeof(_name) - 1);</span>
      _name[sizeof(_name)-1] = &#39;\0&#39;;
      _code_begin = code_begin;
      _code_end = code_end;
    }
    char* name()                  { return _name; }
</pre>
<center><a href="jvmtiExport.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExtensions.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
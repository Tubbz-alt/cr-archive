<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiManageCapabilities.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;prims/jvmtiExport.hpp&quot;
 29 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
 30 
 31 static const jint CAPA_SIZE = (JVMTI_INTERNAL_CAPABILITY_COUNT + 7) / 8;
 32 
 33   // capabilities which are always potentially available
 34 jvmtiCapabilities JvmtiManageCapabilities::always_capabilities;
 35 
 36   // capabilities which are potentially available during OnLoad
 37 jvmtiCapabilities JvmtiManageCapabilities::onload_capabilities;
 38 
 39   // capabilities which are always potentially available
 40   // but to only one environment
 41 jvmtiCapabilities JvmtiManageCapabilities::always_solo_capabilities;
 42 
 43   // capabilities which are potentially available during OnLoad
 44   // but to only one environment
 45 jvmtiCapabilities JvmtiManageCapabilities::onload_solo_capabilities;
 46 
 47   // remaining capabilities which are always potentially available
 48   // but to only one environment
 49 jvmtiCapabilities JvmtiManageCapabilities::always_solo_remaining_capabilities;
 50 
 51   // remaining capabilities which are potentially available during OnLoad
 52   // but to only one environment
 53 jvmtiCapabilities JvmtiManageCapabilities::onload_solo_remaining_capabilities;
 54 
 55   // all capabilities ever acquired
 56 jvmtiCapabilities JvmtiManageCapabilities::acquired_capabilities;
 57 
 58 void JvmtiManageCapabilities::initialize() {
 59   always_capabilities = init_always_capabilities();
 60   onload_capabilities = init_onload_capabilities();
 61   always_solo_capabilities = init_always_solo_capabilities();
 62   onload_solo_capabilities = init_onload_solo_capabilities();
 63   always_solo_remaining_capabilities = init_always_solo_capabilities();
 64   onload_solo_remaining_capabilities = init_onload_solo_capabilities();
 65   memset(&amp;acquired_capabilities, 0, sizeof(acquired_capabilities));
 66 }
 67 
 68 
 69 // corresponding init functions
 70 jvmtiCapabilities JvmtiManageCapabilities::init_always_capabilities() {
 71   jvmtiCapabilities jc;
 72 
 73   memset(&amp;jc, 0, sizeof(jc));
 74   jc.can_get_bytecodes = 1;
 75   jc.can_signal_thread = 1;
 76   jc.can_get_source_file_name = 1;
 77   jc.can_get_line_numbers = 1;
 78   jc.can_get_synthetic_attribute = 1;
 79   jc.can_get_monitor_info = 1;
 80   jc.can_get_constant_pool = 1;
 81   jc.can_generate_all_class_hook_events = 1;
 82   jc.can_generate_monitor_events = 1;
 83   jc.can_generate_garbage_collection_events = 1;
 84   jc.can_generate_compiled_method_load_events = 1;
 85   jc.can_generate_native_method_bind_events = 1;
 86   jc.can_generate_vm_object_alloc_events = 1;
 87   if (os::is_thread_cpu_time_supported()) {
 88     jc.can_get_current_thread_cpu_time = 1;
 89     jc.can_get_thread_cpu_time = 1;
 90   }
 91   jc.can_redefine_classes = 1;
 92   jc.can_redefine_any_class = 1;
 93   jc.can_retransform_classes = 1;
 94   jc.can_retransform_any_class = 1;
 95   jc.can_set_native_method_prefix = 1;
 96   jc.can_tag_objects = 1;
 97   jc.can_generate_object_free_events = 1;
 98   jc.can_generate_resource_exhaustion_heap_events = 1;
 99   jc.can_generate_resource_exhaustion_threads_events = 1;
100   return jc;
101 }
102 
103 jvmtiCapabilities JvmtiManageCapabilities::init_onload_capabilities() {
104   jvmtiCapabilities jc;
105 
106   memset(&amp;jc, 0, sizeof(jc));
107 #ifndef ZERO
108   jc.can_pop_frame = 1;
109   jc.can_force_early_return = 1;
110   // Workaround for 8195635:
111   // disable pop_frame and force_early_return capabilities with Graal
112 #if INCLUDE_JVMCI
113   if (UseJVMCICompiler) {
114     jc.can_pop_frame = 0;
115     jc.can_force_early_return = 0;
116   }
117 #endif // INCLUDE_JVMCI
118 #endif // !ZERO
119   jc.can_get_source_debug_extension = 1;
120   jc.can_access_local_variables = 1;
121   jc.can_maintain_original_method_order = 1;
122   jc.can_generate_single_step_events = 1;
123   jc.can_generate_exception_events = 1;
124   jc.can_generate_frame_pop_events = 1;
125   jc.can_generate_method_entry_events = 1;
126   jc.can_generate_method_exit_events = 1;
127   jc.can_get_owned_monitor_info = 1;
128   jc.can_get_owned_monitor_stack_depth_info = 1;
129   jc.can_get_current_contended_monitor = 1;
130   jc.can_generate_early_vmstart = 1;
131   jc.can_generate_early_class_hook_events = 1;
132   return jc;
133 }
134 
135 
136 jvmtiCapabilities JvmtiManageCapabilities::init_always_solo_capabilities() {
137   jvmtiCapabilities jc;
138 
139   memset(&amp;jc, 0, sizeof(jc));
140   jc.can_suspend = 1;
141   jc.can_generate_sampled_object_alloc_events = 1;
142   return jc;
143 }
144 
145 
146 jvmtiCapabilities JvmtiManageCapabilities::init_onload_solo_capabilities() {
147   jvmtiCapabilities jc;
148 
149   memset(&amp;jc, 0, sizeof(jc));
150   jc.can_generate_field_modification_events = 1;
151   jc.can_generate_field_access_events = 1;
152   jc.can_generate_breakpoint_events = 1;
153   return jc;
154 }
155 
156 
157 jvmtiCapabilities *JvmtiManageCapabilities::either(const jvmtiCapabilities *a, const jvmtiCapabilities *b,
158                                                    jvmtiCapabilities *result) {
159   char *ap = (char *)a;
160   char *bp = (char *)b;
161   char *resultp = (char *)result;
162 
163   for (int i = 0; i &lt; CAPA_SIZE; ++i) {
164     *resultp++ = *ap++ | *bp++;
165   }
166 
167   return result;
168 }
169 
170 
171 jvmtiCapabilities *JvmtiManageCapabilities::both(const jvmtiCapabilities *a, const jvmtiCapabilities *b,
172                                                     jvmtiCapabilities *result) {
173   char *ap = (char *)a;
174   char *bp = (char *)b;
175   char *resultp = (char *)result;
176 
177   for (int i = 0; i &lt; CAPA_SIZE; ++i) {
178     *resultp++ = *ap++ &amp; *bp++;
179   }
180 
181   return result;
182 }
183 
184 
185 jvmtiCapabilities *JvmtiManageCapabilities::exclude(const jvmtiCapabilities *a, const jvmtiCapabilities *b,
186                                                     jvmtiCapabilities *result) {
187   char *ap = (char *)a;
188   char *bp = (char *)b;
189   char *resultp = (char *)result;
190 
191   for (int i = 0; i &lt; CAPA_SIZE; ++i) {
192     *resultp++ = *ap++ &amp; ~*bp++;
193   }
194 
195   return result;
196 }
197 
198 
199 bool JvmtiManageCapabilities::has_some(const jvmtiCapabilities *a) {
200   char *ap = (char *)a;
201 
202   for (int i = 0; i &lt; CAPA_SIZE; ++i) {
203     if (*ap++ != 0) {
204       return true;
205     }
206   }
207 
208   return false;
209 }
210 
211 
212 void JvmtiManageCapabilities::copy_capabilities(const jvmtiCapabilities *from, jvmtiCapabilities *to) {
213   char *ap = (char *)from;
214   char *resultp = (char *)to;
215 
216   for (int i = 0; i &lt; CAPA_SIZE; ++i) {
217     *resultp++ = *ap++;
218   }
219 }
220 
221 
222 void JvmtiManageCapabilities::get_potential_capabilities(const jvmtiCapabilities *current,
223                                                          const jvmtiCapabilities *prohibited,
224                                                          jvmtiCapabilities *result) {
225   // exclude prohibited capabilities, must be before adding current
226   exclude(&amp;always_capabilities, prohibited, result);
227 
228   // must include current since it may possess solo capabilities and now prohibited
229   either(result, current, result);
230 
231   // add other remaining
232   either(result, &amp;always_solo_remaining_capabilities, result);
233 
234   // if this is during OnLoad more capabilities are available
235   if (JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
236     either(result, &amp;onload_capabilities, result);
237     either(result, &amp;onload_solo_remaining_capabilities, result);
238   }
239 }
240 
241 jvmtiError JvmtiManageCapabilities::add_capabilities(const jvmtiCapabilities *current,
242                                                      const jvmtiCapabilities *prohibited,
243                                                      const jvmtiCapabilities *desired,
244                                                      jvmtiCapabilities *result) {
245   // check that the capabilities being added are potential capabilities
246   jvmtiCapabilities temp;
247   get_potential_capabilities(current, prohibited, &amp;temp);
248   if (has_some(exclude(desired, &amp;temp, &amp;temp))) {
249     return JVMTI_ERROR_NOT_AVAILABLE;
250   }
251 
252   // add to the set of ever acquired capabilities
253   either(&amp;acquired_capabilities, desired, &amp;acquired_capabilities);
254 
255   // onload capabilities that got added are now permanent - so, also remove from onload
256   both(&amp;onload_capabilities, desired, &amp;temp);
257   either(&amp;always_capabilities, &amp;temp, &amp;always_capabilities);
258   exclude(&amp;onload_capabilities, &amp;temp, &amp;onload_capabilities);
259 
260   // same for solo capabilities (transferred capabilities in the remaining sets handled as part of standard grab - below)
261   both(&amp;onload_solo_capabilities, desired, &amp;temp);
262   either(&amp;always_solo_capabilities, &amp;temp, &amp;always_solo_capabilities);
263   exclude(&amp;onload_solo_capabilities, &amp;temp, &amp;onload_solo_capabilities);
264 
265   // remove solo capabilities that are now taken
266   exclude(&amp;always_solo_remaining_capabilities, desired, &amp;always_solo_remaining_capabilities);
267   exclude(&amp;onload_solo_remaining_capabilities, desired, &amp;onload_solo_remaining_capabilities);
268 
269   // return the result
270   either(current, desired, result);
271 
272   update();
273 
274   return JVMTI_ERROR_NONE;
275 }
276 
277 
278 void JvmtiManageCapabilities::relinquish_capabilities(const jvmtiCapabilities *current,
279                                                       const jvmtiCapabilities *unwanted,
280                                                       jvmtiCapabilities *result) {
281   jvmtiCapabilities to_trash;
282   jvmtiCapabilities temp;
283 
284   // can&#39;t give up what you don&#39;t have
285   both(current, unwanted, &amp;to_trash);
286 
287   // restore solo capabilities but only those that belong
288   either(&amp;always_solo_remaining_capabilities, both(&amp;always_solo_capabilities, &amp;to_trash, &amp;temp),
289          &amp;always_solo_remaining_capabilities);
290   either(&amp;onload_solo_remaining_capabilities, both(&amp;onload_solo_capabilities, &amp;to_trash, &amp;temp),
291          &amp;onload_solo_remaining_capabilities);
292 
293   update();
294 
295   // return the result
296   exclude(current, unwanted, result);
297 }
298 
299 
300 void JvmtiManageCapabilities::update() {
301   jvmtiCapabilities avail;
302 
303   // all capabilities
304   either(&amp;always_capabilities, &amp;always_solo_capabilities, &amp;avail);
305 
306   bool interp_events =
307     avail.can_generate_field_access_events ||
308     avail.can_generate_field_modification_events ||
309     avail.can_generate_single_step_events ||
310     avail.can_generate_frame_pop_events ||
311     avail.can_generate_method_entry_events ||
312     avail.can_generate_method_exit_events;
313 #ifdef ZERO
314   bool enter_all_methods =
315     interp_events ||
316     avail.can_generate_breakpoint_events;
317   if (enter_all_methods) {
318     // Disable these when tracking the bytecodes
319     UseFastEmptyMethods = false;
320     UseFastAccessorMethods = false;
321   }
322 #endif // ZERO
323 
324   if (avail.can_generate_breakpoint_events
325        || avail.can_generate_field_access_events
326        || avail.can_generate_field_modification_events)
327   {
328     RewriteFrequentPairs = false;
329   }
330 
331   // If can_redefine_classes is enabled in the onload phase then we know that the
332   // dependency information recorded by the compiler is complete.
333   if ((avail.can_redefine_classes || avail.can_retransform_classes) &amp;&amp;
334       JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
335     JvmtiExport::set_all_dependencies_are_recorded(true);
336   }
337 
338   JvmtiExport::set_can_get_source_debug_extension(avail.can_get_source_debug_extension);
339   JvmtiExport::set_can_maintain_original_method_order(avail.can_maintain_original_method_order);
340   JvmtiExport::set_can_post_interpreter_events(interp_events);
341   JvmtiExport::set_can_hotswap_or_post_breakpoint(
342     avail.can_generate_breakpoint_events ||
343     avail.can_redefine_classes ||
344     avail.can_retransform_classes);
345   JvmtiExport::set_can_modify_any_class(
346     avail.can_generate_breakpoint_events ||
347     avail.can_generate_all_class_hook_events);
348   JvmtiExport::set_can_walk_any_space(
349     avail.can_tag_objects);   // disable sharing in onload phase
350   // This controls whether the compilers keep extra locals live to
351   // improve the debugging experience so only set them if the selected
352   // capabilities look like a debugger.
353   JvmtiExport::set_can_access_local_variables(
354     avail.can_access_local_variables ||
355     avail.can_generate_breakpoint_events ||
356     avail.can_generate_frame_pop_events);
357   JvmtiExport::set_can_post_on_exceptions(
358     avail.can_generate_exception_events ||
359     avail.can_generate_frame_pop_events ||
360     avail.can_generate_method_exit_events);
361   JvmtiExport::set_can_post_breakpoint(avail.can_generate_breakpoint_events);
362   JvmtiExport::set_can_post_field_access(avail.can_generate_field_access_events);
363   JvmtiExport::set_can_post_field_modification(avail.can_generate_field_modification_events);
364   JvmtiExport::set_can_post_method_entry(avail.can_generate_method_entry_events);
365   JvmtiExport::set_can_post_method_exit(avail.can_generate_method_exit_events ||
366                                         avail.can_generate_frame_pop_events);
367   JvmtiExport::set_can_pop_frame(avail.can_pop_frame);
368   JvmtiExport::set_can_force_early_return(avail.can_force_early_return);
369   JvmtiExport::set_should_clean_up_heap_objects(avail.can_generate_breakpoint_events);
<a name="2" id="anc2"></a>

370 }
371 
372 #ifndef PRODUCT
373 
374 void JvmtiManageCapabilities:: print(const jvmtiCapabilities* cap) {
375   log_trace(jvmti)(&quot;----- capabilities -----&quot;);
376   if (cap-&gt;can_tag_objects)
377     log_trace(jvmti)(&quot;can_tag_objects&quot;);
378   if (cap-&gt;can_generate_field_modification_events)
379     log_trace(jvmti)(&quot;can_generate_field_modification_events&quot;);
380   if (cap-&gt;can_generate_field_access_events)
381     log_trace(jvmti)(&quot;can_generate_field_access_events&quot;);
382   if (cap-&gt;can_get_bytecodes)
383     log_trace(jvmti)(&quot;can_get_bytecodes&quot;);
384   if (cap-&gt;can_get_synthetic_attribute)
385     log_trace(jvmti)(&quot;can_get_synthetic_attribute&quot;);
386   if (cap-&gt;can_get_owned_monitor_info)
387     log_trace(jvmti)(&quot;can_get_owned_monitor_info&quot;);
388   if (cap-&gt;can_get_current_contended_monitor)
389     log_trace(jvmti)(&quot;can_get_current_contended_monitor&quot;);
390   if (cap-&gt;can_get_monitor_info)
391     log_trace(jvmti)(&quot;can_get_monitor_info&quot;);
392   if (cap-&gt;can_get_constant_pool)
393     log_trace(jvmti)(&quot;can_get_constant_pool&quot;);
394   if (cap-&gt;can_pop_frame)
395     log_trace(jvmti)(&quot;can_pop_frame&quot;);
396   if (cap-&gt;can_force_early_return)
397     log_trace(jvmti)(&quot;can_force_early_return&quot;);
398   if (cap-&gt;can_redefine_classes)
399     log_trace(jvmti)(&quot;can_redefine_classes&quot;);
400   if (cap-&gt;can_retransform_classes)
401     log_trace(jvmti)(&quot;can_retransform_classes&quot;);
402   if (cap-&gt;can_signal_thread)
403     log_trace(jvmti)(&quot;can_signal_thread&quot;);
404   if (cap-&gt;can_get_source_file_name)
405     log_trace(jvmti)(&quot;can_get_source_file_name&quot;);
406   if (cap-&gt;can_get_line_numbers)
407     log_trace(jvmti)(&quot;can_get_line_numbers&quot;);
408   if (cap-&gt;can_get_source_debug_extension)
409     log_trace(jvmti)(&quot;can_get_source_debug_extension&quot;);
410   if (cap-&gt;can_access_local_variables)
411     log_trace(jvmti)(&quot;can_access_local_variables&quot;);
412   if (cap-&gt;can_maintain_original_method_order)
413     log_trace(jvmti)(&quot;can_maintain_original_method_order&quot;);
414   if (cap-&gt;can_generate_single_step_events)
415     log_trace(jvmti)(&quot;can_generate_single_step_events&quot;);
416   if (cap-&gt;can_generate_exception_events)
417     log_trace(jvmti)(&quot;can_generate_exception_events&quot;);
418   if (cap-&gt;can_generate_frame_pop_events)
419     log_trace(jvmti)(&quot;can_generate_frame_pop_events&quot;);
420   if (cap-&gt;can_generate_breakpoint_events)
421     log_trace(jvmti)(&quot;can_generate_breakpoint_events&quot;);
422   if (cap-&gt;can_generate_sampled_object_alloc_events)
423     log_trace(jvmti)(&quot;can_generate_sampled_object_alloc_events&quot;);
424   if (cap-&gt;can_suspend)
425     log_trace(jvmti)(&quot;can_suspend&quot;);
426   if (cap-&gt;can_redefine_any_class )
427     log_trace(jvmti)(&quot;can_redefine_any_class&quot;);
428   if (cap-&gt;can_retransform_any_class )
429     log_trace(jvmti)(&quot;can_retransform_any_class&quot;);
430   if (cap-&gt;can_get_current_thread_cpu_time)
431     log_trace(jvmti)(&quot;can_get_current_thread_cpu_time&quot;);
432   if (cap-&gt;can_get_thread_cpu_time)
433     log_trace(jvmti)(&quot;can_get_thread_cpu_time&quot;);
434   if (cap-&gt;can_generate_method_entry_events)
435     log_trace(jvmti)(&quot;can_generate_method_entry_events&quot;);
436   if (cap-&gt;can_generate_method_exit_events)
437     log_trace(jvmti)(&quot;can_generate_method_exit_events&quot;);
438   if (cap-&gt;can_generate_all_class_hook_events)
439     log_trace(jvmti)(&quot;can_generate_all_class_hook_events&quot;);
440   if (cap-&gt;can_generate_compiled_method_load_events)
441     log_trace(jvmti)(&quot;can_generate_compiled_method_load_events&quot;);
442   if (cap-&gt;can_generate_monitor_events)
443     log_trace(jvmti)(&quot;can_generate_monitor_events&quot;);
444   if (cap-&gt;can_generate_vm_object_alloc_events)
445     log_trace(jvmti)(&quot;can_generate_vm_object_alloc_events&quot;);
446   if (cap-&gt;can_generate_native_method_bind_events)
447     log_trace(jvmti)(&quot;can_generate_native_method_bind_events&quot;);
448   if (cap-&gt;can_generate_garbage_collection_events)
449     log_trace(jvmti)(&quot;can_generate_garbage_collection_events&quot;);
450   if (cap-&gt;can_generate_object_free_events)
451     log_trace(jvmti)(&quot;can_generate_object_free_events&quot;);
452   if (cap-&gt;can_generate_resource_exhaustion_heap_events)
453     log_trace(jvmti)(&quot;can_generate_resource_exhaustion_heap_events&quot;);
454   if (cap-&gt;can_generate_resource_exhaustion_threads_events)
455     log_trace(jvmti)(&quot;can_generate_resource_exhaustion_threads_events&quot;);
456   if (cap-&gt;can_generate_early_vmstart)
457     log_trace(jvmti)(&quot;can_generate_early_vmstart&quot;);
458   if (cap-&gt;can_generate_early_class_hook_events)
459     log_trace(jvmti)(&quot;can_generate_early_class_hook_events&quot;);
460 }
461 
462 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
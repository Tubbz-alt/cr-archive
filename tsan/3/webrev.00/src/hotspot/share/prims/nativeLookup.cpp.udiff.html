<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/nativeLookup.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/nativeLookup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,29 +22,33 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;logging/logTag.hpp&quot;</span>
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/unsafe.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  #if INCLUDE_JFR
  #include &quot;jfr/jfr.hpp&quot;
  #endif
  
  static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,11 +106,11 @@</span>
    stringStream st;
    Symbol* signature = method-&gt;signature();
    st.print(&quot;__&quot;);
    // find &#39;)&#39;
    int end;
<span class="udiff-line-modified-removed">-   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != &#39;)&#39;; end++);</span>
<span class="udiff-line-modified-added">+   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != JVM_SIGNATURE_ENDFUNC; end++);</span>
    // skip first &#39;(&#39;
    mangle_name_on(&amp;st, signature, 1, end);
    return st.as_string();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,11 +139,11 @@</span>
  #if INCLUDE_JFR
    { CC&quot;Java_jdk_jfr_internal_JVM_registerNatives&quot;,                 NULL, FN_PTR(jfr_register_natives)            },
  #endif
  };
  
<span class="udiff-line-modified-removed">- static address lookup_special_native(char* jni_name) {</span>
<span class="udiff-line-modified-added">+ static address lookup_special_native(const char* jni_name) {</span>
    int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
    for (int i = 0; i &lt; count; i++) {
      // NB: To ignore the jni prefix and jni postfix strstr is used matching.
      if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
        return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,17 +152,12 @@</span>
    return NULL;
  }
  
  address NativeLookup::lookup_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style, bool&amp; in_base_library, TRAPS) {
    address entry;
<span class="udiff-line-modified-removed">-   // Compute complete JNI name for style</span>
<span class="udiff-line-modified-removed">-   stringStream st;</span>
<span class="udiff-line-removed">-   if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="udiff-line-removed">-   st.print_raw(pure_name);</span>
<span class="udiff-line-removed">-   st.print_raw(long_name);</span>
<span class="udiff-line-removed">-   if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="udiff-line-removed">-   char* jni_name = st.as_string();</span>
<span class="udiff-line-modified-added">+   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);</span>
<span class="udiff-line-modified-added">+ </span>
  
    // If the loader is null we have a system class, so we attempt a lookup in
    // the native Java library. This takes care of any bootstrapping problems.
    // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find
    // gets found the first time around - otherwise an infinite loop can occure. This is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -202,44 +201,30 @@</span>
    }
  
    return entry;
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- address NativeLookup::lookup_critical_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="udiff-line-modified-removed">-   if (!method-&gt;has_native_function()) {</span>
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+ const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="udiff-line-modified-added">+   stringStream st;</span>
<span class="udiff-line-modified-added">+   if (os_style) {</span>
<span class="udiff-line-modified-added">+     os::print_jni_name_prefix_on(&amp;st, args_size);</span>
    }
  
<span class="udiff-line-modified-removed">-   address current_entry = method-&gt;native_function();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   char dll_name[JVM_MAXPATHLEN];</span>
<span class="udiff-line-modified-removed">-   int offset;</span>
<span class="udiff-line-removed">-   if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {</span>
<span class="udiff-line-removed">-     char ebuf[32];</span>
<span class="udiff-line-removed">-     void* dll = os::dll_load(dll_name, ebuf, sizeof(ebuf));</span>
<span class="udiff-line-removed">-     if (dll != NULL) {</span>
<span class="udiff-line-removed">-       // Compute complete JNI name for style</span>
<span class="udiff-line-removed">-       stringStream st;</span>
<span class="udiff-line-removed">-       if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="udiff-line-removed">-       st.print_raw(pure_name);</span>
<span class="udiff-line-removed">-       st.print_raw(long_name);</span>
<span class="udiff-line-removed">-       if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="udiff-line-removed">-       char* jni_name = st.as_string();</span>
<span class="udiff-line-removed">-       address critical_entry = (address)os::dll_lookup(dll, jni_name);</span>
<span class="udiff-line-removed">-       // Close the handle to avoid keeping the library alive if the native method holder is unloaded.</span>
<span class="udiff-line-removed">-       // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon</span>
<span class="udiff-line-removed">-       // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper</span>
<span class="udiff-line-removed">-       // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.</span>
<span class="udiff-line-removed">-       os::dll_unload(dll);</span>
<span class="udiff-line-removed">-       return critical_entry;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   st.print_raw(pure_name);</span>
<span class="udiff-line-modified-added">+   st.print_raw(long_name);</span>
<span class="udiff-line-modified-added">+   if (os_style) {</span>
<span class="udiff-line-modified-added">+     os::print_jni_name_suffix_on(&amp;st, args_size);</span>
    }
  
<span class="udiff-line-modified-removed">-   return NULL;</span>
<span class="udiff-line-modified-added">+   return st.as_string();</span>
  }
  
<span class="udiff-line-added">+ address NativeLookup::lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="udiff-line-added">+   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);</span>
<span class="udiff-line-added">+   assert(dll != NULL, &quot;dll must be loaded&quot;);</span>
<span class="udiff-line-added">+   return (address)os::dll_lookup(dll, jni_name);</span>
<span class="udiff-line-added">+ }</span>
  
  // Check all the formats of native implementation name to see if there is one
  // for the specified method.
  address NativeLookup::lookup_entry(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
    address entry = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,59 +259,96 @@</span>
  }
  
  // Check all the formats of native implementation name to see if there is one
  // for the specified method.
  address NativeLookup::lookup_critical_entry(const methodHandle&amp; method) {
<span class="udiff-line-modified-removed">-   if (!CriticalJNINatives) return NULL;</span>
<span class="udiff-line-modified-added">+   assert(CriticalJNINatives, &quot;or should not be here&quot;);</span>
  
    if (method-&gt;is_synchronized() ||
        !method-&gt;is_static()) {
      // Only static non-synchronized methods are allowed
      return NULL;
    }
  
    ResourceMark rm;
<span class="udiff-line-removed">-   address entry = NULL;</span>
  
    Symbol* signature = method-&gt;signature();
    for (int end = 0; end &lt; signature-&gt;utf8_length(); end++) {
      if (signature-&gt;char_at(end) == &#39;L&#39;) {
        // Don&#39;t allow object types
        return NULL;
      }
    }
  
<span class="udiff-line-removed">-   // Compute critical name</span>
<span class="udiff-line-removed">-   char* critical_name = critical_jni_name(method);</span>
<span class="udiff-line-removed">- </span>
    // Compute argument size
    int args_size = method-&gt;size_of_parameters();
    for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
      if (ss.is_array()) {
        args_size += T_INT_size; // array length parameter
      }
    }
  
<span class="udiff-line-added">+   // dll handling requires I/O. Don&#39;t do that while in _thread_in_vm (safepoint may get requested).</span>
<span class="udiff-line-added">+   ThreadToNativeFromVM thread_in_native(JavaThread::current());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void* dll = dll_load(method);</span>
<span class="udiff-line-added">+   address entry = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (dll != NULL) {</span>
<span class="udiff-line-added">+     entry = lookup_critical_style(dll, method, args_size);</span>
<span class="udiff-line-added">+     // Close the handle to avoid keeping the library alive if the native method holder is unloaded.</span>
<span class="udiff-line-added">+     // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon</span>
<span class="udiff-line-added">+     // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper</span>
<span class="udiff-line-added">+     // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.</span>
<span class="udiff-line-added">+     os::dll_unload(dll);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return entry; // NULL indicates not found</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void* NativeLookup::dll_load(const methodHandle&amp; method) {</span>
<span class="udiff-line-added">+   if (method-&gt;has_native_function()) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     address current_entry = method-&gt;native_function();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     char dll_name[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+     int offset;</span>
<span class="udiff-line-added">+     if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {</span>
<span class="udiff-line-added">+       char ebuf[32];</span>
<span class="udiff-line-added">+       return os::dll_load(dll_name, ebuf, sizeof(ebuf));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ address NativeLookup::lookup_critical_style(void* dll, const methodHandle&amp; method, int args_size) {</span>
<span class="udiff-line-added">+   address entry = NULL;</span>
<span class="udiff-line-added">+   const char* critical_name = critical_jni_name(method);</span>
<span class="udiff-line-added">+ </span>
    // 1) Try JNI short style
<span class="udiff-line-modified-removed">-   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, true);</span>
<span class="udiff-line-modified-removed">-   if (entry != NULL) return entry;</span>
<span class="udiff-line-modified-added">+   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, true);</span>
<span class="udiff-line-modified-added">+   if (entry != NULL) {</span>
<span class="udiff-line-added">+     return entry;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   // Compute long name</span>
<span class="udiff-line-removed">-   char* long_name = long_jni_name(method);</span>
<span class="udiff-line-modified-added">+   const char* long_name = long_jni_name(method);</span>
  
    // 2) Try JNI long style
<span class="udiff-line-modified-removed">-   entry = lookup_critical_style(method, critical_name, long_name, args_size, true);</span>
<span class="udiff-line-modified-removed">-   if (entry != NULL) return entry;</span>
<span class="udiff-line-modified-added">+   entry = lookup_critical_style(dll, critical_name, long_name, args_size, true);</span>
<span class="udiff-line-modified-added">+   if (entry != NULL) {</span>
<span class="udiff-line-added">+     return entry;</span>
<span class="udiff-line-added">+   }</span>
  
    // 3) Try JNI short style without os prefix/suffix
<span class="udiff-line-modified-removed">-   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, false);</span>
<span class="udiff-line-modified-removed">-   if (entry != NULL) return entry;</span>
<span class="udiff-line-modified-added">+   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, false);</span>
<span class="udiff-line-modified-added">+   if (entry != NULL) {</span>
<span class="udiff-line-added">+     return entry;</span>
<span class="udiff-line-added">+   }</span>
  
    // 4) Try JNI long style without os prefix/suffix
<span class="udiff-line-modified-removed">-   entry = lookup_critical_style(method, critical_name, long_name, args_size, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return entry; // NULL indicates not found</span>
<span class="udiff-line-modified-added">+   return lookup_critical_style(dll, critical_name, long_name, args_size, false);</span>
  }
  
  // Check if there are any JVM TI prefixes which have been applied to the native method name.
  // If any are found, remove them before attemping the look up of the
  // native implementation again.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -356,11 +378,11 @@</span>
        Klass* k = method-&gt;method_holder();
        Method* wrapper_method = k-&gt;lookup_method(wrapper_symbol, method-&gt;signature());
        if (wrapper_method != NULL &amp;&amp; !wrapper_method-&gt;is_native()) {
          // we found a wrapper method, use its native entry
          method-&gt;set_is_prefixed_native();
<span class="udiff-line-modified-removed">-         return lookup_entry(wrapper_method, in_base_library, THREAD);</span>
<span class="udiff-line-modified-added">+         return lookup_entry(methodHandle(THREAD, wrapper_method), in_base_library, THREAD);</span>
        }
      }
    }
  #endif // INCLUDE_JVMTI
    return NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -377,37 +399,40 @@</span>
    // JVM TI prefixes which have been applied to the native method name.
    entry = lookup_entry_prefixed(method, in_base_library, THREAD);
    if (entry != NULL) return entry;
  
    // Native function not found, throw UnsatisfiedLinkError
<span class="udiff-line-modified-removed">-   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(),</span>
<span class="udiff-line-modified-removed">-               method-&gt;name_and_sig_as_C_string());</span>
<span class="udiff-line-modified-added">+   stringStream ss;</span>
<span class="udiff-line-modified-added">+   ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+   method-&gt;print_external_name(&amp;ss);</span>
<span class="udiff-line-added">+   ss.print(&quot;&#39;&quot;);</span>
<span class="udiff-line-added">+   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(), ss.as_string());</span>
  }
  
  
  address NativeLookup::lookup(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
    if (!method-&gt;has_native_function()) {
      address entry = lookup_base(method, in_base_library, CHECK_NULL);
      method-&gt;set_native_function(entry,
        Method::native_bind_event_is_interesting);
      // -verbose:jni printing
<span class="udiff-line-modified-removed">-     if (PrintJNIResolving) {</span>
<span class="udiff-line-modified-added">+     if (log_is_enabled(Debug, jni, resolve)) {</span>
        ResourceMark rm(THREAD);
<span class="udiff-line-modified-removed">-       tty-&gt;print_cr(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="udiff-line-modified-removed">-         method-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-modified-removed">-         method-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-modified-added">+       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="udiff-line-modified-added">+                               method-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+                               method-&gt;name()-&gt;as_C_string());</span>
      }
    }
    return method-&gt;native_function();
  }
  
  address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
    EXCEPTION_MARK;
    bool in_base_library = true;  // SharedRuntime inits some math methods.
<span class="udiff-line-modified-removed">-   TempNewSymbol c_name = SymbolTable::new_symbol(class_name,  CATCH);</span>
<span class="udiff-line-modified-removed">-   TempNewSymbol m_name = SymbolTable::new_symbol(method_name, CATCH);</span>
<span class="udiff-line-modified-removed">-   TempNewSymbol s_name = SymbolTable::new_symbol(signature,   CATCH);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol c_name = SymbolTable::new_symbol(class_name);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol m_name = SymbolTable::new_symbol(method_name);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol s_name = SymbolTable::new_symbol(signature);</span>
  
    // Find the class
    Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
    InstanceKlass* klass  = InstanceKlass::cast(k);
  
</pre>
<center><a href="methodHandles.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
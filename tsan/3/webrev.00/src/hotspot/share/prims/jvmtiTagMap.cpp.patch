diff a/src/hotspot/share/prims/jvmtiTagMap.cpp b/src/hotspot/share/prims/jvmtiTagMap.cpp
--- a/src/hotspot/share/prims/jvmtiTagMap.cpp
+++ b/src/hotspot/share/prims/jvmtiTagMap.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -30,10 +30,11 @@
 #include "classfile/vmSymbols.hpp"
 #include "jvmtifiles/jvmtiEnv.hpp"
 #include "logging/log.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/arrayOop.inline.hpp"
 #include "oops/constantPool.inline.hpp"
 #include "oops/instanceMirrorKlass.hpp"
 #include "oops/objArrayKlass.hpp"
@@ -97,19 +98,24 @@
   // Peek at the object without keeping it alive. The returned object must be
   // kept alive using a normal access if it leaks out of a thread transition from VM.
   inline oop object_peek()  {
     return NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(object_addr());
   }
+
+  inline oop object_raw() {
+    return RawAccess<>::oop_load(object_addr());
+  }
+
   inline jlong tag() const  { return _tag; }
 
   inline void set_tag(jlong tag) {
     assert(tag != 0, "can't be zero");
     _tag = tag;
   }
 
   inline bool equals(oop object) {
-    return oopDesc::equals(object, object_peek());
+    return object == object_peek();
   }
 
   inline JvmtiTagHashmapEntry* next() const        { return _next; }
   inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
 };
@@ -182,21 +188,13 @@
     }
   }
 
   // hash a given key (oop) with the specified size
   static unsigned int hash(oop key, int size) {
-    ZGC_ONLY(assert(ZAddressMetadataShift >= sizeof(unsigned int) * BitsPerByte, "cast removes the metadata bits");)
-
-    // shift right to get better distribution (as these bits will be zero
-    // with aligned addresses)
-    key = Access<>::resolve(key);
-    unsigned int addr = (unsigned int)(cast_from_oop<intptr_t>(key));
-#ifdef _LP64
-    return (addr >> 3) % size;
-#else
-    return (addr >> 2) % size;
-#endif
+    const oop obj = Access<>::resolve(key);
+    const unsigned int hash = Universe::heap()->hash_oop(obj);
+    return hash % size;
   }
 
   // hash a given key (oop)
   unsigned int hash(oop key) {
     return hash(key, _size);
@@ -383,15 +381,15 @@
 };
 
 // Tsan should know that the JVMTI TagMap is protected by a mutex.
 class TsanMutexScope : public StackObj {
  private:
-  Monitor *_lock;  // Keep my own reference, for destructor.
+  Mutex *_lock;  // Keep my own reference, for destructor.
 
  public:
   // Don't actually lock it, just tell tsan we did.
-  TsanMutexScope(Monitor* mutex) : _lock(mutex) {
+  TsanMutexScope(Mutex* mutex) : _lock(mutex) {
     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));
   }
 
   ~TsanMutexScope() {
     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));
@@ -485,11 +483,11 @@
   //  solutions.
 
   _hashmap = new JvmtiTagHashmap();
 
   // finally add us to the environment
-  ((JvmtiEnvBase *)env)->set_tag_map(this);
+  ((JvmtiEnvBase *)env)->release_set_tag_map(this);
 }
 
 
 // destroy a JvmtiTagMap
 JvmtiTagMap::~JvmtiTagMap() {
@@ -526,10 +524,15 @@
 // create a hashmap entry
 // - if there's an entry on the (per-environment) free list then this
 // is returned. Otherwise an new entry is allocated.
 JvmtiTagHashmapEntry* JvmtiTagMap::create_entry(oop ref, jlong tag) {
   assert(Thread::current()->is_VM_thread() || is_locked(), "checking");
+
+  // ref was read with AS_NO_KEEPALIVE, or equivalent.
+  // The object needs to be kept alive when it is published.
+  Universe::heap()->keep_alive(ref);
+
   JvmtiTagHashmapEntry* entry;
   if (_free_entries == NULL) {
     entry = new JvmtiTagHashmapEntry(ref, tag);
   } else {
     assert(_free_entries_count > 0, "mismatched _free_entries_count");
@@ -555,19 +558,19 @@
 }
 
 // returns the tag map for the given environments. If the tag map
 // doesn't exist then it is created.
 JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
-  JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)->tag_map();
+  JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)->tag_map_acquire();
   if (tag_map == NULL) {
     MutexLocker mu(JvmtiThreadState_lock);
     tag_map = ((JvmtiEnvBase*)env)->tag_map();
     if (tag_map == NULL) {
       tag_map = new JvmtiTagMap(env);
     }
   } else {
-    CHECK_UNHANDLED_OOPS_ONLY(Thread::current()->clear_unhandled_oops());
+    DEBUG_ONLY(Thread::current()->check_possible_safepoint());
   }
   return tag_map;
 }
 
 // iterate over all entries in the tag map.
@@ -1077,11 +1080,11 @@
   return false;
 }
 
 // helper function to tell if a field is a primitive field or not
 static inline bool is_primitive_field_type(char type) {
-  return (type != 'L' && type != '[');
+  return (type != JVM_SIGNATURE_CLASS && type != JVM_SIGNATURE_ARRAY);
 }
 
 // helper function to copy the value from location addr to jvalue.
 static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
   switch (value_type) {
@@ -1217,11 +1220,11 @@
     // one-to-one mapping
     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
 
     // get offset and field value
     int offset = field->field_offset();
-    address addr = (address)klass->java_mirror() + offset;
+    address addr = cast_from_oop<address>(klass->java_mirror()) + offset;
     jvalue value;
     copy_to_jvalue(&value, addr, value_type);
 
     // field index
     reference_info.field.index = field->field_index();
@@ -1270,11 +1273,11 @@
     // one-to-one mapping
     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
 
     // get offset and field value
     int offset = field->field_offset();
-    address addr = (address)obj + offset;
+    address addr = cast_from_oop<address>(obj) + offset;
     jvalue value;
     copy_to_jvalue(&value, addr, value_type);
 
     // field index
     reference_info.field.index = field->field_index();
@@ -1327,13 +1330,10 @@
     if (VerifyBeforeIteration) {
       Universe::verify();
     }
 
     // do the iteration
-    // If this operation encounters a bad object when using CMS,
-    // consider using safe_object_iterate() which avoids perm gen
-    // objects that may contain bad references.
     Universe::heap()->object_iterate(_blk);
   }
 
 };
 
@@ -1601,11 +1601,11 @@
         // The reference in this tag map could be the only (implicitly weak)
         // reference to that object. If we hand it out, we need to keep it live wrt
         // SATB marking similar to other j.l.ref.Reference referents. This is
         // achieved by using a phantom load in the object() accessor.
         oop o = entry->object();
-        assert(o != NULL && Universe::heap()->is_in_reserved(o), "sanity check");
+        assert(o != NULL && Universe::heap()->is_in(o), "sanity check");
         jobject ref = JNIHandles::make_local(JavaThread::current(), o);
         _object_results->append(ref);
         _tag_results->append((uint64_t)entry->tag());
       }
     }
@@ -1685,12 +1685,12 @@
 // An ObjectClosure used to restore the mark bits of an object
 class RestoreMarksClosure : public ObjectClosure {
  public:
   void do_object(oop o) {
     if (o != NULL) {
-      markOop mark = o->mark();
-      if (mark->is_marked()) {
+      markWord mark = o->mark();
+      if (mark.is_marked()) {
         o->init_mark();
       }
     }
   }
 };
@@ -1698,11 +1698,11 @@
 // ObjectMarker provides the mark and visited functions
 class ObjectMarker : AllStatic {
  private:
   // saved headers
   static GrowableArray<oop>* _saved_oop_stack;
-  static GrowableArray<markOop>* _saved_mark_stack;
+  static GrowableArray<markWord>* _saved_mark_stack;
   static bool _needs_reset;                  // do we need to reset mark bits?
 
  public:
   static void init();                       // initialize
   static void done();                       // clean-up
@@ -1713,22 +1713,22 @@
   static inline bool needs_reset()            { return _needs_reset; }
   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
 };
 
 GrowableArray<oop>* ObjectMarker::_saved_oop_stack = NULL;
-GrowableArray<markOop>* ObjectMarker::_saved_mark_stack = NULL;
+GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;
 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
 
 // initialize ObjectMarker - prepares for object marking
 void ObjectMarker::init() {
   assert(Thread::current()->is_VM_thread(), "must be VMThread");
 
   // prepare heap for iteration
   Universe::heap()->ensure_parsability(false);  // no need to retire TLABs
 
   // create stacks for interesting headers
-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markOop>(4000, true);
+  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(4000, true);
   _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<oop>(4000, true);
 
   if (UseBiasedLocking) {
     BiasedLocking::preserve_marks();
   }
@@ -1748,11 +1748,11 @@
   }
 
   // now restore the interesting headers
   for (int i = 0; i < _saved_oop_stack->length(); i++) {
     oop o = _saved_oop_stack->at(i);
-    markOop mark = _saved_mark_stack->at(i);
+    markWord mark = _saved_mark_stack->at(i);
     o->set_mark(mark);
   }
 
   if (UseBiasedLocking) {
     BiasedLocking::restore_marks();
@@ -1764,27 +1764,27 @@
 }
 
 // mark an object
 inline void ObjectMarker::mark(oop o) {
   assert(Universe::heap()->is_in(o), "sanity check");
-  assert(!o->mark()->is_marked(), "should only mark an object once");
+  assert(!o->mark().is_marked(), "should only mark an object once");
 
   // object's mark word
-  markOop mark = o->mark();
+  markWord mark = o->mark();
 
-  if (mark->must_be_preserved(o)) {
+  if (o->mark_must_be_preserved(mark)) {
     _saved_mark_stack->push(mark);
     _saved_oop_stack->push(o);
   }
 
   // mark the object
-  o->set_mark(markOopDesc::prototype()->set_marked());
+  o->set_mark(markWord::prototype().set_marked());
 }
 
 // return true if object is marked
 inline bool ObjectMarker::visited(oop o) {
-  return o->mark()->is_marked();
+  return o->mark().is_marked();
 }
 
 // Stack allocated class to help ensure that ObjectMarker is used
 // correctly. Constructor initializes ObjectMarker, destructor calls
 // ObjectMarker's done() function to restore object headers.
@@ -2629,11 +2629,11 @@
     // ignore null
     if (o == NULL) {
       return;
     }
 
-    assert(Universe::heap()->is_in_reserved(o), "should be impossible");
+    assert(Universe::heap()->is_in(o), "should be impossible");
 
     jvmtiHeapReferenceKind kind = root_kind();
     if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
       // SystemDictionary::oops_do reports the application
       // class loader as a root. We want this root to be reported as
@@ -2858,11 +2858,11 @@
 
 #ifdef ASSERT
 // verify that a static oop field is in range
 static inline bool verify_static_oop(InstanceKlass* ik,
                                      oop mirror, int offset) {
-  address obj_p = (address)mirror + offset;
+  address obj_p = cast_from_oop<address>(mirror) + offset;
   address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
   address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
   assert(end >= start, "sanity check");
 
   if (obj_p >= start && obj_p < end) {
@@ -2986,11 +2986,11 @@
             return false;
           }
         }
       } else {
          if (is_reporting_primitive_fields()) {
-           address addr = (address)mirror + field->field_offset();
+           address addr = cast_from_oop<address>(mirror) + field->field_offset();
            int slot = field->field_index();
            if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
              delete field_map;
              return false;
           }
@@ -3018,24 +3018,24 @@
   ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
   for (int i=0; i<field_map->field_count(); i++) {
     ClassFieldDescriptor* field = field_map->field_at(i);
     char type = field->field_type();
     if (!is_primitive_field_type(type)) {
-      oop fld_o = o->obj_field(field->field_offset());
+      oop fld_o = o->obj_field_access<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>(field->field_offset());
       // ignore any objects that aren't visible to profiler
       if (fld_o != NULL) {
-        assert(Universe::heap()->is_in_reserved(fld_o), "unsafe code should not "
+        assert(Universe::heap()->is_in(fld_o), "unsafe code should not "
                "have references to Klass* anymore");
         int slot = field->field_index();
         if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
           return false;
         }
       }
     } else {
       if (is_reporting_primitive_fields()) {
         // primitive instance field
-        address addr = (address)o + field->field_offset();
+        address addr = cast_from_oop<address>(o) + field->field_offset();
         int slot = field->field_index();
         if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
           return false;
         }
       }
@@ -3092,10 +3092,13 @@
   // Other kinds of roots maintained by HotSpot
   // Many of these won't be visible but others (such as instances of important
   // exceptions) will be visible.
   blk.set_kind(JVMTI_HEAP_REFERENCE_OTHER);
   Universe::oops_do(&blk);
+  if (blk.stopped()) {
+    return false;
+  }
 
   return true;
 }
 
 // Walk the stack of a given thread and find all references (locals
@@ -3367,11 +3370,11 @@
          SafepointSynchronize::is_at_safepoint(),
          "must be executed at a safepoint");
   if (JvmtiEnv::environments_might_exist()) {
     JvmtiEnvIterator it;
     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
-      JvmtiTagMap* tag_map = env->tag_map();
+      JvmtiTagMap* tag_map = env->tag_map_acquire();
       if (tag_map != NULL && !tag_map->is_empty()) {
         tag_map->do_weak_oops(is_alive, f);
       }
     }
   }
@@ -3409,11 +3412,11 @@
 
     while (entry != NULL) {
       JvmtiTagHashmapEntry* next = entry->next();
 
       // has object been GC'ed
-      if (!is_alive->do_object_b(entry->object_peek())) {
+      if (!is_alive->do_object_b(entry->object_raw())) {
         // grab the tag
         jlong tag = entry->tag();
         guarantee(tag != 0, "checking");
 
         // remove GC'ed entry from hashmap and return the
@@ -3427,11 +3430,11 @@
         }
 
         ++freed;
       } else {
         f->do_oop(entry->object_addr());
-        oop new_oop = entry->object_peek();
+        oop new_oop = entry->object_raw();
 
         // if the object has moved then re-hash it and move its
         // entry to its new location.
         unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
         if (new_pos != (unsigned int)pos) {
@@ -3461,11 +3464,11 @@
   }
 
   // Re-add all the entries which were kept aside
   while (delayed_add != NULL) {
     JvmtiTagHashmapEntry* next = delayed_add->next();
-    unsigned int pos = JvmtiTagHashmap::hash(delayed_add->object_peek(), size);
+    unsigned int pos = JvmtiTagHashmap::hash(delayed_add->object_raw(), size);
     delayed_add->set_next(table[pos]);
     table[pos] = delayed_add;
     delayed_add = next;
   }
 

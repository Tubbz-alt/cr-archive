<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiClassFileReconstituter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,11 +30,13 @@</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
<span class="udiff-line-added">+ #include &quot;prims/jvmtiThreadState.inline.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/safepointVerifiers.hpp&quot;</span>
  #include &quot;runtime/vmThread.hpp&quot;
  
  // Support class to collect a list of the non-nmethod CodeBlobs in
  // the CodeCache.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -201,11 +203,11 @@</span>
    // First collect all the code blobs.  This has to be done in a
    // single pass over the code cache with CodeCache_lock held because
    // there isn&#39;t any safe way to iterate over regular CodeBlobs since
    // they can be freed at any point.
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      collector.collect();
    }
  
    // iterate over the collected list and post an event for each blob
    JvmtiCodeBlobDesc* blob = collector.first();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,29 +219,38 @@</span>
  }
  
  
  // Generate a COMPILED_METHOD_LOAD event for each nnmethod
  jvmtiError JvmtiCodeBlobEvents::generate_compiled_method_load_events(JvmtiEnv* env) {
<span class="udiff-line-modified-removed">-   HandleMark hm;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Walk the CodeCache notifying for live nmethods.  The code cache</span>
<span class="udiff-line-modified-removed">-   // may be changing while this is happening which is ok since newly</span>
<span class="udiff-line-modified-removed">-   // created nmethod will notify normally and nmethods which are freed</span>
<span class="udiff-line-modified-removed">-   // can be safely skipped.</span>
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-   // Iterate over non-profiled and profiled nmethods</span>
<span class="udiff-line-modified-removed">-   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);</span>
<span class="udiff-line-modified-removed">-   while(iter.next()) {</span>
<span class="udiff-line-modified-removed">-     nmethod* current = iter.method();</span>
<span class="udiff-line-modified-removed">-     // Lock the nmethod so it can&#39;t be freed</span>
<span class="udiff-line-modified-removed">-     nmethodLocker nml(current);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Don&#39;t hold the lock over the notify or jmethodID creation</span>
<span class="udiff-line-modified-removed">-     MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-     current-&gt;get_and_cache_jmethod_id();</span>
<span class="udiff-line-modified-removed">-     JvmtiExport::post_compiled_method_load(current);</span>
<span class="udiff-line-modified-added">+   JavaThread* java_thread = JavaThread::current();</span>
<span class="udiff-line-modified-added">+   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     NoSafepointVerifier nsv;  // safepoints are not safe while collecting methods to post.</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // Walk the CodeCache notifying for live nmethods, don&#39;t release the CodeCache_lock</span>
<span class="udiff-line-modified-added">+       // because the sweeper may be running concurrently.</span>
<span class="udiff-line-modified-added">+       // Save events to the queue for posting outside the CodeCache_lock.</span>
<span class="udiff-line-modified-added">+       MutexLocker mu(java_thread, CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       // Iterate over non-profiled and profiled nmethods</span>
<span class="udiff-line-modified-added">+       NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);</span>
<span class="udiff-line-modified-added">+       while(iter.next()) {</span>
<span class="udiff-line-modified-added">+         nmethod* current = iter.method();</span>
<span class="udiff-line-modified-added">+         current-&gt;post_compiled_method_load_event(state);</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Enter nmethod barrier code if present outside CodeCache_lock</span>
<span class="udiff-line-added">+     state-&gt;run_nmethod_entry_barriers();</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Now post all the events outside the CodeCache_lock.</span>
<span class="udiff-line-added">+   // If there&#39;s a safepoint, the queued events will be kept alive.</span>
<span class="udiff-line-added">+   // Adding these events to the service thread to post is something that</span>
<span class="udiff-line-added">+   // should work, but the service thread doesn&#39;t keep up in stress scenarios and</span>
<span class="udiff-line-added">+   // the os eventually kills the process with OOM.</span>
<span class="udiff-line-added">+   // We want this thread to wait until the events are all posted.</span>
<span class="udiff-line-added">+   state-&gt;post_events(env);</span>
    return JVMTI_ERROR_NONE;
  }
  
  
  // create a C-heap allocated address location map for an nmethod
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -251,11 +262,11 @@</span>
    jvmtiAddrLocationMap* map = NULL;
    jint map_length = 0;
  
  
    // Generate line numbers using PcDesc and ScopeDesc info
<span class="udiff-line-modified-removed">-   methodHandle mh(nm-&gt;method());</span>
<span class="udiff-line-modified-added">+   methodHandle mh(Thread::current(), nm-&gt;method());</span>
  
    if (!mh-&gt;is_native()) {
      PcDesc *pcd;
      int pcds_in_method;
  
</pre>
<center><a href="jvmtiClassFileReconstituter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
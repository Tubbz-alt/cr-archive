<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/resolvedMethodTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="resolvedMethodTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stackwalk.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/resolvedMethodTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,91 ***</span>
   */
  
  #ifndef SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
  #define SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
  
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/weakHandle.hpp&quot;
<span class="line-removed">- #include &quot;utilities/hashtable.hpp&quot;</span>
  
<span class="line-modified">! // Hashtable to record Method* used in ResolvedMethods, via. ResolvedMethod oops.</span>
<span class="line-modified">! // This is needed for redefinition to replace Method* with redefined versions.</span>
  
<span class="line-modified">! // Entry in a ResolvedMethodTable, mapping a ClassLoaderWeakHandle for a single oop of</span>
<span class="line-modified">! // java_lang_invoke_ResolvedMethodName which holds JVM Method* in vmtarget.</span>
  
<span class="line-modified">! class ResolvedMethodEntry : public HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt; {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   ResolvedMethodEntry* next() const {</span>
<span class="line-removed">-     return (ResolvedMethodEntry*)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ResolvedMethodEntry** next_addr() {</span>
<span class="line-removed">-     return (ResolvedMethodEntry**)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::next_addr();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   oop object();</span>
<span class="line-removed">-   oop object_no_keepalive();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void print_on(outputStream* st) const;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ResolvedMethodTable : public Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt; {</span>
<span class="line-removed">-   enum Constants {</span>
<span class="line-removed">-     _table_size  = 1007</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static int _total_oops_removed;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static bool _dead_entries;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static ResolvedMethodTable* _the_table;</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ResolvedMethodEntry* bucket(int i) {</span>
<span class="line-removed">-     return (ResolvedMethodEntry*) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::bucket(i);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   ResolvedMethodEntry** bucket_addr(int i) {</span>
<span class="line-removed">-     return (ResolvedMethodEntry**) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::bucket_addr(i);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   unsigned int compute_hash(Method* method);</span>
  
<span class="line-modified">!   // need not be locked; no state change</span>
<span class="line-modified">!   oop lookup(int index, unsigned int hash, Method* method);</span>
<span class="line-modified">!   oop lookup(Method* method);</span>
  
<span class="line-modified">!   // must be done under ResolvedMethodTable_lock</span>
<span class="line-modified">!   oop basic_add(Method* method, Handle rmethod_name);</span>
  
<span class="line-modified">! public:</span>
<span class="line-removed">-   ResolvedMethodTable();</span>
  
<span class="line-modified">!   static void create_table() {</span>
<span class="line-modified">!     assert(_the_table == NULL, &quot;One symbol table allowed.&quot;);</span>
<span class="line-removed">-     _the_table = new ResolvedMethodTable();</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // Called from java_lang_invoke_ResolvedMethodName</span>
<span class="line-modified">!   static oop find_method(Method* method);</span>
<span class="line-modified">!   static oop add_method(const methodHandle&amp; method, Handle rmethod_name);</span>
  
<span class="line-modified">!   static bool has_work() { return _dead_entries; }</span>
<span class="line-modified">!   static void trigger_cleanup();</span>
  
<span class="line-modified">!   static int removed_entries_count() { return _total_oops_removed; };</span>
  
<span class="line-modified">! #if INCLUDE_JVMTI</span>
<span class="line-modified">!   // It is called at safepoint only for RedefineClasses</span>
<span class="line-modified">!   static void adjust_method_entries(bool * trace_name_printed);</span>
<span class="line-modified">! #endif // INCLUDE_JVMTI</span>
  
<span class="line-modified">!   // Cleanup cleared entries</span>
<span class="line-modified">!   static void unlink();</span>
  
<span class="line-modified">! #ifndef PRODUCT</span>
<span class="line-modified">!   void print();</span>
<span class="line-modified">! #endif</span>
<span class="line-removed">-   void verify();</span>
  };
  
  #endif // SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
<span class="line-new-header">--- 23,64 ---</span>
   */
  
  #ifndef SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
  #define SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
  
<span class="line-added">+ #include &quot;memory/allocation.hpp&quot;</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/weakHandle.hpp&quot;
  
<span class="line-modified">! class ResolvedMethodTable;</span>
<span class="line-modified">! class ResolvedMethodTableConfig;</span>
  
<span class="line-modified">! class ResolvedMethodTable : public AllStatic {</span>
<span class="line-modified">!   static volatile bool            _has_work;</span>
  
<span class="line-modified">! public:</span>
<span class="line-modified">!   // Initialization</span>
<span class="line-modified">!   static void create_table();</span>
  
<span class="line-modified">!   static size_t table_size();</span>
  
<span class="line-modified">!   // Lookup and inserts</span>
<span class="line-added">+   static oop find_method(const Method* method);</span>
<span class="line-added">+   static oop add_method(const Method* method, Handle rmethod_name);</span>
  
<span class="line-modified">!   // Callbacks</span>
<span class="line-modified">!   static void item_added();</span>
<span class="line-modified">!   static void item_removed();</span>
  
<span class="line-modified">!   // Cleaning</span>
<span class="line-modified">!   static bool has_work() { return _has_work; }</span>
  
<span class="line-modified">!   // Cleaning and table management</span>
  
<span class="line-modified">!   static double get_load_factor();</span>
<span class="line-modified">!   static double get_dead_factor();</span>
  
<span class="line-modified">!   static void check_concurrent_work();</span>
<span class="line-modified">!   static void trigger_concurrent_work();</span>
<span class="line-modified">!   static void do_concurrent_work(JavaThread* jt);</span>
  
<span class="line-modified">!   static void grow(JavaThread* jt);</span>
<span class="line-modified">!   static void clean_dead_entries(JavaThread* jt);</span>
  
<span class="line-modified">!   // GC Notification</span>
  
<span class="line-modified">!   // Must be called before a parallel walk where objects might die.</span>
<span class="line-modified">!   static void reset_dead_counter();</span>
<span class="line-modified">!   // After the parallel walk this method must be called to trigger</span>
<span class="line-modified">!   // cleaning. Note it might trigger a resize instead.</span>
<span class="line-added">+   static void finish_dead_counter();</span>
<span class="line-added">+   // If GC uses ParState directly it should add the number of cleared</span>
<span class="line-added">+   // entries to this method.</span>
<span class="line-added">+   static void inc_dead_counter(size_t ndead);</span>
  
<span class="line-modified">!   // JVMTI Support - It is called at safepoint only for RedefineClasses</span>
<span class="line-modified">!   JVMTI_ONLY(static void adjust_method_entries(bool * trace_name_printed);)</span>
  
<span class="line-modified">!   // Debugging</span>
<span class="line-modified">!   static size_t items_count();</span>
<span class="line-modified">!   static void verify();</span>
  };
  
  #endif // SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
</pre>
<center><a href="resolvedMethodTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stackwalk.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
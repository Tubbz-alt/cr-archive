<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvmtiEnvBase.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnvBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,12 +22,14 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/moduleEntry.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/oopHandle.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -656,14 +658,13 @@</span>
    ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
    if (mon == NULL) {
      // thread is not doing an Object.wait() call
      mon = java_thread-&gt;current_pending_monitor();
      if (mon != NULL) {
<span class="udiff-line-modified-removed">-       // The thread is trying to enter() or raw_enter() an ObjectMonitor.</span>
<span class="udiff-line-modified-added">+       // The thread is trying to enter() an ObjectMonitor.</span>
        obj = (oop)mon-&gt;object();
<span class="udiff-line-modified-removed">-       // If obj == NULL, then ObjectMonitor is raw which doesn&#39;t count</span>
<span class="udiff-line-removed">-       // as contended for this API</span>
<span class="udiff-line-modified-added">+       assert(obj != NULL, &quot;ObjectMonitor should have a valid object!&quot;);</span>
      }
      // implied else: no contended ObjectMonitor
    } else {
      // thread is doing an Object.wait() call
      obj = (oop)mon-&gt;object();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -957,27 +958,27 @@</span>
    {
      // Revoke any biases before querying the mark word
      if (at_safepoint) {
        BiasedLocking::revoke_at_safepoint(hobj);
      } else {
<span class="udiff-line-modified-removed">-       BiasedLocking::revoke_and_rebias(hobj, false, calling_thread);</span>
<span class="udiff-line-modified-added">+       BiasedLocking::revoke(hobj, calling_thread);</span>
      }
  
      address owner = NULL;
      {
<span class="udiff-line-modified-removed">-       markOop mark = hobj()-&gt;mark();</span>
<span class="udiff-line-modified-added">+       markWord mark = hobj()-&gt;mark();</span>
  
<span class="udiff-line-modified-removed">-       if (!mark-&gt;has_monitor()) {</span>
<span class="udiff-line-modified-added">+       if (!mark.has_monitor()) {</span>
          // this object has a lightweight monitor
  
<span class="udiff-line-modified-removed">-         if (mark-&gt;has_locker()) {</span>
<span class="udiff-line-modified-removed">-           owner = (address)mark-&gt;locker(); // save the address of the Lock word</span>
<span class="udiff-line-modified-added">+         if (mark.has_locker()) {</span>
<span class="udiff-line-modified-added">+           owner = (address)mark.locker(); // save the address of the Lock word</span>
          }
          // implied else: no owner
        } else {
          // this object has a heavyweight monitor
<span class="udiff-line-modified-removed">-         mon = mark-&gt;monitor();</span>
<span class="udiff-line-modified-added">+         mon = mark.monitor();</span>
  
          // The owner field of a heavyweight monitor may be NULL for no
          // owner, a JavaThread * or it may still be the address of the
          // Lock word in a JavaThread&#39;s stack. A monitor can be inflated
          // by a non-owning JavaThread, but only the owning JavaThread
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1080,11 +1081,11 @@</span>
          for (int i = 0; i &lt; nWant; i++) {
            JavaThread *pending_thread = wantList-&gt;at(i);
            // If the monitor has no owner, then a non-suspended contending
            // thread could potentially change the state of the monitor by
            // entering it. The JVM/TI spec doesn&#39;t allow this.
<span class="udiff-line-modified-removed">-           if (owning_thread == NULL &amp;&amp; !at_safepoint &amp;</span>
<span class="udiff-line-modified-added">+           if (owning_thread == NULL &amp;&amp; !at_safepoint &amp;&amp;</span>
                !pending_thread-&gt;is_thread_fully_suspended(true, &amp;debug_bits)) {
              if (ret.owner != NULL) {
                destroy_jni_reference(calling_thread, ret.owner);
              }
              for (int j = 0; j &lt; i; j++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1212,12 +1213,11 @@</span>
      }
      JavaThreadState jts = thr-&gt;thread_state();
      if (jts == _thread_in_native) {
        state |= JVMTI_THREAD_STATE_IN_NATIVE;
      }
<span class="udiff-line-modified-removed">-     OSThread* osThread = thr-&gt;osthread();</span>
<span class="udiff-line-removed">-     if (osThread != NULL &amp;&amp; osThread-&gt;interrupted()) {</span>
<span class="udiff-line-modified-added">+     if (thr-&gt;is_interrupted(false)) {</span>
        state |= JVMTI_THREAD_STATE_INTERRUPTED;
      }
    }
    infop-&gt;state = state;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1359,11 +1359,11 @@</span>
      NULL_CHECK(ob_h, JVMTI_ERROR_INVALID_OBJECT);
      Klass* ob_k = ob_h()-&gt;klass();
      NULL_CHECK(ob_k, JVMTI_ERROR_INVALID_OBJECT);
  
      // Method return type signature.
<span class="udiff-line-modified-removed">-     char* ty_sign = 1 + strchr(signature-&gt;as_C_string(), &#39;)&#39;);</span>
<span class="udiff-line-modified-added">+     char* ty_sign = 1 + strchr(signature-&gt;as_C_string(), JVM_SIGNATURE_ENDFUNC);</span>
  
      if (!VM_GetOrSetLocal::is_assignable(ty_sign, ob_k, current_thread)) {
        return JVMTI_ERROR_TYPE_MISMATCH;
      }
      *ret_ob_h = ob_h;
</pre>
<center><a href="jvmtiEnv.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnvBase.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
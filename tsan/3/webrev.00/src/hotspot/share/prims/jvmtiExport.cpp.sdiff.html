<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiExport.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEventController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiExport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;

  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;code/nmethod.hpp&quot;
  29 #include &quot;code/pcDesc.hpp&quot;
  30 #include &quot;code/scopeDesc.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  33 #include &quot;logging/log.hpp&quot;
  34 #include &quot;logging/logStream.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;

  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;oops/objArrayOop.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  41 #include &quot;prims/jvmtiEventController.hpp&quot;
  42 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  43 #include &quot;prims/jvmtiExport.hpp&quot;
  44 #include &quot;prims/jvmtiImpl.hpp&quot;
  45 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  46 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  47 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  48 #include &quot;prims/jvmtiTagMap.hpp&quot;
  49 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  50 #include &quot;runtime/arguments.hpp&quot;
  51 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  54 #include &quot;runtime/javaCalls.hpp&quot;
  55 #include &quot;runtime/jniHandles.inline.hpp&quot;
  56 #include &quot;runtime/objectMonitor.hpp&quot;
  57 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  58 #include &quot;runtime/os.inline.hpp&quot;
  59 #include &quot;runtime/safepointVerifiers.hpp&quot;

  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadSMR.hpp&quot;
  62 #include &quot;runtime/vframe.inline.hpp&quot;
  63 #include &quot;utilities/macros.hpp&quot;
  64 
  65 #ifdef JVMTI_TRACE
  66 #define EVT_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_SENT) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  67 #define EVT_TRIG_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_TRIGGER) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  68 #else
  69 #define EVT_TRIG_TRACE(evt,out)
  70 #define EVT_TRACE(evt,out)
  71 #endif
  72 
  73 ///////////////////////////////////////////////////////////////
  74 //
  75 // JvmtiEventTransition
  76 //
  77 // TO DO --
  78 //  more handle purging
  79 
</pre>
<hr />
<pre>
 285     return _jloader;
 286   }
 287   jobject protection_domain() {
 288     return _protection_domain;
 289   }
 290   jclass class_being_redefined() {
 291     return _class_being_redefined;
 292   }
 293 };
 294 
 295 //////////////////////////////////////////////////////////////////////////////
 296 
 297 int               JvmtiExport::_field_access_count                        = 0;
 298 int               JvmtiExport::_field_modification_count                  = 0;
 299 
 300 bool              JvmtiExport::_can_access_local_variables                = false;
 301 bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
 302 bool              JvmtiExport::_can_modify_any_class                      = false;
 303 bool              JvmtiExport::_can_walk_any_space                        = false;
 304 
<span class="line-modified"> 305 bool              JvmtiExport::_has_redefined_a_class                     = false;</span>
 306 bool              JvmtiExport::_all_dependencies_are_recorded             = false;
 307 
 308 //
 309 // field access management
 310 //
 311 
 312 // interpreter generator needs the address of the counter
 313 address JvmtiExport::get_field_access_count_addr() {
 314   // We don&#39;t grab a lock because we don&#39;t want to
 315   // serialize field access between all threads. This means that a
 316   // thread on another processor can see the wrong count value and
 317   // may either miss making a needed call into post_field_access()
 318   // or will make an unneeded call into post_field_access(). We pay
 319   // this price to avoid slowing down the VM when we aren&#39;t watching
 320   // field accesses.
 321   // Other access/mutation safe by virtue of being in VM state.
 322   return (address)(&amp;_field_access_count);
 323 }
 324 
 325 //
</pre>
<hr />
<pre>
 364           return JNI_EVERSION;  // unsupported minor version number
 365       }
 366       break;
 367     case 9:
 368       switch (minor) {
 369         case 0:  // version 9.0.&lt;micro&gt; is recognized
 370           break;
 371         default:
 372           return JNI_EVERSION;  // unsupported minor version number
 373       }
 374       break;
 375     case 11:
 376       switch (minor) {
 377         case 0:  // version 11.0.&lt;micro&gt; is recognized
 378           break;
 379         default:
 380           return JNI_EVERSION;  // unsupported minor version number
 381       }
 382       break;
 383     default:
<span class="line-modified"> 384       return JNI_EVERSION;  // unsupported major version number</span>



 385   }
 386 
 387   if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
 388     JavaThread* current_thread = JavaThread::current();
 389     // transition code: native to VM
 390     ThreadInVMfromNative __tiv(current_thread);
 391     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
 392     debug_only(VMNativeEntryWrapper __vew;)
 393 
 394     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 395     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 396     return JNI_OK;
 397 
 398   } else if (JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
 399     // not live, no thread to transition
 400     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 401     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 402     return JNI_OK;
 403 
 404   } else {
</pre>
<hr />
<pre>
1180 
1181       ets-&gt;set_breakpoint_posted();
1182       thread-&gt;osthread()-&gt;set_state(old_os_state);
1183     }
1184   }
1185 }
1186 
1187 //////////////////////////////////////////////////////////////////////////////
1188 
1189 bool              JvmtiExport::_can_get_source_debug_extension            = false;
1190 bool              JvmtiExport::_can_maintain_original_method_order        = false;
1191 bool              JvmtiExport::_can_post_interpreter_events               = false;
1192 bool              JvmtiExport::_can_post_on_exceptions                    = false;
1193 bool              JvmtiExport::_can_post_breakpoint                       = false;
1194 bool              JvmtiExport::_can_post_field_access                     = false;
1195 bool              JvmtiExport::_can_post_field_modification               = false;
1196 bool              JvmtiExport::_can_post_method_entry                     = false;
1197 bool              JvmtiExport::_can_post_method_exit                      = false;
1198 bool              JvmtiExport::_can_pop_frame                             = false;
1199 bool              JvmtiExport::_can_force_early_return                    = false;

1200 
1201 bool              JvmtiExport::_early_vmstart_recorded                    = false;
1202 
1203 bool              JvmtiExport::_should_post_single_step                   = false;
1204 bool              JvmtiExport::_should_post_field_access                  = false;
1205 bool              JvmtiExport::_should_post_field_modification            = false;
1206 bool              JvmtiExport::_should_post_class_load                    = false;
1207 bool              JvmtiExport::_should_post_class_prepare                 = false;
1208 bool              JvmtiExport::_should_post_class_unload                  = false;
1209 bool              JvmtiExport::_should_post_thread_life                   = false;
1210 bool              JvmtiExport::_should_clean_up_heap_objects              = false;
1211 bool              JvmtiExport::_should_post_native_method_bind            = false;
1212 bool              JvmtiExport::_should_post_dynamic_code_generated        = false;
1213 bool              JvmtiExport::_should_post_data_dump                     = false;
1214 bool              JvmtiExport::_should_post_compiled_method_load          = false;
1215 bool              JvmtiExport::_should_post_compiled_method_unload        = false;
1216 bool              JvmtiExport::_should_post_monitor_contended_enter       = false;
1217 bool              JvmtiExport::_should_post_monitor_contended_entered     = false;
1218 bool              JvmtiExport::_should_post_monitor_wait                  = false;
1219 bool              JvmtiExport::_should_post_monitor_waited                = false;
</pre>
<hr />
<pre>
1326       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1327         continue;
1328       }
1329       EVT_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Evt Class Prepare sent %s&quot;,
1330                                             JvmtiTrace::safe_get_thread_name(thread),
1331                                             klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1332       JvmtiClassEventMark jem(thread, klass);
1333       JvmtiJavaThreadEventTransition jet(thread);
1334       jvmtiEventClassPrepare callback = env-&gt;callbacks()-&gt;ClassPrepare;
1335       if (callback != NULL) {
1336         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1337       }
1338     }
1339   }
1340 }
1341 
1342 void JvmtiExport::post_class_unload(Klass* klass) {
1343   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1344     return;
1345   }
<span class="line-modified">1346   Thread *thread = Thread::current();</span>















1347   HandleMark hm(thread);
1348 
1349   EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
1350   if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-removed">1351     assert(thread-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
<span class="line-removed">1352 </span>
<span class="line-removed">1353     // get JavaThread for whom we are proxy</span>
<span class="line-removed">1354     Thread *calling_thread = ((VMThread *)thread)-&gt;vm_operation()-&gt;calling_thread();</span>
<span class="line-removed">1355     if (!calling_thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">1356       // cannot post an event to a non-JavaThread</span>
<span class="line-removed">1357       return;</span>
<span class="line-removed">1358     }</span>
<span class="line-removed">1359     JavaThread *real_thread = (JavaThread *)calling_thread;</span>
1360 
1361     JvmtiEnvIterator it;
1362     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1363       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1364         continue;
1365       }
1366       if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-modified">1367         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;,</span>
<span class="line-removed">1368                   klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370         // do everything manually, since this is a proxy - needs special care</span>
<span class="line-removed">1371         JNIEnv* jni_env = real_thread-&gt;jni_environment();</span>
<span class="line-removed">1372         jthread jt = (jthread)JNIHandles::make_local(real_thread, real_thread-&gt;threadObj());</span>
<span class="line-removed">1373         jclass jk = (jclass)JNIHandles::make_local(real_thread, klass-&gt;java_mirror());</span>
<span class="line-removed">1374 </span>
<span class="line-removed">1375         // Before we call the JVMTI agent, we have to set the state in the</span>
<span class="line-removed">1376         // thread for which we are proxying.</span>
<span class="line-removed">1377         JavaThreadState prev_state = real_thread-&gt;thread_state();</span>
<span class="line-removed">1378         assert(((Thread *)real_thread)-&gt;is_ConcurrentGC_thread() ||</span>
<span class="line-removed">1379                (real_thread-&gt;is_Java_thread() &amp;&amp; prev_state == _thread_blocked),</span>
<span class="line-removed">1380                &quot;should be ConcurrentGCThread or JavaThread at safepoint&quot;);</span>
<span class="line-removed">1381         real_thread-&gt;set_thread_state(_thread_in_native);</span>
1382 


1383         jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
1384         if (callback != NULL) {
<span class="line-modified">1385           (*callback)(env-&gt;jvmti_external(), jni_env, jt, jk);</span>
1386         }
<span class="line-removed">1387 </span>
<span class="line-removed">1388         assert(real_thread-&gt;thread_state() == _thread_in_native,</span>
<span class="line-removed">1389                &quot;JavaThread should be in native&quot;);</span>
<span class="line-removed">1390         real_thread-&gt;set_thread_state(prev_state);</span>
<span class="line-removed">1391 </span>
<span class="line-removed">1392         JNIHandles::destroy_local(jk);</span>
<span class="line-removed">1393         JNIHandles::destroy_local(jt);</span>
1394       }
1395     }
1396   }
1397 }
1398 
1399 
1400 void JvmtiExport::post_thread_start(JavaThread *thread) {
1401   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1402     return;
1403   }
1404   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
1405 
1406   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Trg Thread Start event triggered&quot;,
1407                       JvmtiTrace::safe_get_thread_name(thread)));
1408 
1409   // do JVMTI thread initialization (if needed)
1410   JvmtiEventController::thread_started(thread);
1411 
1412   // Do not post thread start event for hidden java thread.
1413   if (JvmtiEventController::is_enabled(JVMTI_EVENT_THREAD_START) &amp;&amp;
</pre>
<hr />
<pre>
1567     return;
1568   }
1569 
1570   // return a flag when a method terminates by throwing an exception
1571   // i.e. if an exception is thrown and it&#39;s not caught by the current method
1572   bool exception_exit = state-&gt;is_exception_detected() &amp;&amp; !state-&gt;is_exception_caught();
1573 
1574 
1575   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1576     Handle result;
1577     jvalue value;
1578     value.j = 0L;
1579 
1580     // if the method hasn&#39;t been popped because of an exception then we populate
1581     // the return_value parameter for the callback. At this point we only have
1582     // the address of a &quot;raw result&quot; and we just call into the interpreter to
1583     // convert this into a jvalue.
1584     if (!exception_exit) {
1585       oop oop_result;
1586       BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
<span class="line-modified">1587       if (type == T_OBJECT || type == T_ARRAY) {</span>
1588         result = Handle(thread, oop_result);
1589       }
1590     }
1591 
1592     JvmtiEnvThreadStateIterator it(state);
1593     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1594       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1595         EVT_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Evt Method Exit sent %s.%s&quot;,
1596                                             JvmtiTrace::safe_get_thread_name(thread),
1597                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1598                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1599 
1600         JvmtiEnv *env = ets-&gt;get_env();
1601         JvmtiMethodEventMark jem(thread, mh);
1602         if (result.not_null()) {
1603           value.l = JNIHandles::make_local(thread, result());
1604         }
1605         JvmtiJavaThreadEventTransition jet(thread);
1606         jvmtiEventMethodExit callback = env-&gt;callbacks()-&gt;MethodExit;
1607         if (callback != NULL) {
</pre>
<hr />
<pre>
1971   if (!fd.is_field_modification_watched()) return;
1972 
1973   HandleMark hm(thread);
1974 
1975   Handle h_obj;
1976   if (!is_static) {
1977     // non-static field accessors have an object, but we need a handle
1978     assert(obj != NULL, &quot;non-static needs an object&quot;);
1979     h_obj = Handle(thread, obj);
1980   }
1981   post_field_modification(thread,
1982                           thread-&gt;last_frame().interpreter_frame_method(),
1983                           thread-&gt;last_frame().interpreter_frame_bcp(),
1984                           klass, h_obj, fieldID, sig_type, value);
1985 }
1986 
1987 void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
1988   address location, Klass* field_klass, Handle object, jfieldID field,
1989   char sig_type, jvalue *value) {
1990 
<span class="line-modified">1991   if (sig_type == &#39;I&#39; || sig_type == &#39;Z&#39; || sig_type == &#39;B&#39; || sig_type == &#39;C&#39; || sig_type == &#39;S&#39;) {</span>


1992     // &#39;I&#39; instructions are used for byte, char, short and int.
1993     // determine which it really is, and convert
1994     fieldDescriptor fd;
1995     bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
1996     // should be found (if not, leave as is)
1997     if (found) {
1998       jint ival = value-&gt;i;
1999       // convert value from int to appropriate type
2000       switch (fd.field_type()) {
2001       case T_BOOLEAN:
<span class="line-modified">2002         sig_type = &#39;Z&#39;;</span>
2003         value-&gt;i = 0; // clear it
2004         value-&gt;z = (jboolean)ival;
2005         break;
2006       case T_BYTE:
<span class="line-modified">2007         sig_type = &#39;B&#39;;</span>
2008         value-&gt;i = 0; // clear it
2009         value-&gt;b = (jbyte)ival;
2010         break;
2011       case T_CHAR:
<span class="line-modified">2012         sig_type = &#39;C&#39;;</span>
2013         value-&gt;i = 0; // clear it
2014         value-&gt;c = (jchar)ival;
2015         break;
2016       case T_SHORT:
<span class="line-modified">2017         sig_type = &#39;S&#39;;</span>
2018         value-&gt;i = 0; // clear it
2019         value-&gt;s = (jshort)ival;
2020         break;
2021       case T_INT:
2022         // nothing to do
2023         break;
2024       default:
2025         // this is an integer instruction, should be one of above
2026         ShouldNotReachHere();
2027         break;
2028       }
2029     }
2030   }
2031 
<span class="line-modified">2032   assert(sig_type != &#39;[&#39;, &quot;array should have sig_type == &#39;L&#39;&quot;);</span>
2033   bool handle_created = false;
2034 
2035   // convert oop to JNI handle.
<span class="line-modified">2036   if (sig_type == &#39;L&#39;) {</span>
2037     handle_created = true;
2038     value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
2039   }
2040 
2041   post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
2042 
2043   // Destroy the JNI handle allocated above.
2044   if (handle_created) {
2045     JNIHandles::destroy_local(value-&gt;l);
2046   }
2047 }
2048 
2049 void JvmtiExport::post_field_modification(JavaThread *thread, Method* method,
2050   address location, Klass* field_klass, Handle object, jfieldID field,
2051   char sig_type, jvalue *value_ptr) {
2052 
2053   HandleMark hm(thread);
2054   methodHandle mh(thread, method);
2055 
2056   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
</pre>
<hr />
<pre>
2130    record-&gt;numpcs++;
2131   }
2132   record-&gt;pcinfo = (PCStackInfo*)(NEW_RESOURCE_ARRAY(PCStackInfo, record-&gt;numpcs));
2133   int scope = 0;
2134   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2135     if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2136     void* pc_address = (void*)p-&gt;real_pc(nm);
2137     assert(pc_address != NULL, &quot;pc_address must be non-null&quot;);
2138     record-&gt;pcinfo[scope].pc = pc_address;
2139     numstackframes=0;
2140     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2141       numstackframes++;
2142     }
2143     assert(numstackframes != 0, &quot;numstackframes must be nonzero.&quot;);
2144     record-&gt;pcinfo[scope].methods = (jmethodID *)NEW_RESOURCE_ARRAY(jmethodID, numstackframes);
2145     record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
2146     record-&gt;pcinfo[scope].numstackframes = numstackframes;
2147     int stackframe = 0;
2148     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2149       // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
<span class="line-modified">2150       assert(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);</span>
2151       record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
2152       record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
2153       stackframe++;
2154     }
2155     scope++;
2156   }
2157   return record;
2158 }
2159 
2160 void JvmtiExport::post_compiled_method_load(nmethod *nm) {

2161   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
2162     return;
2163   }
2164   JavaThread* thread = JavaThread::current();
2165 
2166   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,
2167                  (&quot;[%s] method compile load event triggered&quot;,
2168                  JvmtiTrace::safe_get_thread_name(thread)));
2169 
2170   JvmtiEnvIterator it;
2171   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">2172     if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
<span class="line-removed">2173       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {</span>
<span class="line-removed">2174         continue;</span>
<span class="line-removed">2175       }</span>
<span class="line-removed">2176       EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">2177                 (&quot;[%s] class compile method load event sent %s.%s  &quot;,</span>
<span class="line-removed">2178                 JvmtiTrace::safe_get_thread_name(thread),</span>
<span class="line-removed">2179                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),</span>
<span class="line-removed">2180                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));</span>
<span class="line-removed">2181       ResourceMark rm(thread);</span>
<span class="line-removed">2182       HandleMark hm(thread);</span>
<span class="line-removed">2183 </span>
<span class="line-removed">2184       // Add inlining information</span>
<span class="line-removed">2185       jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);</span>
<span class="line-removed">2186       // Pass inlining information through the void pointer</span>
<span class="line-removed">2187       JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);</span>
<span class="line-removed">2188       JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-removed">2189       jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-removed">2190       if (callback != NULL) {</span>
<span class="line-removed">2191         (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),</span>
<span class="line-removed">2192                     jem.code_size(), jem.code_data(), jem.map_length(),</span>
<span class="line-removed">2193                     jem.map(), jem.compile_info());</span>
<span class="line-removed">2194       }</span>
<span class="line-removed">2195     }</span>
2196   }
2197 }
2198 
<span class="line-removed">2199 </span>
2200 // post a COMPILED_METHOD_LOAD event for a given environment
<span class="line-modified">2201 void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-modified">2202                                             const void *code_begin, const jint map_length,</span>
<span class="line-modified">2203                                             const jvmtiAddrLocationMap* map)</span>
<span class="line-modified">2204 {</span>
<span class="line-modified">2205   if (env-&gt;phase() &lt;= JVMTI_PHASE_PRIMORDIAL) {</span>

2206     return;
2207   }
2208   JavaThread* thread = JavaThread::current();
<span class="line-removed">2209   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">2210                  (&quot;[%s] method compile load event triggered (by GenerateEvents)&quot;,</span>
<span class="line-removed">2211                  JvmtiTrace::safe_get_thread_name(thread)));</span>
<span class="line-removed">2212   if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
2213 
<span class="line-modified">2214     EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-modified">2215               (&quot;[%s] class compile method load event sent (by GenerateEvents), jmethodID=&quot; PTR_FORMAT,</span>
<span class="line-modified">2216                JvmtiTrace::safe_get_thread_name(thread), p2i(method)));</span>




2217 
<span class="line-modified">2218     JvmtiEventMark jem(thread);</span>
<span class="line-modified">2219     JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-modified">2220     jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-modified">2221     if (callback != NULL) {</span>
<span class="line-modified">2222       (*callback)(env-&gt;jvmti_external(), method,</span>
<span class="line-modified">2223                   length, code_begin, map_length,</span>
<span class="line-modified">2224                   map, NULL);</span>
<span class="line-modified">2225     }</span>
<span class="line-removed">2226   }</span>
2227 }
2228 
2229 void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
2230   assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
2231 
2232   JavaThread* thread = JavaThread::current();
2233   // In theory everyone coming thru here is in_vm but we need to be certain
2234   // because a callee will do a vm-&gt;native transition
2235   ThreadInVMfromUnknown __tiv;
2236 
2237   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2238                  (&quot;[%s] method dynamic code generated event triggered&quot;,
2239                  JvmtiTrace::safe_get_thread_name(thread)));
2240   JvmtiEnvIterator it;
2241   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2242     if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2243       EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2244                 (&quot;[%s] dynamic code generated event sent for %s&quot;,
2245                 JvmtiTrace::safe_get_thread_name(thread), name));
2246       JvmtiEventMark jem(thread);
2247       JvmtiJavaThreadEventTransition jet(thread);
2248       jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2249       jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2250       if (callback != NULL) {
2251         (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2252       }
2253     }
2254   }
2255 }
2256 
2257 void JvmtiExport::post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) {
2258   jvmtiPhase phase = JvmtiEnv::get_phase();
2259   if (phase == JVMTI_PHASE_PRIMORDIAL || phase == JVMTI_PHASE_START) {
2260     post_dynamic_code_generated_internal(name, code_begin, code_end);
2261   } else {
2262     // It may not be safe to post the event from this thread.  Defer all
2263     // postings to the service thread so that it can perform them in a safe
2264     // context and in-order.
<span class="line-removed">2265     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
2266     JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
2267         name, code_begin, code_end);
<span class="line-modified">2268     JvmtiDeferredEventQueue::enqueue(event);</span>
2269   }
2270 }
2271 
2272 
2273 // post a DYNAMIC_CODE_GENERATED event for a given environment
2274 // used by GenerateEvents
2275 void JvmtiExport::post_dynamic_code_generated(JvmtiEnv* env, const char *name,
2276                                               const void *code_begin, const void *code_end)
2277 {
2278   JavaThread* thread = JavaThread::current();
2279   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2280                  (&quot;[%s] dynamic code generated event triggered (by GenerateEvents)&quot;,
2281                   JvmtiTrace::safe_get_thread_name(thread)));
2282   if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2283     EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2284               (&quot;[%s] dynamic code generated event sent for %s&quot;,
2285                JvmtiTrace::safe_get_thread_name(thread), name));
2286     JvmtiEventMark jem(thread);
2287     JvmtiJavaThreadEventTransition jet(thread);
2288     jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2289     jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2290     if (callback != NULL) {
2291       (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2292     }
2293   }
2294 }
2295 
2296 // post a DynamicCodeGenerated event while holding locks in the VM.
2297 void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
2298                                                                   address code_begin, address code_end)
2299 {
2300   // register the stub with the current dynamic code event collector
<span class="line-modified">2301   JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());</span>


2302   // state can only be NULL if the current thread is exiting which
2303   // should not happen since we&#39;re trying to post an event
2304   guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
2305   JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
2306   guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
2307   collector-&gt;register_stub(name, code_begin, code_end);
2308 }
2309 
2310 // Collect all the vm internally allocated objects which are visible to java world
2311 void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
2312   Thread* thread = Thread::current_or_null();
2313   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2314     // Can not take safepoint here.
2315     NoSafepointVerifier no_sfpt;
<span class="line-modified">2316     // Can not take safepoint here so can not use state_for to get</span>
2317     // jvmti thread state.
2318     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2319     if (state != NULL) {
2320       // state is non NULL when VMObjectAllocEventCollector is enabled.
2321       JvmtiVMObjectAllocEventCollector *collector;
2322       collector = state-&gt;get_vm_object_alloc_event_collector();
2323       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2324         // Don&#39;t record classes as these will be notified via the ClassLoad
2325         // event.
2326         if (obj-&gt;klass() != SystemDictionary::Class_klass()) {
2327           collector-&gt;record_allocation(obj);
2328         }
2329       }
2330     }
2331   }
2332 }
2333 
2334 // Collect all the sampled allocated objects.
2335 void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
2336   Thread* thread = Thread::current_or_null();
2337   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2338     // Can not take safepoint here.
2339     NoSafepointVerifier no_sfpt;
<span class="line-modified">2340     // Can not take safepoint here so can not use state_for to get</span>
2341     // jvmti thread state.
2342     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2343     if (state != NULL) {
2344       // state is non NULL when SampledObjectAllocEventCollector is enabled.
2345       JvmtiSampledObjectAllocEventCollector *collector;
2346       collector = state-&gt;get_sampled_object_alloc_event_collector();
2347 
2348       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2349         collector-&gt;record_allocation(obj);
2350       }
2351     }
2352   }
2353 }
2354 
2355 void JvmtiExport::post_garbage_collection_finish() {
2356   Thread *thread = Thread::current(); // this event is posted from VM-Thread.
2357   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2358                  (&quot;[%s] garbage collection finish event triggered&quot;,
2359                   JvmtiTrace::safe_get_thread_name(thread)));
2360   JvmtiEnvIterator it;
</pre>
<hr />
<pre>
2589                 (&quot;[%s] Evt sampled object alloc sent %s&quot;,
2590                  JvmtiTrace::safe_get_thread_name(thread),
2591                  object == NULL ? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2592 
2593       JvmtiEnv *env = ets-&gt;get_env();
2594       JvmtiObjectAllocEventMark jem(thread, h());
2595       JvmtiJavaThreadEventTransition jet(thread);
2596       jvmtiEventSampledObjectAlloc callback = env-&gt;callbacks()-&gt;SampledObjectAlloc;
2597       if (callback != NULL) {
2598         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2599                     jem.jni_jobject(), jem.jni_class(), jem.size());
2600       }
2601     }
2602   }
2603 }
2604 
2605 ////////////////////////////////////////////////////////////////////////////////////////////////
2606 
2607 void JvmtiExport::cleanup_thread(JavaThread* thread) {
2608   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
<span class="line-modified">2609   MutexLocker mu(JvmtiThreadState_lock);</span>
2610 
2611   if (thread-&gt;jvmti_thread_state() != NULL) {
2612     // This has to happen after the thread state is removed, which is
2613     // why it is not in post_thread_end_event like its complement
2614     // Maybe both these functions should be rolled into the posts?
2615     JvmtiEventController::thread_ended(thread);
2616   }
2617 }
2618 
2619 void JvmtiExport::clear_detected_exception(JavaThread* thread) {
2620   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
2621 
2622   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
2623   if (state != NULL) {
2624     state-&gt;clear_exception_state();
2625   }
2626 }
2627 
2628 void JvmtiExport::oops_do(OopClosure* f) {
<span class="line-removed">2629   JvmtiCurrentBreakpoints::oops_do(f);</span>
2630   JvmtiObjectAllocEventCollector::oops_do_for_all_threads(f);
2631 }
2632 
2633 void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
2634   JvmtiTagMap::weak_oops_do(is_alive, f);
2635 }
2636 
<span class="line-removed">2637 void JvmtiExport::gc_epilogue() {</span>
<span class="line-removed">2638   JvmtiCurrentBreakpoints::gc_epilogue();</span>
<span class="line-removed">2639 }</span>
<span class="line-removed">2640 </span>
2641 // Onload raw monitor transition.
2642 void JvmtiExport::transition_pending_onload_raw_monitors() {
2643   JvmtiPendingMonitors::transition_raw_monitors();
2644 }
2645 
2646 ////////////////////////////////////////////////////////////////////////////////////////////////
2647 #if INCLUDE_SERVICES
2648 // Attach is disabled if SERVICES is not included
2649 
2650 // type for the Agent_OnAttach entry point
2651 extern &quot;C&quot; {
2652   typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);
2653 }
2654 
2655 jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,
2656                                      const char *options, outputStream* st) {
2657   char ebuf[1024] = {0};
2658   char buffer[JVM_MAXPATHLEN];
2659   void* library = NULL;
2660   jint result = JNI_ERR;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">  27 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;code/nmethod.hpp&quot;
  30 #include &quot;code/pcDesc.hpp&quot;
  31 #include &quot;code/scopeDesc.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logStream.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  38 #include &quot;memory/universe.hpp&quot;</span>
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  43 #include &quot;prims/jvmtiEventController.hpp&quot;
  44 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;prims/jvmtiImpl.hpp&quot;
  47 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  48 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  49 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  50 #include &quot;prims/jvmtiTagMap.hpp&quot;
  51 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  52 #include &quot;runtime/arguments.hpp&quot;
  53 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/jniHandles.inline.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  60 #include &quot;runtime/os.inline.hpp&quot;
  61 #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-added">  62 #include &quot;runtime/serviceThread.hpp&quot;</span>
  63 #include &quot;runtime/thread.inline.hpp&quot;
  64 #include &quot;runtime/threadSMR.hpp&quot;
  65 #include &quot;runtime/vframe.inline.hpp&quot;
  66 #include &quot;utilities/macros.hpp&quot;
  67 
  68 #ifdef JVMTI_TRACE
  69 #define EVT_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_SENT) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  70 #define EVT_TRIG_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_TRIGGER) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  71 #else
  72 #define EVT_TRIG_TRACE(evt,out)
  73 #define EVT_TRACE(evt,out)
  74 #endif
  75 
  76 ///////////////////////////////////////////////////////////////
  77 //
  78 // JvmtiEventTransition
  79 //
  80 // TO DO --
  81 //  more handle purging
  82 
</pre>
<hr />
<pre>
 288     return _jloader;
 289   }
 290   jobject protection_domain() {
 291     return _protection_domain;
 292   }
 293   jclass class_being_redefined() {
 294     return _class_being_redefined;
 295   }
 296 };
 297 
 298 //////////////////////////////////////////////////////////////////////////////
 299 
 300 int               JvmtiExport::_field_access_count                        = 0;
 301 int               JvmtiExport::_field_modification_count                  = 0;
 302 
 303 bool              JvmtiExport::_can_access_local_variables                = false;
 304 bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
 305 bool              JvmtiExport::_can_modify_any_class                      = false;
 306 bool              JvmtiExport::_can_walk_any_space                        = false;
 307 
<span class="line-modified"> 308 uint64_t          JvmtiExport::_redefinition_count                        = 0;</span>
 309 bool              JvmtiExport::_all_dependencies_are_recorded             = false;
 310 
 311 //
 312 // field access management
 313 //
 314 
 315 // interpreter generator needs the address of the counter
 316 address JvmtiExport::get_field_access_count_addr() {
 317   // We don&#39;t grab a lock because we don&#39;t want to
 318   // serialize field access between all threads. This means that a
 319   // thread on another processor can see the wrong count value and
 320   // may either miss making a needed call into post_field_access()
 321   // or will make an unneeded call into post_field_access(). We pay
 322   // this price to avoid slowing down the VM when we aren&#39;t watching
 323   // field accesses.
 324   // Other access/mutation safe by virtue of being in VM state.
 325   return (address)(&amp;_field_access_count);
 326 }
 327 
 328 //
</pre>
<hr />
<pre>
 367           return JNI_EVERSION;  // unsupported minor version number
 368       }
 369       break;
 370     case 9:
 371       switch (minor) {
 372         case 0:  // version 9.0.&lt;micro&gt; is recognized
 373           break;
 374         default:
 375           return JNI_EVERSION;  // unsupported minor version number
 376       }
 377       break;
 378     case 11:
 379       switch (minor) {
 380         case 0:  // version 11.0.&lt;micro&gt; is recognized
 381           break;
 382         default:
 383           return JNI_EVERSION;  // unsupported minor version number
 384       }
 385       break;
 386     default:
<span class="line-modified"> 387       // Starting from 13 we do not care about minor version anymore</span>
<span class="line-added"> 388       if (major &lt; 13 || major &gt; Abstract_VM_Version::vm_major_version()) {</span>
<span class="line-added"> 389         return JNI_EVERSION;  // unsupported major version number</span>
<span class="line-added"> 390       }</span>
 391   }
 392 
 393   if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
 394     JavaThread* current_thread = JavaThread::current();
 395     // transition code: native to VM
 396     ThreadInVMfromNative __tiv(current_thread);
 397     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
 398     debug_only(VMNativeEntryWrapper __vew;)
 399 
 400     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 401     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 402     return JNI_OK;
 403 
 404   } else if (JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
 405     // not live, no thread to transition
 406     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 407     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 408     return JNI_OK;
 409 
 410   } else {
</pre>
<hr />
<pre>
1186 
1187       ets-&gt;set_breakpoint_posted();
1188       thread-&gt;osthread()-&gt;set_state(old_os_state);
1189     }
1190   }
1191 }
1192 
1193 //////////////////////////////////////////////////////////////////////////////
1194 
1195 bool              JvmtiExport::_can_get_source_debug_extension            = false;
1196 bool              JvmtiExport::_can_maintain_original_method_order        = false;
1197 bool              JvmtiExport::_can_post_interpreter_events               = false;
1198 bool              JvmtiExport::_can_post_on_exceptions                    = false;
1199 bool              JvmtiExport::_can_post_breakpoint                       = false;
1200 bool              JvmtiExport::_can_post_field_access                     = false;
1201 bool              JvmtiExport::_can_post_field_modification               = false;
1202 bool              JvmtiExport::_can_post_method_entry                     = false;
1203 bool              JvmtiExport::_can_post_method_exit                      = false;
1204 bool              JvmtiExport::_can_pop_frame                             = false;
1205 bool              JvmtiExport::_can_force_early_return                    = false;
<span class="line-added">1206 bool              JvmtiExport::_can_get_owned_monitor_info                = false;</span>
1207 
1208 bool              JvmtiExport::_early_vmstart_recorded                    = false;
1209 
1210 bool              JvmtiExport::_should_post_single_step                   = false;
1211 bool              JvmtiExport::_should_post_field_access                  = false;
1212 bool              JvmtiExport::_should_post_field_modification            = false;
1213 bool              JvmtiExport::_should_post_class_load                    = false;
1214 bool              JvmtiExport::_should_post_class_prepare                 = false;
1215 bool              JvmtiExport::_should_post_class_unload                  = false;
1216 bool              JvmtiExport::_should_post_thread_life                   = false;
1217 bool              JvmtiExport::_should_clean_up_heap_objects              = false;
1218 bool              JvmtiExport::_should_post_native_method_bind            = false;
1219 bool              JvmtiExport::_should_post_dynamic_code_generated        = false;
1220 bool              JvmtiExport::_should_post_data_dump                     = false;
1221 bool              JvmtiExport::_should_post_compiled_method_load          = false;
1222 bool              JvmtiExport::_should_post_compiled_method_unload        = false;
1223 bool              JvmtiExport::_should_post_monitor_contended_enter       = false;
1224 bool              JvmtiExport::_should_post_monitor_contended_entered     = false;
1225 bool              JvmtiExport::_should_post_monitor_wait                  = false;
1226 bool              JvmtiExport::_should_post_monitor_waited                = false;
</pre>
<hr />
<pre>
1333       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1334         continue;
1335       }
1336       EVT_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Evt Class Prepare sent %s&quot;,
1337                                             JvmtiTrace::safe_get_thread_name(thread),
1338                                             klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1339       JvmtiClassEventMark jem(thread, klass);
1340       JvmtiJavaThreadEventTransition jet(thread);
1341       jvmtiEventClassPrepare callback = env-&gt;callbacks()-&gt;ClassPrepare;
1342       if (callback != NULL) {
1343         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1344       }
1345     }
1346   }
1347 }
1348 
1349 void JvmtiExport::post_class_unload(Klass* klass) {
1350   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1351     return;
1352   }
<span class="line-modified">1353 </span>
<span class="line-added">1354   // postings to the service thread so that it can perform them in a safe</span>
<span class="line-added">1355   // context and in-order.</span>
<span class="line-added">1356   ResourceMark rm;</span>
<span class="line-added">1357   // JvmtiDeferredEvent copies the string.</span>
<span class="line-added">1358   JvmtiDeferredEvent event = JvmtiDeferredEvent::class_unload_event(klass-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">1359   ServiceThread::enqueue_deferred_event(&amp;event);</span>
<span class="line-added">1360 }</span>
<span class="line-added">1361 </span>
<span class="line-added">1362 </span>
<span class="line-added">1363 void JvmtiExport::post_class_unload_internal(const char* name) {</span>
<span class="line-added">1364   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {</span>
<span class="line-added">1365     return;</span>
<span class="line-added">1366   }</span>
<span class="line-added">1367   assert(Thread::current()-&gt;is_service_thread(), &quot;must be called from ServiceThread&quot;);</span>
<span class="line-added">1368   JavaThread *thread = JavaThread::current();</span>
1369   HandleMark hm(thread);
1370 
1371   EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
1372   if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {









1373 
1374     JvmtiEnvIterator it;
1375     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1376       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1377         continue;
1378       }
1379       if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-modified">1380         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;, name));</span>














1381 
<span class="line-added">1382         JvmtiEventMark jem(thread);</span>
<span class="line-added">1383         JvmtiJavaThreadEventTransition jet(thread);</span>
1384         jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
1385         if (callback != NULL) {
<span class="line-modified">1386           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), name);</span>
1387         }







1388       }
1389     }
1390   }
1391 }
1392 
1393 
1394 void JvmtiExport::post_thread_start(JavaThread *thread) {
1395   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1396     return;
1397   }
1398   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
1399 
1400   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Trg Thread Start event triggered&quot;,
1401                       JvmtiTrace::safe_get_thread_name(thread)));
1402 
1403   // do JVMTI thread initialization (if needed)
1404   JvmtiEventController::thread_started(thread);
1405 
1406   // Do not post thread start event for hidden java thread.
1407   if (JvmtiEventController::is_enabled(JVMTI_EVENT_THREAD_START) &amp;&amp;
</pre>
<hr />
<pre>
1561     return;
1562   }
1563 
1564   // return a flag when a method terminates by throwing an exception
1565   // i.e. if an exception is thrown and it&#39;s not caught by the current method
1566   bool exception_exit = state-&gt;is_exception_detected() &amp;&amp; !state-&gt;is_exception_caught();
1567 
1568 
1569   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1570     Handle result;
1571     jvalue value;
1572     value.j = 0L;
1573 
1574     // if the method hasn&#39;t been popped because of an exception then we populate
1575     // the return_value parameter for the callback. At this point we only have
1576     // the address of a &quot;raw result&quot; and we just call into the interpreter to
1577     // convert this into a jvalue.
1578     if (!exception_exit) {
1579       oop oop_result;
1580       BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
<span class="line-modified">1581       if (is_reference_type(type)) {</span>
1582         result = Handle(thread, oop_result);
1583       }
1584     }
1585 
1586     JvmtiEnvThreadStateIterator it(state);
1587     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1588       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1589         EVT_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Evt Method Exit sent %s.%s&quot;,
1590                                             JvmtiTrace::safe_get_thread_name(thread),
1591                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1592                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1593 
1594         JvmtiEnv *env = ets-&gt;get_env();
1595         JvmtiMethodEventMark jem(thread, mh);
1596         if (result.not_null()) {
1597           value.l = JNIHandles::make_local(thread, result());
1598         }
1599         JvmtiJavaThreadEventTransition jet(thread);
1600         jvmtiEventMethodExit callback = env-&gt;callbacks()-&gt;MethodExit;
1601         if (callback != NULL) {
</pre>
<hr />
<pre>
1965   if (!fd.is_field_modification_watched()) return;
1966 
1967   HandleMark hm(thread);
1968 
1969   Handle h_obj;
1970   if (!is_static) {
1971     // non-static field accessors have an object, but we need a handle
1972     assert(obj != NULL, &quot;non-static needs an object&quot;);
1973     h_obj = Handle(thread, obj);
1974   }
1975   post_field_modification(thread,
1976                           thread-&gt;last_frame().interpreter_frame_method(),
1977                           thread-&gt;last_frame().interpreter_frame_bcp(),
1978                           klass, h_obj, fieldID, sig_type, value);
1979 }
1980 
1981 void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
1982   address location, Klass* field_klass, Handle object, jfieldID field,
1983   char sig_type, jvalue *value) {
1984 
<span class="line-modified">1985   if (sig_type == JVM_SIGNATURE_INT || sig_type == JVM_SIGNATURE_BOOLEAN ||</span>
<span class="line-added">1986       sig_type == JVM_SIGNATURE_BYTE || sig_type == JVM_SIGNATURE_CHAR ||</span>
<span class="line-added">1987       sig_type == JVM_SIGNATURE_SHORT) {</span>
1988     // &#39;I&#39; instructions are used for byte, char, short and int.
1989     // determine which it really is, and convert
1990     fieldDescriptor fd;
1991     bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
1992     // should be found (if not, leave as is)
1993     if (found) {
1994       jint ival = value-&gt;i;
1995       // convert value from int to appropriate type
1996       switch (fd.field_type()) {
1997       case T_BOOLEAN:
<span class="line-modified">1998         sig_type = JVM_SIGNATURE_BOOLEAN;</span>
1999         value-&gt;i = 0; // clear it
2000         value-&gt;z = (jboolean)ival;
2001         break;
2002       case T_BYTE:
<span class="line-modified">2003         sig_type = JVM_SIGNATURE_BYTE;</span>
2004         value-&gt;i = 0; // clear it
2005         value-&gt;b = (jbyte)ival;
2006         break;
2007       case T_CHAR:
<span class="line-modified">2008         sig_type = JVM_SIGNATURE_CHAR;</span>
2009         value-&gt;i = 0; // clear it
2010         value-&gt;c = (jchar)ival;
2011         break;
2012       case T_SHORT:
<span class="line-modified">2013         sig_type = JVM_SIGNATURE_SHORT;</span>
2014         value-&gt;i = 0; // clear it
2015         value-&gt;s = (jshort)ival;
2016         break;
2017       case T_INT:
2018         // nothing to do
2019         break;
2020       default:
2021         // this is an integer instruction, should be one of above
2022         ShouldNotReachHere();
2023         break;
2024       }
2025     }
2026   }
2027 
<span class="line-modified">2028   assert(sig_type != JVM_SIGNATURE_ARRAY, &quot;array should have sig_type == &#39;L&#39;&quot;);</span>
2029   bool handle_created = false;
2030 
2031   // convert oop to JNI handle.
<span class="line-modified">2032   if (sig_type == JVM_SIGNATURE_CLASS) {</span>
2033     handle_created = true;
2034     value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
2035   }
2036 
2037   post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
2038 
2039   // Destroy the JNI handle allocated above.
2040   if (handle_created) {
2041     JNIHandles::destroy_local(value-&gt;l);
2042   }
2043 }
2044 
2045 void JvmtiExport::post_field_modification(JavaThread *thread, Method* method,
2046   address location, Klass* field_klass, Handle object, jfieldID field,
2047   char sig_type, jvalue *value_ptr) {
2048 
2049   HandleMark hm(thread);
2050   methodHandle mh(thread, method);
2051 
2052   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
</pre>
<hr />
<pre>
2126    record-&gt;numpcs++;
2127   }
2128   record-&gt;pcinfo = (PCStackInfo*)(NEW_RESOURCE_ARRAY(PCStackInfo, record-&gt;numpcs));
2129   int scope = 0;
2130   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2131     if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2132     void* pc_address = (void*)p-&gt;real_pc(nm);
2133     assert(pc_address != NULL, &quot;pc_address must be non-null&quot;);
2134     record-&gt;pcinfo[scope].pc = pc_address;
2135     numstackframes=0;
2136     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2137       numstackframes++;
2138     }
2139     assert(numstackframes != 0, &quot;numstackframes must be nonzero.&quot;);
2140     record-&gt;pcinfo[scope].methods = (jmethodID *)NEW_RESOURCE_ARRAY(jmethodID, numstackframes);
2141     record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
2142     record-&gt;pcinfo[scope].numstackframes = numstackframes;
2143     int stackframe = 0;
2144     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2145       // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
<span class="line-modified">2146       guarantee(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);</span>
2147       record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
2148       record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
2149       stackframe++;
2150     }
2151     scope++;
2152   }
2153   return record;
2154 }
2155 
2156 void JvmtiExport::post_compiled_method_load(nmethod *nm) {
<span class="line-added">2157   guarantee(!nm-&gt;is_unloading(), &quot;nmethod isn&#39;t unloaded or unloading&quot;);</span>
2158   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
2159     return;
2160   }
2161   JavaThread* thread = JavaThread::current();
2162 
2163   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,
2164                  (&quot;[%s] method compile load event triggered&quot;,
2165                  JvmtiTrace::safe_get_thread_name(thread)));
2166 
2167   JvmtiEnvIterator it;
2168   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">2169     post_compiled_method_load(env, nm);</span>























2170   }
2171 }
2172 

2173 // post a COMPILED_METHOD_LOAD event for a given environment
<span class="line-modified">2174 void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, nmethod *nm) {</span>
<span class="line-modified">2175   if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL || !env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
<span class="line-modified">2176     return;</span>
<span class="line-modified">2177   }</span>
<span class="line-modified">2178   jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-added">2179   if (callback == NULL) {</span>
2180     return;
2181   }
2182   JavaThread* thread = JavaThread::current();




2183 
<span class="line-modified">2184   EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-modified">2185            (&quot;[%s] method compile load event sent %s.%s  &quot;,</span>
<span class="line-modified">2186             JvmtiTrace::safe_get_thread_name(thread),</span>
<span class="line-added">2187             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),</span>
<span class="line-added">2188             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));</span>
<span class="line-added">2189   ResourceMark rm(thread);</span>
<span class="line-added">2190   HandleMark hm(thread);</span>
2191 
<span class="line-modified">2192   // Add inlining information</span>
<span class="line-modified">2193   jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);</span>
<span class="line-modified">2194   // Pass inlining information through the void pointer</span>
<span class="line-modified">2195   JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);</span>
<span class="line-modified">2196   JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-modified">2197   (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),</span>
<span class="line-modified">2198               jem.code_size(), jem.code_data(), jem.map_length(),</span>
<span class="line-modified">2199               jem.map(), jem.compile_info());</span>

2200 }
2201 
2202 void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
2203   assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
2204 
2205   JavaThread* thread = JavaThread::current();
2206   // In theory everyone coming thru here is in_vm but we need to be certain
2207   // because a callee will do a vm-&gt;native transition
2208   ThreadInVMfromUnknown __tiv;
2209 
2210   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2211                  (&quot;[%s] method dynamic code generated event triggered&quot;,
2212                  JvmtiTrace::safe_get_thread_name(thread)));
2213   JvmtiEnvIterator it;
2214   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2215     if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2216       EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2217                 (&quot;[%s] dynamic code generated event sent for %s&quot;,
2218                 JvmtiTrace::safe_get_thread_name(thread), name));
2219       JvmtiEventMark jem(thread);
2220       JvmtiJavaThreadEventTransition jet(thread);
2221       jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2222       jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2223       if (callback != NULL) {
2224         (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2225       }
2226     }
2227   }
2228 }
2229 
2230 void JvmtiExport::post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) {
2231   jvmtiPhase phase = JvmtiEnv::get_phase();
2232   if (phase == JVMTI_PHASE_PRIMORDIAL || phase == JVMTI_PHASE_START) {
2233     post_dynamic_code_generated_internal(name, code_begin, code_end);
2234   } else {
2235     // It may not be safe to post the event from this thread.  Defer all
2236     // postings to the service thread so that it can perform them in a safe
2237     // context and in-order.

2238     JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
2239         name, code_begin, code_end);
<span class="line-modified">2240     ServiceThread::enqueue_deferred_event(&amp;event);</span>
2241   }
2242 }
2243 
2244 
2245 // post a DYNAMIC_CODE_GENERATED event for a given environment
2246 // used by GenerateEvents
2247 void JvmtiExport::post_dynamic_code_generated(JvmtiEnv* env, const char *name,
2248                                               const void *code_begin, const void *code_end)
2249 {
2250   JavaThread* thread = JavaThread::current();
2251   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2252                  (&quot;[%s] dynamic code generated event triggered (by GenerateEvents)&quot;,
2253                   JvmtiTrace::safe_get_thread_name(thread)));
2254   if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2255     EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2256               (&quot;[%s] dynamic code generated event sent for %s&quot;,
2257                JvmtiTrace::safe_get_thread_name(thread), name));
2258     JvmtiEventMark jem(thread);
2259     JvmtiJavaThreadEventTransition jet(thread);
2260     jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2261     jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2262     if (callback != NULL) {
2263       (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2264     }
2265   }
2266 }
2267 
2268 // post a DynamicCodeGenerated event while holding locks in the VM.
2269 void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
2270                                                                   address code_begin, address code_end)
2271 {
2272   // register the stub with the current dynamic code event collector
<span class="line-modified">2273   // Cannot take safepoint here so do not use state_for to get</span>
<span class="line-added">2274   // jvmti thread state.</span>
<span class="line-added">2275   JvmtiThreadState* state = JavaThread::current()-&gt;jvmti_thread_state();</span>
2276   // state can only be NULL if the current thread is exiting which
2277   // should not happen since we&#39;re trying to post an event
2278   guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
2279   JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
2280   guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
2281   collector-&gt;register_stub(name, code_begin, code_end);
2282 }
2283 
2284 // Collect all the vm internally allocated objects which are visible to java world
2285 void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
2286   Thread* thread = Thread::current_or_null();
2287   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2288     // Can not take safepoint here.
2289     NoSafepointVerifier no_sfpt;
<span class="line-modified">2290     // Cannot take safepoint here so do not use state_for to get</span>
2291     // jvmti thread state.
2292     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2293     if (state != NULL) {
2294       // state is non NULL when VMObjectAllocEventCollector is enabled.
2295       JvmtiVMObjectAllocEventCollector *collector;
2296       collector = state-&gt;get_vm_object_alloc_event_collector();
2297       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2298         // Don&#39;t record classes as these will be notified via the ClassLoad
2299         // event.
2300         if (obj-&gt;klass() != SystemDictionary::Class_klass()) {
2301           collector-&gt;record_allocation(obj);
2302         }
2303       }
2304     }
2305   }
2306 }
2307 
2308 // Collect all the sampled allocated objects.
2309 void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
2310   Thread* thread = Thread::current_or_null();
2311   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2312     // Can not take safepoint here.
2313     NoSafepointVerifier no_sfpt;
<span class="line-modified">2314     // Cannot take safepoint here so do not use state_for to get</span>
2315     // jvmti thread state.
2316     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2317     if (state != NULL) {
2318       // state is non NULL when SampledObjectAllocEventCollector is enabled.
2319       JvmtiSampledObjectAllocEventCollector *collector;
2320       collector = state-&gt;get_sampled_object_alloc_event_collector();
2321 
2322       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2323         collector-&gt;record_allocation(obj);
2324       }
2325     }
2326   }
2327 }
2328 
2329 void JvmtiExport::post_garbage_collection_finish() {
2330   Thread *thread = Thread::current(); // this event is posted from VM-Thread.
2331   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2332                  (&quot;[%s] garbage collection finish event triggered&quot;,
2333                   JvmtiTrace::safe_get_thread_name(thread)));
2334   JvmtiEnvIterator it;
</pre>
<hr />
<pre>
2563                 (&quot;[%s] Evt sampled object alloc sent %s&quot;,
2564                  JvmtiTrace::safe_get_thread_name(thread),
2565                  object == NULL ? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2566 
2567       JvmtiEnv *env = ets-&gt;get_env();
2568       JvmtiObjectAllocEventMark jem(thread, h());
2569       JvmtiJavaThreadEventTransition jet(thread);
2570       jvmtiEventSampledObjectAlloc callback = env-&gt;callbacks()-&gt;SampledObjectAlloc;
2571       if (callback != NULL) {
2572         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2573                     jem.jni_jobject(), jem.jni_class(), jem.size());
2574       }
2575     }
2576   }
2577 }
2578 
2579 ////////////////////////////////////////////////////////////////////////////////////////////////
2580 
2581 void JvmtiExport::cleanup_thread(JavaThread* thread) {
2582   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
<span class="line-modified">2583   MutexLocker mu(thread, JvmtiThreadState_lock);</span>
2584 
2585   if (thread-&gt;jvmti_thread_state() != NULL) {
2586     // This has to happen after the thread state is removed, which is
2587     // why it is not in post_thread_end_event like its complement
2588     // Maybe both these functions should be rolled into the posts?
2589     JvmtiEventController::thread_ended(thread);
2590   }
2591 }
2592 
2593 void JvmtiExport::clear_detected_exception(JavaThread* thread) {
2594   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
2595 
2596   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
2597   if (state != NULL) {
2598     state-&gt;clear_exception_state();
2599   }
2600 }
2601 
2602 void JvmtiExport::oops_do(OopClosure* f) {

2603   JvmtiObjectAllocEventCollector::oops_do_for_all_threads(f);
2604 }
2605 
2606 void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
2607   JvmtiTagMap::weak_oops_do(is_alive, f);
2608 }
2609 




2610 // Onload raw monitor transition.
2611 void JvmtiExport::transition_pending_onload_raw_monitors() {
2612   JvmtiPendingMonitors::transition_raw_monitors();
2613 }
2614 
2615 ////////////////////////////////////////////////////////////////////////////////////////////////
2616 #if INCLUDE_SERVICES
2617 // Attach is disabled if SERVICES is not included
2618 
2619 // type for the Agent_OnAttach entry point
2620 extern &quot;C&quot; {
2621   typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);
2622 }
2623 
2624 jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,
2625                                      const char *options, outputStream* st) {
2626   char ebuf[1024] = {0};
2627   char buffer[JVM_MAXPATHLEN];
2628   void* library = NULL;
2629   jint result = JNI_ERR;
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEventController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
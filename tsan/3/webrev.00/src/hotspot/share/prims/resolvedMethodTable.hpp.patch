diff a/src/hotspot/share/prims/resolvedMethodTable.hpp b/src/hotspot/share/prims/resolvedMethodTable.hpp
--- a/src/hotspot/share/prims/resolvedMethodTable.hpp
+++ b/src/hotspot/share/prims/resolvedMethodTable.hpp
@@ -23,91 +23,64 @@
  */
 
 #ifndef SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
 #define SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP
 
+#include "memory/allocation.hpp"
 #include "oops/symbol.hpp"
 #include "oops/weakHandle.hpp"
-#include "utilities/hashtable.hpp"
 
-// Hashtable to record Method* used in ResolvedMethods, via. ResolvedMethod oops.
-// This is needed for redefinition to replace Method* with redefined versions.
+class ResolvedMethodTable;
+class ResolvedMethodTableConfig;
 
-// Entry in a ResolvedMethodTable, mapping a ClassLoaderWeakHandle for a single oop of
-// java_lang_invoke_ResolvedMethodName which holds JVM Method* in vmtarget.
+class ResolvedMethodTable : public AllStatic {
+  static volatile bool            _has_work;
 
-class ResolvedMethodEntry : public HashtableEntry<ClassLoaderWeakHandle, mtClass> {
- public:
-  ResolvedMethodEntry* next() const {
-    return (ResolvedMethodEntry*)HashtableEntry<ClassLoaderWeakHandle, mtClass>::next();
-  }
-
-  ResolvedMethodEntry** next_addr() {
-    return (ResolvedMethodEntry**)HashtableEntry<ClassLoaderWeakHandle, mtClass>::next_addr();
-  }
-
-  oop object();
-  oop object_no_keepalive();
-
-  void print_on(outputStream* st) const;
-};
-
-class ResolvedMethodTable : public Hashtable<ClassLoaderWeakHandle, mtClass> {
-  enum Constants {
-    _table_size  = 1007
-  };
-
-  static int _total_oops_removed;
-
-  static bool _dead_entries;
-
-  static ResolvedMethodTable* _the_table;
-private:
-  ResolvedMethodEntry* bucket(int i) {
-    return (ResolvedMethodEntry*) Hashtable<ClassLoaderWeakHandle, mtClass>::bucket(i);
-  }
+public:
+  // Initialization
+  static void create_table();
 
-  ResolvedMethodEntry** bucket_addr(int i) {
-    return (ResolvedMethodEntry**) Hashtable<ClassLoaderWeakHandle, mtClass>::bucket_addr(i);
-  }
+  static size_t table_size();
 
-  unsigned int compute_hash(Method* method);
+  // Lookup and inserts
+  static oop find_method(const Method* method);
+  static oop add_method(const Method* method, Handle rmethod_name);
 
-  // need not be locked; no state change
-  oop lookup(int index, unsigned int hash, Method* method);
-  oop lookup(Method* method);
+  // Callbacks
+  static void item_added();
+  static void item_removed();
 
-  // must be done under ResolvedMethodTable_lock
-  oop basic_add(Method* method, Handle rmethod_name);
+  // Cleaning
+  static bool has_work() { return _has_work; }
 
-public:
-  ResolvedMethodTable();
+  // Cleaning and table management
 
-  static void create_table() {
-    assert(_the_table == NULL, "One symbol table allowed.");
-    _the_table = new ResolvedMethodTable();
-  }
+  static double get_load_factor();
+  static double get_dead_factor();
 
-  // Called from java_lang_invoke_ResolvedMethodName
-  static oop find_method(Method* method);
-  static oop add_method(const methodHandle& method, Handle rmethod_name);
+  static void check_concurrent_work();
+  static void trigger_concurrent_work();
+  static void do_concurrent_work(JavaThread* jt);
 
-  static bool has_work() { return _dead_entries; }
-  static void trigger_cleanup();
+  static void grow(JavaThread* jt);
+  static void clean_dead_entries(JavaThread* jt);
 
-  static int removed_entries_count() { return _total_oops_removed; };
+  // GC Notification
 
-#if INCLUDE_JVMTI
-  // It is called at safepoint only for RedefineClasses
-  static void adjust_method_entries(bool * trace_name_printed);
-#endif // INCLUDE_JVMTI
+  // Must be called before a parallel walk where objects might die.
+  static void reset_dead_counter();
+  // After the parallel walk this method must be called to trigger
+  // cleaning. Note it might trigger a resize instead.
+  static void finish_dead_counter();
+  // If GC uses ParState directly it should add the number of cleared
+  // entries to this method.
+  static void inc_dead_counter(size_t ndead);
 
-  // Cleanup cleared entries
-  static void unlink();
+  // JVMTI Support - It is called at safepoint only for RedefineClasses
+  JVMTI_ONLY(static void adjust_method_entries(bool * trace_name_printed);)
 
-#ifndef PRODUCT
-  void print();
-#endif
-  void verify();
+  // Debugging
+  static size_t items_count();
+  static void verify();
 };
 
 #endif // SHARE_PRIMS_RESOLVEDMETHODTABLE_HPP

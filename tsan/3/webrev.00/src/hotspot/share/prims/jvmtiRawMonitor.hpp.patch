diff a/src/hotspot/share/prims/jvmtiRawMonitor.hpp b/src/hotspot/share/prims/jvmtiRawMonitor.hpp
--- a/src/hotspot/share/prims/jvmtiRawMonitor.hpp
+++ b/src/hotspot/share/prims/jvmtiRawMonitor.hpp
@@ -23,78 +23,122 @@
  */
 
 #ifndef SHARE_PRIMS_JVMTIRAWMONITOR_HPP
 #define SHARE_PRIMS_JVMTIRAWMONITOR_HPP
 
-#include "runtime/objectMonitor.hpp"
+#include "memory/allocation.hpp"
+#include "runtime/park.hpp"
 #include "utilities/growableArray.hpp"
 
 //
 // class JvmtiRawMonitor
 //
 // Used by JVMTI methods: All RawMonitor methods (CreateRawMonitor, EnterRawMonitor, etc.)
 //
-// Wrapper for ObjectMonitor class that saves the Monitor's name
+// A simplified version of the ObjectMonitor code.
 //
 
-class JvmtiRawMonitor : public ObjectMonitor  {
-private:
-  int           _magic;
-  char *        _name;
+class JvmtiRawMonitor : public CHeapObj<mtSynchronizer>  {
+
+  // Helper class to allow Threads to be linked into queues.
+  // This is a stripped down version of ObjectWaiter.
+  class QNode : public StackObj {
+    friend class JvmtiRawMonitor;
+    enum TStates { TS_READY, TS_RUN, TS_WAIT, TS_ENTER };
+    QNode* volatile _next;
+    QNode* volatile _prev;
+    ParkEvent* _event;
+    volatile int _notified;
+    volatile TStates _t_state;
+
+    QNode(Thread* thread);
+  };
+
+  Thread* volatile _owner;      // pointer to owning thread
+  volatile int _recursions;     // recursion count, 0 for first entry
+  QNode* volatile _entry_list;  // Threads blocked on entry or reentry.
+                                // The list is actually composed of nodes,
+                                // acting as proxies for Threads.
+  QNode* volatile _wait_set;    // Threads wait()ing on the monitor
+  volatile jint _waiters;       // number of waiting threads
+  int _magic;
+  char* _name;
   // JVMTI_RM_MAGIC is set in contructor and unset in destructor.
   enum { JVMTI_RM_MAGIC = (int)(('T' << 24) | ('I' << 16) | ('R' << 8) | 'M') };
 
-  int       SimpleEnter (Thread * Self) ;
-  int       SimpleExit  (Thread * Self) ;
-  int       SimpleWait  (Thread * Self, jlong millis) ;
-  int       SimpleNotify (Thread * Self, bool All) ;
+  // Helpers for queue management isolation
+  void enqueue_waiter(QNode& node);
+  void dequeue_waiter(QNode& node);
 
-public:
-  JvmtiRawMonitor(const char *name);
+  // Mostly low-level implementation routines
+  void simple_enter(Thread* self);
+  void simple_exit(Thread* self);
+  int simple_wait(Thread* self, jlong millis);
+  void simple_notify(Thread* self, bool all);
+
+ public:
+
+  // return codes
+  enum {
+    M_OK,                    // no error
+    M_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException
+    M_INTERRUPTED            // Thread.interrupt()
+  };
+
+  // Non-aborting operator new
+  void* operator new(size_t size) throw() {
+    return CHeapObj::operator new(size, std::nothrow);
+  }
+
+  JvmtiRawMonitor(const char* name);
   ~JvmtiRawMonitor();
-  int       raw_enter(TRAPS);
-  int       raw_exit(TRAPS);
-  int       raw_wait(jlong millis, bool interruptable, TRAPS);
-  int       raw_notify(TRAPS);
-  int       raw_notifyAll(TRAPS);
-  int            magic()   { return _magic;  }
-  const char *get_name()   { return _name; }
-  bool        is_valid();
+
+  Thread* owner() const { return _owner; }
+  void set_owner(Thread* owner) { _owner = owner; }
+  int recursions() const { return _recursions; }
+  void raw_enter(Thread* self);
+  int raw_exit(Thread* self);
+  int raw_wait(jlong millis, Thread* self);
+  int raw_notify(Thread* self);
+  int raw_notifyAll(Thread* self);
+  int magic() const { return _magic; }
+  const char* get_name() const { return _name; }
+  bool is_valid();
 };
 
 // Onload pending raw monitors
 // Class is used to cache onload or onstart monitor enter
 // which will transition into real monitor when
 // VM is fully initialized.
 class JvmtiPendingMonitors : public AllStatic {
 
-private:
-  static GrowableArray<JvmtiRawMonitor*> *_monitors; // Cache raw monitor enter
+ private:
+  static GrowableArray<JvmtiRawMonitor*>* _monitors; // Cache raw monitor enter
 
   inline static GrowableArray<JvmtiRawMonitor*>* monitors() { return _monitors; }
 
   static void dispose() {
     delete monitors();
   }
 
-public:
-  static void enter(JvmtiRawMonitor *monitor) {
+ public:
+  static void enter(JvmtiRawMonitor* monitor) {
     monitors()->append(monitor);
   }
 
   static int count() {
     return monitors()->length();
   }
 
-  static void destroy(JvmtiRawMonitor *monitor) {
+  static void destroy(JvmtiRawMonitor* monitor) {
     while (monitors()->contains(monitor)) {
       monitors()->remove(monitor);
     }
   }
 
   // Return false if monitor is not found in the list.
-  static bool exit(JvmtiRawMonitor *monitor) {
+  static bool exit(JvmtiRawMonitor* monitor) {
     if (monitors()->contains(monitor)) {
       monitors()->remove(monitor);
       return true;
     } else {
       return false;

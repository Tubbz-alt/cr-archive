<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/methodComparator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;oops/constantPool.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;prims/methodComparator.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 BytecodeStream *MethodComparator::_s_old;
 36 BytecodeStream *MethodComparator::_s_new;
 37 ConstantPool* MethodComparator::_old_cp;
 38 ConstantPool* MethodComparator::_new_cp;
 39 
 40 bool MethodComparator::methods_EMCP(Method* old_method, Method* new_method) {
 41   if (old_method-&gt;code_size() != new_method-&gt;code_size())
 42     return false;
 43   if (check_stack_and_locals_size(old_method, new_method) != 0) {
 44     if (log_is_enabled(Debug, redefine, class, methodcomparator)) {
 45       ResourceMark rm;
 46       log_debug(redefine, class, methodcomparator)
 47         (&quot;Methods %s non-comparable with diagnosis %d&quot;,
 48          old_method-&gt;name()-&gt;as_C_string(), check_stack_and_locals_size(old_method, new_method));
 49     }
 50     return false;
 51   }
 52 
 53   _old_cp = old_method-&gt;constants();
 54   _new_cp = new_method-&gt;constants();
<a name="1" id="anc1"></a><span class="line-modified"> 55   BytecodeStream s_old(old_method);</span>
<span class="line-modified"> 56   BytecodeStream s_new(new_method);</span>

 57   _s_old = &amp;s_old;
 58   _s_new = &amp;s_new;
 59   Bytecodes::Code c_old, c_new;
 60 
 61   while ((c_old = s_old.next()) &gt;= 0) {
 62     if ((c_new = s_new.next()) &lt; 0 || c_old != c_new)
 63       return false;
 64 
 65     if (! args_same(c_old, c_new))
 66       return false;
 67   }
 68   return true;
 69 }
 70 
 71 bool MethodComparator::args_same(Bytecodes::Code c_old, Bytecodes::Code c_new) {
 72   // BytecodeStream returns the correct standard Java bytecodes for various &quot;fast&quot;
 73   // bytecode versions, so we don&#39;t have to bother about them here..
 74   switch (c_old) {
 75   case Bytecodes::_new            : // fall through
 76   case Bytecodes::_anewarray      : // fall through
 77   case Bytecodes::_multianewarray : // fall through
 78   case Bytecodes::_checkcast      : // fall through
 79   case Bytecodes::_instanceof     : {
 80     u2 cpi_old = _s_old-&gt;get_index_u2();
 81     u2 cpi_new = _s_new-&gt;get_index_u2();
 82     if ((_old_cp-&gt;klass_at_noresolve(cpi_old) != _new_cp-&gt;klass_at_noresolve(cpi_new)))
 83         return false;
 84     if (c_old == Bytecodes::_multianewarray &amp;&amp;
 85         *(jbyte*)(_s_old-&gt;bcp() + 3) != *(jbyte*)(_s_new-&gt;bcp() + 3))
 86       return false;
 87     break;
 88   }
 89 
 90   case Bytecodes::_getstatic       : // fall through
 91   case Bytecodes::_putstatic       : // fall through
 92   case Bytecodes::_getfield        : // fall through
 93   case Bytecodes::_putfield        : // fall through
 94   case Bytecodes::_invokevirtual   : // fall through
 95   case Bytecodes::_invokespecial   : // fall through
 96   case Bytecodes::_invokestatic    : // fall through
 97   case Bytecodes::_invokeinterface : {
 98     int cpci_old = _s_old-&gt;get_index_u2_cpcache();
 99     int cpci_new = _s_new-&gt;get_index_u2_cpcache();
100     // Check if the names of classes, field/method names and signatures at these indexes
101     // are the same. Indices which are really into constantpool cache (rather than constant
102     // pool itself) are accepted by the constantpool query routines below.
103     if ((_old_cp-&gt;klass_ref_at_noresolve(cpci_old) != _new_cp-&gt;klass_ref_at_noresolve(cpci_new)) ||
104         (_old_cp-&gt;name_ref_at(cpci_old) != _new_cp-&gt;name_ref_at(cpci_new)) ||
105         (_old_cp-&gt;signature_ref_at(cpci_old) != _new_cp-&gt;signature_ref_at(cpci_new)))
106       return false;
107     break;
108   }
109   case Bytecodes::_invokedynamic: {
110     int cpci_old = _s_old-&gt;get_index_u4();
111     int cpci_new = _s_new-&gt;get_index_u4();
112 
113     // Check if the names of classes, field/method names and signatures at these indexes
114     // are the same. Indices which are really into constantpool cache (rather than constant
115     // pool itself) are accepted by the constantpool query routines below.
116     if ((_old_cp-&gt;name_ref_at(cpci_old) != _new_cp-&gt;name_ref_at(cpci_new)) ||
117         (_old_cp-&gt;signature_ref_at(cpci_old) != _new_cp-&gt;signature_ref_at(cpci_new)))
118       return false;
119 
120     // Translate object indexes to constant pool cache indexes.
121     cpci_old = _old_cp-&gt;invokedynamic_cp_cache_index(cpci_old);
122     cpci_new = _new_cp-&gt;invokedynamic_cp_cache_index(cpci_new);
123 
124     int cpi_old = _old_cp-&gt;cache()-&gt;entry_at(cpci_old)-&gt;constant_pool_index();
125     int cpi_new = _new_cp-&gt;cache()-&gt;entry_at(cpci_new)-&gt;constant_pool_index();
126     int bsm_old = _old_cp-&gt;bootstrap_method_ref_index_at(cpi_old);
127     int bsm_new = _new_cp-&gt;bootstrap_method_ref_index_at(cpi_new);
128     if (!pool_constants_same(bsm_old, bsm_new))
129       return false;
130     int cnt_old = _old_cp-&gt;bootstrap_argument_count_at(cpi_old);
131     int cnt_new = _new_cp-&gt;bootstrap_argument_count_at(cpi_new);
132     if (cnt_old != cnt_new)
133       return false;
134     for (int arg_i = 0; arg_i &lt; cnt_old; arg_i++) {
135       int idx_old = _old_cp-&gt;bootstrap_argument_index_at(cpi_old, arg_i);
136       int idx_new = _new_cp-&gt;bootstrap_argument_index_at(cpi_new, arg_i);
137       if (!pool_constants_same(idx_old, idx_new))
138         return false;
139     }
140     break;
141   }
142 
143   case Bytecodes::_ldc   : // fall through
144   case Bytecodes::_ldc_w : {
145     Bytecode_loadconstant ldc_old(_s_old-&gt;method(), _s_old-&gt;bci());
146     Bytecode_loadconstant ldc_new(_s_new-&gt;method(), _s_new-&gt;bci());
147     int cpi_old = ldc_old.pool_index();
148     int cpi_new = ldc_new.pool_index();
149     if (!pool_constants_same(cpi_old, cpi_new))
150       return false;
151     break;
152   }
153 
154   case Bytecodes::_ldc2_w : {
155     u2 cpi_old = _s_old-&gt;get_index_u2();
156     u2 cpi_new = _s_new-&gt;get_index_u2();
157     constantTag tag_old = _old_cp-&gt;tag_at(cpi_old);
158     constantTag tag_new = _new_cp-&gt;tag_at(cpi_new);
159     if (tag_old.value() != tag_new.value())
160       return false;
161     if (tag_old.is_long()) {
162       if (_old_cp-&gt;long_at(cpi_old) != _new_cp-&gt;long_at(cpi_new))
163         return false;
164     } else {
165       // Use jlong_cast to compare the bits rather than numerical values.
166       // This makes a difference for NaN constants.
167       if (jlong_cast(_old_cp-&gt;double_at(cpi_old)) != jlong_cast(_new_cp-&gt;double_at(cpi_new)))
168         return false;
169     }
170     break;
171   }
172 
173   case Bytecodes::_bipush :
174     if (_s_old-&gt;bcp()[1] != _s_new-&gt;bcp()[1])
175       return false;
176     break;
177 
178   case Bytecodes::_sipush    :
179     if (_s_old-&gt;get_index_u2() != _s_new-&gt;get_index_u2())
180       return false;
181     break;
182 
183   case Bytecodes::_aload  : // fall through
184   case Bytecodes::_astore : // fall through
185   case Bytecodes::_dload  : // fall through
186   case Bytecodes::_dstore : // fall through
187   case Bytecodes::_fload  : // fall through
188   case Bytecodes::_fstore : // fall through
189   case Bytecodes::_iload  : // fall through
190   case Bytecodes::_istore : // fall through
191   case Bytecodes::_lload  : // fall through
192   case Bytecodes::_lstore : // fall through
193   case Bytecodes::_ret    :
194     if (_s_old-&gt;is_wide() != _s_new-&gt;is_wide())
195       return false;
196     if (_s_old-&gt;get_index() != _s_new-&gt;get_index())
197       return false;
198     break;
199 
200   case Bytecodes::_goto      : // fall through
201   case Bytecodes::_if_acmpeq : // fall through
202   case Bytecodes::_if_acmpne : // fall through
203   case Bytecodes::_if_icmpeq : // fall through
204   case Bytecodes::_if_icmpne : // fall through
205   case Bytecodes::_if_icmplt : // fall through
206   case Bytecodes::_if_icmpge : // fall through
207   case Bytecodes::_if_icmpgt : // fall through
208   case Bytecodes::_if_icmple : // fall through
209   case Bytecodes::_ifeq      : // fall through
210   case Bytecodes::_ifne      : // fall through
211   case Bytecodes::_iflt      : // fall through
212   case Bytecodes::_ifge      : // fall through
213   case Bytecodes::_ifgt      : // fall through
214   case Bytecodes::_ifle      : // fall through
215   case Bytecodes::_ifnonnull : // fall through
216   case Bytecodes::_ifnull    : // fall through
217   case Bytecodes::_jsr       : {
218     int old_ofs = _s_old-&gt;bytecode().get_offset_s2(c_old);
219     int new_ofs = _s_new-&gt;bytecode().get_offset_s2(c_new);
220     if (old_ofs != new_ofs)
221       return false;
222     break;
223   }
224 
225   case Bytecodes::_iinc :
226     if (_s_old-&gt;is_wide() != _s_new-&gt;is_wide())
227       return false;
228     if (! _s_old-&gt;is_wide()) {
229       // We could use get_index_u1 and get_constant_u1, but it&#39;s simpler to grab both bytes at once:
230       if (Bytes::get_Java_u2(_s_old-&gt;bcp() + 1) != Bytes::get_Java_u2(_s_new-&gt;bcp() + 1))
231         return false;
232     } else {
233       // We could use get_index_u2 and get_constant_u2, but it&#39;s simpler to grab all four bytes at once:
234       if (Bytes::get_Java_u4(_s_old-&gt;bcp() + 1) != Bytes::get_Java_u4(_s_new-&gt;bcp() + 1))
235         return false;
236     }
237     break;
238 
239   case Bytecodes::_goto_w : // fall through
240   case Bytecodes::_jsr_w  : {
241     int old_ofs = _s_old-&gt;bytecode().get_offset_s4(c_old);
242     int new_ofs = _s_new-&gt;bytecode().get_offset_s4(c_new);
243     if (old_ofs != new_ofs)
244       return false;
245     break;
246   }
247 
248   case Bytecodes::_lookupswitch : // fall through
249   case Bytecodes::_tableswitch  : {
250     int len_old = _s_old-&gt;instruction_size();
251     int len_new = _s_new-&gt;instruction_size();
252     if (len_old != len_new)
253       return false;
254     if (memcmp(_s_old-&gt;bcp(), _s_new-&gt;bcp(), len_old) != 0)
255       return false;
256     break;
257   }
258 
259   default:
260     break;
261   }
262 
263   return true;
264 }
265 
266 bool MethodComparator::pool_constants_same(int cpi_old, int cpi_new) {
267   constantTag tag_old = _old_cp-&gt;tag_at(cpi_old);
268   constantTag tag_new = _new_cp-&gt;tag_at(cpi_new);
269   if (tag_old.is_int() || tag_old.is_float()) {
270     if (tag_old.value() != tag_new.value())
271       return false;
272     if (tag_old.is_int()) {
273       if (_old_cp-&gt;int_at(cpi_old) != _new_cp-&gt;int_at(cpi_new))
274         return false;
275     } else {
276       // Use jint_cast to compare the bits rather than numerical values.
277       // This makes a difference for NaN constants.
278       if (jint_cast(_old_cp-&gt;float_at(cpi_old)) != jint_cast(_new_cp-&gt;float_at(cpi_new)))
279         return false;
280     }
281   } else if (tag_old.is_string() &amp;&amp; tag_new.is_string()) {
282     if (strcmp(_old_cp-&gt;string_at_noresolve(cpi_old),
283                _new_cp-&gt;string_at_noresolve(cpi_new)) != 0)
284       return false;
285     if (_old_cp-&gt;is_pseudo_string_at(cpi_old) || _new_cp-&gt;is_pseudo_string_at(cpi_new))
286       return (_old_cp-&gt;is_pseudo_string_at(cpi_old) == _new_cp-&gt;is_pseudo_string_at(cpi_new));
287   } else if (tag_old.is_klass() || tag_old.is_unresolved_klass()) {
288     // tag_old should be klass - 4881222
289     if (! (tag_new.is_unresolved_klass() || tag_new.is_klass()))
290       return false;
291     if (_old_cp-&gt;klass_at_noresolve(cpi_old) !=
292         _new_cp-&gt;klass_at_noresolve(cpi_new))
293       return false;
294   } else if (tag_old.is_method_type() &amp;&amp; tag_new.is_method_type()) {
295     int mti_old = _old_cp-&gt;method_type_index_at(cpi_old);
296     int mti_new = _new_cp-&gt;method_type_index_at(cpi_new);
297     if ((_old_cp-&gt;symbol_at(mti_old) != _new_cp-&gt;symbol_at(mti_new)))
298       return false;
299   } else if (tag_old.is_method_handle() &amp;&amp; tag_new.is_method_handle()) {
300     if (_old_cp-&gt;method_handle_ref_kind_at(cpi_old) !=
301         _new_cp-&gt;method_handle_ref_kind_at(cpi_new))
302       return false;
303     int mhi_old = _old_cp-&gt;method_handle_index_at(cpi_old);
304     int mhi_new = _new_cp-&gt;method_handle_index_at(cpi_new);
305     if ((_old_cp-&gt;uncached_klass_ref_at_noresolve(mhi_old) != _new_cp-&gt;uncached_klass_ref_at_noresolve(mhi_new)) ||
306         (_old_cp-&gt;uncached_name_ref_at(mhi_old) != _new_cp-&gt;uncached_name_ref_at(mhi_new)) ||
307         (_old_cp-&gt;uncached_signature_ref_at(mhi_old) != _new_cp-&gt;uncached_signature_ref_at(mhi_new)))
308       return false;
309   } else {
310     return false;  // unknown tag
311   }
312   return true;
313 }
314 
315 
316 int MethodComparator::check_stack_and_locals_size(Method* old_method, Method* new_method) {
317   if (old_method-&gt;max_stack() != new_method-&gt;max_stack()) {
318     return 1;
319   } else if (old_method-&gt;max_locals() != new_method-&gt;max_locals()) {
320     return 2;
321   } else if (old_method-&gt;size_of_parameters() != new_method-&gt;size_of_parameters()) {
322     return 3;
323   } else return 0;
324 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="forte.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
<span class="line-modified">  53 #include &quot;oops/markOop.hpp&quot;</span>
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/jniCheck.hpp&quot;
  62 #include &quot;prims/jniExport.hpp&quot;
  63 #include &quot;prims/jniFastGetField.hpp&quot;
  64 #include &quot;prims/jvm_misc.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiThreadState.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">  68 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">  76 #include &quot;runtime/orderAccess.hpp&quot;</span>
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/safepointVerifiers.hpp&quot;
  79 #include &quot;runtime/sharedRuntime.hpp&quot;
  80 #include &quot;runtime/signature.hpp&quot;
  81 #include &quot;runtime/thread.inline.hpp&quot;
  82 #include &quot;runtime/vmOperations.hpp&quot;
  83 #include &quot;services/memTracker.hpp&quot;
  84 #include &quot;services/runtimeService.hpp&quot;
  85 #include &quot;utilities/defaultStream.hpp&quot;
  86 #include &quot;utilities/dtrace.hpp&quot;
  87 #include &quot;utilities/events.hpp&quot;
  88 #include &quot;utilities/histogram.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/vmError.hpp&quot;
  91 #if INCLUDE_JVMCI
  92 #include &quot;jvmci/jvmciCompiler.hpp&quot;
<span class="line-removed">  93 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  94 #endif
  95 
  96 static jint CurrentVersion = JNI_VERSION_10;
  97 
  98 #ifdef _WIN32
  99 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
 100 #endif
 101 
 102 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 103 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 104 // Methods that have multiple return paths use this to avoid having to
 105 // instrument each return path.  Methods that use CHECK or THROW must use this
 106 // since those macros can cause an immedate uninstrumented return.
 107 //
 108 // In order to get the return value, a reference to the variable containing
 109 // the return value must be passed to the contructor of the object, and
 110 // the return value must be set before return (since the mark object has
 111 // a reference to it).
 112 //
 113 // Example:
</pre>
<hr />
<pre>
 258   }
 259   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 260       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 261 }
 262 
 263 // Wrapper to trace JNI functions
 264 
 265 #ifdef ASSERT
 266   Histogram* JNIHistogram;
 267   static volatile int JNIHistogram_lock = 0;
 268 
 269   class JNIHistogramElement : public HistogramElement {
 270     public:
 271      JNIHistogramElement(const char* name);
 272   };
 273 
 274   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 275     _name = elementName;
 276     uintx count = 0;
 277 
<span class="line-modified"> 278     while (Atomic::cmpxchg(1, &amp;JNIHistogram_lock, 0) != 0) {</span>
<span class="line-modified"> 279       while (OrderAccess::load_acquire(&amp;JNIHistogram_lock) != 0) {</span>
 280         count +=1;
 281         if ( (WarnOnStalledSpinLock &gt; 0)
 282           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 283           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 284         }
 285       }
 286      }
 287 
 288 
 289     if(JNIHistogram == NULL)
 290       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 291 
 292     JNIHistogram-&gt;add_element(this);
 293     Atomic::dec(&amp;JNIHistogram_lock);
 294   }
 295 
 296   #define JNICountWrapper(arg)                                     \
 297      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 298       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 299      if (e != NULL) e-&gt;increment_count()
</pre>
<hr />
<pre>
 316     env, (char*) name, loaderRef, (char*) buf, bufLen);
 317 
 318   jclass cls = NULL;
 319   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 320 
 321   TempNewSymbol class_name = NULL;
 322   // Since exceptions can be thrown, class initialization can take place
 323   // if name is NULL no check for class name in .class stream has to be made.
 324   if (name != NULL) {
 325     const int str_len = (int)strlen(name);
 326     if (str_len &gt; Symbol::max_length()) {
 327       // It&#39;s impossible to create this class;  the name cannot fit
 328       // into the constant pool.
 329       Exceptions::fthrow(THREAD_AND_LOCATION,
 330                          vmSymbols::java_lang_NoClassDefFoundError(),
 331                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 332                          Symbol::max_length(),
 333                          name);
 334       return 0;
 335     }
<span class="line-modified"> 336     class_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
 337   }
 338   ResourceMark rm(THREAD);
 339   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 340   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 341 
 342   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 343     // check whether the current caller thread holds the lock or not.
 344     // If not, increment the corresponding counter
 345     if (ObjectSynchronizer::
 346         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 347         ObjectSynchronizer::owner_self) {
 348       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 349     }
 350   }
 351   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 352                                                    class_loader,
 353                                                    Handle(),
 354                                                    &amp;st,
 355                                                    CHECK_NULL);
 356 
</pre>
<hr />
<pre>
 403         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 404       JavaValue result(T_OBJECT);
 405       JavaCalls::call_static(&amp;result, k,
 406                              vmSymbols::getFromClass_name(),
 407                              vmSymbols::void_class_signature(),
 408                              CHECK_NULL);
 409       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 410       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 411       // it will return NULL to indicate no context.
 412       oop mirror = (oop) result.get_jobject();
 413       if (mirror != NULL) {
 414         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 415         loader = Handle(THREAD, fromClass-&gt;class_loader());
 416         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 417       }
 418     } else {
 419       loader = Handle(THREAD, k-&gt;class_loader());
 420     }
 421   }
 422 
<span class="line-modified"> 423   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);</span>
 424   result = find_class_from_class_loader(env, sym, true, loader,
 425                                         protection_domain, true, thread);
 426 
 427   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 428     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 429   }
 430 
 431   return result;
 432 JNI_END
 433 
 434 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 435                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 436 
 437 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 438   JNIWrapper(&quot;FromReflectedMethod&quot;);
 439 
 440   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 441 
 442   jmethodID ret = NULL;
 443   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
</pre>
<hr />
<pre>
 546 
 547   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 548   // arrays return Object
 549   // interfaces return NULL
 550   // proper classes return Klass::super()
 551   Klass* k = java_lang_Class::as_Klass(mirror);
 552   if (k-&gt;is_interface()) return NULL;
 553 
 554   // return mirror for superclass
 555   Klass* super = k-&gt;java_super();
 556   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 557   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 558                                  ? SystemDictionary::Object_klass()
 559                                  : k-&gt;super() ) );
 560   assert(super == super2,
 561          &quot;java_super computation depends on interface, array, other super&quot;);
 562   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 563   return obj;
 564 JNI_END
 565 
<span class="line-modified"> 566 JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))</span>
 567   JNIWrapper(&quot;IsSubclassOf&quot;);
 568 
 569   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 570 
 571   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 572   oop super_mirror = JNIHandles::resolve_non_null(super);
 573   if (java_lang_Class::is_primitive(sub_mirror) ||
 574       java_lang_Class::is_primitive(super_mirror)) {
<span class="line-modified"> 575     jboolean ret = oopDesc::equals(sub_mirror, super_mirror);</span>
 576 
 577     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 578     return ret;
 579   }
 580   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 581   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 582   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 583   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 584                    JNI_TRUE : JNI_FALSE;
 585 
 586   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 587   return ret;
 588 JNI_END
 589 
 590 
 591 DT_RETURN_MARK_DECL(Throw, jint
 592                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 593 
 594 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 595   JNIWrapper(&quot;Throw&quot;);
</pre>
<hr />
<pre>
 681                                 THREAD);
 682         // If an exception is thrown in the call it gets thrown away. Not much
 683         // we can do with it. The native code that calls this, does not check
 684         // for the exception - hence, it might still be in the thread when DestroyVM gets
 685         // called, potentially causing a few asserts to trigger - since no pending exception
 686         // is expected.
 687         CLEAR_PENDING_EXCEPTION;
 688       } else {
 689         ResourceMark rm(THREAD);
 690         jio_fprintf(defaultStream::error_stream(),
 691         &quot;. Uncaught exception of type %s.&quot;,
 692         ex-&gt;klass()-&gt;external_name());
 693       }
 694     }
 695   }
 696 
 697   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 698 JNI_END
 699 
 700 
<span class="line-modified"> 701 JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))</span>
 702   JNIWrapper(&quot;ExceptionClear&quot;);
 703 
 704   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 705 
 706   // The jni code might be using this API to clear java thrown exception.
 707   // So just mark jvmti thread exception state as exception caught.
 708   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 709   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 710     state-&gt;set_exception_caught();
 711   }
 712   thread-&gt;clear_pending_exception();
 713 
 714   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 715 JNI_END
 716 
 717 
 718 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 719   JNIWrapper(&quot;FatalError&quot;);
 720 
 721   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
</pre>
<hr />
<pre>
 778   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 779 
 780   Handle ref_handle(thread, JNIHandles::resolve(ref));
 781   jobject ret = JNIHandles::make_global(ref_handle);
 782 
 783   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 784   return ret;
 785 JNI_END
 786 
 787 // Must be JNI_ENTRY (with HandleMark)
 788 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 789   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 790 
 791   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 792 
 793   JNIHandles::destroy_global(ref);
 794 
 795   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 796 JNI_END
 797 
<span class="line-modified"> 798 JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))</span>
 799   JNIWrapper(&quot;DeleteLocalRef&quot;);
 800 
 801   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 802 
 803   JNIHandles::destroy_local(obj);
 804 
 805   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 806 JNI_END
 807 
<span class="line-modified"> 808 JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))</span>
 809   JNIWrapper(&quot;IsSameObject&quot;);
 810 
 811   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 812 
 813   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 814 
 815   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 816   return ret;
 817 JNI_END
 818 
 819 
 820 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 821   JNIWrapper(&quot;NewLocalRef&quot;);
 822 
 823   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 824 
 825   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 826 
 827   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 828   return ret;
</pre>
<hr />
<pre>
 848 // Return the Handle Type
 849 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 850   JNIWrapper(&quot;GetObjectRefType&quot;);
 851 
 852   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 853 
 854   jobjectRefType ret = JNIInvalidRefType;
 855   if (obj != NULL) {
 856     ret = JNIHandles::handle_type(thread, obj);
 857   }
 858 
 859   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 860   return ret;
 861 JNI_END
 862 
 863 
 864 class JNI_ArgumentPusher : public SignatureIterator {
 865  protected:
 866   JavaCallArguments*  _arguments;
 867 
<span class="line-modified"> 868   virtual void get_bool   () = 0;</span>
<span class="line-modified"> 869   virtual void get_char   () = 0;</span>
<span class="line-modified"> 870   virtual void get_short  () = 0;</span>
<span class="line-modified"> 871   virtual void get_byte   () = 0;</span>
<span class="line-modified"> 872   virtual void get_int    () = 0;</span>
<span class="line-modified"> 873   virtual void get_long   () = 0;</span>
<span class="line-modified"> 874   virtual void get_float  () = 0;</span>
<span class="line-modified"> 875   virtual void get_double () = 0;</span>
<span class="line-modified"> 876   virtual void get_object () = 0;</span>
<span class="line-modified"> 877 </span>
<span class="line-modified"> 878   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified"> 879     this-&gt;_return_type = T_ILLEGAL;</span>






 880     _arguments = NULL;
 881   }
 882 
 883  public:
<span class="line-modified"> 884   virtual void iterate( uint64_t fingerprint ) = 0;</span>
<span class="line-removed"> 885 </span>
<span class="line-removed"> 886   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888   inline void do_bool()                     { if (!is_return_type()) get_bool();   }</span>
<span class="line-removed"> 889   inline void do_char()                     { if (!is_return_type()) get_char();   }</span>
<span class="line-removed"> 890   inline void do_short()                    { if (!is_return_type()) get_short();  }</span>
<span class="line-removed"> 891   inline void do_byte()                     { if (!is_return_type()) get_byte();   }</span>
<span class="line-removed"> 892   inline void do_int()                      { if (!is_return_type()) get_int();    }</span>
<span class="line-removed"> 893   inline void do_long()                     { if (!is_return_type()) get_long();   }</span>
<span class="line-removed"> 894   inline void do_float()                    { if (!is_return_type()) get_float();  }</span>
<span class="line-removed"> 895   inline void do_double()                   { if (!is_return_type()) get_double(); }</span>
<span class="line-removed"> 896   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }</span>
<span class="line-removed"> 897   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array</span>
<span class="line-removed"> 898   inline void do_void()                     { }</span>
<span class="line-removed"> 899 </span>
<span class="line-removed"> 900   JavaCallArguments* arguments()     { return _arguments; }</span>
<span class="line-removed"> 901   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }</span>
 902 };
 903 
 904 
 905 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 906  protected:
 907   va_list _ap;
 908 
<span class="line-modified"> 909   inline void get_bool()   {</span>
<span class="line-modified"> 910     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed"> 911     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed"> 912     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed"> 913     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed"> 914     jboolean b = va_arg(_ap, jint);</span>
<span class="line-removed"> 915     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
 916   }
<span class="line-removed"> 917   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg</span>
<span class="line-removed"> 918   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg</span>
<span class="line-removed"> 919   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg</span>
<span class="line-removed"> 920   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }</span>
 921 
<span class="line-modified"> 922   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>








 923 
<span class="line-modified"> 924   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }</span>
<span class="line-removed"> 925   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg</span>
<span class="line-removed"> 926   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }</span>
<span class="line-removed"> 927   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }</span>
 928 
<span class="line-modified"> 929   inline void set_ap(va_list rap) {</span>
<span class="line-modified"> 930     va_copy(_ap, rap);</span>







 931   }
 932 
 933  public:
<span class="line-removed"> 934   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)</span>
<span class="line-removed"> 935        : JNI_ArgumentPusher(signature) {</span>
<span class="line-removed"> 936     set_ap(rap);</span>
<span class="line-removed"> 937   }</span>
 938   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<span class="line-modified"> 939       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
 940     set_ap(rap);
 941   }
 942 
<span class="line-modified"> 943   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified"> 944   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified"> 945     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed"> 946       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed"> 947     } else {</span>
<span class="line-removed"> 948       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed"> 949                                   result_feature_mask);</span>
<span class="line-removed"> 950 </span>
<span class="line-removed"> 951       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed"> 952       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed"> 953       while ( 1 ) {</span>
<span class="line-removed"> 954         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed"> 955           case bool_parm:</span>
<span class="line-removed"> 956             get_bool();</span>
<span class="line-removed"> 957             break;</span>
<span class="line-removed"> 958           case char_parm:</span>
<span class="line-removed"> 959             get_char();</span>
<span class="line-removed"> 960             break;</span>
<span class="line-removed"> 961           case short_parm:</span>
<span class="line-removed"> 962             get_short();</span>
<span class="line-removed"> 963             break;</span>
<span class="line-removed"> 964           case byte_parm:</span>
<span class="line-removed"> 965             get_byte();</span>
<span class="line-removed"> 966             break;</span>
<span class="line-removed"> 967           case int_parm:</span>
<span class="line-removed"> 968             get_int();</span>
<span class="line-removed"> 969             break;</span>
<span class="line-removed"> 970           case obj_parm:</span>
<span class="line-removed"> 971             get_object();</span>
<span class="line-removed"> 972             break;</span>
<span class="line-removed"> 973           case long_parm:</span>
<span class="line-removed"> 974             get_long();</span>
<span class="line-removed"> 975             break;</span>
<span class="line-removed"> 976           case float_parm:</span>
<span class="line-removed"> 977             get_float();</span>
<span class="line-removed"> 978             break;</span>
<span class="line-removed"> 979           case double_parm:</span>
<span class="line-removed"> 980             get_double();</span>
<span class="line-removed"> 981             break;</span>
<span class="line-removed"> 982           case done_parm:</span>
<span class="line-removed"> 983             return;</span>
<span class="line-removed"> 984             break;</span>
<span class="line-removed"> 985           default:</span>
<span class="line-removed"> 986             ShouldNotReachHere();</span>
<span class="line-removed"> 987             break;</span>
<span class="line-removed"> 988         }</span>
<span class="line-removed"> 989         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed"> 990       }</span>
<span class="line-removed"> 991     }</span>
 992   }
 993 };
 994 
 995 
 996 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 997  protected:
 998   const jvalue *_ap;
 999 
<span class="line-removed">1000   inline void get_bool()   {</span>
<span class="line-removed">1001     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed">1002     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed">1003     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed">1004     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed">1005     jboolean b = (_ap++)-&gt;z;</span>
<span class="line-removed">1006     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
<span class="line-removed">1007   }</span>
<span class="line-removed">1008   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }</span>
<span class="line-removed">1009   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }</span>
<span class="line-removed">1010   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }</span>
<span class="line-removed">1011   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }</span>
<span class="line-removed">1012 </span>
<span class="line-removed">1013   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }</span>
<span class="line-removed">1014   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }</span>
<span class="line-removed">1015   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}</span>
<span class="line-removed">1016   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }</span>
<span class="line-removed">1017 </span>
1018   inline void set_ap(const jvalue *rap) { _ap = rap; }
1019 
<span class="line-modified">1020  public:</span>
<span class="line-modified">1021   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)</span>
<span class="line-modified">1022        : JNI_ArgumentPusher(signature) {</span>
<span class="line-modified">1023     set_ap(rap);</span>











1024   }


1025   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<span class="line-modified">1026       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
1027     set_ap(rap);
1028   }
1029 
<span class="line-modified">1030   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified">1031   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified">1032     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed">1033       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed">1034     } else {</span>
<span class="line-removed">1035       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed">1036                                   result_feature_mask);</span>
<span class="line-removed">1037       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed">1038       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed">1039       while ( 1 ) {</span>
<span class="line-removed">1040         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed">1041           case bool_parm:</span>
<span class="line-removed">1042             get_bool();</span>
<span class="line-removed">1043             break;</span>
<span class="line-removed">1044           case char_parm:</span>
<span class="line-removed">1045             get_char();</span>
<span class="line-removed">1046             break;</span>
<span class="line-removed">1047           case short_parm:</span>
<span class="line-removed">1048             get_short();</span>
<span class="line-removed">1049             break;</span>
<span class="line-removed">1050           case byte_parm:</span>
<span class="line-removed">1051             get_byte();</span>
<span class="line-removed">1052             break;</span>
<span class="line-removed">1053           case int_parm:</span>
<span class="line-removed">1054             get_int();</span>
<span class="line-removed">1055             break;</span>
<span class="line-removed">1056           case obj_parm:</span>
<span class="line-removed">1057             get_object();</span>
<span class="line-removed">1058             break;</span>
<span class="line-removed">1059           case long_parm:</span>
<span class="line-removed">1060             get_long();</span>
<span class="line-removed">1061             break;</span>
<span class="line-removed">1062           case float_parm:</span>
<span class="line-removed">1063             get_float();</span>
<span class="line-removed">1064             break;</span>
<span class="line-removed">1065           case double_parm:</span>
<span class="line-removed">1066             get_double();</span>
<span class="line-removed">1067             break;</span>
<span class="line-removed">1068           case done_parm:</span>
<span class="line-removed">1069             return;</span>
<span class="line-removed">1070             break;</span>
<span class="line-removed">1071           default:</span>
<span class="line-removed">1072             ShouldNotReachHere();</span>
<span class="line-removed">1073             break;</span>
<span class="line-removed">1074         }</span>
<span class="line-removed">1075         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed">1076       }</span>
<span class="line-removed">1077     }</span>
1078   }
1079 };
1080 
1081 
1082 enum JNICallType {
1083   JNI_STATIC,
1084   JNI_VIRTUAL,
1085   JNI_NONVIRTUAL
1086 };
1087 
1088 
1089 
1090 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1091   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1092 
1093   // Create object to hold arguments for the JavaCall, and associate it with
1094   // the jni parser
1095   ResourceMark rm(THREAD);
1096   int number_of_parameters = method-&gt;size_of_parameters();
1097   JavaCallArguments java_args(number_of_parameters);
<span class="line-removed">1098   args-&gt;set_java_argument_object(&amp;java_args);</span>
1099 
1100   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1101 
1102   // Fill out JavaCallArguments object
<span class="line-modified">1103   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1104   // Initialize result type
<span class="line-modified">1105   result-&gt;set_type(args-&gt;get_ret_type());</span>
1106 
1107   // Invoke the method. Result is returned as oop.
1108   JavaCalls::call(result, method, &amp;java_args, CHECK);
1109 
1110   // Convert result
<span class="line-modified">1111   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {</span>
1112     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1113   }
1114 }
1115 
1116 
1117 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1118   oop recv = JNIHandles::resolve(receiver);
1119   if (recv == NULL) {
1120     THROW(vmSymbols::java_lang_NullPointerException());
1121   }
1122   Handle h_recv(THREAD, recv);
1123 
1124   int number_of_parameters;
1125   Method* selected_method;
1126   {
1127     Method* m = Method::resolve_jmethod_id(method_id);
1128     number_of_parameters = m-&gt;size_of_parameters();
1129     Klass* holder = m-&gt;method_holder();
1130     if (call_type != JNI_VIRTUAL) {
1131         selected_method = m;
</pre>
<hr />
<pre>
1139       if (vtbl_index != Method::nonvirtual_vtable_index) {
1140         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1141       } else {
1142         // final method
1143         selected_method = m;
1144       }
1145     } else {
1146       // interface call
1147       int itbl_index = m-&gt;itable_index();
1148       Klass* k = h_recv-&gt;klass();
1149       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1150     }
1151   }
1152 
1153   methodHandle method(THREAD, selected_method);
1154 
1155   // Create object to hold arguments for the JavaCall, and associate it with
1156   // the jni parser
1157   ResourceMark rm(THREAD);
1158   JavaCallArguments java_args(number_of_parameters);
<span class="line-removed">1159   args-&gt;set_java_argument_object(&amp;java_args);</span>
1160 
1161   // handle arguments
1162   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<span class="line-modified">1163   args-&gt;push_receiver(h_recv); // Push jobject handle</span>
1164 
1165   // Fill out JavaCallArguments object
<span class="line-modified">1166   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1167   // Initialize result type
<span class="line-modified">1168   result-&gt;set_type(args-&gt;get_ret_type());</span>
1169 
1170   // Invoke the method. Result is returned as oop.
1171   JavaCalls::call(result, method, &amp;java_args, CHECK);
1172 
1173   // Convert result
<span class="line-modified">1174   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {</span>
1175     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1176   }
1177 }
1178 
1179 
1180 static instanceOop alloc_object(jclass clazz, TRAPS) {
1181   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1182   if (k == NULL) {
1183     ResourceMark rm(THREAD);
1184     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1185   }
1186   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1187   k-&gt;initialize(CHECK_NULL);
1188   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1189   return ih;
1190 }
1191 
1192 DT_RETURN_MARK_DECL(AllocObject, jobject
1193                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1194 
</pre>
<hr />
<pre>
1264   JNI_ArgumentPusherVaArg ap(methodID, args);
1265   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1266   va_end(args);
1267   return obj;
1268 JNI_END
1269 
1270 
1271 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1272   JNIWrapper(&quot;GetObjectClass&quot;);
1273 
1274   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1275 
1276   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1277   jclass ret =
1278     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1279 
1280   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1281   return ret;
1282 JNI_END
1283 
<span class="line-modified">1284 JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))</span>
1285   JNIWrapper(&quot;IsInstanceOf&quot;);
1286 
1287   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1288 
1289   jboolean ret = JNI_TRUE;
1290   if (obj != NULL) {
1291     ret = JNI_FALSE;
1292     Klass* k = java_lang_Class::as_Klass(
1293       JNIHandles::resolve_non_null(clazz));
1294     if (k != NULL) {
1295       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1296     }
1297   }
1298 
1299   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1300   return ret;
1301 JNI_END
1302 
1303 
1304 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1305                                const char *sig, bool is_static, TRAPS) {
1306   // %%%% This code should probably just call into a method in the LinkResolver
1307   //
1308   // The class should have been loaded (we have an instance of the class
1309   // passed in) so the method and signature should already be in the symbol
1310   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1311   const char *name_to_probe = (name_str == NULL)
1312                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1313                         : name_str;
1314   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1315   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1316 
1317   if (name == NULL || signature == NULL) {
1318     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1319   }
1320 


1321   // Throw a NoSuchMethodError exception if we have an instance of a
1322   // primitive java.lang.Class
1323   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
<span class="line-modified">1324     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);</span>

1325   }
1326 
<span class="line-removed">1327   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="line-removed">1328 </span>
1329   // Make sure class is linked and initialized before handing id&#39;s out to
1330   // Method*s.
1331   klass-&gt;initialize(CHECK_NULL);
1332 
1333   Method* m;
1334   if (name == vmSymbols::object_initializer_name() ||
1335       name == vmSymbols::class_initializer_name()) {
1336     // Never search superclasses for constructors
1337     if (klass-&gt;is_instance_klass()) {
1338       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1339     } else {
1340       m = NULL;
1341     }
1342   } else {
1343     m = klass-&gt;lookup_method(name, signature);
1344     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1345       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1346     }
1347   }
1348   if (m == NULL || (m-&gt;is_static() != is_static)) {
<span class="line-modified">1349     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);</span>

1350   }
1351   return m-&gt;jmethod_id();
1352 }
1353 
1354 
1355 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1356           const char *name, const char *sig))
1357   JNIWrapper(&quot;GetMethodID&quot;);
1358   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1359   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1360   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1361   return ret;
1362 JNI_END
1363 
1364 
1365 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1366           const char *name, const char *sig))
1367   JNIWrapper(&quot;GetStaticMethodID&quot;);
1368   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1369   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
</pre>
<hr />
<pre>
1997   JNI_ArgumentPusherArray ap(methodID, args);
1998   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1999 JNI_END
2000 
2001 
2002 //
2003 // Accessing Fields
2004 //
2005 
2006 
2007 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2008                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2009 
2010 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2011           const char *name, const char *sig))
2012   JNIWrapper(&quot;GetFieldID&quot;);
2013   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2014   jfieldID ret = 0;
2015   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2016 


2017   // The class should have been loaded (we have an instance of the class
2018   // passed in) so the field and signature should already be in the symbol
2019   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2020   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2021   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2022   if (fieldname == NULL || signame == NULL) {
<span class="line-modified">2023     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);</span>

2024   }
<span class="line-modified">2025   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
2026   // Make sure class is initialized before handing id&#39;s out to fields
2027   k-&gt;initialize(CHECK_NULL);
2028 
2029   fieldDescriptor fd;
2030   if (!k-&gt;is_instance_klass() ||
2031       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
<span class="line-modified">2032     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);</span>

2033   }
2034 
2035   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2036   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2037   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
2038   return ret;
2039 JNI_END
2040 
2041 
2042 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2043   JNIWrapper(&quot;GetObjectField&quot;);
2044   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2045   oop o = JNIHandles::resolve_non_null(obj);
2046   Klass* k = o-&gt;klass();
2047   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2048   // Keep JVMTI addition small and only check enabled flag here.
2049   // jni_GetField_probe() assumes that is okay to create handles.
2050   if (JvmtiExport::should_post_field_access()) {
2051     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2052   }
2053   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2054   jobject ret = JNIHandles::make_local(env, loaded_obj);
2055   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2056   return ret;
2057 JNI_END
2058 
2059 
2060 
2061 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2062   , EntryProbe, ReturnProbe) \
2063 \
2064   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2065   , ReturnProbe); \
2066 \
<span class="line-modified">2067 JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \</span>
2068   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2069 \
2070   EntryProbe; \
2071   Return ret = 0;\
2072   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2073 \
2074   oop o = JNIHandles::resolve_non_null(obj); \
2075   Klass* k = o-&gt;klass(); \
2076   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2077   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2078   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2079   /* and creates a ResetNoHandleMark.                                   */ \
2080   if (JvmtiExport::should_post_field_access()) { \
2081     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2082   } \
2083   ret = o-&gt;Fieldname##_field(offset); \
2084   return ret; \
2085 JNI_END
2086 
2087 DEFINE_GETFIELD(jboolean, bool,   Boolean
</pre>
<hr />
<pre>
2118 }
2119 address jni_GetCharField_addr() {
2120   return (address)jni_GetCharField;
2121 }
2122 address jni_GetShortField_addr() {
2123   return (address)jni_GetShortField;
2124 }
2125 address jni_GetIntField_addr() {
2126   return (address)jni_GetIntField;
2127 }
2128 address jni_GetLongField_addr() {
2129   return (address)jni_GetLongField;
2130 }
2131 address jni_GetFloatField_addr() {
2132   return (address)jni_GetFloatField;
2133 }
2134 address jni_GetDoubleField_addr() {
2135   return (address)jni_GetDoubleField;
2136 }
2137 
<span class="line-modified">2138 JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))</span>
2139   JNIWrapper(&quot;SetObjectField&quot;);
2140   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2141   oop o = JNIHandles::resolve_non_null(obj);
2142   Klass* k = o-&gt;klass();
2143   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2144   // Keep JVMTI addition small and only check enabled flag here.
2145   // jni_SetField_probe_nh() assumes that is not okay to create handles
2146   // and creates a ResetNoHandleMark.
2147   if (JvmtiExport::should_post_field_modification()) {
2148     jvalue field_value;
2149     field_value.l = value;
<span class="line-modified">2150     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, &#39;L&#39;, (jvalue *)&amp;field_value);</span>
2151   }
2152   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2153   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2154 JNI_END
2155 
2156 
2157 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2158                         , EntryProbe, ReturnProbe) \
2159 \
<span class="line-modified">2160 JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \</span>
2161   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2162 \
2163   EntryProbe; \
2164 \
2165   oop o = JNIHandles::resolve_non_null(obj); \
2166   Klass* k = o-&gt;klass(); \
2167   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2168   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2169   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2170   /* and creates a ResetNoHandleMark.                                   */ \
2171   if (JvmtiExport::should_post_field_modification()) { \
2172     jvalue field_value; \
2173     field_value.unionType = value; \
2174     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2175   } \
<span class="line-modified">2176   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \</span>
2177   o-&gt;Fieldname##_field_put(offset, value); \
2178   ReturnProbe; \
2179 JNI_END
2180 
<span class="line-modified">2181 DEFINE_SETFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z</span>
2182                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2183                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
<span class="line-modified">2184 DEFINE_SETFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b</span>
2185                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2186                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
<span class="line-modified">2187 DEFINE_SETFIELD(jchar,    char,   Char,    &#39;C&#39;, c</span>
2188                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2189                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
<span class="line-modified">2190 DEFINE_SETFIELD(jshort,   short,  Short,   &#39;S&#39;, s</span>
2191                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2192                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
<span class="line-modified">2193 DEFINE_SETFIELD(jint,     int,    Int,     &#39;I&#39;, i</span>
2194                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2195                 HOTSPOT_JNI_SETINTFIELD_RETURN())
<span class="line-modified">2196 DEFINE_SETFIELD(jlong,    long,   Long,    &#39;J&#39;, j</span>
2197                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2198                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2199 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="line-modified">2200 DEFINE_SETFIELD(jfloat,   float,  Float,   &#39;F&#39;, f</span>
2201                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2202                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
<span class="line-modified">2203 DEFINE_SETFIELD(jdouble,  double, Double,  &#39;D&#39;, d</span>
2204                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2205                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2206 
2207 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2208                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2209 
2210 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2211   JNIWrapper(&quot;ToReflectedField&quot;);
2212   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2213   jobject ret = NULL;
2214   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2215 
2216   fieldDescriptor fd;
2217   bool found = false;
2218   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2219 
2220   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2221 
2222   if (isStatic) {
2223     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
</pre>
<hr />
<pre>
2331 DEFINE_GETSTATICFIELD(jint,     int,    Int
2332                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2333 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2334                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2335 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2336 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2337                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2338 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2339                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2340 
2341 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2342   JNIWrapper(&quot;SetStaticObjectField&quot;);
2343  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2344   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2345   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2346   // Keep JVMTI addition small and only check enabled flag here.
2347   // jni_SetField_probe() assumes that is okay to create handles.
2348   if (JvmtiExport::should_post_field_modification()) {
2349     jvalue field_value;
2350     field_value.l = value;
<span class="line-modified">2351     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, &#39;L&#39;, (jvalue *)&amp;field_value);</span>
2352   }
2353   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2354   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2355 JNI_END
2356 
2357 
2358 
2359 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2360                               , EntryProbe, ReturnProbe) \
2361 \
2362 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2363   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2364   EntryProbe; \
2365 \
2366   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2367   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2368   /* Keep JVMTI addition small and only check enabled flag here. */ \
2369   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2370   if (JvmtiExport::should_post_field_modification()) { \
2371     jvalue field_value; \
2372     field_value.unionType = value; \
2373     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2374   } \
<span class="line-modified">2375   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \</span>
2376   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2377   ReturnProbe;\
2378 JNI_END
2379 
<span class="line-modified">2380 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z</span>
2381                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2382                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
<span class="line-modified">2383 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b</span>
2384                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2385                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
<span class="line-modified">2386 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    &#39;C&#39;, c</span>
2387                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2388                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
<span class="line-modified">2389 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   &#39;S&#39;, s</span>
2390                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2391                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
<span class="line-modified">2392 DEFINE_SETSTATICFIELD(jint,     int,    Int,     &#39;I&#39;, i</span>
2393                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2394                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
<span class="line-modified">2395 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    &#39;J&#39;, j</span>
2396                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2397                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2398 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="line-modified">2399 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   &#39;F&#39;, f</span>
2400                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2401                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
<span class="line-modified">2402 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  &#39;D&#39;, d</span>
2403                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2404                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2405 
2406 //
2407 // String Operations
2408 //
2409 
2410 // Unicode Interface
2411 
2412 DT_RETURN_MARK_DECL(NewString, jstring
2413                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2414 
2415 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2416   JNIWrapper(&quot;NewString&quot;);
2417  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2418   jstring ret = NULL;
2419   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2420   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2421   ret = (jstring) JNIHandles::make_local(env, string);
2422   return ret;
2423 JNI_END
2424 
2425 
<span class="line-modified">2426 JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))</span>
2427   JNIWrapper(&quot;GetStringLength&quot;);
2428   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2429   jsize ret = 0;
2430   oop s = JNIHandles::resolve_non_null(string);
2431   ret = java_lang_String::length(s);
2432  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2433   return ret;
2434 JNI_END
2435 
2436 
<span class="line-modified">2437 JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(</span>
2438   JNIEnv *env, jstring string, jboolean *isCopy))
2439   JNIWrapper(&quot;GetStringChars&quot;);
2440  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2441   jchar* buf = NULL;
2442   oop s = JNIHandles::resolve_non_null(string);
2443   typeArrayOop s_value = java_lang_String::value(s);
2444   if (s_value != NULL) {
2445     int s_len = java_lang_String::length(s, s_value);
2446     bool is_latin1 = java_lang_String::is_latin1(s);
2447     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2448     /* JNI Specification states return NULL on OOM */
2449     if (buf != NULL) {
2450       if (s_len &gt; 0) {
2451         if (!is_latin1) {
2452           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2453                                              buf, s_len);
2454         } else {
2455           for (int i = 0; i &lt; s_len; i++) {
2456             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2457           }
2458         }
2459       }
2460       buf[s_len] = 0;
2461       //%note jni_5
2462       if (isCopy != NULL) {
2463         *isCopy = JNI_TRUE;
2464       }
2465     }
2466   }
2467   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2468   return buf;
2469 JNI_END
2470 
2471 
<span class="line-modified">2472 JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))</span>
2473   JNIWrapper(&quot;ReleaseStringChars&quot;);
2474   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2475   //%note jni_6
2476   if (chars != NULL) {
2477     // Since String objects are supposed to be immutable, don&#39;t copy any
2478     // new data back.  A bad user will have to go after the char array.
2479     FreeHeap((void*) chars);
2480   }
2481   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2482 JNI_END
2483 
2484 
2485 // UTF Interface
2486 
2487 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2488                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2489 
2490 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2491   JNIWrapper(&quot;NewStringUTF&quot;);
2492   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
</pre>
<hr />
<pre>
2524       if (isCopy != NULL) {
2525         *isCopy = JNI_TRUE;
2526       }
2527     }
2528   }
2529  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2530   return result;
2531 JNI_END
2532 
2533 
2534 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2535   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2536  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2537   if (chars != NULL) {
2538     FreeHeap((char*) chars);
2539   }
2540 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2541 JNI_END
2542 
2543 
<span class="line-modified">2544 JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))</span>
2545   JNIWrapper(&quot;GetArrayLength&quot;);
2546  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2547   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2548   assert(a-&gt;is_array(), &quot;must be array&quot;);
2549   jsize ret = a-&gt;length();
2550  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2551   return ret;
2552 JNI_END
2553 
2554 
2555 //
2556 // Object Array Operations
2557 //
2558 
2559 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2560                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2561 
2562 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2563   JNIWrapper(&quot;NewObjectArray&quot;);
2564  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
</pre>
<hr />
<pre>
2681 
2682 static char* get_bad_address() {
2683   static char* bad_address = NULL;
2684   if (bad_address == NULL) {
2685     size_t size = os::vm_allocation_granularity();
2686     bad_address = os::reserve_memory(size);
2687     if (bad_address != NULL) {
2688       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2689                          /*is_committed*/false);
2690       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2691     }
2692   }
2693   return bad_address;
2694 }
2695 
2696 
2697 
2698 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2699                                       , EntryProbe, ReturnProbe) \
2700 \
<span class="line-modified">2701 JNI_QUICK_ENTRY(ElementType*, \</span>
2702           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2703   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2704   EntryProbe; \
2705   /* allocate an chunk of memory in c land */ \
2706   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2707   ElementType* result; \
2708   int len = a-&gt;length(); \
2709   if (len == 0) { \
2710     if (isCopy != NULL) { \
2711       *isCopy = JNI_FALSE; \
2712     } \
2713     /* Empty array: legal but useless, can&#39;t return NULL. \
2714      * Return a pointer to something useless. \
2715      * Avoid asserts in typeArrayOop. */ \
2716     result = (ElementType*)get_bad_address(); \
2717   } else { \
2718     /* JNI Specification states return NULL on OOM */                    \
2719     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2720     if (result != NULL) {                                                \
2721       /* copy the array to the c chunk */                                \
</pre>
<hr />
<pre>
2743                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2744                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2745 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2746                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2747                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2748 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2749                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2750                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2751 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2752 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2753                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2754                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2755 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2756                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2757                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2758 
2759 
2760 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2761                                           , EntryProbe, ReturnProbe);\
2762 \
<span class="line-modified">2763 JNI_QUICK_ENTRY(void, \</span>
2764           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2765                                              ElementType *buf, jint mode)) \
2766   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2767   EntryProbe; \
2768   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2769   int len = a-&gt;length(); \
2770   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2771     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2772       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2773     } \
2774     if ((mode == 0) || (mode == JNI_ABORT)) { \
2775       FreeHeap(buf); \
2776     } \
2777   } \
2778   ReturnProbe; \
2779 JNI_END
2780 
2781 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2782                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2783                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
</pre>
<hr />
<pre>
2888 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2889                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2890                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2891 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2892                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2893                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2894 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2895                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2896                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2897 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2898                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2899                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2900 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2901                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2902                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2903 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2904                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2905                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2906 
2907 
<span class="line-removed">2908 //</span>
<span class="line-removed">2909 // Interception of natives</span>
<span class="line-removed">2910 //</span>
<span class="line-removed">2911 </span>
<span class="line-removed">2912 // The RegisterNatives call being attempted tried to register with a method that</span>
<span class="line-removed">2913 // is not native.  Ask JVM TI what prefixes have been specified.  Then check</span>
<span class="line-removed">2914 // to see if the native method is now wrapped with the prefixes.  See the</span>
<span class="line-removed">2915 // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.</span>
<span class="line-removed">2916 static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {</span>
<span class="line-removed">2917 #if INCLUDE_JVMTI</span>
<span class="line-removed">2918   ResourceMark rm(THREAD);</span>
<span class="line-removed">2919   Method* method;</span>
<span class="line-removed">2920   int name_len = name-&gt;utf8_length();</span>
<span class="line-removed">2921   char* name_str = name-&gt;as_utf8();</span>
<span class="line-removed">2922   int prefix_count;</span>
<span class="line-removed">2923   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);</span>
<span class="line-removed">2924   for (int i = 0; i &lt; prefix_count; i++) {</span>
<span class="line-removed">2925     char* prefix = prefixes[i];</span>
<span class="line-removed">2926     int prefix_len = (int)strlen(prefix);</span>
<span class="line-removed">2927 </span>
<span class="line-removed">2928     // try adding this prefix to the method name and see if it matches another method name</span>
<span class="line-removed">2929     int trial_len = name_len + prefix_len;</span>
<span class="line-removed">2930     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);</span>
<span class="line-removed">2931     strcpy(trial_name_str, prefix);</span>
<span class="line-removed">2932     strcat(trial_name_str, name_str);</span>
<span class="line-removed">2933     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);</span>
<span class="line-removed">2934     if (trial_name == NULL) {</span>
<span class="line-removed">2935       continue; // no such symbol, so this prefix wasn&#39;t used, try the next prefix</span>
<span class="line-removed">2936     }</span>
<span class="line-removed">2937     method = k-&gt;lookup_method(trial_name, signature);</span>
<span class="line-removed">2938     if (method == NULL) {</span>
<span class="line-removed">2939       continue; // signature doesn&#39;t match, try the next prefix</span>
<span class="line-removed">2940     }</span>
<span class="line-removed">2941     if (method-&gt;is_native()) {</span>
<span class="line-removed">2942       method-&gt;set_is_prefixed_native();</span>
<span class="line-removed">2943       return method; // wahoo, we found a prefixed version of the method, return it</span>
<span class="line-removed">2944     }</span>
<span class="line-removed">2945     // found as non-native, so prefix is good, add it, probably just need more prefixes</span>
<span class="line-removed">2946     name_len = trial_len;</span>
<span class="line-removed">2947     name_str = trial_name_str;</span>
<span class="line-removed">2948   }</span>
<span class="line-removed">2949 #endif // INCLUDE_JVMTI</span>
<span class="line-removed">2950   return NULL; // not found</span>
<span class="line-removed">2951 }</span>
<span class="line-removed">2952 </span>
<span class="line-removed">2953 static bool register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {</span>
<span class="line-removed">2954   Method* method = k-&gt;lookup_method(name, signature);</span>
<span class="line-removed">2955   if (method == NULL) {</span>
<span class="line-removed">2956     ResourceMark rm;</span>
<span class="line-removed">2957     stringStream st;</span>
<span class="line-removed">2958     st.print(&quot;Method %s name or signature does not match&quot;,</span>
<span class="line-removed">2959              Method::name_and_sig_as_C_string(k, name, signature));</span>
<span class="line-removed">2960     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-removed">2961   }</span>
<span class="line-removed">2962   if (!method-&gt;is_native()) {</span>
<span class="line-removed">2963     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)</span>
<span class="line-removed">2964     method = find_prefixed_native(k, name, signature, THREAD);</span>
<span class="line-removed">2965     if (method == NULL) {</span>
<span class="line-removed">2966       ResourceMark rm;</span>
<span class="line-removed">2967       stringStream st;</span>
<span class="line-removed">2968       st.print(&quot;Method %s is not declared as native&quot;,</span>
<span class="line-removed">2969                Method::name_and_sig_as_C_string(k, name, signature));</span>
<span class="line-removed">2970       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="line-removed">2971     }</span>
<span class="line-removed">2972   }</span>
<span class="line-removed">2973 </span>
<span class="line-removed">2974   if (entry != NULL) {</span>
<span class="line-removed">2975     method-&gt;set_native_function(entry,</span>
<span class="line-removed">2976       Method::native_bind_event_is_interesting);</span>
<span class="line-removed">2977   } else {</span>
<span class="line-removed">2978     method-&gt;clear_native_function();</span>
<span class="line-removed">2979   }</span>
<span class="line-removed">2980   if (PrintJNIResolving) {</span>
<span class="line-removed">2981     ResourceMark rm(THREAD);</span>
<span class="line-removed">2982     tty-&gt;print_cr(&quot;[Registering JNI native method %s.%s]&quot;,</span>
<span class="line-removed">2983       method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-removed">2984       method-&gt;name()-&gt;as_C_string());</span>
<span class="line-removed">2985   }</span>
<span class="line-removed">2986   return true;</span>
<span class="line-removed">2987 }</span>
<span class="line-removed">2988 </span>
2989 DT_RETURN_MARK_DECL(RegisterNatives, jint
2990                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2991 
2992 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2993                                     const JNINativeMethod *methods,
2994                                     jint nMethods))
2995   JNIWrapper(&quot;RegisterNatives&quot;);
2996   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2997   jint ret = 0;
2998   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2999 
3000   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3001 














3002   for (int index = 0; index &lt; nMethods; index++) {
3003     const char* meth_name = methods[index].name;
3004     const char* meth_sig = methods[index].signature;
3005     int meth_name_len = (int)strlen(meth_name);
3006 
3007     // The class should have been loaded (we have an instance of the class
3008     // passed in) so the method and signature should already be in the symbol
3009     // table.  If they&#39;re not there, the method doesn&#39;t exist.
3010     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
3011     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
3012 
3013     if (name == NULL || signature == NULL) {
<span class="line-modified">3014       ResourceMark rm;</span>
3015       stringStream st;
3016       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
3017       // Must return negative value on failure
3018       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
3019     }
3020 
<span class="line-modified">3021     bool res = register_native(k, name, signature,</span>
<span class="line-modified">3022                                (address) methods[index].fnPtr, THREAD);</span>






3023     if (!res) {
3024       ret = -1;
3025       break;
3026     }
3027   }
3028   return ret;
3029 JNI_END
3030 
3031 
3032 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
3033   JNIWrapper(&quot;UnregisterNatives&quot;);
3034  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
3035   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3036   //%note jni_2
3037   if (k-&gt;is_instance_klass()) {
3038     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
3039       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
3040       if (m-&gt;is_native()) {
3041         m-&gt;clear_native_function();
3042         m-&gt;set_signature_handler(NULL);
</pre>
<hr />
<pre>
3241 
3242 
3243 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3244   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3245  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3246   Handle ref_handle(thread, JNIHandles::resolve(ref));
3247   jweak ret = JNIHandles::make_weak_global(ref_handle);
3248  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3249   return ret;
3250 JNI_END
3251 
3252 // Must be JNI_ENTRY (with HandleMark)
3253 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3254   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3255   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3256   JNIHandles::destroy_weak_global(ref);
3257   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3258 JNI_END
3259 
3260 
<span class="line-modified">3261 JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))</span>
3262   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3263  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3264   jni_check_async_exceptions(thread);
3265   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3266  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3267   return ret;
3268 JNI_END
3269 
3270 
3271 // Initialization state for three routines below relating to
3272 // java.nio.DirectBuffers
3273 static          int directBufferSupportInitializeStarted = 0;
3274 static volatile int directBufferSupportInitializeEnded   = 0;
3275 static volatile int directBufferSupportInitializeFailed  = 0;
3276 static jclass    bufferClass                 = NULL;
3277 static jclass    directBufferClass           = NULL;
3278 static jclass    directByteBufferClass       = NULL;
3279 static jmethodID directByteBufferConstructor = NULL;
3280 static jfieldID  directBufferAddressField    = NULL;
3281 static jfieldID  bufferCapacityField         = NULL;
3282 
3283 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3284   Handle loader;            // null (bootstrap) loader
3285   Handle protection_domain; // null protection domain
3286 
<span class="line-modified">3287   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);</span>
3288   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3289 
3290   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3291     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3292   }
3293   return result;
3294 }
3295 
3296 // These lookups are done with the NULL (bootstrap) ClassLoader to
3297 // circumvent any security checks that would be done by jni_FindClass.
3298 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3299 {
3300   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3301   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3302   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3303   return true;
3304 }
3305 JNI_END
3306 
3307 
3308 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3309   if (directBufferSupportInitializeFailed) {
3310     return false;
3311   }
3312 
<span class="line-modified">3313   if (Atomic::cmpxchg(1, &amp;directBufferSupportInitializeStarted, 0) == 0) {</span>
3314     if (!lookupDirectBufferClasses(env)) {
3315       directBufferSupportInitializeFailed = 1;
3316       return false;
3317     }
3318 
3319     // Make global references for these
3320     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3321     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3322     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3323 
3324     // Get needed field and method IDs
3325     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3326     if (env-&gt;ExceptionCheck()) {
3327       env-&gt;ExceptionClear();
3328       directBufferSupportInitializeFailed = 1;
3329       return false;
3330     }
3331     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3332     if (env-&gt;ExceptionCheck()) {
3333       env-&gt;ExceptionClear();
</pre>
<hr />
<pre>
3749 
3750     jni_GetObjectRefType,
3751 
3752     // Module features
3753 
3754     jni_GetModule
3755 };
3756 
3757 
3758 // For jvmti use to modify jni function table.
3759 // Java threads in native contiues to run until it is transitioned
3760 // to VM at safepoint. Before the transition or before it is blocked
3761 // for safepoint it may access jni function table. VM could crash if
3762 // any java thread access the jni function table in the middle of memcpy.
3763 // To avoid this each function pointers are copied automically.
3764 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3765   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3766   intptr_t *a = (intptr_t *) jni_functions();
3767   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3768   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
<span class="line-modified">3769     Atomic::store(*b++, a++);</span>
3770   }
3771 }
3772 
3773 void quicken_jni_functions() {
3774   // Replace Get&lt;Primitive&gt;Field with fast versions
<span class="line-modified">3775   if (UseFastJNIAccessors &amp;&amp; !JvmtiExport::can_post_field_access()</span>
<span class="line-removed">3776       &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {</span>
3777     address func;
3778     func = JNI_FastGetField::generate_fast_get_boolean_field();
3779     if (func != (address)-1) {
3780       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3781     }
3782     func = JNI_FastGetField::generate_fast_get_byte_field();
3783     if (func != (address)-1) {
3784       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3785     }
3786     func = JNI_FastGetField::generate_fast_get_char_field();
3787     if (func != (address)-1) {
3788       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3789     }
3790     func = JNI_FastGetField::generate_fast_get_short_field();
3791     if (func != (address)-1) {
3792       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3793     }
3794     func = JNI_FastGetField::generate_fast_get_int_field();
3795     if (func != (address)-1) {
3796       jni_NativeInterface.GetIntField = (GetIntField_t)func;
</pre>
<hr />
<pre>
3872   }
3873   return ret;
3874 }
3875 
3876 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3877                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3878 
3879 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3880   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3881 
3882   jint result = JNI_ERR;
3883   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3884 
3885   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3886   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3887   // but __sync_lock_test_and_set is not guaranteed to do what we want
3888   // on all architectures.  So we check it works before relying on it.
3889 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3890   {
3891     jint a = 0xcafebabe;
<span class="line-modified">3892     jint b = Atomic::xchg((jint) 0xdeadbeef, &amp;a);</span>
3893     void *c = &amp;a;
<span class="line-modified">3894     void *d = Atomic::xchg(&amp;b, &amp;c);</span>
3895     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3896     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3897   }
3898 #endif // ZERO &amp;&amp; ASSERT
3899 
3900   // At the moment it&#39;s only possible to have one Java VM,
3901   // since some of the runtime state is in global variables.
3902 
3903   // We cannot use our mutex locks here, since they only work on
3904   // Threads. We do an atomic compare and exchange to ensure only
3905   // one thread can call this method at a time
3906 
3907   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3908   // the add/dec implementations are dependent on whether we are running
3909   // on a multiprocessor Atomic::xchg does not have this problem.
<span class="line-modified">3910   if (Atomic::xchg(1, &amp;vm_created) == 1) {</span>
3911     return JNI_EEXIST;   // already created, or create attempt in progress
3912   }
<span class="line-modified">3913   if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) {</span>
3914     return JNI_ERR;  // someone tried and failed and retry not allowed.
3915   }
3916 
3917   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3918 
3919   /**
3920    * Certain errors during initialization are recoverable and do not
3921    * prevent this method from being called again at a later time
3922    * (perhaps with different arguments).  However, at a certain
3923    * point during initialization if an error occurs we cannot allow
3924    * this function to be called again (or it will crash).  In those
3925    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3926    * sets safe_to_recreate_vm to 1, such that any new call to
3927    * JNI_CreateJavaVM will immediately fail using the above logic.
3928    */
3929   bool can_try_again = true;
3930 
3931   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3932   if (result == JNI_OK) {
3933     JavaThread *thread = JavaThread::current();
</pre>
<hr />
<pre>
3952       }
3953     }
3954 #endif
3955 
3956     // Notify JVMTI
3957     if (JvmtiExport::should_post_thread_life()) {
3958        JvmtiExport::post_thread_start(thread);
3959     }
3960 
3961     post_thread_start_event(thread);
3962 
3963 #ifndef PRODUCT
3964     if (ReplayCompiles) ciReplay::replay(thread);
3965 
3966     // Some platforms (like Win*) need a wrapper around these test
3967     // functions in order to properly handle error conditions.
3968     VMError::test_error_handler();
3969 #endif
3970 
3971     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
<span class="line-modified">3972     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
3973   } else {
3974     // If create_vm exits because of a pending exception, exit with that
3975     // exception.  In the future when we figure out how to reclaim memory,
3976     // we may be able to exit with JNI_ERR and allow the calling application
3977     // to continue.
3978     if (Universe::is_fully_initialized()) {
3979       // otherwise no pending exception possible - VM will already have aborted
3980       JavaThread* THREAD = JavaThread::current();
3981       if (HAS_PENDING_EXCEPTION) {
3982         HandleMark hm;
3983         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3984       }
3985     }
3986 
3987     if (can_try_again) {
3988       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3989       safe_to_recreate_vm = 1;
3990     }
3991 
3992     // Creation failed. We must reset vm_created
3993     *vm = 0;
3994     *(JNIEnv**)penv = 0;
3995     // reset vm_created last to avoid race condition. Use OrderAccess to
3996     // control both compiler and architectural-based reordering.
<span class="line-modified">3997     OrderAccess::release_store(&amp;vm_created, 0);</span>
3998   }
3999 
4000   // Flush stdout and stderr before exit.
4001   fflush(stdout);
4002   fflush(stderr);
4003 
4004   return result;
4005 
4006 }
4007 
4008 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4009   jint result = JNI_ERR;
4010   // On Windows, let CreateJavaVM run with SEH protection
4011 #ifdef _WIN32
4012   __try {
4013 #endif
4014     result = JNI_CreateJavaVM_inner(vm, penv, args);
4015 #ifdef _WIN32
4016   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4017     // Nothing to do.
</pre>
<hr />
<pre>
4054   JNIWrapper(&quot;DestroyJavaVM&quot;);
4055   JNIEnv *env;
4056   JavaVMAttachArgs destroyargs;
4057   destroyargs.version = CurrentVersion;
4058   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4059   destroyargs.group = NULL;
4060   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4061   if (res != JNI_OK) {
4062     return res;
4063   }
4064 
4065   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4066   JavaThread* thread = JavaThread::current();
4067   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4068   if (Threads::destroy_vm()) {
4069     // Should not change thread state, VM is gone
4070     vm_created = 0;
4071     res = JNI_OK;
4072     return res;
4073   } else {
<span class="line-modified">4074     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
4075     res = JNI_ERR;
4076     return res;
4077   }
4078 }
4079 
4080 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4081   jint result = JNI_ERR;
4082   // On Windows, we need SEH protection
4083 #ifdef _WIN32
4084   __try {
4085 #endif
4086     result = jni_DestroyJavaVM_inner(vm);
4087 #ifdef _WIN32
4088   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4089     // Nothing to do.
4090   }
4091 #endif
4092   return result;
4093 }
4094 
</pre>
<hr />
<pre>
4115 
4116   // Set correct safepoint info. The thread is going to call into Java when
4117   // initializing the Java level thread object. Hence, the correct state must
4118   // be set in order for the Safepoint code to deal with it correctly.
4119   thread-&gt;set_thread_state(_thread_in_vm);
4120   thread-&gt;record_stack_base_and_size();
4121   thread-&gt;register_thread_stack_with_NMT();
4122   thread-&gt;initialize_thread_current();
4123 
4124   if (!os::create_attached_thread(thread)) {
4125     thread-&gt;smr_delete();
4126     return JNI_ERR;
4127   }
4128   // Enable stack overflow checks
4129   thread-&gt;create_stack_guard_pages();
4130 
4131   thread-&gt;initialize_tlab();
4132 
4133   thread-&gt;cache_global_variables();
4134 
<span class="line-modified">4135   // Crucial that we do not have a safepoint check for this thread, since it has</span>
4136   // not been added to the Thread list yet.
<span class="line-modified">4137   { Threads_lock-&gt;lock_without_safepoint_check();</span>
4138     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4139     // avoid this thread trying to do a GC before it is added to the thread-list
4140     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4141     Threads::add(thread, daemon);
<span class="line-removed">4142     Threads_lock-&gt;unlock();</span>
4143   }
4144   // Create thread group and name info from attach arguments
4145   oop group = NULL;
4146   char* thread_name = NULL;
4147   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4148     group = JNIHandles::resolve(args-&gt;group);
4149     thread_name = args-&gt;name; // may be NULL
4150   }
4151   if (group == NULL) group = Universe::main_thread_group();
4152 
4153   // Create Java level thread object and attach it to this thread
4154   bool attach_failed = false;
4155   {
4156     EXCEPTION_MARK;
4157     HandleMark hm(THREAD);
4158     Handle thread_group(THREAD, group);
4159     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4160     if (HAS_PENDING_EXCEPTION) {
4161       CLEAR_PENDING_EXCEPTION;
4162       // cleanup outside the handle mark.
4163       attach_failed = true;
4164     }
4165   }
4166 
4167   if (attach_failed) {
4168     // Added missing cleanup
<span class="line-modified">4169     thread-&gt;cleanup_failed_attach_current_thread();</span>
4170     return JNI_ERR;
4171   }
4172 
4173   // mark the thread as no longer attaching
4174   // this uses a fence to push the change through so we don&#39;t have
4175   // to regrab the threads_lock
4176   thread-&gt;set_done_attaching_via_jni();
4177 
4178   // Set java thread status.
4179   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4180               java_lang_Thread::RUNNABLE);
4181 
4182   // Notify the debugger
4183   if (JvmtiExport::should_post_thread_life()) {
4184     JvmtiExport::post_thread_start(thread);
4185   }
4186 
4187   post_thread_start_event(thread);
4188 
4189   *(JNIEnv**)penv = thread-&gt;jni_environment();
4190 
4191   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4192   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4193   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4194   // needed.
4195 
<span class="line-modified">4196   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
4197 
4198   // Perform any platform dependent FPU setup
4199   os::setup_fpu();
4200 
4201   return JNI_OK;
4202 }
4203 
4204 
4205 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4206   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4207   if (vm_created == 0) {
4208   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4209     return JNI_ERR;
4210   }
4211 
4212   JNIWrapper(&quot;AttachCurrentThread&quot;);
4213   jint ret = attach_current_thread(vm, penv, _args, false);
4214   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4215   return ret;
4216 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
<span class="line-modified">  53 #include &quot;oops/markWord.hpp&quot;</span>
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/jniCheck.hpp&quot;
  62 #include &quot;prims/jniExport.hpp&quot;
  63 #include &quot;prims/jniFastGetField.hpp&quot;
  64 #include &quot;prims/jvm_misc.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiThreadState.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;

  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;

  75 #include &quot;runtime/reflection.hpp&quot;
  76 #include &quot;runtime/safepointVerifiers.hpp&quot;
  77 #include &quot;runtime/sharedRuntime.hpp&quot;
  78 #include &quot;runtime/signature.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;services/memTracker.hpp&quot;
  82 #include &quot;services/runtimeService.hpp&quot;
  83 #include &quot;utilities/defaultStream.hpp&quot;
  84 #include &quot;utilities/dtrace.hpp&quot;
  85 #include &quot;utilities/events.hpp&quot;
  86 #include &quot;utilities/histogram.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/vmError.hpp&quot;
  89 #if INCLUDE_JVMCI
  90 #include &quot;jvmci/jvmciCompiler.hpp&quot;

  91 #endif
  92 
  93 static jint CurrentVersion = JNI_VERSION_10;
  94 
  95 #ifdef _WIN32
  96 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
  97 #endif
  98 
  99 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 100 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 101 // Methods that have multiple return paths use this to avoid having to
 102 // instrument each return path.  Methods that use CHECK or THROW must use this
 103 // since those macros can cause an immedate uninstrumented return.
 104 //
 105 // In order to get the return value, a reference to the variable containing
 106 // the return value must be passed to the contructor of the object, and
 107 // the return value must be set before return (since the mark object has
 108 // a reference to it).
 109 //
 110 // Example:
</pre>
<hr />
<pre>
 255   }
 256   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 257       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 258 }
 259 
 260 // Wrapper to trace JNI functions
 261 
 262 #ifdef ASSERT
 263   Histogram* JNIHistogram;
 264   static volatile int JNIHistogram_lock = 0;
 265 
 266   class JNIHistogramElement : public HistogramElement {
 267     public:
 268      JNIHistogramElement(const char* name);
 269   };
 270 
 271   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 272     _name = elementName;
 273     uintx count = 0;
 274 
<span class="line-modified"> 275     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {</span>
<span class="line-modified"> 276       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {</span>
 277         count +=1;
 278         if ( (WarnOnStalledSpinLock &gt; 0)
 279           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 280           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 281         }
 282       }
 283      }
 284 
 285 
 286     if(JNIHistogram == NULL)
 287       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 288 
 289     JNIHistogram-&gt;add_element(this);
 290     Atomic::dec(&amp;JNIHistogram_lock);
 291   }
 292 
 293   #define JNICountWrapper(arg)                                     \
 294      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 295       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 296      if (e != NULL) e-&gt;increment_count()
</pre>
<hr />
<pre>
 313     env, (char*) name, loaderRef, (char*) buf, bufLen);
 314 
 315   jclass cls = NULL;
 316   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 317 
 318   TempNewSymbol class_name = NULL;
 319   // Since exceptions can be thrown, class initialization can take place
 320   // if name is NULL no check for class name in .class stream has to be made.
 321   if (name != NULL) {
 322     const int str_len = (int)strlen(name);
 323     if (str_len &gt; Symbol::max_length()) {
 324       // It&#39;s impossible to create this class;  the name cannot fit
 325       // into the constant pool.
 326       Exceptions::fthrow(THREAD_AND_LOCATION,
 327                          vmSymbols::java_lang_NoClassDefFoundError(),
 328                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 329                          Symbol::max_length(),
 330                          name);
 331       return 0;
 332     }
<span class="line-modified"> 333     class_name = SymbolTable::new_symbol(name);</span>
 334   }
 335   ResourceMark rm(THREAD);
 336   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 337   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 338 
 339   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 340     // check whether the current caller thread holds the lock or not.
 341     // If not, increment the corresponding counter
 342     if (ObjectSynchronizer::
 343         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 344         ObjectSynchronizer::owner_self) {
 345       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 346     }
 347   }
 348   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 349                                                    class_loader,
 350                                                    Handle(),
 351                                                    &amp;st,
 352                                                    CHECK_NULL);
 353 
</pre>
<hr />
<pre>
 400         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 401       JavaValue result(T_OBJECT);
 402       JavaCalls::call_static(&amp;result, k,
 403                              vmSymbols::getFromClass_name(),
 404                              vmSymbols::void_class_signature(),
 405                              CHECK_NULL);
 406       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 407       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 408       // it will return NULL to indicate no context.
 409       oop mirror = (oop) result.get_jobject();
 410       if (mirror != NULL) {
 411         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 412         loader = Handle(THREAD, fromClass-&gt;class_loader());
 413         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 414       }
 415     } else {
 416       loader = Handle(THREAD, k-&gt;class_loader());
 417     }
 418   }
 419 
<span class="line-modified"> 420   TempNewSymbol sym = SymbolTable::new_symbol(name);</span>
 421   result = find_class_from_class_loader(env, sym, true, loader,
 422                                         protection_domain, true, thread);
 423 
 424   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 425     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 426   }
 427 
 428   return result;
 429 JNI_END
 430 
 431 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 432                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 433 
 434 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 435   JNIWrapper(&quot;FromReflectedMethod&quot;);
 436 
 437   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 438 
 439   jmethodID ret = NULL;
 440   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
</pre>
<hr />
<pre>
 543 
 544   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 545   // arrays return Object
 546   // interfaces return NULL
 547   // proper classes return Klass::super()
 548   Klass* k = java_lang_Class::as_Klass(mirror);
 549   if (k-&gt;is_interface()) return NULL;
 550 
 551   // return mirror for superclass
 552   Klass* super = k-&gt;java_super();
 553   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 554   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 555                                  ? SystemDictionary::Object_klass()
 556                                  : k-&gt;super() ) );
 557   assert(super == super2,
 558          &quot;java_super computation depends on interface, array, other super&quot;);
 559   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 560   return obj;
 561 JNI_END
 562 
<span class="line-modified"> 563 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))</span>
 564   JNIWrapper(&quot;IsSubclassOf&quot;);
 565 
 566   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 567 
 568   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 569   oop super_mirror = JNIHandles::resolve_non_null(super);
 570   if (java_lang_Class::is_primitive(sub_mirror) ||
 571       java_lang_Class::is_primitive(super_mirror)) {
<span class="line-modified"> 572     jboolean ret = (sub_mirror == super_mirror);</span>
 573 
 574     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 575     return ret;
 576   }
 577   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 578   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 579   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 580   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 581                    JNI_TRUE : JNI_FALSE;
 582 
 583   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 584   return ret;
 585 JNI_END
 586 
 587 
 588 DT_RETURN_MARK_DECL(Throw, jint
 589                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 590 
 591 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 592   JNIWrapper(&quot;Throw&quot;);
</pre>
<hr />
<pre>
 678                                 THREAD);
 679         // If an exception is thrown in the call it gets thrown away. Not much
 680         // we can do with it. The native code that calls this, does not check
 681         // for the exception - hence, it might still be in the thread when DestroyVM gets
 682         // called, potentially causing a few asserts to trigger - since no pending exception
 683         // is expected.
 684         CLEAR_PENDING_EXCEPTION;
 685       } else {
 686         ResourceMark rm(THREAD);
 687         jio_fprintf(defaultStream::error_stream(),
 688         &quot;. Uncaught exception of type %s.&quot;,
 689         ex-&gt;klass()-&gt;external_name());
 690       }
 691     }
 692   }
 693 
 694   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 695 JNI_END
 696 
 697 
<span class="line-modified"> 698 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))</span>
 699   JNIWrapper(&quot;ExceptionClear&quot;);
 700 
 701   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 702 
 703   // The jni code might be using this API to clear java thrown exception.
 704   // So just mark jvmti thread exception state as exception caught.
 705   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 706   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 707     state-&gt;set_exception_caught();
 708   }
 709   thread-&gt;clear_pending_exception();
 710 
 711   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 712 JNI_END
 713 
 714 
 715 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 716   JNIWrapper(&quot;FatalError&quot;);
 717 
 718   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
</pre>
<hr />
<pre>
 775   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 776 
 777   Handle ref_handle(thread, JNIHandles::resolve(ref));
 778   jobject ret = JNIHandles::make_global(ref_handle);
 779 
 780   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 781   return ret;
 782 JNI_END
 783 
 784 // Must be JNI_ENTRY (with HandleMark)
 785 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 786   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 787 
 788   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 789 
 790   JNIHandles::destroy_global(ref);
 791 
 792   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 793 JNI_END
 794 
<span class="line-modified"> 795 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))</span>
 796   JNIWrapper(&quot;DeleteLocalRef&quot;);
 797 
 798   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 799 
 800   JNIHandles::destroy_local(obj);
 801 
 802   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 803 JNI_END
 804 
<span class="line-modified"> 805 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))</span>
 806   JNIWrapper(&quot;IsSameObject&quot;);
 807 
 808   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 809 
 810   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 811 
 812   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 813   return ret;
 814 JNI_END
 815 
 816 
 817 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 818   JNIWrapper(&quot;NewLocalRef&quot;);
 819 
 820   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 821 
 822   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 823 
 824   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 825   return ret;
</pre>
<hr />
<pre>
 845 // Return the Handle Type
 846 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 847   JNIWrapper(&quot;GetObjectRefType&quot;);
 848 
 849   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 850 
 851   jobjectRefType ret = JNIInvalidRefType;
 852   if (obj != NULL) {
 853     ret = JNIHandles::handle_type(thread, obj);
 854   }
 855 
 856   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 857   return ret;
 858 JNI_END
 859 
 860 
 861 class JNI_ArgumentPusher : public SignatureIterator {
 862  protected:
 863   JavaCallArguments*  _arguments;
 864 
<span class="line-modified"> 865   void push_int(jint x)         { _arguments-&gt;push_int(x); }</span>
<span class="line-modified"> 866   void push_long(jlong x)       { _arguments-&gt;push_long(x); }</span>
<span class="line-modified"> 867   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }</span>
<span class="line-modified"> 868   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }</span>
<span class="line-modified"> 869   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }</span>
<span class="line-modified"> 870 </span>
<span class="line-modified"> 871   void push_boolean(jboolean b) {</span>
<span class="line-modified"> 872     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-modified"> 873     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-modified"> 874     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-modified"> 875     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-modified"> 876     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);</span>
<span class="line-added"> 877   }</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879   JNI_ArgumentPusher(Method* method)</span>
<span class="line-added"> 880     : SignatureIterator(method-&gt;signature(),</span>
<span class="line-added"> 881                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())</span>
<span class="line-added"> 882   {</span>
 883     _arguments = NULL;
 884   }
 885 
 886  public:
<span class="line-modified"> 887   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;</span>

















 888 };
 889 
 890 
 891 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 892  protected:
 893   va_list _ap;
 894 
<span class="line-modified"> 895   void set_ap(va_list rap) {</span>
<span class="line-modified"> 896     va_copy(_ap, rap);</span>





 897   }




 898 
<span class="line-modified"> 899   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added"> 900   void do_type(BasicType type) {</span>
<span class="line-added"> 901     switch (type) {</span>
<span class="line-added"> 902     // these are coerced to int when using va_arg</span>
<span class="line-added"> 903     case T_BYTE:</span>
<span class="line-added"> 904     case T_CHAR:</span>
<span class="line-added"> 905     case T_SHORT:</span>
<span class="line-added"> 906     case T_INT:         push_int(va_arg(_ap, jint)); break;</span>
<span class="line-added"> 907     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;</span>
 908 
<span class="line-modified"> 909     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>



 910 
<span class="line-modified"> 911     case T_LONG:        push_long(va_arg(_ap, jlong)); break;</span>
<span class="line-modified"> 912     // float is coerced to double w/ va_arg</span>
<span class="line-added"> 913     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;</span>
<span class="line-added"> 914     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     case T_ARRAY:</span>
<span class="line-added"> 917     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>
<span class="line-added"> 918     default:            ShouldNotReachHere();</span>
<span class="line-added"> 919     }</span>
 920   }
 921 
 922  public:




 923   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<span class="line-modified"> 924       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
 925     set_ap(rap);
 926   }
 927 
<span class="line-modified"> 928   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="line-modified"> 929     _arguments = arguments;</span>
<span class="line-modified"> 930     do_parameters_on(this);</span>














































 931   }
 932 };
 933 
 934 
 935 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 936  protected:
 937   const jvalue *_ap;
 938 


















 939   inline void set_ap(const jvalue *rap) { _ap = rap; }
 940 
<span class="line-modified"> 941   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 942   void do_type(BasicType type) {</span>
<span class="line-modified"> 943     switch (type) {</span>
<span class="line-modified"> 944     case T_CHAR:        push_int((_ap++)-&gt;c); break;</span>
<span class="line-added"> 945     case T_SHORT:       push_int((_ap++)-&gt;s); break;</span>
<span class="line-added"> 946     case T_BYTE:        push_int((_ap++)-&gt;b); break;</span>
<span class="line-added"> 947     case T_INT:         push_int((_ap++)-&gt;i); break;</span>
<span class="line-added"> 948     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;</span>
<span class="line-added"> 949     case T_LONG:        push_long((_ap++)-&gt;j); break;</span>
<span class="line-added"> 950     case T_FLOAT:       push_float((_ap++)-&gt;f); break;</span>
<span class="line-added"> 951     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;</span>
<span class="line-added"> 952     case T_ARRAY:</span>
<span class="line-added"> 953     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>
<span class="line-added"> 954     default:            ShouldNotReachHere();</span>
<span class="line-added"> 955     }</span>
 956   }
<span class="line-added"> 957 </span>
<span class="line-added"> 958  public:</span>
 959   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<span class="line-modified"> 960       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
 961     set_ap(rap);
 962   }
 963 
<span class="line-modified"> 964   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="line-modified"> 965     _arguments = arguments;</span>
<span class="line-modified"> 966     do_parameters_on(this);</span>













































 967   }
 968 };
 969 
 970 
 971 enum JNICallType {
 972   JNI_STATIC,
 973   JNI_VIRTUAL,
 974   JNI_NONVIRTUAL
 975 };
 976 
 977 
 978 
 979 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 980   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 981 
 982   // Create object to hold arguments for the JavaCall, and associate it with
 983   // the jni parser
 984   ResourceMark rm(THREAD);
 985   int number_of_parameters = method-&gt;size_of_parameters();
 986   JavaCallArguments java_args(number_of_parameters);

 987 
 988   assert(method-&gt;is_static(), &quot;method should be static&quot;);
 989 
 990   // Fill out JavaCallArguments object
<span class="line-modified"> 991   args-&gt;push_arguments_on(&amp;java_args);</span>
 992   // Initialize result type
<span class="line-modified"> 993   result-&gt;set_type(args-&gt;return_type());</span>
 994 
 995   // Invoke the method. Result is returned as oop.
 996   JavaCalls::call(result, method, &amp;java_args, CHECK);
 997 
 998   // Convert result
<span class="line-modified"> 999   if (is_reference_type(result-&gt;get_type())) {</span>
1000     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1001   }
1002 }
1003 
1004 
1005 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1006   oop recv = JNIHandles::resolve(receiver);
1007   if (recv == NULL) {
1008     THROW(vmSymbols::java_lang_NullPointerException());
1009   }
1010   Handle h_recv(THREAD, recv);
1011 
1012   int number_of_parameters;
1013   Method* selected_method;
1014   {
1015     Method* m = Method::resolve_jmethod_id(method_id);
1016     number_of_parameters = m-&gt;size_of_parameters();
1017     Klass* holder = m-&gt;method_holder();
1018     if (call_type != JNI_VIRTUAL) {
1019         selected_method = m;
</pre>
<hr />
<pre>
1027       if (vtbl_index != Method::nonvirtual_vtable_index) {
1028         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1029       } else {
1030         // final method
1031         selected_method = m;
1032       }
1033     } else {
1034       // interface call
1035       int itbl_index = m-&gt;itable_index();
1036       Klass* k = h_recv-&gt;klass();
1037       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1038     }
1039   }
1040 
1041   methodHandle method(THREAD, selected_method);
1042 
1043   // Create object to hold arguments for the JavaCall, and associate it with
1044   // the jni parser
1045   ResourceMark rm(THREAD);
1046   JavaCallArguments java_args(number_of_parameters);

1047 
1048   // handle arguments
1049   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<span class="line-modified">1050   java_args.push_oop(h_recv); // Push jobject handle</span>
1051 
1052   // Fill out JavaCallArguments object
<span class="line-modified">1053   args-&gt;push_arguments_on(&amp;java_args);</span>
1054   // Initialize result type
<span class="line-modified">1055   result-&gt;set_type(args-&gt;return_type());</span>
1056 
1057   // Invoke the method. Result is returned as oop.
1058   JavaCalls::call(result, method, &amp;java_args, CHECK);
1059 
1060   // Convert result
<span class="line-modified">1061   if (is_reference_type(result-&gt;get_type())) {</span>
1062     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1063   }
1064 }
1065 
1066 
1067 static instanceOop alloc_object(jclass clazz, TRAPS) {
1068   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1069   if (k == NULL) {
1070     ResourceMark rm(THREAD);
1071     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1072   }
1073   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1074   k-&gt;initialize(CHECK_NULL);
1075   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1076   return ih;
1077 }
1078 
1079 DT_RETURN_MARK_DECL(AllocObject, jobject
1080                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1081 
</pre>
<hr />
<pre>
1151   JNI_ArgumentPusherVaArg ap(methodID, args);
1152   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1153   va_end(args);
1154   return obj;
1155 JNI_END
1156 
1157 
1158 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1159   JNIWrapper(&quot;GetObjectClass&quot;);
1160 
1161   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1162 
1163   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1164   jclass ret =
1165     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1166 
1167   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1168   return ret;
1169 JNI_END
1170 
<span class="line-modified">1171 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))</span>
1172   JNIWrapper(&quot;IsInstanceOf&quot;);
1173 
1174   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1175 
1176   jboolean ret = JNI_TRUE;
1177   if (obj != NULL) {
1178     ret = JNI_FALSE;
1179     Klass* k = java_lang_Class::as_Klass(
1180       JNIHandles::resolve_non_null(clazz));
1181     if (k != NULL) {
1182       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1183     }
1184   }
1185 
1186   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1187   return ret;
1188 JNI_END
1189 
1190 
1191 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1192                                const char *sig, bool is_static, TRAPS) {
1193   // %%%% This code should probably just call into a method in the LinkResolver
1194   //
1195   // The class should have been loaded (we have an instance of the class
1196   // passed in) so the method and signature should already be in the symbol
1197   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1198   const char *name_to_probe = (name_str == NULL)
1199                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1200                         : name_str;
1201   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1202   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1203 
1204   if (name == NULL || signature == NULL) {
1205     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1206   }
1207 
<span class="line-added">1208   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="line-added">1209 </span>
1210   // Throw a NoSuchMethodError exception if we have an instance of a
1211   // primitive java.lang.Class
1212   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
<span class="line-modified">1213     ResourceMark rm;</span>
<span class="line-added">1214     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));</span>
1215   }
1216 


1217   // Make sure class is linked and initialized before handing id&#39;s out to
1218   // Method*s.
1219   klass-&gt;initialize(CHECK_NULL);
1220 
1221   Method* m;
1222   if (name == vmSymbols::object_initializer_name() ||
1223       name == vmSymbols::class_initializer_name()) {
1224     // Never search superclasses for constructors
1225     if (klass-&gt;is_instance_klass()) {
1226       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1227     } else {
1228       m = NULL;
1229     }
1230   } else {
1231     m = klass-&gt;lookup_method(name, signature);
1232     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1233       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1234     }
1235   }
1236   if (m == NULL || (m-&gt;is_static() != is_static)) {
<span class="line-modified">1237     ResourceMark rm;</span>
<span class="line-added">1238     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));</span>
1239   }
1240   return m-&gt;jmethod_id();
1241 }
1242 
1243 
1244 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1245           const char *name, const char *sig))
1246   JNIWrapper(&quot;GetMethodID&quot;);
1247   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1248   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1249   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1250   return ret;
1251 JNI_END
1252 
1253 
1254 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1255           const char *name, const char *sig))
1256   JNIWrapper(&quot;GetStaticMethodID&quot;);
1257   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1258   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
</pre>
<hr />
<pre>
1886   JNI_ArgumentPusherArray ap(methodID, args);
1887   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1888 JNI_END
1889 
1890 
1891 //
1892 // Accessing Fields
1893 //
1894 
1895 
1896 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1897                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1898 
1899 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1900           const char *name, const char *sig))
1901   JNIWrapper(&quot;GetFieldID&quot;);
1902   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1903   jfieldID ret = 0;
1904   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1905 
<span class="line-added">1906   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="line-added">1907 </span>
1908   // The class should have been loaded (we have an instance of the class
1909   // passed in) so the field and signature should already be in the symbol
1910   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1911   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1912   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1913   if (fieldname == NULL || signame == NULL) {
<span class="line-modified">1914     ResourceMark rm;</span>
<span class="line-added">1915     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));</span>
1916   }
<span class="line-modified">1917 </span>
1918   // Make sure class is initialized before handing id&#39;s out to fields
1919   k-&gt;initialize(CHECK_NULL);
1920 
1921   fieldDescriptor fd;
1922   if (!k-&gt;is_instance_klass() ||
1923       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
<span class="line-modified">1924     ResourceMark rm;</span>
<span class="line-added">1925     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));</span>
1926   }
1927 
1928   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1929   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1930   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
1931   return ret;
1932 JNI_END
1933 
1934 
1935 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1936   JNIWrapper(&quot;GetObjectField&quot;);
1937   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1938   oop o = JNIHandles::resolve_non_null(obj);
1939   Klass* k = o-&gt;klass();
1940   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1941   // Keep JVMTI addition small and only check enabled flag here.
1942   // jni_GetField_probe() assumes that is okay to create handles.
1943   if (JvmtiExport::should_post_field_access()) {
1944     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1945   }
1946   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
1947   jobject ret = JNIHandles::make_local(env, loaded_obj);
1948   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1949   return ret;
1950 JNI_END
1951 
1952 
1953 
1954 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1955   , EntryProbe, ReturnProbe) \
1956 \
1957   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1958   , ReturnProbe); \
1959 \
<span class="line-modified">1960 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \</span>
1961   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1962 \
1963   EntryProbe; \
1964   Return ret = 0;\
1965   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1966 \
1967   oop o = JNIHandles::resolve_non_null(obj); \
1968   Klass* k = o-&gt;klass(); \
1969   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
1970   /* Keep JVMTI addition small and only check enabled flag here.       */ \
1971   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
1972   /* and creates a ResetNoHandleMark.                                   */ \
1973   if (JvmtiExport::should_post_field_access()) { \
1974     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
1975   } \
1976   ret = o-&gt;Fieldname##_field(offset); \
1977   return ret; \
1978 JNI_END
1979 
1980 DEFINE_GETFIELD(jboolean, bool,   Boolean
</pre>
<hr />
<pre>
2011 }
2012 address jni_GetCharField_addr() {
2013   return (address)jni_GetCharField;
2014 }
2015 address jni_GetShortField_addr() {
2016   return (address)jni_GetShortField;
2017 }
2018 address jni_GetIntField_addr() {
2019   return (address)jni_GetIntField;
2020 }
2021 address jni_GetLongField_addr() {
2022   return (address)jni_GetLongField;
2023 }
2024 address jni_GetFloatField_addr() {
2025   return (address)jni_GetFloatField;
2026 }
2027 address jni_GetDoubleField_addr() {
2028   return (address)jni_GetDoubleField;
2029 }
2030 
<span class="line-modified">2031 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))</span>
2032   JNIWrapper(&quot;SetObjectField&quot;);
2033   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2034   oop o = JNIHandles::resolve_non_null(obj);
2035   Klass* k = o-&gt;klass();
2036   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2037   // Keep JVMTI addition small and only check enabled flag here.
2038   // jni_SetField_probe_nh() assumes that is not okay to create handles
2039   // and creates a ResetNoHandleMark.
2040   if (JvmtiExport::should_post_field_modification()) {
2041     jvalue field_value;
2042     field_value.l = value;
<span class="line-modified">2043     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);</span>
2044   }
2045   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2046   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2047 JNI_END
2048 
2049 
2050 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2051                         , EntryProbe, ReturnProbe) \
2052 \
<span class="line-modified">2053 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \</span>
2054   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2055 \
2056   EntryProbe; \
2057 \
2058   oop o = JNIHandles::resolve_non_null(obj); \
2059   Klass* k = o-&gt;klass(); \
2060   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2061   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2062   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2063   /* and creates a ResetNoHandleMark.                                   */ \
2064   if (JvmtiExport::should_post_field_modification()) { \
2065     jvalue field_value; \
2066     field_value.unionType = value; \
2067     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2068   } \
<span class="line-modified">2069   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \</span>
2070   o-&gt;Fieldname##_field_put(offset, value); \
2071   ReturnProbe; \
2072 JNI_END
2073 
<span class="line-modified">2074 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z</span>
2075                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2076                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
<span class="line-modified">2077 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b</span>
2078                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2079                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
<span class="line-modified">2080 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c</span>
2081                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2082                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
<span class="line-modified">2083 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s</span>
2084                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2085                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
<span class="line-modified">2086 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i</span>
2087                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2088                 HOTSPOT_JNI_SETINTFIELD_RETURN())
<span class="line-modified">2089 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j</span>
2090                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2091                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2092 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="line-modified">2093 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f</span>
2094                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2095                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
<span class="line-modified">2096 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d</span>
2097                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2098                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2099 
2100 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2101                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2102 
2103 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2104   JNIWrapper(&quot;ToReflectedField&quot;);
2105   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2106   jobject ret = NULL;
2107   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2108 
2109   fieldDescriptor fd;
2110   bool found = false;
2111   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2112 
2113   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2114 
2115   if (isStatic) {
2116     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
</pre>
<hr />
<pre>
2224 DEFINE_GETSTATICFIELD(jint,     int,    Int
2225                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2226 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2227                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2228 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2229 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2230                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2231 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2232                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2233 
2234 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2235   JNIWrapper(&quot;SetStaticObjectField&quot;);
2236  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2237   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2238   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2239   // Keep JVMTI addition small and only check enabled flag here.
2240   // jni_SetField_probe() assumes that is okay to create handles.
2241   if (JvmtiExport::should_post_field_modification()) {
2242     jvalue field_value;
2243     field_value.l = value;
<span class="line-modified">2244     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);</span>
2245   }
2246   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2247   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2248 JNI_END
2249 
2250 
2251 
2252 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2253                               , EntryProbe, ReturnProbe) \
2254 \
2255 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2256   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2257   EntryProbe; \
2258 \
2259   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2260   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2261   /* Keep JVMTI addition small and only check enabled flag here. */ \
2262   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2263   if (JvmtiExport::should_post_field_modification()) { \
2264     jvalue field_value; \
2265     field_value.unionType = value; \
2266     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2267   } \
<span class="line-modified">2268   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \</span>
2269   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2270   ReturnProbe;\
2271 JNI_END
2272 
<span class="line-modified">2273 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z</span>
2274                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2275                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
<span class="line-modified">2276 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b</span>
2277                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2278                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
<span class="line-modified">2279 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c</span>
2280                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2281                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
<span class="line-modified">2282 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s</span>
2283                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2284                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
<span class="line-modified">2285 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i</span>
2286                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2287                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
<span class="line-modified">2288 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j</span>
2289                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2290                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2291 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="line-modified">2292 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f</span>
2293                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2294                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
<span class="line-modified">2295 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d</span>
2296                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2297                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2298 
2299 //
2300 // String Operations
2301 //
2302 
2303 // Unicode Interface
2304 
2305 DT_RETURN_MARK_DECL(NewString, jstring
2306                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2307 
2308 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2309   JNIWrapper(&quot;NewString&quot;);
2310  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2311   jstring ret = NULL;
2312   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2313   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2314   ret = (jstring) JNIHandles::make_local(env, string);
2315   return ret;
2316 JNI_END
2317 
2318 
<span class="line-modified">2319 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))</span>
2320   JNIWrapper(&quot;GetStringLength&quot;);
2321   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2322   jsize ret = 0;
2323   oop s = JNIHandles::resolve_non_null(string);
2324   ret = java_lang_String::length(s);
2325  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2326   return ret;
2327 JNI_END
2328 
2329 
<span class="line-modified">2330 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(</span>
2331   JNIEnv *env, jstring string, jboolean *isCopy))
2332   JNIWrapper(&quot;GetStringChars&quot;);
2333  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2334   jchar* buf = NULL;
2335   oop s = JNIHandles::resolve_non_null(string);
2336   typeArrayOop s_value = java_lang_String::value(s);
2337   if (s_value != NULL) {
2338     int s_len = java_lang_String::length(s, s_value);
2339     bool is_latin1 = java_lang_String::is_latin1(s);
2340     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2341     /* JNI Specification states return NULL on OOM */
2342     if (buf != NULL) {
2343       if (s_len &gt; 0) {
2344         if (!is_latin1) {
2345           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2346                                              buf, s_len);
2347         } else {
2348           for (int i = 0; i &lt; s_len; i++) {
2349             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2350           }
2351         }
2352       }
2353       buf[s_len] = 0;
2354       //%note jni_5
2355       if (isCopy != NULL) {
2356         *isCopy = JNI_TRUE;
2357       }
2358     }
2359   }
2360   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2361   return buf;
2362 JNI_END
2363 
2364 
<span class="line-modified">2365 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))</span>
2366   JNIWrapper(&quot;ReleaseStringChars&quot;);
2367   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2368   //%note jni_6
2369   if (chars != NULL) {
2370     // Since String objects are supposed to be immutable, don&#39;t copy any
2371     // new data back.  A bad user will have to go after the char array.
2372     FreeHeap((void*) chars);
2373   }
2374   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2375 JNI_END
2376 
2377 
2378 // UTF Interface
2379 
2380 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2381                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2382 
2383 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2384   JNIWrapper(&quot;NewStringUTF&quot;);
2385   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
</pre>
<hr />
<pre>
2417       if (isCopy != NULL) {
2418         *isCopy = JNI_TRUE;
2419       }
2420     }
2421   }
2422  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2423   return result;
2424 JNI_END
2425 
2426 
2427 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2428   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2429  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2430   if (chars != NULL) {
2431     FreeHeap((char*) chars);
2432   }
2433 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2434 JNI_END
2435 
2436 
<span class="line-modified">2437 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))</span>
2438   JNIWrapper(&quot;GetArrayLength&quot;);
2439  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2440   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2441   assert(a-&gt;is_array(), &quot;must be array&quot;);
2442   jsize ret = a-&gt;length();
2443  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2444   return ret;
2445 JNI_END
2446 
2447 
2448 //
2449 // Object Array Operations
2450 //
2451 
2452 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2453                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2454 
2455 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2456   JNIWrapper(&quot;NewObjectArray&quot;);
2457  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
</pre>
<hr />
<pre>
2574 
2575 static char* get_bad_address() {
2576   static char* bad_address = NULL;
2577   if (bad_address == NULL) {
2578     size_t size = os::vm_allocation_granularity();
2579     bad_address = os::reserve_memory(size);
2580     if (bad_address != NULL) {
2581       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2582                          /*is_committed*/false);
2583       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2584     }
2585   }
2586   return bad_address;
2587 }
2588 
2589 
2590 
2591 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2592                                       , EntryProbe, ReturnProbe) \
2593 \
<span class="line-modified">2594 JNI_ENTRY_NO_PRESERVE(ElementType*, \</span>
2595           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2596   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2597   EntryProbe; \
2598   /* allocate an chunk of memory in c land */ \
2599   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2600   ElementType* result; \
2601   int len = a-&gt;length(); \
2602   if (len == 0) { \
2603     if (isCopy != NULL) { \
2604       *isCopy = JNI_FALSE; \
2605     } \
2606     /* Empty array: legal but useless, can&#39;t return NULL. \
2607      * Return a pointer to something useless. \
2608      * Avoid asserts in typeArrayOop. */ \
2609     result = (ElementType*)get_bad_address(); \
2610   } else { \
2611     /* JNI Specification states return NULL on OOM */                    \
2612     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2613     if (result != NULL) {                                                \
2614       /* copy the array to the c chunk */                                \
</pre>
<hr />
<pre>
2636                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2637                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2638 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2639                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2640                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2641 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2642                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2643                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2644 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2645 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2646                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2647                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2648 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2649                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2650                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2651 
2652 
2653 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2654                                           , EntryProbe, ReturnProbe);\
2655 \
<span class="line-modified">2656 JNI_ENTRY_NO_PRESERVE(void, \</span>
2657           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2658                                              ElementType *buf, jint mode)) \
2659   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2660   EntryProbe; \
2661   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2662   int len = a-&gt;length(); \
2663   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2664     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2665       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2666     } \
2667     if ((mode == 0) || (mode == JNI_ABORT)) { \
2668       FreeHeap(buf); \
2669     } \
2670   } \
2671   ReturnProbe; \
2672 JNI_END
2673 
2674 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2675                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2676                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
</pre>
<hr />
<pre>
2781 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2782                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2783                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2784 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2785                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2786                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2787 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2788                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2789                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2790 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2791                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2792                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2793 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2794                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2795                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2796 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2797                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2798                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2799 
2800 

















































































2801 DT_RETURN_MARK_DECL(RegisterNatives, jint
2802                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2803 
2804 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2805                                     const JNINativeMethod *methods,
2806                                     jint nMethods))
2807   JNIWrapper(&quot;RegisterNatives&quot;);
2808   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2809   jint ret = 0;
2810   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2811 
2812   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2813 
<span class="line-added">2814   // There are no restrictions on native code registering native methods, which</span>
<span class="line-added">2815   // allows agents to redefine the bindings to native methods. But we issue a</span>
<span class="line-added">2816   // warning if any code running outside of the boot/platform loader is rebinding</span>
<span class="line-added">2817   // any native methods in classes loaded by the boot/platform loader.</span>
<span class="line-added">2818   Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="line-added">2819   bool do_warning = false;</span>
<span class="line-added">2820   oop cl = k-&gt;class_loader();</span>
<span class="line-added">2821   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {</span>
<span class="line-added">2822     // If no caller class, or caller class has a different loader, then</span>
<span class="line-added">2823     // issue a warning below.</span>
<span class="line-added">2824     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="line-added">2825   }</span>
<span class="line-added">2826 </span>
<span class="line-added">2827 </span>
2828   for (int index = 0; index &lt; nMethods; index++) {
2829     const char* meth_name = methods[index].name;
2830     const char* meth_sig = methods[index].signature;
2831     int meth_name_len = (int)strlen(meth_name);
2832 
2833     // The class should have been loaded (we have an instance of the class
2834     // passed in) so the method and signature should already be in the symbol
2835     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2836     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2837     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2838 
2839     if (name == NULL || signature == NULL) {
<span class="line-modified">2840       ResourceMark rm(THREAD);</span>
2841       stringStream st;
2842       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2843       // Must return negative value on failure
2844       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2845     }
2846 
<span class="line-modified">2847     if (do_warning) {</span>
<span class="line-modified">2848       ResourceMark rm(THREAD);</span>
<span class="line-added">2849       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;</span>
<span class="line-added">2850               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);</span>
<span class="line-added">2851     }</span>
<span class="line-added">2852 </span>
<span class="line-added">2853     bool res = Method::register_native(k, name, signature,</span>
<span class="line-added">2854                                        (address) methods[index].fnPtr, THREAD);</span>
2855     if (!res) {
2856       ret = -1;
2857       break;
2858     }
2859   }
2860   return ret;
2861 JNI_END
2862 
2863 
2864 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2865   JNIWrapper(&quot;UnregisterNatives&quot;);
2866  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2867   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2868   //%note jni_2
2869   if (k-&gt;is_instance_klass()) {
2870     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2871       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2872       if (m-&gt;is_native()) {
2873         m-&gt;clear_native_function();
2874         m-&gt;set_signature_handler(NULL);
</pre>
<hr />
<pre>
3073 
3074 
3075 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3076   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3077  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3078   Handle ref_handle(thread, JNIHandles::resolve(ref));
3079   jweak ret = JNIHandles::make_weak_global(ref_handle);
3080  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3081   return ret;
3082 JNI_END
3083 
3084 // Must be JNI_ENTRY (with HandleMark)
3085 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3086   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3087   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3088   JNIHandles::destroy_weak_global(ref);
3089   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3090 JNI_END
3091 
3092 
<span class="line-modified">3093 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))</span>
3094   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3095  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3096   jni_check_async_exceptions(thread);
3097   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3098  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3099   return ret;
3100 JNI_END
3101 
3102 
3103 // Initialization state for three routines below relating to
3104 // java.nio.DirectBuffers
3105 static          int directBufferSupportInitializeStarted = 0;
3106 static volatile int directBufferSupportInitializeEnded   = 0;
3107 static volatile int directBufferSupportInitializeFailed  = 0;
3108 static jclass    bufferClass                 = NULL;
3109 static jclass    directBufferClass           = NULL;
3110 static jclass    directByteBufferClass       = NULL;
3111 static jmethodID directByteBufferConstructor = NULL;
3112 static jfieldID  directBufferAddressField    = NULL;
3113 static jfieldID  bufferCapacityField         = NULL;
3114 
3115 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3116   Handle loader;            // null (bootstrap) loader
3117   Handle protection_domain; // null protection domain
3118 
<span class="line-modified">3119   TempNewSymbol sym = SymbolTable::new_symbol(name);</span>
3120   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3121 
3122   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3123     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3124   }
3125   return result;
3126 }
3127 
3128 // These lookups are done with the NULL (bootstrap) ClassLoader to
3129 // circumvent any security checks that would be done by jni_FindClass.
3130 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3131 {
3132   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3133   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3134   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3135   return true;
3136 }
3137 JNI_END
3138 
3139 
3140 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3141   if (directBufferSupportInitializeFailed) {
3142     return false;
3143   }
3144 
<span class="line-modified">3145   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {</span>
3146     if (!lookupDirectBufferClasses(env)) {
3147       directBufferSupportInitializeFailed = 1;
3148       return false;
3149     }
3150 
3151     // Make global references for these
3152     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3153     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3154     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3155 
3156     // Get needed field and method IDs
3157     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3158     if (env-&gt;ExceptionCheck()) {
3159       env-&gt;ExceptionClear();
3160       directBufferSupportInitializeFailed = 1;
3161       return false;
3162     }
3163     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3164     if (env-&gt;ExceptionCheck()) {
3165       env-&gt;ExceptionClear();
</pre>
<hr />
<pre>
3581 
3582     jni_GetObjectRefType,
3583 
3584     // Module features
3585 
3586     jni_GetModule
3587 };
3588 
3589 
3590 // For jvmti use to modify jni function table.
3591 // Java threads in native contiues to run until it is transitioned
3592 // to VM at safepoint. Before the transition or before it is blocked
3593 // for safepoint it may access jni function table. VM could crash if
3594 // any java thread access the jni function table in the middle of memcpy.
3595 // To avoid this each function pointers are copied automically.
3596 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3597   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3598   intptr_t *a = (intptr_t *) jni_functions();
3599   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3600   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
<span class="line-modified">3601     Atomic::store(a++, *b++);</span>
3602   }
3603 }
3604 
3605 void quicken_jni_functions() {
3606   // Replace Get&lt;Primitive&gt;Field with fast versions
<span class="line-modified">3607   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {</span>

3608     address func;
3609     func = JNI_FastGetField::generate_fast_get_boolean_field();
3610     if (func != (address)-1) {
3611       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3612     }
3613     func = JNI_FastGetField::generate_fast_get_byte_field();
3614     if (func != (address)-1) {
3615       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3616     }
3617     func = JNI_FastGetField::generate_fast_get_char_field();
3618     if (func != (address)-1) {
3619       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3620     }
3621     func = JNI_FastGetField::generate_fast_get_short_field();
3622     if (func != (address)-1) {
3623       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3624     }
3625     func = JNI_FastGetField::generate_fast_get_int_field();
3626     if (func != (address)-1) {
3627       jni_NativeInterface.GetIntField = (GetIntField_t)func;
</pre>
<hr />
<pre>
3703   }
3704   return ret;
3705 }
3706 
3707 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3708                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3709 
3710 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3711   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3712 
3713   jint result = JNI_ERR;
3714   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3715 
3716   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3717   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3718   // but __sync_lock_test_and_set is not guaranteed to do what we want
3719   // on all architectures.  So we check it works before relying on it.
3720 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3721   {
3722     jint a = 0xcafebabe;
<span class="line-modified">3723     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);</span>
3724     void *c = &amp;a;
<span class="line-modified">3725     void *d = Atomic::xchg(&amp;c, &amp;b);</span>
3726     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3727     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3728   }
3729 #endif // ZERO &amp;&amp; ASSERT
3730 
3731   // At the moment it&#39;s only possible to have one Java VM,
3732   // since some of the runtime state is in global variables.
3733 
3734   // We cannot use our mutex locks here, since they only work on
3735   // Threads. We do an atomic compare and exchange to ensure only
3736   // one thread can call this method at a time
3737 
3738   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3739   // the add/dec implementations are dependent on whether we are running
3740   // on a multiprocessor Atomic::xchg does not have this problem.
<span class="line-modified">3741   if (Atomic::xchg(&amp;vm_created, 1) == 1) {</span>
3742     return JNI_EEXIST;   // already created, or create attempt in progress
3743   }
<span class="line-modified">3744   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {</span>
3745     return JNI_ERR;  // someone tried and failed and retry not allowed.
3746   }
3747 
3748   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3749 
3750   /**
3751    * Certain errors during initialization are recoverable and do not
3752    * prevent this method from being called again at a later time
3753    * (perhaps with different arguments).  However, at a certain
3754    * point during initialization if an error occurs we cannot allow
3755    * this function to be called again (or it will crash).  In those
3756    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3757    * sets safe_to_recreate_vm to 1, such that any new call to
3758    * JNI_CreateJavaVM will immediately fail using the above logic.
3759    */
3760   bool can_try_again = true;
3761 
3762   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3763   if (result == JNI_OK) {
3764     JavaThread *thread = JavaThread::current();
</pre>
<hr />
<pre>
3783       }
3784     }
3785 #endif
3786 
3787     // Notify JVMTI
3788     if (JvmtiExport::should_post_thread_life()) {
3789        JvmtiExport::post_thread_start(thread);
3790     }
3791 
3792     post_thread_start_event(thread);
3793 
3794 #ifndef PRODUCT
3795     if (ReplayCompiles) ciReplay::replay(thread);
3796 
3797     // Some platforms (like Win*) need a wrapper around these test
3798     // functions in order to properly handle error conditions.
3799     VMError::test_error_handler();
3800 #endif
3801 
3802     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
<span class="line-modified">3803     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
3804   } else {
3805     // If create_vm exits because of a pending exception, exit with that
3806     // exception.  In the future when we figure out how to reclaim memory,
3807     // we may be able to exit with JNI_ERR and allow the calling application
3808     // to continue.
3809     if (Universe::is_fully_initialized()) {
3810       // otherwise no pending exception possible - VM will already have aborted
3811       JavaThread* THREAD = JavaThread::current();
3812       if (HAS_PENDING_EXCEPTION) {
3813         HandleMark hm;
3814         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3815       }
3816     }
3817 
3818     if (can_try_again) {
3819       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3820       safe_to_recreate_vm = 1;
3821     }
3822 
3823     // Creation failed. We must reset vm_created
3824     *vm = 0;
3825     *(JNIEnv**)penv = 0;
3826     // reset vm_created last to avoid race condition. Use OrderAccess to
3827     // control both compiler and architectural-based reordering.
<span class="line-modified">3828     Atomic::release_store(&amp;vm_created, 0);</span>
3829   }
3830 
3831   // Flush stdout and stderr before exit.
3832   fflush(stdout);
3833   fflush(stderr);
3834 
3835   return result;
3836 
3837 }
3838 
3839 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
3840   jint result = JNI_ERR;
3841   // On Windows, let CreateJavaVM run with SEH protection
3842 #ifdef _WIN32
3843   __try {
3844 #endif
3845     result = JNI_CreateJavaVM_inner(vm, penv, args);
3846 #ifdef _WIN32
3847   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3848     // Nothing to do.
</pre>
<hr />
<pre>
3885   JNIWrapper(&quot;DestroyJavaVM&quot;);
3886   JNIEnv *env;
3887   JavaVMAttachArgs destroyargs;
3888   destroyargs.version = CurrentVersion;
3889   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
3890   destroyargs.group = NULL;
3891   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
3892   if (res != JNI_OK) {
3893     return res;
3894   }
3895 
3896   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
3897   JavaThread* thread = JavaThread::current();
3898   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
3899   if (Threads::destroy_vm()) {
3900     // Should not change thread state, VM is gone
3901     vm_created = 0;
3902     res = JNI_OK;
3903     return res;
3904   } else {
<span class="line-modified">3905     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
3906     res = JNI_ERR;
3907     return res;
3908   }
3909 }
3910 
3911 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
3912   jint result = JNI_ERR;
3913   // On Windows, we need SEH protection
3914 #ifdef _WIN32
3915   __try {
3916 #endif
3917     result = jni_DestroyJavaVM_inner(vm);
3918 #ifdef _WIN32
3919   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3920     // Nothing to do.
3921   }
3922 #endif
3923   return result;
3924 }
3925 
</pre>
<hr />
<pre>
3946 
3947   // Set correct safepoint info. The thread is going to call into Java when
3948   // initializing the Java level thread object. Hence, the correct state must
3949   // be set in order for the Safepoint code to deal with it correctly.
3950   thread-&gt;set_thread_state(_thread_in_vm);
3951   thread-&gt;record_stack_base_and_size();
3952   thread-&gt;register_thread_stack_with_NMT();
3953   thread-&gt;initialize_thread_current();
3954 
3955   if (!os::create_attached_thread(thread)) {
3956     thread-&gt;smr_delete();
3957     return JNI_ERR;
3958   }
3959   // Enable stack overflow checks
3960   thread-&gt;create_stack_guard_pages();
3961 
3962   thread-&gt;initialize_tlab();
3963 
3964   thread-&gt;cache_global_variables();
3965 
<span class="line-modified">3966   // This thread will not do a safepoint check, since it has</span>
3967   // not been added to the Thread list yet.
<span class="line-modified">3968   { MutexLocker ml(Threads_lock);</span>
3969     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
3970     // avoid this thread trying to do a GC before it is added to the thread-list
3971     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
3972     Threads::add(thread, daemon);

3973   }
3974   // Create thread group and name info from attach arguments
3975   oop group = NULL;
3976   char* thread_name = NULL;
3977   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
3978     group = JNIHandles::resolve(args-&gt;group);
3979     thread_name = args-&gt;name; // may be NULL
3980   }
3981   if (group == NULL) group = Universe::main_thread_group();
3982 
3983   // Create Java level thread object and attach it to this thread
3984   bool attach_failed = false;
3985   {
3986     EXCEPTION_MARK;
3987     HandleMark hm(THREAD);
3988     Handle thread_group(THREAD, group);
3989     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
3990     if (HAS_PENDING_EXCEPTION) {
3991       CLEAR_PENDING_EXCEPTION;
3992       // cleanup outside the handle mark.
3993       attach_failed = true;
3994     }
3995   }
3996 
3997   if (attach_failed) {
3998     // Added missing cleanup
<span class="line-modified">3999     thread-&gt;cleanup_failed_attach_current_thread(daemon);</span>
4000     return JNI_ERR;
4001   }
4002 
4003   // mark the thread as no longer attaching
4004   // this uses a fence to push the change through so we don&#39;t have
4005   // to regrab the threads_lock
4006   thread-&gt;set_done_attaching_via_jni();
4007 
4008   // Set java thread status.
4009   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4010               java_lang_Thread::RUNNABLE);
4011 
4012   // Notify the debugger
4013   if (JvmtiExport::should_post_thread_life()) {
4014     JvmtiExport::post_thread_start(thread);
4015   }
4016 
4017   post_thread_start_event(thread);
4018 
4019   *(JNIEnv**)penv = thread-&gt;jni_environment();
4020 
4021   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4022   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4023   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4024   // needed.
4025 
<span class="line-modified">4026   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
4027 
4028   // Perform any platform dependent FPU setup
4029   os::setup_fpu();
4030 
4031   return JNI_OK;
4032 }
4033 
4034 
4035 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4036   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4037   if (vm_created == 0) {
4038   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4039     return JNI_ERR;
4040   }
4041 
4042   JNIWrapper(&quot;AttachCurrentThread&quot;);
4043   jint ret = attach_current_thread(vm, penv, _args, false);
4044   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4045   return ret;
4046 }
</pre>
</td>
</tr>
</table>
<center><a href="forte.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
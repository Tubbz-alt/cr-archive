<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiTagMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiThreadState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 55   _hide_single_stepping = false;
 56   _hide_level           = 0;
 57   _pending_step_for_popframe = false;
 58   _class_being_redefined = NULL;
 59   _class_load_kind = jvmti_class_load_kind_load;
 60   _head_env_thread_state = NULL;
 61   _dynamic_code_event_collector = NULL;
 62   _vm_object_alloc_event_collector = NULL;
 63   _sampled_object_alloc_event_collector = NULL;
 64   _the_class_for_redefinition_verification = NULL;
 65   _scratch_class_for_redefinition_verification = NULL;
 66   _cur_stack_depth = UNKNOWN_STACK_DEPTH;
 67 
 68   // JVMTI ForceEarlyReturn support
 69   _pending_step_for_earlyret = false;
 70   _earlyret_state = earlyret_inactive;
 71   _earlyret_tos = ilgl;
 72   _earlyret_value.j = 0L;
 73   _earlyret_oop = NULL;
 74 


 75   // add all the JvmtiEnvThreadState to the new JvmtiThreadState
 76   {
 77     JvmtiEnvIterator it;
 78     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
 79       if (env-&gt;is_valid()) {
 80         add_env(env);
 81       }
 82     }
 83   }
 84 
 85   // link us into the list
 86   {
 87     // The thread state list manipulation code must not have safepoints.
 88     // See periodic_clean_up().
 89     debug_only(NoSafepointVerifier nosafepoint;)
 90 
 91     _prev = NULL;
 92     _next = _head;
 93     if (_head != NULL) {
 94       _head-&gt;_prev = this;
</pre>
<hr />
<pre>
380 
381   // If exception was thrown in this frame, need to reset jvmti thread state.
382   // Single stepping may not get enabled correctly by the agent since
383   // exception state is passed in MethodExit event which may be sent at some
384   // time in the future. JDWP agent ignores MethodExit events if caused by
385   // an exception.
386   //
387   if (is_exception_detected()) {
388     clear_exception_state();
389   }
390   // If step is pending for earlyret then it may not be a repeat step.
391   // The new_bci and method_id is same as current_bci and current
392   // method_id after earlyret and step for recursive calls.
393   // Force the step by clearing the last location.
394   JvmtiEnvThreadStateIterator it(this);
395   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
396     ets-&gt;clear_current_location();
397   }
398 }
399 
<span class="line-modified">400 void JvmtiThreadState::oops_do(OopClosure* f) {</span>
401   f-&gt;do_oop((oop*) &amp;_earlyret_oop);



































402 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 55   _hide_single_stepping = false;
 56   _hide_level           = 0;
 57   _pending_step_for_popframe = false;
 58   _class_being_redefined = NULL;
 59   _class_load_kind = jvmti_class_load_kind_load;
 60   _head_env_thread_state = NULL;
 61   _dynamic_code_event_collector = NULL;
 62   _vm_object_alloc_event_collector = NULL;
 63   _sampled_object_alloc_event_collector = NULL;
 64   _the_class_for_redefinition_verification = NULL;
 65   _scratch_class_for_redefinition_verification = NULL;
 66   _cur_stack_depth = UNKNOWN_STACK_DEPTH;
 67 
 68   // JVMTI ForceEarlyReturn support
 69   _pending_step_for_earlyret = false;
 70   _earlyret_state = earlyret_inactive;
 71   _earlyret_tos = ilgl;
 72   _earlyret_value.j = 0L;
 73   _earlyret_oop = NULL;
 74 
<span class="line-added"> 75   _jvmti_event_queue = NULL;</span>
<span class="line-added"> 76 </span>
 77   // add all the JvmtiEnvThreadState to the new JvmtiThreadState
 78   {
 79     JvmtiEnvIterator it;
 80     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
 81       if (env-&gt;is_valid()) {
 82         add_env(env);
 83       }
 84     }
 85   }
 86 
 87   // link us into the list
 88   {
 89     // The thread state list manipulation code must not have safepoints.
 90     // See periodic_clean_up().
 91     debug_only(NoSafepointVerifier nosafepoint;)
 92 
 93     _prev = NULL;
 94     _next = _head;
 95     if (_head != NULL) {
 96       _head-&gt;_prev = this;
</pre>
<hr />
<pre>
382 
383   // If exception was thrown in this frame, need to reset jvmti thread state.
384   // Single stepping may not get enabled correctly by the agent since
385   // exception state is passed in MethodExit event which may be sent at some
386   // time in the future. JDWP agent ignores MethodExit events if caused by
387   // an exception.
388   //
389   if (is_exception_detected()) {
390     clear_exception_state();
391   }
392   // If step is pending for earlyret then it may not be a repeat step.
393   // The new_bci and method_id is same as current_bci and current
394   // method_id after earlyret and step for recursive calls.
395   // Force the step by clearing the last location.
396   JvmtiEnvThreadStateIterator it(this);
397   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
398     ets-&gt;clear_current_location();
399   }
400 }
401 
<span class="line-modified">402 void JvmtiThreadState::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
403   f-&gt;do_oop((oop*) &amp;_earlyret_oop);
<span class="line-added">404 </span>
<span class="line-added">405   // Keep nmethods from unloading on the event queue</span>
<span class="line-added">406   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">407     _jvmti_event_queue-&gt;oops_do(f, cf);</span>
<span class="line-added">408   }</span>
<span class="line-added">409 }</span>
<span class="line-added">410 </span>
<span class="line-added">411 void JvmtiThreadState::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added">412   // Keep nmethods from unloading on the event queue</span>
<span class="line-added">413   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">414     _jvmti_event_queue-&gt;nmethods_do(cf);</span>
<span class="line-added">415   }</span>
<span class="line-added">416 }</span>
<span class="line-added">417 </span>
<span class="line-added">418 // Thread local event queue.</span>
<span class="line-added">419 void JvmtiThreadState::enqueue_event(JvmtiDeferredEvent* event) {</span>
<span class="line-added">420   if (_jvmti_event_queue == NULL) {</span>
<span class="line-added">421     _jvmti_event_queue = new JvmtiDeferredEventQueue();</span>
<span class="line-added">422   }</span>
<span class="line-added">423   // copy the event</span>
<span class="line-added">424   _jvmti_event_queue-&gt;enqueue(*event);</span>
<span class="line-added">425 }</span>
<span class="line-added">426 </span>
<span class="line-added">427 void JvmtiThreadState::post_events(JvmtiEnv* env) {</span>
<span class="line-added">428   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">429     _jvmti_event_queue-&gt;post(env);  // deletes each queue node</span>
<span class="line-added">430     delete _jvmti_event_queue;</span>
<span class="line-added">431     _jvmti_event_queue = NULL;</span>
<span class="line-added">432   }</span>
<span class="line-added">433 }</span>
<span class="line-added">434 </span>
<span class="line-added">435 void JvmtiThreadState::run_nmethod_entry_barriers() {</span>
<span class="line-added">436   if (_jvmti_event_queue != NULL) {</span>
<span class="line-added">437     _jvmti_event_queue-&gt;run_nmethod_entry_barriers();</span>
<span class="line-added">438   }</span>
439 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiTagMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
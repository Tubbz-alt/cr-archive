<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiImpl.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiLib.xsl.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiImpl.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51 // Used by JVMTI methods: none directly.
 52 //
 53 // GrowableCache is a permanent CHeap growable array of &lt;GrowableElement *&gt;
 54 //
 55 // In addition, the GrowableCache maintains a NULL terminated cache array of type address
 56 // that&#39;s created from the element array using the function:
 57 //     address GrowableElement::getCacheValue().
 58 //
 59 // Whenever the GrowableArray changes size, the cache array gets recomputed into a new C_HEAP allocated
 60 // block of memory. Additionally, every time the cache changes its position in memory, the
 61 //    void (*_listener_fun)(void *this_obj, address* cache)
 62 // gets called with the cache&#39;s new address. This gives the user of the GrowableCache a callback
 63 // to update its pointer to the address cache.
 64 //
 65 
 66 class GrowableElement : public CHeapObj&lt;mtInternal&gt; {
 67 public:
 68   virtual ~GrowableElement() {}
 69   virtual address getCacheValue()          =0;
 70   virtual bool equals(GrowableElement* e)  =0;
<span class="line-removed"> 71   virtual bool lessThan(GrowableElement *e)=0;</span>
 72   virtual GrowableElement *clone()         =0;
<span class="line-removed"> 73   virtual void oops_do(OopClosure* f)      =0;</span>
<span class="line-removed"> 74   virtual void metadata_do(void f(Metadata*)) =0;</span>
 75 };
 76 
 77 class GrowableCache {
 78 
 79 private:
 80   // Object pointer passed into cache &amp; listener functions.
 81   void *_this_obj;
 82 
 83   // Array of elements in the collection
 84   GrowableArray&lt;GrowableElement *&gt; *_elements;
 85 
 86   // Parallel array of cached values
 87   address *_cache;
 88 
 89   // Listener for changes to the _cache field.
 90   // Called whenever the _cache field has it&#39;s value changed
 91   // (but NOT when cached elements are recomputed).
 92   void (*_listener_fun)(void *, address*);
 93 
 94   static bool equals(void *, GrowableElement *);
 95 
 96   // recache all elements after size change, notify listener
 97   void recache();
 98 
 99 public:
100    GrowableCache();
101    ~GrowableCache();
102 
103   void initialize(void *this_obj, void listener_fun(void *, address*) );
104 
105   // number of elements in the collection
106   int length();
107   // get the value of the index element in the collection
108   GrowableElement* at(int index);
109   // find the index of the element, -1 if it doesn&#39;t exist
110   int find(GrowableElement* e);
111   // append a copy of the element to the end of the collection, notify listener
112   void append(GrowableElement* e);
<span class="line-removed">113   // insert a copy of the element using lessthan(), notify listener</span>
<span class="line-removed">114   void insert(GrowableElement* e);</span>
115   // remove the element at index, notify listener
116   void remove (int index);
117   // clear out all elements and release all heap space, notify listener
118   void clear();
<span class="line-removed">119   // apply f to every element and update the cache</span>
<span class="line-removed">120   void oops_do(OopClosure* f);</span>
<span class="line-removed">121   // walk metadata to preserve for RedefineClasses</span>
<span class="line-removed">122   void metadata_do(void f(Metadata*));</span>
<span class="line-removed">123   // update the cache after a full gc</span>
<span class="line-removed">124   void gc_epilogue();</span>
125 };
126 
127 
128 ///////////////////////////////////////////////////////////////
129 //
130 // class JvmtiBreakpointCache
131 // Used by              : JvmtiBreakpoints
132 // Used by JVMTI methods: none directly.
133 // Note   : typesafe wrapper for GrowableCache of JvmtiBreakpoint
134 //
135 
136 class JvmtiBreakpointCache : public CHeapObj&lt;mtInternal&gt; {
137 
138 private:
139   GrowableCache _cache;
140 
141 public:
142   JvmtiBreakpointCache()  {}
143   ~JvmtiBreakpointCache() {}
144 
145   void initialize(void *this_obj, void listener_fun(void *, address*) ) {
<span class="line-modified">146     _cache.initialize(this_obj,listener_fun);</span>
147   }
148 
149   int length()                          { return _cache.length(); }
150   JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
151   int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
152   void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
153   void remove (int index)               { _cache.remove(index); }
<span class="line-removed">154   void clear()                          { _cache.clear(); }</span>
<span class="line-removed">155   void oops_do(OopClosure* f)           { _cache.oops_do(f); }</span>
<span class="line-removed">156   void metadata_do(void f(Metadata*))   { _cache.metadata_do(f); }</span>
<span class="line-removed">157   void gc_epilogue()                    { _cache.gc_epilogue(); }</span>
158 };
159 
160 
161 ///////////////////////////////////////////////////////////////
162 //
163 // class JvmtiBreakpoint
164 // Used by              : JvmtiBreakpoints
165 // Used by JVMTI methods: SetBreakpoint, ClearBreakpoint, ClearAllBreakpoints
166 // Note: Extends GrowableElement for use in a GrowableCache
167 //
168 // A JvmtiBreakpoint describes a location (class, method, bci) to break at.
169 //
170 
171 typedef void (Method::*method_action)(int _bci);
172 
173 class JvmtiBreakpoint : public GrowableElement {
174 private:
175   Method*               _method;
176   int                   _bci;
<span class="line-modified">177   Bytecodes::Code       _orig_bytecode;</span>
<span class="line-removed">178   oop                   _class_holder;  // keeps _method memory from being deallocated</span>
179 
180 public:
<span class="line-modified">181   JvmtiBreakpoint();</span>
182   JvmtiBreakpoint(Method* m_method, jlocation location);

183   bool equals(JvmtiBreakpoint&amp; bp);
<span class="line-removed">184   bool lessThan(JvmtiBreakpoint &amp;bp);</span>
185   void copy(JvmtiBreakpoint&amp; bp);
<span class="line-removed">186   bool is_valid();</span>
187   address getBcp() const;
188   void each_method_version_do(method_action meth_act);
189   void set();
190   void clear();
191   void print_on(outputStream* out) const;
192 
193   Method* method() { return _method; }
194 
195   // GrowableElement implementation
196   address getCacheValue()         { return getBcp(); }
<span class="line-removed">197   bool lessThan(GrowableElement* e) { Unimplemented(); return false; }</span>
198   bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }
<span class="line-removed">199   void oops_do(OopClosure* f)     {</span>
<span class="line-removed">200     // Mark the method loader as live so the Method* class loader doesn&#39;t get</span>
<span class="line-removed">201     // unloaded and Method* memory reclaimed.</span>
<span class="line-removed">202     f-&gt;do_oop(&amp;_class_holder);</span>
<span class="line-removed">203   }</span>
<span class="line-removed">204   void metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">205     // walk metadata to preserve for RedefineClasses</span>
<span class="line-removed">206     f(_method);</span>
<span class="line-removed">207   }</span>
208 
209   GrowableElement *clone()        {
210     JvmtiBreakpoint *bp = new JvmtiBreakpoint();
211     bp-&gt;copy(*this);
212     return bp;
213   }
214 };
215 
216 
217 ///////////////////////////////////////////////////////////////
218 //
219 // class JvmtiBreakpoints
220 // Used by              : JvmtiCurrentBreakpoints
221 // Used by JVMTI methods: none directly
222 // Note: A Helper class
223 //
224 // JvmtiBreakpoints is a GrowableCache of JvmtiBreakpoint.
225 // All changes to the GrowableCache occur at a safepoint using VM_ChangeBreakpoints.
226 //
227 // Because _bps is only modified at safepoints, its possible to always use the
228 // cached byte code pointers from _bps without doing any synchronization (see JvmtiCurrentBreakpoints).
229 //
230 // It would be possible to make JvmtiBreakpoints a static class, but I&#39;ve made it
231 // CHeap allocated to emphasize its similarity to JvmtiFramePops.
232 //
233 
234 class JvmtiBreakpoints : public CHeapObj&lt;mtInternal&gt; {
235 private:
236 
237   JvmtiBreakpointCache _bps;
238 
239   // These should only be used by VM_ChangeBreakpoints
240   // to insure they only occur at safepoints.
241   // Todo: add checks for safepoint
242   friend class VM_ChangeBreakpoints;
243   void set_at_safepoint(JvmtiBreakpoint&amp; bp);
244   void clear_at_safepoint(JvmtiBreakpoint&amp; bp);
245 
<span class="line-removed">246   static void do_element(GrowableElement *e);</span>
<span class="line-removed">247 </span>
248 public:
249   JvmtiBreakpoints(void listener_fun(void *, address *));
250   ~JvmtiBreakpoints();
251 
252   int length();
<span class="line-removed">253   void oops_do(OopClosure* f);</span>
<span class="line-removed">254   void metadata_do(void f(Metadata*));</span>
255   void print();
256 
257   int  set(JvmtiBreakpoint&amp; bp);
258   int  clear(JvmtiBreakpoint&amp; bp);
259   void clearall_in_class_at_safepoint(Klass* klass);
<span class="line-removed">260   void gc_epilogue();</span>
261 };
262 
263 
264 ///////////////////////////////////////////////////////////////
265 //
266 // class JvmtiCurrentBreakpoints
267 //
268 // A static wrapper class for the JvmtiBreakpoints that provides:
269 // 1. a fast inlined function to check if a byte code pointer is a breakpoint (is_breakpoint).
270 // 2. a function for lazily creating the JvmtiBreakpoints class (this is not strictly necessary,
271 //    but I&#39;m copying the code from JvmtiThreadState which needs to lazily initialize
272 //    JvmtiFramePops).
273 // 3. An oops_do entry point for GC&#39;ing the breakpoint array.
274 //
275 
276 class JvmtiCurrentBreakpoints : public AllStatic {
277 
278 private:
279 
280   // Current breakpoints, lazily initialized by get_jvmti_breakpoints();
281   static JvmtiBreakpoints *_jvmti_breakpoints;
282 
283   // NULL terminated cache of byte-code pointers corresponding to current breakpoints.
284   // Updated only at safepoints (with listener_fun) when the cache is moved.
285   // It exists only to make is_breakpoint fast.
286   static address          *_breakpoint_list;
287   static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }
<span class="line-removed">288   static inline address *get_breakpoint_list()                     { return _breakpoint_list; }</span>
289 
290   // Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.
291   static void listener_fun(void *this_obj, address *cache);
292 
293 public:
294   static void initialize();
295   static void destroy();
296 
297   // lazily create _jvmti_breakpoints and _breakpoint_list
298   static JvmtiBreakpoints&amp; get_jvmti_breakpoints();
<span class="line-removed">299 </span>
<span class="line-removed">300   static void oops_do(OopClosure* f);</span>
<span class="line-removed">301   static void metadata_do(void f(Metadata*)) NOT_JVMTI_RETURN;</span>
<span class="line-removed">302   static void gc_epilogue();</span>
303 };
304 
305 ///////////////////////////////////////////////////////////////
306 //
307 // class VM_ChangeBreakpoints
308 // Used by              : JvmtiBreakpoints
309 // Used by JVMTI methods: none directly.
310 // Note: A Helper class.
311 //
312 // VM_ChangeBreakpoints implements a VM_Operation for ALL modifications to the JvmtiBreakpoints class.
313 //
314 
315 class VM_ChangeBreakpoints : public VM_Operation {
316 private:
317   JvmtiBreakpoints* _breakpoints;
318   int               _operation;
319   JvmtiBreakpoint*  _bp;
320 
321 public:
322   enum { SET_BREAKPOINT=0, CLEAR_BREAKPOINT=1 };
323 
324   VM_ChangeBreakpoints(int operation, JvmtiBreakpoint *bp) {
325     JvmtiBreakpoints&amp; current_bps = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
326     _breakpoints = &amp;current_bps;
327     _bp = bp;
328     _operation = operation;
329     assert(bp != NULL, &quot;bp != NULL&quot;);
330   }
331 
332   VMOp_Type type() const { return VMOp_ChangeBreakpoints; }
333   void doit();
<span class="line-removed">334   void oops_do(OopClosure* f);</span>
<span class="line-removed">335   void metadata_do(void f(Metadata*));</span>
336 };
337 
338 
339 ///////////////////////////////////////////////////////////////
340 // The get/set local operations must only be done by the VM thread
341 // because the interpreter version needs to access oop maps, which can
342 // only safely be done by the VM thread
343 //
344 // I&#39;m told that in 1.5 oop maps are now protected by a lock and
345 // we could get rid of the VM op
346 // However if the VM op is removed then the target thread must
347 // be suspended AND a lock will be needed to prevent concurrent
348 // setting of locals to the same java thread. This lock is needed
349 // to prevent compiledVFrames from trying to add deferred updates
350 // to the thread simultaneously.
351 //
352 class VM_GetOrSetLocal : public VM_Operation {
353  protected:
354   JavaThread* _thread;
355   JavaThread* _calling_thread;
</pre>
<hr />
<pre>
428 
429 
430 /**
431  * When a thread (such as the compiler thread or VM thread) cannot post a
432  * JVMTI event itself because the event needs to be posted from a Java
433  * thread, then it can defer the event to the Service thread for posting.
434  * The information needed to post the event is encapsulated into this class
435  * and then enqueued onto the JvmtiDeferredEventQueue, where the Service
436  * thread will pick it up and post it.
437  *
438  * This is currently only used for posting compiled-method-load and unload
439  * events, which we don&#39;t want posted from the compiler thread.
440  */
441 class JvmtiDeferredEvent {
442   friend class JvmtiDeferredEventQueue;
443  private:
444   typedef enum {
445     TYPE_NONE,
446     TYPE_COMPILED_METHOD_LOAD,
447     TYPE_COMPILED_METHOD_UNLOAD,
<span class="line-modified">448     TYPE_DYNAMIC_CODE_GENERATED</span>

449   } Type;
450 
451   Type _type;
452   union {
453     nmethod* compiled_method_load;
454     struct {
<span class="line-removed">455       nmethod* nm;</span>
456       jmethodID method_id;
457       const void* code_begin;
458     } compiled_method_unload;
459     struct {
460       const char* name;
461       const void* code_begin;
462       const void* code_end;
463     } dynamic_code_generated;



464   } _event_data;
465 
466   JvmtiDeferredEvent(Type t) : _type(t) {}
467 
468  public:
469 
470   JvmtiDeferredEvent() : _type(TYPE_NONE) {}
471 
472   // Factory methods
473   static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
474     NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-modified">475   static JvmtiDeferredEvent compiled_method_unload_event(nmethod* nm,</span>
476       jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
477   static JvmtiDeferredEvent dynamic_code_generated_event(
478       const char* name, const void* begin, const void* end)
479           NOT_JVMTI_RETURN_(JvmtiDeferredEvent());


480 
481   // Actually posts the event.
482   void post() NOT_JVMTI_RETURN;






483 };
484 
485 /**
486  * Events enqueued on this queue wake up the Service thread which dequeues
487  * and posts the events.  The Service_lock is required to be held
488  * when operating on the queue.
489  */
<span class="line-modified">490 class JvmtiDeferredEventQueue : AllStatic {</span>
491   friend class JvmtiDeferredEvent;
492  private:
493   class QueueNode : public CHeapObj&lt;mtInternal&gt; {
494    private:
495     JvmtiDeferredEvent _event;
496     QueueNode* _next;
497 
498    public:
499     QueueNode(const JvmtiDeferredEvent&amp; event)
500       : _event(event), _next(NULL) {}
501 
<span class="line-modified">502     const JvmtiDeferredEvent&amp; event() const { return _event; }</span>
503     QueueNode* next() const { return _next; }
504 
505     void set_next(QueueNode* next) { _next = next; }
506   };
507 
<span class="line-modified">508   static QueueNode* _queue_head;             // Hold Service_lock to access</span>
<span class="line-modified">509   static QueueNode* _queue_tail;             // Hold Service_lock to access</span>
510 
511  public:
<span class="line-modified">512   // Must be holding Service_lock when calling these</span>
<span class="line-modified">513   static bool has_events() NOT_JVMTI_RETURN_(false);</span>
<span class="line-modified">514   static void enqueue(const JvmtiDeferredEvent&amp; event) NOT_JVMTI_RETURN;</span>
<span class="line-modified">515   static JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>










516 };
517 
518 // Utility macro that checks for NULL pointers:
519 #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
520 
521 #endif // SHARE_PRIMS_JVMTIIMPL_HPP
</pre>
</td>
<td>
<hr />
<pre>
 51 // Used by JVMTI methods: none directly.
 52 //
 53 // GrowableCache is a permanent CHeap growable array of &lt;GrowableElement *&gt;
 54 //
 55 // In addition, the GrowableCache maintains a NULL terminated cache array of type address
 56 // that&#39;s created from the element array using the function:
 57 //     address GrowableElement::getCacheValue().
 58 //
 59 // Whenever the GrowableArray changes size, the cache array gets recomputed into a new C_HEAP allocated
 60 // block of memory. Additionally, every time the cache changes its position in memory, the
 61 //    void (*_listener_fun)(void *this_obj, address* cache)
 62 // gets called with the cache&#39;s new address. This gives the user of the GrowableCache a callback
 63 // to update its pointer to the address cache.
 64 //
 65 
 66 class GrowableElement : public CHeapObj&lt;mtInternal&gt; {
 67 public:
 68   virtual ~GrowableElement() {}
 69   virtual address getCacheValue()          =0;
 70   virtual bool equals(GrowableElement* e)  =0;

 71   virtual GrowableElement *clone()         =0;


 72 };
 73 
 74 class GrowableCache {
 75 
 76 private:
 77   // Object pointer passed into cache &amp; listener functions.
 78   void *_this_obj;
 79 
 80   // Array of elements in the collection
 81   GrowableArray&lt;GrowableElement *&gt; *_elements;
 82 
 83   // Parallel array of cached values
 84   address *_cache;
 85 
 86   // Listener for changes to the _cache field.
 87   // Called whenever the _cache field has it&#39;s value changed
 88   // (but NOT when cached elements are recomputed).
 89   void (*_listener_fun)(void *, address*);
 90 
 91   static bool equals(void *, GrowableElement *);
 92 
 93   // recache all elements after size change, notify listener
 94   void recache();
 95 
 96 public:
 97    GrowableCache();
 98    ~GrowableCache();
 99 
100   void initialize(void *this_obj, void listener_fun(void *, address*) );
101 
102   // number of elements in the collection
103   int length();
104   // get the value of the index element in the collection
105   GrowableElement* at(int index);
106   // find the index of the element, -1 if it doesn&#39;t exist
107   int find(GrowableElement* e);
108   // append a copy of the element to the end of the collection, notify listener
109   void append(GrowableElement* e);


110   // remove the element at index, notify listener
111   void remove (int index);
112   // clear out all elements and release all heap space, notify listener
113   void clear();






114 };
115 
116 
117 ///////////////////////////////////////////////////////////////
118 //
119 // class JvmtiBreakpointCache
120 // Used by              : JvmtiBreakpoints
121 // Used by JVMTI methods: none directly.
122 // Note   : typesafe wrapper for GrowableCache of JvmtiBreakpoint
123 //
124 
125 class JvmtiBreakpointCache : public CHeapObj&lt;mtInternal&gt; {
126 
127 private:
128   GrowableCache _cache;
129 
130 public:
131   JvmtiBreakpointCache()  {}
132   ~JvmtiBreakpointCache() {}
133 
134   void initialize(void *this_obj, void listener_fun(void *, address*) ) {
<span class="line-modified">135     _cache.initialize(this_obj, listener_fun);</span>
136   }
137 
138   int length()                          { return _cache.length(); }
139   JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
140   int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
141   void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
142   void remove (int index)               { _cache.remove(index); }




143 };
144 
145 
146 ///////////////////////////////////////////////////////////////
147 //
148 // class JvmtiBreakpoint
149 // Used by              : JvmtiBreakpoints
150 // Used by JVMTI methods: SetBreakpoint, ClearBreakpoint, ClearAllBreakpoints
151 // Note: Extends GrowableElement for use in a GrowableCache
152 //
153 // A JvmtiBreakpoint describes a location (class, method, bci) to break at.
154 //
155 
156 typedef void (Method::*method_action)(int _bci);
157 
158 class JvmtiBreakpoint : public GrowableElement {
159 private:
160   Method*               _method;
161   int                   _bci;
<span class="line-modified">162   oop*                  _class_holder;  // keeps _method memory from being deallocated</span>

163 
164 public:
<span class="line-modified">165   JvmtiBreakpoint() : _method(NULL), _bci(0), _class_holder(NULL) {}</span>
166   JvmtiBreakpoint(Method* m_method, jlocation location);
<span class="line-added">167   virtual ~JvmtiBreakpoint();</span>
168   bool equals(JvmtiBreakpoint&amp; bp);

169   void copy(JvmtiBreakpoint&amp; bp);

170   address getBcp() const;
171   void each_method_version_do(method_action meth_act);
172   void set();
173   void clear();
174   void print_on(outputStream* out) const;
175 
176   Method* method() { return _method; }
177 
178   // GrowableElement implementation
179   address getCacheValue()         { return getBcp(); }

180   bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }









181 
182   GrowableElement *clone()        {
183     JvmtiBreakpoint *bp = new JvmtiBreakpoint();
184     bp-&gt;copy(*this);
185     return bp;
186   }
187 };
188 
189 
190 ///////////////////////////////////////////////////////////////
191 //
192 // class JvmtiBreakpoints
193 // Used by              : JvmtiCurrentBreakpoints
194 // Used by JVMTI methods: none directly
195 // Note: A Helper class
196 //
197 // JvmtiBreakpoints is a GrowableCache of JvmtiBreakpoint.
198 // All changes to the GrowableCache occur at a safepoint using VM_ChangeBreakpoints.
199 //
200 // Because _bps is only modified at safepoints, its possible to always use the
201 // cached byte code pointers from _bps without doing any synchronization (see JvmtiCurrentBreakpoints).
202 //
203 // It would be possible to make JvmtiBreakpoints a static class, but I&#39;ve made it
204 // CHeap allocated to emphasize its similarity to JvmtiFramePops.
205 //
206 
207 class JvmtiBreakpoints : public CHeapObj&lt;mtInternal&gt; {
208 private:
209 
210   JvmtiBreakpointCache _bps;
211 
212   // These should only be used by VM_ChangeBreakpoints
213   // to insure they only occur at safepoints.
214   // Todo: add checks for safepoint
215   friend class VM_ChangeBreakpoints;
216   void set_at_safepoint(JvmtiBreakpoint&amp; bp);
217   void clear_at_safepoint(JvmtiBreakpoint&amp; bp);
218 


219 public:
220   JvmtiBreakpoints(void listener_fun(void *, address *));
221   ~JvmtiBreakpoints();
222 
223   int length();


224   void print();
225 
226   int  set(JvmtiBreakpoint&amp; bp);
227   int  clear(JvmtiBreakpoint&amp; bp);
228   void clearall_in_class_at_safepoint(Klass* klass);

229 };
230 
231 
232 ///////////////////////////////////////////////////////////////
233 //
234 // class JvmtiCurrentBreakpoints
235 //
236 // A static wrapper class for the JvmtiBreakpoints that provides:
237 // 1. a fast inlined function to check if a byte code pointer is a breakpoint (is_breakpoint).
238 // 2. a function for lazily creating the JvmtiBreakpoints class (this is not strictly necessary,
239 //    but I&#39;m copying the code from JvmtiThreadState which needs to lazily initialize
240 //    JvmtiFramePops).
241 // 3. An oops_do entry point for GC&#39;ing the breakpoint array.
242 //
243 
244 class JvmtiCurrentBreakpoints : public AllStatic {
245 
246 private:
247 
248   // Current breakpoints, lazily initialized by get_jvmti_breakpoints();
249   static JvmtiBreakpoints *_jvmti_breakpoints;
250 
251   // NULL terminated cache of byte-code pointers corresponding to current breakpoints.
252   // Updated only at safepoints (with listener_fun) when the cache is moved.
253   // It exists only to make is_breakpoint fast.
254   static address          *_breakpoint_list;
255   static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }

256 
257   // Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.
258   static void listener_fun(void *this_obj, address *cache);
259 
260 public:
261   static void initialize();
262   static void destroy();
263 
264   // lazily create _jvmti_breakpoints and _breakpoint_list
265   static JvmtiBreakpoints&amp; get_jvmti_breakpoints();




266 };
267 
268 ///////////////////////////////////////////////////////////////
269 //
270 // class VM_ChangeBreakpoints
271 // Used by              : JvmtiBreakpoints
272 // Used by JVMTI methods: none directly.
273 // Note: A Helper class.
274 //
275 // VM_ChangeBreakpoints implements a VM_Operation for ALL modifications to the JvmtiBreakpoints class.
276 //
277 
278 class VM_ChangeBreakpoints : public VM_Operation {
279 private:
280   JvmtiBreakpoints* _breakpoints;
281   int               _operation;
282   JvmtiBreakpoint*  _bp;
283 
284 public:
285   enum { SET_BREAKPOINT=0, CLEAR_BREAKPOINT=1 };
286 
287   VM_ChangeBreakpoints(int operation, JvmtiBreakpoint *bp) {
288     JvmtiBreakpoints&amp; current_bps = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
289     _breakpoints = &amp;current_bps;
290     _bp = bp;
291     _operation = operation;
292     assert(bp != NULL, &quot;bp != NULL&quot;);
293   }
294 
295   VMOp_Type type() const { return VMOp_ChangeBreakpoints; }
296   void doit();


297 };
298 
299 
300 ///////////////////////////////////////////////////////////////
301 // The get/set local operations must only be done by the VM thread
302 // because the interpreter version needs to access oop maps, which can
303 // only safely be done by the VM thread
304 //
305 // I&#39;m told that in 1.5 oop maps are now protected by a lock and
306 // we could get rid of the VM op
307 // However if the VM op is removed then the target thread must
308 // be suspended AND a lock will be needed to prevent concurrent
309 // setting of locals to the same java thread. This lock is needed
310 // to prevent compiledVFrames from trying to add deferred updates
311 // to the thread simultaneously.
312 //
313 class VM_GetOrSetLocal : public VM_Operation {
314  protected:
315   JavaThread* _thread;
316   JavaThread* _calling_thread;
</pre>
<hr />
<pre>
389 
390 
391 /**
392  * When a thread (such as the compiler thread or VM thread) cannot post a
393  * JVMTI event itself because the event needs to be posted from a Java
394  * thread, then it can defer the event to the Service thread for posting.
395  * The information needed to post the event is encapsulated into this class
396  * and then enqueued onto the JvmtiDeferredEventQueue, where the Service
397  * thread will pick it up and post it.
398  *
399  * This is currently only used for posting compiled-method-load and unload
400  * events, which we don&#39;t want posted from the compiler thread.
401  */
402 class JvmtiDeferredEvent {
403   friend class JvmtiDeferredEventQueue;
404  private:
405   typedef enum {
406     TYPE_NONE,
407     TYPE_COMPILED_METHOD_LOAD,
408     TYPE_COMPILED_METHOD_UNLOAD,
<span class="line-modified">409     TYPE_DYNAMIC_CODE_GENERATED,</span>
<span class="line-added">410     TYPE_CLASS_UNLOAD</span>
411   } Type;
412 
413   Type _type;
414   union {
415     nmethod* compiled_method_load;
416     struct {

417       jmethodID method_id;
418       const void* code_begin;
419     } compiled_method_unload;
420     struct {
421       const char* name;
422       const void* code_begin;
423       const void* code_end;
424     } dynamic_code_generated;
<span class="line-added">425     struct {</span>
<span class="line-added">426       const char* name;</span>
<span class="line-added">427     } class_unload;</span>
428   } _event_data;
429 
430   JvmtiDeferredEvent(Type t) : _type(t) {}
431 
432  public:
433 
434   JvmtiDeferredEvent() : _type(TYPE_NONE) {}
435 
436   // Factory methods
437   static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
438     NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-modified">439   static JvmtiDeferredEvent compiled_method_unload_event(</span>
440       jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
441   static JvmtiDeferredEvent dynamic_code_generated_event(
442       const char* name, const void* begin, const void* end)
443           NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-added">444   static JvmtiDeferredEvent class_unload_event(</span>
<span class="line-added">445       const char* name) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>
446 
447   // Actually posts the event.
448   void post() NOT_JVMTI_RETURN;
<span class="line-added">449   void post_compiled_method_load_event(JvmtiEnv* env) NOT_JVMTI_RETURN;</span>
<span class="line-added">450   void run_nmethod_entry_barriers() NOT_JVMTI_RETURN;</span>
<span class="line-added">451   // Sweeper support to keep nmethods from being zombied while in the queue.</span>
<span class="line-added">452   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
<span class="line-added">453   // GC support to keep nmethod from being unloaded while in the queue.</span>
<span class="line-added">454   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
455 };
456 
457 /**
458  * Events enqueued on this queue wake up the Service thread which dequeues
459  * and posts the events.  The Service_lock is required to be held
460  * when operating on the queue.
461  */
<span class="line-modified">462 class JvmtiDeferredEventQueue : public CHeapObj&lt;mtInternal&gt; {</span>
463   friend class JvmtiDeferredEvent;
464  private:
465   class QueueNode : public CHeapObj&lt;mtInternal&gt; {
466    private:
467     JvmtiDeferredEvent _event;
468     QueueNode* _next;
469 
470    public:
471     QueueNode(const JvmtiDeferredEvent&amp; event)
472       : _event(event), _next(NULL) {}
473 
<span class="line-modified">474     JvmtiDeferredEvent&amp; event() { return _event; }</span>
475     QueueNode* next() const { return _next; }
476 
477     void set_next(QueueNode* next) { _next = next; }
478   };
479 
<span class="line-modified">480   QueueNode* _queue_head;</span>
<span class="line-modified">481   QueueNode* _queue_tail;</span>
482 
483  public:
<span class="line-modified">484   JvmtiDeferredEventQueue() : _queue_head(NULL), _queue_tail(NULL) {}</span>
<span class="line-modified">485 </span>
<span class="line-modified">486   bool has_events() NOT_JVMTI_RETURN_(false);</span>
<span class="line-modified">487   JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>
<span class="line-added">488 </span>
<span class="line-added">489   // Post all events in the queue for the current Jvmti environment</span>
<span class="line-added">490   void post(JvmtiEnv* env) NOT_JVMTI_RETURN;</span>
<span class="line-added">491   void enqueue(JvmtiDeferredEvent event) NOT_JVMTI_RETURN;</span>
<span class="line-added">492   void run_nmethod_entry_barriers();</span>
<span class="line-added">493 </span>
<span class="line-added">494   // Sweeper support to keep nmethods from being zombied while in the queue.</span>
<span class="line-added">495   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
<span class="line-added">496   // GC support to keep nmethod from being unloaded while in the queue.</span>
<span class="line-added">497   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
498 };
499 
500 // Utility macro that checks for NULL pointers:
501 #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
502 
503 #endif // SHARE_PRIMS_JVMTIIMPL_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiLib.xsl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
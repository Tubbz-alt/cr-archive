<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiExport.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEventController.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiExport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,20 ***</span>
<span class="line-new-header">--- 22,22 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">+ #include &quot;classfile/moduleEntry.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  #include &quot;prims/jvmtiEventController.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,10 ***</span>
<span class="line-new-header">--- 57,11 ---</span>
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
  #include &quot;runtime/objectMonitor.inline.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-added">+ #include &quot;runtime/serviceThread.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,11 ***</span>
  bool              JvmtiExport::_can_access_local_variables                = false;
  bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
  bool              JvmtiExport::_can_modify_any_class                      = false;
  bool              JvmtiExport::_can_walk_any_space                        = false;
  
<span class="line-modified">! bool              JvmtiExport::_has_redefined_a_class                     = false;</span>
  bool              JvmtiExport::_all_dependencies_are_recorded             = false;
  
  //
  // field access management
  //
<span class="line-new-header">--- 303,11 ---</span>
  bool              JvmtiExport::_can_access_local_variables                = false;
  bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
  bool              JvmtiExport::_can_modify_any_class                      = false;
  bool              JvmtiExport::_can_walk_any_space                        = false;
  
<span class="line-modified">! uint64_t          JvmtiExport::_redefinition_count                        = 0;</span>
  bool              JvmtiExport::_all_dependencies_are_recorded             = false;
  
  //
  // field access management
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,11 ***</span>
          default:
            return JNI_EVERSION;  // unsupported minor version number
        }
        break;
      default:
<span class="line-modified">!       return JNI_EVERSION;  // unsupported major version number</span>
    }
  
    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
      JavaThread* current_thread = JavaThread::current();
      // transition code: native to VM
<span class="line-new-header">--- 382,14 ---</span>
          default:
            return JNI_EVERSION;  // unsupported minor version number
        }
        break;
      default:
<span class="line-modified">!       // Starting from 13 we do not care about minor version anymore</span>
<span class="line-added">+       if (major &lt; 13 || major &gt; Abstract_VM_Version::vm_major_version()) {</span>
<span class="line-added">+         return JNI_EVERSION;  // unsupported major version number</span>
<span class="line-added">+       }</span>
    }
  
    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
      JavaThread* current_thread = JavaThread::current();
      // transition code: native to VM
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1195,10 ***</span>
<span class="line-new-header">--- 1201,11 ---</span>
  bool              JvmtiExport::_can_post_field_modification               = false;
  bool              JvmtiExport::_can_post_method_entry                     = false;
  bool              JvmtiExport::_can_post_method_exit                      = false;
  bool              JvmtiExport::_can_pop_frame                             = false;
  bool              JvmtiExport::_can_force_early_return                    = false;
<span class="line-added">+ bool              JvmtiExport::_can_get_owned_monitor_info                = false;</span>
  
  bool              JvmtiExport::_early_vmstart_recorded                    = false;
  
  bool              JvmtiExport::_should_post_single_step                   = false;
  bool              JvmtiExport::_should_post_field_access                  = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1341,58 ***</span>
  
  void JvmtiExport::post_class_unload(Klass* klass) {
    if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
      return;
    }
<span class="line-modified">!   Thread *thread = Thread::current();</span>
    HandleMark hm(thread);
  
    EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
    if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-removed">-     assert(thread-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // get JavaThread for whom we are proxy</span>
<span class="line-removed">-     Thread *calling_thread = ((VMThread *)thread)-&gt;vm_operation()-&gt;calling_thread();</span>
<span class="line-removed">-     if (!calling_thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">-       // cannot post an event to a non-JavaThread</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     JavaThread *real_thread = (JavaThread *)calling_thread;</span>
  
      JvmtiEnvIterator it;
      for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
        if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
          continue;
        }
        if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-modified">!         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;,</span>
<span class="line-removed">-                   klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // do everything manually, since this is a proxy - needs special care</span>
<span class="line-removed">-         JNIEnv* jni_env = real_thread-&gt;jni_environment();</span>
<span class="line-removed">-         jthread jt = (jthread)JNIHandles::make_local(real_thread, real_thread-&gt;threadObj());</span>
<span class="line-removed">-         jclass jk = (jclass)JNIHandles::make_local(real_thread, klass-&gt;java_mirror());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Before we call the JVMTI agent, we have to set the state in the</span>
<span class="line-removed">-         // thread for which we are proxying.</span>
<span class="line-removed">-         JavaThreadState prev_state = real_thread-&gt;thread_state();</span>
<span class="line-removed">-         assert(((Thread *)real_thread)-&gt;is_ConcurrentGC_thread() ||</span>
<span class="line-removed">-                (real_thread-&gt;is_Java_thread() &amp;&amp; prev_state == _thread_blocked),</span>
<span class="line-removed">-                &quot;should be ConcurrentGCThread or JavaThread at safepoint&quot;);</span>
<span class="line-removed">-         real_thread-&gt;set_thread_state(_thread_in_native);</span>
  
          jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
          if (callback != NULL) {
<span class="line-modified">!           (*callback)(env-&gt;jvmti_external(), jni_env, jt, jk);</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         assert(real_thread-&gt;thread_state() == _thread_in_native,</span>
<span class="line-removed">-                &quot;JavaThread should be in native&quot;);</span>
<span class="line-removed">-         real_thread-&gt;set_thread_state(prev_state);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         JNIHandles::destroy_local(jk);</span>
<span class="line-removed">-         JNIHandles::destroy_local(jt);</span>
        }
      }
    }
  }
  
<span class="line-new-header">--- 1348,45 ---</span>
  
  void JvmtiExport::post_class_unload(Klass* klass) {
    if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
      return;
    }
<span class="line-modified">! </span>
<span class="line-added">+   // postings to the service thread so that it can perform them in a safe</span>
<span class="line-added">+   // context and in-order.</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   // JvmtiDeferredEvent copies the string.</span>
<span class="line-added">+   JvmtiDeferredEvent event = JvmtiDeferredEvent::class_unload_event(klass-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+   ServiceThread::enqueue_deferred_event(&amp;event);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiExport::post_class_unload_internal(const char* name) {</span>
<span class="line-added">+   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(Thread::current()-&gt;is_service_thread(), &quot;must be called from ServiceThread&quot;);</span>
<span class="line-added">+   JavaThread *thread = JavaThread::current();</span>
    HandleMark hm(thread);
  
    EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
    if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
  
      JvmtiEnvIterator it;
      for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
        if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
          continue;
        }
        if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
<span class="line-modified">!         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;, name));</span>
  
<span class="line-added">+         JvmtiEventMark jem(thread);</span>
<span class="line-added">+         JvmtiJavaThreadEventTransition jet(thread);</span>
          jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
          if (callback != NULL) {
<span class="line-modified">!           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), name);</span>
          }
        }
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1582,11 ***</span>
      // the address of a &quot;raw result&quot; and we just call into the interpreter to
      // convert this into a jvalue.
      if (!exception_exit) {
        oop oop_result;
        BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
<span class="line-modified">!       if (type == T_OBJECT || type == T_ARRAY) {</span>
          result = Handle(thread, oop_result);
        }
      }
  
      JvmtiEnvThreadStateIterator it(state);
<span class="line-new-header">--- 1576,11 ---</span>
      // the address of a &quot;raw result&quot; and we just call into the interpreter to
      // convert this into a jvalue.
      if (!exception_exit) {
        oop oop_result;
        BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
<span class="line-modified">!       if (is_reference_type(type)) {</span>
          result = Handle(thread, oop_result);
        }
      }
  
      JvmtiEnvThreadStateIterator it(state);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1986,37 ***</span>
  
  void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
    address location, Klass* field_klass, Handle object, jfieldID field,
    char sig_type, jvalue *value) {
  
<span class="line-modified">!   if (sig_type == &#39;I&#39; || sig_type == &#39;Z&#39; || sig_type == &#39;B&#39; || sig_type == &#39;C&#39; || sig_type == &#39;S&#39;) {</span>
      // &#39;I&#39; instructions are used for byte, char, short and int.
      // determine which it really is, and convert
      fieldDescriptor fd;
      bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
      // should be found (if not, leave as is)
      if (found) {
        jint ival = value-&gt;i;
        // convert value from int to appropriate type
        switch (fd.field_type()) {
        case T_BOOLEAN:
<span class="line-modified">!         sig_type = &#39;Z&#39;;</span>
          value-&gt;i = 0; // clear it
          value-&gt;z = (jboolean)ival;
          break;
        case T_BYTE:
<span class="line-modified">!         sig_type = &#39;B&#39;;</span>
          value-&gt;i = 0; // clear it
          value-&gt;b = (jbyte)ival;
          break;
        case T_CHAR:
<span class="line-modified">!         sig_type = &#39;C&#39;;</span>
          value-&gt;i = 0; // clear it
          value-&gt;c = (jchar)ival;
          break;
        case T_SHORT:
<span class="line-modified">!         sig_type = &#39;S&#39;;</span>
          value-&gt;i = 0; // clear it
          value-&gt;s = (jshort)ival;
          break;
        case T_INT:
          // nothing to do
<span class="line-new-header">--- 1980,39 ---</span>
  
  void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
    address location, Klass* field_klass, Handle object, jfieldID field,
    char sig_type, jvalue *value) {
  
<span class="line-modified">!   if (sig_type == JVM_SIGNATURE_INT || sig_type == JVM_SIGNATURE_BOOLEAN ||</span>
<span class="line-added">+       sig_type == JVM_SIGNATURE_BYTE || sig_type == JVM_SIGNATURE_CHAR ||</span>
<span class="line-added">+       sig_type == JVM_SIGNATURE_SHORT) {</span>
      // &#39;I&#39; instructions are used for byte, char, short and int.
      // determine which it really is, and convert
      fieldDescriptor fd;
      bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
      // should be found (if not, leave as is)
      if (found) {
        jint ival = value-&gt;i;
        // convert value from int to appropriate type
        switch (fd.field_type()) {
        case T_BOOLEAN:
<span class="line-modified">!         sig_type = JVM_SIGNATURE_BOOLEAN;</span>
          value-&gt;i = 0; // clear it
          value-&gt;z = (jboolean)ival;
          break;
        case T_BYTE:
<span class="line-modified">!         sig_type = JVM_SIGNATURE_BYTE;</span>
          value-&gt;i = 0; // clear it
          value-&gt;b = (jbyte)ival;
          break;
        case T_CHAR:
<span class="line-modified">!         sig_type = JVM_SIGNATURE_CHAR;</span>
          value-&gt;i = 0; // clear it
          value-&gt;c = (jchar)ival;
          break;
        case T_SHORT:
<span class="line-modified">!         sig_type = JVM_SIGNATURE_SHORT;</span>
          value-&gt;i = 0; // clear it
          value-&gt;s = (jshort)ival;
          break;
        case T_INT:
          // nothing to do
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2027,15 ***</span>
          break;
        }
      }
    }
  
<span class="line-modified">!   assert(sig_type != &#39;[&#39;, &quot;array should have sig_type == &#39;L&#39;&quot;);</span>
    bool handle_created = false;
  
    // convert oop to JNI handle.
<span class="line-modified">!   if (sig_type == &#39;L&#39;) {</span>
      handle_created = true;
      value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
    }
  
    post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
<span class="line-new-header">--- 2023,15 ---</span>
          break;
        }
      }
    }
  
<span class="line-modified">!   assert(sig_type != JVM_SIGNATURE_ARRAY, &quot;array should have sig_type == &#39;L&#39;&quot;);</span>
    bool handle_created = false;
  
    // convert oop to JNI handle.
<span class="line-modified">!   if (sig_type == JVM_SIGNATURE_CLASS) {</span>
      handle_created = true;
      value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
    }
  
    post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2145,21 ***</span>
      record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
      record-&gt;pcinfo[scope].numstackframes = numstackframes;
      int stackframe = 0;
      for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
        // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
<span class="line-modified">!       assert(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);</span>
        record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
        record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
        stackframe++;
      }
      scope++;
    }
    return record;
  }
  
  void JvmtiExport::post_compiled_method_load(nmethod *nm) {
    if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
      return;
    }
    JavaThread* thread = JavaThread::current();
  
<span class="line-new-header">--- 2141,22 ---</span>
      record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
      record-&gt;pcinfo[scope].numstackframes = numstackframes;
      int stackframe = 0;
      for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
        // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
<span class="line-modified">!       guarantee(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);</span>
        record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
        record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
        stackframe++;
      }
      scope++;
    }
    return record;
  }
  
  void JvmtiExport::post_compiled_method_load(nmethod *nm) {
<span class="line-added">+   guarantee(!nm-&gt;is_unloading(), &quot;nmethod isn&#39;t unloaded or unloading&quot;);</span>
    if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
      return;
    }
    JavaThread* thread = JavaThread::current();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2167,65 ***</span>
                   (&quot;[%s] method compile load event triggered&quot;,
                   JvmtiTrace::safe_get_thread_name(thread)));
  
    JvmtiEnvIterator it;
    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">!     if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
<span class="line-removed">-       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {</span>
<span class="line-removed">-         continue;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">-                 (&quot;[%s] class compile method load event sent %s.%s  &quot;,</span>
<span class="line-removed">-                 JvmtiTrace::safe_get_thread_name(thread),</span>
<span class="line-removed">-                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),</span>
<span class="line-removed">-                 (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));</span>
<span class="line-removed">-       ResourceMark rm(thread);</span>
<span class="line-removed">-       HandleMark hm(thread);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Add inlining information</span>
<span class="line-removed">-       jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);</span>
<span class="line-removed">-       // Pass inlining information through the void pointer</span>
<span class="line-removed">-       JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);</span>
<span class="line-removed">-       JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-removed">-       jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-removed">-       if (callback != NULL) {</span>
<span class="line-removed">-         (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),</span>
<span class="line-removed">-                     jem.code_size(), jem.code_data(), jem.map_length(),</span>
<span class="line-removed">-                     jem.map(), jem.compile_info());</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
  }
  
<span class="line-removed">- </span>
  // post a COMPILED_METHOD_LOAD event for a given environment
<span class="line-modified">! void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-modified">!                                             const void *code_begin, const jint map_length,</span>
<span class="line-modified">!                                             const jvmtiAddrLocationMap* map)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   if (env-&gt;phase() &lt;= JVMTI_PHASE_PRIMORDIAL) {</span>
      return;
    }
    JavaThread* thread = JavaThread::current();
<span class="line-removed">-   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-removed">-                  (&quot;[%s] method compile load event triggered (by GenerateEvents)&quot;,</span>
<span class="line-removed">-                  JvmtiTrace::safe_get_thread_name(thread)));</span>
<span class="line-removed">-   if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
  
<span class="line-modified">!     EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-modified">!               (&quot;[%s] class compile method load event sent (by GenerateEvents), jmethodID=&quot; PTR_FORMAT,</span>
<span class="line-modified">!                JvmtiTrace::safe_get_thread_name(thread), p2i(method)));</span>
  
<span class="line-modified">!     JvmtiEventMark jem(thread);</span>
<span class="line-modified">!     JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-modified">!     jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-modified">!     if (callback != NULL) {</span>
<span class="line-modified">!       (*callback)(env-&gt;jvmti_external(), method,</span>
<span class="line-modified">!                   length, code_begin, map_length,</span>
<span class="line-modified">!                   map, NULL);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">-   }</span>
  }
  
  void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
    assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
  
<span class="line-new-header">--- 2164,41 ---</span>
                   (&quot;[%s] method compile load event triggered&quot;,
                   JvmtiTrace::safe_get_thread_name(thread)));
  
    JvmtiEnvIterator it;
    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
<span class="line-modified">!     post_compiled_method_load(env, nm);</span>
    }
  }
  
  // post a COMPILED_METHOD_LOAD event for a given environment
<span class="line-modified">! void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, nmethod *nm) {</span>
<span class="line-modified">!   if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL || !env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;</span>
<span class="line-added">+   if (callback == NULL) {</span>
      return;
    }
    JavaThread* thread = JavaThread::current();
  
<span class="line-modified">!   EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,</span>
<span class="line-modified">!            (&quot;[%s] method compile load event sent %s.%s  &quot;,</span>
<span class="line-modified">!             JvmtiTrace::safe_get_thread_name(thread),</span>
<span class="line-added">+             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),</span>
<span class="line-added">+             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));</span>
<span class="line-added">+   ResourceMark rm(thread);</span>
<span class="line-added">+   HandleMark hm(thread);</span>
  
<span class="line-modified">!   // Add inlining information</span>
<span class="line-modified">!   jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);</span>
<span class="line-modified">!   // Pass inlining information through the void pointer</span>
<span class="line-modified">!   JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);</span>
<span class="line-modified">!   JvmtiJavaThreadEventTransition jet(thread);</span>
<span class="line-modified">!   (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),</span>
<span class="line-modified">!               jem.code_size(), jem.code_data(), jem.map_length(),</span>
<span class="line-modified">!               jem.map(), jem.compile_info());</span>
  }
  
  void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
    assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2260,14 ***</span>
      post_dynamic_code_generated_internal(name, code_begin, code_end);
    } else {
      // It may not be safe to post the event from this thread.  Defer all
      // postings to the service thread so that it can perform them in a safe
      // context and in-order.
<span class="line-removed">-     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
      JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
          name, code_begin, code_end);
<span class="line-modified">!     JvmtiDeferredEventQueue::enqueue(event);</span>
    }
  }
  
  
  // post a DYNAMIC_CODE_GENERATED event for a given environment
<span class="line-new-header">--- 2233,13 ---</span>
      post_dynamic_code_generated_internal(name, code_begin, code_end);
    } else {
      // It may not be safe to post the event from this thread.  Defer all
      // postings to the service thread so that it can perform them in a safe
      // context and in-order.
      JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
          name, code_begin, code_end);
<span class="line-modified">!     ServiceThread::enqueue_deferred_event(&amp;event);</span>
    }
  }
  
  
  // post a DYNAMIC_CODE_GENERATED event for a given environment
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2296,11 ***</span>
  // post a DynamicCodeGenerated event while holding locks in the VM.
  void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
                                                                    address code_begin, address code_end)
  {
    // register the stub with the current dynamic code event collector
<span class="line-modified">!   JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());</span>
    // state can only be NULL if the current thread is exiting which
    // should not happen since we&#39;re trying to post an event
    guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
    JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
    guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
<span class="line-new-header">--- 2268,13 ---</span>
  // post a DynamicCodeGenerated event while holding locks in the VM.
  void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
                                                                    address code_begin, address code_end)
  {
    // register the stub with the current dynamic code event collector
<span class="line-modified">!   // Cannot take safepoint here so do not use state_for to get</span>
<span class="line-added">+   // jvmti thread state.</span>
<span class="line-added">+   JvmtiThreadState* state = JavaThread::current()-&gt;jvmti_thread_state();</span>
    // state can only be NULL if the current thread is exiting which
    // should not happen since we&#39;re trying to post an event
    guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
    JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
    guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2311,11 ***</span>
  void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
    Thread* thread = Thread::current_or_null();
    if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
      // Can not take safepoint here.
      NoSafepointVerifier no_sfpt;
<span class="line-modified">!     // Can not take safepoint here so can not use state_for to get</span>
      // jvmti thread state.
      JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
      if (state != NULL) {
        // state is non NULL when VMObjectAllocEventCollector is enabled.
        JvmtiVMObjectAllocEventCollector *collector;
<span class="line-new-header">--- 2285,11 ---</span>
  void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
    Thread* thread = Thread::current_or_null();
    if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
      // Can not take safepoint here.
      NoSafepointVerifier no_sfpt;
<span class="line-modified">!     // Cannot take safepoint here so do not use state_for to get</span>
      // jvmti thread state.
      JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
      if (state != NULL) {
        // state is non NULL when VMObjectAllocEventCollector is enabled.
        JvmtiVMObjectAllocEventCollector *collector;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2335,11 ***</span>
  void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
    Thread* thread = Thread::current_or_null();
    if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
      // Can not take safepoint here.
      NoSafepointVerifier no_sfpt;
<span class="line-modified">!     // Can not take safepoint here so can not use state_for to get</span>
      // jvmti thread state.
      JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
      if (state != NULL) {
        // state is non NULL when SampledObjectAllocEventCollector is enabled.
        JvmtiSampledObjectAllocEventCollector *collector;
<span class="line-new-header">--- 2309,11 ---</span>
  void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
    Thread* thread = Thread::current_or_null();
    if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
      // Can not take safepoint here.
      NoSafepointVerifier no_sfpt;
<span class="line-modified">!     // Cannot take safepoint here so do not use state_for to get</span>
      // jvmti thread state.
      JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
      if (state != NULL) {
        // state is non NULL when SampledObjectAllocEventCollector is enabled.
        JvmtiSampledObjectAllocEventCollector *collector;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2604,11 ***</span>
  
  ////////////////////////////////////////////////////////////////////////////////////////////////
  
  void JvmtiExport::cleanup_thread(JavaThread* thread) {
    assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
<span class="line-modified">!   MutexLocker mu(JvmtiThreadState_lock);</span>
  
    if (thread-&gt;jvmti_thread_state() != NULL) {
      // This has to happen after the thread state is removed, which is
      // why it is not in post_thread_end_event like its complement
      // Maybe both these functions should be rolled into the posts?
<span class="line-new-header">--- 2578,11 ---</span>
  
  ////////////////////////////////////////////////////////////////////////////////////////////////
  
  void JvmtiExport::cleanup_thread(JavaThread* thread) {
    assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
<span class="line-modified">!   MutexLocker mu(thread, JvmtiThreadState_lock);</span>
  
    if (thread-&gt;jvmti_thread_state() != NULL) {
      // This has to happen after the thread state is removed, which is
      // why it is not in post_thread_end_event like its complement
      // Maybe both these functions should be rolled into the posts?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2624,22 ***</span>
      state-&gt;clear_exception_state();
    }
  }
  
  void JvmtiExport::oops_do(OopClosure* f) {
<span class="line-removed">-   JvmtiCurrentBreakpoints::oops_do(f);</span>
    JvmtiObjectAllocEventCollector::oops_do_for_all_threads(f);
  }
  
  void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
    JvmtiTagMap::weak_oops_do(is_alive, f);
  }
  
<span class="line-removed">- void JvmtiExport::gc_epilogue() {</span>
<span class="line-removed">-   JvmtiCurrentBreakpoints::gc_epilogue();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Onload raw monitor transition.
  void JvmtiExport::transition_pending_onload_raw_monitors() {
    JvmtiPendingMonitors::transition_raw_monitors();
  }
  
<span class="line-new-header">--- 2598,17 ---</span>
</pre>
<center><a href="jvmtiEventController.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/wbtestmethods/parserTests.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jni.h&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;memory/oopFactory.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/objArrayOop.inline.hpp&quot;
 32 #include &quot;prims/whitebox.inline.hpp&quot;
 33 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
 34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 35 #include &quot;runtime/jniHandles.inline.hpp&quot;
 36 #include &quot;services/diagnosticArgument.hpp&quot;
 37 #include &quot;services/diagnosticFramework.hpp&quot;
 38 
 39 //There&#39;s no way of beforeahnd knowing an upper size
 40 //Of the length of a string representation of
 41 //the value of an argument.
 42 #define VALUE_MAXLEN 256
 43 
 44 // DiagnosticFramework test utility methods
 45 
 46 /*
 47  * The DiagnosticArgumentType class contains an enum that says which type
 48  * this argument represents. (JLONG, BOOLEAN etc).
 49  * This method Returns a char* representation of that enum value.
 50  */
 51 static const char* lookup_diagnosticArgumentEnum(const char* field_name, oop object) {
 52   Thread* THREAD = Thread::current();
 53   const char* enum_sig = &quot;Lsun/hotspot/parser/DiagnosticCommand$DiagnosticArgumentType;&quot;;
 54   TempNewSymbol enumSigSymbol = SymbolTable::lookup(enum_sig, (int) strlen(enum_sig), THREAD);
 55   int offset = WhiteBox::offset_for_field(field_name, object, enumSigSymbol);
 56   oop enumOop = object-&gt;obj_field(offset);
 57 
 58   const char* ret = WhiteBox::lookup_jstring(&quot;name&quot;, enumOop);
 59   return ret;
 60 }
 61 
 62 /*
 63  * Takes an oop to a DiagnosticArgumentType-instance and
 64  * reads the fields from it. Fills an native DCmdParser with
 65  * this info.
 66  */
 67 static void fill_in_parser(DCmdParser* parser, oop argument)
 68 {
 69   const char* name = WhiteBox::lookup_jstring(&quot;name&quot;, argument);
 70   const char* desc = WhiteBox::lookup_jstring(&quot;desc&quot;, argument);
 71   const char* default_value = WhiteBox::lookup_jstring(&quot;defaultValue&quot;, argument);
 72   bool mandatory = WhiteBox::lookup_bool(&quot;mandatory&quot;, argument);
 73   bool isarg = WhiteBox::lookup_bool(&quot;argument&quot;, argument);
 74   const char*  type = lookup_diagnosticArgumentEnum(&quot;type&quot;, argument);
 75 
 76    if (strcmp(type, &quot;STRING&quot;) == 0) {
 77      DCmdArgument&lt;char*&gt;* argument = new DCmdArgument&lt;char*&gt;(
 78      name, desc,
 79      &quot;STRING&quot;, mandatory, default_value);
 80      if (isarg) {
 81       parser-&gt;add_dcmd_argument(argument);
 82      } else {
 83       parser-&gt;add_dcmd_option(argument);
 84      }
 85    } else if (strcmp(type, &quot;NANOTIME&quot;) == 0) {
 86      DCmdArgument&lt;NanoTimeArgument&gt;* argument = new DCmdArgument&lt;NanoTimeArgument&gt;(
 87      name, desc,
 88      &quot;NANOTIME&quot;, mandatory, default_value);
 89      if (isarg) {
 90       parser-&gt;add_dcmd_argument(argument);
 91      } else {
 92       parser-&gt;add_dcmd_option(argument);
 93      }
 94    } else if (strcmp(type, &quot;JLONG&quot;) == 0) {
 95      DCmdArgument&lt;jlong&gt;* argument = new DCmdArgument&lt;jlong&gt;(
 96      name, desc,
 97      &quot;JLONG&quot;, mandatory, default_value);
 98      if (isarg) {
 99       parser-&gt;add_dcmd_argument(argument);
100      } else {
101       parser-&gt;add_dcmd_option(argument);
102      }
103    } else if (strcmp(type, &quot;BOOLEAN&quot;) == 0) {
104      DCmdArgument&lt;bool&gt;* argument = new DCmdArgument&lt;bool&gt;(
105      name, desc,
106      &quot;BOOLEAN&quot;, mandatory, default_value);
107      if (isarg) {
108       parser-&gt;add_dcmd_argument(argument);
109      } else {
110       parser-&gt;add_dcmd_option(argument);
111      }
112    } else if (strcmp(type, &quot;MEMORYSIZE&quot;) == 0) {
113      DCmdArgument&lt;MemorySizeArgument&gt;* argument = new DCmdArgument&lt;MemorySizeArgument&gt;(
114      name, desc,
115      &quot;MEMORY SIZE&quot;, mandatory, default_value);
116      if (isarg) {
117       parser-&gt;add_dcmd_argument(argument);
118      } else {
119       parser-&gt;add_dcmd_option(argument);
120      }
121    } else if (strcmp(type, &quot;STRINGARRAY&quot;) == 0) {
122      DCmdArgument&lt;StringArrayArgument*&gt;* argument = new DCmdArgument&lt;StringArrayArgument*&gt;(
123      name, desc,
124      &quot;STRING SET&quot;, mandatory);
125      if (isarg) {
126       parser-&gt;add_dcmd_argument(argument);
127      } else {
128       parser-&gt;add_dcmd_option(argument);
129      }
130    }
131 }
132 
133 /*
134  * Will Fill in a java object array with alternating names of parsed command line options and
135  * the value that has been parsed for it:
136  * { name, value, name, value ... }
137  * This can then be checked from java.
138  */
139 WB_ENTRY(jobjectArray, WB_ParseCommandLine(JNIEnv* env, jobject o, jstring j_cmdline, jchar j_delim, jobjectArray arguments))
140   ResourceMark rm;
141   DCmdParser parser;
142 
143   const char* c_cmdline = java_lang_String::as_utf8_string(JNIHandles::resolve(j_cmdline));
144   const char c_delim = j_delim &amp; 0xff;
145   objArrayOop argumentArray = objArrayOop(JNIHandles::resolve_non_null(arguments));
146   objArrayHandle argumentArray_ah(THREAD, argumentArray);
147 
148   int length = argumentArray_ah-&gt;length();
149 
150   for (int i = 0; i &lt; length; i++) {
151     oop argument_oop = argumentArray_ah-&gt;obj_at(i);
152     fill_in_parser(&amp;parser, argument_oop);
153   }
154 
155   CmdLine cmdline(c_cmdline, strlen(c_cmdline), true);
156   parser.parse(&amp;cmdline,c_delim,CHECK_NULL);
157 
158   Klass* k = SystemDictionary::Object_klass();
159   objArrayOop returnvalue_array = oopFactory::new_objArray(k, parser.num_arguments() * 2, CHECK_NULL);
160   objArrayHandle returnvalue_array_ah(THREAD, returnvalue_array);
161 
162   GrowableArray&lt;const char *&gt;*parsedArgNames = parser.argument_name_array();
163   GenDCmdArgument* arglist = parser.arguments_list();
164 
165   for (int i = 0; i &lt; parser.num_arguments(); i++) {
166     oop parsedName = java_lang_String::create_oop_from_str(parsedArgNames-&gt;at(i), CHECK_NULL);
167     returnvalue_array_ah-&gt;obj_at_put(i*2, parsedName);
168     GenDCmdArgument* arg = parser.lookup_dcmd_option(parsedArgNames-&gt;at(i), strlen(parsedArgNames-&gt;at(i)));
169     if (!arg) {
170       arg = arglist;
171       arglist = arglist-&gt;next();
172     }
173     char buf[VALUE_MAXLEN];
174     if (arg) {
175       arg-&gt;value_as_str(buf, sizeof(buf));
176     } else {
177       sprintf(buf, &quot;&lt;null&gt;&quot;);
178     }
179     oop parsedValue = java_lang_String::create_oop_from_str(buf, CHECK_NULL);
180     returnvalue_array_ah-&gt;obj_at_put(i*2+1, parsedValue);
181   }
182 
183   return (jobjectArray) JNIHandles::make_local(returnvalue_array_ah());
184 
185 WB_END
    </pre>
  </body>
</html>
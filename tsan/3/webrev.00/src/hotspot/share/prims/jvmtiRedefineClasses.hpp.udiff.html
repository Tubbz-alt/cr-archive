<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvmtiRedefineClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,10 +349,13 @@</span>
    static int             _deleted_methods_length;
    static int             _added_methods_length;
    static bool            _has_redefined_Object;
    static bool            _has_null_class_loader;
  
<span class="udiff-line-added">+   // Used by JFR to group class redefininition events together.</span>
<span class="udiff-line-added">+   static u8              _id_counter;</span>
<span class="udiff-line-added">+ </span>
    // The instance fields are used to pass information from
    // doit_prologue() to doit() and doit_epilogue().
    Klass*                      _the_class;
    jint                        _class_count;
    const jvmtiClassDefinition *_class_defs;  // ptr to _class_count defs
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -386,10 +389,13 @@</span>
    // the heavy lifting.
    elapsedTimer  _timer_rsc_phase1;
    elapsedTimer  _timer_rsc_phase2;
    elapsedTimer  _timer_vm_op_prologue;
  
<span class="udiff-line-added">+   // Redefinition id used by JFR</span>
<span class="udiff-line-added">+   u8 _id;</span>
<span class="udiff-line-added">+ </span>
    // These routines are roughly in call order unless otherwise noted.
  
    // Load the caller&#39;s new class definition(s) into _scratch_classes.
    // Constant pool merging work is done here as needed. Also calls
    // compare_and_normalize_class_versions() to verify the class
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,11 +411,11 @@</span>
    // Figure out which new methods match old methods in name and signature,
    // which methods have been added, and which are no longer present
    void compute_added_deleted_matching_methods();
  
    // Change jmethodIDs to point to the new methods
<span class="udiff-line-modified-removed">-   void update_jmethod_ids();</span>
<span class="udiff-line-modified-added">+   void update_jmethod_ids(Thread* thread);</span>
  
    // In addition to marking methods as old and/or obsolete, this routine
    // counts the number of methods that are EMCP (Equivalent Module Constant Pool).
    int check_methods_and_mark_as_obsolete();
    void transfer_old_native_function_registrations(InstanceKlass* the_class);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -470,10 +476,11 @@</span>
    bool skip_type_annotation_type_path(
      AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS);
    bool rewrite_cp_refs_in_fields_annotations(
      InstanceKlass* scratch_class, TRAPS);
    bool rewrite_cp_refs_in_nest_attributes(InstanceKlass* scratch_class);
<span class="udiff-line-added">+   bool rewrite_cp_refs_in_record_attribute(InstanceKlass* scratch_class, TRAPS);</span>
    void rewrite_cp_refs_in_method(methodHandle method,
      methodHandle * new_method_p, TRAPS);
    bool rewrite_cp_refs_in_methods(InstanceKlass* scratch_class, TRAPS);
    bool rewrite_cp_refs_in_methods_annotations(
      InstanceKlass* scratch_class, TRAPS);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,10 +507,12 @@</span>
  
    // lock classes to redefine since constant pool merging isn&#39;t thread safe.
    void lock_classes();
    void unlock_classes();
  
<span class="udiff-line-added">+   u8 next_id();</span>
<span class="udiff-line-added">+ </span>
    static void dump_methods();
  
    // Check that there are no old or obsolete methods
    class CheckClass : public KlassClosure {
      Thread* _thread;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,10 +541,11 @@</span>
    void doit();
    void doit_epilogue();
  
    bool allow_nested_vm_operations() const        { return true; }
    jvmtiError check_error()                       { return _res; }
<span class="udiff-line-added">+   u8 id()                                        { return _id; }</span>
  
    // Modifiable test must be shared between IsModifiableClass query
    // and redefine implementation
    static bool is_modifiable_class(oop klass_mirror);
  
</pre>
<center><a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiCodeBlobEvents.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeBlob.hpp&quot;
 27 #include &quot;code/codeCache.hpp&quot;
 28 #include &quot;code/scopeDesc.hpp&quot;
 29 #include &quot;code/vtableStubs.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
 34 #include &quot;prims/jvmtiExport.hpp&quot;

 35 #include &quot;runtime/handles.inline.hpp&quot;

 36 #include &quot;runtime/vmThread.hpp&quot;
 37 
 38 // Support class to collect a list of the non-nmethod CodeBlobs in
 39 // the CodeCache.
 40 //
 41 // This class actually creates a list of JvmtiCodeBlobDesc - each JvmtiCodeBlobDesc
 42 // describes a single CodeBlob in the CodeCache. Note that collection is
 43 // done to a static list - this is because CodeCache::blobs_do is defined
 44 // as void CodeCache::blobs_do(void f(CodeBlob* nm)) and hence requires
 45 // a C or static method.
 46 //
 47 // Usage :-
 48 //
 49 // CodeBlobCollector collector;
 50 //
 51 // collector.collect();
 52 // JvmtiCodeBlobDesc* blob = collector.first();
 53 // while (blob != NULL) {
 54 //   :
 55 //   blob = collector.next();
</pre>
<hr />
<pre>
186   // enclosing blobs.
187   CodeCache::blobs_do(do_blob);
188 
189   // make the global list the instance list so that it can be used
190   // for other iterations.
191   _code_blobs = _global_code_blobs;
192   _global_code_blobs = NULL;
193 }
194 
195 
196 // Generate a DYNAMIC_CODE_GENERATED event for each non-nmethod code blob.
197 
198 jvmtiError JvmtiCodeBlobEvents::generate_dynamic_code_events(JvmtiEnv* env) {
199   CodeBlobCollector collector;
200 
201   // First collect all the code blobs.  This has to be done in a
202   // single pass over the code cache with CodeCache_lock held because
203   // there isn&#39;t any safe way to iterate over regular CodeBlobs since
204   // they can be freed at any point.
205   {
<span class="line-modified">206     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
207     collector.collect();
208   }
209 
210   // iterate over the collected list and post an event for each blob
211   JvmtiCodeBlobDesc* blob = collector.first();
212   while (blob != NULL) {
213     JvmtiExport::post_dynamic_code_generated(env, blob-&gt;name(), blob-&gt;code_begin(), blob-&gt;code_end());
214     blob = collector.next();
215   }
216   return JVMTI_ERROR_NONE;
217 }
218 
219 
220 // Generate a COMPILED_METHOD_LOAD event for each nnmethod
221 jvmtiError JvmtiCodeBlobEvents::generate_compiled_method_load_events(JvmtiEnv* env) {
<span class="line-modified">222   HandleMark hm;</span>
<span class="line-modified">223 </span>
<span class="line-modified">224   // Walk the CodeCache notifying for live nmethods.  The code cache</span>
<span class="line-modified">225   // may be changing while this is happening which is ok since newly</span>
<span class="line-modified">226   // created nmethod will notify normally and nmethods which are freed</span>
<span class="line-modified">227   // can be safely skipped.</span>
<span class="line-modified">228   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">229   // Iterate over non-profiled and profiled nmethods</span>
<span class="line-modified">230   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);</span>
<span class="line-modified">231   while(iter.next()) {</span>
<span class="line-modified">232     nmethod* current = iter.method();</span>
<span class="line-modified">233     // Lock the nmethod so it can&#39;t be freed</span>
<span class="line-modified">234     nmethodLocker nml(current);</span>
<span class="line-modified">235 </span>
<span class="line-modified">236     // Don&#39;t hold the lock over the notify or jmethodID creation</span>
<span class="line-modified">237     MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">238     current-&gt;get_and_cache_jmethod_id();</span>
<span class="line-modified">239     JvmtiExport::post_compiled_method_load(current);</span>

240   }








241   return JVMTI_ERROR_NONE;
242 }
243 
244 
245 // create a C-heap allocated address location map for an nmethod
246 void JvmtiCodeBlobEvents::build_jvmti_addr_location_map(nmethod *nm,
247                                                         jvmtiAddrLocationMap** map_ptr,
248                                                         jint *map_length_ptr)
249 {
250   ResourceMark rm;
251   jvmtiAddrLocationMap* map = NULL;
252   jint map_length = 0;
253 
254 
255   // Generate line numbers using PcDesc and ScopeDesc info
<span class="line-modified">256   methodHandle mh(nm-&gt;method());</span>
257 
258   if (!mh-&gt;is_native()) {
259     PcDesc *pcd;
260     int pcds_in_method;
261 
262     pcds_in_method = (nm-&gt;scopes_pcs_end() - nm-&gt;scopes_pcs_begin());
263     map = NEW_C_HEAP_ARRAY(jvmtiAddrLocationMap, pcds_in_method, mtInternal);
264 
265     address scopes_data = nm-&gt;scopes_data_begin();
266     for( pcd = nm-&gt;scopes_pcs_begin(); pcd &lt; nm-&gt;scopes_pcs_end(); ++pcd ) {
267       ScopeDesc sc0(nm, pcd-&gt;scope_decode_offset(), pcd-&gt;should_reexecute(), pcd-&gt;rethrow_exception(), pcd-&gt;return_oop());
268       ScopeDesc *sd  = &amp;sc0;
269       while( !sd-&gt;is_top() ) { sd = sd-&gt;sender(); }
270       int bci = sd-&gt;bci();
271       if (bci &gt;= 0) {
272         assert(map_length &lt; pcds_in_method, &quot;checking&quot;);
273         map[map_length].start_address = (const void*)pcd-&gt;real_pc(nm);
274         map[map_length].location = bci;
275         ++map_length;
276       }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeBlob.hpp&quot;
 27 #include &quot;code/codeCache.hpp&quot;
 28 #include &quot;code/scopeDesc.hpp&quot;
 29 #include &quot;code/vtableStubs.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
 34 #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-added"> 35 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;</span>
 36 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added"> 37 #include &quot;runtime/safepointVerifiers.hpp&quot;</span>
 38 #include &quot;runtime/vmThread.hpp&quot;
 39 
 40 // Support class to collect a list of the non-nmethod CodeBlobs in
 41 // the CodeCache.
 42 //
 43 // This class actually creates a list of JvmtiCodeBlobDesc - each JvmtiCodeBlobDesc
 44 // describes a single CodeBlob in the CodeCache. Note that collection is
 45 // done to a static list - this is because CodeCache::blobs_do is defined
 46 // as void CodeCache::blobs_do(void f(CodeBlob* nm)) and hence requires
 47 // a C or static method.
 48 //
 49 // Usage :-
 50 //
 51 // CodeBlobCollector collector;
 52 //
 53 // collector.collect();
 54 // JvmtiCodeBlobDesc* blob = collector.first();
 55 // while (blob != NULL) {
 56 //   :
 57 //   blob = collector.next();
</pre>
<hr />
<pre>
188   // enclosing blobs.
189   CodeCache::blobs_do(do_blob);
190 
191   // make the global list the instance list so that it can be used
192   // for other iterations.
193   _code_blobs = _global_code_blobs;
194   _global_code_blobs = NULL;
195 }
196 
197 
198 // Generate a DYNAMIC_CODE_GENERATED event for each non-nmethod code blob.
199 
200 jvmtiError JvmtiCodeBlobEvents::generate_dynamic_code_events(JvmtiEnv* env) {
201   CodeBlobCollector collector;
202 
203   // First collect all the code blobs.  This has to be done in a
204   // single pass over the code cache with CodeCache_lock held because
205   // there isn&#39;t any safe way to iterate over regular CodeBlobs since
206   // they can be freed at any point.
207   {
<span class="line-modified">208     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
209     collector.collect();
210   }
211 
212   // iterate over the collected list and post an event for each blob
213   JvmtiCodeBlobDesc* blob = collector.first();
214   while (blob != NULL) {
215     JvmtiExport::post_dynamic_code_generated(env, blob-&gt;name(), blob-&gt;code_begin(), blob-&gt;code_end());
216     blob = collector.next();
217   }
218   return JVMTI_ERROR_NONE;
219 }
220 
221 
222 // Generate a COMPILED_METHOD_LOAD event for each nnmethod
223 jvmtiError JvmtiCodeBlobEvents::generate_compiled_method_load_events(JvmtiEnv* env) {
<span class="line-modified">224   JavaThread* java_thread = JavaThread::current();</span>
<span class="line-modified">225   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);</span>
<span class="line-modified">226   {</span>
<span class="line-modified">227     NoSafepointVerifier nsv;  // safepoints are not safe while collecting methods to post.</span>
<span class="line-modified">228     {</span>
<span class="line-modified">229       // Walk the CodeCache notifying for live nmethods, don&#39;t release the CodeCache_lock</span>
<span class="line-modified">230       // because the sweeper may be running concurrently.</span>
<span class="line-modified">231       // Save events to the queue for posting outside the CodeCache_lock.</span>
<span class="line-modified">232       MutexLocker mu(java_thread, CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">233       // Iterate over non-profiled and profiled nmethods</span>
<span class="line-modified">234       NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);</span>
<span class="line-modified">235       while(iter.next()) {</span>
<span class="line-modified">236         nmethod* current = iter.method();</span>
<span class="line-modified">237         current-&gt;post_compiled_method_load_event(state);</span>
<span class="line-modified">238       }</span>
<span class="line-modified">239     }</span>
<span class="line-modified">240 </span>
<span class="line-modified">241     // Enter nmethod barrier code if present outside CodeCache_lock</span>
<span class="line-added">242     state-&gt;run_nmethod_entry_barriers();</span>
243   }
<span class="line-added">244 </span>
<span class="line-added">245   // Now post all the events outside the CodeCache_lock.</span>
<span class="line-added">246   // If there&#39;s a safepoint, the queued events will be kept alive.</span>
<span class="line-added">247   // Adding these events to the service thread to post is something that</span>
<span class="line-added">248   // should work, but the service thread doesn&#39;t keep up in stress scenarios and</span>
<span class="line-added">249   // the os eventually kills the process with OOM.</span>
<span class="line-added">250   // We want this thread to wait until the events are all posted.</span>
<span class="line-added">251   state-&gt;post_events(env);</span>
252   return JVMTI_ERROR_NONE;
253 }
254 
255 
256 // create a C-heap allocated address location map for an nmethod
257 void JvmtiCodeBlobEvents::build_jvmti_addr_location_map(nmethod *nm,
258                                                         jvmtiAddrLocationMap** map_ptr,
259                                                         jint *map_length_ptr)
260 {
261   ResourceMark rm;
262   jvmtiAddrLocationMap* map = NULL;
263   jint map_length = 0;
264 
265 
266   // Generate line numbers using PcDesc and ScopeDesc info
<span class="line-modified">267   methodHandle mh(Thread::current(), nm-&gt;method());</span>
268 
269   if (!mh-&gt;is_native()) {
270     PcDesc *pcd;
271     int pcds_in_method;
272 
273     pcds_in_method = (nm-&gt;scopes_pcs_end() - nm-&gt;scopes_pcs_begin());
274     map = NEW_C_HEAP_ARRAY(jvmtiAddrLocationMap, pcds_in_method, mtInternal);
275 
276     address scopes_data = nm-&gt;scopes_data_begin();
277     for( pcd = nm-&gt;scopes_pcs_begin(); pcd &lt; nm-&gt;scopes_pcs_end(); ++pcd ) {
278       ScopeDesc sc0(nm, pcd-&gt;scope_decode_offset(), pcd-&gt;should_reexecute(), pcd-&gt;rethrow_exception(), pcd-&gt;return_oop());
279       ScopeDesc *sd  = &amp;sc0;
280       while( !sd-&gt;is_top() ) { sd = sd-&gt;sender(); }
281       int bci = sd-&gt;bci();
282       if (bci &gt;= 0) {
283         assert(map_length &lt; pcds_in_method, &quot;checking&quot;);
284         map[map_length].start_address = (const void*)pcd-&gt;real_pc(nm);
285         map[map_length].location = bci;
286         ++map_length;
287       }
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
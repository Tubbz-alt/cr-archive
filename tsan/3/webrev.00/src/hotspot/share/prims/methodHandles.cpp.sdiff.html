<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodComparator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;

  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/dependencyContext.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/oopMapCache.hpp&quot;
  33 #include &quot;interpreter/linkResolver.hpp&quot;
  34 #include &quot;memory/allocation.inline.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;


  37 #include &quot;oops/objArrayOop.inline.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  40 #include &quot;prims/methodHandles.hpp&quot;
<span class="line-modified">  41 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  42 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.inline.hpp&quot;
  47 #include &quot;runtime/timerTrace.hpp&quot;
  48 #include &quot;runtime/reflection.hpp&quot;
  49 #include &quot;runtime/safepointVerifiers.hpp&quot;
  50 #include &quot;runtime/signature.hpp&quot;
  51 #include &quot;runtime/stubRoutines.hpp&quot;
  52 #include &quot;utilities/exceptions.hpp&quot;
  53 
  54 
  55 /*
  56  * JSR 292 reference implementation: method handles
  57  * The JDK 7 reference implementation represented method handle
  58  * combinations as chains.  Each link in the chain had a &quot;vmentry&quot;
  59  * field which pointed at a bit of assembly code which performed
  60  * one transformation before dispatching to the next link in the chain.
  61  *
</pre>
<hr />
<pre>
 202         return NULL;            // do not resolve unless there is a concrete signature
 203       CallInfo info(m, k, CHECK_NULL);
 204       return init_method_MemberName(mname, info);
 205     }
 206   } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {
 207     oop clazz  = java_lang_reflect_Constructor::clazz(target_oop);
 208     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 209     Klass* k = java_lang_Class::as_Klass(clazz);
 210     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 211       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 212       if (m == NULL)  return NULL;
 213       CallInfo info(m, k, CHECK_NULL);
 214       return init_method_MemberName(mname, info);
 215     }
 216   }
 217   return NULL;
 218 }
 219 
 220 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 221   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
<span class="line-modified"> 222   methodHandle m = info.resolved_method();</span>
 223   assert(m.not_null(), &quot;null method handle&quot;);
 224   InstanceKlass* m_klass = m-&gt;method_holder();
 225   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 226   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 227   int vmindex = Method::invalid_vtable_index;
 228 
 229   switch (info.call_kind()) {
 230   case CallInfo::itable_call:
 231     vmindex = info.itable_index();
 232     // More importantly, the itable index only works with the method holder.
 233     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 234     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
 235     if (TraceInvokeDynamic) {
 236       ttyLocker ttyl;
 237       ResourceMark rm;
 238       tty-&gt;print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,
 239             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 240             vmindex);
 241        m-&gt;access_flags().print_on(tty);
 242        if (!m-&gt;is_abstract()) {
</pre>
<hr />
<pre>
 299       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 300     } else if (m-&gt;is_initializer()) {
 301       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 302     } else {
 303       // &quot;special&quot; reflects that this is a direct call, not that it
 304       // necessarily originates from an invokespecial. We can also do
 305       // direct calls for private and/or final non-static methods.
 306       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 307     }
 308     break;
 309 
 310   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 311   }
 312 
 313   // @CallerSensitive annotation detected
 314   if (m-&gt;caller_sensitive()) {
 315     flags |= CALLER_SENSITIVE;
 316   }
 317 
 318   Handle resolved_method = info.resolved_method_name();
<span class="line-modified"> 319   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m(),</span>
 320          &quot;Should not change after link resolution&quot;);
 321 
 322   oop mname_oop = mname();
 323   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 324   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 325   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 326   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 327   // Note:  name and type can be lazily computed by resolve_MemberName,
 328   // if Java code needs them as resolved String and MethodType objects.
 329   // If relevant, the vtable or itable value is stored as vmindex.
 330   // This is done eagerly, since it is readily available without
 331   // constructing any new objects.
 332   return mname();
 333 }
 334 
 335 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 336   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 337   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 338   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 339   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
</pre>
<hr />
<pre>
 499   if (is_signature_polymorphic_name(klass, name)) {
 500     InstanceKlass* iklass = InstanceKlass::cast(klass);
 501     int me;
 502     int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 503     assert(ms != -1, &quot;&quot;);
 504     for (; ms &lt; me; ms++) {
 505       Method* m = iklass-&gt;methods()-&gt;at(ms);
 506       int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS | JVM_ACC_PUBLIC;
 507       int flags = m-&gt;access_flags().as_int();
 508       if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 509         return true;
 510       }
 511     }
 512   }
 513   return false;
 514 }
 515 
 516 // convert the external string or reflective type to an internal signature
 517 Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
 518   if (java_lang_invoke_MethodType::is_instance(type_str)) {
<span class="line-modified"> 519     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found, THREAD);</span>
 520   } else if (java_lang_Class::is_instance(type_str)) {
<span class="line-modified"> 521     return java_lang_Class::as_signature(type_str, false, THREAD);</span>
 522   } else if (java_lang_String::is_instance_inlined(type_str)) {
 523     if (intern_if_not_found) {
<span class="line-modified"> 524       return java_lang_String::as_symbol(type_str, THREAD);</span>
 525     } else {
 526       return java_lang_String::as_symbol_or_null(type_str);
 527     }
 528   } else {
 529     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
 530   }
 531 }
 532 
 533 static const char OBJ_SIG[] = &quot;Ljava/lang/Object;&quot;;
 534 enum { OBJ_SIG_LEN = 18 };
 535 
 536 bool MethodHandles::is_basic_type_signature(Symbol* sig) {
 537   assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
 538   assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
<span class="line-modified"> 539   const int len = sig-&gt;utf8_length();</span>
<span class="line-modified"> 540   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified"> 541     switch (sig-&gt;char_at(i)) {</span>
<span class="line-removed"> 542     case &#39;L&#39;:</span>
 543       // only java/lang/Object is valid here
<span class="line-modified"> 544       if (sig-&gt;index_of_at(i, OBJ_SIG, OBJ_SIG_LEN) != i)</span>
 545         return false;
<span class="line-modified"> 546       i += OBJ_SIG_LEN-1;  //-1 because of i++ in loop</span>
<span class="line-modified"> 547       continue;</span>
<span class="line-modified"> 548     case &#39;(&#39;: case &#39;)&#39;: case &#39;V&#39;:</span>
<span class="line-modified"> 549     case &#39;I&#39;: case &#39;J&#39;: case &#39;F&#39;: case &#39;D&#39;:</span>
<span class="line-modified"> 550       continue;</span>
<span class="line-modified"> 551     //case &#39;[&#39;:</span>
<span class="line-modified"> 552     //case &#39;Z&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;S&#39;:</span>
 553     default:

 554       return false;
 555     }
 556   }
 557   return true;
 558 }
 559 
 560 Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg, TRAPS) {
 561   Symbol* bsig = NULL;
 562   if (sig == NULL) {
 563     return sig;
 564   } else if (is_basic_type_signature(sig)) {
 565     sig-&gt;increment_refcount();
 566     return sig;  // that was easy
<span class="line-modified"> 567   } else if (sig-&gt;char_at(0) != &#39;(&#39;) {</span>
<span class="line-modified"> 568     BasicType bt = char2type(sig-&gt;char_at(0));</span>
 569     if (is_subword_type(bt)) {
 570       bsig = vmSymbols::int_signature();
 571     } else {
<span class="line-modified"> 572       assert(bt == T_OBJECT || bt == T_ARRAY, &quot;is_basic_type_signature was false&quot;);</span>
 573       bsig = vmSymbols::object_signature();
 574     }
 575   } else {
 576     ResourceMark rm;
 577     stringStream buffer(128);
<span class="line-modified"> 578     buffer.put(&#39;(&#39;);</span>
 579     int arg_pos = 0, keep_arg_pos = -1;
 580     if (keep_last_arg)
 581       keep_arg_pos = ArgumentCount(sig).size() - 1;
 582     for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
 583       BasicType bt = ss.type();
 584       size_t this_arg_pos = buffer.size();
 585       if (ss.at_return_type()) {
<span class="line-modified"> 586         buffer.put(&#39;)&#39;);</span>
 587       }
 588       if (arg_pos == keep_arg_pos) {
 589         buffer.write((char*) ss.raw_bytes(),
 590                      (int)   ss.raw_length());
<span class="line-modified"> 591       } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
 592         buffer.write(OBJ_SIG, OBJ_SIG_LEN);
 593       } else {
 594         if (is_subword_type(bt))
 595           bt = T_INT;
 596         buffer.put(type2char(bt));
 597       }
 598       arg_pos++;
 599     }
 600     const char* sigstr =       buffer.base();
 601     int         siglen = (int) buffer.size();
<span class="line-modified"> 602     bsig = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
 603   }
 604   assert(is_basic_type_signature(bsig) ||
 605          // detune assert in case the injected argument is not a basic type:
 606          keep_last_arg, &quot;&quot;);
 607   return bsig;
 608 }
 609 
 610 void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
<span class="line-modified"> 611                                                      Symbol* sig,</span>
<span class="line-removed"> 612                                                      bool keep_arrays,</span>
<span class="line-removed"> 613                                                      bool keep_basic_names) {</span>
 614   st = st ? st : tty;
<span class="line-removed"> 615   int len  = sig-&gt;utf8_length();</span>
<span class="line-removed"> 616   int array = 0;</span>
 617   bool prev_type = false;
<span class="line-modified"> 618   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified"> 619     char ch = sig-&gt;char_at(i);</span>
<span class="line-modified"> 620     switch (ch) {</span>
<span class="line-modified"> 621     case &#39;(&#39;: case &#39;)&#39;:</span>
<span class="line-modified"> 622       prev_type = false;</span>
<span class="line-modified"> 623       st-&gt;put(ch);</span>
<span class="line-modified"> 624       continue;</span>
<span class="line-modified"> 625     case &#39;[&#39;:</span>
<span class="line-modified"> 626       if (!keep_basic_names &amp;&amp; keep_arrays)</span>
<span class="line-modified"> 627         st-&gt;put(ch);</span>
<span class="line-modified"> 628       array++;</span>
<span class="line-modified"> 629       continue;</span>
<span class="line-modified"> 630     case &#39;L&#39;:</span>
<span class="line-modified"> 631       {</span>
<span class="line-modified"> 632         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-modified"> 633         int start = i+1, slash = start;</span>
<span class="line-removed"> 634         while (++i &lt; len &amp;&amp; (ch = sig-&gt;char_at(i)) != &#39;;&#39;) {</span>
<span class="line-removed"> 635           if (ch == &#39;/&#39; || ch == &#39;.&#39; || ch == &#39;$&#39;)  slash = i+1;</span>
<span class="line-removed"> 636         }</span>
<span class="line-removed"> 637         if (slash &lt; i)  start = slash;</span>
<span class="line-removed"> 638         if (!keep_basic_names) {</span>
<span class="line-removed"> 639           st-&gt;put(&#39;L&#39;);</span>
<span class="line-removed"> 640         } else {</span>
<span class="line-removed"> 641           for (int j = start; j &lt; i; j++)</span>
<span class="line-removed"> 642             st-&gt;put(sig-&gt;char_at(j));</span>
<span class="line-removed"> 643           prev_type = true;</span>
<span class="line-removed"> 644         }</span>
<span class="line-removed"> 645         break;</span>
<span class="line-removed"> 646       }</span>
<span class="line-removed"> 647     default:</span>
<span class="line-removed"> 648       {</span>
<span class="line-removed"> 649         if (array &amp;&amp; char2type(ch) != T_ILLEGAL &amp;&amp; !keep_arrays) {</span>
<span class="line-removed"> 650           ch = &#39;[&#39;;</span>
<span class="line-removed"> 651           array = 0;</span>
<span class="line-removed"> 652         }</span>
<span class="line-removed"> 653         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-removed"> 654         const char* n = NULL;</span>
<span class="line-removed"> 655         if (keep_basic_names)</span>
<span class="line-removed"> 656           n = type2name(char2type(ch));</span>
<span class="line-removed"> 657         if (n == NULL) {</span>
<span class="line-removed"> 658           // unknown letter, or we don&#39;t want to know its name</span>
<span class="line-removed"> 659           st-&gt;put(ch);</span>
<span class="line-removed"> 660         } else {</span>
<span class="line-removed"> 661           st-&gt;print(&quot;%s&quot;, n);</span>
<span class="line-removed"> 662           prev_type = true;</span>
<span class="line-removed"> 663         }</span>
<span class="line-removed"> 664         break;</span>
<span class="line-removed"> 665       }</span>
<span class="line-removed"> 666     }</span>
<span class="line-removed"> 667     // Switch break goes here to take care of array suffix:</span>
<span class="line-removed"> 668     if (prev_type) {</span>
<span class="line-removed"> 669       while (array &gt; 0) {</span>
<span class="line-removed"> 670         st-&gt;print(&quot;[]&quot;);</span>
<span class="line-removed"> 671         --array;</span>
<span class="line-removed"> 672       }</span>
 673     }
<span class="line-removed"> 674     array = 0;</span>
 675   }
 676 }
 677 
 678 
 679 
 680 static oop object_java_mirror() {
 681   return SystemDictionary::Object_klass()-&gt;java_mirror();
 682 }
 683 
 684 oop MethodHandles::field_name_or_null(Symbol* s) {
 685   if (s == NULL)  return NULL;
 686   return StringTable::lookup(s);
 687 }
 688 
 689 oop MethodHandles::field_signature_type_or_null(Symbol* s) {
 690   if (s == NULL)  return NULL;
<span class="line-modified"> 691   BasicType bt = FieldType::basic_type(s);</span>
 692   if (is_java_primitive(bt)) {
 693     assert(s-&gt;utf8_length() == 1, &quot;&quot;);
 694     return java_lang_Class::primitive_mirror(bt);
 695   }
 696   // Here are some more short cuts for common types.
 697   // They are optional, since reference types can be resolved lazily.
 698   if (bt == T_OBJECT) {
 699     if (s == vmSymbols::object_signature()) {
 700       return object_java_mirror();
 701     } else if (s == vmSymbols::class_signature()) {
 702       return SystemDictionary::Class_klass()-&gt;java_mirror();
 703     } else if (s == vmSymbols::string_signature()) {
 704       return SystemDictionary::String_klass()-&gt;java_mirror();
 705     }
 706   }
 707   return NULL;
 708 }
 709 
 710 
 711 // An unresolved member name is a mere symbolic reference.
</pre>
<hr />
<pre>
 957                                     int skip, objArrayHandle results, TRAPS) {
 958   // %%% take caller into account!
 959 
 960   Thread* thread = Thread::current();
 961 
 962   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 963 
 964   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 965   // overflow measurement:
 966   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 967 
 968   int match_flags = mflags;
 969   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 970   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 971   bool local_only = !(search_superc | search_intfc);
 972 
 973   if (name != NULL) {
 974     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 975   }
 976   if (sig != NULL) {
<span class="line-modified"> 977     if (sig-&gt;utf8_length() == 0)  return 0; // a match is not possible</span>
<span class="line-removed"> 978     if (sig-&gt;char_at(0) == &#39;(&#39;)</span>
 979       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 980     else
 981       match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);
 982   }
 983 
 984   if ((match_flags &amp; IS_TYPE) != 0) {
 985     // NYI, and Core Reflection works quite well for this query
 986   }
 987 
 988   if ((match_flags &amp; IS_FIELD) != 0) {
 989     InstanceKlass* ik = InstanceKlass::cast(k);
 990     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 991       if (name != NULL &amp;&amp; st.name() != name)
 992           continue;
 993       if (sig != NULL &amp;&amp; st.signature() != sig)
 994         continue;
 995       // passed the filters
 996       if (rskip &gt; 0) {
 997         --rskip;
 998       } else if (rfill &lt; rlimit) {
 999         Handle result(thread, results-&gt;obj_at(rfill++));
1000         if (!java_lang_invoke_MemberName::is_instance(result()))
1001           return -99;  // caller bug!
1002         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
<span class="line-modified">1003         if (!oopDesc::equals(saved, result()))</span>
1004           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1005       } else if (++overflow &gt;= overflow_limit) {
1006         match_flags = 0; break; // got tired of looking at overflow
1007       }
1008     }
1009   }
1010 
1011   if ((match_flags &amp; (IS_METHOD | IS_CONSTRUCTOR)) != 0) {
1012     // watch out for these guys:
1013     Symbol* init_name   = vmSymbols::object_initializer_name();
1014     Symbol* clinit_name = vmSymbols::class_initializer_name();
1015     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
1016     bool negate_name_test = false;
1017     // fix name so that it captures the intention of IS_CONSTRUCTOR
1018     if (!(match_flags &amp; IS_METHOD)) {
1019       // constructors only
1020       if (name == NULL) {
1021         name = init_name;
1022       } else if (name != init_name) {
1023         return 0;               // no constructors of this method name
</pre>
<hr />
<pre>
1035     }
1036     InstanceKlass* ik = InstanceKlass::cast(k);
1037     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
1038       Method* m = st.method();
1039       Symbol* m_name = m-&gt;name();
1040       if (m_name == clinit_name)
1041         continue;
1042       if (name != NULL &amp;&amp; ((m_name != name) ^ negate_name_test))
1043           continue;
1044       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1045         continue;
1046       // passed the filters
1047       if (rskip &gt; 0) {
1048         --rskip;
1049       } else if (rfill &lt; rlimit) {
1050         Handle result(thread, results-&gt;obj_at(rfill++));
1051         if (!java_lang_invoke_MemberName::is_instance(result()))
1052           return -99;  // caller bug!
1053         CallInfo info(m, NULL, CHECK_0);
1054         oop saved = MethodHandles::init_method_MemberName(result, info);
<span class="line-modified">1055         if (!oopDesc::equals(saved, result()))</span>
1056           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1057       } else if (++overflow &gt;= overflow_limit) {
1058         match_flags = 0; break; // got tired of looking at overflow
1059       }
1060     }
1061   }
1062 
1063   // return number of elements we at leasted wanted to initialize
1064   return rfill + overflow;
1065 }
1066 
1067 void MethodHandles::add_dependent_nmethod(oop call_site, nmethod* nm) {
1068   assert_locked_or_safepoint(CodeCache_lock);
1069 
1070   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1071   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1072   // Try to purge stale entries on updates.
1073   // Since GC doesn&#39;t clean dependency contexts rooted at CallSiteContext objects,
1074   // in order to avoid memory leak, stale entries are purged whenever a dependency list
1075   // is changed (both on addition and removal). Though memory reclamation is delayed,
</pre>
<hr />
<pre>
1081   assert_locked_or_safepoint(CodeCache_lock);
1082 
1083   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1084   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1085   deps.remove_dependent_nmethod(nm);
1086 }
1087 
1088 void MethodHandles::clean_dependency_context(oop call_site) {
1089   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1090   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1091   deps.clean_unloading_dependents();
1092 }
1093 
1094 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1095   assert_lock_strong(Compile_lock);
1096 
1097   int marked = 0;
1098   CallSiteDepChange changes(call_site, target);
1099   {
1100     NoSafepointVerifier nsv;
<span class="line-modified">1101     MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1102 
1103     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1104     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1105     marked = deps.mark_dependent_nmethods(changes);
1106   }
1107   if (marked &gt; 0) {
1108     // At least one nmethod has been marked for deoptimization.
<span class="line-modified">1109     VM_Deoptimize op;</span>
<span class="line-removed">1110     VMThread::execute(&amp;op);</span>
1111   }
1112 }
1113 
1114 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
1115   if (TraceMethodHandles) {
1116     const char* name = vmIntrinsics::name_at(iid);
1117     if (*name == &#39;_&#39;)  name += 1;
1118     const size_t len = strlen(name) + 50;
1119     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1120     const char* suffix = &quot;&quot;;
1121     if (is_signature_polymorphic(iid)) {
1122       if (is_signature_polymorphic_static(iid))
1123         suffix = &quot;/static&quot;;
1124       else
1125         suffix = &quot;/private&quot;;
1126     }
1127     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1128     trace_method_handle(_masm, qname);
1129     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1130     // during runtime.
</pre>
<hr />
<pre>
1369     caller = java_lang_Class::as_Klass(caller_oop);
1370   }
1371 
1372   if (name != NULL &amp;&amp; sig != NULL &amp;&amp; results.not_null()) {
1373     // try a direct resolve
1374     // %%% TO DO
1375   }
1376 
1377   int res = MethodHandles::find_MemberNames(k, name, sig, mflags,
1378                                             caller, skip, results, CHECK_0);
1379   // TO DO: expand at least some of the MemberNames, to avoid massive callbacks
1380   return res;
1381 }
1382 JVM_END
1383 
1384 JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1385   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1386   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1387   {
1388     // Walk all nmethods depending on this call site.
<span class="line-modified">1389     MutexLocker mu(Compile_lock, thread);</span>
1390     MethodHandles::flush_dependent_nmethods(call_site, target);
1391     java_lang_invoke_CallSite::set_target(call_site(), target());
1392   }
1393 }
1394 JVM_END
1395 
1396 JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1397   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1398   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1399   {
1400     // Walk all nmethods depending on this call site.
<span class="line-modified">1401     MutexLocker mu(Compile_lock, thread);</span>
1402     MethodHandles::flush_dependent_nmethods(call_site, target);
1403     java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
1404   }
1405 }
1406 JVM_END
1407 
1408 JVM_ENTRY(void, MHN_copyOutBootstrapArguments(JNIEnv* env, jobject igcls,
1409                                               jobject caller_jh, jintArray index_info_jh,
1410                                               jint start, jint end,
1411                                               jobjectArray buf_jh, jint pos,
1412                                               jboolean resolve, jobject ifna_jh)) {
1413   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller_jh));
1414   if (caller_k == NULL || !caller_k-&gt;is_instance_klass()) {
1415       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad caller&quot;);
1416   }
1417   InstanceKlass* caller = InstanceKlass::cast(caller_k);
1418   typeArrayOop index_info_oop = (typeArrayOop) JNIHandles::resolve(index_info_jh);
1419   if (index_info_oop == NULL ||
1420       index_info_oop-&gt;klass() != Universe::intArrayKlassObj() ||
1421       typeArrayOop(index_info_oop)-&gt;length() &lt; 2) {
</pre>
<hr />
<pre>
1437         if (start &gt;= end || 0 &gt; pos || pos &gt;= buf-&gt;length())  break;
1438         oop pseudo_arg = NULL;
1439         switch (pseudo_index) {
1440         case -4:  // bootstrap method
1441           {
1442             int bsm_index = caller-&gt;constants()-&gt;bootstrap_method_ref_index_at(bss_index_in_pool);
1443             pseudo_arg = caller-&gt;constants()-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK);
1444             break;
1445           }
1446         case -3:  // name
1447           {
1448             Symbol* name = caller-&gt;constants()-&gt;name_ref_at(bss_index_in_pool);
1449             Handle str = java_lang_String::create_from_symbol(name, CHECK);
1450             pseudo_arg = str();
1451             break;
1452           }
1453         case -2:  // type
1454           {
1455             Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
1456             Handle th;
<span class="line-modified">1457             if (type-&gt;char_at(0) == &#39;(&#39;) {</span>
1458               th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
1459             } else {
1460               th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
1461             }
1462             pseudo_arg = th();
1463             break;
1464           }
1465         case -1:  // argument count
1466           {
1467             int argc = caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool);
1468             jvalue argc_value; argc_value.i = (jint)argc;
1469             pseudo_arg = java_lang_boxing_object::create(T_INT, &amp;argc_value, CHECK);
1470             break;
1471           }
1472         }
1473 
1474         // Store the pseudo-argument, and advance the pointers.
1475         buf-&gt;obj_at_put(pos++, pseudo_arg);
1476         ++start;
1477       }
1478     }
1479     // When we are done with this there may be regular arguments to process too.
1480   }
1481   Handle ifna(THREAD, JNIHandles::resolve(ifna_jh));
1482   caller-&gt;constants()-&gt;
1483     copy_bootstrap_arguments_at(bss_index_in_pool,
1484                                 start, end, buf, pos,
1485                                 (resolve == JNI_TRUE), ifna, CHECK);
1486 }
1487 JVM_END
1488 
1489 // It is called by a Cleaner object which ensures that dropped CallSites properly
1490 // deallocate their dependency information.
1491 JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
1492   Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
1493   {
1494     // Walk all nmethods depending on this call site.
<span class="line-modified">1495     MutexLocker mu1(Compile_lock, thread);</span>
1496 
1497     int marked = 0;
1498     {
1499       NoSafepointVerifier nsv;
<span class="line-modified">1500       MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1501       DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
1502       marked = deps.remove_all_dependents();
1503     }
1504     if (marked &gt; 0) {
1505       // At least one nmethod has been marked for deoptimization
<span class="line-modified">1506       VM_Deoptimize op;</span>
<span class="line-removed">1507       VMThread::execute(&amp;op);</span>
1508     }
1509   }
1510 }
1511 JVM_END
1512 
1513 /**
1514  * Throws a java/lang/UnsupportedOperationException unconditionally.
1515  * This is required by the specification of MethodHandle.invoke if
1516  * invoked directly.
1517  */
1518 JVM_ENTRY(jobject, MH_invoke_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1519   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invoke cannot be invoked reflectively&quot;);
1520   return NULL;
1521 }
1522 JVM_END
1523 
1524 /**
1525  * Throws a java/lang/UnsupportedOperationException unconditionally.
1526  * This is required by the specification of MethodHandle.invokeExact if
1527  * invoked directly.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">  28 #include &quot;classfile/symbolTable.hpp&quot;</span>
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  38 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  39 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;prims/methodHandles.hpp&quot;
<span class="line-modified">  44 #include &quot;runtime/deoptimization.hpp&quot;</span>
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/timerTrace.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/safepointVerifiers.hpp&quot;
  53 #include &quot;runtime/signature.hpp&quot;
  54 #include &quot;runtime/stubRoutines.hpp&quot;
  55 #include &quot;utilities/exceptions.hpp&quot;
  56 
  57 
  58 /*
  59  * JSR 292 reference implementation: method handles
  60  * The JDK 7 reference implementation represented method handle
  61  * combinations as chains.  Each link in the chain had a &quot;vmentry&quot;
  62  * field which pointed at a bit of assembly code which performed
  63  * one transformation before dispatching to the next link in the chain.
  64  *
</pre>
<hr />
<pre>
 205         return NULL;            // do not resolve unless there is a concrete signature
 206       CallInfo info(m, k, CHECK_NULL);
 207       return init_method_MemberName(mname, info);
 208     }
 209   } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {
 210     oop clazz  = java_lang_reflect_Constructor::clazz(target_oop);
 211     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 212     Klass* k = java_lang_Class::as_Klass(clazz);
 213     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 214       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 215       if (m == NULL)  return NULL;
 216       CallInfo info(m, k, CHECK_NULL);
 217       return init_method_MemberName(mname, info);
 218     }
 219   }
 220   return NULL;
 221 }
 222 
 223 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 224   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
<span class="line-modified"> 225   methodHandle m(Thread::current(), info.resolved_method());</span>
 226   assert(m.not_null(), &quot;null method handle&quot;);
 227   InstanceKlass* m_klass = m-&gt;method_holder();
 228   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 229   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 230   int vmindex = Method::invalid_vtable_index;
 231 
 232   switch (info.call_kind()) {
 233   case CallInfo::itable_call:
 234     vmindex = info.itable_index();
 235     // More importantly, the itable index only works with the method holder.
 236     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 237     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
 238     if (TraceInvokeDynamic) {
 239       ttyLocker ttyl;
 240       ResourceMark rm;
 241       tty-&gt;print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,
 242             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 243             vmindex);
 244        m-&gt;access_flags().print_on(tty);
 245        if (!m-&gt;is_abstract()) {
</pre>
<hr />
<pre>
 302       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 303     } else if (m-&gt;is_initializer()) {
 304       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 305     } else {
 306       // &quot;special&quot; reflects that this is a direct call, not that it
 307       // necessarily originates from an invokespecial. We can also do
 308       // direct calls for private and/or final non-static methods.
 309       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 310     }
 311     break;
 312 
 313   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 314   }
 315 
 316   // @CallerSensitive annotation detected
 317   if (m-&gt;caller_sensitive()) {
 318     flags |= CALLER_SENSITIVE;
 319   }
 320 
 321   Handle resolved_method = info.resolved_method_name();
<span class="line-modified"> 322   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),</span>
 323          &quot;Should not change after link resolution&quot;);
 324 
 325   oop mname_oop = mname();
 326   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 327   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 328   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 329   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 330   // Note:  name and type can be lazily computed by resolve_MemberName,
 331   // if Java code needs them as resolved String and MethodType objects.
 332   // If relevant, the vtable or itable value is stored as vmindex.
 333   // This is done eagerly, since it is readily available without
 334   // constructing any new objects.
 335   return mname();
 336 }
 337 
 338 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 339   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 340   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 341   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 342   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
</pre>
<hr />
<pre>
 502   if (is_signature_polymorphic_name(klass, name)) {
 503     InstanceKlass* iklass = InstanceKlass::cast(klass);
 504     int me;
 505     int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 506     assert(ms != -1, &quot;&quot;);
 507     for (; ms &lt; me; ms++) {
 508       Method* m = iklass-&gt;methods()-&gt;at(ms);
 509       int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS | JVM_ACC_PUBLIC;
 510       int flags = m-&gt;access_flags().as_int();
 511       if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 512         return true;
 513       }
 514     }
 515   }
 516   return false;
 517 }
 518 
 519 // convert the external string or reflective type to an internal signature
 520 Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
 521   if (java_lang_invoke_MethodType::is_instance(type_str)) {
<span class="line-modified"> 522     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found);</span>
 523   } else if (java_lang_Class::is_instance(type_str)) {
<span class="line-modified"> 524     return java_lang_Class::as_signature(type_str, false);</span>
 525   } else if (java_lang_String::is_instance_inlined(type_str)) {
 526     if (intern_if_not_found) {
<span class="line-modified"> 527       return java_lang_String::as_symbol(type_str);</span>
 528     } else {
 529       return java_lang_String::as_symbol_or_null(type_str);
 530     }
 531   } else {
 532     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
 533   }
 534 }
 535 
 536 static const char OBJ_SIG[] = &quot;Ljava/lang/Object;&quot;;
 537 enum { OBJ_SIG_LEN = 18 };
 538 
 539 bool MethodHandles::is_basic_type_signature(Symbol* sig) {
 540   assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
 541   assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
<span class="line-modified"> 542   for (SignatureStream ss(sig, sig-&gt;starts_with(JVM_SIGNATURE_FUNC)); !ss.is_done(); ss.next()) {</span>
<span class="line-modified"> 543     switch (ss.type()) {</span>
<span class="line-modified"> 544     case T_OBJECT:</span>

 545       // only java/lang/Object is valid here
<span class="line-modified"> 546       if (strncmp((char*) ss.raw_bytes(), OBJ_SIG, OBJ_SIG_LEN) != 0)</span>
 547         return false;
<span class="line-modified"> 548       break;</span>
<span class="line-modified"> 549     case T_VOID:</span>
<span class="line-modified"> 550     case T_INT:</span>
<span class="line-modified"> 551     case T_LONG:</span>
<span class="line-modified"> 552     case T_FLOAT:</span>
<span class="line-modified"> 553     case T_DOUBLE:</span>
<span class="line-modified"> 554       break;</span>
 555     default:
<span class="line-added"> 556       // subword types (T_BYTE etc.), Q-descriptors, arrays</span>
 557       return false;
 558     }
 559   }
 560   return true;
 561 }
 562 
 563 Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg, TRAPS) {
 564   Symbol* bsig = NULL;
 565   if (sig == NULL) {
 566     return sig;
 567   } else if (is_basic_type_signature(sig)) {
 568     sig-&gt;increment_refcount();
 569     return sig;  // that was easy
<span class="line-modified"> 570   } else if (!sig-&gt;starts_with(JVM_SIGNATURE_FUNC)) {</span>
<span class="line-modified"> 571     BasicType bt = Signature::basic_type(sig);</span>
 572     if (is_subword_type(bt)) {
 573       bsig = vmSymbols::int_signature();
 574     } else {
<span class="line-modified"> 575       assert(is_reference_type(bt), &quot;is_basic_type_signature was false&quot;);</span>
 576       bsig = vmSymbols::object_signature();
 577     }
 578   } else {
 579     ResourceMark rm;
 580     stringStream buffer(128);
<span class="line-modified"> 581     buffer.put(JVM_SIGNATURE_FUNC);</span>
 582     int arg_pos = 0, keep_arg_pos = -1;
 583     if (keep_last_arg)
 584       keep_arg_pos = ArgumentCount(sig).size() - 1;
 585     for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
 586       BasicType bt = ss.type();
 587       size_t this_arg_pos = buffer.size();
 588       if (ss.at_return_type()) {
<span class="line-modified"> 589         buffer.put(JVM_SIGNATURE_ENDFUNC);</span>
 590       }
 591       if (arg_pos == keep_arg_pos) {
 592         buffer.write((char*) ss.raw_bytes(),
 593                      (int)   ss.raw_length());
<span class="line-modified"> 594       } else if (is_reference_type(bt)) {</span>
 595         buffer.write(OBJ_SIG, OBJ_SIG_LEN);
 596       } else {
 597         if (is_subword_type(bt))
 598           bt = T_INT;
 599         buffer.put(type2char(bt));
 600       }
 601       arg_pos++;
 602     }
 603     const char* sigstr =       buffer.base();
 604     int         siglen = (int) buffer.size();
<span class="line-modified"> 605     bsig = SymbolTable::new_symbol(sigstr, siglen);</span>
 606   }
 607   assert(is_basic_type_signature(bsig) ||
 608          // detune assert in case the injected argument is not a basic type:
 609          keep_last_arg, &quot;&quot;);
 610   return bsig;
 611 }
 612 
 613 void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
<span class="line-modified"> 614                                                      Symbol* sig) {</span>


 615   st = st ? st : tty;


 616   bool prev_type = false;
<span class="line-modified"> 617   bool is_method = (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC);</span>
<span class="line-modified"> 618   if (is_method)  st-&gt;put(JVM_SIGNATURE_FUNC);</span>
<span class="line-modified"> 619   for (SignatureStream ss(sig, is_method); !ss.is_done(); ss.next()) {</span>
<span class="line-modified"> 620     if (ss.at_return_type())</span>
<span class="line-modified"> 621       st-&gt;put(JVM_SIGNATURE_ENDFUNC);</span>
<span class="line-modified"> 622     else if (prev_type)</span>
<span class="line-modified"> 623       st-&gt;put(&#39;,&#39;);</span>
<span class="line-modified"> 624     const char* cp = (const char*) ss.raw_bytes();</span>
<span class="line-modified"> 625     if (ss.is_array()) {</span>
<span class="line-modified"> 626       st-&gt;put(JVM_SIGNATURE_ARRAY);</span>
<span class="line-modified"> 627       if (ss.array_prefix_length() == 1)</span>
<span class="line-modified"> 628         st-&gt;put(cp[1]);</span>
<span class="line-modified"> 629       else</span>
<span class="line-modified"> 630         st-&gt;put(JVM_SIGNATURE_CLASS);</span>
<span class="line-modified"> 631     } else {</span>
<span class="line-modified"> 632       st-&gt;put(cp[0]);</span>







































 633     }

 634   }
 635 }
 636 
 637 
 638 
 639 static oop object_java_mirror() {
 640   return SystemDictionary::Object_klass()-&gt;java_mirror();
 641 }
 642 
 643 oop MethodHandles::field_name_or_null(Symbol* s) {
 644   if (s == NULL)  return NULL;
 645   return StringTable::lookup(s);
 646 }
 647 
 648 oop MethodHandles::field_signature_type_or_null(Symbol* s) {
 649   if (s == NULL)  return NULL;
<span class="line-modified"> 650   BasicType bt = Signature::basic_type(s);</span>
 651   if (is_java_primitive(bt)) {
 652     assert(s-&gt;utf8_length() == 1, &quot;&quot;);
 653     return java_lang_Class::primitive_mirror(bt);
 654   }
 655   // Here are some more short cuts for common types.
 656   // They are optional, since reference types can be resolved lazily.
 657   if (bt == T_OBJECT) {
 658     if (s == vmSymbols::object_signature()) {
 659       return object_java_mirror();
 660     } else if (s == vmSymbols::class_signature()) {
 661       return SystemDictionary::Class_klass()-&gt;java_mirror();
 662     } else if (s == vmSymbols::string_signature()) {
 663       return SystemDictionary::String_klass()-&gt;java_mirror();
 664     }
 665   }
 666   return NULL;
 667 }
 668 
 669 
 670 // An unresolved member name is a mere symbolic reference.
</pre>
<hr />
<pre>
 916                                     int skip, objArrayHandle results, TRAPS) {
 917   // %%% take caller into account!
 918 
 919   Thread* thread = Thread::current();
 920 
 921   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 922 
 923   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 924   // overflow measurement:
 925   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 926 
 927   int match_flags = mflags;
 928   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 929   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 930   bool local_only = !(search_superc | search_intfc);
 931 
 932   if (name != NULL) {
 933     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 934   }
 935   if (sig != NULL) {
<span class="line-modified"> 936     if (sig-&gt;starts_with(JVM_SIGNATURE_FUNC))</span>

 937       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 938     else
 939       match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);
 940   }
 941 
 942   if ((match_flags &amp; IS_TYPE) != 0) {
 943     // NYI, and Core Reflection works quite well for this query
 944   }
 945 
 946   if ((match_flags &amp; IS_FIELD) != 0) {
 947     InstanceKlass* ik = InstanceKlass::cast(k);
 948     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 949       if (name != NULL &amp;&amp; st.name() != name)
 950           continue;
 951       if (sig != NULL &amp;&amp; st.signature() != sig)
 952         continue;
 953       // passed the filters
 954       if (rskip &gt; 0) {
 955         --rskip;
 956       } else if (rfill &lt; rlimit) {
 957         Handle result(thread, results-&gt;obj_at(rfill++));
 958         if (!java_lang_invoke_MemberName::is_instance(result()))
 959           return -99;  // caller bug!
 960         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
<span class="line-modified"> 961         if (saved != result())</span>
 962           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
 963       } else if (++overflow &gt;= overflow_limit) {
 964         match_flags = 0; break; // got tired of looking at overflow
 965       }
 966     }
 967   }
 968 
 969   if ((match_flags &amp; (IS_METHOD | IS_CONSTRUCTOR)) != 0) {
 970     // watch out for these guys:
 971     Symbol* init_name   = vmSymbols::object_initializer_name();
 972     Symbol* clinit_name = vmSymbols::class_initializer_name();
 973     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
 974     bool negate_name_test = false;
 975     // fix name so that it captures the intention of IS_CONSTRUCTOR
 976     if (!(match_flags &amp; IS_METHOD)) {
 977       // constructors only
 978       if (name == NULL) {
 979         name = init_name;
 980       } else if (name != init_name) {
 981         return 0;               // no constructors of this method name
</pre>
<hr />
<pre>
 993     }
 994     InstanceKlass* ik = InstanceKlass::cast(k);
 995     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 996       Method* m = st.method();
 997       Symbol* m_name = m-&gt;name();
 998       if (m_name == clinit_name)
 999         continue;
1000       if (name != NULL &amp;&amp; ((m_name != name) ^ negate_name_test))
1001           continue;
1002       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1003         continue;
1004       // passed the filters
1005       if (rskip &gt; 0) {
1006         --rskip;
1007       } else if (rfill &lt; rlimit) {
1008         Handle result(thread, results-&gt;obj_at(rfill++));
1009         if (!java_lang_invoke_MemberName::is_instance(result()))
1010           return -99;  // caller bug!
1011         CallInfo info(m, NULL, CHECK_0);
1012         oop saved = MethodHandles::init_method_MemberName(result, info);
<span class="line-modified">1013         if (saved != result())</span>
1014           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1015       } else if (++overflow &gt;= overflow_limit) {
1016         match_flags = 0; break; // got tired of looking at overflow
1017       }
1018     }
1019   }
1020 
1021   // return number of elements we at leasted wanted to initialize
1022   return rfill + overflow;
1023 }
1024 
1025 void MethodHandles::add_dependent_nmethod(oop call_site, nmethod* nm) {
1026   assert_locked_or_safepoint(CodeCache_lock);
1027 
1028   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1029   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1030   // Try to purge stale entries on updates.
1031   // Since GC doesn&#39;t clean dependency contexts rooted at CallSiteContext objects,
1032   // in order to avoid memory leak, stale entries are purged whenever a dependency list
1033   // is changed (both on addition and removal). Though memory reclamation is delayed,
</pre>
<hr />
<pre>
1039   assert_locked_or_safepoint(CodeCache_lock);
1040 
1041   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1042   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1043   deps.remove_dependent_nmethod(nm);
1044 }
1045 
1046 void MethodHandles::clean_dependency_context(oop call_site) {
1047   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1048   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1049   deps.clean_unloading_dependents();
1050 }
1051 
1052 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1053   assert_lock_strong(Compile_lock);
1054 
1055   int marked = 0;
1056   CallSiteDepChange changes(call_site, target);
1057   {
1058     NoSafepointVerifier nsv;
<span class="line-modified">1059     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1060 
1061     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1062     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1063     marked = deps.mark_dependent_nmethods(changes);
1064   }
1065   if (marked &gt; 0) {
1066     // At least one nmethod has been marked for deoptimization.
<span class="line-modified">1067     Deoptimization::deoptimize_all_marked();</span>

1068   }
1069 }
1070 
1071 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
1072   if (TraceMethodHandles) {
1073     const char* name = vmIntrinsics::name_at(iid);
1074     if (*name == &#39;_&#39;)  name += 1;
1075     const size_t len = strlen(name) + 50;
1076     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1077     const char* suffix = &quot;&quot;;
1078     if (is_signature_polymorphic(iid)) {
1079       if (is_signature_polymorphic_static(iid))
1080         suffix = &quot;/static&quot;;
1081       else
1082         suffix = &quot;/private&quot;;
1083     }
1084     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1085     trace_method_handle(_masm, qname);
1086     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1087     // during runtime.
</pre>
<hr />
<pre>
1326     caller = java_lang_Class::as_Klass(caller_oop);
1327   }
1328 
1329   if (name != NULL &amp;&amp; sig != NULL &amp;&amp; results.not_null()) {
1330     // try a direct resolve
1331     // %%% TO DO
1332   }
1333 
1334   int res = MethodHandles::find_MemberNames(k, name, sig, mflags,
1335                                             caller, skip, results, CHECK_0);
1336   // TO DO: expand at least some of the MemberNames, to avoid massive callbacks
1337   return res;
1338 }
1339 JVM_END
1340 
1341 JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1342   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1343   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1344   {
1345     // Walk all nmethods depending on this call site.
<span class="line-modified">1346     MutexLocker mu(thread, Compile_lock);</span>
1347     MethodHandles::flush_dependent_nmethods(call_site, target);
1348     java_lang_invoke_CallSite::set_target(call_site(), target());
1349   }
1350 }
1351 JVM_END
1352 
1353 JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1354   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1355   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1356   {
1357     // Walk all nmethods depending on this call site.
<span class="line-modified">1358     MutexLocker mu(thread, Compile_lock);</span>
1359     MethodHandles::flush_dependent_nmethods(call_site, target);
1360     java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
1361   }
1362 }
1363 JVM_END
1364 
1365 JVM_ENTRY(void, MHN_copyOutBootstrapArguments(JNIEnv* env, jobject igcls,
1366                                               jobject caller_jh, jintArray index_info_jh,
1367                                               jint start, jint end,
1368                                               jobjectArray buf_jh, jint pos,
1369                                               jboolean resolve, jobject ifna_jh)) {
1370   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller_jh));
1371   if (caller_k == NULL || !caller_k-&gt;is_instance_klass()) {
1372       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad caller&quot;);
1373   }
1374   InstanceKlass* caller = InstanceKlass::cast(caller_k);
1375   typeArrayOop index_info_oop = (typeArrayOop) JNIHandles::resolve(index_info_jh);
1376   if (index_info_oop == NULL ||
1377       index_info_oop-&gt;klass() != Universe::intArrayKlassObj() ||
1378       typeArrayOop(index_info_oop)-&gt;length() &lt; 2) {
</pre>
<hr />
<pre>
1394         if (start &gt;= end || 0 &gt; pos || pos &gt;= buf-&gt;length())  break;
1395         oop pseudo_arg = NULL;
1396         switch (pseudo_index) {
1397         case -4:  // bootstrap method
1398           {
1399             int bsm_index = caller-&gt;constants()-&gt;bootstrap_method_ref_index_at(bss_index_in_pool);
1400             pseudo_arg = caller-&gt;constants()-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK);
1401             break;
1402           }
1403         case -3:  // name
1404           {
1405             Symbol* name = caller-&gt;constants()-&gt;name_ref_at(bss_index_in_pool);
1406             Handle str = java_lang_String::create_from_symbol(name, CHECK);
1407             pseudo_arg = str();
1408             break;
1409           }
1410         case -2:  // type
1411           {
1412             Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
1413             Handle th;
<span class="line-modified">1414             if (type-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
1415               th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
1416             } else {
1417               th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
1418             }
1419             pseudo_arg = th();
1420             break;
1421           }
1422         case -1:  // argument count
1423           {
1424             int argc = caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool);
1425             jvalue argc_value; argc_value.i = (jint)argc;
1426             pseudo_arg = java_lang_boxing_object::create(T_INT, &amp;argc_value, CHECK);
1427             break;
1428           }
1429         }
1430 
1431         // Store the pseudo-argument, and advance the pointers.
1432         buf-&gt;obj_at_put(pos++, pseudo_arg);
1433         ++start;
1434       }
1435     }
1436     // When we are done with this there may be regular arguments to process too.
1437   }
1438   Handle ifna(THREAD, JNIHandles::resolve(ifna_jh));
1439   caller-&gt;constants()-&gt;
1440     copy_bootstrap_arguments_at(bss_index_in_pool,
1441                                 start, end, buf, pos,
1442                                 (resolve == JNI_TRUE), ifna, CHECK);
1443 }
1444 JVM_END
1445 
1446 // It is called by a Cleaner object which ensures that dropped CallSites properly
1447 // deallocate their dependency information.
1448 JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
1449   Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
1450   {
1451     // Walk all nmethods depending on this call site.
<span class="line-modified">1452     MutexLocker mu1(thread, Compile_lock);</span>
1453 
1454     int marked = 0;
1455     {
1456       NoSafepointVerifier nsv;
<span class="line-modified">1457       MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1458       DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
1459       marked = deps.remove_all_dependents();
1460     }
1461     if (marked &gt; 0) {
1462       // At least one nmethod has been marked for deoptimization
<span class="line-modified">1463       Deoptimization::deoptimize_all_marked();</span>

1464     }
1465   }
1466 }
1467 JVM_END
1468 
1469 /**
1470  * Throws a java/lang/UnsupportedOperationException unconditionally.
1471  * This is required by the specification of MethodHandle.invoke if
1472  * invoked directly.
1473  */
1474 JVM_ENTRY(jobject, MH_invoke_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1475   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invoke cannot be invoked reflectively&quot;);
1476   return NULL;
1477 }
1478 JVM_END
1479 
1480 /**
1481  * Throws a java/lang/UnsupportedOperationException unconditionally.
1482  * This is required by the specification of MethodHandle.invokeExact if
1483  * invoked directly.
</pre>
</td>
</tr>
</table>
<center><a href="methodComparator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
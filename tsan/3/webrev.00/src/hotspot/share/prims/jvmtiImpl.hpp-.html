<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvmtiImpl.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIIMPL_HPP
 26 #define SHARE_PRIMS_JVMTIIMPL_HPP
 27 
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;jvmtifiles/jvmti.h&quot;
 30 #include &quot;oops/objArrayOop.hpp&quot;
 31 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 32 #include &quot;prims/jvmtiEventController.hpp&quot;
 33 #include &quot;prims/jvmtiTrace.hpp&quot;
 34 #include &quot;prims/jvmtiUtil.hpp&quot;
 35 #include &quot;runtime/stackValueCollection.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;utilities/ostream.hpp&quot;
 38 
 39 //
 40 // Forward Declarations
 41 //
 42 
 43 class JvmtiBreakpoint;
 44 class JvmtiBreakpoints;
 45 
 46 
 47 ///////////////////////////////////////////////////////////////
 48 //
 49 // class GrowableCache, GrowableElement
 50 // Used by              : JvmtiBreakpointCache
 51 // Used by JVMTI methods: none directly.
 52 //
 53 // GrowableCache is a permanent CHeap growable array of &lt;GrowableElement *&gt;
 54 //
 55 // In addition, the GrowableCache maintains a NULL terminated cache array of type address
 56 // that&#39;s created from the element array using the function:
 57 //     address GrowableElement::getCacheValue().
 58 //
 59 // Whenever the GrowableArray changes size, the cache array gets recomputed into a new C_HEAP allocated
 60 // block of memory. Additionally, every time the cache changes its position in memory, the
 61 //    void (*_listener_fun)(void *this_obj, address* cache)
 62 // gets called with the cache&#39;s new address. This gives the user of the GrowableCache a callback
 63 // to update its pointer to the address cache.
 64 //
 65 
 66 class GrowableElement : public CHeapObj&lt;mtInternal&gt; {
 67 public:
 68   virtual ~GrowableElement() {}
 69   virtual address getCacheValue()          =0;
 70   virtual bool equals(GrowableElement* e)  =0;
 71   virtual bool lessThan(GrowableElement *e)=0;
 72   virtual GrowableElement *clone()         =0;
 73   virtual void oops_do(OopClosure* f)      =0;
 74   virtual void metadata_do(void f(Metadata*)) =0;
 75 };
 76 
 77 class GrowableCache {
 78 
 79 private:
 80   // Object pointer passed into cache &amp; listener functions.
 81   void *_this_obj;
 82 
 83   // Array of elements in the collection
 84   GrowableArray&lt;GrowableElement *&gt; *_elements;
 85 
 86   // Parallel array of cached values
 87   address *_cache;
 88 
 89   // Listener for changes to the _cache field.
 90   // Called whenever the _cache field has it&#39;s value changed
 91   // (but NOT when cached elements are recomputed).
 92   void (*_listener_fun)(void *, address*);
 93 
 94   static bool equals(void *, GrowableElement *);
 95 
 96   // recache all elements after size change, notify listener
 97   void recache();
 98 
 99 public:
100    GrowableCache();
101    ~GrowableCache();
102 
103   void initialize(void *this_obj, void listener_fun(void *, address*) );
104 
105   // number of elements in the collection
106   int length();
107   // get the value of the index element in the collection
108   GrowableElement* at(int index);
109   // find the index of the element, -1 if it doesn&#39;t exist
110   int find(GrowableElement* e);
111   // append a copy of the element to the end of the collection, notify listener
112   void append(GrowableElement* e);
113   // insert a copy of the element using lessthan(), notify listener
114   void insert(GrowableElement* e);
115   // remove the element at index, notify listener
116   void remove (int index);
117   // clear out all elements and release all heap space, notify listener
118   void clear();
119   // apply f to every element and update the cache
120   void oops_do(OopClosure* f);
121   // walk metadata to preserve for RedefineClasses
122   void metadata_do(void f(Metadata*));
123   // update the cache after a full gc
124   void gc_epilogue();
125 };
126 
127 
128 ///////////////////////////////////////////////////////////////
129 //
130 // class JvmtiBreakpointCache
131 // Used by              : JvmtiBreakpoints
132 // Used by JVMTI methods: none directly.
133 // Note   : typesafe wrapper for GrowableCache of JvmtiBreakpoint
134 //
135 
136 class JvmtiBreakpointCache : public CHeapObj&lt;mtInternal&gt; {
137 
138 private:
139   GrowableCache _cache;
140 
141 public:
142   JvmtiBreakpointCache()  {}
143   ~JvmtiBreakpointCache() {}
144 
145   void initialize(void *this_obj, void listener_fun(void *, address*) ) {
146     _cache.initialize(this_obj,listener_fun);
147   }
148 
149   int length()                          { return _cache.length(); }
150   JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
151   int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
152   void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
153   void remove (int index)               { _cache.remove(index); }
154   void clear()                          { _cache.clear(); }
155   void oops_do(OopClosure* f)           { _cache.oops_do(f); }
156   void metadata_do(void f(Metadata*))   { _cache.metadata_do(f); }
157   void gc_epilogue()                    { _cache.gc_epilogue(); }
158 };
159 
160 
161 ///////////////////////////////////////////////////////////////
162 //
163 // class JvmtiBreakpoint
164 // Used by              : JvmtiBreakpoints
165 // Used by JVMTI methods: SetBreakpoint, ClearBreakpoint, ClearAllBreakpoints
166 // Note: Extends GrowableElement for use in a GrowableCache
167 //
168 // A JvmtiBreakpoint describes a location (class, method, bci) to break at.
169 //
170 
171 typedef void (Method::*method_action)(int _bci);
172 
173 class JvmtiBreakpoint : public GrowableElement {
174 private:
175   Method*               _method;
176   int                   _bci;
177   Bytecodes::Code       _orig_bytecode;
178   oop                   _class_holder;  // keeps _method memory from being deallocated
179 
180 public:
181   JvmtiBreakpoint();
182   JvmtiBreakpoint(Method* m_method, jlocation location);
183   bool equals(JvmtiBreakpoint&amp; bp);
184   bool lessThan(JvmtiBreakpoint &amp;bp);
185   void copy(JvmtiBreakpoint&amp; bp);
186   bool is_valid();
187   address getBcp() const;
188   void each_method_version_do(method_action meth_act);
189   void set();
190   void clear();
191   void print_on(outputStream* out) const;
192 
193   Method* method() { return _method; }
194 
195   // GrowableElement implementation
196   address getCacheValue()         { return getBcp(); }
197   bool lessThan(GrowableElement* e) { Unimplemented(); return false; }
198   bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }
199   void oops_do(OopClosure* f)     {
200     // Mark the method loader as live so the Method* class loader doesn&#39;t get
201     // unloaded and Method* memory reclaimed.
202     f-&gt;do_oop(&amp;_class_holder);
203   }
204   void metadata_do(void f(Metadata*)) {
205     // walk metadata to preserve for RedefineClasses
206     f(_method);
207   }
208 
209   GrowableElement *clone()        {
210     JvmtiBreakpoint *bp = new JvmtiBreakpoint();
211     bp-&gt;copy(*this);
212     return bp;
213   }
214 };
215 
216 
217 ///////////////////////////////////////////////////////////////
218 //
219 // class JvmtiBreakpoints
220 // Used by              : JvmtiCurrentBreakpoints
221 // Used by JVMTI methods: none directly
222 // Note: A Helper class
223 //
224 // JvmtiBreakpoints is a GrowableCache of JvmtiBreakpoint.
225 // All changes to the GrowableCache occur at a safepoint using VM_ChangeBreakpoints.
226 //
227 // Because _bps is only modified at safepoints, its possible to always use the
228 // cached byte code pointers from _bps without doing any synchronization (see JvmtiCurrentBreakpoints).
229 //
230 // It would be possible to make JvmtiBreakpoints a static class, but I&#39;ve made it
231 // CHeap allocated to emphasize its similarity to JvmtiFramePops.
232 //
233 
234 class JvmtiBreakpoints : public CHeapObj&lt;mtInternal&gt; {
235 private:
236 
237   JvmtiBreakpointCache _bps;
238 
239   // These should only be used by VM_ChangeBreakpoints
240   // to insure they only occur at safepoints.
241   // Todo: add checks for safepoint
242   friend class VM_ChangeBreakpoints;
243   void set_at_safepoint(JvmtiBreakpoint&amp; bp);
244   void clear_at_safepoint(JvmtiBreakpoint&amp; bp);
245 
246   static void do_element(GrowableElement *e);
247 
248 public:
249   JvmtiBreakpoints(void listener_fun(void *, address *));
250   ~JvmtiBreakpoints();
251 
252   int length();
253   void oops_do(OopClosure* f);
254   void metadata_do(void f(Metadata*));
255   void print();
256 
257   int  set(JvmtiBreakpoint&amp; bp);
258   int  clear(JvmtiBreakpoint&amp; bp);
259   void clearall_in_class_at_safepoint(Klass* klass);
260   void gc_epilogue();
261 };
262 
263 
264 ///////////////////////////////////////////////////////////////
265 //
266 // class JvmtiCurrentBreakpoints
267 //
268 // A static wrapper class for the JvmtiBreakpoints that provides:
269 // 1. a fast inlined function to check if a byte code pointer is a breakpoint (is_breakpoint).
270 // 2. a function for lazily creating the JvmtiBreakpoints class (this is not strictly necessary,
271 //    but I&#39;m copying the code from JvmtiThreadState which needs to lazily initialize
272 //    JvmtiFramePops).
273 // 3. An oops_do entry point for GC&#39;ing the breakpoint array.
274 //
275 
276 class JvmtiCurrentBreakpoints : public AllStatic {
277 
278 private:
279 
280   // Current breakpoints, lazily initialized by get_jvmti_breakpoints();
281   static JvmtiBreakpoints *_jvmti_breakpoints;
282 
283   // NULL terminated cache of byte-code pointers corresponding to current breakpoints.
284   // Updated only at safepoints (with listener_fun) when the cache is moved.
285   // It exists only to make is_breakpoint fast.
286   static address          *_breakpoint_list;
287   static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }
288   static inline address *get_breakpoint_list()                     { return _breakpoint_list; }
289 
290   // Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.
291   static void listener_fun(void *this_obj, address *cache);
292 
293 public:
294   static void initialize();
295   static void destroy();
296 
297   // lazily create _jvmti_breakpoints and _breakpoint_list
298   static JvmtiBreakpoints&amp; get_jvmti_breakpoints();
299 
300   static void oops_do(OopClosure* f);
301   static void metadata_do(void f(Metadata*)) NOT_JVMTI_RETURN;
302   static void gc_epilogue();
303 };
304 
305 ///////////////////////////////////////////////////////////////
306 //
307 // class VM_ChangeBreakpoints
308 // Used by              : JvmtiBreakpoints
309 // Used by JVMTI methods: none directly.
310 // Note: A Helper class.
311 //
312 // VM_ChangeBreakpoints implements a VM_Operation for ALL modifications to the JvmtiBreakpoints class.
313 //
314 
315 class VM_ChangeBreakpoints : public VM_Operation {
316 private:
317   JvmtiBreakpoints* _breakpoints;
318   int               _operation;
319   JvmtiBreakpoint*  _bp;
320 
321 public:
322   enum { SET_BREAKPOINT=0, CLEAR_BREAKPOINT=1 };
323 
324   VM_ChangeBreakpoints(int operation, JvmtiBreakpoint *bp) {
325     JvmtiBreakpoints&amp; current_bps = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
326     _breakpoints = &amp;current_bps;
327     _bp = bp;
328     _operation = operation;
329     assert(bp != NULL, &quot;bp != NULL&quot;);
330   }
331 
332   VMOp_Type type() const { return VMOp_ChangeBreakpoints; }
333   void doit();
334   void oops_do(OopClosure* f);
335   void metadata_do(void f(Metadata*));
336 };
337 
338 
339 ///////////////////////////////////////////////////////////////
340 // The get/set local operations must only be done by the VM thread
341 // because the interpreter version needs to access oop maps, which can
342 // only safely be done by the VM thread
343 //
344 // I&#39;m told that in 1.5 oop maps are now protected by a lock and
345 // we could get rid of the VM op
346 // However if the VM op is removed then the target thread must
347 // be suspended AND a lock will be needed to prevent concurrent
348 // setting of locals to the same java thread. This lock is needed
349 // to prevent compiledVFrames from trying to add deferred updates
350 // to the thread simultaneously.
351 //
352 class VM_GetOrSetLocal : public VM_Operation {
353  protected:
354   JavaThread* _thread;
355   JavaThread* _calling_thread;
356   jint        _depth;
357   jint        _index;
358   BasicType   _type;
359   jvalue      _value;
360   javaVFrame* _jvf;
361   bool        _set;
362 
363   // It is possible to get the receiver out of a non-static native wrapper
364   // frame.  Use VM_GetReceiver to do this.
365   virtual bool getting_receiver() const { return false; }
366 
367   jvmtiError  _result;
368 
369   vframe* get_vframe();
370   javaVFrame* get_java_vframe();
371   bool check_slot_type_lvt(javaVFrame* vf);
372   bool check_slot_type_no_lvt(javaVFrame* vf);
373 
374 public:
375   // Constructor for non-object getter
376   VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type);
377 
378   // Constructor for object or non-object setter
379   VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value);
380 
381   // Constructor for object getter
382   VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth,
383                    int index);
384 
385   VMOp_Type type() const { return VMOp_GetOrSetLocal; }
386   jvalue value()         { return _value; }
387   jvmtiError result()    { return _result; }
388 
389   bool doit_prologue();
390   void doit();
391   bool allow_nested_vm_operations() const;
392   const char* name() const                       { return &quot;get/set locals&quot;; }
393 
394   // Check that the klass is assignable to a type with the given signature.
395   static bool is_assignable(const char* ty_sign, Klass* klass, Thread* thread);
396 };
397 
398 class VM_GetReceiver : public VM_GetOrSetLocal {
399  protected:
400   virtual bool getting_receiver() const { return true; }
401 
402  public:
403   VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth);
404   const char* name() const                       { return &quot;get receiver&quot;; }
405 };
406 
407 
408 ///////////////////////////////////////////////////////////////
409 //
410 // class JvmtiSuspendControl
411 //
412 // Convenience routines for suspending and resuming threads.
413 //
414 // All attempts by JVMTI to suspend and resume threads must go through the
415 // JvmtiSuspendControl interface.
416 //
417 // methods return true if successful
418 //
419 class JvmtiSuspendControl : public AllStatic {
420 public:
421   // suspend the thread, taking it to a safepoint
422   static bool suspend(JavaThread *java_thread);
423   // resume the thread
424   static bool resume(JavaThread *java_thread);
425 
426   static void print();
427 };
428 
429 
430 /**
431  * When a thread (such as the compiler thread or VM thread) cannot post a
432  * JVMTI event itself because the event needs to be posted from a Java
433  * thread, then it can defer the event to the Service thread for posting.
434  * The information needed to post the event is encapsulated into this class
435  * and then enqueued onto the JvmtiDeferredEventQueue, where the Service
436  * thread will pick it up and post it.
437  *
438  * This is currently only used for posting compiled-method-load and unload
439  * events, which we don&#39;t want posted from the compiler thread.
440  */
441 class JvmtiDeferredEvent {
442   friend class JvmtiDeferredEventQueue;
443  private:
444   typedef enum {
445     TYPE_NONE,
446     TYPE_COMPILED_METHOD_LOAD,
447     TYPE_COMPILED_METHOD_UNLOAD,
448     TYPE_DYNAMIC_CODE_GENERATED
449   } Type;
450 
451   Type _type;
452   union {
453     nmethod* compiled_method_load;
454     struct {
455       nmethod* nm;
456       jmethodID method_id;
457       const void* code_begin;
458     } compiled_method_unload;
459     struct {
460       const char* name;
461       const void* code_begin;
462       const void* code_end;
463     } dynamic_code_generated;
464   } _event_data;
465 
466   JvmtiDeferredEvent(Type t) : _type(t) {}
467 
468  public:
469 
470   JvmtiDeferredEvent() : _type(TYPE_NONE) {}
471 
472   // Factory methods
473   static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
474     NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
475   static JvmtiDeferredEvent compiled_method_unload_event(nmethod* nm,
476       jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
477   static JvmtiDeferredEvent dynamic_code_generated_event(
478       const char* name, const void* begin, const void* end)
479           NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
480 
481   // Actually posts the event.
482   void post() NOT_JVMTI_RETURN;
483 };
484 
485 /**
486  * Events enqueued on this queue wake up the Service thread which dequeues
487  * and posts the events.  The Service_lock is required to be held
488  * when operating on the queue.
489  */
490 class JvmtiDeferredEventQueue : AllStatic {
491   friend class JvmtiDeferredEvent;
492  private:
493   class QueueNode : public CHeapObj&lt;mtInternal&gt; {
494    private:
495     JvmtiDeferredEvent _event;
496     QueueNode* _next;
497 
498    public:
499     QueueNode(const JvmtiDeferredEvent&amp; event)
500       : _event(event), _next(NULL) {}
501 
502     const JvmtiDeferredEvent&amp; event() const { return _event; }
503     QueueNode* next() const { return _next; }
504 
505     void set_next(QueueNode* next) { _next = next; }
506   };
507 
508   static QueueNode* _queue_head;             // Hold Service_lock to access
509   static QueueNode* _queue_tail;             // Hold Service_lock to access
510 
511  public:
512   // Must be holding Service_lock when calling these
513   static bool has_events() NOT_JVMTI_RETURN_(false);
514   static void enqueue(const JvmtiDeferredEvent&amp; event) NOT_JVMTI_RETURN;
515   static JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
516 };
517 
518 // Utility macro that checks for NULL pointers:
519 #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
520 
521 #endif // SHARE_PRIMS_JVMTIIMPL_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiImpl.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiImpl.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiLib.xsl.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiImpl.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 66,14 ***</span>
  class GrowableElement : public CHeapObj&lt;mtInternal&gt; {
  public:
    virtual ~GrowableElement() {}
    virtual address getCacheValue()          =0;
    virtual bool equals(GrowableElement* e)  =0;
<span class="line-removed">-   virtual bool lessThan(GrowableElement *e)=0;</span>
    virtual GrowableElement *clone()         =0;
<span class="line-removed">-   virtual void oops_do(OopClosure* f)      =0;</span>
<span class="line-removed">-   virtual void metadata_do(void f(Metadata*)) =0;</span>
  };
  
  class GrowableCache {
  
  private:
<span class="line-new-header">--- 66,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,22 ***</span>
    GrowableElement* at(int index);
    // find the index of the element, -1 if it doesn&#39;t exist
    int find(GrowableElement* e);
    // append a copy of the element to the end of the collection, notify listener
    void append(GrowableElement* e);
<span class="line-removed">-   // insert a copy of the element using lessthan(), notify listener</span>
<span class="line-removed">-   void insert(GrowableElement* e);</span>
    // remove the element at index, notify listener
    void remove (int index);
    // clear out all elements and release all heap space, notify listener
    void clear();
<span class="line-removed">-   // apply f to every element and update the cache</span>
<span class="line-removed">-   void oops_do(OopClosure* f);</span>
<span class="line-removed">-   // walk metadata to preserve for RedefineClasses</span>
<span class="line-removed">-   void metadata_do(void f(Metadata*));</span>
<span class="line-removed">-   // update the cache after a full gc</span>
<span class="line-removed">-   void gc_epilogue();</span>
  };
  
  
  ///////////////////////////////////////////////////////////////
  //
<span class="line-new-header">--- 105,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,22 ***</span>
  public:
    JvmtiBreakpointCache()  {}
    ~JvmtiBreakpointCache() {}
  
    void initialize(void *this_obj, void listener_fun(void *, address*) ) {
<span class="line-modified">!     _cache.initialize(this_obj,listener_fun);</span>
    }
  
    int length()                          { return _cache.length(); }
    JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
    int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
    void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
    void remove (int index)               { _cache.remove(index); }
<span class="line-removed">-   void clear()                          { _cache.clear(); }</span>
<span class="line-removed">-   void oops_do(OopClosure* f)           { _cache.oops_do(f); }</span>
<span class="line-removed">-   void metadata_do(void f(Metadata*))   { _cache.metadata_do(f); }</span>
<span class="line-removed">-   void gc_epilogue()                    { _cache.gc_epilogue(); }</span>
  };
  
  
  ///////////////////////////////////////////////////////////////
  //
<span class="line-new-header">--- 130,18 ---</span>
  public:
    JvmtiBreakpointCache()  {}
    ~JvmtiBreakpointCache() {}
  
    void initialize(void *this_obj, void listener_fun(void *, address*) ) {
<span class="line-modified">!     _cache.initialize(this_obj, listener_fun);</span>
    }
  
    int length()                          { return _cache.length(); }
    JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
    int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
    void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
    void remove (int index)               { _cache.remove(index); }
  };
  
  
  ///////////////////////////////////////////////////////////////
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,41 ***</span>
  
  class JvmtiBreakpoint : public GrowableElement {
  private:
    Method*               _method;
    int                   _bci;
<span class="line-modified">!   Bytecodes::Code       _orig_bytecode;</span>
<span class="line-removed">-   oop                   _class_holder;  // keeps _method memory from being deallocated</span>
  
  public:
<span class="line-modified">!   JvmtiBreakpoint();</span>
    JvmtiBreakpoint(Method* m_method, jlocation location);
    bool equals(JvmtiBreakpoint&amp; bp);
<span class="line-removed">-   bool lessThan(JvmtiBreakpoint &amp;bp);</span>
    void copy(JvmtiBreakpoint&amp; bp);
<span class="line-removed">-   bool is_valid();</span>
    address getBcp() const;
    void each_method_version_do(method_action meth_act);
    void set();
    void clear();
    void print_on(outputStream* out) const;
  
    Method* method() { return _method; }
  
    // GrowableElement implementation
    address getCacheValue()         { return getBcp(); }
<span class="line-removed">-   bool lessThan(GrowableElement* e) { Unimplemented(); return false; }</span>
    bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }
<span class="line-removed">-   void oops_do(OopClosure* f)     {</span>
<span class="line-removed">-     // Mark the method loader as live so the Method* class loader doesn&#39;t get</span>
<span class="line-removed">-     // unloaded and Method* memory reclaimed.</span>
<span class="line-removed">-     f-&gt;do_oop(&amp;_class_holder);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   void metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">-     // walk metadata to preserve for RedefineClasses</span>
<span class="line-removed">-     f(_method);</span>
<span class="line-removed">-   }</span>
  
    GrowableElement *clone()        {
      JvmtiBreakpoint *bp = new JvmtiBreakpoint();
      bp-&gt;copy(*this);
      return bp;
<span class="line-new-header">--- 157,29 ---</span>
  
  class JvmtiBreakpoint : public GrowableElement {
  private:
    Method*               _method;
    int                   _bci;
<span class="line-modified">!   oop*                  _class_holder;  // keeps _method memory from being deallocated</span>
  
  public:
<span class="line-modified">!   JvmtiBreakpoint() : _method(NULL), _bci(0), _class_holder(NULL) {}</span>
    JvmtiBreakpoint(Method* m_method, jlocation location);
<span class="line-added">+   virtual ~JvmtiBreakpoint();</span>
    bool equals(JvmtiBreakpoint&amp; bp);
    void copy(JvmtiBreakpoint&amp; bp);
    address getBcp() const;
    void each_method_version_do(method_action meth_act);
    void set();
    void clear();
    void print_on(outputStream* out) const;
  
    Method* method() { return _method; }
  
    // GrowableElement implementation
    address getCacheValue()         { return getBcp(); }
    bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }
  
    GrowableElement *clone()        {
      JvmtiBreakpoint *bp = new JvmtiBreakpoint();
      bp-&gt;copy(*this);
      return bp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,25 ***</span>
    // Todo: add checks for safepoint
    friend class VM_ChangeBreakpoints;
    void set_at_safepoint(JvmtiBreakpoint&amp; bp);
    void clear_at_safepoint(JvmtiBreakpoint&amp; bp);
  
<span class="line-removed">-   static void do_element(GrowableElement *e);</span>
<span class="line-removed">- </span>
  public:
    JvmtiBreakpoints(void listener_fun(void *, address *));
    ~JvmtiBreakpoints();
  
    int length();
<span class="line-removed">-   void oops_do(OopClosure* f);</span>
<span class="line-removed">-   void metadata_do(void f(Metadata*));</span>
    void print();
  
    int  set(JvmtiBreakpoint&amp; bp);
    int  clear(JvmtiBreakpoint&amp; bp);
    void clearall_in_class_at_safepoint(Klass* klass);
<span class="line-removed">-   void gc_epilogue();</span>
  };
  
  
  ///////////////////////////////////////////////////////////////
  //
<span class="line-new-header">--- 214,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,25 ***</span>
    // NULL terminated cache of byte-code pointers corresponding to current breakpoints.
    // Updated only at safepoints (with listener_fun) when the cache is moved.
    // It exists only to make is_breakpoint fast.
    static address          *_breakpoint_list;
    static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }
<span class="line-removed">-   static inline address *get_breakpoint_list()                     { return _breakpoint_list; }</span>
  
    // Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.
    static void listener_fun(void *this_obj, address *cache);
  
  public:
    static void initialize();
    static void destroy();
  
    // lazily create _jvmti_breakpoints and _breakpoint_list
    static JvmtiBreakpoints&amp; get_jvmti_breakpoints();
<span class="line-removed">- </span>
<span class="line-removed">-   static void oops_do(OopClosure* f);</span>
<span class="line-removed">-   static void metadata_do(void f(Metadata*)) NOT_JVMTI_RETURN;</span>
<span class="line-removed">-   static void gc_epilogue();</span>
  };
  
  ///////////////////////////////////////////////////////////////
  //
  // class VM_ChangeBreakpoints
<span class="line-new-header">--- 251,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,12 ***</span>
      assert(bp != NULL, &quot;bp != NULL&quot;);
    }
  
    VMOp_Type type() const { return VMOp_ChangeBreakpoints; }
    void doit();
<span class="line-removed">-   void oops_do(OopClosure* f);</span>
<span class="line-removed">-   void metadata_do(void f(Metadata*));</span>
  };
  
  
  ///////////////////////////////////////////////////////////////
  // The get/set local operations must only be done by the VM thread
<span class="line-new-header">--- 292,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,26 ***</span>
   private:
    typedef enum {
      TYPE_NONE,
      TYPE_COMPILED_METHOD_LOAD,
      TYPE_COMPILED_METHOD_UNLOAD,
<span class="line-modified">!     TYPE_DYNAMIC_CODE_GENERATED</span>
    } Type;
  
    Type _type;
    union {
      nmethod* compiled_method_load;
      struct {
<span class="line-removed">-       nmethod* nm;</span>
        jmethodID method_id;
        const void* code_begin;
      } compiled_method_unload;
      struct {
        const char* name;
        const void* code_begin;
        const void* code_end;
      } dynamic_code_generated;
    } _event_data;
  
    JvmtiDeferredEvent(Type t) : _type(t) {}
  
   public:
<span class="line-new-header">--- 404,29 ---</span>
   private:
    typedef enum {
      TYPE_NONE,
      TYPE_COMPILED_METHOD_LOAD,
      TYPE_COMPILED_METHOD_UNLOAD,
<span class="line-modified">!     TYPE_DYNAMIC_CODE_GENERATED,</span>
<span class="line-added">+     TYPE_CLASS_UNLOAD</span>
    } Type;
  
    Type _type;
    union {
      nmethod* compiled_method_load;
      struct {
        jmethodID method_id;
        const void* code_begin;
      } compiled_method_unload;
      struct {
        const char* name;
        const void* code_begin;
        const void* code_end;
      } dynamic_code_generated;
<span class="line-added">+     struct {</span>
<span class="line-added">+       const char* name;</span>
<span class="line-added">+     } class_unload;</span>
    } _event_data;
  
    JvmtiDeferredEvent(Type t) : _type(t) {}
  
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,26 ***</span>
    JvmtiDeferredEvent() : _type(TYPE_NONE) {}
  
    // Factory methods
    static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
      NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-modified">!   static JvmtiDeferredEvent compiled_method_unload_event(nmethod* nm,</span>
        jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
    static JvmtiDeferredEvent dynamic_code_generated_event(
        const char* name, const void* begin, const void* end)
            NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
  
    // Actually posts the event.
    void post() NOT_JVMTI_RETURN;
  };
  
  /**
   * Events enqueued on this queue wake up the Service thread which dequeues
   * and posts the events.  The Service_lock is required to be held
   * when operating on the queue.
   */
<span class="line-modified">! class JvmtiDeferredEventQueue : AllStatic {</span>
    friend class JvmtiDeferredEvent;
   private:
    class QueueNode : public CHeapObj&lt;mtInternal&gt; {
     private:
      JvmtiDeferredEvent _event;
<span class="line-new-header">--- 434,34 ---</span>
    JvmtiDeferredEvent() : _type(TYPE_NONE) {}
  
    // Factory methods
    static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
      NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-modified">!   static JvmtiDeferredEvent compiled_method_unload_event(</span>
        jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
    static JvmtiDeferredEvent dynamic_code_generated_event(
        const char* name, const void* begin, const void* end)
            NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
<span class="line-added">+   static JvmtiDeferredEvent class_unload_event(</span>
<span class="line-added">+       const char* name) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>
  
    // Actually posts the event.
    void post() NOT_JVMTI_RETURN;
<span class="line-added">+   void post_compiled_method_load_event(JvmtiEnv* env) NOT_JVMTI_RETURN;</span>
<span class="line-added">+   void run_nmethod_entry_barriers() NOT_JVMTI_RETURN;</span>
<span class="line-added">+   // Sweeper support to keep nmethods from being zombied while in the queue.</span>
<span class="line-added">+   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
<span class="line-added">+   // GC support to keep nmethod from being unloaded while in the queue.</span>
<span class="line-added">+   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
  };
  
  /**
   * Events enqueued on this queue wake up the Service thread which dequeues
   * and posts the events.  The Service_lock is required to be held
   * when operating on the queue.
   */
<span class="line-modified">! class JvmtiDeferredEventQueue : public CHeapObj&lt;mtInternal&gt; {</span>
    friend class JvmtiDeferredEvent;
   private:
    class QueueNode : public CHeapObj&lt;mtInternal&gt; {
     private:
      JvmtiDeferredEvent _event;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 497,24 ***</span>
  
     public:
      QueueNode(const JvmtiDeferredEvent&amp; event)
        : _event(event), _next(NULL) {}
  
<span class="line-modified">!     const JvmtiDeferredEvent&amp; event() const { return _event; }</span>
      QueueNode* next() const { return _next; }
  
      void set_next(QueueNode* next) { _next = next; }
    };
  
<span class="line-modified">!   static QueueNode* _queue_head;             // Hold Service_lock to access</span>
<span class="line-modified">!   static QueueNode* _queue_tail;             // Hold Service_lock to access</span>
  
   public:
<span class="line-modified">!   // Must be holding Service_lock when calling these</span>
<span class="line-modified">!   static bool has_events() NOT_JVMTI_RETURN_(false);</span>
<span class="line-modified">!   static void enqueue(const JvmtiDeferredEvent&amp; event) NOT_JVMTI_RETURN;</span>
<span class="line-modified">!   static JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>
  };
  
  // Utility macro that checks for NULL pointers:
  #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
  
<span class="line-new-header">--- 469,34 ---</span>
  
     public:
      QueueNode(const JvmtiDeferredEvent&amp; event)
        : _event(event), _next(NULL) {}
  
<span class="line-modified">!     JvmtiDeferredEvent&amp; event() { return _event; }</span>
      QueueNode* next() const { return _next; }
  
      void set_next(QueueNode* next) { _next = next; }
    };
  
<span class="line-modified">!   QueueNode* _queue_head;</span>
<span class="line-modified">!   QueueNode* _queue_tail;</span>
  
   public:
<span class="line-modified">!   JvmtiDeferredEventQueue() : _queue_head(NULL), _queue_tail(NULL) {}</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool has_events() NOT_JVMTI_RETURN_(false);</span>
<span class="line-modified">!   JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Post all events in the queue for the current Jvmti environment</span>
<span class="line-added">+   void post(JvmtiEnv* env) NOT_JVMTI_RETURN;</span>
<span class="line-added">+   void enqueue(JvmtiDeferredEvent event) NOT_JVMTI_RETURN;</span>
<span class="line-added">+   void run_nmethod_entry_barriers();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Sweeper support to keep nmethods from being zombied while in the queue.</span>
<span class="line-added">+   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
<span class="line-added">+   // GC support to keep nmethod from being unloaded while in the queue.</span>
<span class="line-added">+   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
  };
  
  // Utility macro that checks for NULL pointers:
  #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
  
</pre>
<center><a href="jvmtiImpl.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiLib.xsl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markOop.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/jniCheck.hpp&quot;
  62 #include &quot;prims/jniExport.hpp&quot;
  63 #include &quot;prims/jniFastGetField.hpp&quot;
  64 #include &quot;prims/jvm_misc.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiThreadState.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/compilationPolicy.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/orderAccess.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/safepointVerifiers.hpp&quot;
  79 #include &quot;runtime/sharedRuntime.hpp&quot;
  80 #include &quot;runtime/signature.hpp&quot;
  81 #include &quot;runtime/thread.inline.hpp&quot;
  82 #include &quot;runtime/vmOperations.hpp&quot;
  83 #include &quot;services/memTracker.hpp&quot;
  84 #include &quot;services/runtimeService.hpp&quot;
  85 #include &quot;utilities/defaultStream.hpp&quot;
  86 #include &quot;utilities/dtrace.hpp&quot;
  87 #include &quot;utilities/events.hpp&quot;
  88 #include &quot;utilities/histogram.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/vmError.hpp&quot;
  91 #if INCLUDE_JVMCI
  92 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  93 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  94 #endif
  95 
  96 static jint CurrentVersion = JNI_VERSION_10;
  97 
  98 #ifdef _WIN32
  99 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
 100 #endif
 101 
 102 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 103 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 104 // Methods that have multiple return paths use this to avoid having to
 105 // instrument each return path.  Methods that use CHECK or THROW must use this
 106 // since those macros can cause an immedate uninstrumented return.
 107 //
 108 // In order to get the return value, a reference to the variable containing
 109 // the return value must be passed to the contructor of the object, and
 110 // the return value must be set before return (since the mark object has
 111 // a reference to it).
 112 //
 113 // Example:
 114 // DT_RETURN_MARK_DECL(SomeFunc, int);
 115 // JNI_ENTRY(int, SomeFunc, ...)
 116 //   int return_value = 0;
 117 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 118 //   foo(CHECK_0)
 119 //   return_value = 5;
 120 //   return return_value;
 121 // JNI_END
 122 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 123   DTRACE_ONLY(                                                             \
 124     class DTraceReturnProbeMark_##name {                                   \
 125      public:                                                               \
 126       const type&amp; _ret_ref;                                                \
 127       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 128       ~DTraceReturnProbeMark_##name() {                                    \
 129         probe;                                                             \
 130       }                                                                    \
 131     }                                                                      \
 132   )
 133 // Void functions are simpler since there&#39;s no return value
 134 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 135   DTRACE_ONLY(                                                             \
 136     class DTraceReturnProbeMark_##name {                                   \
 137      public:                                                               \
 138       ~DTraceReturnProbeMark_##name() {                                    \
 139         probe;                                                             \
 140       }                                                                    \
 141     }                                                                      \
 142   )
 143 
 144 // Place these macros in the function to mark the return.  Non-void
 145 // functions need the type and address of the return value.
 146 #define DT_RETURN_MARK(name, type, ref) \
 147   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 148 #define DT_VOID_RETURN_MARK(name) \
 149   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 150 
 151 
 152 // Use these to select distinct code for floating-point vs. non-floating point
 153 // situations.  Used from within common macros where we need slightly
 154 // different behavior for Float/Double
 155 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 156 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 157 #define FP_SELECT_Char(intcode, fpcode)    intcode
 158 #define FP_SELECT_Short(intcode, fpcode)   intcode
 159 #define FP_SELECT_Object(intcode, fpcode)  intcode
 160 #define FP_SELECT_Int(intcode, fpcode)     intcode
 161 #define FP_SELECT_Long(intcode, fpcode)    intcode
 162 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 163 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 164 #define FP_SELECT(TypeName, intcode, fpcode) \
 165   FP_SELECT_##TypeName(intcode, fpcode)
 166 
 167 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 168 // (dtrace doesn&#39;t do FP yet)
 169 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 172 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 173   FP_SELECT(TypeName, \
 174     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 175 
 176 
 177 // out-of-line helpers for class jfieldIDWorkaround:
 178 
 179 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 180   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 181     uintptr_t as_uint = (uintptr_t) id;
 182     intptr_t offset = raw_instance_offset(id);
 183     if (is_checked_jfieldID(id)) {
 184       if (!klass_hash_ok(k, id)) {
 185         return false;
 186       }
 187     }
 188     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 189   } else {
 190     JNIid* result = (JNIid*) id;
 191 #ifdef ASSERT
 192     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 193 #else
 194     return result != NULL;
 195 #endif
 196   }
 197 }
 198 
 199 
 200 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 201   if (offset &lt;= small_offset_mask) {
 202     Klass* field_klass = k;
 203     Klass* super_klass = field_klass-&gt;super();
 204     // With compressed oops the most super class with nonstatic fields would
 205     // be the owner of fields embedded in the header.
 206     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 207            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 208       field_klass = super_klass;   // super contains the field also
 209       super_klass = field_klass-&gt;super();
 210     }
 211     debug_only(NoSafepointVerifier nosafepoint;)
 212     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 213     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 214   } else {
 215 #if 0
 216     #ifndef PRODUCT
 217     {
 218       ResourceMark rm;
 219       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 220     }
 221     #endif
 222 #endif
 223     return 0;
 224   }
 225 }
 226 
 227 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 228   uintptr_t as_uint = (uintptr_t) id;
 229   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 230   do {
 231     debug_only(NoSafepointVerifier nosafepoint;)
 232     // Could use a non-blocking query for identity_hash here...
 233     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 234       return true;
 235     k = k-&gt;super();
 236   } while (k != NULL);
 237   return false;
 238 }
 239 
 240 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 241   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 242   uintptr_t as_uint = (uintptr_t) id;
 243   intptr_t offset = raw_instance_offset(id);
 244   if (VerifyJNIFields) {
 245     if (is_checked_jfieldID(id)) {
 246       guarantee(klass_hash_ok(k, id),
 247     &quot;Bug in native code: jfieldID class must match object&quot;);
 248     } else {
 249 #if 0
 250       #ifndef PRODUCT
 251       if (Verbose) {
 252   ResourceMark rm;
 253   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 254       }
 255       #endif
 256 #endif
 257     }
 258   }
 259   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 260       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 261 }
 262 
 263 // Wrapper to trace JNI functions
 264 
 265 #ifdef ASSERT
 266   Histogram* JNIHistogram;
 267   static volatile int JNIHistogram_lock = 0;
 268 
 269   class JNIHistogramElement : public HistogramElement {
 270     public:
 271      JNIHistogramElement(const char* name);
 272   };
 273 
 274   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 275     _name = elementName;
 276     uintx count = 0;
 277 
 278     while (Atomic::cmpxchg(1, &amp;JNIHistogram_lock, 0) != 0) {
 279       while (OrderAccess::load_acquire(&amp;JNIHistogram_lock) != 0) {
 280         count +=1;
 281         if ( (WarnOnStalledSpinLock &gt; 0)
 282           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 283           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 284         }
 285       }
 286      }
 287 
 288 
 289     if(JNIHistogram == NULL)
 290       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 291 
 292     JNIHistogram-&gt;add_element(this);
 293     Atomic::dec(&amp;JNIHistogram_lock);
 294   }
 295 
 296   #define JNICountWrapper(arg)                                     \
 297      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 298       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 299      if (e != NULL) e-&gt;increment_count()
 300   #define JNIWrapper(arg) JNICountWrapper(arg);
 301 #else
 302   #define JNIWrapper(arg)
 303 #endif
 304 
 305 
 306 // Implementation of JNI entries
 307 
 308 DT_RETURN_MARK_DECL(DefineClass, jclass
 309                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 310 
 311 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 312                                   const jbyte *buf, jsize bufLen))
 313   JNIWrapper(&quot;DefineClass&quot;);
 314 
 315   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 316     env, (char*) name, loaderRef, (char*) buf, bufLen);
 317 
 318   jclass cls = NULL;
 319   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 320 
 321   TempNewSymbol class_name = NULL;
 322   // Since exceptions can be thrown, class initialization can take place
 323   // if name is NULL no check for class name in .class stream has to be made.
 324   if (name != NULL) {
 325     const int str_len = (int)strlen(name);
 326     if (str_len &gt; Symbol::max_length()) {
 327       // It&#39;s impossible to create this class;  the name cannot fit
 328       // into the constant pool.
 329       Exceptions::fthrow(THREAD_AND_LOCATION,
 330                          vmSymbols::java_lang_NoClassDefFoundError(),
 331                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 332                          Symbol::max_length(),
 333                          name);
 334       return 0;
 335     }
 336     class_name = SymbolTable::new_symbol(name, CHECK_NULL);
 337   }
 338   ResourceMark rm(THREAD);
 339   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 340   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 341 
 342   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 343     // check whether the current caller thread holds the lock or not.
 344     // If not, increment the corresponding counter
 345     if (ObjectSynchronizer::
 346         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 347         ObjectSynchronizer::owner_self) {
 348       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 349     }
 350   }
 351   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 352                                                    class_loader,
 353                                                    Handle(),
 354                                                    &amp;st,
 355                                                    CHECK_NULL);
 356 
 357   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 358     trace_class_resolution(k);
 359   }
 360 
 361   cls = (jclass)JNIHandles::make_local(
 362     env, k-&gt;java_mirror());
 363   return cls;
 364 JNI_END
 365 
 366 
 367 
 368 DT_RETURN_MARK_DECL(FindClass, jclass
 369                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 370 
 371 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 372   JNIWrapper(&quot;FindClass&quot;);
 373 
 374   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 375 
 376   jclass result = NULL;
 377   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 378 
 379   // Sanity check the name:  it cannot be null or larger than the maximum size
 380   // name we can fit in the constant pool.
 381   if (name == NULL) {
 382     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 383   }
 384   if ((int)strlen(name) &gt; Symbol::max_length()) {
 385     Exceptions::fthrow(THREAD_AND_LOCATION,
 386                        vmSymbols::java_lang_NoClassDefFoundError(),
 387                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 388                        Symbol::max_length(),
 389                        name);
 390     return 0;
 391   }
 392 
 393   //%note jni_3
 394   Handle protection_domain;
 395   // Find calling class
 396   Klass* k = thread-&gt;security_get_caller_class(0);
 397   // default to the system loader when no context
 398   Handle loader(THREAD, SystemDictionary::java_system_loader());
 399   if (k != NULL) {
 400     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 401     // in the correct class context.
 402     if (k-&gt;class_loader() == NULL &amp;&amp;
 403         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 404       JavaValue result(T_OBJECT);
 405       JavaCalls::call_static(&amp;result, k,
 406                              vmSymbols::getFromClass_name(),
 407                              vmSymbols::void_class_signature(),
 408                              CHECK_NULL);
 409       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 410       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 411       // it will return NULL to indicate no context.
 412       oop mirror = (oop) result.get_jobject();
 413       if (mirror != NULL) {
 414         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 415         loader = Handle(THREAD, fromClass-&gt;class_loader());
 416         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 417       }
 418     } else {
 419       loader = Handle(THREAD, k-&gt;class_loader());
 420     }
 421   }
 422 
 423   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
 424   result = find_class_from_class_loader(env, sym, true, loader,
 425                                         protection_domain, true, thread);
 426 
 427   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 428     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 429   }
 430 
 431   return result;
 432 JNI_END
 433 
 434 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 435                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 436 
 437 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 438   JNIWrapper(&quot;FromReflectedMethod&quot;);
 439 
 440   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 441 
 442   jmethodID ret = NULL;
 443   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 444 
 445   // method is a handle to a java.lang.reflect.Method object
 446   oop reflected  = JNIHandles::resolve_non_null(method);
 447   oop mirror     = NULL;
 448   int slot       = 0;
 449 
 450   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 451     mirror = java_lang_reflect_Constructor::clazz(reflected);
 452     slot   = java_lang_reflect_Constructor::slot(reflected);
 453   } else {
 454     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 455     mirror = java_lang_reflect_Method::clazz(reflected);
 456     slot   = java_lang_reflect_Method::slot(reflected);
 457   }
 458   Klass* k1 = java_lang_Class::as_Klass(mirror);
 459 
 460   // Make sure class is initialized before handing id&#39;s out to methods
 461   k1-&gt;initialize(CHECK_NULL);
 462   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 463   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 464   return ret;
 465 JNI_END
 466 
 467 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 468                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 469 
 470 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 471   JNIWrapper(&quot;FromReflectedField&quot;);
 472 
 473   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 474 
 475   jfieldID ret = NULL;
 476   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 477 
 478   // field is a handle to a java.lang.reflect.Field object
 479   oop reflected   = JNIHandles::resolve_non_null(field);
 480   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 481   Klass* k1       = java_lang_Class::as_Klass(mirror);
 482   int slot        = java_lang_reflect_Field::slot(reflected);
 483   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 484 
 485   // Make sure class is initialized before handing id&#39;s out to fields
 486   k1-&gt;initialize(CHECK_NULL);
 487 
 488   // First check if this is a static field
 489   if (modifiers &amp; JVM_ACC_STATIC) {
 490     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 491     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 492     assert(id != NULL, &quot;corrupt Field object&quot;);
 493     debug_only(id-&gt;set_is_static_field_id();)
 494     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 495     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 496     return ret;
 497   }
 498 
 499   // The slot is the index of the field description in the field-array
 500   // The jfieldID is the offset of the field within the object
 501   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 502   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 503   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 504   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
 505   return ret;
 506 JNI_END
 507 
 508 
 509 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 510                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 511 
 512 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 513   JNIWrapper(&quot;ToReflectedMethod&quot;);
 514 
 515   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 516 
 517   jobject ret = NULL;
 518   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 519 
 520   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 521   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 522   oop reflection_method;
 523   if (m-&gt;is_initializer()) {
 524     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 525   } else {
 526     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 527   }
 528   ret = JNIHandles::make_local(env, reflection_method);
 529   return ret;
 530 JNI_END
 531 
 532 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 533                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 534 
 535 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 536   JNIWrapper(&quot;GetSuperclass&quot;);
 537 
 538   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 539 
 540   jclass obj = NULL;
 541   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 542 
 543   oop mirror = JNIHandles::resolve_non_null(sub);
 544   // primitive classes return NULL
 545   if (java_lang_Class::is_primitive(mirror)) return NULL;
 546 
 547   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 548   // arrays return Object
 549   // interfaces return NULL
 550   // proper classes return Klass::super()
 551   Klass* k = java_lang_Class::as_Klass(mirror);
 552   if (k-&gt;is_interface()) return NULL;
 553 
 554   // return mirror for superclass
 555   Klass* super = k-&gt;java_super();
 556   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 557   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 558                                  ? SystemDictionary::Object_klass()
 559                                  : k-&gt;super() ) );
 560   assert(super == super2,
 561          &quot;java_super computation depends on interface, array, other super&quot;);
 562   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 563   return obj;
 564 JNI_END
 565 
 566 JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 567   JNIWrapper(&quot;IsSubclassOf&quot;);
 568 
 569   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 570 
 571   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 572   oop super_mirror = JNIHandles::resolve_non_null(super);
 573   if (java_lang_Class::is_primitive(sub_mirror) ||
 574       java_lang_Class::is_primitive(super_mirror)) {
 575     jboolean ret = oopDesc::equals(sub_mirror, super_mirror);
 576 
 577     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 578     return ret;
 579   }
 580   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 581   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 582   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 583   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 584                    JNI_TRUE : JNI_FALSE;
 585 
 586   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 587   return ret;
 588 JNI_END
 589 
 590 
 591 DT_RETURN_MARK_DECL(Throw, jint
 592                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 593 
 594 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 595   JNIWrapper(&quot;Throw&quot;);
 596 
 597   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 598 
 599   jint ret = JNI_OK;
 600   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 601 
 602   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 603   ShouldNotReachHere();
 604   return 0;  // Mute compiler.
 605 JNI_END
 606 
 607 
 608 DT_RETURN_MARK_DECL(ThrowNew, jint
 609                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 610 
 611 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 612   JNIWrapper(&quot;ThrowNew&quot;);
 613 
 614   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 615 
 616   jint ret = JNI_OK;
 617   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 618 
 619   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 620   Symbol*  name = k-&gt;name();
 621   Handle class_loader (THREAD,  k-&gt;class_loader());
 622   Handle protection_domain (THREAD, k-&gt;protection_domain());
 623   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 624   ShouldNotReachHere();
 625   return 0;  // Mute compiler.
 626 JNI_END
 627 
 628 
 629 // JNI functions only transform a pending async exception to a synchronous
 630 // exception in ExceptionOccurred and ExceptionCheck calls, since
 631 // delivering an async exception in other places won&#39;t change the native
 632 // code&#39;s control flow and would be harmful when native code further calls
 633 // JNI functions with a pending exception. Async exception is also checked
 634 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 635 // false but deliver the async exception at the very end during
 636 // state transition.
 637 
 638 static void jni_check_async_exceptions(JavaThread *thread) {
 639   assert(thread == Thread::current(), &quot;must be itself&quot;);
 640   thread-&gt;check_and_handle_async_exceptions();
 641 }
 642 
 643 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 644   JNIWrapper(&quot;ExceptionOccurred&quot;);
 645 
 646   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 647 
 648   jni_check_async_exceptions(thread);
 649   oop exception = thread-&gt;pending_exception();
 650   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 651 
 652   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 653   return ret;
 654 JNI_END
 655 
 656 
 657 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 658   JNIWrapper(&quot;ExceptionDescribe&quot;);
 659 
 660   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 661 
 662   if (thread-&gt;has_pending_exception()) {
 663     Handle ex(thread, thread-&gt;pending_exception());
 664     thread-&gt;clear_pending_exception();
 665     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 666       // Don&#39;t print anything if we are being killed.
 667     } else {
 668       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 669       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 670         ResourceMark rm(THREAD);
 671         jio_fprintf(defaultStream::error_stream(),
 672         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 673       }
 674       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 675         JavaValue result(T_VOID);
 676         JavaCalls::call_virtual(&amp;result,
 677                                 ex,
 678                                 SystemDictionary::Throwable_klass(),
 679                                 vmSymbols::printStackTrace_name(),
 680                                 vmSymbols::void_method_signature(),
 681                                 THREAD);
 682         // If an exception is thrown in the call it gets thrown away. Not much
 683         // we can do with it. The native code that calls this, does not check
 684         // for the exception - hence, it might still be in the thread when DestroyVM gets
 685         // called, potentially causing a few asserts to trigger - since no pending exception
 686         // is expected.
 687         CLEAR_PENDING_EXCEPTION;
 688       } else {
 689         ResourceMark rm(THREAD);
 690         jio_fprintf(defaultStream::error_stream(),
 691         &quot;. Uncaught exception of type %s.&quot;,
 692         ex-&gt;klass()-&gt;external_name());
 693       }
 694     }
 695   }
 696 
 697   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 698 JNI_END
 699 
 700 
 701 JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))
 702   JNIWrapper(&quot;ExceptionClear&quot;);
 703 
 704   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 705 
 706   // The jni code might be using this API to clear java thrown exception.
 707   // So just mark jvmti thread exception state as exception caught.
 708   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 709   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 710     state-&gt;set_exception_caught();
 711   }
 712   thread-&gt;clear_pending_exception();
 713 
 714   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 715 JNI_END
 716 
 717 
 718 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 719   JNIWrapper(&quot;FatalError&quot;);
 720 
 721   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 722 
 723   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 724   thread-&gt;print_stack();
 725   os::abort(); // Dump core and abort
 726 JNI_END
 727 
 728 
 729 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 730   JNIWrapper(&quot;PushLocalFrame&quot;);
 731 
 732   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 733 
 734   //%note jni_11
 735   if (capacity &lt; 0 ||
 736       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 737     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 738     return JNI_ERR;
 739   }
 740   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 741   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 742   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 743   new_handles-&gt;set_pop_frame_link(old_handles);
 744   thread-&gt;set_active_handles(new_handles);
 745   jint ret = JNI_OK;
 746   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 747   return ret;
 748 JNI_END
 749 
 750 
 751 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 752   JNIWrapper(&quot;PopLocalFrame&quot;);
 753 
 754   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 755 
 756   //%note jni_11
 757   Handle result_handle(thread, JNIHandles::resolve(result));
 758   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 759   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 760   if (new_handles != NULL) {
 761     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 762     // This way code will still work if PopLocalFrame is called without a corresponding
 763     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 764     // the release_block call will release the blocks.
 765     thread-&gt;set_active_handles(new_handles);
 766     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 767     JNIHandleBlock::release_block(old_handles, thread); // may block
 768     result = JNIHandles::make_local(thread, result_handle());
 769   }
 770   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 771   return result;
 772 JNI_END
 773 
 774 
 775 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 776   JNIWrapper(&quot;NewGlobalRef&quot;);
 777 
 778   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 779 
 780   Handle ref_handle(thread, JNIHandles::resolve(ref));
 781   jobject ret = JNIHandles::make_global(ref_handle);
 782 
 783   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 784   return ret;
 785 JNI_END
 786 
 787 // Must be JNI_ENTRY (with HandleMark)
 788 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 789   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 790 
 791   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 792 
 793   JNIHandles::destroy_global(ref);
 794 
 795   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 796 JNI_END
 797 
 798 JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 799   JNIWrapper(&quot;DeleteLocalRef&quot;);
 800 
 801   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 802 
 803   JNIHandles::destroy_local(obj);
 804 
 805   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 806 JNI_END
 807 
 808 JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 809   JNIWrapper(&quot;IsSameObject&quot;);
 810 
 811   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 812 
 813   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 814 
 815   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 816   return ret;
 817 JNI_END
 818 
 819 
 820 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 821   JNIWrapper(&quot;NewLocalRef&quot;);
 822 
 823   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 824 
 825   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 826 
 827   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 828   return ret;
 829 JNI_END
 830 
 831 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 832   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 833 
 834   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 835 
 836   jint ret;
 837   if (capacity &gt;= 0 &amp;&amp;
 838       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 839     ret = JNI_OK;
 840   } else {
 841     ret = JNI_ERR;
 842   }
 843 
 844   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 845   return ret;
 846 JNI_END
 847 
 848 // Return the Handle Type
 849 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 850   JNIWrapper(&quot;GetObjectRefType&quot;);
 851 
 852   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 853 
 854   jobjectRefType ret = JNIInvalidRefType;
 855   if (obj != NULL) {
 856     ret = JNIHandles::handle_type(thread, obj);
 857   }
 858 
 859   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 860   return ret;
 861 JNI_END
 862 
 863 
 864 class JNI_ArgumentPusher : public SignatureIterator {
 865  protected:
 866   JavaCallArguments*  _arguments;
 867 
 868   virtual void get_bool   () = 0;
 869   virtual void get_char   () = 0;
 870   virtual void get_short  () = 0;
 871   virtual void get_byte   () = 0;
 872   virtual void get_int    () = 0;
 873   virtual void get_long   () = 0;
 874   virtual void get_float  () = 0;
 875   virtual void get_double () = 0;
 876   virtual void get_object () = 0;
 877 
 878   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {
 879     this-&gt;_return_type = T_ILLEGAL;
 880     _arguments = NULL;
 881   }
 882 
 883  public:
 884   virtual void iterate( uint64_t fingerprint ) = 0;
 885 
 886   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }
 887 
 888   inline void do_bool()                     { if (!is_return_type()) get_bool();   }
 889   inline void do_char()                     { if (!is_return_type()) get_char();   }
 890   inline void do_short()                    { if (!is_return_type()) get_short();  }
 891   inline void do_byte()                     { if (!is_return_type()) get_byte();   }
 892   inline void do_int()                      { if (!is_return_type()) get_int();    }
 893   inline void do_long()                     { if (!is_return_type()) get_long();   }
 894   inline void do_float()                    { if (!is_return_type()) get_float();  }
 895   inline void do_double()                   { if (!is_return_type()) get_double(); }
 896   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }
 897   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array
 898   inline void do_void()                     { }
 899 
 900   JavaCallArguments* arguments()     { return _arguments; }
 901   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }
 902 };
 903 
 904 
 905 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 906  protected:
 907   va_list _ap;
 908 
 909   inline void get_bool()   {
 910     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 911     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 912     // TemplateInterpreterGenerator::generate_result_handler_for and
 913     // SharedRuntime::generate_native_wrapper.
 914     jboolean b = va_arg(_ap, jint);
 915     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
 916   }
 917   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg
 918   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg
 919   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg
 920   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }
 921 
 922   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 923 
 924   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }
 925   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg
 926   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }
 927   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }
 928 
 929   inline void set_ap(va_list rap) {
 930     va_copy(_ap, rap);
 931   }
 932 
 933  public:
 934   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)
 935        : JNI_ArgumentPusher(signature) {
 936     set_ap(rap);
 937   }
 938   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 939       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
 940     set_ap(rap);
 941   }
 942 
 943   // Optimized path if we have the bitvector form of signature
 944   void iterate( uint64_t fingerprint ) {
 945     if (fingerprint == (uint64_t)CONST64(-1)) {
 946       SignatureIterator::iterate(); // Must be too many arguments
 947     } else {
 948       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
 949                                   result_feature_mask);
 950 
 951       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);
 952       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
 953       while ( 1 ) {
 954         switch ( fingerprint &amp; parameter_feature_mask ) {
 955           case bool_parm:
 956             get_bool();
 957             break;
 958           case char_parm:
 959             get_char();
 960             break;
 961           case short_parm:
 962             get_short();
 963             break;
 964           case byte_parm:
 965             get_byte();
 966             break;
 967           case int_parm:
 968             get_int();
 969             break;
 970           case obj_parm:
 971             get_object();
 972             break;
 973           case long_parm:
 974             get_long();
 975             break;
 976           case float_parm:
 977             get_float();
 978             break;
 979           case double_parm:
 980             get_double();
 981             break;
 982           case done_parm:
 983             return;
 984             break;
 985           default:
 986             ShouldNotReachHere();
 987             break;
 988         }
 989         fingerprint &gt;&gt;= parameter_feature_size;
 990       }
 991     }
 992   }
 993 };
 994 
 995 
 996 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 997  protected:
 998   const jvalue *_ap;
 999 
1000   inline void get_bool()   {
1001     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
1002     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
1003     // TemplateInterpreterGenerator::generate_result_handler_for and
1004     // SharedRuntime::generate_native_wrapper.
1005     jboolean b = (_ap++)-&gt;z;
1006     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));
1007   }
1008   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }
1009   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }
1010   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }
1011   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }
1012 
1013   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }
1014   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }
1015   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}
1016   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }
1017 
1018   inline void set_ap(const jvalue *rap) { _ap = rap; }
1019 
1020  public:
1021   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)
1022        : JNI_ArgumentPusher(signature) {
1023     set_ap(rap);
1024   }
1025   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
1026       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
1027     set_ap(rap);
1028   }
1029 
1030   // Optimized path if we have the bitvector form of signature
1031   void iterate( uint64_t fingerprint ) {
1032     if (fingerprint == (uint64_t)CONST64(-1)) {
1033       SignatureIterator::iterate(); // Must be too many arguments
1034     } else {
1035       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
1036                                   result_feature_mask);
1037       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);
1038       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
1039       while ( 1 ) {
1040         switch ( fingerprint &amp; parameter_feature_mask ) {
1041           case bool_parm:
1042             get_bool();
1043             break;
1044           case char_parm:
1045             get_char();
1046             break;
1047           case short_parm:
1048             get_short();
1049             break;
1050           case byte_parm:
1051             get_byte();
1052             break;
1053           case int_parm:
1054             get_int();
1055             break;
1056           case obj_parm:
1057             get_object();
1058             break;
1059           case long_parm:
1060             get_long();
1061             break;
1062           case float_parm:
1063             get_float();
1064             break;
1065           case double_parm:
1066             get_double();
1067             break;
1068           case done_parm:
1069             return;
1070             break;
1071           default:
1072             ShouldNotReachHere();
1073             break;
1074         }
1075         fingerprint &gt;&gt;= parameter_feature_size;
1076       }
1077     }
1078   }
1079 };
1080 
1081 
1082 enum JNICallType {
1083   JNI_STATIC,
1084   JNI_VIRTUAL,
1085   JNI_NONVIRTUAL
1086 };
1087 
1088 
1089 
1090 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1091   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1092 
1093   // Create object to hold arguments for the JavaCall, and associate it with
1094   // the jni parser
1095   ResourceMark rm(THREAD);
1096   int number_of_parameters = method-&gt;size_of_parameters();
1097   JavaCallArguments java_args(number_of_parameters);
1098   args-&gt;set_java_argument_object(&amp;java_args);
1099 
1100   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1101 
1102   // Fill out JavaCallArguments object
1103   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1104   // Initialize result type
1105   result-&gt;set_type(args-&gt;get_ret_type());
1106 
1107   // Invoke the method. Result is returned as oop.
1108   JavaCalls::call(result, method, &amp;java_args, CHECK);
1109 
1110   // Convert result
1111   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1112     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1113   }
1114 }
1115 
1116 
1117 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1118   oop recv = JNIHandles::resolve(receiver);
1119   if (recv == NULL) {
1120     THROW(vmSymbols::java_lang_NullPointerException());
1121   }
1122   Handle h_recv(THREAD, recv);
1123 
1124   int number_of_parameters;
1125   Method* selected_method;
1126   {
1127     Method* m = Method::resolve_jmethod_id(method_id);
1128     number_of_parameters = m-&gt;size_of_parameters();
1129     Klass* holder = m-&gt;method_holder();
1130     if (call_type != JNI_VIRTUAL) {
1131         selected_method = m;
1132     } else if (!m-&gt;has_itable_index()) {
1133       // non-interface call -- for that little speed boost, don&#39;t handlize
1134       debug_only(NoSafepointVerifier nosafepoint;)
1135       // jni_GetMethodID makes sure class is linked and initialized
1136       // so m should have a valid vtable index.
1137       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1138       int vtbl_index = m-&gt;vtable_index();
1139       if (vtbl_index != Method::nonvirtual_vtable_index) {
1140         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1141       } else {
1142         // final method
1143         selected_method = m;
1144       }
1145     } else {
1146       // interface call
1147       int itbl_index = m-&gt;itable_index();
1148       Klass* k = h_recv-&gt;klass();
1149       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1150     }
1151   }
1152 
1153   methodHandle method(THREAD, selected_method);
1154 
1155   // Create object to hold arguments for the JavaCall, and associate it with
1156   // the jni parser
1157   ResourceMark rm(THREAD);
1158   JavaCallArguments java_args(number_of_parameters);
1159   args-&gt;set_java_argument_object(&amp;java_args);
1160 
1161   // handle arguments
1162   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1163   args-&gt;push_receiver(h_recv); // Push jobject handle
1164 
1165   // Fill out JavaCallArguments object
1166   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1167   // Initialize result type
1168   result-&gt;set_type(args-&gt;get_ret_type());
1169 
1170   // Invoke the method. Result is returned as oop.
1171   JavaCalls::call(result, method, &amp;java_args, CHECK);
1172 
1173   // Convert result
1174   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1175     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1176   }
1177 }
1178 
1179 
1180 static instanceOop alloc_object(jclass clazz, TRAPS) {
1181   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1182   if (k == NULL) {
1183     ResourceMark rm(THREAD);
1184     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1185   }
1186   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1187   k-&gt;initialize(CHECK_NULL);
1188   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1189   return ih;
1190 }
1191 
1192 DT_RETURN_MARK_DECL(AllocObject, jobject
1193                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1194 
1195 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1196   JNIWrapper(&quot;AllocObject&quot;);
1197 
1198   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1199 
1200   jobject ret = NULL;
1201   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1202 
1203   instanceOop i = alloc_object(clazz, CHECK_NULL);
1204   ret = JNIHandles::make_local(env, i);
1205   return ret;
1206 JNI_END
1207 
1208 DT_RETURN_MARK_DECL(NewObjectA, jobject
1209                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1210 
1211 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1212   JNIWrapper(&quot;NewObjectA&quot;);
1213 
1214   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1215 
1216   jobject obj = NULL;
1217   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1218 
1219   instanceOop i = alloc_object(clazz, CHECK_NULL);
1220   obj = JNIHandles::make_local(env, i);
1221   JavaValue jvalue(T_VOID);
1222   JNI_ArgumentPusherArray ap(methodID, args);
1223   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1224   return obj;
1225 JNI_END
1226 
1227 
1228 DT_RETURN_MARK_DECL(NewObjectV, jobject
1229                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1230 
1231 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1232   JNIWrapper(&quot;NewObjectV&quot;);
1233 
1234   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1235 
1236   jobject obj = NULL;
1237   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1238 
1239   instanceOop i = alloc_object(clazz, CHECK_NULL);
1240   obj = JNIHandles::make_local(env, i);
1241   JavaValue jvalue(T_VOID);
1242   JNI_ArgumentPusherVaArg ap(methodID, args);
1243   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1244   return obj;
1245 JNI_END
1246 
1247 
1248 DT_RETURN_MARK_DECL(NewObject, jobject
1249                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1250 
1251 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1252   JNIWrapper(&quot;NewObject&quot;);
1253 
1254   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1255 
1256   jobject obj = NULL;
1257   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1258 
1259   instanceOop i = alloc_object(clazz, CHECK_NULL);
1260   obj = JNIHandles::make_local(env, i);
1261   va_list args;
1262   va_start(args, methodID);
1263   JavaValue jvalue(T_VOID);
1264   JNI_ArgumentPusherVaArg ap(methodID, args);
1265   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1266   va_end(args);
1267   return obj;
1268 JNI_END
1269 
1270 
1271 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1272   JNIWrapper(&quot;GetObjectClass&quot;);
1273 
1274   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1275 
1276   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1277   jclass ret =
1278     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1279 
1280   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1281   return ret;
1282 JNI_END
1283 
1284 JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1285   JNIWrapper(&quot;IsInstanceOf&quot;);
1286 
1287   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1288 
1289   jboolean ret = JNI_TRUE;
1290   if (obj != NULL) {
1291     ret = JNI_FALSE;
1292     Klass* k = java_lang_Class::as_Klass(
1293       JNIHandles::resolve_non_null(clazz));
1294     if (k != NULL) {
1295       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1296     }
1297   }
1298 
1299   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1300   return ret;
1301 JNI_END
1302 
1303 
1304 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1305                                const char *sig, bool is_static, TRAPS) {
1306   // %%%% This code should probably just call into a method in the LinkResolver
1307   //
1308   // The class should have been loaded (we have an instance of the class
1309   // passed in) so the method and signature should already be in the symbol
1310   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1311   const char *name_to_probe = (name_str == NULL)
1312                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1313                         : name_str;
1314   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1315   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1316 
1317   if (name == NULL || signature == NULL) {
1318     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1319   }
1320 
1321   // Throw a NoSuchMethodError exception if we have an instance of a
1322   // primitive java.lang.Class
1323   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1324     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1325   }
1326 
1327   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1328 
1329   // Make sure class is linked and initialized before handing id&#39;s out to
1330   // Method*s.
1331   klass-&gt;initialize(CHECK_NULL);
1332 
1333   Method* m;
1334   if (name == vmSymbols::object_initializer_name() ||
1335       name == vmSymbols::class_initializer_name()) {
1336     // Never search superclasses for constructors
1337     if (klass-&gt;is_instance_klass()) {
1338       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1339     } else {
1340       m = NULL;
1341     }
1342   } else {
1343     m = klass-&gt;lookup_method(name, signature);
1344     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1345       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1346     }
1347   }
1348   if (m == NULL || (m-&gt;is_static() != is_static)) {
1349     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1350   }
1351   return m-&gt;jmethod_id();
1352 }
1353 
1354 
1355 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1356           const char *name, const char *sig))
1357   JNIWrapper(&quot;GetMethodID&quot;);
1358   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1359   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1360   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1361   return ret;
1362 JNI_END
1363 
1364 
1365 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1366           const char *name, const char *sig))
1367   JNIWrapper(&quot;GetStaticMethodID&quot;);
1368   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1369   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1370   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1371   return ret;
1372 JNI_END
1373 
1374 
1375 
1376 //
1377 // Calling Methods
1378 //
1379 
1380 
1381 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1382                           , EntryProbe, ReturnProbe)    \
1383 \
1384   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1385                           , ReturnProbe);                          \
1386 \
1387 JNI_ENTRY(ResultType, \
1388           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1389   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1390 \
1391   EntryProbe; \
1392   ResultType ret = 0;\
1393   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1394                      (const ResultType&amp;)ret);\
1395 \
1396   va_list args; \
1397   va_start(args, methodID); \
1398   JavaValue jvalue(Tag); \
1399   JNI_ArgumentPusherVaArg ap(methodID, args); \
1400   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1401   va_end(args); \
1402   ret = jvalue.get_##ResultType(); \
1403   return ret;\
1404 JNI_END
1405 
1406 // the runtime type of subword integral basic types is integer
1407 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1408                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1409                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1410 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1411                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1412                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1413 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1414                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1415                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1416 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1417                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1418                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1419 
1420 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1421                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1422                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1423 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1424                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1425                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1426 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1427                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1428                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1429 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1430 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1431                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1432                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1433 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1434                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1435                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1436 
1437 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1438                           , EntryProbe, ReturnProbe)    \
1439 \
1440   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1441                           , ReturnProbe);                          \
1442 \
1443 JNI_ENTRY(ResultType, \
1444           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1445   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1446 \
1447   EntryProbe;\
1448   ResultType ret = 0;\
1449   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1450                      (const ResultType&amp;)ret);\
1451 \
1452   JavaValue jvalue(Tag); \
1453   JNI_ArgumentPusherVaArg ap(methodID, args); \
1454   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1455   ret = jvalue.get_##ResultType(); \
1456   return ret;\
1457 JNI_END
1458 
1459 // the runtime type of subword integral basic types is integer
1460 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1461                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1462                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1463 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1464                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1465                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1466 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1467                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1468                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1469 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1470                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1471                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1472 
1473 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1474                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1475                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1476 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1477                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1478                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1479 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1480                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1481                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1482 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1483 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1484                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1485                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1486 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1487                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1488                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1489 
1490 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1491                           , EntryProbe, ReturnProbe)    \
1492 \
1493   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1494                           , ReturnProbe);                          \
1495 \
1496 JNI_ENTRY(ResultType, \
1497           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1498   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1499   EntryProbe; \
1500   ResultType ret = 0;\
1501   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1502                      (const ResultType&amp;)ret);\
1503 \
1504   JavaValue jvalue(Tag); \
1505   JNI_ArgumentPusherArray ap(methodID, args); \
1506   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1507   ret = jvalue.get_##ResultType(); \
1508   return ret;\
1509 JNI_END
1510 
1511 // the runtime type of subword integral basic types is integer
1512 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1513                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1514                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1515 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1516                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1517                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1518 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1519                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1520                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1521 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1522                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1523                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1524 
1525 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1526                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1527                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1528 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1529                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1530                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1531 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1532                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1533                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1534 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1535 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1536                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1537                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1538 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1539                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1540                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1541 
1542 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1543 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1544 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1545 
1546 
1547 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1548   JNIWrapper(&quot;CallVoidMethod&quot;);
1549   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1550   DT_VOID_RETURN_MARK(CallVoidMethod);
1551 
1552   va_list args;
1553   va_start(args, methodID);
1554   JavaValue jvalue(T_VOID);
1555   JNI_ArgumentPusherVaArg ap(methodID, args);
1556   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1557   va_end(args);
1558 JNI_END
1559 
1560 
1561 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1562   JNIWrapper(&quot;CallVoidMethodV&quot;);
1563   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1564   DT_VOID_RETURN_MARK(CallVoidMethodV);
1565 
1566   JavaValue jvalue(T_VOID);
1567   JNI_ArgumentPusherVaArg ap(methodID, args);
1568   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1569 JNI_END
1570 
1571 
1572 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1573   JNIWrapper(&quot;CallVoidMethodA&quot;);
1574   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1575   DT_VOID_RETURN_MARK(CallVoidMethodA);
1576 
1577   JavaValue jvalue(T_VOID);
1578   JNI_ArgumentPusherArray ap(methodID, args);
1579   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1580 JNI_END
1581 
1582 
1583 
1584 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1585                                     , EntryProbe, ReturnProbe)      \
1586 \
1587   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1588                           , ReturnProbe);\
1589 \
1590 JNI_ENTRY(ResultType, \
1591           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1592   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1593 \
1594   EntryProbe;\
1595   ResultType ret;\
1596   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1597                      (const ResultType&amp;)ret);\
1598 \
1599   va_list args; \
1600   va_start(args, methodID); \
1601   JavaValue jvalue(Tag); \
1602   JNI_ArgumentPusherVaArg ap(methodID, args); \
1603   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1604   va_end(args); \
1605   ret = jvalue.get_##ResultType(); \
1606   return ret;\
1607 JNI_END
1608 
1609 // the runtime type of subword integral basic types is integer
1610 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1611                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1612                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1613 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1614                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1615                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1616 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1617                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1618                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1619 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1620                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1621                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1622 
1623 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1624                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1625                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1626 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1627                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1628                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1629 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1630                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1631 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1632                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1633 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1634                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1635                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1636 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1637                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1638                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1639 
1640 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1641                                     , EntryProbe, ReturnProbe)      \
1642 \
1643   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1644                           , ReturnProbe);\
1645 \
1646 JNI_ENTRY(ResultType, \
1647           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1648   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1649 \
1650   EntryProbe;\
1651   ResultType ret;\
1652   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1653                      (const ResultType&amp;)ret);\
1654 \
1655   JavaValue jvalue(Tag); \
1656   JNI_ArgumentPusherVaArg ap(methodID, args); \
1657   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1658   ret = jvalue.get_##ResultType(); \
1659   return ret;\
1660 JNI_END
1661 
1662 // the runtime type of subword integral basic types is integer
1663 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1664                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1665                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1666 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1667                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1668                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1669 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1670                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1671                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1672 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1673                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1674                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1675 
1676 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1677                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1678                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1679 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1680                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1681                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1682 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1683                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1684 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1685                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1686 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1687                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1688                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1689 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1690                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1691                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1692 
1693 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1694                                     , EntryProbe, ReturnProbe)      \
1695 \
1696   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1697                           , ReturnProbe);\
1698 \
1699 JNI_ENTRY(ResultType, \
1700           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1701   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1702 \
1703   EntryProbe;\
1704   ResultType ret;\
1705   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1706                      (const ResultType&amp;)ret);\
1707 \
1708   JavaValue jvalue(Tag); \
1709   JNI_ArgumentPusherArray ap(methodID, args); \
1710   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1711   ret = jvalue.get_##ResultType(); \
1712   return ret;\
1713 JNI_END
1714 
1715 // the runtime type of subword integral basic types is integer
1716 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1717                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1718                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1719 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1720                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1721                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1722 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1723                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1724                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1725 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1726                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1727                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1728 
1729 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1730                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1731                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1732 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1733                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1734                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1735 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1736                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1737 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1738                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1739 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1740                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1741                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1742 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1743                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1744                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1745 
1746 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1747                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1748 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1749                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1750 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1751                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1752 
1753 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1754   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1755 
1756   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1757   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1758 
1759   va_list args;
1760   va_start(args, methodID);
1761   JavaValue jvalue(T_VOID);
1762   JNI_ArgumentPusherVaArg ap(methodID, args);
1763   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1764   va_end(args);
1765 JNI_END
1766 
1767 
1768 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1769   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1770 
1771   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1772                env, obj, cls, (uintptr_t) methodID);
1773   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1774 
1775   JavaValue jvalue(T_VOID);
1776   JNI_ArgumentPusherVaArg ap(methodID, args);
1777   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1778 JNI_END
1779 
1780 
1781 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1782   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1783   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1784                 env, obj, cls, (uintptr_t) methodID);
1785   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1786   JavaValue jvalue(T_VOID);
1787   JNI_ArgumentPusherArray ap(methodID, args);
1788   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1789 JNI_END
1790 
1791 
1792 
1793 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1794                                 , EntryProbe, ResultProbe) \
1795 \
1796   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1797                           , ResultProbe);                               \
1798 \
1799 JNI_ENTRY(ResultType, \
1800           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1801   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1802 \
1803   EntryProbe; \
1804   ResultType ret = 0;\
1805   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1806                      (const ResultType&amp;)ret);\
1807 \
1808   va_list args; \
1809   va_start(args, methodID); \
1810   JavaValue jvalue(Tag); \
1811   JNI_ArgumentPusherVaArg ap(methodID, args); \
1812   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1813   va_end(args); \
1814   ret = jvalue.get_##ResultType(); \
1815   return ret;\
1816 JNI_END
1817 
1818 // the runtime type of subword integral basic types is integer
1819 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1820                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1821                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1822 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1823                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1824                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1825 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1826                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1827                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1828 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1829                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1830                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1831 
1832 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1833                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1834                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1835 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1836                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1837                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1838 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1839                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1840                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1841 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1842 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1843                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1844                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1845 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1846                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1847                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1848 
1849 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1850                                 , EntryProbe, ResultProbe) \
1851 \
1852   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1853                           , ResultProbe);                               \
1854 \
1855 JNI_ENTRY(ResultType, \
1856           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1857   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1858 \
1859   EntryProbe; \
1860   ResultType ret = 0;\
1861   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1862                      (const ResultType&amp;)ret);\
1863 \
1864   JavaValue jvalue(Tag); \
1865   JNI_ArgumentPusherVaArg ap(methodID, args); \
1866   /* Make sure class is initialized before trying to invoke its method */ \
1867   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1868   k-&gt;initialize(CHECK_0); \
1869   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1870   va_end(args); \
1871   ret = jvalue.get_##ResultType(); \
1872   return ret;\
1873 JNI_END
1874 
1875 // the runtime type of subword integral basic types is integer
1876 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1877                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1878                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1879 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1880                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1881                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1882 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1883                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1884                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1885 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1886                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1887                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1888 
1889 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1890                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1891                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1892 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1893                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1894                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1895 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1896                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1897                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1898 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1899 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1900                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1901                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1902 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1903                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1904                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1905 
1906 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1907                                 , EntryProbe, ResultProbe) \
1908 \
1909   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1910                           , ResultProbe);                               \
1911 \
1912 JNI_ENTRY(ResultType, \
1913           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1914   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1915 \
1916   EntryProbe; \
1917   ResultType ret = 0;\
1918   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1919                      (const ResultType&amp;)ret);\
1920 \
1921   JavaValue jvalue(Tag); \
1922   JNI_ArgumentPusherArray ap(methodID, args); \
1923   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1924   ret = jvalue.get_##ResultType(); \
1925   return ret;\
1926 JNI_END
1927 
1928 // the runtime type of subword integral basic types is integer
1929 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1930                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1931                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1932 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1933                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1934                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1935 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1936                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1937                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1938 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1939                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1940                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1941 
1942 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1943                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1944                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1945 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1946                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1947                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1948 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1949                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1950                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1951 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1952 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1953                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1954                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1955 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1956                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1957                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1958 
1959 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1960                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1961 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1962                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1963 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1964                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1965 
1966 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1967   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1968   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1969   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1970 
1971   va_list args;
1972   va_start(args, methodID);
1973   JavaValue jvalue(T_VOID);
1974   JNI_ArgumentPusherVaArg ap(methodID, args);
1975   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1976   va_end(args);
1977 JNI_END
1978 
1979 
1980 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1981   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1982   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1983   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1984 
1985   JavaValue jvalue(T_VOID);
1986   JNI_ArgumentPusherVaArg ap(methodID, args);
1987   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1988 JNI_END
1989 
1990 
1991 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1992   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1993   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1994   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1995 
1996   JavaValue jvalue(T_VOID);
1997   JNI_ArgumentPusherArray ap(methodID, args);
1998   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1999 JNI_END
2000 
2001 
2002 //
2003 // Accessing Fields
2004 //
2005 
2006 
2007 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2008                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2009 
2010 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2011           const char *name, const char *sig))
2012   JNIWrapper(&quot;GetFieldID&quot;);
2013   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2014   jfieldID ret = 0;
2015   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2016 
2017   // The class should have been loaded (we have an instance of the class
2018   // passed in) so the field and signature should already be in the symbol
2019   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2020   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2021   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2022   if (fieldname == NULL || signame == NULL) {
2023     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2024   }
2025   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2026   // Make sure class is initialized before handing id&#39;s out to fields
2027   k-&gt;initialize(CHECK_NULL);
2028 
2029   fieldDescriptor fd;
2030   if (!k-&gt;is_instance_klass() ||
2031       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
2032     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2033   }
2034 
2035   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2036   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2037   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
2038   return ret;
2039 JNI_END
2040 
2041 
2042 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2043   JNIWrapper(&quot;GetObjectField&quot;);
2044   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2045   oop o = JNIHandles::resolve_non_null(obj);
2046   Klass* k = o-&gt;klass();
2047   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2048   // Keep JVMTI addition small and only check enabled flag here.
2049   // jni_GetField_probe() assumes that is okay to create handles.
2050   if (JvmtiExport::should_post_field_access()) {
2051     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2052   }
2053   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2054   jobject ret = JNIHandles::make_local(env, loaded_obj);
2055   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2056   return ret;
2057 JNI_END
2058 
2059 
2060 
2061 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2062   , EntryProbe, ReturnProbe) \
2063 \
2064   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2065   , ReturnProbe); \
2066 \
2067 JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2068   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2069 \
2070   EntryProbe; \
2071   Return ret = 0;\
2072   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2073 \
2074   oop o = JNIHandles::resolve_non_null(obj); \
2075   Klass* k = o-&gt;klass(); \
2076   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2077   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2078   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2079   /* and creates a ResetNoHandleMark.                                   */ \
2080   if (JvmtiExport::should_post_field_access()) { \
2081     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2082   } \
2083   ret = o-&gt;Fieldname##_field(offset); \
2084   return ret; \
2085 JNI_END
2086 
2087 DEFINE_GETFIELD(jboolean, bool,   Boolean
2088                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2089                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2090 DEFINE_GETFIELD(jbyte,    byte,   Byte
2091                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2092                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2093 DEFINE_GETFIELD(jchar,    char,   Char
2094                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2095                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2096 DEFINE_GETFIELD(jshort,   short,  Short
2097                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2098                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2099 DEFINE_GETFIELD(jint,     int,    Int
2100                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2101                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2102 DEFINE_GETFIELD(jlong,    long,   Long
2103                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2104                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2105 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2106 DEFINE_GETFIELD(jfloat,   float,  Float
2107                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2108                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2109 DEFINE_GETFIELD(jdouble,  double, Double
2110                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2111                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2112 
2113 address jni_GetBooleanField_addr() {
2114   return (address)jni_GetBooleanField;
2115 }
2116 address jni_GetByteField_addr() {
2117   return (address)jni_GetByteField;
2118 }
2119 address jni_GetCharField_addr() {
2120   return (address)jni_GetCharField;
2121 }
2122 address jni_GetShortField_addr() {
2123   return (address)jni_GetShortField;
2124 }
2125 address jni_GetIntField_addr() {
2126   return (address)jni_GetIntField;
2127 }
2128 address jni_GetLongField_addr() {
2129   return (address)jni_GetLongField;
2130 }
2131 address jni_GetFloatField_addr() {
2132   return (address)jni_GetFloatField;
2133 }
2134 address jni_GetDoubleField_addr() {
2135   return (address)jni_GetDoubleField;
2136 }
2137 
2138 JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2139   JNIWrapper(&quot;SetObjectField&quot;);
2140   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2141   oop o = JNIHandles::resolve_non_null(obj);
2142   Klass* k = o-&gt;klass();
2143   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2144   // Keep JVMTI addition small and only check enabled flag here.
2145   // jni_SetField_probe_nh() assumes that is not okay to create handles
2146   // and creates a ResetNoHandleMark.
2147   if (JvmtiExport::should_post_field_modification()) {
2148     jvalue field_value;
2149     field_value.l = value;
2150     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, &#39;L&#39;, (jvalue *)&amp;field_value);
2151   }
2152   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2153   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2154 JNI_END
2155 
2156 
2157 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2158                         , EntryProbe, ReturnProbe) \
2159 \
2160 JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2161   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2162 \
2163   EntryProbe; \
2164 \
2165   oop o = JNIHandles::resolve_non_null(obj); \
2166   Klass* k = o-&gt;klass(); \
2167   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2168   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2169   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2170   /* and creates a ResetNoHandleMark.                                   */ \
2171   if (JvmtiExport::should_post_field_modification()) { \
2172     jvalue field_value; \
2173     field_value.unionType = value; \
2174     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2175   } \
2176   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \
2177   o-&gt;Fieldname##_field_put(offset, value); \
2178   ReturnProbe; \
2179 JNI_END
2180 
2181 DEFINE_SETFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z
2182                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2183                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2184 DEFINE_SETFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b
2185                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2186                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2187 DEFINE_SETFIELD(jchar,    char,   Char,    &#39;C&#39;, c
2188                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2189                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2190 DEFINE_SETFIELD(jshort,   short,  Short,   &#39;S&#39;, s
2191                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2192                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2193 DEFINE_SETFIELD(jint,     int,    Int,     &#39;I&#39;, i
2194                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2195                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2196 DEFINE_SETFIELD(jlong,    long,   Long,    &#39;J&#39;, j
2197                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2198                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2199 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2200 DEFINE_SETFIELD(jfloat,   float,  Float,   &#39;F&#39;, f
2201                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2202                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2203 DEFINE_SETFIELD(jdouble,  double, Double,  &#39;D&#39;, d
2204                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2205                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2206 
2207 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2208                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2209 
2210 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2211   JNIWrapper(&quot;ToReflectedField&quot;);
2212   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2213   jobject ret = NULL;
2214   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2215 
2216   fieldDescriptor fd;
2217   bool found = false;
2218   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2219 
2220   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2221 
2222   if (isStatic) {
2223     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2224     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2225     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2226     found = id-&gt;find_local_field(&amp;fd);
2227   } else {
2228     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2229     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2230     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2231   }
2232   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2233   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2234   ret = JNIHandles::make_local(env, reflected);
2235   return ret;
2236 JNI_END
2237 
2238 
2239 //
2240 // Accessing Static Fields
2241 //
2242 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2243                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2244 
2245 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2246           const char *name, const char *sig))
2247   JNIWrapper(&quot;GetStaticFieldID&quot;);
2248   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2249   jfieldID ret = NULL;
2250   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2251 
2252   // The class should have been loaded (we have an instance of the class
2253   // passed in) so the field and signature should already be in the symbol
2254   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2255   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2256   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2257   if (fieldname == NULL || signame == NULL) {
2258     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2259   }
2260   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2261   // Make sure class is initialized before handing id&#39;s out to static fields
2262   k-&gt;initialize(CHECK_NULL);
2263 
2264   fieldDescriptor fd;
2265   if (!k-&gt;is_instance_klass() ||
2266       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2267     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2268   }
2269 
2270   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2271   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2272   debug_only(id-&gt;set_is_static_field_id();)
2273 
2274   debug_only(id-&gt;verify(fd.field_holder()));
2275 
2276   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2277   return ret;
2278 JNI_END
2279 
2280 
2281 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2282   JNIWrapper(&quot;GetStaticObjectField&quot;);
2283   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2284 #if INCLUDE_JNI_CHECK
2285   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2286 #endif // INCLUDE_JNI_CHECK
2287   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2288   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2289   // Keep JVMTI addition small and only check enabled flag here.
2290   // jni_GetField_probe() assumes that is okay to create handles.
2291   if (JvmtiExport::should_post_field_access()) {
2292     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2293   }
2294   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2295   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2296   return ret;
2297 JNI_END
2298 
2299 
2300 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2301                               , EntryProbe, ReturnProbe) \
2302 \
2303   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2304                           , ReturnProbe);                                          \
2305 \
2306 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2307   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2308   EntryProbe; \
2309   Return ret = 0;\
2310   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2311                      (const Return&amp;)ret);\
2312   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2313   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2314   /* Keep JVMTI addition small and only check enabled flag here. */ \
2315   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2316   if (JvmtiExport::should_post_field_access()) { \
2317     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2318   } \
2319   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2320   return ret;\
2321 JNI_END
2322 
2323 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2324                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2325 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2326                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2327 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2328                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2329 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2330                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2331 DEFINE_GETSTATICFIELD(jint,     int,    Int
2332                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2333 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2334                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2335 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2336 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2337                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2338 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2339                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2340 
2341 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2342   JNIWrapper(&quot;SetStaticObjectField&quot;);
2343  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2344   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2345   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2346   // Keep JVMTI addition small and only check enabled flag here.
2347   // jni_SetField_probe() assumes that is okay to create handles.
2348   if (JvmtiExport::should_post_field_modification()) {
2349     jvalue field_value;
2350     field_value.l = value;
2351     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, &#39;L&#39;, (jvalue *)&amp;field_value);
2352   }
2353   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2354   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2355 JNI_END
2356 
2357 
2358 
2359 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2360                               , EntryProbe, ReturnProbe) \
2361 \
2362 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2363   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2364   EntryProbe; \
2365 \
2366   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2367   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2368   /* Keep JVMTI addition small and only check enabled flag here. */ \
2369   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2370   if (JvmtiExport::should_post_field_modification()) { \
2371     jvalue field_value; \
2372     field_value.unionType = value; \
2373     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2374   } \
2375   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \
2376   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2377   ReturnProbe;\
2378 JNI_END
2379 
2380 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z
2381                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2382                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2383 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b
2384                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2385                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2386 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    &#39;C&#39;, c
2387                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2388                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2389 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   &#39;S&#39;, s
2390                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2391                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2392 DEFINE_SETSTATICFIELD(jint,     int,    Int,     &#39;I&#39;, i
2393                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2394                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2395 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    &#39;J&#39;, j
2396                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2397                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2398 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2399 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   &#39;F&#39;, f
2400                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2401                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2402 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  &#39;D&#39;, d
2403                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2404                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2405 
2406 //
2407 // String Operations
2408 //
2409 
2410 // Unicode Interface
2411 
2412 DT_RETURN_MARK_DECL(NewString, jstring
2413                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2414 
2415 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2416   JNIWrapper(&quot;NewString&quot;);
2417  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2418   jstring ret = NULL;
2419   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2420   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2421   ret = (jstring) JNIHandles::make_local(env, string);
2422   return ret;
2423 JNI_END
2424 
2425 
2426 JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2427   JNIWrapper(&quot;GetStringLength&quot;);
2428   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2429   jsize ret = 0;
2430   oop s = JNIHandles::resolve_non_null(string);
2431   ret = java_lang_String::length(s);
2432  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2433   return ret;
2434 JNI_END
2435 
2436 
2437 JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(
2438   JNIEnv *env, jstring string, jboolean *isCopy))
2439   JNIWrapper(&quot;GetStringChars&quot;);
2440  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2441   jchar* buf = NULL;
2442   oop s = JNIHandles::resolve_non_null(string);
2443   typeArrayOop s_value = java_lang_String::value(s);
2444   if (s_value != NULL) {
2445     int s_len = java_lang_String::length(s, s_value);
2446     bool is_latin1 = java_lang_String::is_latin1(s);
2447     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2448     /* JNI Specification states return NULL on OOM */
2449     if (buf != NULL) {
2450       if (s_len &gt; 0) {
2451         if (!is_latin1) {
2452           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2453                                              buf, s_len);
2454         } else {
2455           for (int i = 0; i &lt; s_len; i++) {
2456             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2457           }
2458         }
2459       }
2460       buf[s_len] = 0;
2461       //%note jni_5
2462       if (isCopy != NULL) {
2463         *isCopy = JNI_TRUE;
2464       }
2465     }
2466   }
2467   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2468   return buf;
2469 JNI_END
2470 
2471 
2472 JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2473   JNIWrapper(&quot;ReleaseStringChars&quot;);
2474   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2475   //%note jni_6
2476   if (chars != NULL) {
2477     // Since String objects are supposed to be immutable, don&#39;t copy any
2478     // new data back.  A bad user will have to go after the char array.
2479     FreeHeap((void*) chars);
2480   }
2481   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2482 JNI_END
2483 
2484 
2485 // UTF Interface
2486 
2487 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2488                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2489 
2490 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2491   JNIWrapper(&quot;NewStringUTF&quot;);
2492   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2493   jstring ret;
2494   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2495 
2496   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2497   ret = (jstring) JNIHandles::make_local(env, result);
2498   return ret;
2499 JNI_END
2500 
2501 
2502 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2503   JNIWrapper(&quot;GetStringUTFLength&quot;);
2504  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2505   oop java_string = JNIHandles::resolve_non_null(string);
2506   jsize ret = java_lang_String::utf8_length(java_string);
2507   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2508   return ret;
2509 JNI_END
2510 
2511 
2512 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2513   JNIWrapper(&quot;GetStringUTFChars&quot;);
2514  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2515   char* result = NULL;
2516   oop java_string = JNIHandles::resolve_non_null(string);
2517   typeArrayOop s_value = java_lang_String::value(java_string);
2518   if (s_value != NULL) {
2519     size_t length = java_lang_String::utf8_length(java_string, s_value);
2520     /* JNI Specification states return NULL on OOM */
2521     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2522     if (result != NULL) {
2523       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2524       if (isCopy != NULL) {
2525         *isCopy = JNI_TRUE;
2526       }
2527     }
2528   }
2529  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2530   return result;
2531 JNI_END
2532 
2533 
2534 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2535   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2536  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2537   if (chars != NULL) {
2538     FreeHeap((char*) chars);
2539   }
2540 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2541 JNI_END
2542 
2543 
2544 JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2545   JNIWrapper(&quot;GetArrayLength&quot;);
2546  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2547   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2548   assert(a-&gt;is_array(), &quot;must be array&quot;);
2549   jsize ret = a-&gt;length();
2550  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2551   return ret;
2552 JNI_END
2553 
2554 
2555 //
2556 // Object Array Operations
2557 //
2558 
2559 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2560                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2561 
2562 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2563   JNIWrapper(&quot;NewObjectArray&quot;);
2564  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2565   jobjectArray ret = NULL;
2566   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2567   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2568   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2569   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2570   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2571   oop initial_value = JNIHandles::resolve(initialElement);
2572   if (initial_value != NULL) {  // array already initialized with NULL
2573     for (int index = 0; index &lt; length; index++) {
2574       result-&gt;obj_at_put(index, initial_value);
2575     }
2576   }
2577   ret = (jobjectArray) JNIHandles::make_local(env, result);
2578   return ret;
2579 JNI_END
2580 
2581 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2582                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2583 
2584 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2585   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2586  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2587   jobject ret = NULL;
2588   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2589   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2590   if (a-&gt;is_within_bounds(index)) {
2591     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2592     return ret;
2593   } else {
2594     ResourceMark rm(THREAD);
2595     stringStream ss;
2596     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2597     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2598   }
2599 JNI_END
2600 
2601 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2602                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2603 
2604 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2605   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2606  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2607   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2608 
2609   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2610   oop v = JNIHandles::resolve(value);
2611   if (a-&gt;is_within_bounds(index)) {
2612     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2613       a-&gt;obj_at_put(index, v);
2614     } else {
2615       ResourceMark rm(THREAD);
2616       stringStream ss;
2617       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2618       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2619                v-&gt;klass()-&gt;external_name(),
2620                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2621                index);
2622       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2623         ss.print(&quot;[]&quot;);
2624       }
2625       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2626     }
2627   } else {
2628     ResourceMark rm(THREAD);
2629     stringStream ss;
2630     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2631     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2632   }
2633 JNI_END
2634 
2635 
2636 
2637 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2638                               ,EntryProbe,ReturnProbe)  \
2639 \
2640   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2641                       , ReturnProbe); \
2642 \
2643 JNI_ENTRY(Return, \
2644           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2645   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2646   EntryProbe; \
2647   Return ret = NULL;\
2648   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2649 \
2650   oop obj= oopFactory::Allocator(len, CHECK_0); \
2651   ret = (Return) JNIHandles::make_local(env, obj); \
2652   return ret;\
2653 JNI_END
2654 
2655 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2656                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2657                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2658 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2659                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2660                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2661 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2662                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2663                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2664 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2665                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2666                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2667 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2668                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2669                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2670 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2671                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2672                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2673 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2674                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2675                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2676 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2677                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2678                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2679 
2680 // Return an address which will fault if the caller writes to it.
2681 
2682 static char* get_bad_address() {
2683   static char* bad_address = NULL;
2684   if (bad_address == NULL) {
2685     size_t size = os::vm_allocation_granularity();
2686     bad_address = os::reserve_memory(size);
2687     if (bad_address != NULL) {
2688       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2689                          /*is_committed*/false);
2690       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2691     }
2692   }
2693   return bad_address;
2694 }
2695 
2696 
2697 
2698 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2699                                       , EntryProbe, ReturnProbe) \
2700 \
2701 JNI_QUICK_ENTRY(ElementType*, \
2702           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2703   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2704   EntryProbe; \
2705   /* allocate an chunk of memory in c land */ \
2706   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2707   ElementType* result; \
2708   int len = a-&gt;length(); \
2709   if (len == 0) { \
2710     if (isCopy != NULL) { \
2711       *isCopy = JNI_FALSE; \
2712     } \
2713     /* Empty array: legal but useless, can&#39;t return NULL. \
2714      * Return a pointer to something useless. \
2715      * Avoid asserts in typeArrayOop. */ \
2716     result = (ElementType*)get_bad_address(); \
2717   } else { \
2718     /* JNI Specification states return NULL on OOM */                    \
2719     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2720     if (result != NULL) {                                                \
2721       /* copy the array to the c chunk */                                \
2722       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2723                                          result, len);                   \
2724       if (isCopy) {                                                      \
2725         *isCopy = JNI_TRUE;                                              \
2726       }                                                                  \
2727     }                                                                    \
2728   } \
2729   ReturnProbe; \
2730   return result; \
2731 JNI_END
2732 
2733 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2734                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2735                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2736 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2737                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2738                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2739 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2740                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2741                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2742 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2743                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2744                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2745 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2746                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2747                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2748 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2749                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2750                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2751 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2752 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2753                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2754                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2755 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2756                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2757                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2758 
2759 
2760 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2761                                           , EntryProbe, ReturnProbe);\
2762 \
2763 JNI_QUICK_ENTRY(void, \
2764           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2765                                              ElementType *buf, jint mode)) \
2766   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2767   EntryProbe; \
2768   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2769   int len = a-&gt;length(); \
2770   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2771     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2772       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2773     } \
2774     if ((mode == 0) || (mode == JNI_ABORT)) { \
2775       FreeHeap(buf); \
2776     } \
2777   } \
2778   ReturnProbe; \
2779 JNI_END
2780 
2781 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2782                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2783                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2784 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2785                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2786                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2787 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2788                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2789                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2790 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2791                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2792                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2793 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2794                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2795                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2796 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2797                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2798                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2799 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2800                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2801                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2802 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2803                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2804                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2805 
2806 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2807   ResourceMark rm(THREAD);
2808   if (copy_len &lt; 0) {
2809     stringStream ss;
2810     ss.print(&quot;Length %d is negative&quot;, copy_len);
2811     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2812   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2813     stringStream ss;
2814     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2815              start, (int64_t)start+(int64_t)copy_len, array_len);
2816     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2817   }
2818 }
2819 
2820 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2821                                     , EntryProbe, ReturnProbe); \
2822   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2823                            , ReturnProbe); \
2824 \
2825 JNI_ENTRY(void, \
2826 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2827              jsize len, ElementType *buf)) \
2828   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2829   EntryProbe; \
2830   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2831   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2832   check_bounds(start, len, src-&gt;length(), CHECK); \
2833   if (len &gt; 0) {    \
2834     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2835   } \
2836 JNI_END
2837 
2838 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2839                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2840                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2841 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2842                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2843                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2844 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2845                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2846                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2847 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2848                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2849                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2850 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2851                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2852                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2853 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2854                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2855                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2856 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2857                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2858                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2859 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2860                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2861                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2862 
2863 
2864 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2865                                     , EntryProbe, ReturnProbe); \
2866   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2867                            ,ReturnProbe);           \
2868 \
2869 JNI_ENTRY(void, \
2870 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2871              jsize len, const ElementType *buf)) \
2872   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2873   EntryProbe; \
2874   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2875   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2876   check_bounds(start, len, dst-&gt;length(), CHECK); \
2877   if (len &gt; 0) { \
2878     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2879   } \
2880 JNI_END
2881 
2882 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2883                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2884                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2885 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2886                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2887                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2888 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2889                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2890                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2891 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2892                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2893                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2894 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2895                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2896                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2897 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2898                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2899                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2900 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2901                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2902                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2903 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2904                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2905                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2906 
2907 
2908 //
2909 // Interception of natives
2910 //
2911 
2912 // The RegisterNatives call being attempted tried to register with a method that
2913 // is not native.  Ask JVM TI what prefixes have been specified.  Then check
2914 // to see if the native method is now wrapped with the prefixes.  See the
2915 // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.
2916 static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {
2917 #if INCLUDE_JVMTI
2918   ResourceMark rm(THREAD);
2919   Method* method;
2920   int name_len = name-&gt;utf8_length();
2921   char* name_str = name-&gt;as_utf8();
2922   int prefix_count;
2923   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
2924   for (int i = 0; i &lt; prefix_count; i++) {
2925     char* prefix = prefixes[i];
2926     int prefix_len = (int)strlen(prefix);
2927 
2928     // try adding this prefix to the method name and see if it matches another method name
2929     int trial_len = name_len + prefix_len;
2930     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
2931     strcpy(trial_name_str, prefix);
2932     strcat(trial_name_str, name_str);
2933     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);
2934     if (trial_name == NULL) {
2935       continue; // no such symbol, so this prefix wasn&#39;t used, try the next prefix
2936     }
2937     method = k-&gt;lookup_method(trial_name, signature);
2938     if (method == NULL) {
2939       continue; // signature doesn&#39;t match, try the next prefix
2940     }
2941     if (method-&gt;is_native()) {
2942       method-&gt;set_is_prefixed_native();
2943       return method; // wahoo, we found a prefixed version of the method, return it
2944     }
2945     // found as non-native, so prefix is good, add it, probably just need more prefixes
2946     name_len = trial_len;
2947     name_str = trial_name_str;
2948   }
2949 #endif // INCLUDE_JVMTI
2950   return NULL; // not found
2951 }
2952 
2953 static bool register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {
2954   Method* method = k-&gt;lookup_method(name, signature);
2955   if (method == NULL) {
2956     ResourceMark rm;
2957     stringStream st;
2958     st.print(&quot;Method %s name or signature does not match&quot;,
2959              Method::name_and_sig_as_C_string(k, name, signature));
2960     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2961   }
2962   if (!method-&gt;is_native()) {
2963     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)
2964     method = find_prefixed_native(k, name, signature, THREAD);
2965     if (method == NULL) {
2966       ResourceMark rm;
2967       stringStream st;
2968       st.print(&quot;Method %s is not declared as native&quot;,
2969                Method::name_and_sig_as_C_string(k, name, signature));
2970       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2971     }
2972   }
2973 
2974   if (entry != NULL) {
2975     method-&gt;set_native_function(entry,
2976       Method::native_bind_event_is_interesting);
2977   } else {
2978     method-&gt;clear_native_function();
2979   }
2980   if (PrintJNIResolving) {
2981     ResourceMark rm(THREAD);
2982     tty-&gt;print_cr(&quot;[Registering JNI native method %s.%s]&quot;,
2983       method-&gt;method_holder()-&gt;external_name(),
2984       method-&gt;name()-&gt;as_C_string());
2985   }
2986   return true;
2987 }
2988 
2989 DT_RETURN_MARK_DECL(RegisterNatives, jint
2990                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2991 
2992 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2993                                     const JNINativeMethod *methods,
2994                                     jint nMethods))
2995   JNIWrapper(&quot;RegisterNatives&quot;);
2996   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2997   jint ret = 0;
2998   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2999 
3000   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3001 
3002   for (int index = 0; index &lt; nMethods; index++) {
3003     const char* meth_name = methods[index].name;
3004     const char* meth_sig = methods[index].signature;
3005     int meth_name_len = (int)strlen(meth_name);
3006 
3007     // The class should have been loaded (we have an instance of the class
3008     // passed in) so the method and signature should already be in the symbol
3009     // table.  If they&#39;re not there, the method doesn&#39;t exist.
3010     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
3011     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
3012 
3013     if (name == NULL || signature == NULL) {
3014       ResourceMark rm;
3015       stringStream st;
3016       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
3017       // Must return negative value on failure
3018       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
3019     }
3020 
3021     bool res = register_native(k, name, signature,
3022                                (address) methods[index].fnPtr, THREAD);
3023     if (!res) {
3024       ret = -1;
3025       break;
3026     }
3027   }
3028   return ret;
3029 JNI_END
3030 
3031 
3032 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
3033   JNIWrapper(&quot;UnregisterNatives&quot;);
3034  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
3035   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3036   //%note jni_2
3037   if (k-&gt;is_instance_klass()) {
3038     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
3039       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
3040       if (m-&gt;is_native()) {
3041         m-&gt;clear_native_function();
3042         m-&gt;set_signature_handler(NULL);
3043       }
3044     }
3045   }
3046  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
3047   return 0;
3048 JNI_END
3049 
3050 //
3051 // Monitor functions
3052 //
3053 
3054 DT_RETURN_MARK_DECL(MonitorEnter, jint
3055                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
3056 
3057 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
3058  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
3059   jint ret = JNI_ERR;
3060   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3061 
3062   // If the object is null, we can&#39;t do anything with it
3063   if (jobj == NULL) {
3064     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3065   }
3066 
3067   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3068   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3069   ret = JNI_OK;
3070   return ret;
3071 JNI_END
3072 
3073 DT_RETURN_MARK_DECL(MonitorExit, jint
3074                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3075 
3076 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3077  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3078   jint ret = JNI_ERR;
3079   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3080 
3081   // Don&#39;t do anything with a null object
3082   if (jobj == NULL) {
3083     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3084   }
3085 
3086   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3087   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3088 
3089   ret = JNI_OK;
3090   return ret;
3091 JNI_END
3092 
3093 //
3094 // Extensions
3095 //
3096 
3097 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3098                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3099 
3100 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3101   JNIWrapper(&quot;GetStringRegion&quot;);
3102  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3103   DT_VOID_RETURN_MARK(GetStringRegion);
3104   oop s = JNIHandles::resolve_non_null(string);
3105   typeArrayOop s_value = java_lang_String::value(s);
3106   int s_len = java_lang_String::length(s, s_value);
3107   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3108     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3109   } else {
3110     if (len &gt; 0) {
3111       bool is_latin1 = java_lang_String::is_latin1(s);
3112       if (!is_latin1) {
3113         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3114                                            buf, len);
3115       } else {
3116         for (int i = 0; i &lt; len; i++) {
3117           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3118         }
3119       }
3120     }
3121   }
3122 JNI_END
3123 
3124 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3125                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3126 
3127 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3128   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3129  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3130   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3131   oop s = JNIHandles::resolve_non_null(string);
3132   typeArrayOop s_value = java_lang_String::value(s);
3133   int s_len = java_lang_String::length(s, s_value);
3134   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3135     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3136   } else {
3137     //%note jni_7
3138     if (len &gt; 0) {
3139       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3140       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3141       // as_utf8_string null-terminates the result string
3142     } else {
3143       // JDK null-terminates the buffer even in len is zero
3144       if (buf != NULL) {
3145         buf[0] = 0;
3146       }
3147     }
3148   }
3149 JNI_END
3150 
3151 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3152   if (Universe::heap()-&gt;supports_object_pinning()) {
3153     const oop o = JNIHandles::resolve_non_null(obj);
3154     return Universe::heap()-&gt;pin_object(thread, o);
3155   } else {
3156     GCLocker::lock_critical(thread);
3157     return JNIHandles::resolve_non_null(obj);
3158   }
3159 }
3160 
3161 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3162   if (Universe::heap()-&gt;supports_object_pinning()) {
3163     const oop o = JNIHandles::resolve_non_null(obj);
3164     return Universe::heap()-&gt;unpin_object(thread, o);
3165   } else {
3166     GCLocker::unlock_critical(thread);
3167   }
3168 }
3169 
3170 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3171   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3172  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3173   if (isCopy != NULL) {
3174     *isCopy = JNI_FALSE;
3175   }
3176   oop a = lock_gc_or_pin_object(thread, array);
3177   assert(a-&gt;is_array(), &quot;just checking&quot;);
3178   BasicType type;
3179   if (a-&gt;is_objArray()) {
3180     type = T_OBJECT;
3181   } else {
3182     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3183   }
3184   void* ret = arrayOop(a)-&gt;base(type);
3185  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3186   return ret;
3187 JNI_END
3188 
3189 
3190 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3191   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3192   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3193   unlock_gc_or_unpin_object(thread, array);
3194 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3195 JNI_END
3196 
3197 
3198 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3199   JNIWrapper(&quot;GetStringCritical&quot;);
3200   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3201   oop s = lock_gc_or_pin_object(thread, string);
3202   typeArrayOop s_value = java_lang_String::value(s);
3203   bool is_latin1 = java_lang_String::is_latin1(s);
3204   if (isCopy != NULL) {
3205     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3206   }
3207   jchar* ret;
3208   if (!is_latin1) {
3209     ret = (jchar*) s_value-&gt;base(T_CHAR);
3210   } else {
3211     // Inflate latin1 encoded string to UTF16
3212     int s_len = java_lang_String::length(s, s_value);
3213     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3214     /* JNI Specification states return NULL on OOM */
3215     if (ret != NULL) {
3216       for (int i = 0; i &lt; s_len; i++) {
3217         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3218       }
3219       ret[s_len] = 0;
3220     }
3221   }
3222  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3223   return ret;
3224 JNI_END
3225 
3226 
3227 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3228   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3229   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3230   // The str and chars arguments are ignored for UTF16 strings
3231   oop s = JNIHandles::resolve_non_null(str);
3232   bool is_latin1 = java_lang_String::is_latin1(s);
3233   if (is_latin1) {
3234     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3235     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3236     FREE_C_HEAP_ARRAY(jchar, chars);
3237   }
3238   unlock_gc_or_unpin_object(thread, str);
3239 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3240 JNI_END
3241 
3242 
3243 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3244   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3245  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3246   Handle ref_handle(thread, JNIHandles::resolve(ref));
3247   jweak ret = JNIHandles::make_weak_global(ref_handle);
3248  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3249   return ret;
3250 JNI_END
3251 
3252 // Must be JNI_ENTRY (with HandleMark)
3253 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3254   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3255   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3256   JNIHandles::destroy_weak_global(ref);
3257   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3258 JNI_END
3259 
3260 
3261 JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))
3262   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3263  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3264   jni_check_async_exceptions(thread);
3265   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3266  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3267   return ret;
3268 JNI_END
3269 
3270 
3271 // Initialization state for three routines below relating to
3272 // java.nio.DirectBuffers
3273 static          int directBufferSupportInitializeStarted = 0;
3274 static volatile int directBufferSupportInitializeEnded   = 0;
3275 static volatile int directBufferSupportInitializeFailed  = 0;
3276 static jclass    bufferClass                 = NULL;
3277 static jclass    directBufferClass           = NULL;
3278 static jclass    directByteBufferClass       = NULL;
3279 static jmethodID directByteBufferConstructor = NULL;
3280 static jfieldID  directBufferAddressField    = NULL;
3281 static jfieldID  bufferCapacityField         = NULL;
3282 
3283 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3284   Handle loader;            // null (bootstrap) loader
3285   Handle protection_domain; // null protection domain
3286 
3287   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
3288   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3289 
3290   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3291     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3292   }
3293   return result;
3294 }
3295 
3296 // These lookups are done with the NULL (bootstrap) ClassLoader to
3297 // circumvent any security checks that would be done by jni_FindClass.
3298 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3299 {
3300   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3301   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3302   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3303   return true;
3304 }
3305 JNI_END
3306 
3307 
3308 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3309   if (directBufferSupportInitializeFailed) {
3310     return false;
3311   }
3312 
3313   if (Atomic::cmpxchg(1, &amp;directBufferSupportInitializeStarted, 0) == 0) {
3314     if (!lookupDirectBufferClasses(env)) {
3315       directBufferSupportInitializeFailed = 1;
3316       return false;
3317     }
3318 
3319     // Make global references for these
3320     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3321     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3322     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3323 
3324     // Get needed field and method IDs
3325     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3326     if (env-&gt;ExceptionCheck()) {
3327       env-&gt;ExceptionClear();
3328       directBufferSupportInitializeFailed = 1;
3329       return false;
3330     }
3331     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3332     if (env-&gt;ExceptionCheck()) {
3333       env-&gt;ExceptionClear();
3334       directBufferSupportInitializeFailed = 1;
3335       return false;
3336     }
3337     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3338     if (env-&gt;ExceptionCheck()) {
3339       env-&gt;ExceptionClear();
3340       directBufferSupportInitializeFailed = 1;
3341       return false;
3342     }
3343 
3344     if ((directByteBufferConstructor == NULL) ||
3345         (directBufferAddressField    == NULL) ||
3346         (bufferCapacityField         == NULL)) {
3347       directBufferSupportInitializeFailed = 1;
3348       return false;
3349     }
3350 
3351     directBufferSupportInitializeEnded = 1;
3352   } else {
3353     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3354       os::naked_yield();
3355     }
3356   }
3357 
3358   return !directBufferSupportInitializeFailed;
3359 }
3360 
3361 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3362 {
3363   // thread_from_jni_environment() will block if VM is gone.
3364   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3365 
3366   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3367  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3368 
3369   if (!directBufferSupportInitializeEnded) {
3370     if (!initializeDirectBufferSupport(env, thread)) {
3371       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3372       return NULL;
3373     }
3374   }
3375 
3376   // Being paranoid about accidental sign extension on address
3377   jlong addr = (jlong) ((uintptr_t) address);
3378   // NOTE that package-private DirectByteBuffer constructor currently
3379   // takes int capacity
3380   jint  cap  = (jint)  capacity;
3381   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3382   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3383   return ret;
3384 }
3385 
3386 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3387                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3388 
3389 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3390 {
3391   // thread_from_jni_environment() will block if VM is gone.
3392   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3393 
3394   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3395   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3396   void* ret = NULL;
3397   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3398 
3399   if (!directBufferSupportInitializeEnded) {
3400     if (!initializeDirectBufferSupport(env, thread)) {
3401       return 0;
3402     }
3403   }
3404 
3405   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3406     return 0;
3407   }
3408 
3409   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3410   return ret;
3411 }
3412 
3413 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3414                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3415 
3416 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3417 {
3418   // thread_from_jni_environment() will block if VM is gone.
3419   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3420 
3421   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3422   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3423   jlong ret = -1;
3424   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3425 
3426   if (!directBufferSupportInitializeEnded) {
3427     if (!initializeDirectBufferSupport(env, thread)) {
3428       ret = 0;
3429       return ret;
3430     }
3431   }
3432 
3433   if (buf == NULL) {
3434     return -1;
3435   }
3436 
3437   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3438     return -1;
3439   }
3440 
3441   // NOTE that capacity is currently an int in the implementation
3442   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3443   return ret;
3444 }
3445 
3446 
3447 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3448   JNIWrapper(&quot;GetVersion&quot;);
3449   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3450   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3451   return CurrentVersion;
3452 JNI_END
3453 
3454 extern struct JavaVM_ main_vm;
3455 
3456 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3457   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3458   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3459   *vm  = (JavaVM *)(&amp;main_vm);
3460   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3461   return JNI_OK;
3462 JNI_END
3463 
3464 
3465 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3466   JNIWrapper(&quot;GetModule&quot;);
3467   return Modules::get_module(clazz, THREAD);
3468 JNI_END
3469 
3470 
3471 // Structure containing all jni functions
3472 struct JNINativeInterface_ jni_NativeInterface = {
3473     NULL,
3474     NULL,
3475     NULL,
3476 
3477     NULL,
3478 
3479     jni_GetVersion,
3480 
3481     jni_DefineClass,
3482     jni_FindClass,
3483 
3484     jni_FromReflectedMethod,
3485     jni_FromReflectedField,
3486 
3487     jni_ToReflectedMethod,
3488 
3489     jni_GetSuperclass,
3490     jni_IsAssignableFrom,
3491 
3492     jni_ToReflectedField,
3493 
3494     jni_Throw,
3495     jni_ThrowNew,
3496     jni_ExceptionOccurred,
3497     jni_ExceptionDescribe,
3498     jni_ExceptionClear,
3499     jni_FatalError,
3500 
3501     jni_PushLocalFrame,
3502     jni_PopLocalFrame,
3503 
3504     jni_NewGlobalRef,
3505     jni_DeleteGlobalRef,
3506     jni_DeleteLocalRef,
3507     jni_IsSameObject,
3508 
3509     jni_NewLocalRef,
3510     jni_EnsureLocalCapacity,
3511 
3512     jni_AllocObject,
3513     jni_NewObject,
3514     jni_NewObjectV,
3515     jni_NewObjectA,
3516 
3517     jni_GetObjectClass,
3518     jni_IsInstanceOf,
3519 
3520     jni_GetMethodID,
3521 
3522     jni_CallObjectMethod,
3523     jni_CallObjectMethodV,
3524     jni_CallObjectMethodA,
3525     jni_CallBooleanMethod,
3526     jni_CallBooleanMethodV,
3527     jni_CallBooleanMethodA,
3528     jni_CallByteMethod,
3529     jni_CallByteMethodV,
3530     jni_CallByteMethodA,
3531     jni_CallCharMethod,
3532     jni_CallCharMethodV,
3533     jni_CallCharMethodA,
3534     jni_CallShortMethod,
3535     jni_CallShortMethodV,
3536     jni_CallShortMethodA,
3537     jni_CallIntMethod,
3538     jni_CallIntMethodV,
3539     jni_CallIntMethodA,
3540     jni_CallLongMethod,
3541     jni_CallLongMethodV,
3542     jni_CallLongMethodA,
3543     jni_CallFloatMethod,
3544     jni_CallFloatMethodV,
3545     jni_CallFloatMethodA,
3546     jni_CallDoubleMethod,
3547     jni_CallDoubleMethodV,
3548     jni_CallDoubleMethodA,
3549     jni_CallVoidMethod,
3550     jni_CallVoidMethodV,
3551     jni_CallVoidMethodA,
3552 
3553     jni_CallNonvirtualObjectMethod,
3554     jni_CallNonvirtualObjectMethodV,
3555     jni_CallNonvirtualObjectMethodA,
3556     jni_CallNonvirtualBooleanMethod,
3557     jni_CallNonvirtualBooleanMethodV,
3558     jni_CallNonvirtualBooleanMethodA,
3559     jni_CallNonvirtualByteMethod,
3560     jni_CallNonvirtualByteMethodV,
3561     jni_CallNonvirtualByteMethodA,
3562     jni_CallNonvirtualCharMethod,
3563     jni_CallNonvirtualCharMethodV,
3564     jni_CallNonvirtualCharMethodA,
3565     jni_CallNonvirtualShortMethod,
3566     jni_CallNonvirtualShortMethodV,
3567     jni_CallNonvirtualShortMethodA,
3568     jni_CallNonvirtualIntMethod,
3569     jni_CallNonvirtualIntMethodV,
3570     jni_CallNonvirtualIntMethodA,
3571     jni_CallNonvirtualLongMethod,
3572     jni_CallNonvirtualLongMethodV,
3573     jni_CallNonvirtualLongMethodA,
3574     jni_CallNonvirtualFloatMethod,
3575     jni_CallNonvirtualFloatMethodV,
3576     jni_CallNonvirtualFloatMethodA,
3577     jni_CallNonvirtualDoubleMethod,
3578     jni_CallNonvirtualDoubleMethodV,
3579     jni_CallNonvirtualDoubleMethodA,
3580     jni_CallNonvirtualVoidMethod,
3581     jni_CallNonvirtualVoidMethodV,
3582     jni_CallNonvirtualVoidMethodA,
3583 
3584     jni_GetFieldID,
3585 
3586     jni_GetObjectField,
3587     jni_GetBooleanField,
3588     jni_GetByteField,
3589     jni_GetCharField,
3590     jni_GetShortField,
3591     jni_GetIntField,
3592     jni_GetLongField,
3593     jni_GetFloatField,
3594     jni_GetDoubleField,
3595 
3596     jni_SetObjectField,
3597     jni_SetBooleanField,
3598     jni_SetByteField,
3599     jni_SetCharField,
3600     jni_SetShortField,
3601     jni_SetIntField,
3602     jni_SetLongField,
3603     jni_SetFloatField,
3604     jni_SetDoubleField,
3605 
3606     jni_GetStaticMethodID,
3607 
3608     jni_CallStaticObjectMethod,
3609     jni_CallStaticObjectMethodV,
3610     jni_CallStaticObjectMethodA,
3611     jni_CallStaticBooleanMethod,
3612     jni_CallStaticBooleanMethodV,
3613     jni_CallStaticBooleanMethodA,
3614     jni_CallStaticByteMethod,
3615     jni_CallStaticByteMethodV,
3616     jni_CallStaticByteMethodA,
3617     jni_CallStaticCharMethod,
3618     jni_CallStaticCharMethodV,
3619     jni_CallStaticCharMethodA,
3620     jni_CallStaticShortMethod,
3621     jni_CallStaticShortMethodV,
3622     jni_CallStaticShortMethodA,
3623     jni_CallStaticIntMethod,
3624     jni_CallStaticIntMethodV,
3625     jni_CallStaticIntMethodA,
3626     jni_CallStaticLongMethod,
3627     jni_CallStaticLongMethodV,
3628     jni_CallStaticLongMethodA,
3629     jni_CallStaticFloatMethod,
3630     jni_CallStaticFloatMethodV,
3631     jni_CallStaticFloatMethodA,
3632     jni_CallStaticDoubleMethod,
3633     jni_CallStaticDoubleMethodV,
3634     jni_CallStaticDoubleMethodA,
3635     jni_CallStaticVoidMethod,
3636     jni_CallStaticVoidMethodV,
3637     jni_CallStaticVoidMethodA,
3638 
3639     jni_GetStaticFieldID,
3640 
3641     jni_GetStaticObjectField,
3642     jni_GetStaticBooleanField,
3643     jni_GetStaticByteField,
3644     jni_GetStaticCharField,
3645     jni_GetStaticShortField,
3646     jni_GetStaticIntField,
3647     jni_GetStaticLongField,
3648     jni_GetStaticFloatField,
3649     jni_GetStaticDoubleField,
3650 
3651     jni_SetStaticObjectField,
3652     jni_SetStaticBooleanField,
3653     jni_SetStaticByteField,
3654     jni_SetStaticCharField,
3655     jni_SetStaticShortField,
3656     jni_SetStaticIntField,
3657     jni_SetStaticLongField,
3658     jni_SetStaticFloatField,
3659     jni_SetStaticDoubleField,
3660 
3661     jni_NewString,
3662     jni_GetStringLength,
3663     jni_GetStringChars,
3664     jni_ReleaseStringChars,
3665 
3666     jni_NewStringUTF,
3667     jni_GetStringUTFLength,
3668     jni_GetStringUTFChars,
3669     jni_ReleaseStringUTFChars,
3670 
3671     jni_GetArrayLength,
3672 
3673     jni_NewObjectArray,
3674     jni_GetObjectArrayElement,
3675     jni_SetObjectArrayElement,
3676 
3677     jni_NewBooleanArray,
3678     jni_NewByteArray,
3679     jni_NewCharArray,
3680     jni_NewShortArray,
3681     jni_NewIntArray,
3682     jni_NewLongArray,
3683     jni_NewFloatArray,
3684     jni_NewDoubleArray,
3685 
3686     jni_GetBooleanArrayElements,
3687     jni_GetByteArrayElements,
3688     jni_GetCharArrayElements,
3689     jni_GetShortArrayElements,
3690     jni_GetIntArrayElements,
3691     jni_GetLongArrayElements,
3692     jni_GetFloatArrayElements,
3693     jni_GetDoubleArrayElements,
3694 
3695     jni_ReleaseBooleanArrayElements,
3696     jni_ReleaseByteArrayElements,
3697     jni_ReleaseCharArrayElements,
3698     jni_ReleaseShortArrayElements,
3699     jni_ReleaseIntArrayElements,
3700     jni_ReleaseLongArrayElements,
3701     jni_ReleaseFloatArrayElements,
3702     jni_ReleaseDoubleArrayElements,
3703 
3704     jni_GetBooleanArrayRegion,
3705     jni_GetByteArrayRegion,
3706     jni_GetCharArrayRegion,
3707     jni_GetShortArrayRegion,
3708     jni_GetIntArrayRegion,
3709     jni_GetLongArrayRegion,
3710     jni_GetFloatArrayRegion,
3711     jni_GetDoubleArrayRegion,
3712 
3713     jni_SetBooleanArrayRegion,
3714     jni_SetByteArrayRegion,
3715     jni_SetCharArrayRegion,
3716     jni_SetShortArrayRegion,
3717     jni_SetIntArrayRegion,
3718     jni_SetLongArrayRegion,
3719     jni_SetFloatArrayRegion,
3720     jni_SetDoubleArrayRegion,
3721 
3722     jni_RegisterNatives,
3723     jni_UnregisterNatives,
3724 
3725     jni_MonitorEnter,
3726     jni_MonitorExit,
3727 
3728     jni_GetJavaVM,
3729 
3730     jni_GetStringRegion,
3731     jni_GetStringUTFRegion,
3732 
3733     jni_GetPrimitiveArrayCritical,
3734     jni_ReleasePrimitiveArrayCritical,
3735 
3736     jni_GetStringCritical,
3737     jni_ReleaseStringCritical,
3738 
3739     jni_NewWeakGlobalRef,
3740     jni_DeleteWeakGlobalRef,
3741 
3742     jni_ExceptionCheck,
3743 
3744     jni_NewDirectByteBuffer,
3745     jni_GetDirectBufferAddress,
3746     jni_GetDirectBufferCapacity,
3747 
3748     // New 1_6 features
3749 
3750     jni_GetObjectRefType,
3751 
3752     // Module features
3753 
3754     jni_GetModule
3755 };
3756 
3757 
3758 // For jvmti use to modify jni function table.
3759 // Java threads in native contiues to run until it is transitioned
3760 // to VM at safepoint. Before the transition or before it is blocked
3761 // for safepoint it may access jni function table. VM could crash if
3762 // any java thread access the jni function table in the middle of memcpy.
3763 // To avoid this each function pointers are copied automically.
3764 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3765   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3766   intptr_t *a = (intptr_t *) jni_functions();
3767   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3768   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3769     Atomic::store(*b++, a++);
3770   }
3771 }
3772 
3773 void quicken_jni_functions() {
3774   // Replace Get&lt;Primitive&gt;Field with fast versions
3775   if (UseFastJNIAccessors &amp;&amp; !JvmtiExport::can_post_field_access()
3776       &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
3777     address func;
3778     func = JNI_FastGetField::generate_fast_get_boolean_field();
3779     if (func != (address)-1) {
3780       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3781     }
3782     func = JNI_FastGetField::generate_fast_get_byte_field();
3783     if (func != (address)-1) {
3784       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3785     }
3786     func = JNI_FastGetField::generate_fast_get_char_field();
3787     if (func != (address)-1) {
3788       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3789     }
3790     func = JNI_FastGetField::generate_fast_get_short_field();
3791     if (func != (address)-1) {
3792       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3793     }
3794     func = JNI_FastGetField::generate_fast_get_int_field();
3795     if (func != (address)-1) {
3796       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3797     }
3798     func = JNI_FastGetField::generate_fast_get_long_field();
3799     if (func != (address)-1) {
3800       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3801     }
3802     func = JNI_FastGetField::generate_fast_get_float_field();
3803     if (func != (address)-1) {
3804       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3805     }
3806     func = JNI_FastGetField::generate_fast_get_double_field();
3807     if (func != (address)-1) {
3808       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3809     }
3810   }
3811 }
3812 
3813 // Returns the function structure
3814 struct JNINativeInterface_* jni_functions() {
3815 #if INCLUDE_JNI_CHECK
3816   if (CheckJNICalls) return jni_functions_check();
3817 #endif // INCLUDE_JNI_CHECK
3818   return &amp;jni_NativeInterface;
3819 }
3820 
3821 // Returns the function structure
3822 struct JNINativeInterface_* jni_functions_nocheck() {
3823   return &amp;jni_NativeInterface;
3824 }
3825 
3826 static void post_thread_start_event(const JavaThread* jt) {
3827   assert(jt != NULL, &quot;invariant&quot;);
3828   EventThreadStart event;
3829   if (event.should_commit()) {
3830     event.set_thread(JFR_THREAD_ID(jt));
3831     event.commit();
3832   }
3833 }
3834 
3835 // Invocation API
3836 
3837 
3838 // Forward declaration
3839 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3840 
3841 // Global invocation API vars
3842 volatile int vm_created = 0;
3843 // Indicate whether it is safe to recreate VM
3844 volatile int safe_to_recreate_vm = 1;
3845 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3846 
3847 
3848 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3849 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3850 
3851 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3852                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3853 
3854 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3855   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3856   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3857   jint ret = JNI_ERR;
3858   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3859 
3860   if (Threads::is_supported_jni_version(args-&gt;version)) {
3861     ret = JNI_OK;
3862   }
3863   // 1.1 style no longer supported in hotspot.
3864   // According the JNI spec, we should update args-&gt;version on return.
3865   // We also use the structure to communicate with launcher about default
3866   // stack size.
3867   if (args-&gt;version == JNI_VERSION_1_1) {
3868     args-&gt;version = JNI_VERSION_1_2;
3869     // javaStackSize is int in arguments structure
3870     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
3871     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3872   }
3873   return ret;
3874 }
3875 
3876 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3877                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3878 
3879 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3880   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3881 
3882   jint result = JNI_ERR;
3883   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3884 
3885   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3886   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3887   // but __sync_lock_test_and_set is not guaranteed to do what we want
3888   // on all architectures.  So we check it works before relying on it.
3889 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3890   {
3891     jint a = 0xcafebabe;
3892     jint b = Atomic::xchg((jint) 0xdeadbeef, &amp;a);
3893     void *c = &amp;a;
3894     void *d = Atomic::xchg(&amp;b, &amp;c);
3895     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3896     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3897   }
3898 #endif // ZERO &amp;&amp; ASSERT
3899 
3900   // At the moment it&#39;s only possible to have one Java VM,
3901   // since some of the runtime state is in global variables.
3902 
3903   // We cannot use our mutex locks here, since they only work on
3904   // Threads. We do an atomic compare and exchange to ensure only
3905   // one thread can call this method at a time
3906 
3907   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3908   // the add/dec implementations are dependent on whether we are running
3909   // on a multiprocessor Atomic::xchg does not have this problem.
3910   if (Atomic::xchg(1, &amp;vm_created) == 1) {
3911     return JNI_EEXIST;   // already created, or create attempt in progress
3912   }
3913   if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) {
3914     return JNI_ERR;  // someone tried and failed and retry not allowed.
3915   }
3916 
3917   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3918 
3919   /**
3920    * Certain errors during initialization are recoverable and do not
3921    * prevent this method from being called again at a later time
3922    * (perhaps with different arguments).  However, at a certain
3923    * point during initialization if an error occurs we cannot allow
3924    * this function to be called again (or it will crash).  In those
3925    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3926    * sets safe_to_recreate_vm to 1, such that any new call to
3927    * JNI_CreateJavaVM will immediately fail using the above logic.
3928    */
3929   bool can_try_again = true;
3930 
3931   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3932   if (result == JNI_OK) {
3933     JavaThread *thread = JavaThread::current();
3934     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
3935     /* thread is thread_in_vm here */
3936     *vm = (JavaVM *)(&amp;main_vm);
3937     *(JNIEnv**)penv = thread-&gt;jni_environment();
3938 
3939 #if INCLUDE_JVMCI
3940     if (EnableJVMCI) {
3941       if (UseJVMCICompiler) {
3942         // JVMCI is initialized on a CompilerThread
3943         if (BootstrapJVMCI) {
3944           JavaThread* THREAD = thread;
3945           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
3946           compiler-&gt;bootstrap(THREAD);
3947           if (HAS_PENDING_EXCEPTION) {
3948             HandleMark hm;
3949             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3950           }
3951         }
3952       }
3953     }
3954 #endif
3955 
3956     // Notify JVMTI
3957     if (JvmtiExport::should_post_thread_life()) {
3958        JvmtiExport::post_thread_start(thread);
3959     }
3960 
3961     post_thread_start_event(thread);
3962 
3963 #ifndef PRODUCT
3964     if (ReplayCompiles) ciReplay::replay(thread);
3965 
3966     // Some platforms (like Win*) need a wrapper around these test
3967     // functions in order to properly handle error conditions.
3968     VMError::test_error_handler();
3969 #endif
3970 
3971     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
3972     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
3973   } else {
3974     // If create_vm exits because of a pending exception, exit with that
3975     // exception.  In the future when we figure out how to reclaim memory,
3976     // we may be able to exit with JNI_ERR and allow the calling application
3977     // to continue.
3978     if (Universe::is_fully_initialized()) {
3979       // otherwise no pending exception possible - VM will already have aborted
3980       JavaThread* THREAD = JavaThread::current();
3981       if (HAS_PENDING_EXCEPTION) {
3982         HandleMark hm;
3983         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3984       }
3985     }
3986 
3987     if (can_try_again) {
3988       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3989       safe_to_recreate_vm = 1;
3990     }
3991 
3992     // Creation failed. We must reset vm_created
3993     *vm = 0;
3994     *(JNIEnv**)penv = 0;
3995     // reset vm_created last to avoid race condition. Use OrderAccess to
3996     // control both compiler and architectural-based reordering.
3997     OrderAccess::release_store(&amp;vm_created, 0);
3998   }
3999 
4000   // Flush stdout and stderr before exit.
4001   fflush(stdout);
4002   fflush(stderr);
4003 
4004   return result;
4005 
4006 }
4007 
4008 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4009   jint result = JNI_ERR;
4010   // On Windows, let CreateJavaVM run with SEH protection
4011 #ifdef _WIN32
4012   __try {
4013 #endif
4014     result = JNI_CreateJavaVM_inner(vm, penv, args);
4015 #ifdef _WIN32
4016   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4017     // Nothing to do.
4018   }
4019 #endif
4020   return result;
4021 }
4022 
4023 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4024   // See bug 4367188, the wrapper can sometimes cause VM crashes
4025   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
4026 
4027   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4028 
4029   if (vm_created == 1) {
4030     if (numVMs != NULL) *numVMs = 1;
4031     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4032   } else {
4033     if (numVMs != NULL) *numVMs = 0;
4034   }
4035   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4036   return JNI_OK;
4037 }
4038 
4039 extern &quot;C&quot; {
4040 
4041 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4042                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4043 
4044 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4045   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4046   jint res = JNI_ERR;
4047   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4048 
4049   if (vm_created == 0) {
4050     res = JNI_ERR;
4051     return res;
4052   }
4053 
4054   JNIWrapper(&quot;DestroyJavaVM&quot;);
4055   JNIEnv *env;
4056   JavaVMAttachArgs destroyargs;
4057   destroyargs.version = CurrentVersion;
4058   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4059   destroyargs.group = NULL;
4060   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4061   if (res != JNI_OK) {
4062     return res;
4063   }
4064 
4065   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4066   JavaThread* thread = JavaThread::current();
4067   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4068   if (Threads::destroy_vm()) {
4069     // Should not change thread state, VM is gone
4070     vm_created = 0;
4071     res = JNI_OK;
4072     return res;
4073   } else {
4074     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4075     res = JNI_ERR;
4076     return res;
4077   }
4078 }
4079 
4080 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4081   jint result = JNI_ERR;
4082   // On Windows, we need SEH protection
4083 #ifdef _WIN32
4084   __try {
4085 #endif
4086     result = jni_DestroyJavaVM_inner(vm);
4087 #ifdef _WIN32
4088   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4089     // Nothing to do.
4090   }
4091 #endif
4092   return result;
4093 }
4094 
4095 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4096   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4097 
4098   // Check below commented out from JDK1.2fcs as well
4099   /*
4100   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4101     return JNI_EVERSION;
4102   }
4103   */
4104 
4105   Thread* t = Thread::current_or_null();
4106   if (t != NULL) {
4107     // If the thread has been attached this operation is a no-op
4108     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4109     return JNI_OK;
4110   }
4111 
4112   // Create a thread and mark it as attaching so it will be skipped by the
4113   // ThreadsListEnumerator - see CR 6404306
4114   JavaThread* thread = new JavaThread(true);
4115 
4116   // Set correct safepoint info. The thread is going to call into Java when
4117   // initializing the Java level thread object. Hence, the correct state must
4118   // be set in order for the Safepoint code to deal with it correctly.
4119   thread-&gt;set_thread_state(_thread_in_vm);
4120   thread-&gt;record_stack_base_and_size();
4121   thread-&gt;register_thread_stack_with_NMT();
4122   thread-&gt;initialize_thread_current();
4123 
4124   if (!os::create_attached_thread(thread)) {
4125     thread-&gt;smr_delete();
4126     return JNI_ERR;
4127   }
4128   // Enable stack overflow checks
4129   thread-&gt;create_stack_guard_pages();
4130 
4131   thread-&gt;initialize_tlab();
4132 
4133   thread-&gt;cache_global_variables();
4134 
4135   // Crucial that we do not have a safepoint check for this thread, since it has
4136   // not been added to the Thread list yet.
4137   { Threads_lock-&gt;lock_without_safepoint_check();
4138     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4139     // avoid this thread trying to do a GC before it is added to the thread-list
4140     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4141     Threads::add(thread, daemon);
4142     Threads_lock-&gt;unlock();
4143   }
4144   // Create thread group and name info from attach arguments
4145   oop group = NULL;
4146   char* thread_name = NULL;
4147   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4148     group = JNIHandles::resolve(args-&gt;group);
4149     thread_name = args-&gt;name; // may be NULL
4150   }
4151   if (group == NULL) group = Universe::main_thread_group();
4152 
4153   // Create Java level thread object and attach it to this thread
4154   bool attach_failed = false;
4155   {
4156     EXCEPTION_MARK;
4157     HandleMark hm(THREAD);
4158     Handle thread_group(THREAD, group);
4159     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4160     if (HAS_PENDING_EXCEPTION) {
4161       CLEAR_PENDING_EXCEPTION;
4162       // cleanup outside the handle mark.
4163       attach_failed = true;
4164     }
4165   }
4166 
4167   if (attach_failed) {
4168     // Added missing cleanup
4169     thread-&gt;cleanup_failed_attach_current_thread();
4170     return JNI_ERR;
4171   }
4172 
4173   // mark the thread as no longer attaching
4174   // this uses a fence to push the change through so we don&#39;t have
4175   // to regrab the threads_lock
4176   thread-&gt;set_done_attaching_via_jni();
4177 
4178   // Set java thread status.
4179   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4180               java_lang_Thread::RUNNABLE);
4181 
4182   // Notify the debugger
4183   if (JvmtiExport::should_post_thread_life()) {
4184     JvmtiExport::post_thread_start(thread);
4185   }
4186 
4187   post_thread_start_event(thread);
4188 
4189   *(JNIEnv**)penv = thread-&gt;jni_environment();
4190 
4191   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4192   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4193   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4194   // needed.
4195 
4196   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4197 
4198   // Perform any platform dependent FPU setup
4199   os::setup_fpu();
4200 
4201   return JNI_OK;
4202 }
4203 
4204 
4205 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4206   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4207   if (vm_created == 0) {
4208   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4209     return JNI_ERR;
4210   }
4211 
4212   JNIWrapper(&quot;AttachCurrentThread&quot;);
4213   jint ret = attach_current_thread(vm, penv, _args, false);
4214   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4215   return ret;
4216 }
4217 
4218 
4219 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4220   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4221 
4222   JNIWrapper(&quot;DetachCurrentThread&quot;);
4223 
4224   // If the thread has already been detached the operation is a no-op
4225   if (Thread::current_or_null() == NULL) {
4226     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4227     return JNI_OK;
4228   }
4229 
4230   VM_Exit::block_if_vm_exited();
4231 
4232   JavaThread* thread = JavaThread::current();
4233   if (thread-&gt;has_last_Java_frame()) {
4234     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4235     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4236     return JNI_ERR;
4237   }
4238 
4239   // Safepoint support. Have to do call-back to safepoint code, if in the
4240   // middle of a safepoint operation
4241   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4242 
4243   // XXX: Note that JavaThread::exit() call below removes the guards on the
4244   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4245   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4246   // of the guards is visible in jni_AttachCurrentThread above,
4247   // the removal of the guards is buried below in JavaThread::exit()
4248   // here. The abstraction should be more symmetrically either exposed
4249   // or hidden (e.g. it could probably be hidden in the same
4250   // (platform-dependent) methods where we do alternate stack
4251   // maintenance work?)
4252   thread-&gt;exit(false, JavaThread::jni_detach);
4253   thread-&gt;smr_delete();
4254 
4255   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4256   return JNI_OK;
4257 }
4258 
4259 DT_RETURN_MARK_DECL(GetEnv, jint
4260                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4261 
4262 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4263   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4264   jint ret = JNI_ERR;
4265   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4266 
4267   if (vm_created == 0) {
4268     *penv = NULL;
4269     ret = JNI_EDETACHED;
4270     return ret;
4271   }
4272 
4273   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4274     return ret;
4275   }
4276 
4277 #ifndef JVMPI_VERSION_1
4278 // need these in order to be polite about older agents
4279 #define JVMPI_VERSION_1   ((jint)0x10000001)
4280 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4281 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4282 #endif // !JVMPI_VERSION_1
4283 
4284   Thread* thread = Thread::current_or_null();
4285   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4286     if (Threads::is_supported_jni_version_including_1_1(version)) {
4287       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4288       ret = JNI_OK;
4289       return ret;
4290 
4291     } else if (version == JVMPI_VERSION_1 ||
4292                version == JVMPI_VERSION_1_1 ||
4293                version == JVMPI_VERSION_1_2) {
4294       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4295       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4296       ret = JNI_EVERSION;
4297       return ret;
4298     } else if (JvmtiExport::is_jvmdi_version(version)) {
4299       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4300       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4301       ret = JNI_EVERSION;
4302       return ret;
4303     } else {
4304       *penv = NULL;
4305       ret = JNI_EVERSION;
4306       return ret;
4307     }
4308   } else {
4309     *penv = NULL;
4310     ret = JNI_EDETACHED;
4311     return ret;
4312   }
4313 }
4314 
4315 
4316 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4317   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4318   if (vm_created == 0) {
4319   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4320     return JNI_ERR;
4321   }
4322 
4323   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4324   jint ret = attach_current_thread(vm, penv, _args, true);
4325   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4326   return ret;
4327 }
4328 
4329 
4330 } // End extern &quot;C&quot;
4331 
4332 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4333     NULL,
4334     NULL,
4335     NULL,
4336 
4337     jni_DestroyJavaVM,
4338     jni_AttachCurrentThread,
4339     jni_DetachCurrentThread,
4340     jni_GetEnv,
4341     jni_AttachCurrentThreadAsDaemon
4342 };
    </pre>
  </body>
</html>
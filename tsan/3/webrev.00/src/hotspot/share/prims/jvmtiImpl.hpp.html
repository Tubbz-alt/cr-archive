<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvmtiImpl.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIIMPL_HPP
 26 #define SHARE_PRIMS_JVMTIIMPL_HPP
 27 
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;jvmtifiles/jvmti.h&quot;
 30 #include &quot;oops/objArrayOop.hpp&quot;
 31 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 32 #include &quot;prims/jvmtiEventController.hpp&quot;
 33 #include &quot;prims/jvmtiTrace.hpp&quot;
 34 #include &quot;prims/jvmtiUtil.hpp&quot;
 35 #include &quot;runtime/stackValueCollection.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;utilities/ostream.hpp&quot;
 38 
 39 //
 40 // Forward Declarations
 41 //
 42 
 43 class JvmtiBreakpoint;
 44 class JvmtiBreakpoints;
 45 
 46 
 47 ///////////////////////////////////////////////////////////////
 48 //
 49 // class GrowableCache, GrowableElement
 50 // Used by              : JvmtiBreakpointCache
 51 // Used by JVMTI methods: none directly.
 52 //
 53 // GrowableCache is a permanent CHeap growable array of &lt;GrowableElement *&gt;
 54 //
 55 // In addition, the GrowableCache maintains a NULL terminated cache array of type address
 56 // that&#39;s created from the element array using the function:
 57 //     address GrowableElement::getCacheValue().
 58 //
 59 // Whenever the GrowableArray changes size, the cache array gets recomputed into a new C_HEAP allocated
 60 // block of memory. Additionally, every time the cache changes its position in memory, the
 61 //    void (*_listener_fun)(void *this_obj, address* cache)
 62 // gets called with the cache&#39;s new address. This gives the user of the GrowableCache a callback
 63 // to update its pointer to the address cache.
 64 //
 65 
 66 class GrowableElement : public CHeapObj&lt;mtInternal&gt; {
 67 public:
 68   virtual ~GrowableElement() {}
 69   virtual address getCacheValue()          =0;
 70   virtual bool equals(GrowableElement* e)  =0;
 71   virtual GrowableElement *clone()         =0;
 72 };
 73 
 74 class GrowableCache {
 75 
 76 private:
 77   // Object pointer passed into cache &amp; listener functions.
 78   void *_this_obj;
 79 
 80   // Array of elements in the collection
 81   GrowableArray&lt;GrowableElement *&gt; *_elements;
 82 
 83   // Parallel array of cached values
 84   address *_cache;
 85 
 86   // Listener for changes to the _cache field.
 87   // Called whenever the _cache field has it&#39;s value changed
 88   // (but NOT when cached elements are recomputed).
 89   void (*_listener_fun)(void *, address*);
 90 
 91   static bool equals(void *, GrowableElement *);
 92 
 93   // recache all elements after size change, notify listener
 94   void recache();
 95 
 96 public:
 97    GrowableCache();
 98    ~GrowableCache();
 99 
100   void initialize(void *this_obj, void listener_fun(void *, address*) );
101 
102   // number of elements in the collection
103   int length();
104   // get the value of the index element in the collection
105   GrowableElement* at(int index);
106   // find the index of the element, -1 if it doesn&#39;t exist
107   int find(GrowableElement* e);
108   // append a copy of the element to the end of the collection, notify listener
109   void append(GrowableElement* e);
110   // remove the element at index, notify listener
111   void remove (int index);
112   // clear out all elements and release all heap space, notify listener
113   void clear();
114 };
115 
116 
117 ///////////////////////////////////////////////////////////////
118 //
119 // class JvmtiBreakpointCache
120 // Used by              : JvmtiBreakpoints
121 // Used by JVMTI methods: none directly.
122 // Note   : typesafe wrapper for GrowableCache of JvmtiBreakpoint
123 //
124 
125 class JvmtiBreakpointCache : public CHeapObj&lt;mtInternal&gt; {
126 
127 private:
128   GrowableCache _cache;
129 
130 public:
131   JvmtiBreakpointCache()  {}
132   ~JvmtiBreakpointCache() {}
133 
134   void initialize(void *this_obj, void listener_fun(void *, address*) ) {
135     _cache.initialize(this_obj, listener_fun);
136   }
137 
138   int length()                          { return _cache.length(); }
139   JvmtiBreakpoint&amp; at(int index)        { return (JvmtiBreakpoint&amp;) *(_cache.at(index)); }
140   int find(JvmtiBreakpoint&amp; e)          { return _cache.find((GrowableElement *) &amp;e); }
141   void append(JvmtiBreakpoint&amp; e)       { _cache.append((GrowableElement *) &amp;e); }
142   void remove (int index)               { _cache.remove(index); }
143 };
144 
145 
146 ///////////////////////////////////////////////////////////////
147 //
148 // class JvmtiBreakpoint
149 // Used by              : JvmtiBreakpoints
150 // Used by JVMTI methods: SetBreakpoint, ClearBreakpoint, ClearAllBreakpoints
151 // Note: Extends GrowableElement for use in a GrowableCache
152 //
153 // A JvmtiBreakpoint describes a location (class, method, bci) to break at.
154 //
155 
156 typedef void (Method::*method_action)(int _bci);
157 
158 class JvmtiBreakpoint : public GrowableElement {
159 private:
160   Method*               _method;
161   int                   _bci;
162   oop*                  _class_holder;  // keeps _method memory from being deallocated
163 
164 public:
165   JvmtiBreakpoint() : _method(NULL), _bci(0), _class_holder(NULL) {}
166   JvmtiBreakpoint(Method* m_method, jlocation location);
167   virtual ~JvmtiBreakpoint();
168   bool equals(JvmtiBreakpoint&amp; bp);
169   void copy(JvmtiBreakpoint&amp; bp);
170   address getBcp() const;
171   void each_method_version_do(method_action meth_act);
172   void set();
173   void clear();
174   void print_on(outputStream* out) const;
175 
176   Method* method() { return _method; }
177 
178   // GrowableElement implementation
179   address getCacheValue()         { return getBcp(); }
180   bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&amp;) *e); }
181 
182   GrowableElement *clone()        {
183     JvmtiBreakpoint *bp = new JvmtiBreakpoint();
184     bp-&gt;copy(*this);
185     return bp;
186   }
187 };
188 
189 
190 ///////////////////////////////////////////////////////////////
191 //
192 // class JvmtiBreakpoints
193 // Used by              : JvmtiCurrentBreakpoints
194 // Used by JVMTI methods: none directly
195 // Note: A Helper class
196 //
197 // JvmtiBreakpoints is a GrowableCache of JvmtiBreakpoint.
198 // All changes to the GrowableCache occur at a safepoint using VM_ChangeBreakpoints.
199 //
200 // Because _bps is only modified at safepoints, its possible to always use the
201 // cached byte code pointers from _bps without doing any synchronization (see JvmtiCurrentBreakpoints).
202 //
203 // It would be possible to make JvmtiBreakpoints a static class, but I&#39;ve made it
204 // CHeap allocated to emphasize its similarity to JvmtiFramePops.
205 //
206 
207 class JvmtiBreakpoints : public CHeapObj&lt;mtInternal&gt; {
208 private:
209 
210   JvmtiBreakpointCache _bps;
211 
212   // These should only be used by VM_ChangeBreakpoints
213   // to insure they only occur at safepoints.
214   // Todo: add checks for safepoint
215   friend class VM_ChangeBreakpoints;
216   void set_at_safepoint(JvmtiBreakpoint&amp; bp);
217   void clear_at_safepoint(JvmtiBreakpoint&amp; bp);
218 
219 public:
220   JvmtiBreakpoints(void listener_fun(void *, address *));
221   ~JvmtiBreakpoints();
222 
223   int length();
224   void print();
225 
226   int  set(JvmtiBreakpoint&amp; bp);
227   int  clear(JvmtiBreakpoint&amp; bp);
228   void clearall_in_class_at_safepoint(Klass* klass);
229 };
230 
231 
232 ///////////////////////////////////////////////////////////////
233 //
234 // class JvmtiCurrentBreakpoints
235 //
236 // A static wrapper class for the JvmtiBreakpoints that provides:
237 // 1. a fast inlined function to check if a byte code pointer is a breakpoint (is_breakpoint).
238 // 2. a function for lazily creating the JvmtiBreakpoints class (this is not strictly necessary,
239 //    but I&#39;m copying the code from JvmtiThreadState which needs to lazily initialize
240 //    JvmtiFramePops).
241 // 3. An oops_do entry point for GC&#39;ing the breakpoint array.
242 //
243 
244 class JvmtiCurrentBreakpoints : public AllStatic {
245 
246 private:
247 
248   // Current breakpoints, lazily initialized by get_jvmti_breakpoints();
249   static JvmtiBreakpoints *_jvmti_breakpoints;
250 
251   // NULL terminated cache of byte-code pointers corresponding to current breakpoints.
252   // Updated only at safepoints (with listener_fun) when the cache is moved.
253   // It exists only to make is_breakpoint fast.
254   static address          *_breakpoint_list;
255   static inline void set_breakpoint_list(address *breakpoint_list) { _breakpoint_list = breakpoint_list; }
256 
257   // Listener for the GrowableCache in _jvmti_breakpoints, updates _breakpoint_list.
258   static void listener_fun(void *this_obj, address *cache);
259 
260 public:
261   static void initialize();
262   static void destroy();
263 
264   // lazily create _jvmti_breakpoints and _breakpoint_list
265   static JvmtiBreakpoints&amp; get_jvmti_breakpoints();
266 };
267 
268 ///////////////////////////////////////////////////////////////
269 //
270 // class VM_ChangeBreakpoints
271 // Used by              : JvmtiBreakpoints
272 // Used by JVMTI methods: none directly.
273 // Note: A Helper class.
274 //
275 // VM_ChangeBreakpoints implements a VM_Operation for ALL modifications to the JvmtiBreakpoints class.
276 //
277 
278 class VM_ChangeBreakpoints : public VM_Operation {
279 private:
280   JvmtiBreakpoints* _breakpoints;
281   int               _operation;
282   JvmtiBreakpoint*  _bp;
283 
284 public:
285   enum { SET_BREAKPOINT=0, CLEAR_BREAKPOINT=1 };
286 
287   VM_ChangeBreakpoints(int operation, JvmtiBreakpoint *bp) {
288     JvmtiBreakpoints&amp; current_bps = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
289     _breakpoints = &amp;current_bps;
290     _bp = bp;
291     _operation = operation;
292     assert(bp != NULL, &quot;bp != NULL&quot;);
293   }
294 
295   VMOp_Type type() const { return VMOp_ChangeBreakpoints; }
296   void doit();
297 };
298 
299 
300 ///////////////////////////////////////////////////////////////
301 // The get/set local operations must only be done by the VM thread
302 // because the interpreter version needs to access oop maps, which can
303 // only safely be done by the VM thread
304 //
305 // I&#39;m told that in 1.5 oop maps are now protected by a lock and
306 // we could get rid of the VM op
307 // However if the VM op is removed then the target thread must
308 // be suspended AND a lock will be needed to prevent concurrent
309 // setting of locals to the same java thread. This lock is needed
310 // to prevent compiledVFrames from trying to add deferred updates
311 // to the thread simultaneously.
312 //
313 class VM_GetOrSetLocal : public VM_Operation {
314  protected:
315   JavaThread* _thread;
316   JavaThread* _calling_thread;
317   jint        _depth;
318   jint        _index;
319   BasicType   _type;
320   jvalue      _value;
321   javaVFrame* _jvf;
322   bool        _set;
323 
324   // It is possible to get the receiver out of a non-static native wrapper
325   // frame.  Use VM_GetReceiver to do this.
326   virtual bool getting_receiver() const { return false; }
327 
328   jvmtiError  _result;
329 
330   vframe* get_vframe();
331   javaVFrame* get_java_vframe();
332   bool check_slot_type_lvt(javaVFrame* vf);
333   bool check_slot_type_no_lvt(javaVFrame* vf);
334 
335 public:
336   // Constructor for non-object getter
337   VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type);
338 
339   // Constructor for object or non-object setter
340   VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value);
341 
342   // Constructor for object getter
343   VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth,
344                    int index);
345 
346   VMOp_Type type() const { return VMOp_GetOrSetLocal; }
347   jvalue value()         { return _value; }
348   jvmtiError result()    { return _result; }
349 
350   bool doit_prologue();
351   void doit();
352   bool allow_nested_vm_operations() const;
353   const char* name() const                       { return &quot;get/set locals&quot;; }
354 
355   // Check that the klass is assignable to a type with the given signature.
356   static bool is_assignable(const char* ty_sign, Klass* klass, Thread* thread);
357 };
358 
359 class VM_GetReceiver : public VM_GetOrSetLocal {
360  protected:
361   virtual bool getting_receiver() const { return true; }
362 
363  public:
364   VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth);
365   const char* name() const                       { return &quot;get receiver&quot;; }
366 };
367 
368 
369 ///////////////////////////////////////////////////////////////
370 //
371 // class JvmtiSuspendControl
372 //
373 // Convenience routines for suspending and resuming threads.
374 //
375 // All attempts by JVMTI to suspend and resume threads must go through the
376 // JvmtiSuspendControl interface.
377 //
378 // methods return true if successful
379 //
380 class JvmtiSuspendControl : public AllStatic {
381 public:
382   // suspend the thread, taking it to a safepoint
383   static bool suspend(JavaThread *java_thread);
384   // resume the thread
385   static bool resume(JavaThread *java_thread);
386 
387   static void print();
388 };
389 
390 
391 /**
392  * When a thread (such as the compiler thread or VM thread) cannot post a
393  * JVMTI event itself because the event needs to be posted from a Java
394  * thread, then it can defer the event to the Service thread for posting.
395  * The information needed to post the event is encapsulated into this class
396  * and then enqueued onto the JvmtiDeferredEventQueue, where the Service
397  * thread will pick it up and post it.
398  *
399  * This is currently only used for posting compiled-method-load and unload
400  * events, which we don&#39;t want posted from the compiler thread.
401  */
402 class JvmtiDeferredEvent {
403   friend class JvmtiDeferredEventQueue;
404  private:
405   typedef enum {
406     TYPE_NONE,
407     TYPE_COMPILED_METHOD_LOAD,
408     TYPE_COMPILED_METHOD_UNLOAD,
409     TYPE_DYNAMIC_CODE_GENERATED,
410     TYPE_CLASS_UNLOAD
411   } Type;
412 
413   Type _type;
414   union {
415     nmethod* compiled_method_load;
416     struct {
417       jmethodID method_id;
418       const void* code_begin;
419     } compiled_method_unload;
420     struct {
421       const char* name;
422       const void* code_begin;
423       const void* code_end;
424     } dynamic_code_generated;
425     struct {
426       const char* name;
427     } class_unload;
428   } _event_data;
429 
430   JvmtiDeferredEvent(Type t) : _type(t) {}
431 
432  public:
433 
434   JvmtiDeferredEvent() : _type(TYPE_NONE) {}
435 
436   // Factory methods
437   static JvmtiDeferredEvent compiled_method_load_event(nmethod* nm)
438     NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
439   static JvmtiDeferredEvent compiled_method_unload_event(
440       jmethodID id, const void* code) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
441   static JvmtiDeferredEvent dynamic_code_generated_event(
442       const char* name, const void* begin, const void* end)
443           NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
444   static JvmtiDeferredEvent class_unload_event(
445       const char* name) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
446 
447   // Actually posts the event.
448   void post() NOT_JVMTI_RETURN;
449   void post_compiled_method_load_event(JvmtiEnv* env) NOT_JVMTI_RETURN;
450   void run_nmethod_entry_barriers() NOT_JVMTI_RETURN;
451   // Sweeper support to keep nmethods from being zombied while in the queue.
452   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;
453   // GC support to keep nmethod from being unloaded while in the queue.
454   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;
455 };
456 
457 /**
458  * Events enqueued on this queue wake up the Service thread which dequeues
459  * and posts the events.  The Service_lock is required to be held
460  * when operating on the queue.
461  */
462 class JvmtiDeferredEventQueue : public CHeapObj&lt;mtInternal&gt; {
463   friend class JvmtiDeferredEvent;
464  private:
465   class QueueNode : public CHeapObj&lt;mtInternal&gt; {
466    private:
467     JvmtiDeferredEvent _event;
468     QueueNode* _next;
469 
470    public:
471     QueueNode(const JvmtiDeferredEvent&amp; event)
472       : _event(event), _next(NULL) {}
473 
474     JvmtiDeferredEvent&amp; event() { return _event; }
475     QueueNode* next() const { return _next; }
476 
477     void set_next(QueueNode* next) { _next = next; }
478   };
479 
480   QueueNode* _queue_head;
481   QueueNode* _queue_tail;
482 
483  public:
484   JvmtiDeferredEventQueue() : _queue_head(NULL), _queue_tail(NULL) {}
485 
486   bool has_events() NOT_JVMTI_RETURN_(false);
487   JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());
488 
489   // Post all events in the queue for the current Jvmti environment
490   void post(JvmtiEnv* env) NOT_JVMTI_RETURN;
491   void enqueue(JvmtiDeferredEvent event) NOT_JVMTI_RETURN;
492   void run_nmethod_entry_barriers();
493 
494   // Sweeper support to keep nmethods from being zombied while in the queue.
495   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;
496   // GC support to keep nmethod from being unloaded while in the queue.
497   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;
498 };
499 
500 // Utility macro that checks for NULL pointers:
501 #define NULL_CHECK(X, Y) if ((X) == NULL) { return (Y); }
502 
503 #endif // SHARE_PRIMS_JVMTIIMPL_HPP
    </pre>
  </body>
</html>
diff a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,24 +23,27 @@
  */
 
 #include "precompiled.hpp"
 #include "classfile/javaClasses.inline.hpp"
 #include "classfile/stringTable.hpp"
+#include "classfile/symbolTable.hpp"
 #include "code/codeCache.hpp"
 #include "code/dependencyContext.hpp"
 #include "compiler/compileBroker.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
+#include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
 #include "prims/methodHandles.hpp"
-#include "runtime/compilationPolicy.hpp"
+#include "runtime/deoptimization.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/jniHandles.inline.hpp"
@@ -217,11 +220,11 @@
   return NULL;
 }
 
 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo& info) {
   assert(info.resolved_appendix().is_null(), "only normal methods here");
-  methodHandle m = info.resolved_method();
+  methodHandle m(Thread::current(), info.resolved_method());
   assert(m.not_null(), "null method handle");
   InstanceKlass* m_klass = m->method_holder();
   assert(m_klass != NULL, "null holder for method handle");
   int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );
   int vmindex = Method::invalid_vtable_index;
@@ -314,11 +317,11 @@
   if (m->caller_sensitive()) {
     flags |= CALLER_SENSITIVE;
   }
 
   Handle resolved_method = info.resolved_method_name();
-  assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m(),
+  assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m->is_old(),
          "Should not change after link resolution");
 
   oop mname_oop = mname();
   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
@@ -514,16 +517,16 @@
 }
 
 // convert the external string or reflective type to an internal signature
 Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
   if (java_lang_invoke_MethodType::is_instance(type_str)) {
-    return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found, THREAD);
+    return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found);
   } else if (java_lang_Class::is_instance(type_str)) {
-    return java_lang_Class::as_signature(type_str, false, THREAD);
+    return java_lang_Class::as_signature(type_str, false);
   } else if (java_lang_String::is_instance_inlined(type_str)) {
     if (intern_if_not_found) {
-      return java_lang_String::as_symbol(type_str, THREAD);
+      return java_lang_String::as_symbol(type_str);
     } else {
       return java_lang_String::as_symbol_or_null(type_str);
     }
   } else {
     THROW_MSG_(vmSymbols::java_lang_InternalError(), "unrecognized type", NULL);
@@ -534,25 +537,25 @@
 enum { OBJ_SIG_LEN = 18 };
 
 bool MethodHandles::is_basic_type_signature(Symbol* sig) {
   assert(vmSymbols::object_signature()->utf8_length() == (int)OBJ_SIG_LEN, "");
   assert(vmSymbols::object_signature()->equals(OBJ_SIG), "");
-  const int len = sig->utf8_length();
-  for (int i = 0; i < len; i++) {
-    switch (sig->char_at(i)) {
-    case 'L':
+  for (SignatureStream ss(sig, sig->starts_with(JVM_SIGNATURE_FUNC)); !ss.is_done(); ss.next()) {
+    switch (ss.type()) {
+    case T_OBJECT:
       // only java/lang/Object is valid here
-      if (sig->index_of_at(i, OBJ_SIG, OBJ_SIG_LEN) != i)
+      if (strncmp((char*) ss.raw_bytes(), OBJ_SIG, OBJ_SIG_LEN) != 0)
         return false;
-      i += OBJ_SIG_LEN-1;  //-1 because of i++ in loop
-      continue;
-    case '(': case ')': case 'V':
-    case 'I': case 'J': case 'F': case 'D':
-      continue;
-    //case '[':
-    //case 'Z': case 'B': case 'C': case 'S':
+      break;
+    case T_VOID:
+    case T_INT:
+    case T_LONG:
+    case T_FLOAT:
+    case T_DOUBLE:
+      break;
     default:
+      // subword types (T_BYTE etc.), Q-descriptors, arrays
       return false;
     }
   }
   return true;
 }
@@ -562,118 +565,74 @@
   if (sig == NULL) {
     return sig;
   } else if (is_basic_type_signature(sig)) {
     sig->increment_refcount();
     return sig;  // that was easy
-  } else if (sig->char_at(0) != '(') {
-    BasicType bt = char2type(sig->char_at(0));
+  } else if (!sig->starts_with(JVM_SIGNATURE_FUNC)) {
+    BasicType bt = Signature::basic_type(sig);
     if (is_subword_type(bt)) {
       bsig = vmSymbols::int_signature();
     } else {
-      assert(bt == T_OBJECT || bt == T_ARRAY, "is_basic_type_signature was false");
+      assert(is_reference_type(bt), "is_basic_type_signature was false");
       bsig = vmSymbols::object_signature();
     }
   } else {
     ResourceMark rm;
     stringStream buffer(128);
-    buffer.put('(');
+    buffer.put(JVM_SIGNATURE_FUNC);
     int arg_pos = 0, keep_arg_pos = -1;
     if (keep_last_arg)
       keep_arg_pos = ArgumentCount(sig).size() - 1;
     for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
       BasicType bt = ss.type();
       size_t this_arg_pos = buffer.size();
       if (ss.at_return_type()) {
-        buffer.put(')');
+        buffer.put(JVM_SIGNATURE_ENDFUNC);
       }
       if (arg_pos == keep_arg_pos) {
         buffer.write((char*) ss.raw_bytes(),
                      (int)   ss.raw_length());
-      } else if (bt == T_OBJECT || bt == T_ARRAY) {
+      } else if (is_reference_type(bt)) {
         buffer.write(OBJ_SIG, OBJ_SIG_LEN);
       } else {
         if (is_subword_type(bt))
           bt = T_INT;
         buffer.put(type2char(bt));
       }
       arg_pos++;
     }
     const char* sigstr =       buffer.base();
     int         siglen = (int) buffer.size();
-    bsig = SymbolTable::new_symbol(sigstr, siglen, THREAD);
+    bsig = SymbolTable::new_symbol(sigstr, siglen);
   }
   assert(is_basic_type_signature(bsig) ||
          // detune assert in case the injected argument is not a basic type:
          keep_last_arg, "");
   return bsig;
 }
 
 void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
-                                                     Symbol* sig,
-                                                     bool keep_arrays,
-                                                     bool keep_basic_names) {
+                                                     Symbol* sig) {
   st = st ? st : tty;
-  int len  = sig->utf8_length();
-  int array = 0;
   bool prev_type = false;
-  for (int i = 0; i < len; i++) {
-    char ch = sig->char_at(i);
-    switch (ch) {
-    case '(': case ')':
-      prev_type = false;
-      st->put(ch);
-      continue;
-    case '[':
-      if (!keep_basic_names && keep_arrays)
-        st->put(ch);
-      array++;
-      continue;
-    case 'L':
-      {
-        if (prev_type)  st->put(',');
-        int start = i+1, slash = start;
-        while (++i < len && (ch = sig->char_at(i)) != ';') {
-          if (ch == '/' || ch == '.' || ch == '$')  slash = i+1;
-        }
-        if (slash < i)  start = slash;
-        if (!keep_basic_names) {
-          st->put('L');
-        } else {
-          for (int j = start; j < i; j++)
-            st->put(sig->char_at(j));
-          prev_type = true;
-        }
-        break;
-      }
-    default:
-      {
-        if (array && char2type(ch) != T_ILLEGAL && !keep_arrays) {
-          ch = '[';
-          array = 0;
-        }
-        if (prev_type)  st->put(',');
-        const char* n = NULL;
-        if (keep_basic_names)
-          n = type2name(char2type(ch));
-        if (n == NULL) {
-          // unknown letter, or we don't want to know its name
-          st->put(ch);
-        } else {
-          st->print("%s", n);
-          prev_type = true;
-        }
-        break;
-      }
-    }
-    // Switch break goes here to take care of array suffix:
-    if (prev_type) {
-      while (array > 0) {
-        st->print("[]");
-        --array;
-      }
+  bool is_method = (sig->char_at(0) == JVM_SIGNATURE_FUNC);
+  if (is_method)  st->put(JVM_SIGNATURE_FUNC);
+  for (SignatureStream ss(sig, is_method); !ss.is_done(); ss.next()) {
+    if (ss.at_return_type())
+      st->put(JVM_SIGNATURE_ENDFUNC);
+    else if (prev_type)
+      st->put(',');
+    const char* cp = (const char*) ss.raw_bytes();
+    if (ss.is_array()) {
+      st->put(JVM_SIGNATURE_ARRAY);
+      if (ss.array_prefix_length() == 1)
+        st->put(cp[1]);
+      else
+        st->put(JVM_SIGNATURE_CLASS);
+    } else {
+      st->put(cp[0]);
     }
-    array = 0;
   }
 }
 
 
 
@@ -686,11 +645,11 @@
   return StringTable::lookup(s);
 }
 
 oop MethodHandles::field_signature_type_or_null(Symbol* s) {
   if (s == NULL)  return NULL;
-  BasicType bt = FieldType::basic_type(s);
+  BasicType bt = Signature::basic_type(s);
   if (is_java_primitive(bt)) {
     assert(s->utf8_length() == 1, "");
     return java_lang_Class::primitive_mirror(bt);
   }
   // Here are some more short cuts for common types.
@@ -972,12 +931,11 @@
 
   if (name != NULL) {
     if (name->utf8_length() == 0)  return 0; // a match is not possible
   }
   if (sig != NULL) {
-    if (sig->utf8_length() == 0)  return 0; // a match is not possible
-    if (sig->char_at(0) == '(')
+    if (sig->starts_with(JVM_SIGNATURE_FUNC))
       match_flags &= ~(IS_FIELD | IS_TYPE);
     else
       match_flags &= ~(IS_CONSTRUCTOR | IS_METHOD);
   }
 
@@ -998,11 +956,11 @@
       } else if (rfill < rlimit) {
         Handle result(thread, results->obj_at(rfill++));
         if (!java_lang_invoke_MemberName::is_instance(result()))
           return -99;  // caller bug!
         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
-        if (!oopDesc::equals(saved, result()))
+        if (saved != result())
           results->obj_at_put(rfill-1, saved);  // show saved instance to user
       } else if (++overflow >= overflow_limit) {
         match_flags = 0; break; // got tired of looking at overflow
       }
     }
@@ -1050,11 +1008,11 @@
         Handle result(thread, results->obj_at(rfill++));
         if (!java_lang_invoke_MemberName::is_instance(result()))
           return -99;  // caller bug!
         CallInfo info(m, NULL, CHECK_0);
         oop saved = MethodHandles::init_method_MemberName(result, info);
-        if (!oopDesc::equals(saved, result()))
+        if (saved != result())
           results->obj_at_put(rfill-1, saved);  // show saved instance to user
       } else if (++overflow >= overflow_limit) {
         match_flags = 0; break; // got tired of looking at overflow
       }
     }
@@ -1096,20 +1054,19 @@
 
   int marked = 0;
   CallSiteDepChange changes(call_site, target);
   {
     NoSafepointVerifier nsv;
-    MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 
     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
     marked = deps.mark_dependent_nmethods(changes);
   }
   if (marked > 0) {
     // At least one nmethod has been marked for deoptimization.
-    VM_Deoptimize op;
-    VMThread::execute(&op);
+    Deoptimization::deoptimize_all_marked();
   }
 }
 
 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
   if (TraceMethodHandles) {
@@ -1384,11 +1341,11 @@
 JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
   {
     // Walk all nmethods depending on this call site.
-    MutexLocker mu(Compile_lock, thread);
+    MutexLocker mu(thread, Compile_lock);
     MethodHandles::flush_dependent_nmethods(call_site, target);
     java_lang_invoke_CallSite::set_target(call_site(), target());
   }
 }
 JVM_END
@@ -1396,11 +1353,11 @@
 JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
   {
     // Walk all nmethods depending on this call site.
-    MutexLocker mu(Compile_lock, thread);
+    MutexLocker mu(thread, Compile_lock);
     MethodHandles::flush_dependent_nmethods(call_site, target);
     java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
   }
 }
 JVM_END
@@ -1452,11 +1409,11 @@
           }
         case -2:  // type
           {
             Symbol* type = caller->constants()->signature_ref_at(bss_index_in_pool);
             Handle th;
-            if (type->char_at(0) == '(') {
+            if (type->char_at(0) == JVM_SIGNATURE_FUNC) {
               th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
             } else {
               th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
             }
             pseudo_arg = th();
@@ -1490,23 +1447,22 @@
 // deallocate their dependency information.
 JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
   Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
   {
     // Walk all nmethods depending on this call site.
-    MutexLocker mu1(Compile_lock, thread);
+    MutexLocker mu1(thread, Compile_lock);
 
     int marked = 0;
     {
       NoSafepointVerifier nsv;
-      MutexLockerEx mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);
       DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
       marked = deps.remove_all_dependents();
     }
     if (marked > 0) {
       // At least one nmethod has been marked for deoptimization
-      VM_Deoptimize op;
-      VMThread::execute(&op);
+      Deoptimization::deoptimize_all_marked();
     }
   }
 }
 JVM_END
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/nativeLookup.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;memory/oopFactory.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;memory/universe.hpp&quot;
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;prims/jvm_misc.hpp&quot;
 37 #include &quot;prims/nativeLookup.hpp&quot;
 38 #include &quot;prims/unsafe.hpp&quot;
 39 #include &quot;runtime/arguments.hpp&quot;
 40 #include &quot;runtime/handles.inline.hpp&quot;
 41 #include &quot;runtime/javaCalls.hpp&quot;
 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/signature.hpp&quot;
 45 #include &quot;utilities/macros.hpp&quot;
 46 #if INCLUDE_JFR
 47 #include &quot;jfr/jfr.hpp&quot;
 48 #endif
 49 
 50 static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
 51   char* bytes = (char*)name-&gt;bytes() + begin;
 52   char* end_bytes = (char*)name-&gt;bytes() + end;
 53   while (bytes &lt; end_bytes) {
 54     jchar c;
 55     bytes = UTF8::next(bytes, &amp;c);
 56     if (c &lt;= 0x7f &amp;&amp; isalnum(c)) {
 57       st-&gt;put((char) c);
 58     } else {
 59            if (c == &#39;_&#39;) st-&gt;print(&quot;_1&quot;);
 60       else if (c == &#39;/&#39;) st-&gt;print(&quot;_&quot;);
 61       else if (c == &#39;;&#39;) st-&gt;print(&quot;_2&quot;);
 62       else if (c == &#39;[&#39;) st-&gt;print(&quot;_3&quot;);
 63       else               st-&gt;print(&quot;_%.5x&quot;, c);
 64     }
 65   }
 66 }
 67 
 68 
 69 static void mangle_name_on(outputStream* st, Symbol* name) {
 70   mangle_name_on(st, name, 0, name-&gt;utf8_length());
 71 }
 72 
 73 
 74 char* NativeLookup::pure_jni_name(const methodHandle&amp; method) {
 75   stringStream st;
 76   // Prefix
 77   st.print(&quot;Java_&quot;);
 78   // Klass name
 79   mangle_name_on(&amp;st, method-&gt;klass_name());
 80   st.print(&quot;_&quot;);
 81   // Method name
 82   mangle_name_on(&amp;st, method-&gt;name());
 83   return st.as_string();
 84 }
 85 
 86 
 87 char* NativeLookup::critical_jni_name(const methodHandle&amp; method) {
 88   stringStream st;
 89   // Prefix
 90   st.print(&quot;JavaCritical_&quot;);
 91   // Klass name
 92   mangle_name_on(&amp;st, method-&gt;klass_name());
 93   st.print(&quot;_&quot;);
 94   // Method name
 95   mangle_name_on(&amp;st, method-&gt;name());
 96   return st.as_string();
 97 }
 98 
 99 
100 char* NativeLookup::long_jni_name(const methodHandle&amp; method) {
101   // Signature ignore the wrapping parenteses and the trailing return type
102   stringStream st;
103   Symbol* signature = method-&gt;signature();
104   st.print(&quot;__&quot;);
105   // find &#39;)&#39;
106   int end;
107   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != &#39;)&#39;; end++);
108   // skip first &#39;(&#39;
109   mangle_name_on(&amp;st, signature, 1, end);
110   return st.as_string();
111 }
112 
113 extern &quot;C&quot; {
114   void JNICALL JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass unsafecls);
115   void JNICALL JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass);
116   void JNICALL JVM_RegisterWhiteBoxMethods(JNIEnv *env, jclass wbclass);
117 #if INCLUDE_JVMCI
118   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
119   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
120 #endif
121 }
122 
123 #define CC (char*)  /* cast a literal from (const char*) */
124 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
125 
126 static JNINativeMethod lookup_special_native_methods[] = {
127   { CC&quot;Java_jdk_internal_misc_Unsafe_registerNatives&quot;,             NULL, FN_PTR(JVM_RegisterJDKInternalMiscUnsafeMethods) },
128   { CC&quot;Java_java_lang_invoke_MethodHandleNatives_registerNatives&quot;, NULL, FN_PTR(JVM_RegisterMethodHandleMethods) },
129   { CC&quot;Java_jdk_internal_perf_Perf_registerNatives&quot;,               NULL, FN_PTR(JVM_RegisterPerfMethods)         },
130   { CC&quot;Java_sun_hotspot_WhiteBox_registerNatives&quot;,                 NULL, FN_PTR(JVM_RegisterWhiteBoxMethods)     },
131 #if INCLUDE_JVMCI
132   { CC&quot;Java_jdk_vm_ci_runtime_JVMCI_initializeRuntime&quot;,            NULL, FN_PTR(JVM_GetJVMCIRuntime)             },
133   { CC&quot;Java_jdk_vm_ci_hotspot_CompilerToVM_registerNatives&quot;,       NULL, FN_PTR(JVM_RegisterJVMCINatives)        },
134 #endif
135 #if INCLUDE_JFR
136   { CC&quot;Java_jdk_jfr_internal_JVM_registerNatives&quot;,                 NULL, FN_PTR(jfr_register_natives)            },
137 #endif
138 };
139 
140 static address lookup_special_native(char* jni_name) {
141   int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
142   for (int i = 0; i &lt; count; i++) {
143     // NB: To ignore the jni prefix and jni postfix strstr is used matching.
144     if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
145       return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
146     }
147   }
148   return NULL;
149 }
150 
151 address NativeLookup::lookup_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style, bool&amp; in_base_library, TRAPS) {
152   address entry;
153   // Compute complete JNI name for style
154   stringStream st;
155   if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);
156   st.print_raw(pure_name);
157   st.print_raw(long_name);
158   if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);
159   char* jni_name = st.as_string();
160 
161   // If the loader is null we have a system class, so we attempt a lookup in
162   // the native Java library. This takes care of any bootstrapping problems.
163   // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find
164   // gets found the first time around - otherwise an infinite loop can occure. This is
165   // another VM/library dependency
166   Handle loader(THREAD, method-&gt;method_holder()-&gt;class_loader());
167   if (loader.is_null()) {
168     entry = lookup_special_native(jni_name);
169     if (entry == NULL) {
170        entry = (address) os::dll_lookup(os::native_java_library(), jni_name);
171     }
172     if (entry != NULL) {
173       in_base_library = true;
174       return entry;
175     }
176   }
177 
178   // Otherwise call static method findNative in ClassLoader
179   Klass*   klass = SystemDictionary::ClassLoader_klass();
180   Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);
181 
182   JavaValue result(T_LONG);
183   JavaCalls::call_static(&amp;result,
184                          klass,
185                          vmSymbols::findNative_name(),
186                          vmSymbols::classloader_string_long_signature(),
187                          // Arguments
188                          loader,
189                          name_arg,
190                          CHECK_NULL);
191   entry = (address) (intptr_t) result.get_jlong();
192 
193   if (entry == NULL) {
194     // findNative didn&#39;t find it, if there are any agent libraries look in them
195     AgentLibrary* agent;
196     for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
197       entry = (address) os::dll_lookup(agent-&gt;os_lib(), jni_name);
198       if (entry != NULL) {
199         return entry;
200       }
201     }
202   }
203 
204   return entry;
205 }
206 
207 
208 address NativeLookup::lookup_critical_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style) {
209   if (!method-&gt;has_native_function()) {
210     return NULL;
211   }
212 
213   address current_entry = method-&gt;native_function();
214 
215   char dll_name[JVM_MAXPATHLEN];
216   int offset;
217   if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {
218     char ebuf[32];
219     void* dll = os::dll_load(dll_name, ebuf, sizeof(ebuf));
220     if (dll != NULL) {
221       // Compute complete JNI name for style
222       stringStream st;
223       if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);
224       st.print_raw(pure_name);
225       st.print_raw(long_name);
226       if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);
227       char* jni_name = st.as_string();
228       address critical_entry = (address)os::dll_lookup(dll, jni_name);
229       // Close the handle to avoid keeping the library alive if the native method holder is unloaded.
230       // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon
231       // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper
232       // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.
233       os::dll_unload(dll);
234       return critical_entry;
235     }
236   }
237 
238   return NULL;
239 }
240 
241 
242 // Check all the formats of native implementation name to see if there is one
243 // for the specified method.
244 address NativeLookup::lookup_entry(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
245   address entry = NULL;
246   in_base_library = false;
247   // Compute pure name
248   char* pure_name = pure_jni_name(method);
249 
250   // Compute argument size
251   int args_size = 1                             // JNIEnv
252                 + (method-&gt;is_static() ? 1 : 0) // class for static methods
253                 + method-&gt;size_of_parameters(); // actual parameters
254 
255   // 1) Try JNI short style
256   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, true,  in_base_library, CHECK_NULL);
257   if (entry != NULL) return entry;
258 
259   // Compute long name
260   char* long_name = long_jni_name(method);
261 
262   // 2) Try JNI long style
263   entry = lookup_style(method, pure_name, long_name, args_size, true,  in_base_library, CHECK_NULL);
264   if (entry != NULL) return entry;
265 
266   // 3) Try JNI short style without os prefix/suffix
267   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, false, in_base_library, CHECK_NULL);
268   if (entry != NULL) return entry;
269 
270   // 4) Try JNI long style without os prefix/suffix
271   entry = lookup_style(method, pure_name, long_name, args_size, false, in_base_library, CHECK_NULL);
272 
273   return entry; // NULL indicates not found
274 }
275 
276 // Check all the formats of native implementation name to see if there is one
277 // for the specified method.
278 address NativeLookup::lookup_critical_entry(const methodHandle&amp; method) {
279   if (!CriticalJNINatives) return NULL;
280 
281   if (method-&gt;is_synchronized() ||
282       !method-&gt;is_static()) {
283     // Only static non-synchronized methods are allowed
284     return NULL;
285   }
286 
287   ResourceMark rm;
288   address entry = NULL;
289 
290   Symbol* signature = method-&gt;signature();
291   for (int end = 0; end &lt; signature-&gt;utf8_length(); end++) {
292     if (signature-&gt;char_at(end) == &#39;L&#39;) {
293       // Don&#39;t allow object types
294       return NULL;
295     }
296   }
297 
298   // Compute critical name
299   char* critical_name = critical_jni_name(method);
300 
301   // Compute argument size
302   int args_size = method-&gt;size_of_parameters();
303   for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
304     if (ss.is_array()) {
305       args_size += T_INT_size; // array length parameter
306     }
307   }
308 
309   // 1) Try JNI short style
310   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, true);
311   if (entry != NULL) return entry;
312 
313   // Compute long name
314   char* long_name = long_jni_name(method);
315 
316   // 2) Try JNI long style
317   entry = lookup_critical_style(method, critical_name, long_name, args_size, true);
318   if (entry != NULL) return entry;
319 
320   // 3) Try JNI short style without os prefix/suffix
321   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, false);
322   if (entry != NULL) return entry;
323 
324   // 4) Try JNI long style without os prefix/suffix
325   entry = lookup_critical_style(method, critical_name, long_name, args_size, false);
326 
327   return entry; // NULL indicates not found
328 }
329 
330 // Check if there are any JVM TI prefixes which have been applied to the native method name.
331 // If any are found, remove them before attemping the look up of the
332 // native implementation again.
333 // See SetNativeMethodPrefix in the JVM TI Spec for more details.
334 address NativeLookup::lookup_entry_prefixed(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
335 #if INCLUDE_JVMTI
336   ResourceMark rm(THREAD);
337 
338   int prefix_count;
339   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
340   char* in_name = method-&gt;name()-&gt;as_C_string();
341   char* wrapper_name = in_name;
342   // last applied prefix will be first -- go backwards
343   for (int i = prefix_count-1; i &gt;= 0; i--) {
344     char* prefix = prefixes[i];
345     size_t prefix_len = strlen(prefix);
346     if (strncmp(prefix, wrapper_name, prefix_len) == 0) {
347       // has this prefix remove it
348       wrapper_name += prefix_len;
349     }
350   }
351   if (wrapper_name != in_name) {
352     // we have a name for a wrapping method
353     int wrapper_name_len = (int)strlen(wrapper_name);
354     TempNewSymbol wrapper_symbol = SymbolTable::probe(wrapper_name, wrapper_name_len);
355     if (wrapper_symbol != NULL) {
356       Klass* k = method-&gt;method_holder();
357       Method* wrapper_method = k-&gt;lookup_method(wrapper_symbol, method-&gt;signature());
358       if (wrapper_method != NULL &amp;&amp; !wrapper_method-&gt;is_native()) {
359         // we found a wrapper method, use its native entry
360         method-&gt;set_is_prefixed_native();
361         return lookup_entry(wrapper_method, in_base_library, THREAD);
362       }
363     }
364   }
365 #endif // INCLUDE_JVMTI
366   return NULL;
367 }
368 
369 address NativeLookup::lookup_base(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
370   address entry = NULL;
371   ResourceMark rm(THREAD);
372 
373   entry = lookup_entry(method, in_base_library, THREAD);
374   if (entry != NULL) return entry;
375 
376   // standard native method resolution has failed.  Check if there are any
377   // JVM TI prefixes which have been applied to the native method name.
378   entry = lookup_entry_prefixed(method, in_base_library, THREAD);
379   if (entry != NULL) return entry;
380 
381   // Native function not found, throw UnsatisfiedLinkError
382   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(),
383               method-&gt;name_and_sig_as_C_string());
384 }
385 
386 
387 address NativeLookup::lookup(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
388   if (!method-&gt;has_native_function()) {
389     address entry = lookup_base(method, in_base_library, CHECK_NULL);
390     method-&gt;set_native_function(entry,
391       Method::native_bind_event_is_interesting);
392     // -verbose:jni printing
393     if (PrintJNIResolving) {
394       ResourceMark rm(THREAD);
395       tty-&gt;print_cr(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,
396         method-&gt;method_holder()-&gt;external_name(),
397         method-&gt;name()-&gt;as_C_string());
398     }
399   }
400   return method-&gt;native_function();
401 }
402 
403 address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
404   EXCEPTION_MARK;
405   bool in_base_library = true;  // SharedRuntime inits some math methods.
406   TempNewSymbol c_name = SymbolTable::new_symbol(class_name,  CATCH);
407   TempNewSymbol m_name = SymbolTable::new_symbol(method_name, CATCH);
408   TempNewSymbol s_name = SymbolTable::new_symbol(signature,   CATCH);
409 
410   // Find the class
411   Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
412   InstanceKlass* klass  = InstanceKlass::cast(k);
413 
414   // Find method and invoke standard lookup
415   methodHandle method (THREAD,
416                        klass-&gt;uncached_lookup_method(m_name, s_name, Klass::find_overpass));
417   address result = lookup(method, in_base_library, CATCH);
418   assert(in_base_library, &quot;must be in basic library&quot;);
419   guarantee(result != NULL, &quot;must be non NULL&quot;);
420   return result;
421 }
    </pre>
  </body>
</html>
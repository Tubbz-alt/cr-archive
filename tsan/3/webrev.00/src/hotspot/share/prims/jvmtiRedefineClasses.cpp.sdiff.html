<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRawMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;

  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;code/codeCache.hpp&quot;
  34 #include &quot;compiler/compileBroker.hpp&quot;
  35 #include &quot;interpreter/oopMapCache.hpp&quot;
  36 #include &quot;interpreter/rewriter.hpp&quot;

  37 #include &quot;logging/logStream.hpp&quot;
  38 #include &quot;memory/metadataFactory.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/resourceArea.hpp&quot;
  41 #include &quot;memory/universe.hpp&quot;

  42 #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">  43 #include &quot;oops/fieldStreams.hpp&quot;</span>
  44 #include &quot;oops/klassVtable.hpp&quot;
  45 #include &quot;oops/oop.inline.hpp&quot;

  46 #include &quot;prims/jvmtiImpl.hpp&quot;
  47 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  48 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  49 #include &quot;prims/resolvedMethodTable.hpp&quot;
  50 #include &quot;prims/methodComparator.hpp&quot;

  51 #include &quot;runtime/deoptimization.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/jniHandles.inline.hpp&quot;
  54 #include &quot;runtime/relocator.hpp&quot;
  55 #include &quot;runtime/safepointVerifiers.hpp&quot;
  56 #include &quot;utilities/bitMap.inline.hpp&quot;
  57 #include &quot;utilities/events.hpp&quot;
  58 
  59 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  60 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  61 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  62 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  63 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  64 Method**  VM_RedefineClasses::_added_methods        = NULL;
  65 int       VM_RedefineClasses::_matching_methods_length = 0;
  66 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  67 int       VM_RedefineClasses::_added_methods_length    = 0;
  68 bool      VM_RedefineClasses::_has_redefined_Object = false;
  69 bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">  70 </span>
  71 
  72 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  73                                        const jvmtiClassDefinition *class_defs,
  74                                        JvmtiClassLoadKind class_load_kind) {
  75   _class_count = class_count;
  76   _class_defs = class_defs;
  77   _class_load_kind = class_load_kind;
  78   _any_class_has_resolved_methods = false;
  79   _res = JVMTI_ERROR_NONE;
  80   _the_class = NULL;
  81   _has_redefined_Object = false;
  82   _has_null_class_loader = false;

  83 }
  84 
  85 static inline InstanceKlass* get_ik(jclass def) {
  86   oop mirror = JNIHandles::resolve_non_null(def);
  87   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  88 }
  89 
  90 // If any of the classes are being redefined, wait
  91 // Parallel constant pool merging leads to indeterminate constant pools.
  92 void VM_RedefineClasses::lock_classes() {
<span class="line-modified">  93   MutexLocker ml(RedefineClasses_lock);</span>
  94   bool has_redefined;
  95   do {
  96     has_redefined = false;
  97     // Go through classes each time until none are being redefined.
  98     for (int i = 0; i &lt; _class_count; i++) {
  99       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
<span class="line-modified"> 100         RedefineClasses_lock-&gt;wait();</span>
 101         has_redefined = true;
 102         break;  // for loop
 103       }
 104     }
 105   } while (has_redefined);
 106   for (int i = 0; i &lt; _class_count; i++) {
 107     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 108   }
<span class="line-modified"> 109   RedefineClasses_lock-&gt;notify_all();</span>
 110 }
 111 
 112 void VM_RedefineClasses::unlock_classes() {
<span class="line-modified"> 113   MutexLocker ml(RedefineClasses_lock);</span>
 114   for (int i = 0; i &lt; _class_count; i++) {
 115     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 116            &quot;should be being redefined to get here&quot;);
 117     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 118   }
<span class="line-modified"> 119   RedefineClasses_lock-&gt;notify_all();</span>
 120 }
 121 
 122 bool VM_RedefineClasses::doit_prologue() {
 123   if (_class_count == 0) {
 124     _res = JVMTI_ERROR_NONE;
 125     return false;
 126   }
 127   if (_class_defs == NULL) {
 128     _res = JVMTI_ERROR_NULL_POINTER;
 129     return false;
 130   }
 131 
 132   for (int i = 0; i &lt; _class_count; i++) {
 133     if (_class_defs[i].klass == NULL) {
 134       _res = JVMTI_ERROR_INVALID_CLASS;
 135       return false;
 136     }
 137     if (_class_defs[i].class_byte_count == 0) {
 138       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 139       return false;
</pre>
<hr />
<pre>
 190 
 191 void VM_RedefineClasses::doit() {
 192   Thread *thread = Thread::current();
 193 
 194 #if INCLUDE_CDS
 195   if (UseSharedSpaces) {
 196     // Sharing is enabled so we remap the shared readonly space to
 197     // shared readwrite, private just in case we need to redefine
 198     // a shared class. We do the remap during the doit() phase of
 199     // the safepoint to be safer.
 200     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 201       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 202       _res = JVMTI_ERROR_INTERNAL;
 203       return;
 204     }
 205   }
 206 #endif
 207 
 208   // Mark methods seen on stack and everywhere else so old methods are not
 209   // cleaned up if they&#39;re on the stack.
<span class="line-modified"> 210   MetadataOnStackMark md_on_stack(true);</span>
 211   HandleMark hm(thread);   // make sure any handles created are deleted
 212                            // before the stack walk again.
 213 
 214   for (int i = 0; i &lt; _class_count; i++) {
 215     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 216   }
 217 
 218   // Flush all compiled code that depends on the classes redefined.
 219   flush_dependent_code();
 220 
 221   // Adjust constantpool caches and vtables for all classes
 222   // that reference methods of the evolved classes.
 223   // Have to do this after all classes are redefined and all methods that
 224   // are redefined are marked as old.
 225   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 226   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 227 
 228   // JSR-292 support
 229   if (_any_class_has_resolved_methods) {
 230     bool trace_name_printed = false;
 231     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 232   }
 233 
<span class="line-modified"> 234   // Disable any dependent concurrent compilations</span>
<span class="line-removed"> 235   SystemDictionary::notice_modification();</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237   // Set flag indicating that some invariants are no longer true.</span>
 238   // See jvmtiExport.hpp for detailed explanation.
<span class="line-modified"> 239   JvmtiExport::set_has_redefined_a_class();</span>
 240 
 241   // check_class() is optionally called for product bits, but is
 242   // always called for non-product bits.
 243 #ifdef PRODUCT
 244   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 245 #endif
 246     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 247     CheckClass check_class(thread);
 248     ClassLoaderDataGraph::classes_do(&amp;check_class);
 249 #ifdef PRODUCT
 250   }
 251 #endif
 252 
 253   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 254   ClassLoaderDataGraph::clean_deallocate_lists(false);
 255 }
 256 
 257 void VM_RedefineClasses::doit_epilogue() {
 258   unlock_classes();
 259 
</pre>
<hr />
<pre>
 770 
 771     for (int i = 0; i &lt; members_len; i++) {
 772       if (the_syms[i] != scr_syms[i]) {
 773         log_trace(redefine, class, nestmates)
 774           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 775            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 776         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 777       }
 778     }
 779   } else if (the_members_exists ^ scr_members_exists) {
 780     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 781     log_trace(redefine, class, nestmates)
 782       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 783        the_class-&gt;external_name(), action_str);
 784     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 785   }
 786 
 787   return JVMTI_ERROR_NONE;
 788 }
 789 





































































 790 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 791              InstanceKlass* the_class,
 792              InstanceKlass* scratch_class) {
 793   int i;
 794 
 795   // Check superclasses, or rather their names, since superclasses themselves can be
 796   // requested to replace.
 797   // Check for NULL superclass first since this might be java.lang.Object
 798   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 799       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 800        the_class-&gt;super()-&gt;name() !=
 801        scratch_class-&gt;super()-&gt;name())) {
 802     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 803   }
 804 
 805   // Check if the number, names and order of directly implemented interfaces are the same.
 806   // I think in principle we should just check if the sets of names of directly implemented
 807   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 808   // .java file, also changes in .class file) should not matter. However, comparing sets is
 809   // technically a bit more difficult, and, more importantly, I am not sure at present that the
</pre>
<hr />
<pre>
 817   }
 818   for (i = 0; i &lt; n_intfs; i++) {
 819     if (k_interfaces-&gt;at(i)-&gt;name() !=
 820         k_new_interfaces-&gt;at(i)-&gt;name()) {
 821       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 822     }
 823   }
 824 
 825   // Check whether class is in the error init state.
 826   if (the_class-&gt;is_in_error_state()) {
 827     // TBD #5057930: special error code is needed in 1.6
 828     return JVMTI_ERROR_INVALID_CLASS;
 829   }
 830 
 831   // Check whether the nest-related attributes have been changed.
 832   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 833   if (err != JVMTI_ERROR_NONE) {
 834     return err;
 835   }
 836 






 837   // Check whether class modifiers are the same.
 838   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 839   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 840   if (old_flags != new_flags) {
 841     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 842   }
 843 
 844   // Check if the number, names, types and order of fields declared in these classes
 845   // are the same.
 846   JavaFieldStream old_fs(the_class);
 847   JavaFieldStream new_fs(scratch_class);
 848   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 849     // access
 850     old_flags = old_fs.access_flags().as_short();
 851     new_flags = new_fs.access_flags().as_short();
 852     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 853       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 854     }
 855     // offset
 856     if (old_fs.offset() != new_fs.offset()) {
</pre>
<hr />
<pre>
 975             idnum_owner-&gt;set_method_idnum(new_num);
 976             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
 977           }
 978           // Take current and original idnum from the old_method
 979           k_new_method-&gt;set_method_idnum(old_num);
 980           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
 981           if (thread-&gt;has_pending_exception()) {
 982             return JVMTI_ERROR_OUT_OF_MEMORY;
 983           }
 984         }
 985       }
 986       log_trace(redefine, class, normalize)
 987         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
 988          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
 989       // advance to next pair of methods
 990       ++oi;
 991       ++ni;
 992       break;
 993     case added:
 994       // method added, see if it is OK
<span class="line-modified"> 995       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();</span>
<span class="line-removed"> 996       if ((new_flags &amp; JVM_ACC_PRIVATE) == 0</span>
<span class="line-removed"> 997            // hack: private should be treated as final, but alas</span>
<span class="line-removed"> 998           || (new_flags &amp; (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0</span>
<span class="line-removed"> 999          ) {</span>
<span class="line-removed">1000         // new methods must be private</span>
1001         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1002       }
1003       {
1004         u2 num = the_class-&gt;next_method_idnum();
1005         if (num == ConstMethod::UNSET_IDNUM) {
1006           // cannot add any more methods
1007           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1008         }
1009         u2 new_num = k_new_method-&gt;method_idnum();
1010         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1011         if (idnum_owner != NULL) {
1012           // There is already a method assigned this idnum -- switch them
1013           // Take current and original idnum from the new_method
1014           idnum_owner-&gt;set_method_idnum(new_num);
1015           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1016         }
1017         k_new_method-&gt;set_method_idnum(num);
1018         k_new_method-&gt;set_orig_method_idnum(num);
1019         if (thread-&gt;has_pending_exception()) {
1020           return JVMTI_ERROR_OUT_OF_MEMORY;
1021         }
1022       }
1023       log_trace(redefine, class, normalize)
1024         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1025       ++ni; // advance to next new method
1026       break;
1027     case deleted:
1028       // method deleted, see if it is OK
<span class="line-modified">1029       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();</span>
<span class="line-removed">1030       if ((old_flags &amp; JVM_ACC_PRIVATE) == 0</span>
<span class="line-removed">1031            // hack: private should be treated as final, but alas</span>
<span class="line-removed">1032           || (old_flags &amp; (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0</span>
<span class="line-removed">1033          ) {</span>
<span class="line-removed">1034         // deleted methods must be private</span>
1035         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1036       }
1037       log_trace(redefine, class, normalize)
1038         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1039       ++oi; // advance to next old method
1040       break;
1041     default:
1042       ShouldNotReachHere();
1043     }
1044   }
1045 
1046   return JVMTI_ERROR_NONE;
1047 }
1048 
1049 
1050 // Find new constant pool index value for old constant pool index value
1051 // by seaching the index map. Returns zero (0) if there is no mapped
1052 // value for the old constant pool index.
1053 int VM_RedefineClasses::find_new_index(int old_index) {
1054   if (_index_map_count == 0) {
</pre>
<hr />
<pre>
1612   _index_map_count = 0;
1613   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1614 
1615   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1616   _operands_index_map_count = 0;
1617   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1618   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1619 
1620   // reference to the cp holder is needed for copy_operands()
1621   merge_cp-&gt;set_pool_holder(scratch_class);
1622   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1623                   &amp;merge_cp_length, THREAD);
1624   merge_cp-&gt;set_pool_holder(NULL);
1625 
1626   if (!result) {
1627     // The merge can fail due to memory allocation failure or due
1628     // to robustness checks.
1629     return JVMTI_ERROR_INTERNAL;
1630   }
1631 





1632   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1633 
1634   if (_index_map_count == 0) {
1635     // there is nothing to map between the new and merged constant pools
1636 
1637     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1638       // The old and new constant pools are the same length and the
1639       // index map is empty. This means that the three constant pools
1640       // are equivalent (but not the same). Unfortunately, the new
1641       // constant pool has not gone through link resolution nor have
1642       // the new class bytecodes gone through constant pool cache
1643       // rewriting so we can&#39;t use the old constant pool with the new
1644       // class.
1645 
1646       // toss the merged constant pool at return
1647     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1648       // The old constant pool has fewer entries than the new constant
1649       // pool and the index map is empty. This means the new constant
1650       // pool is a superset of the old constant pool. However, the old
1651       // class bytecodes have already gone through constant pool cache
</pre>
<hr />
<pre>
1695                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1696     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1697     // It can&#39;t be cleaned up while there are handles to it.
1698     cp_cleaner.add_scratch_cp(scratch_cp());
1699   }
1700 
1701   return JVMTI_ERROR_NONE;
1702 } // end merge_cp_and_rewrite()
1703 
1704 
1705 // Rewrite constant pool references in klass scratch_class.
1706 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1707        TRAPS) {
1708 
1709   // rewrite constant pool references in the nest attributes:
1710   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1711     // propagate failure back to caller
1712     return false;
1713   }
1714 






1715   // rewrite constant pool references in the methods:
1716   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1717     // propagate failure back to caller
1718     return false;
1719   }
1720 
1721   // rewrite constant pool references in the class_annotations:
1722   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1723     // propagate failure back to caller
1724     return false;
1725   }
1726 
1727   // rewrite constant pool references in the fields_annotations:
1728   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1729     // propagate failure back to caller
1730     return false;
1731   }
1732 
1733   // rewrite constant pool references in the methods_annotations:
1734   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
</pre>
<hr />
<pre>
1793 
1794   return true;
1795 } // end rewrite_cp_refs()
1796 
1797 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1798 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1799        InstanceKlass* scratch_class) {
1800 
1801   u2 cp_index = scratch_class-&gt;nest_host_index();
1802   if (cp_index != 0) {
1803     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1804   }
1805   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1806   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1807     u2 cp_index = nest_members-&gt;at(i);
1808     nest_members-&gt;at_put(i, find_new_index(cp_index));
1809   }
1810   return true;
1811 }
1812 








































1813 // Rewrite constant pool references in the methods.
1814 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1815        InstanceKlass* scratch_class, TRAPS) {
1816 
1817   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1818 
1819   if (methods == NULL || methods-&gt;length() == 0) {
1820     // no methods so nothing to do
1821     return true;
1822   }
1823 
1824   // rewrite constant pool references in the methods:
1825   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1826     methodHandle method(THREAD, methods-&gt;at(i));
1827     methodHandle new_method;
1828     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1829     if (!new_method.is_null()) {
1830       // the method has been replaced so save the new method version
1831       // even in the case of an exception.  original method is on the
1832       // deallocation list.
</pre>
<hr />
<pre>
2150 //       element_value values[num_values];
2151 //     } array_value;
2152 //   } value;
2153 // }
2154 //
2155 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2156        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2157 
2158   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2159     // not enough room for a tag let alone the rest of an element_value
2160     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2161     return false;
2162   }
2163 
2164   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2165   byte_i_ref++;
2166   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2167 
2168   switch (tag) {
2169     // These BaseType tag values are from Table 4.2 in VM spec:
<span class="line-modified">2170     case &#39;B&#39;:  // byte</span>
<span class="line-modified">2171     case &#39;C&#39;:  // char</span>
<span class="line-modified">2172     case &#39;D&#39;:  // double</span>
<span class="line-modified">2173     case &#39;F&#39;:  // float</span>
<span class="line-modified">2174     case &#39;I&#39;:  // int</span>
<span class="line-modified">2175     case &#39;J&#39;:  // long</span>
<span class="line-modified">2176     case &#39;S&#39;:  // short</span>
<span class="line-modified">2177     case &#39;Z&#39;:  // boolean</span>
2178 
2179     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2180     // the VM spec:
2181     case &#39;s&#39;:
2182     {
2183       // For the above tag values (including the BaseType values),
2184       // value.const_value_index is right union field.
2185 
2186       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2187         // not enough room for a const_value_index
2188         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2189         return false;
2190       }
2191 
2192       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2193                                annotations_typeArray, byte_i_ref,
2194                                &quot;const_value_index&quot;, THREAD);
2195 
2196       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2197     } break;
</pre>
<hr />
<pre>
2228         return false;
2229       }
2230 
2231       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2232                               annotations_typeArray, byte_i_ref,
2233                               &quot;class_info_index&quot;, THREAD);
2234 
2235       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2236     } break;
2237 
2238     case &#39;@&#39;:
2239       // For the above tag value, value.attr_value is the right union
2240       // field. This is a nested annotation.
2241       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2242              byte_i_ref, THREAD)) {
2243         // propagate failure back to caller
2244         return false;
2245       }
2246       break;
2247 
<span class="line-modified">2248     case &#39;[&#39;:</span>
2249     {
2250       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2251         // not enough room for a num_values field
2252         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2253         return false;
2254       }
2255 
2256       // For the above tag value, value.array_value is the right union
2257       // field. This is an array of nested element_value.
2258       u2 num_values = Bytes::get_Java_u2((address)
2259                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2260       byte_i_ref += 2;
2261       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2262 
2263       int calc_num_values = 0;
2264       for (; calc_num_values &lt; num_values; calc_num_values++) {
2265         if (!rewrite_cp_refs_in_element_value(
2266                annotations_typeArray, byte_i_ref, THREAD)) {
2267           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2268           // propagate failure back to caller
</pre>
<hr />
<pre>
3235        ClassLoaderData* loader_data,
3236        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3237        int scratch_cp_length, TRAPS) {
3238   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3239 
3240   // scratch_cp is a merged constant pool and has enough space for a
3241   // worst case merge situation. We want to associate the minimum
3242   // sized constant pool with the klass to save space.
3243   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3244   constantPoolHandle smaller_cp(THREAD, cp);
3245 
3246   // preserve version() value in the smaller copy
3247   int version = scratch_cp-&gt;version();
3248   assert(version != 0, &quot;sanity check&quot;);
3249   smaller_cp-&gt;set_version(version);
3250 
3251   // attach klass to new constant pool
3252   // reference to the cp holder is needed for copy_operands()
3253   smaller_cp-&gt;set_pool_holder(scratch_class);
3254 




3255   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3256   if (HAS_PENDING_EXCEPTION) {
3257     // Exception is handled in the caller
3258     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3259     return;
3260   }
3261   scratch_cp = smaller_cp;
3262 
3263   // attach new constant pool to klass
3264   scratch_class-&gt;set_constants(scratch_cp());
3265   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3266 
3267   int i;  // for portability
3268 
3269   // update each field in klass to use new constant pool indices as needed
3270   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3271     jshort cur_index = fs.name_index();
3272     jshort new_index = find_new_index(cur_index);
3273     if (new_index != 0) {
3274       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
</pre>
<hr />
<pre>
3472       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3473     }
3474 
3475     if (ik-&gt;itable_length() &gt; 0) {
3476       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3477     }
3478 
3479     // The constant pools in other classes (other_cp) can refer to
3480     // old methods.  We have to update method information in
3481     // other_cp&#39;s cache. If other_cp has a previous version, then we
3482     // have to repeat the process for each previous version. The
3483     // constant pool cache holds the Method*s for non-virtual
3484     // methods and for virtual, final methods.
3485     //
3486     // Special case: if the current class being redefined, then new_cp
3487     // has already been attached to the_class and old_cp has already
3488     // been added as a previous version. The new_cp doesn&#39;t have any
3489     // cached references to old methods so it doesn&#39;t need to be
3490     // updated. We can simply start with the previous version(s) in
3491     // that case.
<span class="line-removed">3492     constantPoolHandle other_cp;</span>
3493     ConstantPoolCache* cp_cache;
3494 
3495     if (!ik-&gt;is_being_redefined()) {
3496       // this klass&#39; constant pool cache may need adjustment
<span class="line-modified">3497       other_cp = constantPoolHandle(ik-&gt;constants());</span>
3498       cp_cache = other_cp-&gt;cache();
3499       if (cp_cache != NULL) {
3500         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3501       }
3502     }
3503 
3504     // the previous versions&#39; constant pool caches may need adjustment
3505     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3506          pv_node != NULL;
3507          pv_node = pv_node-&gt;previous_versions()) {
3508       cp_cache = pv_node-&gt;constants()-&gt;cache();
3509       if (cp_cache != NULL) {
3510         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3511       }
3512     }
3513   }
3514 }
3515 
<span class="line-modified">3516 void VM_RedefineClasses::update_jmethod_ids() {</span>
3517   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3518     Method* old_method = _matching_old_methods[j];
3519     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3520     if (jmid != NULL) {
3521       // There is a jmethodID, change it to point to the new method
<span class="line-modified">3522       methodHandle new_method_h(_matching_new_methods[j]);</span>
3523       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3524       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3525              &quot;should be replaced&quot;);
3526     }
3527   }
<span class="line-removed">3528   // Update deleted jmethodID</span>
<span class="line-removed">3529   for (int j = 0; j &lt; _deleted_methods_length; ++j) {</span>
<span class="line-removed">3530     Method* old_method = _deleted_methods[j];</span>
<span class="line-removed">3531     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();</span>
<span class="line-removed">3532     if (jmid != NULL) {</span>
<span class="line-removed">3533       // Change the jmethodID to point to NSME.</span>
<span class="line-removed">3534       Method::change_method_associated_with_jmethod_id(jmid, Universe::throw_no_such_method_error());</span>
<span class="line-removed">3535     }</span>
<span class="line-removed">3536   }</span>
3537 }
3538 
3539 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3540   int emcp_method_count = 0;
3541   int obsolete_count = 0;
3542   int old_index = 0;
3543   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3544     Method* old_method = _matching_old_methods[j];
3545     Method* new_method = _matching_new_methods[j];
3546     Method* old_array_method;
3547 
3548     // Maintain an old_index into the _old_methods array by skipping
3549     // deleted methods
3550     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3551       ++old_index;
3552     }
3553 
3554     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3555       // The EMCP definition from JSR-163 requires the bytecodes to be
3556       // the same with the exception of constant pool indices which may
</pre>
<hr />
<pre>
3825 // First step is to walk the code cache for each class redefined and mark
3826 // dependent methods.  Wait until all classes are processed to deoptimize everything.
3827 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
3828   assert_locked_or_safepoint(Compile_lock);
3829 
3830   // All dependencies have been recorded from startup or this is a second or
3831   // subsequent use of RedefineClasses
3832   if (JvmtiExport::all_dependencies_are_recorded()) {
3833     CodeCache::mark_for_evol_deoptimization(ik);
3834   }
3835 }
3836 
3837 void VM_RedefineClasses::flush_dependent_code() {
3838   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3839 
3840   bool deopt_needed;
3841 
3842   // This is the first redefinition, mark all the nmethods for deoptimization
3843   if (!JvmtiExport::all_dependencies_are_recorded()) {
3844     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
<span class="line-modified">3845     CodeCache::mark_all_nmethods_for_deoptimization();</span>
3846     deopt_needed = true;
3847   } else {
3848     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
3849     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
3850     deopt_needed = (deopt != 0);
3851   }
3852 
3853   if (deopt_needed) {
3854     CodeCache::flush_evol_dependents();
3855   }
3856 
3857   // From now on we know that the dependency information is complete
3858   JvmtiExport::set_all_dependencies_are_recorded(true);
3859 }
3860 
3861 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
3862   Method* old_method;
3863   Method* new_method;
3864 
3865   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
</pre>
<hr />
<pre>
3950     _timer_rsc_phase1.start();
3951   }
3952 
3953   InstanceKlass* the_class = get_ik(the_jclass);
3954 
3955   // Set some flags to control and optimize adjusting method entries
3956   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
3957   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
3958 
3959   // Remove all breakpoints in methods of this class
3960   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
3961   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
3962 
3963   // Mark all compiled code that depends on this class
3964   mark_dependent_code(the_class);
3965 
3966   _old_methods = the_class-&gt;methods();
3967   _new_methods = scratch_class-&gt;methods();
3968   _the_class = the_class;
3969   compute_added_deleted_matching_methods();
<span class="line-modified">3970   update_jmethod_ids();</span>
3971 
3972   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
3973 
3974   // Attach new constant pool to the original klass. The original
3975   // klass still refers to the old constant pool (for now).
3976   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
3977 
3978 #if 0
3979   // In theory, with constant pool merging in place we should be able
3980   // to save space by using the new, merged constant pool in place of
3981   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
3982   // the klass version we are replacing now and any constant pool(s) in
3983   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
3984   // When this code is enabled, even simple programs throw NullPointer
3985   // exceptions. I&#39;m guessing that this is caused by some constant pool
3986   // cache difference between the new, merged constant pool and the
3987   // constant pool that was just being used by the klass. I&#39;m keeping
3988   // this code around to archive the idea, but the code has to remain
3989   // disabled for now.
3990 
</pre>
<hr />
<pre>
4167     // Class was already initialized, so AOT has only seen the original version.
4168     // We need to let AOT look at it again.
4169     AOTLoader::load_for_klass(the_class, THREAD);
4170   }
4171 
4172   // keep track of previous versions of this class
4173   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4174 
4175   _timer_rsc_phase1.stop();
4176   if (log_is_enabled(Info, redefine, class, timer)) {
4177     _timer_rsc_phase2.start();
4178   }
4179 
4180   if (the_class-&gt;oop_map_cache() != NULL) {
4181     // Flush references to any obsolete methods from the oop map cache
4182     // so that obsolete methods are not pinned.
4183     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4184   }
4185 
4186   increment_class_counter((InstanceKlass *)the_class, THREAD);









4187   {
4188     ResourceMark rm(THREAD);
4189     // increment the classRedefinedCount field in the_class and in any
4190     // direct and indirect subclasses of the_class
4191     log_info(redefine, class, load)
4192       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4193        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4194     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4195                              the_class-&gt;external_name(),
4196                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4197 
4198   }
4199   _timer_rsc_phase2.stop();

4200 } // end redefine_single_class()
4201 
4202 
4203 // Increment the classRedefinedCount field in the specific InstanceKlass
4204 // and in all direct and indirect subclasses.
4205 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4206   oop class_mirror = ik-&gt;java_mirror();
4207   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4208   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4209   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4210 
4211   if (class_oop != _the_class) {
4212     // _the_class count is printed at end of redefine_single_class()
4213     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4214   }
4215 
4216   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4217        subk = subk-&gt;next_sibling()) {
4218     if (subk-&gt;is_instance_klass()) {
4219       // Only update instanceKlasses
</pre>
<hr />
<pre>
4266           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4267            ik-&gt;signature_name());
4268         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4269       }
4270       no_old_methods = false;
4271     }
4272   }
4273 
4274   // print and fail guarantee if old methods are found.
4275   if (!no_old_methods) {
4276     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4277       dump_methods();
4278     } else {
4279       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4280         &quot;to see more info about the following guarantee() failure.&quot;);
4281     }
4282     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4283   }
4284 }
4285 










4286 
4287 void VM_RedefineClasses::dump_methods() {
4288   int j;
4289   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4290   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4291     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4292     Method* m = _old_methods-&gt;at(j);
4293     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4294     m-&gt;access_flags().print_on(&amp;log_stream);
4295     log_stream.print(&quot; --  &quot;);
4296     m-&gt;print_name(&amp;log_stream);
4297     log_stream.cr();
4298   }
4299   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4300   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4301     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4302     Method* m = _new_methods-&gt;at(j);
4303     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4304     m-&gt;access_flags().print_on(&amp;log_stream);
4305     log_stream.print(&quot; --  &quot;);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
<span class="line-added">  31 #include &quot;classfile/symbolTable.hpp&quot;</span>
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
<span class="line-added">  38 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
<span class="line-added">  44 #include &quot;oops/annotations.hpp&quot;</span>
  45 #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">  46 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  49 #include &quot;oops/recordComponent.hpp&quot;</span>
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
<span class="line-added">  55 #include &quot;runtime/atomic.hpp&quot;</span>
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
  74 bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">  75 u8        VM_RedefineClasses::_id_counter = 0;</span>
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
  86   _has_redefined_Object = false;
  87   _has_null_class_loader = false;
<span class="line-added">  88   _id = next_id();</span>
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
<span class="line-modified">  99   MonitorLocker ml(RedefineClasses_lock);</span>
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
<span class="line-modified"> 106         ml.wait();</span>
 107         has_redefined = true;
 108         break;  // for loop
 109       }
 110     }
 111   } while (has_redefined);
 112   for (int i = 0; i &lt; _class_count; i++) {
 113     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 114   }
<span class="line-modified"> 115   ml.notify_all();</span>
 116 }
 117 
 118 void VM_RedefineClasses::unlock_classes() {
<span class="line-modified"> 119   MonitorLocker ml(RedefineClasses_lock);</span>
 120   for (int i = 0; i &lt; _class_count; i++) {
 121     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 122            &quot;should be being redefined to get here&quot;);
 123     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 124   }
<span class="line-modified"> 125   ml.notify_all();</span>
 126 }
 127 
 128 bool VM_RedefineClasses::doit_prologue() {
 129   if (_class_count == 0) {
 130     _res = JVMTI_ERROR_NONE;
 131     return false;
 132   }
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
</pre>
<hr />
<pre>
 196 
 197 void VM_RedefineClasses::doit() {
 198   Thread *thread = Thread::current();
 199 
 200 #if INCLUDE_CDS
 201   if (UseSharedSpaces) {
 202     // Sharing is enabled so we remap the shared readonly space to
 203     // shared readwrite, private just in case we need to redefine
 204     // a shared class. We do the remap during the doit() phase of
 205     // the safepoint to be safer.
 206     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 207       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 208       _res = JVMTI_ERROR_INTERNAL;
 209       return;
 210     }
 211   }
 212 #endif
 213 
 214   // Mark methods seen on stack and everywhere else so old methods are not
 215   // cleaned up if they&#39;re on the stack.
<span class="line-modified"> 216   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);</span>
 217   HandleMark hm(thread);   // make sure any handles created are deleted
 218                            // before the stack walk again.
 219 
 220   for (int i = 0; i &lt; _class_count; i++) {
 221     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 222   }
 223 
 224   // Flush all compiled code that depends on the classes redefined.
 225   flush_dependent_code();
 226 
 227   // Adjust constantpool caches and vtables for all classes
 228   // that reference methods of the evolved classes.
 229   // Have to do this after all classes are redefined and all methods that
 230   // are redefined are marked as old.
 231   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 232   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 233 
 234   // JSR-292 support
 235   if (_any_class_has_resolved_methods) {
 236     bool trace_name_printed = false;
 237     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 238   }
 239 
<span class="line-modified"> 240   // Increment flag indicating that some invariants are no longer true.</span>



 241   // See jvmtiExport.hpp for detailed explanation.
<span class="line-modified"> 242   JvmtiExport::increment_redefinition_count();</span>
 243 
 244   // check_class() is optionally called for product bits, but is
 245   // always called for non-product bits.
 246 #ifdef PRODUCT
 247   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 248 #endif
 249     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 250     CheckClass check_class(thread);
 251     ClassLoaderDataGraph::classes_do(&amp;check_class);
 252 #ifdef PRODUCT
 253   }
 254 #endif
 255 
 256   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 257   ClassLoaderDataGraph::clean_deallocate_lists(false);
 258 }
 259 
 260 void VM_RedefineClasses::doit_epilogue() {
 261   unlock_classes();
 262 
</pre>
<hr />
<pre>
 773 
 774     for (int i = 0; i &lt; members_len; i++) {
 775       if (the_syms[i] != scr_syms[i]) {
 776         log_trace(redefine, class, nestmates)
 777           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 778            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 779         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 780       }
 781     }
 782   } else if (the_members_exists ^ scr_members_exists) {
 783     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 784     log_trace(redefine, class, nestmates)
 785       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 786        the_class-&gt;external_name(), action_str);
 787     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 788   }
 789 
 790   return JVMTI_ERROR_NONE;
 791 }
 792 
<span class="line-added"> 793 // Return an error status if the class Record attribute was changed.</span>
<span class="line-added"> 794 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {</span>
<span class="line-added"> 795   // Get lists of record components.</span>
<span class="line-added"> 796   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();</span>
<span class="line-added"> 797   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();</span>
<span class="line-added"> 798   bool the_record_exists = the_record != NULL;</span>
<span class="line-added"> 799   bool scr_record_exists = scr_record != NULL;</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801   if (the_record_exists &amp;&amp; scr_record_exists) {</span>
<span class="line-added"> 802     int the_num_components = the_record-&gt;length();</span>
<span class="line-added"> 803     int scr_num_components = scr_record-&gt;length();</span>
<span class="line-added"> 804     if (the_num_components != scr_num_components) {</span>
<span class="line-added"> 805       log_trace(redefine, class, record)</span>
<span class="line-added"> 806         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,</span>
<span class="line-added"> 807          the_class-&gt;external_name(), the_num_components, scr_num_components);</span>
<span class="line-added"> 808       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 809     }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811     // Compare each field in each record component.</span>
<span class="line-added"> 812     ConstantPool* the_cp =  the_class-&gt;constants();</span>
<span class="line-added"> 813     ConstantPool* scr_cp =  scratch_class-&gt;constants();</span>
<span class="line-added"> 814     for (int x = 0; x &lt; the_num_components; x++) {</span>
<span class="line-added"> 815       RecordComponent* the_component = the_record-&gt;at(x);</span>
<span class="line-added"> 816       RecordComponent* scr_component = scr_record-&gt;at(x);</span>
<span class="line-added"> 817       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());</span>
<span class="line-added"> 818       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());</span>
<span class="line-added"> 819       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());</span>
<span class="line-added"> 820       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());</span>
<span class="line-added"> 821       if (the_name != scr_name || the_descr != scr_descr) {</span>
<span class="line-added"> 822         log_trace(redefine, class, record)</span>
<span class="line-added"> 823           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,</span>
<span class="line-added"> 824            the_class-&gt;external_name());</span>
<span class="line-added"> 825         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 826       }</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828       int the_gen_sig = the_component-&gt;generic_signature_index();</span>
<span class="line-added"> 829       int scr_gen_sig = scr_component-&gt;generic_signature_index();</span>
<span class="line-added"> 830       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :</span>
<span class="line-added"> 831         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));</span>
<span class="line-added"> 832       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :</span>
<span class="line-added"> 833         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));</span>
<span class="line-added"> 834       if (the_gen_sig_sym != scr_gen_sig_sym) {</span>
<span class="line-added"> 835         log_trace(redefine, class, record)</span>
<span class="line-added"> 836           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,</span>
<span class="line-added"> 837            the_class-&gt;external_name());</span>
<span class="line-added"> 838         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 839       }</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841       // It&#39;s okay if a record component&#39;s annotations were changed.</span>
<span class="line-added"> 842     }</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844   } else if (the_record_exists ^ scr_record_exists) {</span>
<span class="line-added"> 845     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;</span>
<span class="line-added"> 846     log_trace(redefine, class, record)</span>
<span class="line-added"> 847       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,</span>
<span class="line-added"> 848        the_class-&gt;external_name(), action_str);</span>
<span class="line-added"> 849     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 850   }</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852   return JVMTI_ERROR_NONE;</span>
<span class="line-added"> 853 }</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855 </span>
<span class="line-added"> 856 static bool can_add_or_delete(Method* m) {</span>
<span class="line-added"> 857       // Compatibility mode</span>
<span class="line-added"> 858   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;</span>
<span class="line-added"> 859           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));</span>
<span class="line-added"> 860 }</span>
<span class="line-added"> 861 </span>
 862 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 863              InstanceKlass* the_class,
 864              InstanceKlass* scratch_class) {
 865   int i;
 866 
 867   // Check superclasses, or rather their names, since superclasses themselves can be
 868   // requested to replace.
 869   // Check for NULL superclass first since this might be java.lang.Object
 870   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 871       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 872        the_class-&gt;super()-&gt;name() !=
 873        scratch_class-&gt;super()-&gt;name())) {
 874     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 875   }
 876 
 877   // Check if the number, names and order of directly implemented interfaces are the same.
 878   // I think in principle we should just check if the sets of names of directly implemented
 879   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 880   // .java file, also changes in .class file) should not matter. However, comparing sets is
 881   // technically a bit more difficult, and, more importantly, I am not sure at present that the
</pre>
<hr />
<pre>
 889   }
 890   for (i = 0; i &lt; n_intfs; i++) {
 891     if (k_interfaces-&gt;at(i)-&gt;name() !=
 892         k_new_interfaces-&gt;at(i)-&gt;name()) {
 893       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 894     }
 895   }
 896 
 897   // Check whether class is in the error init state.
 898   if (the_class-&gt;is_in_error_state()) {
 899     // TBD #5057930: special error code is needed in 1.6
 900     return JVMTI_ERROR_INVALID_CLASS;
 901   }
 902 
 903   // Check whether the nest-related attributes have been changed.
 904   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 905   if (err != JVMTI_ERROR_NONE) {
 906     return err;
 907   }
 908 
<span class="line-added"> 909   // Check whether the Record attribute has been changed.</span>
<span class="line-added"> 910   err = check_record_attribute(the_class, scratch_class);</span>
<span class="line-added"> 911   if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added"> 912     return err;</span>
<span class="line-added"> 913   }</span>
<span class="line-added"> 914 </span>
 915   // Check whether class modifiers are the same.
 916   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 917   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 918   if (old_flags != new_flags) {
 919     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 920   }
 921 
 922   // Check if the number, names, types and order of fields declared in these classes
 923   // are the same.
 924   JavaFieldStream old_fs(the_class);
 925   JavaFieldStream new_fs(scratch_class);
 926   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 927     // access
 928     old_flags = old_fs.access_flags().as_short();
 929     new_flags = new_fs.access_flags().as_short();
 930     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 931       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 932     }
 933     // offset
 934     if (old_fs.offset() != new_fs.offset()) {
</pre>
<hr />
<pre>
1053             idnum_owner-&gt;set_method_idnum(new_num);
1054             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1055           }
1056           // Take current and original idnum from the old_method
1057           k_new_method-&gt;set_method_idnum(old_num);
1058           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1059           if (thread-&gt;has_pending_exception()) {
1060             return JVMTI_ERROR_OUT_OF_MEMORY;
1061           }
1062         }
1063       }
1064       log_trace(redefine, class, normalize)
1065         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1066          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1067       // advance to next pair of methods
1068       ++oi;
1069       ++ni;
1070       break;
1071     case added:
1072       // method added, see if it is OK
<span class="line-modified">1073       if (!can_add_or_delete(k_new_method)) {</span>





1074         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1075       }
1076       {
1077         u2 num = the_class-&gt;next_method_idnum();
1078         if (num == ConstMethod::UNSET_IDNUM) {
1079           // cannot add any more methods
1080           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1081         }
1082         u2 new_num = k_new_method-&gt;method_idnum();
1083         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1084         if (idnum_owner != NULL) {
1085           // There is already a method assigned this idnum -- switch them
1086           // Take current and original idnum from the new_method
1087           idnum_owner-&gt;set_method_idnum(new_num);
1088           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1089         }
1090         k_new_method-&gt;set_method_idnum(num);
1091         k_new_method-&gt;set_orig_method_idnum(num);
1092         if (thread-&gt;has_pending_exception()) {
1093           return JVMTI_ERROR_OUT_OF_MEMORY;
1094         }
1095       }
1096       log_trace(redefine, class, normalize)
1097         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1098       ++ni; // advance to next new method
1099       break;
1100     case deleted:
1101       // method deleted, see if it is OK
<span class="line-modified">1102       if (!can_add_or_delete(k_old_method)) {</span>





1103         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1104       }
1105       log_trace(redefine, class, normalize)
1106         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1107       ++oi; // advance to next old method
1108       break;
1109     default:
1110       ShouldNotReachHere();
1111     }
1112   }
1113 
1114   return JVMTI_ERROR_NONE;
1115 }
1116 
1117 
1118 // Find new constant pool index value for old constant pool index value
1119 // by seaching the index map. Returns zero (0) if there is no mapped
1120 // value for the old constant pool index.
1121 int VM_RedefineClasses::find_new_index(int old_index) {
1122   if (_index_map_count == 0) {
</pre>
<hr />
<pre>
1680   _index_map_count = 0;
1681   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1682 
1683   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1684   _operands_index_map_count = 0;
1685   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1686   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1687 
1688   // reference to the cp holder is needed for copy_operands()
1689   merge_cp-&gt;set_pool_holder(scratch_class);
1690   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1691                   &amp;merge_cp_length, THREAD);
1692   merge_cp-&gt;set_pool_holder(NULL);
1693 
1694   if (!result) {
1695     // The merge can fail due to memory allocation failure or due
1696     // to robustness checks.
1697     return JVMTI_ERROR_INTERNAL;
1698   }
1699 
<span class="line-added">1700   if (old_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-added">1701     merge_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">1702     scratch_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">1703   }</span>
<span class="line-added">1704 </span>
1705   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1706 
1707   if (_index_map_count == 0) {
1708     // there is nothing to map between the new and merged constant pools
1709 
1710     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1711       // The old and new constant pools are the same length and the
1712       // index map is empty. This means that the three constant pools
1713       // are equivalent (but not the same). Unfortunately, the new
1714       // constant pool has not gone through link resolution nor have
1715       // the new class bytecodes gone through constant pool cache
1716       // rewriting so we can&#39;t use the old constant pool with the new
1717       // class.
1718 
1719       // toss the merged constant pool at return
1720     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1721       // The old constant pool has fewer entries than the new constant
1722       // pool and the index map is empty. This means the new constant
1723       // pool is a superset of the old constant pool. However, the old
1724       // class bytecodes have already gone through constant pool cache
</pre>
<hr />
<pre>
1768                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1769     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1770     // It can&#39;t be cleaned up while there are handles to it.
1771     cp_cleaner.add_scratch_cp(scratch_cp());
1772   }
1773 
1774   return JVMTI_ERROR_NONE;
1775 } // end merge_cp_and_rewrite()
1776 
1777 
1778 // Rewrite constant pool references in klass scratch_class.
1779 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1780        TRAPS) {
1781 
1782   // rewrite constant pool references in the nest attributes:
1783   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1784     // propagate failure back to caller
1785     return false;
1786   }
1787 
<span class="line-added">1788   // rewrite constant pool references in the Record attribute:</span>
<span class="line-added">1789   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {</span>
<span class="line-added">1790     // propagate failure back to caller</span>
<span class="line-added">1791     return false;</span>
<span class="line-added">1792   }</span>
<span class="line-added">1793 </span>
1794   // rewrite constant pool references in the methods:
1795   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1796     // propagate failure back to caller
1797     return false;
1798   }
1799 
1800   // rewrite constant pool references in the class_annotations:
1801   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1802     // propagate failure back to caller
1803     return false;
1804   }
1805 
1806   // rewrite constant pool references in the fields_annotations:
1807   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1808     // propagate failure back to caller
1809     return false;
1810   }
1811 
1812   // rewrite constant pool references in the methods_annotations:
1813   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
</pre>
<hr />
<pre>
1872 
1873   return true;
1874 } // end rewrite_cp_refs()
1875 
1876 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1877 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1878        InstanceKlass* scratch_class) {
1879 
1880   u2 cp_index = scratch_class-&gt;nest_host_index();
1881   if (cp_index != 0) {
1882     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1883   }
1884   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1885   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1886     u2 cp_index = nest_members-&gt;at(i);
1887     nest_members-&gt;at_put(i, find_new_index(cp_index));
1888   }
1889   return true;
1890 }
1891 
<span class="line-added">1892 // Rewrite constant pool references in the Record attribute.</span>
<span class="line-added">1893 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(</span>
<span class="line-added">1894        InstanceKlass* scratch_class, TRAPS) {</span>
<span class="line-added">1895   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();</span>
<span class="line-added">1896   if (components != NULL) {</span>
<span class="line-added">1897     for (int i = 0; i &lt; components-&gt;length(); i++) {</span>
<span class="line-added">1898       RecordComponent* component = components-&gt;at(i);</span>
<span class="line-added">1899       u2 cp_index = component-&gt;name_index();</span>
<span class="line-added">1900       component-&gt;set_name_index(find_new_index(cp_index));</span>
<span class="line-added">1901       cp_index = component-&gt;descriptor_index();</span>
<span class="line-added">1902       component-&gt;set_descriptor_index(find_new_index(cp_index));</span>
<span class="line-added">1903       cp_index = component-&gt;generic_signature_index();</span>
<span class="line-added">1904       if (cp_index != 0) {</span>
<span class="line-added">1905         component-&gt;set_generic_signature_index(find_new_index(cp_index));</span>
<span class="line-added">1906       }</span>
<span class="line-added">1907 </span>
<span class="line-added">1908       AnnotationArray* annotations = component-&gt;annotations();</span>
<span class="line-added">1909       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {</span>
<span class="line-added">1910         int byte_i = 0;  // byte index into annotations</span>
<span class="line-added">1911         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {</span>
<span class="line-added">1912           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);</span>
<span class="line-added">1913           // propagate failure back to caller</span>
<span class="line-added">1914           return false;</span>
<span class="line-added">1915         }</span>
<span class="line-added">1916       }</span>
<span class="line-added">1917 </span>
<span class="line-added">1918       AnnotationArray* type_annotations = component-&gt;type_annotations();</span>
<span class="line-added">1919       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {</span>
<span class="line-added">1920         int byte_i = 0;  // byte index into annotations</span>
<span class="line-added">1921         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {</span>
<span class="line-added">1922           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);</span>
<span class="line-added">1923           // propagate failure back to caller</span>
<span class="line-added">1924           return false;</span>
<span class="line-added">1925         }</span>
<span class="line-added">1926       }</span>
<span class="line-added">1927     }</span>
<span class="line-added">1928   }</span>
<span class="line-added">1929   return true;</span>
<span class="line-added">1930 }</span>
<span class="line-added">1931 </span>
1932 // Rewrite constant pool references in the methods.
1933 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1934        InstanceKlass* scratch_class, TRAPS) {
1935 
1936   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1937 
1938   if (methods == NULL || methods-&gt;length() == 0) {
1939     // no methods so nothing to do
1940     return true;
1941   }
1942 
1943   // rewrite constant pool references in the methods:
1944   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1945     methodHandle method(THREAD, methods-&gt;at(i));
1946     methodHandle new_method;
1947     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1948     if (!new_method.is_null()) {
1949       // the method has been replaced so save the new method version
1950       // even in the case of an exception.  original method is on the
1951       // deallocation list.
</pre>
<hr />
<pre>
2269 //       element_value values[num_values];
2270 //     } array_value;
2271 //   } value;
2272 // }
2273 //
2274 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2275        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2276 
2277   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2278     // not enough room for a tag let alone the rest of an element_value
2279     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2280     return false;
2281   }
2282 
2283   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2284   byte_i_ref++;
2285   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2286 
2287   switch (tag) {
2288     // These BaseType tag values are from Table 4.2 in VM spec:
<span class="line-modified">2289     case JVM_SIGNATURE_BYTE:</span>
<span class="line-modified">2290     case JVM_SIGNATURE_CHAR:</span>
<span class="line-modified">2291     case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-modified">2292     case JVM_SIGNATURE_FLOAT:</span>
<span class="line-modified">2293     case JVM_SIGNATURE_INT:</span>
<span class="line-modified">2294     case JVM_SIGNATURE_LONG:</span>
<span class="line-modified">2295     case JVM_SIGNATURE_SHORT:</span>
<span class="line-modified">2296     case JVM_SIGNATURE_BOOLEAN:</span>
2297 
2298     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2299     // the VM spec:
2300     case &#39;s&#39;:
2301     {
2302       // For the above tag values (including the BaseType values),
2303       // value.const_value_index is right union field.
2304 
2305       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2306         // not enough room for a const_value_index
2307         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2308         return false;
2309       }
2310 
2311       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2312                                annotations_typeArray, byte_i_ref,
2313                                &quot;const_value_index&quot;, THREAD);
2314 
2315       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2316     } break;
</pre>
<hr />
<pre>
2347         return false;
2348       }
2349 
2350       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2351                               annotations_typeArray, byte_i_ref,
2352                               &quot;class_info_index&quot;, THREAD);
2353 
2354       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2355     } break;
2356 
2357     case &#39;@&#39;:
2358       // For the above tag value, value.attr_value is the right union
2359       // field. This is a nested annotation.
2360       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2361              byte_i_ref, THREAD)) {
2362         // propagate failure back to caller
2363         return false;
2364       }
2365       break;
2366 
<span class="line-modified">2367     case JVM_SIGNATURE_ARRAY:</span>
2368     {
2369       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2370         // not enough room for a num_values field
2371         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2372         return false;
2373       }
2374 
2375       // For the above tag value, value.array_value is the right union
2376       // field. This is an array of nested element_value.
2377       u2 num_values = Bytes::get_Java_u2((address)
2378                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2379       byte_i_ref += 2;
2380       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2381 
2382       int calc_num_values = 0;
2383       for (; calc_num_values &lt; num_values; calc_num_values++) {
2384         if (!rewrite_cp_refs_in_element_value(
2385                annotations_typeArray, byte_i_ref, THREAD)) {
2386           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2387           // propagate failure back to caller
</pre>
<hr />
<pre>
3354        ClassLoaderData* loader_data,
3355        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3356        int scratch_cp_length, TRAPS) {
3357   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3358 
3359   // scratch_cp is a merged constant pool and has enough space for a
3360   // worst case merge situation. We want to associate the minimum
3361   // sized constant pool with the klass to save space.
3362   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3363   constantPoolHandle smaller_cp(THREAD, cp);
3364 
3365   // preserve version() value in the smaller copy
3366   int version = scratch_cp-&gt;version();
3367   assert(version != 0, &quot;sanity check&quot;);
3368   smaller_cp-&gt;set_version(version);
3369 
3370   // attach klass to new constant pool
3371   // reference to the cp holder is needed for copy_operands()
3372   smaller_cp-&gt;set_pool_holder(scratch_class);
3373 
<span class="line-added">3374   if (scratch_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-added">3375     smaller_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">3376   }</span>
<span class="line-added">3377 </span>
3378   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3379   if (HAS_PENDING_EXCEPTION) {
3380     // Exception is handled in the caller
3381     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3382     return;
3383   }
3384   scratch_cp = smaller_cp;
3385 
3386   // attach new constant pool to klass
3387   scratch_class-&gt;set_constants(scratch_cp());
3388   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3389 
3390   int i;  // for portability
3391 
3392   // update each field in klass to use new constant pool indices as needed
3393   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3394     jshort cur_index = fs.name_index();
3395     jshort new_index = find_new_index(cur_index);
3396     if (new_index != 0) {
3397       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
</pre>
<hr />
<pre>
3595       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3596     }
3597 
3598     if (ik-&gt;itable_length() &gt; 0) {
3599       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3600     }
3601 
3602     // The constant pools in other classes (other_cp) can refer to
3603     // old methods.  We have to update method information in
3604     // other_cp&#39;s cache. If other_cp has a previous version, then we
3605     // have to repeat the process for each previous version. The
3606     // constant pool cache holds the Method*s for non-virtual
3607     // methods and for virtual, final methods.
3608     //
3609     // Special case: if the current class being redefined, then new_cp
3610     // has already been attached to the_class and old_cp has already
3611     // been added as a previous version. The new_cp doesn&#39;t have any
3612     // cached references to old methods so it doesn&#39;t need to be
3613     // updated. We can simply start with the previous version(s) in
3614     // that case.

3615     ConstantPoolCache* cp_cache;
3616 
3617     if (!ik-&gt;is_being_redefined()) {
3618       // this klass&#39; constant pool cache may need adjustment
<span class="line-modified">3619       ConstantPool* other_cp = ik-&gt;constants();</span>
3620       cp_cache = other_cp-&gt;cache();
3621       if (cp_cache != NULL) {
3622         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3623       }
3624     }
3625 
3626     // the previous versions&#39; constant pool caches may need adjustment
3627     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3628          pv_node != NULL;
3629          pv_node = pv_node-&gt;previous_versions()) {
3630       cp_cache = pv_node-&gt;constants()-&gt;cache();
3631       if (cp_cache != NULL) {
3632         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3633       }
3634     }
3635   }
3636 }
3637 
<span class="line-modified">3638 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {</span>
3639   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3640     Method* old_method = _matching_old_methods[j];
3641     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3642     if (jmid != NULL) {
3643       // There is a jmethodID, change it to point to the new method
<span class="line-modified">3644       methodHandle new_method_h(thread, _matching_new_methods[j]);</span>
3645       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3646       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3647              &quot;should be replaced&quot;);
3648     }
3649   }









3650 }
3651 
3652 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3653   int emcp_method_count = 0;
3654   int obsolete_count = 0;
3655   int old_index = 0;
3656   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3657     Method* old_method = _matching_old_methods[j];
3658     Method* new_method = _matching_new_methods[j];
3659     Method* old_array_method;
3660 
3661     // Maintain an old_index into the _old_methods array by skipping
3662     // deleted methods
3663     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3664       ++old_index;
3665     }
3666 
3667     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3668       // The EMCP definition from JSR-163 requires the bytecodes to be
3669       // the same with the exception of constant pool indices which may
</pre>
<hr />
<pre>
3938 // First step is to walk the code cache for each class redefined and mark
3939 // dependent methods.  Wait until all classes are processed to deoptimize everything.
3940 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
3941   assert_locked_or_safepoint(Compile_lock);
3942 
3943   // All dependencies have been recorded from startup or this is a second or
3944   // subsequent use of RedefineClasses
3945   if (JvmtiExport::all_dependencies_are_recorded()) {
3946     CodeCache::mark_for_evol_deoptimization(ik);
3947   }
3948 }
3949 
3950 void VM_RedefineClasses::flush_dependent_code() {
3951   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3952 
3953   bool deopt_needed;
3954 
3955   // This is the first redefinition, mark all the nmethods for deoptimization
3956   if (!JvmtiExport::all_dependencies_are_recorded()) {
3957     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
<span class="line-modified">3958     CodeCache::mark_all_nmethods_for_evol_deoptimization();</span>
3959     deopt_needed = true;
3960   } else {
3961     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
3962     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
3963     deopt_needed = (deopt != 0);
3964   }
3965 
3966   if (deopt_needed) {
3967     CodeCache::flush_evol_dependents();
3968   }
3969 
3970   // From now on we know that the dependency information is complete
3971   JvmtiExport::set_all_dependencies_are_recorded(true);
3972 }
3973 
3974 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
3975   Method* old_method;
3976   Method* new_method;
3977 
3978   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
</pre>
<hr />
<pre>
4063     _timer_rsc_phase1.start();
4064   }
4065 
4066   InstanceKlass* the_class = get_ik(the_jclass);
4067 
4068   // Set some flags to control and optimize adjusting method entries
4069   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4070   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
4071 
4072   // Remove all breakpoints in methods of this class
4073   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4074   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4075 
4076   // Mark all compiled code that depends on this class
4077   mark_dependent_code(the_class);
4078 
4079   _old_methods = the_class-&gt;methods();
4080   _new_methods = scratch_class-&gt;methods();
4081   _the_class = the_class;
4082   compute_added_deleted_matching_methods();
<span class="line-modified">4083   update_jmethod_ids(THREAD);</span>
4084 
4085   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4086 
4087   // Attach new constant pool to the original klass. The original
4088   // klass still refers to the old constant pool (for now).
4089   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4090 
4091 #if 0
4092   // In theory, with constant pool merging in place we should be able
4093   // to save space by using the new, merged constant pool in place of
4094   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4095   // the klass version we are replacing now and any constant pool(s) in
4096   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4097   // When this code is enabled, even simple programs throw NullPointer
4098   // exceptions. I&#39;m guessing that this is caused by some constant pool
4099   // cache difference between the new, merged constant pool and the
4100   // constant pool that was just being used by the klass. I&#39;m keeping
4101   // this code around to archive the idea, but the code has to remain
4102   // disabled for now.
4103 
</pre>
<hr />
<pre>
4280     // Class was already initialized, so AOT has only seen the original version.
4281     // We need to let AOT look at it again.
4282     AOTLoader::load_for_klass(the_class, THREAD);
4283   }
4284 
4285   // keep track of previous versions of this class
4286   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4287 
4288   _timer_rsc_phase1.stop();
4289   if (log_is_enabled(Info, redefine, class, timer)) {
4290     _timer_rsc_phase2.start();
4291   }
4292 
4293   if (the_class-&gt;oop_map_cache() != NULL) {
4294     // Flush references to any obsolete methods from the oop map cache
4295     // so that obsolete methods are not pinned.
4296     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4297   }
4298 
4299   increment_class_counter((InstanceKlass *)the_class, THREAD);
<span class="line-added">4300 </span>
<span class="line-added">4301   if (EventClassRedefinition::is_enabled()) {</span>
<span class="line-added">4302     EventClassRedefinition event;</span>
<span class="line-added">4303     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));</span>
<span class="line-added">4304     event.set_redefinedClass(the_class);</span>
<span class="line-added">4305     event.set_redefinitionId(_id);</span>
<span class="line-added">4306     event.commit();</span>
<span class="line-added">4307   }</span>
<span class="line-added">4308 </span>
4309   {
4310     ResourceMark rm(THREAD);
4311     // increment the classRedefinedCount field in the_class and in any
4312     // direct and indirect subclasses of the_class
4313     log_info(redefine, class, load)
4314       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4315        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4316     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4317                              the_class-&gt;external_name(),
4318                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4319 
4320   }
4321   _timer_rsc_phase2.stop();
<span class="line-added">4322 </span>
4323 } // end redefine_single_class()
4324 
4325 
4326 // Increment the classRedefinedCount field in the specific InstanceKlass
4327 // and in all direct and indirect subclasses.
4328 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4329   oop class_mirror = ik-&gt;java_mirror();
4330   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4331   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4332   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4333 
4334   if (class_oop != _the_class) {
4335     // _the_class count is printed at end of redefine_single_class()
4336     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4337   }
4338 
4339   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4340        subk = subk-&gt;next_sibling()) {
4341     if (subk-&gt;is_instance_klass()) {
4342       // Only update instanceKlasses
</pre>
<hr />
<pre>
4389           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4390            ik-&gt;signature_name());
4391         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4392       }
4393       no_old_methods = false;
4394     }
4395   }
4396 
4397   // print and fail guarantee if old methods are found.
4398   if (!no_old_methods) {
4399     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4400       dump_methods();
4401     } else {
4402       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4403         &quot;to see more info about the following guarantee() failure.&quot;);
4404     }
4405     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4406   }
4407 }
4408 
<span class="line-added">4409 u8 VM_RedefineClasses::next_id() {</span>
<span class="line-added">4410   while (true) {</span>
<span class="line-added">4411     u8 id = _id_counter;</span>
<span class="line-added">4412     u8 next_id = id + 1;</span>
<span class="line-added">4413     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);</span>
<span class="line-added">4414     if (result == id) {</span>
<span class="line-added">4415       return next_id;</span>
<span class="line-added">4416     }</span>
<span class="line-added">4417   }</span>
<span class="line-added">4418 }</span>
4419 
4420 void VM_RedefineClasses::dump_methods() {
4421   int j;
4422   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4423   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4424     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4425     Method* m = _old_methods-&gt;at(j);
4426     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4427     m-&gt;access_flags().print_on(&amp;log_stream);
4428     log_stream.print(&quot; --  &quot;);
4429     m-&gt;print_name(&amp;log_stream);
4430     log_stream.cr();
4431   }
4432   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4433   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4434     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4435     Method* m = _new_methods-&gt;at(j);
4436     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4437     m-&gt;access_flags().print_on(&amp;log_stream);
4438     log_stream.print(&quot; --  &quot;);
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiRawMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
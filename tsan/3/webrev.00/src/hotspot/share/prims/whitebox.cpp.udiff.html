<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="wbtestmethods/parserTests.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,35 +28,40 @@</span>
  
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/protectionDomainCache.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
<span class="udiff-line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/methodMatcher.hpp&quot;
  #include &quot;compiler/directivesParser.hpp&quot;
  #include &quot;gc/shared/gcConfig.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
  #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/filemap.hpp&quot;</span>
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;oops/array.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
  #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  #include &quot;prims/whitebox.inline.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -77,10 +82,11 @@</span>
  #include &quot;utilities/macros.hpp&quot;
  #if INCLUDE_CDS
  #include &quot;prims/cdsoffsets.hpp&quot;
  #endif // INCLUDE_CDS
  #if INCLUDE_G1GC
<span class="udiff-line-added">+ #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,43 +159,43 @@</span>
    return os::large_page_size();
  WB_END
  
  class WBIsKlassAliveClosure : public LockedClassesDo {
      Symbol* _name;
<span class="udiff-line-modified-removed">-     bool _found;</span>
<span class="udiff-line-modified-added">+     int _count;</span>
  public:
<span class="udiff-line-modified-removed">-     WBIsKlassAliveClosure(Symbol* name) : _name(name), _found(false) {}</span>
<span class="udiff-line-modified-added">+     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}</span>
  
      void do_klass(Klass* k) {
<span class="udiff-line-removed">-       if (_found) return;</span>
        Symbol* ksym = k-&gt;name();
        if (ksym-&gt;fast_compare(_name) == 0) {
<span class="udiff-line-modified-removed">-         _found = true;</span>
<span class="udiff-line-modified-added">+         _count++;</span>
        }
      }
  
<span class="udiff-line-modified-removed">-     bool found() const {</span>
<span class="udiff-line-modified-removed">-         return _found;</span>
<span class="udiff-line-modified-added">+     int count() const {</span>
<span class="udiff-line-modified-added">+         return _count;</span>
      }
  };
  
<span class="udiff-line-modified-removed">- WB_ENTRY(jboolean, WB_IsClassAlive(JNIEnv* env, jobject target, jstring name))</span>
<span class="udiff-line-modified-added">+ WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))</span>
    oop h_name = JNIHandles::resolve(name);
    if (h_name == NULL) return false;
<span class="udiff-line-modified-removed">-   Symbol* sym = java_lang_String::as_symbol(h_name, CHECK_false);</span>
<span class="udiff-line-modified-added">+   Symbol* sym = java_lang_String::as_symbol(h_name);</span>
    TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
  
    WBIsKlassAliveClosure closure(sym);
    ClassLoaderDataGraph::classes_do(&amp;closure);
  
<span class="udiff-line-modified-removed">-   return closure.found();</span>
<span class="udiff-line-modified-added">+   // Return the count of alive classes with this name.</span>
<span class="udiff-line-added">+   return closure.count();</span>
  WB_END
  
  WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
    oop h_name = JNIHandles::resolve(name);
    if (h_name == NULL) return false;
<span class="udiff-line-modified-removed">-   Symbol* sym = java_lang_String::as_symbol(h_name, CHECK_0);</span>
<span class="udiff-line-modified-added">+   Symbol* sym = java_lang_String::as_symbol(h_name);</span>
    TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
    return (jint)sym-&gt;refcount();
  WB_END
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,32 +226,32 @@</span>
    return (jlong)Arguments::max_heap_for_compressed_oops();
  }
  WB_END
  
  WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
<span class="udiff-line-modified-removed">-   CollectorPolicy * p = Universe::heap()-&gt;collector_policy();</span>
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot;</span>
<span class="udiff-line-modified-removed">-     SIZE_FORMAT &quot; Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,</span>
<span class="udiff-line-modified-removed">-     p-&gt;min_heap_byte_size(), p-&gt;initial_heap_byte_size(), p-&gt;max_heap_byte_size(),</span>
<span class="udiff-line-modified-removed">-     p-&gt;space_alignment(), p-&gt;heap_alignment());</span>
<span class="udiff-line-modified-added">+   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;</span>
<span class="udiff-line-modified-added">+                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,</span>
<span class="udiff-line-modified-added">+                 MinHeapSize,</span>
<span class="udiff-line-modified-added">+                 InitialHeapSize,</span>
<span class="udiff-line-modified-added">+                 MaxHeapSize,</span>
<span class="udiff-line-added">+                 SpaceAlignment,</span>
<span class="udiff-line-added">+                 HeapAlignment);</span>
  }
  WB_END
  
  #ifndef PRODUCT
  // Forward declaration
  void TestReservedSpace_test();
  void TestReserveMemorySpecial_test();
  void TestVirtualSpace_test();
<span class="udiff-line-removed">- void TestMetaspaceUtils_test();</span>
  #endif
  
  WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
  #ifndef PRODUCT
    TestReservedSpace_test();
    TestReserveMemorySpecial_test();
    TestVirtualSpace_test();
<span class="udiff-line-removed">-   TestMetaspaceUtils_test();</span>
  #endif
  WB_END
  
  WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
    size_t granularity = os::vm_allocation_granularity();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -253,21 +259,21 @@</span>
    VirtualSpace vs;
    vs.initialize(rhs, 50 * granularity);
  
    // Check if constraints are complied
    if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-          Universe::narrow_oop_base() != NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-          Universe::narrow_oop_use_implicit_null_checks() )) {</span>
<span class="udiff-line-modified-added">+          CompressedOops::base() != NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+          CompressedOops::use_implicit_null_checks() )) {</span>
      tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
                    &quot;\tUseCompressedOops is %d\n&quot;
                    &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
<span class="udiff-line-modified-removed">-                   &quot;\tUniverse::narrow_oop_base() is &quot; PTR_FORMAT &quot;\n&quot;</span>
<span class="udiff-line-modified-removed">-                   &quot;\tUniverse::narrow_oop_use_implicit_null_checks() is %d&quot;,</span>
<span class="udiff-line-modified-added">+                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;</span>
<span class="udiff-line-modified-added">+                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,</span>
                    UseCompressedOops,
                    p2i(rhs.base()),
<span class="udiff-line-modified-removed">-                   p2i(Universe::narrow_oop_base()),</span>
<span class="udiff-line-modified-removed">-                   Universe::narrow_oop_use_implicit_null_checks());</span>
<span class="udiff-line-modified-added">+                   p2i(CompressedOops::base()),</span>
<span class="udiff-line-modified-added">+                   CompressedOops::use_implicit_null_checks());</span>
      return;
    }
    tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
    tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
                  *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,17 +385,15 @@</span>
    oop p = JNIHandles::resolve(obj);
    return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
  WB_END
  
  WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
<span class="udiff-line-modified-removed">-   size_t alignment = Universe::heap()-&gt;collector_policy()-&gt;space_alignment();</span>
<span class="udiff-line-removed">-   return (jlong)alignment;</span>
<span class="udiff-line-modified-added">+   return (jlong)SpaceAlignment;</span>
  WB_END
  
  WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
<span class="udiff-line-modified-removed">-   size_t alignment = Universe::heap()-&gt;collector_policy()-&gt;heap_alignment();</span>
<span class="udiff-line-removed">-   return (jlong)alignment;</span>
<span class="udiff-line-modified-added">+   return (jlong)HeapAlignment;</span>
  WB_END
  
  WB_ENTRY(jboolean, WB_SupportsConcurrentGCPhaseControl(JNIEnv* env, jobject o))
    return Universe::heap()-&gt;supports_concurrent_phase_control();
  WB_END
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -511,11 +515,11 @@</span>
      G1CollectedHeap* g1h = G1CollectedHeap::heap();
      if (g1h-&gt;is_heterogeneous_heap()) {
        uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
        return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
      } else {
<span class="udiff-line-modified-removed">-       return (jlong)g1h-&gt;base() + g1h-&gt;collector_policy()-&gt;max_heap_byte_size();</span>
<span class="udiff-line-modified-added">+       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();</span>
      }
    }
  #endif // INCLUDE_G1GC
  #if INCLUDE_PARALLELGC
    if (UseParallelGC) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,11 +598,11 @@</span>
    THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
  WB_END
  
  WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
    if (UseParallelGC) {
<span class="udiff-line-modified-removed">-     return ParallelScavengeHeap::heap()-&gt;generation_alignment();</span>
<span class="udiff-line-modified-added">+     return GenAlignment;</span>
    }
    THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
  WB_END
  
  #endif // INCLUDE_PARALLELGC
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -614,10 +618,33 @@</span>
      return JNIHandles::make_local(env, h());
    }
    THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))</span>
<span class="udiff-line-added">+   if (UseG1GC) {</span>
<span class="udiff-line-added">+     G1NUMA* numa = G1NUMA::numa();</span>
<span class="udiff-line-added">+     return (jint)numa-&gt;num_active_nodes();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))</span>
<span class="udiff-line-added">+   if (UseG1GC) {</span>
<span class="udiff-line-added">+     G1NUMA* numa = G1NUMA::numa();</span>
<span class="udiff-line-added">+     int num_node_ids = (int)numa-&gt;num_active_nodes();</span>
<span class="udiff-line-added">+     const int* node_ids = numa-&gt;node_ids();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; num_node_ids; i++) {</span>
<span class="udiff-line-added">+       result-&gt;int_at_put(i, (jint)node_ids[i]);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return (jintArray) JNIHandles::make_local(env, result);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  class OldRegionsLivenessClosure: public HeapRegionClosure {
  
   private:
    const int _liveness;
    size_t _total_count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -769,10 +796,25 @@</span>
  WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
    int hash_size = MallocSiteTable::hash_buckets();
    assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
    return (jint)hash_size;
  WB_END
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))</span>
<span class="udiff-line-added">+   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));</span>
<span class="udiff-line-added">+   return (jlong)arena;</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))</span>
<span class="udiff-line-added">+   Arena* a = (Arena*)arena;</span>
<span class="udiff-line-added">+   delete a;</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))</span>
<span class="udiff-line-added">+   Arena* a = (Arena*)arena;</span>
<span class="udiff-line-added">+   a-&gt;Amalloc(size_t(size));</span>
<span class="udiff-line-added">+ WB_END</span>
  #endif // INCLUDE_NMT
  
  static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
    assert(method != NULL, &quot;method should not be null&quot;);
    ThreadToNativeFromVM ttn(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -790,15 +832,14 @@</span>
    int  result() const { return _result; }
  
    void doit() {
      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
        if (t-&gt;has_last_Java_frame()) {
<span class="udiff-line-modified-removed">-         for (StackFrameStream fst(t, UseBiasedLocking); !fst.is_done(); fst.next()) {</span>
<span class="udiff-line-modified-added">+         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {</span>
            frame* f = fst.current();
            if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
<span class="udiff-line-modified-removed">-             RegisterMap* reg_map = fst.register_map();</span>
<span class="udiff-line-removed">-             Deoptimization::deoptimize(t, *f, reg_map);</span>
<span class="udiff-line-modified-added">+             Deoptimization::deoptimize(t, *f);</span>
              if (_make_not_entrant) {
                  CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
                  assert(cm != NULL, &quot;sanity check&quot;);
                  cm-&gt;make_not_entrant();
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -815,40 +856,37 @@</span>
    VMThread::execute(&amp;op);
    return op.result();
  WB_END
  
  WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
<span class="udiff-line-removed">-   MutexLockerEx mu(Compile_lock);</span>
    CodeCache::mark_all_nmethods_for_deoptimization();
<span class="udiff-line-modified-removed">-   VM_Deoptimize op;</span>
<span class="udiff-line-removed">-   VMThread::execute(&amp;op);</span>
<span class="udiff-line-modified-added">+   Deoptimization::deoptimize_all_marked();</span>
  WB_END
  
  WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    int result = 0;
    CHECK_JNI_EXCEPTION_(env, result);
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(Compile_lock);</span>
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
    if (is_osr) {
      result += mh-&gt;mark_osr_nmethods();
    } else if (mh-&gt;code() != NULL) {
      mh-&gt;code()-&gt;mark_for_deoptimization();
      ++result;
    }
    result += CodeCache::mark_for_deoptimization(mh());
    if (result &gt; 0) {
<span class="udiff-line-modified-removed">-     VM_Deoptimize op;</span>
<span class="udiff-line-removed">-     VMThread::execute(&amp;op);</span>
<span class="udiff-line-modified-added">+     Deoptimization::deoptimize_all_marked();</span>
    }
    return result;
  WB_END
  
  WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(Compile_lock);</span>
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
    CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
    if (code == NULL) {
      return JNI_FALSE;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -859,11 +897,11 @@</span>
    if (method == NULL || comp_level &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {
      return false;
    }
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(Compile_lock);</span>
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
    if (is_osr) {
      return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
    } else {
      return CompilationPolicy::can_be_compiled(mh, comp_level);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -871,11 +909,11 @@</span>
  WB_END
  
  WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(Compile_lock);</span>
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
    return mh-&gt;queued_for_compilation();
  WB_END
  
  WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -915,13 +953,13 @@</span>
  WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION(env);
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
    if (is_osr) {
<span class="udiff-line-modified-removed">-     mh-&gt;set_not_osr_compilable(comp_level, true /* report */, &quot;WhiteBox&quot;);</span>
<span class="udiff-line-modified-added">+     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);</span>
    } else {
<span class="udiff-line-modified-removed">-     mh-&gt;set_not_compilable(comp_level, true /* report */, &quot;WhiteBox&quot;);</span>
<span class="udiff-line-modified-added">+     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);</span>
    }
  WB_END
  
  WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -980,11 +1018,11 @@</span>
    bool is_blocking = !directive-&gt;BackgroundCompilationOption;
    DirectivesStack::release(directive);
  
    // Compile method and check result
    nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(THREAD, Compile_lock);</span>
    bool is_queued = mh-&gt;queued_for_compilation();
    if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
      return true;
    }
    tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,11 +1065,11 @@</span>
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
  
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
  
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
    const char* error_msg = NULL;
    char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
    InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
  
    if (m == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1076,26 +1114,44 @@</span>
    delete m;
    assert(result == 0 || result == 1, &quot;Result out of range&quot;);
    return result;
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))</span>
<span class="udiff-line-added">+   jmethodID jmid = reflected_method_to_jmid(thread, env, method);</span>
<span class="udiff-line-added">+   CHECK_JNI_EXCEPTION(env);</span>
<span class="udiff-line-added">+   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   MethodData* mdo = mh-&gt;method_data();</span>
<span class="udiff-line-added">+   if (mdo == NULL) {</span>
<span class="udiff-line-added">+     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);</span>
<span class="udiff-line-added">+     mdo = mh-&gt;method_data();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   mdo-&gt;init();</span>
<span class="udiff-line-added">+   InvocationCounter* icnt = mdo-&gt;invocation_counter();</span>
<span class="udiff-line-added">+   InvocationCounter* bcnt = mdo-&gt;backedge_counter();</span>
<span class="udiff-line-added">+   // set i-counter according to TieredThresholdPolicy::is_method_profiled</span>
<span class="udiff-line-added">+   icnt-&gt;set(Tier4MinInvocationThreshold);</span>
<span class="udiff-line-added">+   bcnt-&gt;set(Tier4CompileThreshold);</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
    jmethodID jmid = reflected_method_to_jmid(thread, env, method);
    CHECK_JNI_EXCEPTION(env);
    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(Compile_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(THREAD, Compile_lock);</span>
    MethodData* mdo = mh-&gt;method_data();
    MethodCounters* mcs = mh-&gt;method_counters();
  
    if (mdo != NULL) {
      mdo-&gt;init();
<span class="udiff-line-modified-removed">-     ResourceMark rm;</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
      int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
      for (int i = 0; i &lt; arg_count; i++) {
        mdo-&gt;set_arg_modified(i, 0);
      }
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(mdo-&gt;extra_data_lock());</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());</span>
      mdo-&gt;clean_method_data(/*always_clean*/true);
    }
  
    mh-&gt;clear_not_c1_compilable();
    mh-&gt;clear_not_c2_compilable();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1114,31 +1170,33 @@</span>
  #endif
    }
  WB_END
  
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const char*, T*, bool, bool)) {</span>
<span class="udiff-line-modified-added">+ static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {</span>
    if (name == NULL) {
      return false;
    }
    ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
    const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
    CHECK_JNI_EXCEPTION_(env, false);
<span class="udiff-line-modified-removed">-   JVMFlag::Error result = (*TAt)(flag_name, value, true, true);</span>
<span class="udiff-line-modified-added">+   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);</span>
<span class="udiff-line-added">+   JVMFlag::Error result = (*TAt)(flag, value);</span>
    env-&gt;ReleaseStringUTFChars(name, flag_name);
    return (result == JVMFlag::SUCCESS);
  }
  
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(const char*, T*, JVMFlag::Flags)) {</span>
<span class="udiff-line-modified-added">+ static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {</span>
    if (name == NULL) {
      return false;
    }
    ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
    const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
    CHECK_JNI_EXCEPTION_(env, false);
<span class="udiff-line-modified-removed">-   JVMFlag::Error result = (*TAtPut)(flag_name, value, JVMFlag::INTERNAL);</span>
<span class="udiff-line-modified-added">+   JVMFlag* flag = JVMFlag::find_flag(flag_name);</span>
<span class="udiff-line-added">+   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);</span>
    env-&gt;ReleaseStringUTFChars(name, flag_name);
    return (result == JVMFlag::SUCCESS);
  }
  
  template &lt;typename T&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1169,26 +1227,26 @@</span>
  }*/
  static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
    return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
  }
  
<span class="udiff-line-modified-removed">- static JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {</span>
<span class="udiff-line-modified-added">+ static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {</span>
    ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
    const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
    CHECK_JNI_EXCEPTION_(env, NULL);
<span class="udiff-line-modified-removed">-   JVMFlag* result = JVMFlag::find_flag(flag_name, strlen(flag_name), true, true);</span>
<span class="udiff-line-modified-added">+   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);</span>
    env-&gt;ReleaseStringUTFChars(name, flag_name);
    return result;
  }
  
  WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
<span class="udiff-line-modified-removed">-   JVMFlag* flag = getVMFlag(thread, env, name);</span>
<span class="udiff-line-modified-added">+   const JVMFlag* flag = getVMFlag(thread, env, name);</span>
    return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
  WB_END
  
  WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
<span class="udiff-line-modified-removed">-   JVMFlag* flag = getVMFlag(thread, env, name);</span>
<span class="udiff-line-modified-added">+   const JVMFlag* flag = getVMFlag(thread, env, name);</span>
    return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
  WB_END
  
  WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
    bool result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1340,11 +1398,11 @@</span>
  WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
    WhiteBox::compilation_locked = true;
  WB_END
  
  WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
<span class="udiff-line-modified-removed">-   MonitorLockerEx mo(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
    WhiteBox::compilation_locked = false;
    mo.notify_all();
  WB_END
  
  WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1500,11 +1558,11 @@</span>
    int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
    if (full_size &lt; size) {
      full_size += align_up(size - full_size, oopSize);
    }
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
      if (blob != NULL) {
        ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1530,11 +1588,11 @@</span>
  
  WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
    ResourceMark rm;
    GrowableArray&lt;CodeBlobStub*&gt; blobs;
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
      if (heap == NULL) {
        return NULL;
      }
      for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1704,29 +1762,42 @@</span>
  
  WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
    return (jlong) MetaspaceGC::capacity_until_GC();
  WB_END
  
<span class="udiff-line-removed">- WB_ENTRY(jboolean, WB_MetaspaceShouldConcurrentCollect(JNIEnv* env, jobject wb))</span>
<span class="udiff-line-removed">-   return MetaspaceGC::should_concurrent_collect();</span>
<span class="udiff-line-removed">- WB_END</span>
<span class="udiff-line-removed">- </span>
  WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
    return (jlong)Metaspace::reserve_alignment();
  WB_END
  
  WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
<span class="udiff-line-modified-removed">-   Monitor::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?</span>
<span class="udiff-line-modified-removed">-                                            Monitor::_safepoint_check_always :</span>
<span class="udiff-line-modified-removed">-                                            Monitor::_safepoint_check_never;</span>
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),</span>
<span class="udiff-line-modified-removed">-                    attemptedNoSafepointValue == JNI_TRUE);</span>
<span class="udiff-line-modified-added">+   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?</span>
<span class="udiff-line-modified-added">+                                            Mutex::_safepoint_check_always :</span>
<span class="udiff-line-modified-added">+                                            Mutex::_safepoint_check_never;</span>
<span class="udiff-line-modified-added">+   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?</span>
<span class="udiff-line-modified-added">+                                            Mutex::_no_safepoint_check_flag :</span>
<span class="udiff-line-added">+                                            Mutex::_safepoint_check_flag;</span>
<span class="udiff-line-added">+   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),</span>
<span class="udiff-line-added">+                  sfpt_check_attempted);</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))</span>
<span class="udiff-line-added">+   // Create a special lock violating condition in value</span>
<span class="udiff-line-added">+   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?</span>
<span class="udiff-line-added">+                                            Mutex::_safepoint_check_always :</span>
<span class="udiff-line-added">+                                            Mutex::_safepoint_check_never;</span>
<span class="udiff-line-added">+   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?</span>
<span class="udiff-line-added">+                                            Monitor::_safepoint_check_flag :</span>
<span class="udiff-line-added">+                                            Monitor::_no_safepoint_check_flag;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);</span>
<span class="udiff-line-added">+   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.</span>
<span class="udiff-line-added">+   ThreadBlockInVM tbivm(JavaThread::current());</span>
  WB_END
  
  WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
    oop obj_oop = JNIHandles::resolve(obj);
<span class="udiff-line-modified-removed">-   return (jboolean) obj_oop-&gt;mark()-&gt;has_monitor();</span>
<span class="udiff-line-modified-added">+   return (jboolean) obj_oop-&gt;mark().has_monitor();</span>
  WB_END
  
  WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
    VM_ForceSafepoint force_safepoint_op;
    VMThread::execute(&amp;force_safepoint_op);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1856,10 +1927,14 @@</span>
  
  WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
    return UseSharedSpaces;
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))</span>
<span class="udiff-line-added">+   return FileMapInfo::memory_mapping_failed();</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
    oop obj_oop = JNIHandles::resolve(obj);
    return HeapShared::is_archived_object(obj_oop);
  WB_END
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1881,10 +1956,19 @@</span>
    } else {
      return NULL;
    }
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))</span>
<span class="udiff-line-added">+   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="udiff-line-added">+   if (!k-&gt;is_instance_klass()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   InstanceKlass *ik = InstanceKlass::cast(k);</span>
<span class="udiff-line-added">+   ik-&gt;link_class(THREAD); // may throw verification error</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
    return HeapShared::open_archive_heap_region_mapped();
  WB_END
  
  WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1899,10 +1983,18 @@</span>
  #else
    return false;
  #endif // INCLUDE_CDS
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))</span>
<span class="udiff-line-added">+ #if COMPILER2_OR_JVMCI</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
    return HeapShared::is_heap_object_archiving_allowed();
  WB_END
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1924,11 +2016,11 @@</span>
  WB_END
  
  #endif // INCLUDE_CDS
  
  WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
<span class="udiff-line-modified-removed">-   class TraceSelfClosure : public ThreadClosure {</span>
<span class="udiff-line-modified-added">+   class TraceSelfClosure : public HandshakeClosure {</span>
      jint _num_threads_completed;
  
      void do_thread(Thread* th) {
        assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
        JavaThread* jt = (JavaThread*)th;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1939,11 +2031,11 @@</span>
        tty-&gt;cr();
        Atomic::inc(&amp;_num_threads_completed);
      }
  
    public:
<span class="udiff-line-modified-removed">-     TraceSelfClosure() : _num_threads_completed(0) {}</span>
<span class="udiff-line-modified-added">+     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}</span>
  
      jint num_threads_completed() const { return _num_threads_completed; }
    };
    TraceSelfClosure tsc;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1969,12 +2061,11 @@</span>
    Klass* arg_klass = object-&gt;klass();
    //Turn it into an instance-klass
    InstanceKlass* ik = InstanceKlass::cast(arg_klass);
  
    //Create symbols to look for in the class
<span class="udiff-line-modified-removed">-   TempNewSymbol name_symbol = SymbolTable::lookup(field_name, (int) strlen(field_name),</span>
<span class="udiff-line-removed">-       THREAD);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);</span>
  
    //To be filled in with an offset of the field we&#39;re looking for
    fieldDescriptor fd;
  
    Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2090,12 +2181,12 @@</span>
  #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
    ElfFile::_do_not_cache_elf_section = true;
  #endif
  WB_END
  
<span class="udiff-line-modified-removed">- WB_ENTRY(jint, WB_ResolvedMethodRemovedCount(JNIEnv* env, jobject o))</span>
<span class="udiff-line-modified-removed">-   return (jint) ResolvedMethodTable::removed_entries_count();</span>
<span class="udiff-line-modified-added">+ WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))</span>
<span class="udiff-line-modified-added">+   return (jlong) ResolvedMethodTable::items_count();</span>
  WB_END
  
  WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
    return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
  WB_END
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2106,10 +2197,16 @@</span>
    result = (jint) AOTLoader::heaps_count();
  #endif
    return result;
  WB_END
  
<span class="udiff-line-added">+ WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))</span>
<span class="udiff-line-added">+   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));</span>
<span class="udiff-line-added">+   // Return size in bytes.</span>
<span class="udiff-line-added">+   return k-&gt;size() * wordSize;</span>
<span class="udiff-line-added">+ WB_END</span>
<span class="udiff-line-added">+ </span>
  #define CC (char*)
  
  static JNINativeMethod methods[] = {
    {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
    {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2118,11 +2215,11 @@</span>
    {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
    {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
    {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
    {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
    {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
<span class="udiff-line-modified-removed">-   {CC&quot;isClassAlive0&quot;,                    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsClassAlive      },</span>
<span class="udiff-line-modified-added">+   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },</span>
    {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
    {CC&quot;parseCommandLine0&quot;,
        CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
        (void*) &amp;WB_ParseCommandLine
    },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2148,10 +2245,12 @@</span>
    {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
    {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
    {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
    {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
                                                        (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
<span class="udiff-line-added">+   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },</span>
<span class="udiff-line-added">+   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },</span>
    {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
  #endif // INCLUDE_G1GC
  #if INCLUDE_G1GC || INCLUDE_PARALLELGC
    {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
    {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2172,10 +2271,13 @@</span>
    {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
    {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
    {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
    {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
    {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
<span class="udiff-line-added">+   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },</span>
<span class="udiff-line-added">+   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },</span>
<span class="udiff-line-added">+   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },</span>
  #endif // INCLUDE_NMT
    {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
    {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
    {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
                                                        (void*)&amp;WB_DeoptimizeMethod  },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2202,10 +2304,12 @@</span>
        CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
    {CC&quot;enqueueMethodForCompilation0&quot;,
        CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
    {CC&quot;enqueueInitializerForCompilation0&quot;,
        CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
<span class="udiff-line-added">+   {CC&quot;markMethodProfiled&quot;,</span>
<span class="udiff-line-added">+       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},</span>
    {CC&quot;clearMethodState0&quot;,
        CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
    {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
    {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
    {CC&quot;matchesMethod&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2256,11 +2360,10 @@</span>
       CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
    {CC&quot;freeMetaspace&quot;,
       CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
    {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
    {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
<span class="udiff-line-removed">-   {CC&quot;metaspaceShouldConcurrentCollect&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_MetaspaceShouldConcurrentCollect },</span>
    {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
    {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
    {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
                                                        (void*)&amp;WB_GetNMethod         },
    {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2283,10 +2386,11 @@</span>
    {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
                                                        (void*)&amp;WB_AddModuleExportsToAllUnnamed },
    {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
                                                        (void*)&amp;WB_AddModuleExportsToAll },
    {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
<span class="udiff-line-added">+   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },</span>
    {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
    {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
    {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
    {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
    {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2314,14 +2418,17 @@</span>
    {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
    {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
    {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
    {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
    {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
<span class="udiff-line-added">+   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},</span>
    {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
    {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
    {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
<span class="udiff-line-modified-removed">-   {CC&quot;isJavaHeapArchiveSupported&quot;,      CC&quot;()Z&quot;,      (void*)&amp;WB_IsJavaHeapArchiveSupported },</span>
<span class="udiff-line-modified-added">+   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },</span>
<span class="udiff-line-added">+   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },</span>
<span class="udiff-line-added">+   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },</span>
  
    {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
    {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
    {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
                                                        (void*)&amp;WB_AddCompilerDirective },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2335,13 +2442,14 @@</span>
    {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
                                                        (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
    {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
    {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
    {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
<span class="udiff-line-modified-removed">-   {CC&quot;resolvedMethodRemovedCount&quot;,     CC&quot;()I&quot;,       (void*)&amp;WB_ResolvedMethodRemovedCount },</span>
<span class="udiff-line-modified-added">+   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },</span>
    {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
    {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
<span class="udiff-line-added">+   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},</span>
  };
  
  
  #undef CC
  
</pre>
<center><a href="wbtestmethods/parserTests.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
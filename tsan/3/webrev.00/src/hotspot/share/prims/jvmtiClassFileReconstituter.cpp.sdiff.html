<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiClassFileReconstituter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmti.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiClassFileReconstituter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;interpreter/bytecodeStream.hpp&quot;
<span class="line-modified">  28 #include &quot;oops/fieldStreams.hpp&quot;</span>


  29 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
  30 #include &quot;runtime/handles.inline.hpp&quot;
  31 #include &quot;runtime/signature.hpp&quot;
  32 #include &quot;utilities/bytes.hpp&quot;
  33 
  34 // FIXME: add Deprecated attribute
  35 // FIXME: fix Synthetic attribute
  36 // FIXME: per Serguei, add error return handling for ConstantPool::copy_cpool_bytes()
  37 
  38 JvmtiConstantPoolReconstituter::JvmtiConstantPoolReconstituter(InstanceKlass* ik) {
  39   set_error(JVMTI_ERROR_NONE);
  40   _ik = ik;
  41   _cpool = constantPoolHandle(Thread::current(), ik-&gt;constants());
  42   _symmap = new SymbolHashMap();
  43   _classmap = new SymbolHashMap();
  44   _cpool_size = _cpool-&gt;hash_entries_to(_symmap, _classmap);
  45   if (_cpool_size == 0) {
  46     set_error(JVMTI_ERROR_OUT_OF_MEMORY);
  47   } else if (_cpool_size &lt; 0) {
  48     set_error(JVMTI_ERROR_INTERNAL);
</pre>
<hr />
<pre>
 405 //  NestMembers_attribute {
 406 //    u2 attribute_name_index;
 407 //    u4 attribute_length;
 408 //    u2 number_of_classes;
 409 //    u2 classes[number_of_classes];
 410 //  }
 411 void JvmtiClassFileReconstituter::write_nest_members_attribute() {
 412   Array&lt;u2&gt;* nest_members = ik()-&gt;nest_members();
 413   int number_of_classes = nest_members-&gt;length();
 414   int length = sizeof(u2) * (1 + number_of_classes);
 415 
 416   write_attribute_name_index(&quot;NestMembers&quot;);
 417   write_u4(length);
 418   write_u2(number_of_classes);
 419   for (int i = 0; i &lt; number_of_classes; i++) {
 420     u2 class_cp_index = nest_members-&gt;at(i);
 421     write_u2(class_cp_index);
 422   }
 423 }
 424 



















































 425 
 426 // Write InnerClasses attribute
 427 // JVMSpec|   InnerClasses_attribute {
 428 // JVMSpec|     u2 attribute_name_index;
 429 // JVMSpec|     u4 attribute_length;
 430 // JVMSpec|     u2 number_of_classes;
 431 // JVMSpec|     {  u2 inner_class_info_index;
 432 // JVMSpec|        u2 outer_class_info_index;
 433 // JVMSpec|        u2 inner_name_index;
 434 // JVMSpec|        u2 inner_class_access_flags;
 435 // JVMSpec|     } classes[number_of_classes];
 436 // JVMSpec|   }
 437 void JvmtiClassFileReconstituter::write_inner_classes_attribute(int length) {
 438   InnerClassesIterator iter(ik());
 439   guarantee(iter.length() != 0 &amp;&amp; iter.length() == length,
 440             &quot;caller must check&quot;);
 441   u2 entry_count = length / InstanceKlass::inner_class_next_offset;
 442   u4 size = 2 + entry_count * (2+2+2+2);
 443 
 444   write_attribute_name_index(&quot;InnerClasses&quot;);
</pre>
<hr />
<pre>
 681     ++attr_count;
 682   }
 683   if (inner_classes_length &gt; 0) {
 684     ++attr_count;
 685   }
 686   if (anno != NULL) {
 687     ++attr_count;     // has RuntimeVisibleAnnotations attribute
 688   }
 689   if (type_anno != NULL) {
 690     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
 691   }
 692   if (cpool()-&gt;operands() != NULL) {
 693     ++attr_count;
 694   }
 695   if (ik()-&gt;nest_host_index() != 0) {
 696     ++attr_count;
 697   }
 698   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 699     ++attr_count;
 700   }



 701 
 702   write_u2(attr_count);
 703 
 704   if (generic_signature != NULL) {
 705     write_signature_attribute(symbol_to_cpool_index(generic_signature));
 706   }
 707   if (ik()-&gt;source_file_name() != NULL) {
 708     write_source_file_attribute();
 709   }
 710   if (ik()-&gt;source_debug_extension() != NULL) {
 711     write_source_debug_extension_attribute();
 712   }
 713   if (inner_classes_length &gt; 0) {
 714     write_inner_classes_attribute(inner_classes_length);
 715   }
 716   if (anno != NULL) {
 717     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
 718   }
 719   if (type_anno != NULL) {
 720     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
 721   }
 722   if (cpool()-&gt;operands() != NULL) {
 723     write_bootstrapmethod_attribute();
 724   }
 725   if (ik()-&gt;nest_host_index() != 0) {
 726     write_nest_host_attribute();
 727   }
 728   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 729     write_nest_members_attribute();
 730   }



 731 }
 732 
 733 // Write the method information portion of ClassFile structure
 734 // JVMSpec|     u2 methods_count;
 735 // JVMSpec|     method_info methods[methods_count];
 736 void JvmtiClassFileReconstituter::write_method_infos() {
 737   HandleMark hm(thread());
 738   Array&lt;Method*&gt;* methods = ik()-&gt;methods();
 739   int num_methods = methods-&gt;length();
 740   int num_overpass = 0;
 741 
 742   // count the generated default interface methods
 743   // these will not be re-created by write_method_info
 744   // and should not be included in the total count
 745   for (int index = 0; index &lt; num_methods; index++) {
 746     Method* method = methods-&gt;at(index);
 747     if (method-&gt;is_overpass()) {
 748       num_overpass++;
 749     }
 750   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;interpreter/bytecodeStream.hpp&quot;
<span class="line-modified">  28 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  29 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
<span class="line-added">  30 #include &quot;oops/recordComponent.hpp&quot;</span>
  31 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
  32 #include &quot;runtime/handles.inline.hpp&quot;
  33 #include &quot;runtime/signature.hpp&quot;
  34 #include &quot;utilities/bytes.hpp&quot;
  35 
  36 // FIXME: add Deprecated attribute
  37 // FIXME: fix Synthetic attribute
  38 // FIXME: per Serguei, add error return handling for ConstantPool::copy_cpool_bytes()
  39 
  40 JvmtiConstantPoolReconstituter::JvmtiConstantPoolReconstituter(InstanceKlass* ik) {
  41   set_error(JVMTI_ERROR_NONE);
  42   _ik = ik;
  43   _cpool = constantPoolHandle(Thread::current(), ik-&gt;constants());
  44   _symmap = new SymbolHashMap();
  45   _classmap = new SymbolHashMap();
  46   _cpool_size = _cpool-&gt;hash_entries_to(_symmap, _classmap);
  47   if (_cpool_size == 0) {
  48     set_error(JVMTI_ERROR_OUT_OF_MEMORY);
  49   } else if (_cpool_size &lt; 0) {
  50     set_error(JVMTI_ERROR_INTERNAL);
</pre>
<hr />
<pre>
 407 //  NestMembers_attribute {
 408 //    u2 attribute_name_index;
 409 //    u4 attribute_length;
 410 //    u2 number_of_classes;
 411 //    u2 classes[number_of_classes];
 412 //  }
 413 void JvmtiClassFileReconstituter::write_nest_members_attribute() {
 414   Array&lt;u2&gt;* nest_members = ik()-&gt;nest_members();
 415   int number_of_classes = nest_members-&gt;length();
 416   int length = sizeof(u2) * (1 + number_of_classes);
 417 
 418   write_attribute_name_index(&quot;NestMembers&quot;);
 419   write_u4(length);
 420   write_u2(number_of_classes);
 421   for (int i = 0; i &lt; number_of_classes; i++) {
 422     u2 class_cp_index = nest_members-&gt;at(i);
 423     write_u2(class_cp_index);
 424   }
 425 }
 426 
<span class="line-added"> 427 //  Record {</span>
<span class="line-added"> 428 //    u2 attribute_name_index;</span>
<span class="line-added"> 429 //    u4 attribute_length;</span>
<span class="line-added"> 430 //    u2 components_count;</span>
<span class="line-added"> 431 //    component_info components[components_count];</span>
<span class="line-added"> 432 //  }</span>
<span class="line-added"> 433 //  component_info {</span>
<span class="line-added"> 434 //    u2 name_index;</span>
<span class="line-added"> 435 //    u2 descriptor_index</span>
<span class="line-added"> 436 //    u2 attributes_count;</span>
<span class="line-added"> 437 //    attribute_info_attributes[attributes_count];</span>
<span class="line-added"> 438 //  }</span>
<span class="line-added"> 439 void JvmtiClassFileReconstituter::write_record_attribute() {</span>
<span class="line-added"> 440   Array&lt;RecordComponent*&gt;* components = ik()-&gt;record_components();</span>
<span class="line-added"> 441   int number_of_components = components-&gt;length();</span>
<span class="line-added"> 442 </span>
<span class="line-added"> 443   // Each component has a u2 for name, descr, attribute count</span>
<span class="line-added"> 444   int length = sizeof(u2) + (sizeof(u2) * 3 * number_of_components);</span>
<span class="line-added"> 445   for (int x = 0; x &lt; number_of_components; x++) {</span>
<span class="line-added"> 446     RecordComponent* component = components-&gt;at(x);</span>
<span class="line-added"> 447     if (component-&gt;generic_signature_index() != 0) {</span>
<span class="line-added"> 448       length += 8; // Signature attribute size</span>
<span class="line-added"> 449       assert(component-&gt;attributes_count() &gt; 0, &quot;Bad component attributes count&quot;);</span>
<span class="line-added"> 450     }</span>
<span class="line-added"> 451     if (component-&gt;annotations() != NULL) {</span>
<span class="line-added"> 452       length += 6 + component-&gt;annotations()-&gt;length();</span>
<span class="line-added"> 453     }</span>
<span class="line-added"> 454     if (component-&gt;type_annotations() != NULL) {</span>
<span class="line-added"> 455       length += 6 + component-&gt;type_annotations()-&gt;length();</span>
<span class="line-added"> 456     }</span>
<span class="line-added"> 457   }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459   write_attribute_name_index(&quot;Record&quot;);</span>
<span class="line-added"> 460   write_u4(length);</span>
<span class="line-added"> 461   write_u2(number_of_components);</span>
<span class="line-added"> 462   for (int i = 0; i &lt; number_of_components; i++) {</span>
<span class="line-added"> 463     RecordComponent* component = components-&gt;at(i);</span>
<span class="line-added"> 464     write_u2(component-&gt;name_index());</span>
<span class="line-added"> 465     write_u2(component-&gt;descriptor_index());</span>
<span class="line-added"> 466     write_u2(component-&gt;attributes_count());</span>
<span class="line-added"> 467     if (component-&gt;generic_signature_index() != 0) {</span>
<span class="line-added"> 468       write_signature_attribute(component-&gt;generic_signature_index());</span>
<span class="line-added"> 469     }</span>
<span class="line-added"> 470     if (component-&gt;annotations() != NULL) {</span>
<span class="line-added"> 471       write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, component-&gt;annotations());</span>
<span class="line-added"> 472     }</span>
<span class="line-added"> 473     if (component-&gt;type_annotations() != NULL) {</span>
<span class="line-added"> 474       write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, component-&gt;type_annotations());</span>
<span class="line-added"> 475     }</span>
<span class="line-added"> 476   }</span>
<span class="line-added"> 477 }</span>
 478 
 479 // Write InnerClasses attribute
 480 // JVMSpec|   InnerClasses_attribute {
 481 // JVMSpec|     u2 attribute_name_index;
 482 // JVMSpec|     u4 attribute_length;
 483 // JVMSpec|     u2 number_of_classes;
 484 // JVMSpec|     {  u2 inner_class_info_index;
 485 // JVMSpec|        u2 outer_class_info_index;
 486 // JVMSpec|        u2 inner_name_index;
 487 // JVMSpec|        u2 inner_class_access_flags;
 488 // JVMSpec|     } classes[number_of_classes];
 489 // JVMSpec|   }
 490 void JvmtiClassFileReconstituter::write_inner_classes_attribute(int length) {
 491   InnerClassesIterator iter(ik());
 492   guarantee(iter.length() != 0 &amp;&amp; iter.length() == length,
 493             &quot;caller must check&quot;);
 494   u2 entry_count = length / InstanceKlass::inner_class_next_offset;
 495   u4 size = 2 + entry_count * (2+2+2+2);
 496 
 497   write_attribute_name_index(&quot;InnerClasses&quot;);
</pre>
<hr />
<pre>
 734     ++attr_count;
 735   }
 736   if (inner_classes_length &gt; 0) {
 737     ++attr_count;
 738   }
 739   if (anno != NULL) {
 740     ++attr_count;     // has RuntimeVisibleAnnotations attribute
 741   }
 742   if (type_anno != NULL) {
 743     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
 744   }
 745   if (cpool()-&gt;operands() != NULL) {
 746     ++attr_count;
 747   }
 748   if (ik()-&gt;nest_host_index() != 0) {
 749     ++attr_count;
 750   }
 751   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 752     ++attr_count;
 753   }
<span class="line-added"> 754   if (ik()-&gt;record_components() != NULL) {</span>
<span class="line-added"> 755     ++attr_count;</span>
<span class="line-added"> 756   }</span>
 757 
 758   write_u2(attr_count);
 759 
 760   if (generic_signature != NULL) {
 761     write_signature_attribute(symbol_to_cpool_index(generic_signature));
 762   }
 763   if (ik()-&gt;source_file_name() != NULL) {
 764     write_source_file_attribute();
 765   }
 766   if (ik()-&gt;source_debug_extension() != NULL) {
 767     write_source_debug_extension_attribute();
 768   }
 769   if (inner_classes_length &gt; 0) {
 770     write_inner_classes_attribute(inner_classes_length);
 771   }
 772   if (anno != NULL) {
 773     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
 774   }
 775   if (type_anno != NULL) {
 776     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
 777   }
 778   if (cpool()-&gt;operands() != NULL) {
 779     write_bootstrapmethod_attribute();
 780   }
 781   if (ik()-&gt;nest_host_index() != 0) {
 782     write_nest_host_attribute();
 783   }
 784   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 785     write_nest_members_attribute();
 786   }
<span class="line-added"> 787   if (ik()-&gt;record_components() != NULL) {</span>
<span class="line-added"> 788     write_record_attribute();</span>
<span class="line-added"> 789   }</span>
 790 }
 791 
 792 // Write the method information portion of ClassFile structure
 793 // JVMSpec|     u2 methods_count;
 794 // JVMSpec|     method_info methods[methods_count];
 795 void JvmtiClassFileReconstituter::write_method_infos() {
 796   HandleMark hm(thread());
 797   Array&lt;Method*&gt;* methods = ik()-&gt;methods();
 798   int num_methods = methods-&gt;length();
 799   int num_overpass = 0;
 800 
 801   // count the generated default interface methods
 802   // these will not be re-created by write_method_info
 803   // and should not be included in the total count
 804   for (int index = 0; index &lt; num_methods; index++) {
 805     Method* method = methods-&gt;at(index);
 806     if (method-&gt;is_overpass()) {
 807       num_overpass++;
 808     }
 809   }
</pre>
</td>
</tr>
</table>
<center><a href="jvmti.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
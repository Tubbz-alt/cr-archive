<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEventController.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnvBase.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEventController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interpreter/interpreter.hpp&quot;
  27 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;prims/jvmtiEventController.hpp&quot;
  31 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  32 #include &quot;prims/jvmtiExport.hpp&quot;
  33 #include &quot;prims/jvmtiImpl.hpp&quot;
  34 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;

  35 #include &quot;runtime/frame.hpp&quot;
  36 #include &quot;runtime/thread.inline.hpp&quot;
  37 #include &quot;runtime/threadSMR.hpp&quot;
  38 #include &quot;runtime/vframe.hpp&quot;
  39 #include &quot;runtime/vframe_hp.hpp&quot;
  40 #include &quot;runtime/vmThread.hpp&quot;
  41 #include &quot;runtime/vmOperations.hpp&quot;
  42 
  43 #ifdef JVMTI_TRACE
  44 #define EC_TRACE(out) do { \
  45   if (JvmtiTrace::trace_event_controller()) { \
  46     SafeResourceMark rm; \
  47     log_trace(jvmti) out; \
  48   } \
  49 } while (0)
  50 #else
  51 #define EC_TRACE(out)
  52 #endif /*JVMTI_TRACE */
  53 
  54 // bits for standard events
</pre>
<hr />
<pre>
 222   _state-&gt;enter_interp_only_mode();
 223 
 224   JavaThread *thread = _state-&gt;get_thread();
 225   if (thread-&gt;has_last_Java_frame()) {
 226     // If running in fullspeed mode, single stepping is implemented
 227     // as follows: first, the interpreter does not dispatch to
 228     // compiled code for threads that have single stepping enabled;
 229     // second, we deoptimize all methods on the thread&#39;s stack when
 230     // interpreted-only mode is enabled the first time for a given
 231     // thread (nothing to do if no Java frames yet).
 232     int num_marked = 0;
 233     ResourceMark resMark;
 234     RegisterMap rm(thread, false);
 235     for (vframe* vf = thread-&gt;last_java_vframe(&amp;rm); vf; vf = vf-&gt;sender()) {
 236       if (can_be_deoptimized(vf)) {
 237         ((compiledVFrame*) vf)-&gt;code()-&gt;mark_for_deoptimization();
 238         ++num_marked;
 239       }
 240     }
 241     if (num_marked &gt; 0) {
<span class="line-modified"> 242       VM_Deoptimize op;</span>
<span class="line-removed"> 243       VMThread::execute(&amp;op);</span>
 244     }
 245   }
 246 }
 247 
 248 
 249 ///////////////////////////////////////////////////////////////
 250 //
 251 // VM_ChangeSingleStep
 252 //
 253 
 254 class VM_ChangeSingleStep : public VM_Operation {
 255 private:
 256   bool _on;
 257 
 258 public:
 259   VM_ChangeSingleStep(bool on);
 260   VMOp_Type type() const                         { return VMOp_ChangeSingleStep; }
 261   bool allow_nested_vm_operations() const        { return true; }
 262   void doit();   // method definition is after definition of JvmtiEventControllerPrivate because of scoping
 263 };
 264 
 265 
 266 VM_ChangeSingleStep::VM_ChangeSingleStep(bool on)
<span class="line-modified"> 267   : _on(on != 0)</span>
 268 {
 269 }
 270 
 271 
 272 
 273 
 274 ///////////////////////////////////////////////////////////////
 275 //
 276 // JvmtiEventControllerPrivate
 277 //
 278 // Private internal implementation methods for JvmtiEventController.
 279 //
 280 // These methods are thread safe either because they are called
 281 // in early VM initialization which is single threaded, or they
 282 // hold the JvmtiThreadState_lock.
 283 //
 284 
 285 class JvmtiEventControllerPrivate : public AllStatic {
 286   static bool _initialized;
 287 public:
</pre>
<hr />
<pre>
 314 
 315   static void env_initialize(JvmtiEnvBase *env);
 316   static void env_dispose(JvmtiEnvBase *env);
 317 
 318   static void vm_start();
 319   static void vm_init();
 320   static void vm_death();
 321 
 322   static void trace_changed(JvmtiThreadState *state, jlong now_enabled, jlong changed);
 323   static void trace_changed(jlong now_enabled, jlong changed);
 324 };
 325 
 326 bool JvmtiEventControllerPrivate::_initialized = false;
 327 
 328 void JvmtiEventControllerPrivate::set_should_post_single_step(bool on) {
 329   // we have permission to do this, VM op doesn&#39;t
 330   JvmtiExport::set_should_post_single_step(on);
 331 }
 332 
 333 
<span class="line-modified"> 334 // This change must always be occur when at a safepoint.</span>
<span class="line-modified"> 335 // Being at a safepoint causes the interpreter to use the</span>
<span class="line-modified"> 336 // safepoint dispatch table which we overload to find single</span>
<span class="line-modified"> 337 // step points.  Just to be sure that it has been set, we</span>
<span class="line-modified"> 338 // call notice_safepoints when turning on single stepping.</span>
<span class="line-modified"> 339 // When we leave our current safepoint, should_post_single_step</span>
<span class="line-modified"> 340 // will be checked by the interpreter, and the table kept</span>
<span class="line-removed"> 341 // or changed accordingly.</span>
 342 void VM_ChangeSingleStep::doit() {

 343   JvmtiEventControllerPrivate::set_should_post_single_step(_on);
 344   if (_on) {
 345     Interpreter::notice_safepoints();


 346   }
 347 }
 348 
 349 
 350 void JvmtiEventControllerPrivate::enter_interp_only_mode(JvmtiThreadState *state) {
 351   EC_TRACE((&quot;[%s] # Entering interpreter only mode&quot;,
 352             JvmtiTrace::safe_get_thread_name(state-&gt;get_thread())));
 353 
 354   VM_EnterInterpOnlyMode op(state);
 355   VMThread::execute(&amp;op);
 356 }
 357 
 358 
 359 void
 360 JvmtiEventControllerPrivate::leave_interp_only_mode(JvmtiThreadState *state) {
 361   EC_TRACE((&quot;[%s] # Leaving interpreter only mode&quot;,
 362             JvmtiTrace::safe_get_thread_name(state-&gt;get_thread())));
 363   state-&gt;leave_interp_only_mode();
 364 }
 365 
</pre>
<hr />
<pre>
 980   }
 981 }
 982 
 983 void
 984 JvmtiEventController::set_extension_event_callback(JvmtiEnvBase *env,
 985                                                    jint extension_event_index,
 986                                                    jvmtiExtensionEvent callback) {
 987   if (Threads::number_of_threads() == 0) {
 988     JvmtiEventControllerPrivate::set_extension_event_callback(env, extension_event_index, callback);
 989   } else {
 990     MutexLocker mu(JvmtiThreadState_lock);
 991     JvmtiEventControllerPrivate::set_extension_event_callback(env, extension_event_index, callback);
 992   }
 993 }
 994 
 995 
 996 
 997 
 998 void
 999 JvmtiEventController::set_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1000   MutexLockerEx mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1001   JvmtiEventControllerPrivate::set_frame_pop(ets, fpop);
1002 }
1003 
1004 
1005 void
1006 JvmtiEventController::clear_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1007   MutexLockerEx mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1008   JvmtiEventControllerPrivate::clear_frame_pop(ets, fpop);
1009 }
1010 
1011 
1012 void
1013 JvmtiEventController::clear_to_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1014   MutexLockerEx mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1015   JvmtiEventControllerPrivate::clear_to_frame_pop(ets, fpop);
1016 }
1017 
1018 void
1019 JvmtiEventController::change_field_watch(jvmtiEvent event_type, bool added) {
1020   MutexLocker mu(JvmtiThreadState_lock);
1021   JvmtiEventControllerPrivate::change_field_watch(event_type, added);
1022 }
1023 
1024 void
1025 JvmtiEventController::thread_started(JavaThread *thread) {
1026   // operates only on the current thread
1027   // JvmtiThreadState_lock grabbed only if needed.
1028   JvmtiEventControllerPrivate::thread_started(thread);
1029 }
1030 
1031 void
1032 JvmtiEventController::thread_ended(JavaThread *thread) {
1033   // operates only on the current thread
1034   // JvmtiThreadState_lock grabbed only if needed.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interpreter/interpreter.hpp&quot;
  27 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;prims/jvmtiEventController.hpp&quot;
  31 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  32 #include &quot;prims/jvmtiExport.hpp&quot;
  33 #include &quot;prims/jvmtiImpl.hpp&quot;
  34 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
<span class="line-added">  35 #include &quot;runtime/deoptimization.hpp&quot;</span>
  36 #include &quot;runtime/frame.hpp&quot;
  37 #include &quot;runtime/thread.inline.hpp&quot;
  38 #include &quot;runtime/threadSMR.hpp&quot;
  39 #include &quot;runtime/vframe.hpp&quot;
  40 #include &quot;runtime/vframe_hp.hpp&quot;
  41 #include &quot;runtime/vmThread.hpp&quot;
  42 #include &quot;runtime/vmOperations.hpp&quot;
  43 
  44 #ifdef JVMTI_TRACE
  45 #define EC_TRACE(out) do { \
  46   if (JvmtiTrace::trace_event_controller()) { \
  47     SafeResourceMark rm; \
  48     log_trace(jvmti) out; \
  49   } \
  50 } while (0)
  51 #else
  52 #define EC_TRACE(out)
  53 #endif /*JVMTI_TRACE */
  54 
  55 // bits for standard events
</pre>
<hr />
<pre>
 223   _state-&gt;enter_interp_only_mode();
 224 
 225   JavaThread *thread = _state-&gt;get_thread();
 226   if (thread-&gt;has_last_Java_frame()) {
 227     // If running in fullspeed mode, single stepping is implemented
 228     // as follows: first, the interpreter does not dispatch to
 229     // compiled code for threads that have single stepping enabled;
 230     // second, we deoptimize all methods on the thread&#39;s stack when
 231     // interpreted-only mode is enabled the first time for a given
 232     // thread (nothing to do if no Java frames yet).
 233     int num_marked = 0;
 234     ResourceMark resMark;
 235     RegisterMap rm(thread, false);
 236     for (vframe* vf = thread-&gt;last_java_vframe(&amp;rm); vf; vf = vf-&gt;sender()) {
 237       if (can_be_deoptimized(vf)) {
 238         ((compiledVFrame*) vf)-&gt;code()-&gt;mark_for_deoptimization();
 239         ++num_marked;
 240       }
 241     }
 242     if (num_marked &gt; 0) {
<span class="line-modified"> 243       Deoptimization::deoptimize_all_marked();</span>

 244     }
 245   }
 246 }
 247 
 248 
 249 ///////////////////////////////////////////////////////////////
 250 //
 251 // VM_ChangeSingleStep
 252 //
 253 
 254 class VM_ChangeSingleStep : public VM_Operation {
 255 private:
 256   bool _on;
 257 
 258 public:
 259   VM_ChangeSingleStep(bool on);
 260   VMOp_Type type() const                         { return VMOp_ChangeSingleStep; }
 261   bool allow_nested_vm_operations() const        { return true; }
 262   void doit();   // method definition is after definition of JvmtiEventControllerPrivate because of scoping
 263 };
 264 
 265 
 266 VM_ChangeSingleStep::VM_ChangeSingleStep(bool on)
<span class="line-modified"> 267   : _on(on)</span>
 268 {
 269 }
 270 
 271 
 272 
 273 
 274 ///////////////////////////////////////////////////////////////
 275 //
 276 // JvmtiEventControllerPrivate
 277 //
 278 // Private internal implementation methods for JvmtiEventController.
 279 //
 280 // These methods are thread safe either because they are called
 281 // in early VM initialization which is single threaded, or they
 282 // hold the JvmtiThreadState_lock.
 283 //
 284 
 285 class JvmtiEventControllerPrivate : public AllStatic {
 286   static bool _initialized;
 287 public:
</pre>
<hr />
<pre>
 314 
 315   static void env_initialize(JvmtiEnvBase *env);
 316   static void env_dispose(JvmtiEnvBase *env);
 317 
 318   static void vm_start();
 319   static void vm_init();
 320   static void vm_death();
 321 
 322   static void trace_changed(JvmtiThreadState *state, jlong now_enabled, jlong changed);
 323   static void trace_changed(jlong now_enabled, jlong changed);
 324 };
 325 
 326 bool JvmtiEventControllerPrivate::_initialized = false;
 327 
 328 void JvmtiEventControllerPrivate::set_should_post_single_step(bool on) {
 329   // we have permission to do this, VM op doesn&#39;t
 330   JvmtiExport::set_should_post_single_step(on);
 331 }
 332 
 333 
<span class="line-modified"> 334 // When _on == true, we use the safepoint interpreter dispatch table</span>
<span class="line-modified"> 335 // to allow us to find the single step points. Otherwise, we switch</span>
<span class="line-modified"> 336 // back to the regular interpreter dispatch table.</span>
<span class="line-modified"> 337 // Note: We call Interpreter::notice_safepoints() and ignore_safepoints()</span>
<span class="line-modified"> 338 // in a VM_Operation to safely make the dispatch table switch. We</span>
<span class="line-modified"> 339 // no longer rely on the safepoint mechanism to do any of this work</span>
<span class="line-modified"> 340 // for us.</span>

 341 void VM_ChangeSingleStep::doit() {
<span class="line-added"> 342   log_debug(interpreter, safepoint)(&quot;changing single step to &#39;%s&#39;&quot;, _on ? &quot;on&quot; : &quot;off&quot;);</span>
 343   JvmtiEventControllerPrivate::set_should_post_single_step(_on);
 344   if (_on) {
 345     Interpreter::notice_safepoints();
<span class="line-added"> 346   } else {</span>
<span class="line-added"> 347     Interpreter::ignore_safepoints();</span>
 348   }
 349 }
 350 
 351 
 352 void JvmtiEventControllerPrivate::enter_interp_only_mode(JvmtiThreadState *state) {
 353   EC_TRACE((&quot;[%s] # Entering interpreter only mode&quot;,
 354             JvmtiTrace::safe_get_thread_name(state-&gt;get_thread())));
 355 
 356   VM_EnterInterpOnlyMode op(state);
 357   VMThread::execute(&amp;op);
 358 }
 359 
 360 
 361 void
 362 JvmtiEventControllerPrivate::leave_interp_only_mode(JvmtiThreadState *state) {
 363   EC_TRACE((&quot;[%s] # Leaving interpreter only mode&quot;,
 364             JvmtiTrace::safe_get_thread_name(state-&gt;get_thread())));
 365   state-&gt;leave_interp_only_mode();
 366 }
 367 
</pre>
<hr />
<pre>
 982   }
 983 }
 984 
 985 void
 986 JvmtiEventController::set_extension_event_callback(JvmtiEnvBase *env,
 987                                                    jint extension_event_index,
 988                                                    jvmtiExtensionEvent callback) {
 989   if (Threads::number_of_threads() == 0) {
 990     JvmtiEventControllerPrivate::set_extension_event_callback(env, extension_event_index, callback);
 991   } else {
 992     MutexLocker mu(JvmtiThreadState_lock);
 993     JvmtiEventControllerPrivate::set_extension_event_callback(env, extension_event_index, callback);
 994   }
 995 }
 996 
 997 
 998 
 999 
1000 void
1001 JvmtiEventController::set_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1002   MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1003   JvmtiEventControllerPrivate::set_frame_pop(ets, fpop);
1004 }
1005 
1006 
1007 void
1008 JvmtiEventController::clear_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1009   MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1010   JvmtiEventControllerPrivate::clear_frame_pop(ets, fpop);
1011 }
1012 
1013 
1014 void
1015 JvmtiEventController::clear_to_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {
<span class="line-modified">1016   MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);</span>
1017   JvmtiEventControllerPrivate::clear_to_frame_pop(ets, fpop);
1018 }
1019 
1020 void
1021 JvmtiEventController::change_field_watch(jvmtiEvent event_type, bool added) {
1022   MutexLocker mu(JvmtiThreadState_lock);
1023   JvmtiEventControllerPrivate::change_field_watch(event_type, added);
1024 }
1025 
1026 void
1027 JvmtiEventController::thread_started(JavaThread *thread) {
1028   // operates only on the current thread
1029   // JvmtiThreadState_lock grabbed only if needed.
1030   JvmtiEventControllerPrivate::thread_started(thread);
1031 }
1032 
1033 void
1034 JvmtiEventController::thread_ended(JavaThread *thread) {
1035   // operates only on the current thread
1036   // JvmtiThreadState_lock grabbed only if needed.
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnvBase.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
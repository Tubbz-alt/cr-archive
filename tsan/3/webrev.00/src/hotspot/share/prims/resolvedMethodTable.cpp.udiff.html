<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/resolvedMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeLookup.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="resolvedMethodTable.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/resolvedMethodTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,228 +22,389 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;oops/oop.inline.hpp&quot;</span>
  #include &quot;oops/method.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/symbol.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/oop.inline.hpp&quot;</span>
  #include &quot;oops/weakHandle.inline.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;utilities/hashtable.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/timerTrace.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/concurrentHashTable.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  
<span class="udiff-line-added">+ // 2^24 is max size</span>
<span class="udiff-line-added">+ static const size_t END_SIZE = 24;</span>
<span class="udiff-line-added">+ // If a chain gets to 32 something might be wrong</span>
<span class="udiff-line-added">+ static const size_t GROW_HINT = 32;</span>
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodEntry::object() {</span>
<span class="udiff-line-removed">-   return literal().resolve();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ static const size_t ResolvedMethodTableSizeLog = 10;</span>
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodEntry::object_no_keepalive() {</span>
<span class="udiff-line-modified-removed">-   // The AS_NO_KEEPALIVE peeks at the oop without keeping it alive.</span>
<span class="udiff-line-modified-removed">-   // This is dangerous in general but is okay if the loaded oop does</span>
<span class="udiff-line-modified-removed">-   // not leak out past a thread transition where a safepoint can happen.</span>
<span class="udiff-line-removed">-   // A subsequent oop_load without AS_NO_KEEPALIVE (the object() accessor)</span>
<span class="udiff-line-removed">-   // keeps the oop alive before doing so.</span>
<span class="udiff-line-removed">-   return literal().peek();</span>
<span class="udiff-line-modified-added">+ unsigned int method_hash(const Method* method) {</span>
<span class="udiff-line-modified-added">+   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="udiff-line-modified-added">+   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="udiff-line-modified-added">+   return name_hash ^ signature_hash;</span>
  }
  
<span class="udiff-line-modified-removed">- ResolvedMethodTable::ResolvedMethodTable()</span>
<span class="udiff-line-modified-removed">-   : Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;(_table_size, sizeof(ResolvedMethodEntry)) { }</span>
<span class="udiff-line-modified-added">+ typedef ConcurrentHashTable&lt;ResolvedMethodTableConfig,</span>
<span class="udiff-line-modified-added">+                             mtClass&gt; ResolvedMethodTableHash;</span>
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodTable::lookup(int index, unsigned int hash, Method* method) {</span>
<span class="udiff-line-modified-removed">-   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-removed">-   for (ResolvedMethodEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {</span>
<span class="udiff-line-modified-removed">-     if (p-&gt;hash() == hash) {</span>
<span class="udiff-line-modified-added">+ class ResolvedMethodTableConfig : public AllStatic {</span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   typedef WeakHandle&lt;vm_resolved_method_table_data&gt; Value;</span>
  
<span class="udiff-line-modified-removed">-       // Peek the object to check if it is the right target.</span>
<span class="udiff-line-modified-removed">-       oop target = p-&gt;object_no_keepalive();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       // The method is in the table as a target already</span>
<span class="udiff-line-modified-removed">-       if (target != NULL &amp;&amp; java_lang_invoke_ResolvedMethodName::vmtarget(target) == method) {</span>
<span class="udiff-line-removed">-         ResourceMark rm;</span>
<span class="udiff-line-removed">-         log_debug(membername, table) (&quot;ResolvedMethod entry found for %s index %d&quot;,</span>
<span class="udiff-line-removed">-                                        method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="udiff-line-removed">-         // The object() accessor makes sure the target object is kept alive before</span>
<span class="udiff-line-removed">-         // leaking out.</span>
<span class="udiff-line-removed">-         return p-&gt;object();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
<span class="udiff-line-modified-added">+     oop val_oop = value.peek();</span>
<span class="udiff-line-modified-added">+     if (val_oop == NULL) {</span>
<span class="udiff-line-modified-added">+       *is_dead = true;</span>
<span class="udiff-line-modified-added">+       return 0;</span>
      }
<span class="udiff-line-added">+     *is_dead = false;</span>
<span class="udiff-line-added">+     Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="udiff-line-added">+     return method_hash(method);</span>
    }
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-modified-removed">- unsigned int ResolvedMethodTable::compute_hash(Method* method) {</span>
<span class="udiff-line-modified-removed">-   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="udiff-line-modified-removed">-   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="udiff-line-modified-removed">-   return name_hash ^ signature_hash;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+   // We use default allocation/deallocation but counted</span>
<span class="udiff-line-modified-added">+   static void* allocate_node(size_t size, Value const&amp; value) {</span>
<span class="udiff-line-modified-added">+     ResolvedMethodTable::item_added();</span>
<span class="udiff-line-modified-added">+     return AllocateHeap(size, mtClass);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+   static void free_node(void* memory, Value const&amp; value) {</span>
<span class="udiff-line-added">+     value.release();</span>
<span class="udiff-line-added">+     FreeHeap(memory);</span>
<span class="udiff-line-added">+     ResolvedMethodTable::item_removed();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static ResolvedMethodTableHash* _local_table           = NULL;</span>
<span class="udiff-line-added">+ static size_t                   _current_size          = (size_t)1 &lt;&lt; ResolvedMethodTableSizeLog;</span>
  
<span class="udiff-line-added">+ volatile bool            ResolvedMethodTable::_has_work              = false;</span>
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodTable::lookup(Method* method) {</span>
<span class="udiff-line-modified-removed">-   unsigned int hash = compute_hash(method);</span>
<span class="udiff-line-modified-removed">-   int index = hash_to_index(hash);</span>
<span class="udiff-line-modified-removed">-   return lookup(index, hash, method);</span>
<span class="udiff-line-modified-added">+ volatile size_t          _items_count           = 0;</span>
<span class="udiff-line-modified-added">+ volatile size_t          _uncleaned_items_count = 0;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::create_table() {</span>
<span class="udiff-line-added">+   _local_table  = new ResolvedMethodTableHash(ResolvedMethodTableSizeLog, END_SIZE, GROW_HINT);</span>
<span class="udiff-line-added">+   log_trace(membername, table)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-added">+                                _current_size, ResolvedMethodTableSizeLog);</span>
  }
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodTable::basic_add(Method* method, Handle rmethod_name) {</span>
<span class="udiff-line-modified-removed">-   assert_locked_or_safepoint(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-added">+ size_t ResolvedMethodTable::table_size() {</span>
<span class="udiff-line-modified-added">+   return (size_t)1 &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   unsigned int hash = compute_hash(method);</span>
<span class="udiff-line-modified-removed">-   int index = hash_to_index(hash);</span>
<span class="udiff-line-modified-added">+ class ResolvedMethodTableLookup : StackObj {</span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-added">+   Thread*       _thread;</span>
<span class="udiff-line-added">+   uintx         _hash;</span>
<span class="udiff-line-added">+   const Method* _method;</span>
<span class="udiff-line-added">+   Handle        _found;</span>
  
<span class="udiff-line-modified-removed">-   // One was added while aquiring the lock</span>
<span class="udiff-line-modified-removed">-   oop entry = lookup(index, hash, method);</span>
<span class="udiff-line-modified-removed">-   if (entry != NULL) {</span>
<span class="udiff-line-modified-removed">-     return entry;</span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   ResolvedMethodTableLookup(Thread* thread, uintx hash, const Method* key)</span>
<span class="udiff-line-modified-added">+     : _thread(thread), _hash(hash), _method(key) {</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+   uintx get_hash() const {</span>
<span class="udiff-line-added">+     return _hash;</span>
    }
<span class="udiff-line-added">+   bool equals(WeakHandle&lt;vm_resolved_method_table_data&gt;* value, bool* is_dead) {</span>
<span class="udiff-line-added">+     oop val_oop = value-&gt;peek();</span>
<span class="udiff-line-added">+     if (val_oop == NULL) {</span>
<span class="udiff-line-added">+       // dead oop, mark this hash dead for cleaning</span>
<span class="udiff-line-added">+       *is_dead = true;</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     bool equals = _method == java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="udiff-line-added">+     if (!equals) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Need to resolve weak handle and Handleize through possible safepoint.</span>
<span class="udiff-line-added">+     _found = Handle(_thread, value-&gt;resolve());</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
  
<span class="udiff-line-removed">-   ClassLoaderWeakHandle w = ClassLoaderWeakHandle::create(rmethod_name);</span>
<span class="udiff-line-removed">-   ResolvedMethodEntry* p = (ResolvedMethodEntry*) Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::new_entry(hash, w);</span>
<span class="udiff-line-removed">-   Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::add_entry(index, p);</span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   log_debug(membername, table) (&quot;ResolvedMethod entry added for %s index %d&quot;,</span>
<span class="udiff-line-removed">-                                  method-&gt;name_and_sig_as_C_string(), index);</span>
<span class="udiff-line-removed">-   return rmethod_name();</span>
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-modified-removed">- ResolvedMethodTable* ResolvedMethodTable::_the_table = NULL;</span>
<span class="udiff-line-modified-added">+ class ResolvedMethodGet : public StackObj {</span>
<span class="udiff-line-added">+   Thread*       _thread;</span>
<span class="udiff-line-added">+   const Method* _method;</span>
<span class="udiff-line-added">+   Handle        _return;</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   ResolvedMethodGet(Thread* thread, const Method* method) : _thread(thread), _method(method) {}</span>
<span class="udiff-line-added">+   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="udiff-line-added">+     oop result = val-&gt;resolve();</span>
<span class="udiff-line-added">+     assert(result != NULL, &quot;Result should be reachable&quot;);</span>
<span class="udiff-line-added">+     _return = Handle(_thread, result);</span>
<span class="udiff-line-added">+     log_get();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oop get_res_oop() {</span>
<span class="udiff-line-added">+     return _return();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   void log_get() {</span>
<span class="udiff-line-added">+     LogTarget(Trace, membername, table) log;</span>
<span class="udiff-line-added">+     if (log.is_enabled()) {</span>
<span class="udiff-line-added">+       ResourceMark rm;</span>
<span class="udiff-line-added">+       log.print(&quot;ResolvedMethod entry found for %s&quot;,</span>
<span class="udiff-line-added">+                 _method-&gt;name_and_sig_as_C_string());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ oop ResolvedMethodTable::find_method(const Method* method) {</span>
<span class="udiff-line-added">+   Thread* thread = Thread::current();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="udiff-line-added">+   ResolvedMethodGet rmg(thread, method);</span>
<span class="udiff-line-added">+   _local_table-&gt;get(thread, lookup, rmg);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return rmg.get_res_oop();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodTable::find_method(Method* method) {</span>
<span class="udiff-line-modified-removed">-   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-removed">-   oop entry = _the_table-&gt;lookup(method);</span>
<span class="udiff-line-modified-removed">-   return entry;</span>
<span class="udiff-line-modified-added">+ static void log_insert(const Method* method) {</span>
<span class="udiff-line-modified-added">+   LogTarget(Debug, membername, table) log;</span>
<span class="udiff-line-modified-added">+   if (log.is_enabled()) {</span>
<span class="udiff-line-modified-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     log.print(&quot;ResolvedMethod entry added for %s&quot;,</span>
<span class="udiff-line-added">+               method-&gt;name_and_sig_as_C_string());</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-modified-removed">- oop ResolvedMethodTable::add_method(const methodHandle&amp; m, Handle resolved_method_name) {</span>
<span class="udiff-line-modified-removed">-   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-removed">-   DEBUG_ONLY(NoSafepointVerifier nsv);</span>
<span class="udiff-line-modified-added">+ oop ResolvedMethodTable::add_method(const Method* method, Handle rmethod_name) {</span>
<span class="udiff-line-modified-added">+   Thread* thread = Thread::current();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="udiff-line-added">+   ResolvedMethodGet rmg(thread, method);</span>
  
<span class="udiff-line-modified-removed">-   Method* method = m();</span>
<span class="udiff-line-modified-removed">-   // Check if method has been redefined while taking out ResolvedMethodTable_lock, if so</span>
<span class="udiff-line-modified-removed">-   // use new method.  The old method won&#39;t be deallocated because it&#39;s passed in as a Handle.</span>
<span class="udiff-line-modified-removed">-   if (method-&gt;is_old()) {</span>
<span class="udiff-line-modified-removed">-     // Replace method with redefined version</span>
<span class="udiff-line-modified-removed">-     InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="udiff-line-modified-removed">-     method = holder-&gt;method_with_idnum(method-&gt;method_idnum());</span>
<span class="udiff-line-modified-removed">-     if (method == NULL) {</span>
<span class="udiff-line-modified-removed">-       // Replace deleted method with NSME.</span>
<span class="udiff-line-removed">-       method = Universe::throw_no_such_method_error();</span>
<span class="udiff-line-modified-added">+   while (true) {</span>
<span class="udiff-line-modified-added">+     if (_local_table-&gt;get(thread, lookup, rmg)) {</span>
<span class="udiff-line-modified-added">+       return rmg.get_res_oop();</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     WeakHandle&lt;vm_resolved_method_table_data&gt; wh = WeakHandle&lt;vm_resolved_method_table_data&gt;::create(rmethod_name);</span>
<span class="udiff-line-modified-added">+     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.</span>
<span class="udiff-line-modified-added">+     if (_local_table-&gt;insert(thread, lookup, wh)) {</span>
<span class="udiff-line-modified-added">+       log_insert(method);</span>
<span class="udiff-line-modified-added">+       return wh.resolve();</span>
      }
<span class="udiff-line-removed">-     java_lang_invoke_ResolvedMethodName::set_vmtarget(resolved_method_name(), method);</span>
    }
<span class="udiff-line-modified-removed">-   // Set flag in class to indicate this InstanceKlass has entries in the table</span>
<span class="udiff-line-modified-removed">-   // to avoid walking table during redefinition if none of the redefined classes</span>
<span class="udiff-line-modified-removed">-   // have any membernames in the table.</span>
<span class="udiff-line-modified-removed">-   method-&gt;method_holder()-&gt;set_has_resolved_methods();</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::item_added() {</span>
<span class="udiff-line-modified-added">+   Atomic::inc(&amp;_items_count);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   return _the_table-&gt;basic_add(method, resolved_method_name);</span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::item_removed() {</span>
<span class="udiff-line-added">+   Atomic::dec(&amp;_items_count);</span>
<span class="udiff-line-added">+   log_trace(membername, table) (&quot;ResolvedMethod entry removed&quot;);</span>
  }
  
<span class="udiff-line-modified-removed">- // Removing entries</span>
<span class="udiff-line-modified-removed">- int ResolvedMethodTable::_total_oops_removed = 0;</span>
<span class="udiff-line-modified-added">+ double ResolvedMethodTable::get_load_factor() {</span>
<span class="udiff-line-modified-added">+   return (double)_items_count/_current_size;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- // There are no dead entries at start</span>
<span class="udiff-line-modified-removed">- bool ResolvedMethodTable::_dead_entries = false;</span>
<span class="udiff-line-modified-added">+ double ResolvedMethodTable::get_dead_factor() {</span>
<span class="udiff-line-modified-added">+   return (double)_uncleaned_items_count/_current_size;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- void ResolvedMethodTable::trigger_cleanup() {</span>
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-   _dead_entries = true;</span>
<span class="udiff-line-modified-added">+ static const double PREF_AVG_LIST_LEN = 2.0;</span>
<span class="udiff-line-modified-added">+ // If we have as many dead items as 50% of the number of bucket</span>
<span class="udiff-line-modified-added">+ static const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ResolvedMethodTable::check_concurrent_work() {</span>
<span class="udiff-line-added">+   if (_has_work) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double load_factor = get_load_factor();</span>
<span class="udiff-line-added">+   double dead_factor = get_dead_factor();</span>
<span class="udiff-line-added">+   // We should clean/resize if we have more dead than alive,</span>
<span class="udiff-line-added">+   // more items than preferred load factor or</span>
<span class="udiff-line-added">+   // more dead items than water mark.</span>
<span class="udiff-line-added">+   if ((dead_factor &gt; load_factor) ||</span>
<span class="udiff-line-added">+       (load_factor &gt; PREF_AVG_LIST_LEN) ||</span>
<span class="udiff-line-added">+       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {</span>
<span class="udiff-line-added">+     log_debug(membername, table)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,</span>
<span class="udiff-line-added">+                                  load_factor, dead_factor);</span>
<span class="udiff-line-added">+     trigger_concurrent_work();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ResolvedMethodTable::trigger_concurrent_work() {</span>
<span class="udiff-line-added">+   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+   _has_work = true;</span>
    Service_lock-&gt;notify_all();
  }
  
<span class="udiff-line-modified-removed">- // Serially invoke removed unused oops from the table.</span>
<span class="udiff-line-modified-removed">- // This is done by the ServiceThread after being notified on class unloading</span>
<span class="udiff-line-modified-removed">- void ResolvedMethodTable::unlink() {</span>
<span class="udiff-line-modified-removed">-   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-removed">-   int _oops_removed = 0;</span>
<span class="udiff-line-modified-removed">-   int _oops_counted = 0;</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="udiff-line-modified-removed">-     ResolvedMethodEntry** p = _the_table-&gt;bucket_addr(i);</span>
<span class="udiff-line-modified-removed">-     ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="udiff-line-modified-removed">-     while (entry != NULL) {</span>
<span class="udiff-line-modified-removed">-       _oops_counted++;</span>
<span class="udiff-line-modified-removed">-       oop l = entry-&gt;object_no_keepalive();</span>
<span class="udiff-line-modified-removed">-       if (l != NULL) {</span>
<span class="udiff-line-modified-removed">-         p = entry-&gt;next_addr();</span>
<span class="udiff-line-modified-removed">-       } else {</span>
<span class="udiff-line-modified-removed">-         // Entry has been removed.</span>
<span class="udiff-line-modified-removed">-         _oops_removed++;</span>
<span class="udiff-line-modified-removed">-         if (log_is_enabled(Debug, membername, table)) {</span>
<span class="udiff-line-modified-removed">-           log_debug(membername, table) (&quot;ResolvedMethod entry removed for index %d&quot;, i);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         entry-&gt;literal().release();</span>
<span class="udiff-line-modified-removed">-         *p = entry-&gt;next();</span>
<span class="udiff-line-modified-removed">-         _the_table-&gt;free_entry(entry);</span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="udiff-line-modified-added">+   _has_work = false;</span>
<span class="udiff-line-modified-added">+   double load_factor = get_load_factor();</span>
<span class="udiff-line-modified-added">+   log_debug(membername, table)(&quot;Concurrent work, live factor: %g&quot;, load_factor);</span>
<span class="udiff-line-modified-added">+   // We prefer growing, since that also removes dead items</span>
<span class="udiff-line-modified-added">+   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {</span>
<span class="udiff-line-modified-added">+     grow(jt);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     clean_dead_entries(jt);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::grow(JavaThread* jt) {</span>
<span class="udiff-line-modified-added">+   ResolvedMethodTableHash::GrowTask gt(_local_table);</span>
<span class="udiff-line-modified-added">+   if (!gt.prepare(jt)) {</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   log_trace(membername, table)(&quot;Started to grow&quot;);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="udiff-line-modified-added">+     while (gt.do_task(jt)) {</span>
<span class="udiff-line-modified-added">+       gt.pause(jt);</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-added">+         ThreadBlockInVM tbivm(jt);</span>
        }
<span class="udiff-line-modified-removed">-       // get next entry</span>
<span class="udiff-line-modified-removed">-       entry = (ResolvedMethodEntry*)HashtableEntry&lt;ClassLoaderWeakHandle, mtClass&gt;::make_ptr(*p);</span>
<span class="udiff-line-modified-added">+       gt.cont(jt);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   gt.done(jt);</span>
<span class="udiff-line-added">+   _current_size = table_size();</span>
<span class="udiff-line-added">+   log_info(membername, table)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ struct ResolvedMethodTableDoDelete : StackObj {</span>
<span class="udiff-line-added">+   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="udiff-line-added">+     /* do nothing */</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ struct ResolvedMethodTableDeleteCheck : StackObj {</span>
<span class="udiff-line-added">+   long _count;</span>
<span class="udiff-line-added">+   long _item;</span>
<span class="udiff-line-added">+   ResolvedMethodTableDeleteCheck() : _count(0), _item(0) {}</span>
<span class="udiff-line-added">+   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="udiff-line-added">+     ++_item;</span>
<span class="udiff-line-added">+     oop tmp = val-&gt;peek();</span>
<span class="udiff-line-added">+     if (tmp == NULL) {</span>
<span class="udiff-line-added">+       ++_count;</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return false;</span>
      }
    }
<span class="udiff-line-modified-removed">-   log_debug(membername, table) (&quot;ResolvedMethod entries counted %d removed %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                 _oops_counted, _oops_removed);</span>
<span class="udiff-line-modified-removed">-   _total_oops_removed += _oops_removed;</span>
<span class="udiff-line-modified-removed">-   _dead_entries = false;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">- void ResolvedMethodTable::print() {</span>
<span class="udiff-line-modified-removed">-   MutexLocker ml(ResolvedMethodTable_lock);</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; table_size(); ++i) {</span>
<span class="udiff-line-modified-removed">-     ResolvedMethodEntry* entry = bucket(i);</span>
<span class="udiff-line-modified-removed">-     while (entry != NULL) {</span>
<span class="udiff-line-modified-removed">-       tty-&gt;print(&quot;%d : &quot;, i);</span>
<span class="udiff-line-modified-removed">-       oop rmethod_name = entry-&gt;object_no_keepalive();</span>
<span class="udiff-line-modified-removed">-       if (rmethod_name != NULL) {</span>
<span class="udiff-line-removed">-         rmethod_name-&gt;print();</span>
<span class="udiff-line-removed">-         Method* m = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(rmethod_name);</span>
<span class="udiff-line-removed">-         m-&gt;print();</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void ResolvedMethodTable::clean_dead_entries(JavaThread* jt) {</span>
<span class="udiff-line-modified-added">+   ResolvedMethodTableHash::BulkDeleteTask bdt(_local_table);</span>
<span class="udiff-line-modified-added">+   if (!bdt.prepare(jt)) {</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   ResolvedMethodTableDeleteCheck stdc;</span>
<span class="udiff-line-modified-added">+   ResolvedMethodTableDoDelete stdd;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TraceTime timer(&quot;Clean&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="udiff-line-modified-added">+     while(bdt.do_task(jt, stdc, stdd)) {</span>
<span class="udiff-line-modified-added">+       bdt.pause(jt);</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         ThreadBlockInVM tbivm(jt);</span>
        }
<span class="udiff-line-modified-removed">-       entry = entry-&gt;next();</span>
<span class="udiff-line-modified-added">+       bdt.cont(jt);</span>
      }
<span class="udiff-line-added">+     bdt.done(jt);</span>
    }
<span class="udiff-line-added">+   log_info(membername, table)(&quot;Cleaned %ld of %ld&quot;, stdc._count, stdc._item);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ void ResolvedMethodTable::reset_dead_counter() {</span>
<span class="udiff-line-added">+   _uncleaned_items_count = 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ResolvedMethodTable::inc_dead_counter(size_t ndead) {</span>
<span class="udiff-line-added">+   size_t total = Atomic::add(&amp;_uncleaned_items_count, ndead);</span>
<span class="udiff-line-added">+   log_trace(membername, table)(</span>
<span class="udiff-line-added">+      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+      _uncleaned_items_count, ndead, total);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // After the parallel walk this method must be called to trigger</span>
<span class="udiff-line-added">+ // cleaning. Note it might trigger a resize instead.</span>
<span class="udiff-line-added">+ void ResolvedMethodTable::finish_dead_counter() {</span>
<span class="udiff-line-added">+   check_concurrent_work();</span>
  }
<span class="udiff-line-removed">- #endif // PRODUCT</span>
  
  #if INCLUDE_JVMTI
<span class="udiff-line-added">+ class AdjustMethodEntries : public StackObj {</span>
<span class="udiff-line-added">+   bool* _trace_name_printed;</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   AdjustMethodEntries(bool* trace_name_printed) : _trace_name_printed(trace_name_printed) {};</span>
<span class="udiff-line-added">+   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* entry) {</span>
<span class="udiff-line-added">+     oop mem_name = entry-&gt;peek();</span>
<span class="udiff-line-added">+     if (mem_name == NULL) {</span>
<span class="udiff-line-added">+       // Removed</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (old_method-&gt;is_old()) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="udiff-line-added">+                             Universe::throw_no_such_method_error() :</span>
<span class="udiff-line-added">+                             old_method-&gt;get_new_method();</span>
<span class="udiff-line-added">+       java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       ResourceMark rm;</span>
<span class="udiff-line-added">+       if (!(*_trace_name_printed)) {</span>
<span class="udiff-line-added">+         log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="udiff-line-added">+          *_trace_name_printed = true;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       log_debug(redefine, class, update, constantpool)</span>
<span class="udiff-line-added">+         (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="udiff-line-added">+          new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  // It is called at safepoint only for RedefineClasses
  void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
    // For each entry in RMT, change to new method
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; _the_table-&gt;table_size(); ++i) {</span>
<span class="udiff-line-modified-removed">-     for (ResolvedMethodEntry* entry = _the_table-&gt;bucket(i);</span>
<span class="udiff-line-modified-removed">-          entry != NULL;</span>
<span class="udiff-line-modified-removed">-          entry = entry-&gt;next()) {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       oop mem_name = entry-&gt;object_no_keepalive();</span>
<span class="udiff-line-modified-removed">-       // except ones removed</span>
<span class="udiff-line-modified-removed">-       if (mem_name == NULL) {</span>
<span class="udiff-line-modified-removed">-         continue;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       if (old_method-&gt;is_old()) {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="udiff-line-removed">-                               Universe::throw_no_such_method_error() :</span>
<span class="udiff-line-removed">-                               old_method-&gt;get_new_method();</span>
<span class="udiff-line-removed">-         java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         ResourceMark rm;</span>
<span class="udiff-line-removed">-         if (!(*trace_name_printed)) {</span>
<span class="udiff-line-removed">-           log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="udiff-line-removed">-            *trace_name_printed = true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         log_debug(redefine, class, update, constantpool)</span>
<span class="udiff-line-removed">-           (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="udiff-line-removed">-            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+   AdjustMethodEntries adjust(trace_name_printed);</span>
<span class="udiff-line-modified-added">+   _local_table-&gt;do_safepoint_scan(adjust);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ #endif // INCLUDE_JVMTI</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Verification</span>
<span class="udiff-line-modified-added">+ class VerifyResolvedMethod : StackObj {</span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="udiff-line-modified-added">+     oop obj = val-&gt;peek();</span>
<span class="udiff-line-modified-added">+     if (obj != NULL) {</span>
<span class="udiff-line-modified-added">+       Method* method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(obj);</span>
<span class="udiff-line-modified-added">+       guarantee(method-&gt;is_method(), &quot;Must be&quot;);</span>
<span class="udiff-line-modified-added">+       guarantee(!method-&gt;is_old(), &quot;Must be&quot;);</span>
      }
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t ResolvedMethodTable::items_count() {</span>
<span class="udiff-line-added">+   return _items_count;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ResolvedMethodTable::verify() {</span>
<span class="udiff-line-added">+   VerifyResolvedMethod vcs;</span>
<span class="udiff-line-added">+   if (!_local_table-&gt;try_scan(Thread::current(), vcs)) {</span>
<span class="udiff-line-added">+     log_info(membername, table)(&quot;verify unavailable at this moment&quot;);</span>
    }
  }
<span class="udiff-line-removed">- #endif // INCLUDE_JVMTI</span>
</pre>
<center><a href="nativeLookup.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="resolvedMethodTable.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
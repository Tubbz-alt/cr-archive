<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRawMonitor.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,30 ***</span>
  #include &quot;aot/aotLoader.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/metadataOnStackMark.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;interpreter/rewriter.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/klassVtable.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiImpl.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
  #include &quot;prims/methodComparator.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/relocator.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-new-header">--- 26,35 ---</span>
  #include &quot;aot/aotLoader.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/metadataOnStackMark.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;interpreter/rewriter.hpp&quot;
<span class="line-added">+ #include &quot;jfr/jfrEvents.hpp&quot;</span>
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-added">+ #include &quot;oops/annotations.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/klassVtable.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/recordComponent.hpp&quot;</span>
  #include &quot;prims/jvmtiImpl.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
  #include &quot;prims/methodComparator.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/relocator.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
  int       VM_RedefineClasses::_matching_methods_length = 0;
  int       VM_RedefineClasses::_deleted_methods_length  = 0;
  int       VM_RedefineClasses::_added_methods_length    = 0;
  bool      VM_RedefineClasses::_has_redefined_Object = false;
  bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">! </span>
  
  VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                         const jvmtiClassDefinition *class_defs,
                                         JvmtiClassLoadKind class_load_kind) {
    _class_count = class_count;
<span class="line-new-header">--- 70,11 ---</span>
  int       VM_RedefineClasses::_matching_methods_length = 0;
  int       VM_RedefineClasses::_deleted_methods_length  = 0;
  int       VM_RedefineClasses::_added_methods_length    = 0;
  bool      VM_RedefineClasses::_has_redefined_Object = false;
  bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">! u8        VM_RedefineClasses::_id_counter = 0;</span>
  
  VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                         const jvmtiClassDefinition *class_defs,
                                         JvmtiClassLoadKind class_load_kind) {
    _class_count = class_count;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,47 ***</span>
    _any_class_has_resolved_methods = false;
    _res = JVMTI_ERROR_NONE;
    _the_class = NULL;
    _has_redefined_Object = false;
    _has_null_class_loader = false;
  }
  
  static inline InstanceKlass* get_ik(jclass def) {
    oop mirror = JNIHandles::resolve_non_null(def);
    return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  }
  
  // If any of the classes are being redefined, wait
  // Parallel constant pool merging leads to indeterminate constant pools.
  void VM_RedefineClasses::lock_classes() {
<span class="line-modified">!   MutexLocker ml(RedefineClasses_lock);</span>
    bool has_redefined;
    do {
      has_redefined = false;
      // Go through classes each time until none are being redefined.
      for (int i = 0; i &lt; _class_count; i++) {
        if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
<span class="line-modified">!         RedefineClasses_lock-&gt;wait();</span>
          has_redefined = true;
          break;  // for loop
        }
      }
    } while (has_redefined);
    for (int i = 0; i &lt; _class_count; i++) {
      get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
    }
<span class="line-modified">!   RedefineClasses_lock-&gt;notify_all();</span>
  }
  
  void VM_RedefineClasses::unlock_classes() {
<span class="line-modified">!   MutexLocker ml(RedefineClasses_lock);</span>
    for (int i = 0; i &lt; _class_count; i++) {
      assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
             &quot;should be being redefined to get here&quot;);
      get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
    }
<span class="line-modified">!   RedefineClasses_lock-&gt;notify_all();</span>
  }
  
  bool VM_RedefineClasses::doit_prologue() {
    if (_class_count == 0) {
      _res = JVMTI_ERROR_NONE;
<span class="line-new-header">--- 83,48 ---</span>
    _any_class_has_resolved_methods = false;
    _res = JVMTI_ERROR_NONE;
    _the_class = NULL;
    _has_redefined_Object = false;
    _has_null_class_loader = false;
<span class="line-added">+   _id = next_id();</span>
  }
  
  static inline InstanceKlass* get_ik(jclass def) {
    oop mirror = JNIHandles::resolve_non_null(def);
    return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  }
  
  // If any of the classes are being redefined, wait
  // Parallel constant pool merging leads to indeterminate constant pools.
  void VM_RedefineClasses::lock_classes() {
<span class="line-modified">!   MonitorLocker ml(RedefineClasses_lock);</span>
    bool has_redefined;
    do {
      has_redefined = false;
      // Go through classes each time until none are being redefined.
      for (int i = 0; i &lt; _class_count; i++) {
        if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
<span class="line-modified">!         ml.wait();</span>
          has_redefined = true;
          break;  // for loop
        }
      }
    } while (has_redefined);
    for (int i = 0; i &lt; _class_count; i++) {
      get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
    }
<span class="line-modified">!   ml.notify_all();</span>
  }
  
  void VM_RedefineClasses::unlock_classes() {
<span class="line-modified">!   MonitorLocker ml(RedefineClasses_lock);</span>
    for (int i = 0; i &lt; _class_count; i++) {
      assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
             &quot;should be being redefined to get here&quot;);
      get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
    }
<span class="line-modified">!   ml.notify_all();</span>
  }
  
  bool VM_RedefineClasses::doit_prologue() {
    if (_class_count == 0) {
      _res = JVMTI_ERROR_NONE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,11 ***</span>
    }
  #endif
  
    // Mark methods seen on stack and everywhere else so old methods are not
    // cleaned up if they&#39;re on the stack.
<span class="line-modified">!   MetadataOnStackMark md_on_stack(true);</span>
    HandleMark hm(thread);   // make sure any handles created are deleted
                             // before the stack walk again.
  
    for (int i = 0; i &lt; _class_count; i++) {
      redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
<span class="line-new-header">--- 211,11 ---</span>
    }
  #endif
  
    // Mark methods seen on stack and everywhere else so old methods are not
    // cleaned up if they&#39;re on the stack.
<span class="line-modified">!   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);</span>
    HandleMark hm(thread);   // make sure any handles created are deleted
                             // before the stack walk again.
  
    for (int i = 0; i &lt; _class_count; i++) {
      redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,16 ***</span>
    if (_any_class_has_resolved_methods) {
      bool trace_name_printed = false;
      ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
    }
  
<span class="line-modified">!   // Disable any dependent concurrent compilations</span>
<span class="line-removed">-   SystemDictionary::notice_modification();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Set flag indicating that some invariants are no longer true.</span>
    // See jvmtiExport.hpp for detailed explanation.
<span class="line-modified">!   JvmtiExport::set_has_redefined_a_class();</span>
  
    // check_class() is optionally called for product bits, but is
    // always called for non-product bits.
  #ifdef PRODUCT
    if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
<span class="line-new-header">--- 235,13 ---</span>
    if (_any_class_has_resolved_methods) {
      bool trace_name_printed = false;
      ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
    }
  
<span class="line-modified">!   // Increment flag indicating that some invariants are no longer true.</span>
    // See jvmtiExport.hpp for detailed explanation.
<span class="line-modified">!   JvmtiExport::increment_redefinition_count();</span>
  
    // check_class() is optionally called for product bits, but is
    // always called for non-product bits.
  #ifdef PRODUCT
    if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 785,10 ***</span>
<span class="line-new-header">--- 788,79 ---</span>
    }
  
    return JVMTI_ERROR_NONE;
  }
  
<span class="line-added">+ // Return an error status if the class Record attribute was changed.</span>
<span class="line-added">+ static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {</span>
<span class="line-added">+   // Get lists of record components.</span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();</span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();</span>
<span class="line-added">+   bool the_record_exists = the_record != NULL;</span>
<span class="line-added">+   bool scr_record_exists = scr_record != NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (the_record_exists &amp;&amp; scr_record_exists) {</span>
<span class="line-added">+     int the_num_components = the_record-&gt;length();</span>
<span class="line-added">+     int scr_num_components = scr_record-&gt;length();</span>
<span class="line-added">+     if (the_num_components != scr_num_components) {</span>
<span class="line-added">+       log_trace(redefine, class, record)</span>
<span class="line-added">+         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,</span>
<span class="line-added">+          the_class-&gt;external_name(), the_num_components, scr_num_components);</span>
<span class="line-added">+       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Compare each field in each record component.</span>
<span class="line-added">+     ConstantPool* the_cp =  the_class-&gt;constants();</span>
<span class="line-added">+     ConstantPool* scr_cp =  scratch_class-&gt;constants();</span>
<span class="line-added">+     for (int x = 0; x &lt; the_num_components; x++) {</span>
<span class="line-added">+       RecordComponent* the_component = the_record-&gt;at(x);</span>
<span class="line-added">+       RecordComponent* scr_component = scr_record-&gt;at(x);</span>
<span class="line-added">+       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());</span>
<span class="line-added">+       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());</span>
<span class="line-added">+       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());</span>
<span class="line-added">+       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());</span>
<span class="line-added">+       if (the_name != scr_name || the_descr != scr_descr) {</span>
<span class="line-added">+         log_trace(redefine, class, record)</span>
<span class="line-added">+           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,</span>
<span class="line-added">+            the_class-&gt;external_name());</span>
<span class="line-added">+         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       int the_gen_sig = the_component-&gt;generic_signature_index();</span>
<span class="line-added">+       int scr_gen_sig = scr_component-&gt;generic_signature_index();</span>
<span class="line-added">+       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :</span>
<span class="line-added">+         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));</span>
<span class="line-added">+       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :</span>
<span class="line-added">+         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));</span>
<span class="line-added">+       if (the_gen_sig_sym != scr_gen_sig_sym) {</span>
<span class="line-added">+         log_trace(redefine, class, record)</span>
<span class="line-added">+           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,</span>
<span class="line-added">+            the_class-&gt;external_name());</span>
<span class="line-added">+         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       // It&#39;s okay if a record component&#39;s annotations were changed.</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   } else if (the_record_exists ^ scr_record_exists) {</span>
<span class="line-added">+     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;</span>
<span class="line-added">+     log_trace(redefine, class, record)</span>
<span class="line-added">+       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,</span>
<span class="line-added">+        the_class-&gt;external_name(), action_str);</span>
<span class="line-added">+     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return JVMTI_ERROR_NONE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool can_add_or_delete(Method* m) {</span>
<span class="line-added">+       // Compatibility mode</span>
<span class="line-added">+   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;</span>
<span class="line-added">+           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
               InstanceKlass* the_class,
               InstanceKlass* scratch_class) {
    int i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,10 ***</span>
<span class="line-new-header">--- 904,16 ---</span>
    jvmtiError err = check_nest_attributes(the_class, scratch_class);
    if (err != JVMTI_ERROR_NONE) {
      return err;
    }
  
<span class="line-added">+   // Check whether the Record attribute has been changed.</span>
<span class="line-added">+   err = check_record_attribute(the_class, scratch_class);</span>
<span class="line-added">+   if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">+     return err;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Check whether class modifiers are the same.
    jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
    jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
    if (old_flags != new_flags) {
      return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,16 ***</span>
        ++oi;
        ++ni;
        break;
      case added:
        // method added, see if it is OK
<span class="line-modified">!       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();</span>
<span class="line-removed">-       if ((new_flags &amp; JVM_ACC_PRIVATE) == 0</span>
<span class="line-removed">-            // hack: private should be treated as final, but alas</span>
<span class="line-removed">-           || (new_flags &amp; (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0</span>
<span class="line-removed">-          ) {</span>
<span class="line-removed">-         // new methods must be private</span>
          return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
        }
        {
          u2 num = the_class-&gt;next_method_idnum();
          if (num == ConstMethod::UNSET_IDNUM) {
<span class="line-new-header">--- 1068,11 ---</span>
        ++oi;
        ++ni;
        break;
      case added:
        // method added, see if it is OK
<span class="line-modified">!       if (!can_add_or_delete(k_new_method)) {</span>
          return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
        }
        {
          u2 num = the_class-&gt;next_method_idnum();
          if (num == ConstMethod::UNSET_IDNUM) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,16 ***</span>
          (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
        ++ni; // advance to next new method
        break;
      case deleted:
        // method deleted, see if it is OK
<span class="line-modified">!       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();</span>
<span class="line-removed">-       if ((old_flags &amp; JVM_ACC_PRIVATE) == 0</span>
<span class="line-removed">-            // hack: private should be treated as final, but alas</span>
<span class="line-removed">-           || (old_flags &amp; (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0</span>
<span class="line-removed">-          ) {</span>
<span class="line-removed">-         // deleted methods must be private</span>
          return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
        }
        log_trace(redefine, class, normalize)
          (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
        ++oi; // advance to next old method
<span class="line-new-header">--- 1097,11 ---</span>
          (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
        ++ni; // advance to next new method
        break;
      case deleted:
        // method deleted, see if it is OK
<span class="line-modified">!       if (!can_add_or_delete(k_old_method)) {</span>
          return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
        }
        log_trace(redefine, class, normalize)
          (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
        ++oi; // advance to next old method
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1627,10 ***</span>
<span class="line-new-header">--- 1695,15 ---</span>
      // The merge can fail due to memory allocation failure or due
      // to robustness checks.
      return JVMTI_ERROR_INTERNAL;
    }
  
<span class="line-added">+   if (old_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-added">+     merge_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">+     scratch_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
  
    if (_index_map_count == 0) {
      // there is nothing to map between the new and merged constant pools
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1710,10 ***</span>
<span class="line-new-header">--- 1783,16 ---</span>
    if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
      // propagate failure back to caller
      return false;
    }
  
<span class="line-added">+   // rewrite constant pool references in the Record attribute:</span>
<span class="line-added">+   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {</span>
<span class="line-added">+     // propagate failure back to caller</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // rewrite constant pool references in the methods:
    if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
      // propagate failure back to caller
      return false;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1808,10 ***</span>
<span class="line-new-header">--- 1887,50 ---</span>
      nest_members-&gt;at_put(i, find_new_index(cp_index));
    }
    return true;
  }
  
<span class="line-added">+ // Rewrite constant pool references in the Record attribute.</span>
<span class="line-added">+ bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(</span>
<span class="line-added">+        InstanceKlass* scratch_class, TRAPS) {</span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();</span>
<span class="line-added">+   if (components != NULL) {</span>
<span class="line-added">+     for (int i = 0; i &lt; components-&gt;length(); i++) {</span>
<span class="line-added">+       RecordComponent* component = components-&gt;at(i);</span>
<span class="line-added">+       u2 cp_index = component-&gt;name_index();</span>
<span class="line-added">+       component-&gt;set_name_index(find_new_index(cp_index));</span>
<span class="line-added">+       cp_index = component-&gt;descriptor_index();</span>
<span class="line-added">+       component-&gt;set_descriptor_index(find_new_index(cp_index));</span>
<span class="line-added">+       cp_index = component-&gt;generic_signature_index();</span>
<span class="line-added">+       if (cp_index != 0) {</span>
<span class="line-added">+         component-&gt;set_generic_signature_index(find_new_index(cp_index));</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       AnnotationArray* annotations = component-&gt;annotations();</span>
<span class="line-added">+       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {</span>
<span class="line-added">+         int byte_i = 0;  // byte index into annotations</span>
<span class="line-added">+         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {</span>
<span class="line-added">+           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);</span>
<span class="line-added">+           // propagate failure back to caller</span>
<span class="line-added">+           return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       AnnotationArray* type_annotations = component-&gt;type_annotations();</span>
<span class="line-added">+       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {</span>
<span class="line-added">+         int byte_i = 0;  // byte index into annotations</span>
<span class="line-added">+         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {</span>
<span class="line-added">+           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);</span>
<span class="line-added">+           // propagate failure back to caller</span>
<span class="line-added">+           return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Rewrite constant pool references in the methods.
  bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
         InstanceKlass* scratch_class, TRAPS) {
  
    Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2165,18 ***</span>
    byte_i_ref++;
    log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
  
    switch (tag) {
      // These BaseType tag values are from Table 4.2 in VM spec:
<span class="line-modified">!     case &#39;B&#39;:  // byte</span>
<span class="line-modified">!     case &#39;C&#39;:  // char</span>
<span class="line-modified">!     case &#39;D&#39;:  // double</span>
<span class="line-modified">!     case &#39;F&#39;:  // float</span>
<span class="line-modified">!     case &#39;I&#39;:  // int</span>
<span class="line-modified">!     case &#39;J&#39;:  // long</span>
<span class="line-modified">!     case &#39;S&#39;:  // short</span>
<span class="line-modified">!     case &#39;Z&#39;:  // boolean</span>
  
      // The remaining tag values are from Table 4.8 in the 2nd-edition of
      // the VM spec:
      case &#39;s&#39;:
      {
<span class="line-new-header">--- 2284,18 ---</span>
    byte_i_ref++;
    log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
  
    switch (tag) {
      // These BaseType tag values are from Table 4.2 in VM spec:
<span class="line-modified">!     case JVM_SIGNATURE_BYTE:</span>
<span class="line-modified">!     case JVM_SIGNATURE_CHAR:</span>
<span class="line-modified">!     case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-modified">!     case JVM_SIGNATURE_FLOAT:</span>
<span class="line-modified">!     case JVM_SIGNATURE_INT:</span>
<span class="line-modified">!     case JVM_SIGNATURE_LONG:</span>
<span class="line-modified">!     case JVM_SIGNATURE_SHORT:</span>
<span class="line-modified">!     case JVM_SIGNATURE_BOOLEAN:</span>
  
      // The remaining tag values are from Table 4.8 in the 2nd-edition of
      // the VM spec:
      case &#39;s&#39;:
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2243,11 ***</span>
          // propagate failure back to caller
          return false;
        }
        break;
  
<span class="line-modified">!     case &#39;[&#39;:</span>
      {
        if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
          // not enough room for a num_values field
          log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
          return false;
<span class="line-new-header">--- 2362,11 ---</span>
          // propagate failure back to caller
          return false;
        }
        break;
  
<span class="line-modified">!     case JVM_SIGNATURE_ARRAY:</span>
      {
        if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
          // not enough room for a num_values field
          log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3250,10 ***</span>
<span class="line-new-header">--- 3369,14 ---</span>
  
    // attach klass to new constant pool
    // reference to the cp holder is needed for copy_operands()
    smaller_cp-&gt;set_pool_holder(scratch_class);
  
<span class="line-added">+   if (scratch_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-added">+     smaller_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      // Exception is handled in the caller
      loader_data-&gt;add_to_deallocate_list(smaller_cp());
      return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3487,16 ***</span>
      // has already been attached to the_class and old_cp has already
      // been added as a previous version. The new_cp doesn&#39;t have any
      // cached references to old methods so it doesn&#39;t need to be
      // updated. We can simply start with the previous version(s) in
      // that case.
<span class="line-removed">-     constantPoolHandle other_cp;</span>
      ConstantPoolCache* cp_cache;
  
      if (!ik-&gt;is_being_redefined()) {
        // this klass&#39; constant pool cache may need adjustment
<span class="line-modified">!       other_cp = constantPoolHandle(ik-&gt;constants());</span>
        cp_cache = other_cp-&gt;cache();
        if (cp_cache != NULL) {
          cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
        }
      }
<span class="line-new-header">--- 3610,15 ---</span>
      // has already been attached to the_class and old_cp has already
      // been added as a previous version. The new_cp doesn&#39;t have any
      // cached references to old methods so it doesn&#39;t need to be
      // updated. We can simply start with the previous version(s) in
      // that case.
      ConstantPoolCache* cp_cache;
  
      if (!ik-&gt;is_being_redefined()) {
        // this klass&#39; constant pool cache may need adjustment
<span class="line-modified">!       ConstantPool* other_cp = ik-&gt;constants();</span>
        cp_cache = other_cp-&gt;cache();
        if (cp_cache != NULL) {
          cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3511,31 ***</span>
        }
      }
    }
  }
  
<span class="line-modified">! void VM_RedefineClasses::update_jmethod_ids() {</span>
    for (int j = 0; j &lt; _matching_methods_length; ++j) {
      Method* old_method = _matching_old_methods[j];
      jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
      if (jmid != NULL) {
        // There is a jmethodID, change it to point to the new method
<span class="line-modified">!       methodHandle new_method_h(_matching_new_methods[j]);</span>
        Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
        assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
               &quot;should be replaced&quot;);
      }
    }
<span class="line-removed">-   // Update deleted jmethodID</span>
<span class="line-removed">-   for (int j = 0; j &lt; _deleted_methods_length; ++j) {</span>
<span class="line-removed">-     Method* old_method = _deleted_methods[j];</span>
<span class="line-removed">-     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();</span>
<span class="line-removed">-     if (jmid != NULL) {</span>
<span class="line-removed">-       // Change the jmethodID to point to NSME.</span>
<span class="line-removed">-       Method::change_method_associated_with_jmethod_id(jmid, Universe::throw_no_such_method_error());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
  int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
    int emcp_method_count = 0;
    int obsolete_count = 0;
<span class="line-new-header">--- 3633,22 ---</span>
        }
      }
    }
  }
  
<span class="line-modified">! void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {</span>
    for (int j = 0; j &lt; _matching_methods_length; ++j) {
      Method* old_method = _matching_old_methods[j];
      jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
      if (jmid != NULL) {
        // There is a jmethodID, change it to point to the new method
<span class="line-modified">!       methodHandle new_method_h(thread, _matching_new_methods[j]);</span>
        Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
        assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
               &quot;should be replaced&quot;);
      }
    }
  }
  
  int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
    int emcp_method_count = 0;
    int obsolete_count = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3840,11 ***</span>
    bool deopt_needed;
  
    // This is the first redefinition, mark all the nmethods for deoptimization
    if (!JvmtiExport::all_dependencies_are_recorded()) {
      log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
<span class="line-modified">!     CodeCache::mark_all_nmethods_for_deoptimization();</span>
      deopt_needed = true;
    } else {
      int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
      log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
      deopt_needed = (deopt != 0);
<span class="line-new-header">--- 3953,11 ---</span>
    bool deopt_needed;
  
    // This is the first redefinition, mark all the nmethods for deoptimization
    if (!JvmtiExport::all_dependencies_are_recorded()) {
      log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
<span class="line-modified">!     CodeCache::mark_all_nmethods_for_evol_deoptimization();</span>
      deopt_needed = true;
    } else {
      int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
      log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
      deopt_needed = (deopt != 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3965,11 ***</span>
  
    _old_methods = the_class-&gt;methods();
    _new_methods = scratch_class-&gt;methods();
    _the_class = the_class;
    compute_added_deleted_matching_methods();
<span class="line-modified">!   update_jmethod_ids();</span>
  
    _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
  
    // Attach new constant pool to the original klass. The original
    // klass still refers to the old constant pool (for now).
<span class="line-new-header">--- 4078,11 ---</span>
  
    _old_methods = the_class-&gt;methods();
    _new_methods = scratch_class-&gt;methods();
    _the_class = the_class;
    compute_added_deleted_matching_methods();
<span class="line-modified">!   update_jmethod_ids(THREAD);</span>
  
    _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
  
    // Attach new constant pool to the original klass. The original
    // klass still refers to the old constant pool (for now).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4182,10 ***</span>
<span class="line-new-header">--- 4295,19 ---</span>
      // so that obsolete methods are not pinned.
      the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
    }
  
    increment_class_counter((InstanceKlass *)the_class, THREAD);
<span class="line-added">+ </span>
<span class="line-added">+   if (EventClassRedefinition::is_enabled()) {</span>
<span class="line-added">+     EventClassRedefinition event;</span>
<span class="line-added">+     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));</span>
<span class="line-added">+     event.set_redefinedClass(the_class);</span>
<span class="line-added">+     event.set_redefinitionId(_id);</span>
<span class="line-added">+     event.commit();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    {
      ResourceMark rm(THREAD);
      // increment the classRedefinedCount field in the_class and in any
      // direct and indirect subclasses of the_class
      log_info(redefine, class, load)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4195,10 ***</span>
<span class="line-new-header">--- 4317,11 ---</span>
                               the_class-&gt;external_name(),
                               java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
  
    }
    _timer_rsc_phase2.stop();
<span class="line-added">+ </span>
  } // end redefine_single_class()
  
  
  // Increment the classRedefinedCount field in the specific InstanceKlass
  // and in all direct and indirect subclasses.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4281,10 ***</span>
<span class="line-new-header">--- 4404,20 ---</span>
      }
      guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
    }
  }
  
<span class="line-added">+ u8 VM_RedefineClasses::next_id() {</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     u8 id = _id_counter;</span>
<span class="line-added">+     u8 next_id = id + 1;</span>
<span class="line-added">+     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);</span>
<span class="line-added">+     if (result == id) {</span>
<span class="line-added">+       return next_id;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  void VM_RedefineClasses::dump_methods() {
    int j;
    log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
    for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
</pre>
<center><a href="jvmtiRawMonitor.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/nativeLookup.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/nativeLookup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;

 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;


 29 #include &quot;memory/oopFactory.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed"> 31 #include &quot;memory/universe.hpp&quot;</span>
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;prims/jvm_misc.hpp&quot;
 37 #include &quot;prims/nativeLookup.hpp&quot;
 38 #include &quot;prims/unsafe.hpp&quot;
 39 #include &quot;runtime/arguments.hpp&quot;
 40 #include &quot;runtime/handles.inline.hpp&quot;

 41 #include &quot;runtime/javaCalls.hpp&quot;
 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/signature.hpp&quot;
 45 #include &quot;utilities/macros.hpp&quot;

 46 #if INCLUDE_JFR
 47 #include &quot;jfr/jfr.hpp&quot;
 48 #endif
 49 
 50 static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
 51   char* bytes = (char*)name-&gt;bytes() + begin;
 52   char* end_bytes = (char*)name-&gt;bytes() + end;
 53   while (bytes &lt; end_bytes) {
 54     jchar c;
 55     bytes = UTF8::next(bytes, &amp;c);
 56     if (c &lt;= 0x7f &amp;&amp; isalnum(c)) {
 57       st-&gt;put((char) c);
 58     } else {
 59            if (c == &#39;_&#39;) st-&gt;print(&quot;_1&quot;);
 60       else if (c == &#39;/&#39;) st-&gt;print(&quot;_&quot;);
 61       else if (c == &#39;;&#39;) st-&gt;print(&quot;_2&quot;);
 62       else if (c == &#39;[&#39;) st-&gt;print(&quot;_3&quot;);
 63       else               st-&gt;print(&quot;_%.5x&quot;, c);
 64     }
 65   }
</pre>
<hr />
<pre>
 87 char* NativeLookup::critical_jni_name(const methodHandle&amp; method) {
 88   stringStream st;
 89   // Prefix
 90   st.print(&quot;JavaCritical_&quot;);
 91   // Klass name
 92   mangle_name_on(&amp;st, method-&gt;klass_name());
 93   st.print(&quot;_&quot;);
 94   // Method name
 95   mangle_name_on(&amp;st, method-&gt;name());
 96   return st.as_string();
 97 }
 98 
 99 
100 char* NativeLookup::long_jni_name(const methodHandle&amp; method) {
101   // Signature ignore the wrapping parenteses and the trailing return type
102   stringStream st;
103   Symbol* signature = method-&gt;signature();
104   st.print(&quot;__&quot;);
105   // find &#39;)&#39;
106   int end;
<span class="line-modified">107   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != &#39;)&#39;; end++);</span>
108   // skip first &#39;(&#39;
109   mangle_name_on(&amp;st, signature, 1, end);
110   return st.as_string();
111 }
112 
113 extern &quot;C&quot; {
114   void JNICALL JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass unsafecls);
115   void JNICALL JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass);
116   void JNICALL JVM_RegisterWhiteBoxMethods(JNIEnv *env, jclass wbclass);
117 #if INCLUDE_JVMCI
118   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
119   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
120 #endif
121 }
122 
123 #define CC (char*)  /* cast a literal from (const char*) */
124 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
125 
126 static JNINativeMethod lookup_special_native_methods[] = {
127   { CC&quot;Java_jdk_internal_misc_Unsafe_registerNatives&quot;,             NULL, FN_PTR(JVM_RegisterJDKInternalMiscUnsafeMethods) },
128   { CC&quot;Java_java_lang_invoke_MethodHandleNatives_registerNatives&quot;, NULL, FN_PTR(JVM_RegisterMethodHandleMethods) },
129   { CC&quot;Java_jdk_internal_perf_Perf_registerNatives&quot;,               NULL, FN_PTR(JVM_RegisterPerfMethods)         },
130   { CC&quot;Java_sun_hotspot_WhiteBox_registerNatives&quot;,                 NULL, FN_PTR(JVM_RegisterWhiteBoxMethods)     },
131 #if INCLUDE_JVMCI
132   { CC&quot;Java_jdk_vm_ci_runtime_JVMCI_initializeRuntime&quot;,            NULL, FN_PTR(JVM_GetJVMCIRuntime)             },
133   { CC&quot;Java_jdk_vm_ci_hotspot_CompilerToVM_registerNatives&quot;,       NULL, FN_PTR(JVM_RegisterJVMCINatives)        },
134 #endif
135 #if INCLUDE_JFR
136   { CC&quot;Java_jdk_jfr_internal_JVM_registerNatives&quot;,                 NULL, FN_PTR(jfr_register_natives)            },
137 #endif
138 };
139 
<span class="line-modified">140 static address lookup_special_native(char* jni_name) {</span>
141   int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
142   for (int i = 0; i &lt; count; i++) {
143     // NB: To ignore the jni prefix and jni postfix strstr is used matching.
144     if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
145       return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
146     }
147   }
148   return NULL;
149 }
150 
151 address NativeLookup::lookup_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style, bool&amp; in_base_library, TRAPS) {
152   address entry;
<span class="line-modified">153   // Compute complete JNI name for style</span>
<span class="line-modified">154   stringStream st;</span>
<span class="line-removed">155   if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-removed">156   st.print_raw(pure_name);</span>
<span class="line-removed">157   st.print_raw(long_name);</span>
<span class="line-removed">158   if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-removed">159   char* jni_name = st.as_string();</span>
160 
161   // If the loader is null we have a system class, so we attempt a lookup in
162   // the native Java library. This takes care of any bootstrapping problems.
163   // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find
164   // gets found the first time around - otherwise an infinite loop can occure. This is
165   // another VM/library dependency
166   Handle loader(THREAD, method-&gt;method_holder()-&gt;class_loader());
167   if (loader.is_null()) {
168     entry = lookup_special_native(jni_name);
169     if (entry == NULL) {
170        entry = (address) os::dll_lookup(os::native_java_library(), jni_name);
171     }
172     if (entry != NULL) {
173       in_base_library = true;
174       return entry;
175     }
176   }
177 
178   // Otherwise call static method findNative in ClassLoader
179   Klass*   klass = SystemDictionary::ClassLoader_klass();
</pre>
<hr />
<pre>
187                          // Arguments
188                          loader,
189                          name_arg,
190                          CHECK_NULL);
191   entry = (address) (intptr_t) result.get_jlong();
192 
193   if (entry == NULL) {
194     // findNative didn&#39;t find it, if there are any agent libraries look in them
195     AgentLibrary* agent;
196     for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
197       entry = (address) os::dll_lookup(agent-&gt;os_lib(), jni_name);
198       if (entry != NULL) {
199         return entry;
200       }
201     }
202   }
203 
204   return entry;
205 }
206 
<span class="line-modified">207 </span>
<span class="line-modified">208 address NativeLookup::lookup_critical_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="line-modified">209   if (!method-&gt;has_native_function()) {</span>
<span class="line-modified">210     return NULL;</span>
211   }
212 
<span class="line-modified">213   address current_entry = method-&gt;native_function();</span>
<span class="line-modified">214 </span>
<span class="line-modified">215   char dll_name[JVM_MAXPATHLEN];</span>
<span class="line-modified">216   int offset;</span>
<span class="line-removed">217   if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {</span>
<span class="line-removed">218     char ebuf[32];</span>
<span class="line-removed">219     void* dll = os::dll_load(dll_name, ebuf, sizeof(ebuf));</span>
<span class="line-removed">220     if (dll != NULL) {</span>
<span class="line-removed">221       // Compute complete JNI name for style</span>
<span class="line-removed">222       stringStream st;</span>
<span class="line-removed">223       if (os_style) os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-removed">224       st.print_raw(pure_name);</span>
<span class="line-removed">225       st.print_raw(long_name);</span>
<span class="line-removed">226       if (os_style) os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-removed">227       char* jni_name = st.as_string();</span>
<span class="line-removed">228       address critical_entry = (address)os::dll_lookup(dll, jni_name);</span>
<span class="line-removed">229       // Close the handle to avoid keeping the library alive if the native method holder is unloaded.</span>
<span class="line-removed">230       // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon</span>
<span class="line-removed">231       // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper</span>
<span class="line-removed">232       // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.</span>
<span class="line-removed">233       os::dll_unload(dll);</span>
<span class="line-removed">234       return critical_entry;</span>
<span class="line-removed">235     }</span>
236   }
237 
<span class="line-modified">238   return NULL;</span>
239 }
240 





241 
242 // Check all the formats of native implementation name to see if there is one
243 // for the specified method.
244 address NativeLookup::lookup_entry(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
245   address entry = NULL;
246   in_base_library = false;
247   // Compute pure name
248   char* pure_name = pure_jni_name(method);
249 
250   // Compute argument size
251   int args_size = 1                             // JNIEnv
252                 + (method-&gt;is_static() ? 1 : 0) // class for static methods
253                 + method-&gt;size_of_parameters(); // actual parameters
254 
255   // 1) Try JNI short style
256   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, true,  in_base_library, CHECK_NULL);
257   if (entry != NULL) return entry;
258 
259   // Compute long name
260   char* long_name = long_jni_name(method);
261 
262   // 2) Try JNI long style
263   entry = lookup_style(method, pure_name, long_name, args_size, true,  in_base_library, CHECK_NULL);
264   if (entry != NULL) return entry;
265 
266   // 3) Try JNI short style without os prefix/suffix
267   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, false, in_base_library, CHECK_NULL);
268   if (entry != NULL) return entry;
269 
270   // 4) Try JNI long style without os prefix/suffix
271   entry = lookup_style(method, pure_name, long_name, args_size, false, in_base_library, CHECK_NULL);
272 
273   return entry; // NULL indicates not found
274 }
275 
276 // Check all the formats of native implementation name to see if there is one
277 // for the specified method.
278 address NativeLookup::lookup_critical_entry(const methodHandle&amp; method) {
<span class="line-modified">279   if (!CriticalJNINatives) return NULL;</span>
280 
281   if (method-&gt;is_synchronized() ||
282       !method-&gt;is_static()) {
283     // Only static non-synchronized methods are allowed
284     return NULL;
285   }
286 
287   ResourceMark rm;
<span class="line-removed">288   address entry = NULL;</span>
289 
290   Symbol* signature = method-&gt;signature();
291   for (int end = 0; end &lt; signature-&gt;utf8_length(); end++) {
292     if (signature-&gt;char_at(end) == &#39;L&#39;) {
293       // Don&#39;t allow object types
294       return NULL;
295     }
296   }
297 
<span class="line-removed">298   // Compute critical name</span>
<span class="line-removed">299   char* critical_name = critical_jni_name(method);</span>
<span class="line-removed">300 </span>
301   // Compute argument size
302   int args_size = method-&gt;size_of_parameters();
303   for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
304     if (ss.is_array()) {
305       args_size += T_INT_size; // array length parameter
306     }
307   }
308 






































309   // 1) Try JNI short style
<span class="line-modified">310   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, true);</span>
<span class="line-modified">311   if (entry != NULL) return entry;</span>


312 
<span class="line-modified">313   // Compute long name</span>
<span class="line-removed">314   char* long_name = long_jni_name(method);</span>
315 
316   // 2) Try JNI long style
<span class="line-modified">317   entry = lookup_critical_style(method, critical_name, long_name, args_size, true);</span>
<span class="line-modified">318   if (entry != NULL) return entry;</span>


319 
320   // 3) Try JNI short style without os prefix/suffix
<span class="line-modified">321   entry = lookup_critical_style(method, critical_name, &quot;&quot;,        args_size, false);</span>
<span class="line-modified">322   if (entry != NULL) return entry;</span>


323 
324   // 4) Try JNI long style without os prefix/suffix
<span class="line-modified">325   entry = lookup_critical_style(method, critical_name, long_name, args_size, false);</span>
<span class="line-removed">326 </span>
<span class="line-removed">327   return entry; // NULL indicates not found</span>
328 }
329 
330 // Check if there are any JVM TI prefixes which have been applied to the native method name.
331 // If any are found, remove them before attemping the look up of the
332 // native implementation again.
333 // See SetNativeMethodPrefix in the JVM TI Spec for more details.
334 address NativeLookup::lookup_entry_prefixed(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
335 #if INCLUDE_JVMTI
336   ResourceMark rm(THREAD);
337 
338   int prefix_count;
339   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
340   char* in_name = method-&gt;name()-&gt;as_C_string();
341   char* wrapper_name = in_name;
342   // last applied prefix will be first -- go backwards
343   for (int i = prefix_count-1; i &gt;= 0; i--) {
344     char* prefix = prefixes[i];
345     size_t prefix_len = strlen(prefix);
346     if (strncmp(prefix, wrapper_name, prefix_len) == 0) {
347       // has this prefix remove it
348       wrapper_name += prefix_len;
349     }
350   }
351   if (wrapper_name != in_name) {
352     // we have a name for a wrapping method
353     int wrapper_name_len = (int)strlen(wrapper_name);
354     TempNewSymbol wrapper_symbol = SymbolTable::probe(wrapper_name, wrapper_name_len);
355     if (wrapper_symbol != NULL) {
356       Klass* k = method-&gt;method_holder();
357       Method* wrapper_method = k-&gt;lookup_method(wrapper_symbol, method-&gt;signature());
358       if (wrapper_method != NULL &amp;&amp; !wrapper_method-&gt;is_native()) {
359         // we found a wrapper method, use its native entry
360         method-&gt;set_is_prefixed_native();
<span class="line-modified">361         return lookup_entry(wrapper_method, in_base_library, THREAD);</span>
362       }
363     }
364   }
365 #endif // INCLUDE_JVMTI
366   return NULL;
367 }
368 
369 address NativeLookup::lookup_base(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
370   address entry = NULL;
371   ResourceMark rm(THREAD);
372 
373   entry = lookup_entry(method, in_base_library, THREAD);
374   if (entry != NULL) return entry;
375 
376   // standard native method resolution has failed.  Check if there are any
377   // JVM TI prefixes which have been applied to the native method name.
378   entry = lookup_entry_prefixed(method, in_base_library, THREAD);
379   if (entry != NULL) return entry;
380 
381   // Native function not found, throw UnsatisfiedLinkError
<span class="line-modified">382   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(),</span>
<span class="line-modified">383               method-&gt;name_and_sig_as_C_string());</span>



384 }
385 
386 
387 address NativeLookup::lookup(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
388   if (!method-&gt;has_native_function()) {
389     address entry = lookup_base(method, in_base_library, CHECK_NULL);
390     method-&gt;set_native_function(entry,
391       Method::native_bind_event_is_interesting);
392     // -verbose:jni printing
<span class="line-modified">393     if (PrintJNIResolving) {</span>
394       ResourceMark rm(THREAD);
<span class="line-modified">395       tty-&gt;print_cr(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="line-modified">396         method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-modified">397         method-&gt;name()-&gt;as_C_string());</span>
398     }
399   }
400   return method-&gt;native_function();
401 }
402 
403 address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
404   EXCEPTION_MARK;
405   bool in_base_library = true;  // SharedRuntime inits some math methods.
<span class="line-modified">406   TempNewSymbol c_name = SymbolTable::new_symbol(class_name,  CATCH);</span>
<span class="line-modified">407   TempNewSymbol m_name = SymbolTable::new_symbol(method_name, CATCH);</span>
<span class="line-modified">408   TempNewSymbol s_name = SymbolTable::new_symbol(signature,   CATCH);</span>
409 
410   // Find the class
411   Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
412   InstanceKlass* klass  = InstanceKlass::cast(k);
413 
414   // Find method and invoke standard lookup
415   methodHandle method (THREAD,
416                        klass-&gt;uncached_lookup_method(m_name, s_name, Klass::find_overpass));
417   address result = lookup(method, in_base_library, CATCH);
418   assert(in_base_library, &quot;must be in basic library&quot;);
419   guarantee(result != NULL, &quot;must be non NULL&quot;);
420   return result;
421 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
<span class="line-added"> 27 #include &quot;classfile/symbolTable.hpp&quot;</span>
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;classfile/vmSymbols.hpp&quot;
<span class="line-added"> 30 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;logging/logTag.hpp&quot;</span>
 32 #include &quot;memory/oopFactory.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;

 34 #include &quot;oops/instanceKlass.hpp&quot;
 35 #include &quot;oops/method.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/symbol.hpp&quot;
 38 #include &quot;prims/jvm_misc.hpp&quot;
 39 #include &quot;prims/nativeLookup.hpp&quot;
 40 #include &quot;prims/unsafe.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added"> 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 44 #include &quot;runtime/javaCalls.hpp&quot;
 45 #include &quot;runtime/os.inline.hpp&quot;
 46 #include &quot;runtime/sharedRuntime.hpp&quot;
 47 #include &quot;runtime/signature.hpp&quot;
 48 #include &quot;utilities/macros.hpp&quot;
<span class="line-added"> 49 #include &quot;utilities/utf8.hpp&quot;</span>
 50 #if INCLUDE_JFR
 51 #include &quot;jfr/jfr.hpp&quot;
 52 #endif
 53 
 54 static void mangle_name_on(outputStream* st, Symbol* name, int begin, int end) {
 55   char* bytes = (char*)name-&gt;bytes() + begin;
 56   char* end_bytes = (char*)name-&gt;bytes() + end;
 57   while (bytes &lt; end_bytes) {
 58     jchar c;
 59     bytes = UTF8::next(bytes, &amp;c);
 60     if (c &lt;= 0x7f &amp;&amp; isalnum(c)) {
 61       st-&gt;put((char) c);
 62     } else {
 63            if (c == &#39;_&#39;) st-&gt;print(&quot;_1&quot;);
 64       else if (c == &#39;/&#39;) st-&gt;print(&quot;_&quot;);
 65       else if (c == &#39;;&#39;) st-&gt;print(&quot;_2&quot;);
 66       else if (c == &#39;[&#39;) st-&gt;print(&quot;_3&quot;);
 67       else               st-&gt;print(&quot;_%.5x&quot;, c);
 68     }
 69   }
</pre>
<hr />
<pre>
 91 char* NativeLookup::critical_jni_name(const methodHandle&amp; method) {
 92   stringStream st;
 93   // Prefix
 94   st.print(&quot;JavaCritical_&quot;);
 95   // Klass name
 96   mangle_name_on(&amp;st, method-&gt;klass_name());
 97   st.print(&quot;_&quot;);
 98   // Method name
 99   mangle_name_on(&amp;st, method-&gt;name());
100   return st.as_string();
101 }
102 
103 
104 char* NativeLookup::long_jni_name(const methodHandle&amp; method) {
105   // Signature ignore the wrapping parenteses and the trailing return type
106   stringStream st;
107   Symbol* signature = method-&gt;signature();
108   st.print(&quot;__&quot;);
109   // find &#39;)&#39;
110   int end;
<span class="line-modified">111   for (end = 0; end &lt; signature-&gt;utf8_length() &amp;&amp; signature-&gt;char_at(end) != JVM_SIGNATURE_ENDFUNC; end++);</span>
112   // skip first &#39;(&#39;
113   mangle_name_on(&amp;st, signature, 1, end);
114   return st.as_string();
115 }
116 
117 extern &quot;C&quot; {
118   void JNICALL JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass unsafecls);
119   void JNICALL JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass);
120   void JNICALL JVM_RegisterWhiteBoxMethods(JNIEnv *env, jclass wbclass);
121 #if INCLUDE_JVMCI
122   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
123   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
124 #endif
125 }
126 
127 #define CC (char*)  /* cast a literal from (const char*) */
128 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
129 
130 static JNINativeMethod lookup_special_native_methods[] = {
131   { CC&quot;Java_jdk_internal_misc_Unsafe_registerNatives&quot;,             NULL, FN_PTR(JVM_RegisterJDKInternalMiscUnsafeMethods) },
132   { CC&quot;Java_java_lang_invoke_MethodHandleNatives_registerNatives&quot;, NULL, FN_PTR(JVM_RegisterMethodHandleMethods) },
133   { CC&quot;Java_jdk_internal_perf_Perf_registerNatives&quot;,               NULL, FN_PTR(JVM_RegisterPerfMethods)         },
134   { CC&quot;Java_sun_hotspot_WhiteBox_registerNatives&quot;,                 NULL, FN_PTR(JVM_RegisterWhiteBoxMethods)     },
135 #if INCLUDE_JVMCI
136   { CC&quot;Java_jdk_vm_ci_runtime_JVMCI_initializeRuntime&quot;,            NULL, FN_PTR(JVM_GetJVMCIRuntime)             },
137   { CC&quot;Java_jdk_vm_ci_hotspot_CompilerToVM_registerNatives&quot;,       NULL, FN_PTR(JVM_RegisterJVMCINatives)        },
138 #endif
139 #if INCLUDE_JFR
140   { CC&quot;Java_jdk_jfr_internal_JVM_registerNatives&quot;,                 NULL, FN_PTR(jfr_register_natives)            },
141 #endif
142 };
143 
<span class="line-modified">144 static address lookup_special_native(const char* jni_name) {</span>
145   int count = sizeof(lookup_special_native_methods) / sizeof(JNINativeMethod);
146   for (int i = 0; i &lt; count; i++) {
147     // NB: To ignore the jni prefix and jni postfix strstr is used matching.
148     if (strstr(jni_name, lookup_special_native_methods[i].name) != NULL) {
149       return CAST_FROM_FN_PTR(address, lookup_special_native_methods[i].fnPtr);
150     }
151   }
152   return NULL;
153 }
154 
155 address NativeLookup::lookup_style(const methodHandle&amp; method, char* pure_name, const char* long_name, int args_size, bool os_style, bool&amp; in_base_library, TRAPS) {
156   address entry;
<span class="line-modified">157   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);</span>
<span class="line-modified">158 </span>





159 
160   // If the loader is null we have a system class, so we attempt a lookup in
161   // the native Java library. This takes care of any bootstrapping problems.
162   // Note: It is critical for bootstrapping that Java_java_lang_ClassLoader_00024NativeLibrary_find
163   // gets found the first time around - otherwise an infinite loop can occure. This is
164   // another VM/library dependency
165   Handle loader(THREAD, method-&gt;method_holder()-&gt;class_loader());
166   if (loader.is_null()) {
167     entry = lookup_special_native(jni_name);
168     if (entry == NULL) {
169        entry = (address) os::dll_lookup(os::native_java_library(), jni_name);
170     }
171     if (entry != NULL) {
172       in_base_library = true;
173       return entry;
174     }
175   }
176 
177   // Otherwise call static method findNative in ClassLoader
178   Klass*   klass = SystemDictionary::ClassLoader_klass();
</pre>
<hr />
<pre>
186                          // Arguments
187                          loader,
188                          name_arg,
189                          CHECK_NULL);
190   entry = (address) (intptr_t) result.get_jlong();
191 
192   if (entry == NULL) {
193     // findNative didn&#39;t find it, if there are any agent libraries look in them
194     AgentLibrary* agent;
195     for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
196       entry = (address) os::dll_lookup(agent-&gt;os_lib(), jni_name);
197       if (entry != NULL) {
198         return entry;
199       }
200     }
201   }
202 
203   return entry;
204 }
205 
<span class="line-modified">206 const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="line-modified">207   stringStream st;</span>
<span class="line-modified">208   if (os_style) {</span>
<span class="line-modified">209     os::print_jni_name_prefix_on(&amp;st, args_size);</span>
210   }
211 
<span class="line-modified">212   st.print_raw(pure_name);</span>
<span class="line-modified">213   st.print_raw(long_name);</span>
<span class="line-modified">214   if (os_style) {</span>
<span class="line-modified">215     os::print_jni_name_suffix_on(&amp;st, args_size);</span>



















216   }
217 
<span class="line-modified">218   return st.as_string();</span>
219 }
220 
<span class="line-added">221 address NativeLookup::lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style) {</span>
<span class="line-added">222   const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);</span>
<span class="line-added">223   assert(dll != NULL, &quot;dll must be loaded&quot;);</span>
<span class="line-added">224   return (address)os::dll_lookup(dll, jni_name);</span>
<span class="line-added">225 }</span>
226 
227 // Check all the formats of native implementation name to see if there is one
228 // for the specified method.
229 address NativeLookup::lookup_entry(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
230   address entry = NULL;
231   in_base_library = false;
232   // Compute pure name
233   char* pure_name = pure_jni_name(method);
234 
235   // Compute argument size
236   int args_size = 1                             // JNIEnv
237                 + (method-&gt;is_static() ? 1 : 0) // class for static methods
238                 + method-&gt;size_of_parameters(); // actual parameters
239 
240   // 1) Try JNI short style
241   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, true,  in_base_library, CHECK_NULL);
242   if (entry != NULL) return entry;
243 
244   // Compute long name
245   char* long_name = long_jni_name(method);
246 
247   // 2) Try JNI long style
248   entry = lookup_style(method, pure_name, long_name, args_size, true,  in_base_library, CHECK_NULL);
249   if (entry != NULL) return entry;
250 
251   // 3) Try JNI short style without os prefix/suffix
252   entry = lookup_style(method, pure_name, &quot;&quot;,        args_size, false, in_base_library, CHECK_NULL);
253   if (entry != NULL) return entry;
254 
255   // 4) Try JNI long style without os prefix/suffix
256   entry = lookup_style(method, pure_name, long_name, args_size, false, in_base_library, CHECK_NULL);
257 
258   return entry; // NULL indicates not found
259 }
260 
261 // Check all the formats of native implementation name to see if there is one
262 // for the specified method.
263 address NativeLookup::lookup_critical_entry(const methodHandle&amp; method) {
<span class="line-modified">264   assert(CriticalJNINatives, &quot;or should not be here&quot;);</span>
265 
266   if (method-&gt;is_synchronized() ||
267       !method-&gt;is_static()) {
268     // Only static non-synchronized methods are allowed
269     return NULL;
270   }
271 
272   ResourceMark rm;

273 
274   Symbol* signature = method-&gt;signature();
275   for (int end = 0; end &lt; signature-&gt;utf8_length(); end++) {
276     if (signature-&gt;char_at(end) == &#39;L&#39;) {
277       // Don&#39;t allow object types
278       return NULL;
279     }
280   }
281 



282   // Compute argument size
283   int args_size = method-&gt;size_of_parameters();
284   for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {
285     if (ss.is_array()) {
286       args_size += T_INT_size; // array length parameter
287     }
288   }
289 
<span class="line-added">290   // dll handling requires I/O. Don&#39;t do that while in _thread_in_vm (safepoint may get requested).</span>
<span class="line-added">291   ThreadToNativeFromVM thread_in_native(JavaThread::current());</span>
<span class="line-added">292 </span>
<span class="line-added">293   void* dll = dll_load(method);</span>
<span class="line-added">294   address entry = NULL;</span>
<span class="line-added">295 </span>
<span class="line-added">296   if (dll != NULL) {</span>
<span class="line-added">297     entry = lookup_critical_style(dll, method, args_size);</span>
<span class="line-added">298     // Close the handle to avoid keeping the library alive if the native method holder is unloaded.</span>
<span class="line-added">299     // This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon</span>
<span class="line-added">300     // as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper</span>
<span class="line-added">301     // that calls &#39;critical_entry&#39; becomes unreachable and is unloaded as well.</span>
<span class="line-added">302     os::dll_unload(dll);</span>
<span class="line-added">303   }</span>
<span class="line-added">304 </span>
<span class="line-added">305   return entry; // NULL indicates not found</span>
<span class="line-added">306 }</span>
<span class="line-added">307 </span>
<span class="line-added">308 void* NativeLookup::dll_load(const methodHandle&amp; method) {</span>
<span class="line-added">309   if (method-&gt;has_native_function()) {</span>
<span class="line-added">310 </span>
<span class="line-added">311     address current_entry = method-&gt;native_function();</span>
<span class="line-added">312 </span>
<span class="line-added">313     char dll_name[JVM_MAXPATHLEN];</span>
<span class="line-added">314     int offset;</span>
<span class="line-added">315     if (os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &amp;offset)) {</span>
<span class="line-added">316       char ebuf[32];</span>
<span class="line-added">317       return os::dll_load(dll_name, ebuf, sizeof(ebuf));</span>
<span class="line-added">318     }</span>
<span class="line-added">319   }</span>
<span class="line-added">320 </span>
<span class="line-added">321   return NULL;</span>
<span class="line-added">322 }</span>
<span class="line-added">323 </span>
<span class="line-added">324 address NativeLookup::lookup_critical_style(void* dll, const methodHandle&amp; method, int args_size) {</span>
<span class="line-added">325   address entry = NULL;</span>
<span class="line-added">326   const char* critical_name = critical_jni_name(method);</span>
<span class="line-added">327 </span>
328   // 1) Try JNI short style
<span class="line-modified">329   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, true);</span>
<span class="line-modified">330   if (entry != NULL) {</span>
<span class="line-added">331     return entry;</span>
<span class="line-added">332   }</span>
333 
<span class="line-modified">334   const char* long_name = long_jni_name(method);</span>

335 
336   // 2) Try JNI long style
<span class="line-modified">337   entry = lookup_critical_style(dll, critical_name, long_name, args_size, true);</span>
<span class="line-modified">338   if (entry != NULL) {</span>
<span class="line-added">339     return entry;</span>
<span class="line-added">340   }</span>
341 
342   // 3) Try JNI short style without os prefix/suffix
<span class="line-modified">343   entry = lookup_critical_style(dll, critical_name, &quot;&quot;,        args_size, false);</span>
<span class="line-modified">344   if (entry != NULL) {</span>
<span class="line-added">345     return entry;</span>
<span class="line-added">346   }</span>
347 
348   // 4) Try JNI long style without os prefix/suffix
<span class="line-modified">349   return lookup_critical_style(dll, critical_name, long_name, args_size, false);</span>


350 }
351 
352 // Check if there are any JVM TI prefixes which have been applied to the native method name.
353 // If any are found, remove them before attemping the look up of the
354 // native implementation again.
355 // See SetNativeMethodPrefix in the JVM TI Spec for more details.
356 address NativeLookup::lookup_entry_prefixed(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
357 #if INCLUDE_JVMTI
358   ResourceMark rm(THREAD);
359 
360   int prefix_count;
361   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
362   char* in_name = method-&gt;name()-&gt;as_C_string();
363   char* wrapper_name = in_name;
364   // last applied prefix will be first -- go backwards
365   for (int i = prefix_count-1; i &gt;= 0; i--) {
366     char* prefix = prefixes[i];
367     size_t prefix_len = strlen(prefix);
368     if (strncmp(prefix, wrapper_name, prefix_len) == 0) {
369       // has this prefix remove it
370       wrapper_name += prefix_len;
371     }
372   }
373   if (wrapper_name != in_name) {
374     // we have a name for a wrapping method
375     int wrapper_name_len = (int)strlen(wrapper_name);
376     TempNewSymbol wrapper_symbol = SymbolTable::probe(wrapper_name, wrapper_name_len);
377     if (wrapper_symbol != NULL) {
378       Klass* k = method-&gt;method_holder();
379       Method* wrapper_method = k-&gt;lookup_method(wrapper_symbol, method-&gt;signature());
380       if (wrapper_method != NULL &amp;&amp; !wrapper_method-&gt;is_native()) {
381         // we found a wrapper method, use its native entry
382         method-&gt;set_is_prefixed_native();
<span class="line-modified">383         return lookup_entry(methodHandle(THREAD, wrapper_method), in_base_library, THREAD);</span>
384       }
385     }
386   }
387 #endif // INCLUDE_JVMTI
388   return NULL;
389 }
390 
391 address NativeLookup::lookup_base(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
392   address entry = NULL;
393   ResourceMark rm(THREAD);
394 
395   entry = lookup_entry(method, in_base_library, THREAD);
396   if (entry != NULL) return entry;
397 
398   // standard native method resolution has failed.  Check if there are any
399   // JVM TI prefixes which have been applied to the native method name.
400   entry = lookup_entry_prefixed(method, in_base_library, THREAD);
401   if (entry != NULL) return entry;
402 
403   // Native function not found, throw UnsatisfiedLinkError
<span class="line-modified">404   stringStream ss;</span>
<span class="line-modified">405   ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">406   method-&gt;print_external_name(&amp;ss);</span>
<span class="line-added">407   ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">408   THROW_MSG_0(vmSymbols::java_lang_UnsatisfiedLinkError(), ss.as_string());</span>
409 }
410 
411 
412 address NativeLookup::lookup(const methodHandle&amp; method, bool&amp; in_base_library, TRAPS) {
413   if (!method-&gt;has_native_function()) {
414     address entry = lookup_base(method, in_base_library, CHECK_NULL);
415     method-&gt;set_native_function(entry,
416       Method::native_bind_event_is_interesting);
417     // -verbose:jni printing
<span class="line-modified">418     if (log_is_enabled(Debug, jni, resolve)) {</span>
419       ResourceMark rm(THREAD);
<span class="line-modified">420       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="line-modified">421                               method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-modified">422                               method-&gt;name()-&gt;as_C_string());</span>
423     }
424   }
425   return method-&gt;native_function();
426 }
427 
428 address NativeLookup::base_library_lookup(const char* class_name, const char* method_name, const char* signature) {
429   EXCEPTION_MARK;
430   bool in_base_library = true;  // SharedRuntime inits some math methods.
<span class="line-modified">431   TempNewSymbol c_name = SymbolTable::new_symbol(class_name);</span>
<span class="line-modified">432   TempNewSymbol m_name = SymbolTable::new_symbol(method_name);</span>
<span class="line-modified">433   TempNewSymbol s_name = SymbolTable::new_symbol(signature);</span>
434 
435   // Find the class
436   Klass* k = SystemDictionary::resolve_or_fail(c_name, true, CATCH);
437   InstanceKlass* klass  = InstanceKlass::cast(k);
438 
439   // Find method and invoke standard lookup
440   methodHandle method (THREAD,
441                        klass-&gt;uncached_lookup_method(m_name, s_name, Klass::find_overpass));
442   address result = lookup(method, in_base_library, CATCH);
443   assert(in_base_library, &quot;must be in basic library&quot;);
444   guarantee(result != NULL, &quot;must be non NULL&quot;);
445   return result;
446 }
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
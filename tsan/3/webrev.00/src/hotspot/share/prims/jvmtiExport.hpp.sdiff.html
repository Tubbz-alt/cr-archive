<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiExport.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiExport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExtensions.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiExport.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 74 
 75   static bool        _can_access_local_variables;
 76   static bool        _can_hotswap_or_post_breakpoint;
 77   static bool        _can_modify_any_class;
 78   static bool        _can_walk_any_space;
 79 #endif // INCLUDE_JVMTI
 80 
 81   JVMTI_SUPPORT_FLAG(can_get_source_debug_extension)
 82   JVMTI_SUPPORT_FLAG(can_maintain_original_method_order)
 83   JVMTI_SUPPORT_FLAG(can_post_interpreter_events)
 84   JVMTI_SUPPORT_FLAG(can_post_on_exceptions)
 85   JVMTI_SUPPORT_FLAG(can_post_breakpoint)
 86   JVMTI_SUPPORT_FLAG(can_post_field_access)
 87   JVMTI_SUPPORT_FLAG(can_post_field_modification)
 88   JVMTI_SUPPORT_FLAG(can_post_method_entry)
 89   JVMTI_SUPPORT_FLAG(can_post_method_exit)
 90   JVMTI_SUPPORT_FLAG(can_pop_frame)
 91   JVMTI_SUPPORT_FLAG(can_force_early_return)
 92 
 93   JVMTI_SUPPORT_FLAG(early_vmstart_recorded)

 94 
 95   friend class JvmtiEventControllerPrivate;  // should only modify these flags
 96   JVMTI_SUPPORT_FLAG(should_post_single_step)
 97   JVMTI_SUPPORT_FLAG(should_post_field_access)
 98   JVMTI_SUPPORT_FLAG(should_post_field_modification)
 99   JVMTI_SUPPORT_FLAG(should_post_class_load)
100   JVMTI_SUPPORT_FLAG(should_post_class_prepare)
101   JVMTI_SUPPORT_FLAG(should_post_class_unload)
102   JVMTI_SUPPORT_FLAG(should_post_native_method_bind)
103   JVMTI_SUPPORT_FLAG(should_post_compiled_method_load)
104   JVMTI_SUPPORT_FLAG(should_post_compiled_method_unload)
105   JVMTI_SUPPORT_FLAG(should_post_dynamic_code_generated)
106   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_enter)
107   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_entered)
108   JVMTI_SUPPORT_FLAG(should_post_monitor_wait)
109   JVMTI_SUPPORT_FLAG(should_post_monitor_waited)
110   JVMTI_SUPPORT_FLAG(should_post_data_dump)
111   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_start)
112   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_finish)
113   JVMTI_SUPPORT_FLAG(should_post_on_exceptions)
</pre>
<hr />
<pre>
142   inline static void set_can_walk_any_space(bool on) {
143     JVMTI_ONLY(_can_walk_any_space = (on != 0);)
144   }
145 
146   enum {
147     JVMTI_VERSION_MASK   = 0x70000000,
148     JVMTI_VERSION_VALUE  = 0x30000000,
149     JVMDI_VERSION_VALUE  = 0x20000000
150   };
151 
152   static void post_field_modification(JavaThread *thread, Method* method, address location,
153                                       Klass* field_klass, Handle object, jfieldID field,
154                                       char sig_type, jvalue *value);
155 
156 
157   // posts a DynamicCodeGenerated event (internal/private implementation).
158   // The public post_dynamic_code_generated* functions make use of the
159   // internal implementation.  Also called from JvmtiDeferredEvent::post()
160   static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
161 

162  private:
163 
164   // GenerateEvents support to allow posting of CompiledMethodLoad and
165   // DynamicCodeGenerated events for a given environment.
166   friend class JvmtiCodeBlobEvents;
167 
<span class="line-removed">168   static void post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-removed">169                                         const void *code_begin, const jint map_length,</span>
<span class="line-removed">170                                         const jvmtiAddrLocationMap* map) NOT_JVMTI_RETURN;</span>
171   static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
172                                           const void *code_end) NOT_JVMTI_RETURN;
173 
174   // This flag indicates whether RedefineClasses() has ever redefined
175   // one or more classes during the lifetime of the VM. The flag should
176   // only be set by the friend class and can be queried by other sub
177   // systems as needed to relax invariant checks.
<span class="line-modified">178   static bool _has_redefined_a_class;</span>
179   friend class VM_RedefineClasses;
<span class="line-modified">180   inline static void set_has_redefined_a_class() {</span>
<span class="line-modified">181     JVMTI_ONLY(_has_redefined_a_class = true;)</span>
182   }
183   // Flag to indicate if the compiler has recorded all dependencies. When the
184   // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
185   // records all dependencies from startup. However if the capability is first
186   // enabled some time later then the dependencies recorded by the compiler
187   // are incomplete. This flag is used by RedefineClasses to know if the
188   // dependency information is complete or not.
189   static bool _all_dependencies_are_recorded;
190 
191  public:
192   inline static bool has_redefined_a_class() {
<span class="line-modified">193     JVMTI_ONLY(return _has_redefined_a_class);</span>
194     NOT_JVMTI(return false);
195   }
196 






197   inline static bool all_dependencies_are_recorded() {
198     return _all_dependencies_are_recorded;
199   }
200 
201   inline static void set_all_dependencies_are_recorded(bool on) {
202     _all_dependencies_are_recorded = (on != 0);
203   }
204 
205   // Add read edges to the unnamed modules of the bootstrap and app class loaders
206   static void add_default_read_edges(Handle h_module, TRAPS) NOT_JVMTI_RETURN;
207 
208   // Add a read edge to the module
209   static jvmtiError add_module_reads(Handle module, Handle to_module, TRAPS);
210 
211   // Updates a module to export a package
212   static jvmtiError add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS);
213 
214   // Updates a module to open a package
215   static jvmtiError add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS);
216 
</pre>
<hr />
<pre>
319   static void post_class_prepare         (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
320 
321   static void post_thread_start          (JavaThread *thread) NOT_JVMTI_RETURN;
322   static void post_thread_end            (JavaThread *thread) NOT_JVMTI_RETURN;
323 
324   // Support for java.lang.instrument agent loading.
325   static bool _should_post_class_file_load_hook;
326   inline static void set_should_post_class_file_load_hook(bool on)     { _should_post_class_file_load_hook = on;  }
327   inline static bool should_post_class_file_load_hook()           {
328     JVMTI_ONLY(return _should_post_class_file_load_hook);
329     NOT_JVMTI(return false;)
330   }
331   static bool is_early_phase() NOT_JVMTI_RETURN_(false);
332   static bool has_early_class_hook_env() NOT_JVMTI_RETURN_(false);
333   // Return true if the class was modified by the hook.
334   static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
335                                         Handle h_protection_domain,
336                                         unsigned char **data_ptr, unsigned char **end_ptr,
337                                         JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
338   static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;

339   static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
340   static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
341 
342   // used to post a CompiledMethodUnload event
343   static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
344 
345   // similiar to post_dynamic_code_generated except that it can be used to
346   // post a DynamicCodeGenerated event while holding locks in the VM. Any event
347   // posted using this function is recorded by the enclosing event collector
348   // -- JvmtiDynamicCodeEventCollector.
349   static void post_dynamic_code_generated_while_holding_locks(const char* name, address code_begin, address code_end) NOT_JVMTI_RETURN;
350 
351   static void post_garbage_collection_finish() NOT_JVMTI_RETURN;
352   static void post_garbage_collection_start() NOT_JVMTI_RETURN;
353   static void post_data_dump() NOT_JVMTI_RETURN;
354   static void post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
355   static void post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
356   static void post_monitor_wait(JavaThread *thread, oop obj, jlong timeout) NOT_JVMTI_RETURN;
357   static void post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) NOT_JVMTI_RETURN;
358   static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;
</pre>
<hr />
<pre>
373 
374   // Collects vm internal objects for later event posting.
375   inline static void sampled_object_alloc_event_collector(oop object) {
376     if (should_post_sampled_object_alloc()) {
377       record_sampled_internal_object_allocation(object);
378     }
379   }
380 
381   inline static void post_array_size_exhausted() {
382     if (should_post_resource_exhausted()) {
383       post_resource_exhausted(JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
384                               &quot;Requested array size exceeds VM limit&quot;);
385     }
386   }
387 
388   static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
389   static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
390 
391   static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
392   static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;
<span class="line-removed">393   static void gc_epilogue() NOT_JVMTI_RETURN;</span>
394 
395   static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
396 
397 #if INCLUDE_SERVICES
398   // attach support
399   static jint load_agent_library(const char *agent, const char *absParam, const char *options, outputStream* out) NOT_JVMTI_RETURN_(JNI_ERR);
400 #endif
401 
402   // SetNativeMethodPrefix support
403   static char** get_all_native_method_prefixes(int* count_ptr) NOT_JVMTI_RETURN_(NULL);
404 
405   // JavaThread lifecycle support:
406   static jvmtiError cv_external_thread_to_JavaThread(ThreadsList * t_list,
407                                                      jthread thread,
408                                                      JavaThread ** jt_pp,
409                                                      oop * thread_oop_p);
410   static jvmtiError cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
411                                          JavaThread ** jt_pp);
412 };
413 
414 // Support class used by JvmtiDynamicCodeEventCollector and others. It
415 // describes a single code blob by name and address range.
416 class JvmtiCodeBlobDesc : public CHeapObj&lt;mtInternal&gt; {
417  private:
418   char _name[64];
419   address _code_begin;
420   address _code_end;
421 
422  public:
423   JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
424     assert(name != NULL, &quot;all code blobs must be named&quot;);
<span class="line-modified">425     strncpy(_name, name, sizeof(_name));</span>
426     _name[sizeof(_name)-1] = &#39;\0&#39;;
427     _code_begin = code_begin;
428     _code_end = code_end;
429   }
430   char* name()                  { return _name; }
431   address code_begin()          { return _code_begin; }
432   address code_end()            { return _code_end; }
433 };
434 
435 // JvmtiEventCollector is a helper class to setup thread for
436 // event collection.
437 class JvmtiEventCollector : public StackObj {
438  private:
439   JvmtiEventCollector* _prev;  // Save previous one to support nested event collector.
440   bool _unset_jvmti_thread_state;
441 
442  public:
443   JvmtiEventCollector() : _prev(NULL), _unset_jvmti_thread_state(false) {}
444 
445   void setup_jvmti_thread_state(); // Set this collector in current thread, returns if success.
</pre>
</td>
<td>
<hr />
<pre>
 74 
 75   static bool        _can_access_local_variables;
 76   static bool        _can_hotswap_or_post_breakpoint;
 77   static bool        _can_modify_any_class;
 78   static bool        _can_walk_any_space;
 79 #endif // INCLUDE_JVMTI
 80 
 81   JVMTI_SUPPORT_FLAG(can_get_source_debug_extension)
 82   JVMTI_SUPPORT_FLAG(can_maintain_original_method_order)
 83   JVMTI_SUPPORT_FLAG(can_post_interpreter_events)
 84   JVMTI_SUPPORT_FLAG(can_post_on_exceptions)
 85   JVMTI_SUPPORT_FLAG(can_post_breakpoint)
 86   JVMTI_SUPPORT_FLAG(can_post_field_access)
 87   JVMTI_SUPPORT_FLAG(can_post_field_modification)
 88   JVMTI_SUPPORT_FLAG(can_post_method_entry)
 89   JVMTI_SUPPORT_FLAG(can_post_method_exit)
 90   JVMTI_SUPPORT_FLAG(can_pop_frame)
 91   JVMTI_SUPPORT_FLAG(can_force_early_return)
 92 
 93   JVMTI_SUPPORT_FLAG(early_vmstart_recorded)
<span class="line-added"> 94   JVMTI_SUPPORT_FLAG(can_get_owned_monitor_info) // includes can_get_owned_monitor_stack_depth_info</span>
 95 
 96   friend class JvmtiEventControllerPrivate;  // should only modify these flags
 97   JVMTI_SUPPORT_FLAG(should_post_single_step)
 98   JVMTI_SUPPORT_FLAG(should_post_field_access)
 99   JVMTI_SUPPORT_FLAG(should_post_field_modification)
100   JVMTI_SUPPORT_FLAG(should_post_class_load)
101   JVMTI_SUPPORT_FLAG(should_post_class_prepare)
102   JVMTI_SUPPORT_FLAG(should_post_class_unload)
103   JVMTI_SUPPORT_FLAG(should_post_native_method_bind)
104   JVMTI_SUPPORT_FLAG(should_post_compiled_method_load)
105   JVMTI_SUPPORT_FLAG(should_post_compiled_method_unload)
106   JVMTI_SUPPORT_FLAG(should_post_dynamic_code_generated)
107   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_enter)
108   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_entered)
109   JVMTI_SUPPORT_FLAG(should_post_monitor_wait)
110   JVMTI_SUPPORT_FLAG(should_post_monitor_waited)
111   JVMTI_SUPPORT_FLAG(should_post_data_dump)
112   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_start)
113   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_finish)
114   JVMTI_SUPPORT_FLAG(should_post_on_exceptions)
</pre>
<hr />
<pre>
143   inline static void set_can_walk_any_space(bool on) {
144     JVMTI_ONLY(_can_walk_any_space = (on != 0);)
145   }
146 
147   enum {
148     JVMTI_VERSION_MASK   = 0x70000000,
149     JVMTI_VERSION_VALUE  = 0x30000000,
150     JVMDI_VERSION_VALUE  = 0x20000000
151   };
152 
153   static void post_field_modification(JavaThread *thread, Method* method, address location,
154                                       Klass* field_klass, Handle object, jfieldID field,
155                                       char sig_type, jvalue *value);
156 
157 
158   // posts a DynamicCodeGenerated event (internal/private implementation).
159   // The public post_dynamic_code_generated* functions make use of the
160   // internal implementation.  Also called from JvmtiDeferredEvent::post()
161   static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
162 
<span class="line-added">163   static void post_class_unload_internal(const char *name) NOT_JVMTI_RETURN;</span>
164  private:
165 
166   // GenerateEvents support to allow posting of CompiledMethodLoad and
167   // DynamicCodeGenerated events for a given environment.
168   friend class JvmtiCodeBlobEvents;
169 



170   static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
171                                           const void *code_end) NOT_JVMTI_RETURN;
172 
173   // This flag indicates whether RedefineClasses() has ever redefined
174   // one or more classes during the lifetime of the VM. The flag should
175   // only be set by the friend class and can be queried by other sub
176   // systems as needed to relax invariant checks.
<span class="line-modified">177   static uint64_t _redefinition_count;</span>
178   friend class VM_RedefineClasses;
<span class="line-modified">179   inline static void increment_redefinition_count() {</span>
<span class="line-modified">180     JVMTI_ONLY(_redefinition_count++;)</span>
181   }
182   // Flag to indicate if the compiler has recorded all dependencies. When the
183   // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
184   // records all dependencies from startup. However if the capability is first
185   // enabled some time later then the dependencies recorded by the compiler
186   // are incomplete. This flag is used by RedefineClasses to know if the
187   // dependency information is complete or not.
188   static bool _all_dependencies_are_recorded;
189 
190  public:
191   inline static bool has_redefined_a_class() {
<span class="line-modified">192     JVMTI_ONLY(return _redefinition_count != 0);</span>
193     NOT_JVMTI(return false);
194   }
195 
<span class="line-added">196   // Only set in safepoint, so no memory ordering needed.</span>
<span class="line-added">197   inline static uint64_t redefinition_count() {</span>
<span class="line-added">198     JVMTI_ONLY(return _redefinition_count);</span>
<span class="line-added">199     NOT_JVMTI(return 0);</span>
<span class="line-added">200   }</span>
<span class="line-added">201 </span>
202   inline static bool all_dependencies_are_recorded() {
203     return _all_dependencies_are_recorded;
204   }
205 
206   inline static void set_all_dependencies_are_recorded(bool on) {
207     _all_dependencies_are_recorded = (on != 0);
208   }
209 
210   // Add read edges to the unnamed modules of the bootstrap and app class loaders
211   static void add_default_read_edges(Handle h_module, TRAPS) NOT_JVMTI_RETURN;
212 
213   // Add a read edge to the module
214   static jvmtiError add_module_reads(Handle module, Handle to_module, TRAPS);
215 
216   // Updates a module to export a package
217   static jvmtiError add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS);
218 
219   // Updates a module to open a package
220   static jvmtiError add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS);
221 
</pre>
<hr />
<pre>
324   static void post_class_prepare         (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
325 
326   static void post_thread_start          (JavaThread *thread) NOT_JVMTI_RETURN;
327   static void post_thread_end            (JavaThread *thread) NOT_JVMTI_RETURN;
328 
329   // Support for java.lang.instrument agent loading.
330   static bool _should_post_class_file_load_hook;
331   inline static void set_should_post_class_file_load_hook(bool on)     { _should_post_class_file_load_hook = on;  }
332   inline static bool should_post_class_file_load_hook()           {
333     JVMTI_ONLY(return _should_post_class_file_load_hook);
334     NOT_JVMTI(return false;)
335   }
336   static bool is_early_phase() NOT_JVMTI_RETURN_(false);
337   static bool has_early_class_hook_env() NOT_JVMTI_RETURN_(false);
338   // Return true if the class was modified by the hook.
339   static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
340                                         Handle h_protection_domain,
341                                         unsigned char **data_ptr, unsigned char **end_ptr,
342                                         JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
343   static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;
<span class="line-added">344   static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;</span>
345   static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
346   static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
347 
348   // used to post a CompiledMethodUnload event
349   static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
350 
351   // similiar to post_dynamic_code_generated except that it can be used to
352   // post a DynamicCodeGenerated event while holding locks in the VM. Any event
353   // posted using this function is recorded by the enclosing event collector
354   // -- JvmtiDynamicCodeEventCollector.
355   static void post_dynamic_code_generated_while_holding_locks(const char* name, address code_begin, address code_end) NOT_JVMTI_RETURN;
356 
357   static void post_garbage_collection_finish() NOT_JVMTI_RETURN;
358   static void post_garbage_collection_start() NOT_JVMTI_RETURN;
359   static void post_data_dump() NOT_JVMTI_RETURN;
360   static void post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
361   static void post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
362   static void post_monitor_wait(JavaThread *thread, oop obj, jlong timeout) NOT_JVMTI_RETURN;
363   static void post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) NOT_JVMTI_RETURN;
364   static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;
</pre>
<hr />
<pre>
379 
380   // Collects vm internal objects for later event posting.
381   inline static void sampled_object_alloc_event_collector(oop object) {
382     if (should_post_sampled_object_alloc()) {
383       record_sampled_internal_object_allocation(object);
384     }
385   }
386 
387   inline static void post_array_size_exhausted() {
388     if (should_post_resource_exhausted()) {
389       post_resource_exhausted(JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
390                               &quot;Requested array size exceeds VM limit&quot;);
391     }
392   }
393 
394   static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
395   static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
396 
397   static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
398   static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;

399 
400   static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
401 
402 #if INCLUDE_SERVICES
403   // attach support
404   static jint load_agent_library(const char *agent, const char *absParam, const char *options, outputStream* out) NOT_JVMTI_RETURN_(JNI_ERR);
405 #endif
406 
407   // SetNativeMethodPrefix support
408   static char** get_all_native_method_prefixes(int* count_ptr) NOT_JVMTI_RETURN_(NULL);
409 
410   // JavaThread lifecycle support:
411   static jvmtiError cv_external_thread_to_JavaThread(ThreadsList * t_list,
412                                                      jthread thread,
413                                                      JavaThread ** jt_pp,
414                                                      oop * thread_oop_p);
415   static jvmtiError cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
416                                          JavaThread ** jt_pp);
417 };
418 
419 // Support class used by JvmtiDynamicCodeEventCollector and others. It
420 // describes a single code blob by name and address range.
421 class JvmtiCodeBlobDesc : public CHeapObj&lt;mtInternal&gt; {
422  private:
423   char _name[64];
424   address _code_begin;
425   address _code_end;
426 
427  public:
428   JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
429     assert(name != NULL, &quot;all code blobs must be named&quot;);
<span class="line-modified">430     strncpy(_name, name, sizeof(_name) - 1);</span>
431     _name[sizeof(_name)-1] = &#39;\0&#39;;
432     _code_begin = code_begin;
433     _code_end = code_end;
434   }
435   char* name()                  { return _name; }
436   address code_begin()          { return _code_begin; }
437   address code_end()            { return _code_end; }
438 };
439 
440 // JvmtiEventCollector is a helper class to setup thread for
441 // event collection.
442 class JvmtiEventCollector : public StackObj {
443  private:
444   JvmtiEventCollector* _prev;  // Save previous one to support nested event collector.
445   bool _unset_jvmti_thread_state;
446 
447  public:
448   JvmtiEventCollector() : _prev(NULL), _unset_jvmti_thread_state(false) {}
449 
450   void setup_jvmti_thread_state(); // Set this collector in current thread, returns if success.
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiExport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiExtensions.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
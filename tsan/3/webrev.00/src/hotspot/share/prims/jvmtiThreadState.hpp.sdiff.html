<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiThreadState.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiThreadState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiThreadState.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiThreadState.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018 Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTITHREADSTATE_HPP
 26 #define SHARE_PRIMS_JVMTITHREADSTATE_HPP
 27 
 28 #include &quot;jvmtifiles/jvmti.h&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/growableArray.hpp&quot;
 33 
 34 //
 35 // Forward Declarations
 36 //
 37 
 38 class JvmtiEnvBase;
 39 class JvmtiEnvThreadState;
 40 class JvmtiDynamicCodeEventCollector;
 41 



 42 enum JvmtiClassLoadKind {
 43   jvmti_class_load_kind_load = 100,
 44   jvmti_class_load_kind_retransform,
 45   jvmti_class_load_kind_redefine
 46 };
 47 
 48 ///////////////////////////////////////////////////////////////
 49 //
 50 // class JvmtiEnvThreadStateIterator
 51 //
 52 // The only safe means of iterating through the JvmtiEnvThreadStates
 53 // in a JvmtiThreadState.
 54 // Note that this iteratation includes invalid environments pending
 55 // deallocation -- in fact, some uses depend on this behavior.
 56 //
 57 class JvmtiEnvThreadStateIterator : public StackObj {
 58  private:
 59   JvmtiThreadState* state;
 60  public:
 61   JvmtiEnvThreadStateIterator(JvmtiThreadState* thread_state);
 62   ~JvmtiEnvThreadStateIterator();
 63   JvmtiEnvThreadState* first();
 64   JvmtiEnvThreadState* next(JvmtiEnvThreadState* ets);
 65 };
 66 
 67 
 68 ///////////////////////////////////////////////////////////////
 69 //
 70 // class JvmtiThreadState
 71 //
 72 // The Jvmti state for each thread (across all JvmtiEnv):
 73 // 1. Local table of enabled events.
 74 class JvmtiThreadState : public CHeapObj&lt;mtInternal&gt; {
 75  private:
 76   friend class JvmtiEnv;
 77   JavaThread        *_thread;


 78   bool              _hide_single_stepping;
 79   bool              _pending_step_for_popframe;
 80   bool              _pending_step_for_earlyret;
 81   int               _hide_level;
 82 
 83  public:
 84   enum ExceptionState {
 85     ES_CLEARED,
 86     ES_DETECTED,
 87     ES_CAUGHT
 88   };
 89 
 90  private:
 91   ExceptionState _exception_state;
 92 
 93   // Used to send class being redefined/retransformed and kind of transform
 94   // info to the class file load hook event handler.
 95   Klass*                _class_being_redefined;
 96   JvmtiClassLoadKind    _class_load_kind;
 97 
</pre>
<hr />
<pre>
367     earlyret_inactive = 0,
368     earlyret_pending  = 1
369   };
370 
371   void set_earlyret_pending(void) { _earlyret_state = earlyret_pending;  }
372   void clr_earlyret_pending(void) { _earlyret_state = earlyret_inactive; }
373   bool is_earlyret_pending(void)  { return (_earlyret_state == earlyret_pending);  }
374 
375   TosState earlyret_tos()                            { return _earlyret_tos; }
376   oop  earlyret_oop() const                          { return _earlyret_oop; }
377   void set_earlyret_oop (oop x)                      { _earlyret_oop = x;    }
378   jvalue earlyret_value()                            { return _earlyret_value; }
379   void set_earlyret_value(jvalue val, TosState tos)  { _earlyret_tos = tos;  _earlyret_value = val;  }
380   void clr_earlyret_value()                          { _earlyret_tos = ilgl; _earlyret_value.j = 0L; }
381 
382   static ByteSize earlyret_state_offset() { return byte_offset_of(JvmtiThreadState, _earlyret_state); }
383   static ByteSize earlyret_tos_offset()   { return byte_offset_of(JvmtiThreadState, _earlyret_tos); }
384   static ByteSize earlyret_oop_offset()   { return byte_offset_of(JvmtiThreadState, _earlyret_oop); }
385   static ByteSize earlyret_value_offset() { return byte_offset_of(JvmtiThreadState, _earlyret_value); }
386 
<span class="line-modified">387   void oops_do(OopClosure* f) NOT_JVMTI_RETURN; // GC support</span>

388 
389 public:
390   void set_should_post_on_exceptions(bool val) { _thread-&gt;set_should_post_on_exceptions_flag(val ? JNI_TRUE : JNI_FALSE); }





391 };
392 
393 class RedefineVerifyMark : public StackObj {
394  private:
395   JvmtiThreadState* _state;
396   Klass*            _scratch_class;
397   OopHandle         _scratch_mirror;
398 
399  public:
400   RedefineVerifyMark(Klass* the_class, Klass* scratch_class,
401                      JvmtiThreadState *state) : _state(state), _scratch_class(scratch_class)
402   {
403     _state-&gt;set_class_versions_map(the_class, scratch_class);
404     _scratch_mirror = _scratch_class-&gt;java_mirror_handle();
405     _scratch_class-&gt;set_java_mirror_handle(the_class-&gt;java_mirror_handle());
406   }
407 
408   ~RedefineVerifyMark() {
409     // Restore the scratch class&#39;s mirror, so when scratch_class is removed
410     // the correct mirror pointing to it can be cleared.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTITHREADSTATE_HPP
 26 #define SHARE_PRIMS_JVMTITHREADSTATE_HPP
 27 
 28 #include &quot;jvmtifiles/jvmti.h&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/growableArray.hpp&quot;
 33 
 34 //
 35 // Forward Declarations
 36 //
 37 
 38 class JvmtiEnvBase;
 39 class JvmtiEnvThreadState;
 40 class JvmtiDynamicCodeEventCollector;
 41 
<span class="line-added"> 42 class JvmtiDeferredEvent;</span>
<span class="line-added"> 43 class JvmtiDeferredEventQueue;</span>
<span class="line-added"> 44 </span>
 45 enum JvmtiClassLoadKind {
 46   jvmti_class_load_kind_load = 100,
 47   jvmti_class_load_kind_retransform,
 48   jvmti_class_load_kind_redefine
 49 };
 50 
 51 ///////////////////////////////////////////////////////////////
 52 //
 53 // class JvmtiEnvThreadStateIterator
 54 //
 55 // The only safe means of iterating through the JvmtiEnvThreadStates
 56 // in a JvmtiThreadState.
 57 // Note that this iteratation includes invalid environments pending
 58 // deallocation -- in fact, some uses depend on this behavior.
 59 //
 60 class JvmtiEnvThreadStateIterator : public StackObj {
 61  private:
 62   JvmtiThreadState* state;
 63  public:
 64   JvmtiEnvThreadStateIterator(JvmtiThreadState* thread_state);
 65   ~JvmtiEnvThreadStateIterator();
 66   JvmtiEnvThreadState* first();
 67   JvmtiEnvThreadState* next(JvmtiEnvThreadState* ets);
 68 };
 69 
 70 
 71 ///////////////////////////////////////////////////////////////
 72 //
 73 // class JvmtiThreadState
 74 //
 75 // The Jvmti state for each thread (across all JvmtiEnv):
 76 // 1. Local table of enabled events.
 77 class JvmtiThreadState : public CHeapObj&lt;mtInternal&gt; {
 78  private:
 79   friend class JvmtiEnv;
 80   JavaThread        *_thread;
<span class="line-added"> 81   // Jvmti Events that cannot be posted in their current context.</span>
<span class="line-added"> 82   JvmtiDeferredEventQueue* _jvmti_event_queue;</span>
 83   bool              _hide_single_stepping;
 84   bool              _pending_step_for_popframe;
 85   bool              _pending_step_for_earlyret;
 86   int               _hide_level;
 87 
 88  public:
 89   enum ExceptionState {
 90     ES_CLEARED,
 91     ES_DETECTED,
 92     ES_CAUGHT
 93   };
 94 
 95  private:
 96   ExceptionState _exception_state;
 97 
 98   // Used to send class being redefined/retransformed and kind of transform
 99   // info to the class file load hook event handler.
100   Klass*                _class_being_redefined;
101   JvmtiClassLoadKind    _class_load_kind;
102 
</pre>
<hr />
<pre>
372     earlyret_inactive = 0,
373     earlyret_pending  = 1
374   };
375 
376   void set_earlyret_pending(void) { _earlyret_state = earlyret_pending;  }
377   void clr_earlyret_pending(void) { _earlyret_state = earlyret_inactive; }
378   bool is_earlyret_pending(void)  { return (_earlyret_state == earlyret_pending);  }
379 
380   TosState earlyret_tos()                            { return _earlyret_tos; }
381   oop  earlyret_oop() const                          { return _earlyret_oop; }
382   void set_earlyret_oop (oop x)                      { _earlyret_oop = x;    }
383   jvalue earlyret_value()                            { return _earlyret_value; }
384   void set_earlyret_value(jvalue val, TosState tos)  { _earlyret_tos = tos;  _earlyret_value = val;  }
385   void clr_earlyret_value()                          { _earlyret_tos = ilgl; _earlyret_value.j = 0L; }
386 
387   static ByteSize earlyret_state_offset() { return byte_offset_of(JvmtiThreadState, _earlyret_state); }
388   static ByteSize earlyret_tos_offset()   { return byte_offset_of(JvmtiThreadState, _earlyret_tos); }
389   static ByteSize earlyret_oop_offset()   { return byte_offset_of(JvmtiThreadState, _earlyret_oop); }
390   static ByteSize earlyret_value_offset() { return byte_offset_of(JvmtiThreadState, _earlyret_value); }
391 
<span class="line-modified">392   void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN; // GC support</span>
<span class="line-added">393   void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;</span>
394 
395 public:
396   void set_should_post_on_exceptions(bool val) { _thread-&gt;set_should_post_on_exceptions_flag(val ? JNI_TRUE : JNI_FALSE); }
<span class="line-added">397 </span>
<span class="line-added">398   // Thread local event queue, which doesn&#39;t require taking the Service_lock.</span>
<span class="line-added">399   void enqueue_event(JvmtiDeferredEvent* event) NOT_JVMTI_RETURN;</span>
<span class="line-added">400   void post_events(JvmtiEnv* env);</span>
<span class="line-added">401   void run_nmethod_entry_barriers();</span>
402 };
403 
404 class RedefineVerifyMark : public StackObj {
405  private:
406   JvmtiThreadState* _state;
407   Klass*            _scratch_class;
408   OopHandle         _scratch_mirror;
409 
410  public:
411   RedefineVerifyMark(Klass* the_class, Klass* scratch_class,
412                      JvmtiThreadState *state) : _state(state), _scratch_class(scratch_class)
413   {
414     _state-&gt;set_class_versions_map(the_class, scratch_class);
415     _scratch_mirror = _scratch_class-&gt;java_mirror_handle();
416     _scratch_class-&gt;set_java_mirror_handle(the_class-&gt;java_mirror_handle());
417   }
418 
419   ~RedefineVerifyMark() {
420     // Restore the scratch class&#39;s mirror, so when scratch_class is removed
421     // the correct mirror pointing to it can be cleared.
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiThreadState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiThreadState.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
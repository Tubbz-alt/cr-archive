<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/access.inline.hpp&quot;
  36 #include &quot;oops/arrayOop.inline.hpp&quot;
  37 #include &quot;oops/constantPool.inline.hpp&quot;
  38 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;prims/jvmtiEventController.hpp&quot;
  44 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;prims/jvmtiImpl.hpp&quot;
  47 #include &quot;prims/jvmtiTagMap.hpp&quot;
  48 #include &quot;runtime/biasedLocking.hpp&quot;
  49 #include &quot;runtime/frame.inline.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/mutex.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/reflectionUtils.hpp&quot;
  56 #include &quot;runtime/thread.inline.hpp&quot;
  57 #include &quot;runtime/threadSMR.hpp&quot;
  58 #include &quot;runtime/vframe.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 #include &quot;runtime/vmOperations.hpp&quot;
  61 #if INCLUDE_TSAN
  62 #include &quot;tsan/tsan.hpp&quot;
  63 #endif  // INCLUDE_TSAN
  64 #include &quot;utilities/macros.hpp&quot;
  65 #if INCLUDE_ZGC
  66 #include &quot;gc/z/zGlobals.hpp&quot;
  67 #endif
  68 
  69 // JvmtiTagHashmapEntry
  70 //
  71 // Each entry encapsulates a reference to the tagged object
  72 // and the tag value. In addition an entry includes a next pointer which
  73 // is used to chain entries together.
  74 
  75 class JvmtiTagHashmapEntry : public CHeapObj&lt;mtInternal&gt; {
  76  private:
  77   friend class JvmtiTagMap;
  78 
  79   oop _object;                          // tagged object
  80   jlong _tag;                           // the tag
  81   JvmtiTagHashmapEntry* _next;          // next on the list
  82 
  83   inline void init(oop object, jlong tag) {
  84     _object = object;
  85     _tag = tag;
  86     _next = NULL;
  87   }
  88 
  89   // constructor
  90   JvmtiTagHashmapEntry(oop object, jlong tag) { init(object, tag); }
  91 
  92  public:
  93 
  94   // accessor methods
  95   inline oop* object_addr() { return &amp;_object; }
  96   inline oop object()       { return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(object_addr()); }
  97   // Peek at the object without keeping it alive. The returned object must be
  98   // kept alive using a normal access if it leaks out of a thread transition from VM.
  99   inline oop object_peek()  {
 100     return NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(object_addr());
 101   }
 102   inline jlong tag() const  { return _tag; }
 103 
 104   inline void set_tag(jlong tag) {
 105     assert(tag != 0, &quot;can&#39;t be zero&quot;);
 106     _tag = tag;
 107   }
 108 
 109   inline bool equals(oop object) {
 110     return oopDesc::equals(object, object_peek());
 111   }
 112 
 113   inline JvmtiTagHashmapEntry* next() const        { return _next; }
 114   inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
 115 };
 116 
 117 
 118 // JvmtiTagHashmap
 119 //
 120 // A hashmap is essentially a table of pointers to entries. Entries
 121 // are hashed to a location, or position in the table, and then
 122 // chained from that location. The &quot;key&quot; for hashing is address of
 123 // the object, or oop. The &quot;value&quot; is the tag value.
 124 //
 125 // A hashmap maintains a count of the number entries in the hashmap
 126 // and resizes if the number of entries exceeds a given threshold.
 127 // The threshold is specified as a percentage of the size - for
 128 // example a threshold of 0.75 will trigger the hashmap to resize
 129 // if the number of entries is &gt;75% of table size.
 130 //
 131 // A hashmap provides functions for adding, removing, and finding
 132 // entries. It also provides a function to iterate over all entries
 133 // in the hashmap.
 134 
 135 class JvmtiTagHashmap : public CHeapObj&lt;mtInternal&gt; {
 136  private:
 137   friend class JvmtiTagMap;
 138 
 139   enum {
 140     small_trace_threshold  = 10000,                  // threshold for tracing
 141     medium_trace_threshold = 100000,
 142     large_trace_threshold  = 1000000,
 143     initial_trace_threshold = small_trace_threshold
 144   };
 145 
 146   static int _sizes[];                  // array of possible hashmap sizes
 147   int _size;                            // actual size of the table
 148   int _size_index;                      // index into size table
 149 
 150   int _entry_count;                     // number of entries in the hashmap
 151 
 152   float _load_factor;                   // load factor as a % of the size
 153   int _resize_threshold;                // computed threshold to trigger resizing.
 154   bool _resizing_enabled;               // indicates if hashmap can resize
 155 
 156   int _trace_threshold;                 // threshold for trace messages
 157 
 158   JvmtiTagHashmapEntry** _table;        // the table of entries.
 159 
 160   // private accessors
 161   int resize_threshold() const                  { return _resize_threshold; }
 162   int trace_threshold() const                   { return _trace_threshold; }
 163 
 164   // initialize the hashmap
 165   void init(int size_index=0, float load_factor=4.0f) {
 166     int initial_size =  _sizes[size_index];
 167     _size_index = size_index;
 168     _size = initial_size;
 169     _entry_count = 0;
 170     _trace_threshold = initial_trace_threshold;
 171     _load_factor = load_factor;
 172     _resize_threshold = (int)(_load_factor * _size);
 173     _resizing_enabled = true;
 174     size_t s = initial_size * sizeof(JvmtiTagHashmapEntry*);
 175     _table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 176     if (_table == NULL) {
 177       vm_exit_out_of_memory(s, OOM_MALLOC_ERROR,
 178         &quot;unable to allocate initial hashtable for jvmti object tags&quot;);
 179     }
 180     for (int i=0; i&lt;initial_size; i++) {
 181       _table[i] = NULL;
 182     }
 183   }
 184 
 185   // hash a given key (oop) with the specified size
 186   static unsigned int hash(oop key, int size) {
 187     ZGC_ONLY(assert(ZAddressMetadataShift &gt;= sizeof(unsigned int) * BitsPerByte, &quot;cast removes the metadata bits&quot;);)
 188 
 189     // shift right to get better distribution (as these bits will be zero
 190     // with aligned addresses)
 191     key = Access&lt;&gt;::resolve(key);
 192     unsigned int addr = (unsigned int)(cast_from_oop&lt;intptr_t&gt;(key));
 193 #ifdef _LP64
 194     return (addr &gt;&gt; 3) % size;
 195 #else
 196     return (addr &gt;&gt; 2) % size;
 197 #endif
 198   }
 199 
 200   // hash a given key (oop)
 201   unsigned int hash(oop key) {
 202     return hash(key, _size);
 203   }
 204 
 205   // resize the hashmap - allocates a large table and re-hashes
 206   // all entries into the new table.
 207   void resize() {
 208     int new_size_index = _size_index+1;
 209     int new_size = _sizes[new_size_index];
 210     if (new_size &lt; 0) {
 211       // hashmap already at maximum capacity
 212       return;
 213     }
 214 
 215     // allocate new table
 216     size_t s = new_size * sizeof(JvmtiTagHashmapEntry*);
 217     JvmtiTagHashmapEntry** new_table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 218     if (new_table == NULL) {
 219       warning(&quot;unable to allocate larger hashtable for jvmti object tags&quot;);
 220       set_resizing_enabled(false);
 221       return;
 222     }
 223 
 224     // initialize new table
 225     int i;
 226     for (i=0; i&lt;new_size; i++) {
 227       new_table[i] = NULL;
 228     }
 229 
 230     // rehash all entries into the new table
 231     for (i=0; i&lt;_size; i++) {
 232       JvmtiTagHashmapEntry* entry = _table[i];
 233       while (entry != NULL) {
 234         JvmtiTagHashmapEntry* next = entry-&gt;next();
 235         oop key = entry-&gt;object_peek();
 236         assert(key != NULL, &quot;jni weak reference cleared!!&quot;);
 237         unsigned int h = hash(key, new_size);
 238         JvmtiTagHashmapEntry* anchor = new_table[h];
 239         if (anchor == NULL) {
 240           new_table[h] = entry;
 241           entry-&gt;set_next(NULL);
 242         } else {
 243           entry-&gt;set_next(anchor);
 244           new_table[h] = entry;
 245         }
 246         entry = next;
 247       }
 248     }
 249 
 250     // free old table and update settings.
 251     os::free((void*)_table);
 252     _table = new_table;
 253     _size_index = new_size_index;
 254     _size = new_size;
 255 
 256     // compute new resize threshold
 257     _resize_threshold = (int)(_load_factor * _size);
 258   }
 259 
 260 
 261   // internal remove function - remove an entry at a given position in the
 262   // table.
 263   inline void remove(JvmtiTagHashmapEntry* prev, int pos, JvmtiTagHashmapEntry* entry) {
 264     assert(pos &gt;= 0 &amp;&amp; pos &lt; _size, &quot;out of range&quot;);
 265     if (prev == NULL) {
 266       _table[pos] = entry-&gt;next();
 267     } else {
 268       prev-&gt;set_next(entry-&gt;next());
 269     }
 270     assert(_entry_count &gt; 0, &quot;checking&quot;);
 271     _entry_count--;
 272   }
 273 
 274   // resizing switch
 275   bool is_resizing_enabled() const          { return _resizing_enabled; }
 276   void set_resizing_enabled(bool enable)    { _resizing_enabled = enable; }
 277 
 278   // debugging
 279   void print_memory_usage();
 280   void compute_next_trace_threshold();
 281 
 282  public:
 283 
 284   // create a JvmtiTagHashmap of a preferred size and optionally a load factor.
 285   // The preferred size is rounded down to an actual size.
 286   JvmtiTagHashmap(int size, float load_factor=0.0f) {
 287     int i=0;
 288     while (_sizes[i] &lt; size) {
 289       if (_sizes[i] &lt; 0) {
 290         assert(i &gt; 0, &quot;sanity check&quot;);
 291         i--;
 292         break;
 293       }
 294       i++;
 295     }
 296 
 297     // if a load factor is specified then use it, otherwise use default
 298     if (load_factor &gt; 0.01f) {
 299       init(i, load_factor);
 300     } else {
 301       init(i);
 302     }
 303   }
 304 
 305   // create a JvmtiTagHashmap with default settings
 306   JvmtiTagHashmap() {
 307     init();
 308   }
 309 
 310   // release table when JvmtiTagHashmap destroyed
 311   ~JvmtiTagHashmap() {
 312     if (_table != NULL) {
 313       os::free((void*)_table);
 314       _table = NULL;
 315     }
 316   }
 317 
 318   // accessors
 319   int size() const                              { return _size; }
 320   JvmtiTagHashmapEntry** table() const          { return _table; }
 321   int entry_count() const                       { return _entry_count; }
 322 
 323   // find an entry in the hashmap, returns NULL if not found.
 324   inline JvmtiTagHashmapEntry* find(oop key) {
 325     unsigned int h = hash(key);
 326     JvmtiTagHashmapEntry* entry = _table[h];
 327     while (entry != NULL) {
 328       if (entry-&gt;equals(key)) {
 329          return entry;
 330       }
 331       entry = entry-&gt;next();
 332     }
 333     return NULL;
 334   }
 335 
 336 
 337   // add a new entry to hashmap
 338   inline void add(oop key, JvmtiTagHashmapEntry* entry) {
 339     assert(key != NULL, &quot;checking&quot;);
 340     assert(find(key) == NULL, &quot;duplicate detected&quot;);
 341     unsigned int h = hash(key);
 342     JvmtiTagHashmapEntry* anchor = _table[h];
 343     if (anchor == NULL) {
 344       _table[h] = entry;
 345       entry-&gt;set_next(NULL);
 346     } else {
 347       entry-&gt;set_next(anchor);
 348       _table[h] = entry;
 349     }
 350 
 351     _entry_count++;
 352     if (log_is_enabled(Debug, jvmti, objecttagging) &amp;&amp; entry_count() &gt;= trace_threshold()) {
 353       print_memory_usage();
 354       compute_next_trace_threshold();
 355     }
 356 
 357     // if the number of entries exceed the threshold then resize
 358     if (entry_count() &gt; resize_threshold() &amp;&amp; is_resizing_enabled()) {
 359       resize();
 360     }
 361   }
 362 
 363   // remove an entry with the given key.
 364   inline JvmtiTagHashmapEntry* remove(oop key) {
 365     unsigned int h = hash(key);
 366     JvmtiTagHashmapEntry* entry = _table[h];
 367     JvmtiTagHashmapEntry* prev = NULL;
 368     while (entry != NULL) {
 369       if (entry-&gt;equals(key)) {
 370         break;
 371       }
 372       prev = entry;
 373       entry = entry-&gt;next();
 374     }
 375     if (entry != NULL) {
 376       remove(prev, h, entry);
 377     }
 378     return entry;
 379   }
 380 
 381   // iterate over all entries in the hashmap
 382   void entry_iterate(JvmtiTagHashmapEntryClosure* closure);
 383 };
 384 
 385 // Tsan should know that the JVMTI TagMap is protected by a mutex.
 386 class TsanMutexScope : public StackObj {
 387  private:
 388   Monitor *_lock;  // Keep my own reference, for destructor.
 389 
 390  public:
 391   // Don&#39;t actually lock it, just tell tsan we did.
 392   TsanMutexScope(Monitor* mutex) : _lock(mutex) {
 393     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));
 394   }
 395 
 396   ~TsanMutexScope() {
 397     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));
 398   }
 399 };
 400 
 401 // possible hashmap sizes - odd primes that roughly double in size.
 402 // To avoid excessive resizing the odd primes from 4801-76831 and
 403 // 76831-307261 have been removed. The list must be terminated by -1.
 404 int JvmtiTagHashmap::_sizes[] =  { 4801, 76831, 307261, 614563, 1228891,
 405     2457733, 4915219, 9830479, 19660831, 39321619, 78643219, -1 };
 406 
 407 
 408 // A supporting class for iterating over all entries in Hashmap
 409 class JvmtiTagHashmapEntryClosure {
 410  public:
 411   virtual void do_entry(JvmtiTagHashmapEntry* entry) = 0;
 412 };
 413 
 414 
 415 // iterate over all entries in the hashmap
 416 void JvmtiTagHashmap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 417   for (int i=0; i&lt;_size; i++) {
 418     JvmtiTagHashmapEntry* entry = _table[i];
 419     JvmtiTagHashmapEntry* prev = NULL;
 420     while (entry != NULL) {
 421       // obtain the next entry before invoking do_entry - this is
 422       // necessary because do_entry may remove the entry from the
 423       // hashmap.
 424       JvmtiTagHashmapEntry* next = entry-&gt;next();
 425       closure-&gt;do_entry(entry);
 426       entry = next;
 427      }
 428   }
 429 }
 430 
 431 // debugging
 432 void JvmtiTagHashmap::print_memory_usage() {
 433   intptr_t p = (intptr_t)this;
 434   tty-&gt;print(&quot;[JvmtiTagHashmap @ &quot; INTPTR_FORMAT, p);
 435 
 436   // table + entries in KB
 437   int hashmap_usage = (size()*sizeof(JvmtiTagHashmapEntry*) +
 438     entry_count()*sizeof(JvmtiTagHashmapEntry))/K;
 439 
 440   int weak_globals_usage = (int)(JNIHandles::weak_global_handle_memory_usage()/K);
 441   tty-&gt;print_cr(&quot;, %d entries (%d KB) &lt;JNI weak globals: %d KB&gt;]&quot;,
 442     entry_count(), hashmap_usage, weak_globals_usage);
 443 }
 444 
 445 // compute threshold for the next trace message
 446 void JvmtiTagHashmap::compute_next_trace_threshold() {
 447   _trace_threshold = entry_count();
 448   if (trace_threshold() &lt; medium_trace_threshold) {
 449     _trace_threshold += small_trace_threshold;
 450   } else {
 451     if (trace_threshold() &lt; large_trace_threshold) {
 452       _trace_threshold += medium_trace_threshold;
 453     } else {
 454       _trace_threshold += large_trace_threshold;
 455     }
 456   }
 457 }
 458 
 459 // create a JvmtiTagMap
 460 JvmtiTagMap::JvmtiTagMap(JvmtiEnv* env) :
 461   _env(env),
 462   _lock(Mutex::nonleaf+2, &quot;JvmtiTagMap._lock&quot;, false),
 463   _free_entries(NULL),
 464   _free_entries_count(0)
 465 {
 466   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
 467   assert(((JvmtiEnvBase *)env)-&gt;tag_map() == NULL, &quot;tag map already exists for environment&quot;);
 468 
 469   // TSAN Note: we cannot tell TSAN about the creation of this lock due to
 470   // this being seen as racy though is not really.
 471   //
 472   // The JvmtiTagMap gets created by the first thread to call tag_map_for; which
 473   // uses a lock to create it if need be.
 474   //
 475   // This means that this lock is created under a mutex but then,
 476   // subsequent uses do not have a lock to protect it (because not
 477   // needed in this case), however TSAN sees it as being needed because:
 478   //  - Another thread can come and get the newly created JvmtiTagMap without a
 479   //  lock and acquire the lock.
 480   //  - This provokes a race for TSAN on the lock itself, though there is no
 481   //  real issue.
 482   //
 483   //  Not creating the lock or having a fence mechanism to tell TSAN this is
 484   //  safe (a fake lock around this lock for example) seem to be the only
 485   //  solutions.
 486 
 487   _hashmap = new JvmtiTagHashmap();
 488 
 489   // finally add us to the environment
 490   ((JvmtiEnvBase *)env)-&gt;set_tag_map(this);
 491 }
 492 
 493 
 494 // destroy a JvmtiTagMap
 495 JvmtiTagMap::~JvmtiTagMap() {
 496   // no lock acquired as we assume the enclosing environment is
 497   // also being destroryed.
 498   ((JvmtiEnvBase *)_env)-&gt;set_tag_map(NULL);
 499 
 500   JvmtiTagHashmapEntry** table = _hashmap-&gt;table();
 501   for (int j = 0; j &lt; _hashmap-&gt;size(); j++) {
 502     JvmtiTagHashmapEntry* entry = table[j];
 503     while (entry != NULL) {
 504       JvmtiTagHashmapEntry* next = entry-&gt;next();
 505       delete entry;
 506       entry = next;
 507     }
 508   }
 509 
 510   // finally destroy the hashmap
 511   delete _hashmap;
 512   _hashmap = NULL;
 513 
 514   // remove any entries on the free list
 515   JvmtiTagHashmapEntry* entry = _free_entries;
 516   while (entry != NULL) {
 517     JvmtiTagHashmapEntry* next = entry-&gt;next();
 518     delete entry;
 519     entry = next;
 520   }
 521   _free_entries = NULL;
 522 
 523   // TSAN Note: see above for the Tsan creation note.
 524 }
 525 
 526 // create a hashmap entry
 527 // - if there&#39;s an entry on the (per-environment) free list then this
 528 // is returned. Otherwise an new entry is allocated.
 529 JvmtiTagHashmapEntry* JvmtiTagMap::create_entry(oop ref, jlong tag) {
 530   assert(Thread::current()-&gt;is_VM_thread() || is_locked(), &quot;checking&quot;);
 531   JvmtiTagHashmapEntry* entry;
 532   if (_free_entries == NULL) {
 533     entry = new JvmtiTagHashmapEntry(ref, tag);
 534   } else {
 535     assert(_free_entries_count &gt; 0, &quot;mismatched _free_entries_count&quot;);
 536     _free_entries_count--;
 537     entry = _free_entries;
 538     _free_entries = entry-&gt;next();
 539     entry-&gt;init(ref, tag);
 540   }
 541   return entry;
 542 }
 543 
 544 // destroy an entry by returning it to the free list
 545 void JvmtiTagMap::destroy_entry(JvmtiTagHashmapEntry* entry) {
 546   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 547   // limit the size of the free list
 548   if (_free_entries_count &gt;= max_free_entries) {
 549     delete entry;
 550   } else {
 551     entry-&gt;set_next(_free_entries);
 552     _free_entries = entry;
 553     _free_entries_count++;
 554   }
 555 }
 556 
 557 // returns the tag map for the given environments. If the tag map
 558 // doesn&#39;t exist then it is created.
 559 JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
 560   JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
 561   if (tag_map == NULL) {
 562     MutexLocker mu(JvmtiThreadState_lock);
 563     tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
 564     if (tag_map == NULL) {
 565       tag_map = new JvmtiTagMap(env);
 566     }
 567   } else {
 568     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
 569   }
 570   return tag_map;
 571 }
 572 
 573 // iterate over all entries in the tag map.
 574 void JvmtiTagMap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 575   hashmap()-&gt;entry_iterate(closure);
 576 }
 577 
 578 // returns true if the hashmaps are empty
 579 bool JvmtiTagMap::is_empty() {
 580   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 581   return hashmap()-&gt;entry_count() == 0;
 582 }
 583 
 584 
 585 // Return the tag value for an object, or 0 if the object is
 586 // not tagged
 587 //
 588 static inline jlong tag_for(JvmtiTagMap* tag_map, oop o) {
 589   JvmtiTagHashmapEntry* entry = tag_map-&gt;hashmap()-&gt;find(o);
 590   if (entry == NULL) {
 591     return 0;
 592   } else {
 593     return entry-&gt;tag();
 594   }
 595 }
 596 
 597 
 598 // A CallbackWrapper is a support class for querying and tagging an object
 599 // around a callback to a profiler. The constructor does pre-callback
 600 // work to get the tag value, klass tag value, ... and the destructor
 601 // does the post-callback work of tagging or untagging the object.
 602 //
 603 // {
 604 //   CallbackWrapper wrapper(tag_map, o);
 605 //
 606 //   (*callback)(wrapper.klass_tag(), wrapper.obj_size(), wrapper.obj_tag_p(), ...)
 607 //
 608 // } // wrapper goes out of scope here which results in the destructor
 609 //      checking to see if the object has been tagged, untagged, or the
 610 //      tag value has changed.
 611 //
 612 class CallbackWrapper : public StackObj {
 613  private:
 614   JvmtiTagMap* _tag_map;
 615   JvmtiTagHashmap* _hashmap;
 616   JvmtiTagHashmapEntry* _entry;
 617   oop _o;
 618   jlong _obj_size;
 619   jlong _obj_tag;
 620   jlong _klass_tag;
 621 
 622  protected:
 623   JvmtiTagMap* tag_map() const      { return _tag_map; }
 624 
 625   // invoked post-callback to tag, untag, or update the tag of an object
 626   void inline post_callback_tag_update(oop o, JvmtiTagHashmap* hashmap,
 627                                        JvmtiTagHashmapEntry* entry, jlong obj_tag);
 628  public:
 629   CallbackWrapper(JvmtiTagMap* tag_map, oop o) {
 630     assert(Thread::current()-&gt;is_VM_thread() || tag_map-&gt;is_locked(),
 631            &quot;MT unsafe or must be VM thread&quot;);
 632 
 633     // object to tag
 634     _o = o;
 635 
 636     // object size
 637     _obj_size = (jlong)_o-&gt;size() * wordSize;
 638 
 639     // record the context
 640     _tag_map = tag_map;
 641     _hashmap = tag_map-&gt;hashmap();
 642     _entry = _hashmap-&gt;find(_o);
 643 
 644     // get object tag
 645     _obj_tag = (_entry == NULL) ? 0 : _entry-&gt;tag();
 646 
 647     // get the class and the class&#39;s tag value
 648     assert(SystemDictionary::Class_klass()-&gt;is_mirror_instance_klass(), &quot;Is not?&quot;);
 649 
 650     _klass_tag = tag_for(tag_map, _o-&gt;klass()-&gt;java_mirror());
 651   }
 652 
 653   ~CallbackWrapper() {
 654     post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);
 655   }
 656 
 657   inline jlong* obj_tag_p()                     { return &amp;_obj_tag; }
 658   inline jlong obj_size() const                 { return _obj_size; }
 659   inline jlong obj_tag() const                  { return _obj_tag; }
 660   inline jlong klass_tag() const                { return _klass_tag; }
 661 };
 662 
 663 
 664 
 665 // callback post-callback to tag, untag, or update the tag of an object
 666 void inline CallbackWrapper::post_callback_tag_update(oop o,
 667                                                       JvmtiTagHashmap* hashmap,
 668                                                       JvmtiTagHashmapEntry* entry,
 669                                                       jlong obj_tag) {
 670   if (entry == NULL) {
 671     if (obj_tag != 0) {
 672       // callback has tagged the object
 673       assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 674       entry = tag_map()-&gt;create_entry(o, obj_tag);
 675       hashmap-&gt;add(o, entry);
 676     }
 677   } else {
 678     // object was previously tagged - the callback may have untagged
 679     // the object or changed the tag value
 680     if (obj_tag == 0) {
 681 
 682       JvmtiTagHashmapEntry* entry_removed = hashmap-&gt;remove(o);
 683       assert(entry_removed == entry, &quot;checking&quot;);
 684       tag_map()-&gt;destroy_entry(entry);
 685 
 686     } else {
 687       if (obj_tag != entry-&gt;tag()) {
 688          entry-&gt;set_tag(obj_tag);
 689       }
 690     }
 691   }
 692 }
 693 
 694 // An extended CallbackWrapper used when reporting an object reference
 695 // to the agent.
 696 //
 697 // {
 698 //   TwoOopCallbackWrapper wrapper(tag_map, referrer, o);
 699 //
 700 //   (*callback)(wrapper.klass_tag(),
 701 //               wrapper.obj_size(),
 702 //               wrapper.obj_tag_p()
 703 //               wrapper.referrer_tag_p(), ...)
 704 //
 705 // } // wrapper goes out of scope here which results in the destructor
 706 //      checking to see if the referrer object has been tagged, untagged,
 707 //      or the tag value has changed.
 708 //
 709 class TwoOopCallbackWrapper : public CallbackWrapper {
 710  private:
 711   bool _is_reference_to_self;
 712   JvmtiTagHashmap* _referrer_hashmap;
 713   JvmtiTagHashmapEntry* _referrer_entry;
 714   oop _referrer;
 715   jlong _referrer_obj_tag;
 716   jlong _referrer_klass_tag;
 717   jlong* _referrer_tag_p;
 718 
 719   bool is_reference_to_self() const             { return _is_reference_to_self; }
 720 
 721  public:
 722   TwoOopCallbackWrapper(JvmtiTagMap* tag_map, oop referrer, oop o) :
 723     CallbackWrapper(tag_map, o)
 724   {
 725     // self reference needs to be handled in a special way
 726     _is_reference_to_self = (referrer == o);
 727 
 728     if (_is_reference_to_self) {
 729       _referrer_klass_tag = klass_tag();
 730       _referrer_tag_p = obj_tag_p();
 731     } else {
 732       _referrer = referrer;
 733       // record the context
 734       _referrer_hashmap = tag_map-&gt;hashmap();
 735       _referrer_entry = _referrer_hashmap-&gt;find(_referrer);
 736 
 737       // get object tag
 738       _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry-&gt;tag();
 739       _referrer_tag_p = &amp;_referrer_obj_tag;
 740 
 741       // get referrer class tag.
 742       _referrer_klass_tag = tag_for(tag_map, _referrer-&gt;klass()-&gt;java_mirror());
 743     }
 744   }
 745 
 746   ~TwoOopCallbackWrapper() {
 747     if (!is_reference_to_self()){
 748       post_callback_tag_update(_referrer,
 749                                _referrer_hashmap,
 750                                _referrer_entry,
 751                                _referrer_obj_tag);
 752     }
 753   }
 754 
 755   // address of referrer tag
 756   // (for a self reference this will return the same thing as obj_tag_p())
 757   inline jlong* referrer_tag_p()        { return _referrer_tag_p; }
 758 
 759   // referrer&#39;s class tag
 760   inline jlong referrer_klass_tag()     { return _referrer_klass_tag; }
 761 };
 762 
 763 // tag an object
 764 //
 765 // This function is performance critical. If many threads attempt to tag objects
 766 // around the same time then it&#39;s possible that the Mutex associated with the
 767 // tag map will be a hot lock.
 768 void JvmtiTagMap::set_tag(jobject object, jlong tag) {
 769   MutexLocker ml(lock());
 770   TSAN_ONLY(TsanMutexScope tms(lock()));
 771 
 772   // resolve the object
 773   oop o = JNIHandles::resolve_non_null(object);
 774 
 775   // see if the object is already tagged
 776   JvmtiTagHashmap* hashmap = _hashmap;
 777   JvmtiTagHashmapEntry* entry = hashmap-&gt;find(o);
 778 
 779   // if the object is not already tagged then we tag it
 780   if (entry == NULL) {
 781     if (tag != 0) {
 782       entry = create_entry(o, tag);
 783       hashmap-&gt;add(o, entry);
 784     } else {
 785       // no-op
 786     }
 787   } else {
 788     // if the object is already tagged then we either update
 789     // the tag (if a new tag value has been provided)
 790     // or remove the object if the new tag value is 0.
 791     if (tag == 0) {
 792       hashmap-&gt;remove(o);
 793       destroy_entry(entry);
 794     } else {
 795       entry-&gt;set_tag(tag);
 796     }
 797   }
 798 }
 799 
 800 // get the tag for an object
 801 jlong JvmtiTagMap::get_tag(jobject object) {
 802   MutexLocker ml(lock());
 803   TSAN_ONLY(TsanMutexScope tms(lock()));
 804 
 805   // resolve the object
 806   oop o = JNIHandles::resolve_non_null(object);
 807 
 808   return tag_for(this, o);
 809 }
 810 
 811 
 812 // Helper class used to describe the static or instance fields of a class.
 813 // For each field it holds the field index (as defined by the JVMTI specification),
 814 // the field type, and the offset.
 815 
 816 class ClassFieldDescriptor: public CHeapObj&lt;mtInternal&gt; {
 817  private:
 818   int _field_index;
 819   int _field_offset;
 820   char _field_type;
 821  public:
 822   ClassFieldDescriptor(int index, char type, int offset) :
 823     _field_index(index), _field_offset(offset), _field_type(type) {
 824   }
 825   int field_index()  const  { return _field_index; }
 826   char field_type()  const  { return _field_type; }
 827   int field_offset() const  { return _field_offset; }
 828 };
 829 
 830 class ClassFieldMap: public CHeapObj&lt;mtInternal&gt; {
 831  private:
 832   enum {
 833     initial_field_count = 5
 834   };
 835 
 836   // list of field descriptors
 837   GrowableArray&lt;ClassFieldDescriptor*&gt;* _fields;
 838 
 839   // constructor
 840   ClassFieldMap();
 841 
 842   // add a field
 843   void add(int index, char type, int offset);
 844 
 845   // returns the field count for the given class
 846   static int compute_field_count(InstanceKlass* ik);
 847 
 848  public:
 849   ~ClassFieldMap();
 850 
 851   // access
 852   int field_count()                     { return _fields-&gt;length(); }
 853   ClassFieldDescriptor* field_at(int i) { return _fields-&gt;at(i); }
 854 
 855   // functions to create maps of static or instance fields
 856   static ClassFieldMap* create_map_of_static_fields(Klass* k);
 857   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 858 };
 859 
 860 ClassFieldMap::ClassFieldMap() {
 861   _fields = new (ResourceObj::C_HEAP, mtInternal)
 862     GrowableArray&lt;ClassFieldDescriptor*&gt;(initial_field_count, true);
 863 }
 864 
 865 ClassFieldMap::~ClassFieldMap() {
 866   for (int i=0; i&lt;_fields-&gt;length(); i++) {
 867     delete _fields-&gt;at(i);
 868   }
 869   delete _fields;
 870 }
 871 
 872 void ClassFieldMap::add(int index, char type, int offset) {
 873   ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);
 874   _fields-&gt;append(field);
 875 }
 876 
 877 // Returns a heap allocated ClassFieldMap to describe the static fields
 878 // of the given class.
 879 //
 880 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
 881   HandleMark hm;
 882   InstanceKlass* ik = InstanceKlass::cast(k);
 883 
 884   // create the field map
 885   ClassFieldMap* field_map = new ClassFieldMap();
 886 
 887   FilteredFieldStream f(ik, false, false);
 888   int max_field_index = f.field_count()-1;
 889 
 890   int index = 0;
 891   for (FilteredFieldStream fld(ik, true, true); !fld.eos(); fld.next(), index++) {
 892     // ignore instance fields
 893     if (!fld.access_flags().is_static()) {
 894       continue;
 895     }
 896     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 897   }
 898   return field_map;
 899 }
 900 
 901 // Returns a heap allocated ClassFieldMap to describe the instance fields
 902 // of the given class. All instance fields are included (this means public
 903 // and private fields declared in superclasses and superinterfaces too).
 904 //
 905 ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {
 906   HandleMark hm;
 907   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
 908 
 909   // create the field map
 910   ClassFieldMap* field_map = new ClassFieldMap();
 911 
 912   FilteredFieldStream f(ik, false, false);
 913 
 914   int max_field_index = f.field_count()-1;
 915 
 916   int index = 0;
 917   for (FilteredFieldStream fld(ik, false, false); !fld.eos(); fld.next(), index++) {
 918     // ignore static fields
 919     if (fld.access_flags().is_static()) {
 920       continue;
 921     }
 922     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 923   }
 924 
 925   return field_map;
 926 }
 927 
 928 // Helper class used to cache a ClassFileMap for the instance fields of
 929 // a cache. A JvmtiCachedClassFieldMap can be cached by an InstanceKlass during
 930 // heap iteration and avoid creating a field map for each object in the heap
 931 // (only need to create the map when the first instance of a class is encountered).
 932 //
 933 class JvmtiCachedClassFieldMap : public CHeapObj&lt;mtInternal&gt; {
 934  private:
 935    enum {
 936      initial_class_count = 200
 937    };
 938   ClassFieldMap* _field_map;
 939 
 940   ClassFieldMap* field_map() const          { return _field_map; }
 941 
 942   JvmtiCachedClassFieldMap(ClassFieldMap* field_map);
 943   ~JvmtiCachedClassFieldMap();
 944 
 945   static GrowableArray&lt;InstanceKlass*&gt;* _class_list;
 946   static void add_to_class_list(InstanceKlass* ik);
 947 
 948  public:
 949   // returns the field map for a given object (returning map cached
 950   // by InstanceKlass if possible
 951   static ClassFieldMap* get_map_of_instance_fields(oop obj);
 952 
 953   // removes the field map from all instanceKlasses - should be
 954   // called before VM operation completes
 955   static void clear_cache();
 956 
 957   // returns the number of ClassFieldMap cached by instanceKlasses
 958   static int cached_field_map_count();
 959 };
 960 
 961 GrowableArray&lt;InstanceKlass*&gt;* JvmtiCachedClassFieldMap::_class_list;
 962 
 963 JvmtiCachedClassFieldMap::JvmtiCachedClassFieldMap(ClassFieldMap* field_map) {
 964   _field_map = field_map;
 965 }
 966 
 967 JvmtiCachedClassFieldMap::~JvmtiCachedClassFieldMap() {
 968   if (_field_map != NULL) {
 969     delete _field_map;
 970   }
 971 }
 972 
 973 // Marker class to ensure that the class file map cache is only used in a defined
 974 // scope.
 975 class ClassFieldMapCacheMark : public StackObj {
 976  private:
 977    static bool _is_active;
 978  public:
 979    ClassFieldMapCacheMark() {
 980      assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 981      assert(JvmtiCachedClassFieldMap::cached_field_map_count() == 0, &quot;cache not empty&quot;);
 982      assert(!_is_active, &quot;ClassFieldMapCacheMark cannot be nested&quot;);
 983      _is_active = true;
 984    }
 985    ~ClassFieldMapCacheMark() {
 986      JvmtiCachedClassFieldMap::clear_cache();
 987      _is_active = false;
 988    }
 989    static bool is_active() { return _is_active; }
 990 };
 991 
 992 bool ClassFieldMapCacheMark::_is_active;
 993 
 994 
 995 // record that the given InstanceKlass is caching a field map
 996 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
 997   if (_class_list == NULL) {
 998     _class_list = new (ResourceObj::C_HEAP, mtInternal)
 999       GrowableArray&lt;InstanceKlass*&gt;(initial_class_count, true);
1000   }
1001   _class_list-&gt;push(ik);
1002 }
1003 
1004 // returns the instance field map for the given object
1005 // (returns field map cached by the InstanceKlass if possible)
1006 ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {
1007   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1008   assert(ClassFieldMapCacheMark::is_active(), &quot;ClassFieldMapCacheMark not active&quot;);
1009 
1010   Klass* k = obj-&gt;klass();
1011   InstanceKlass* ik = InstanceKlass::cast(k);
1012 
1013   // return cached map if possible
1014   JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
1015   if (cached_map != NULL) {
1016     assert(cached_map-&gt;field_map() != NULL, &quot;missing field list&quot;);
1017     return cached_map-&gt;field_map();
1018   } else {
1019     ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);
1020     cached_map = new JvmtiCachedClassFieldMap(field_map);
1021     ik-&gt;set_jvmti_cached_class_field_map(cached_map);
1022     add_to_class_list(ik);
1023     return field_map;
1024   }
1025 }
1026 
1027 // remove the fields maps cached from all instanceKlasses
1028 void JvmtiCachedClassFieldMap::clear_cache() {
1029   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1030   if (_class_list != NULL) {
1031     for (int i = 0; i &lt; _class_list-&gt;length(); i++) {
1032       InstanceKlass* ik = _class_list-&gt;at(i);
1033       JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
1034       assert(cached_map != NULL, &quot;should not be NULL&quot;);
1035       ik-&gt;set_jvmti_cached_class_field_map(NULL);
1036       delete cached_map;  // deletes the encapsulated field map
1037     }
1038     delete _class_list;
1039     _class_list = NULL;
1040   }
1041 }
1042 
1043 // returns the number of ClassFieldMap cached by instanceKlasses
1044 int JvmtiCachedClassFieldMap::cached_field_map_count() {
1045   return (_class_list == NULL) ? 0 : _class_list-&gt;length();
1046 }
1047 
1048 // helper function to indicate if an object is filtered by its tag or class tag
1049 static inline bool is_filtered_by_heap_filter(jlong obj_tag,
1050                                               jlong klass_tag,
1051                                               int heap_filter) {
1052   // apply the heap filter
1053   if (obj_tag != 0) {
1054     // filter out tagged objects
1055     if (heap_filter &amp; JVMTI_HEAP_FILTER_TAGGED) return true;
1056   } else {
1057     // filter out untagged objects
1058     if (heap_filter &amp; JVMTI_HEAP_FILTER_UNTAGGED) return true;
1059   }
1060   if (klass_tag != 0) {
1061     // filter out objects with tagged classes
1062     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_TAGGED) return true;
1063   } else {
1064     // filter out objects with untagged classes.
1065     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_UNTAGGED) return true;
1066   }
1067   return false;
1068 }
1069 
1070 // helper function to indicate if an object is filtered by a klass filter
1071 static inline bool is_filtered_by_klass_filter(oop obj, Klass* klass_filter) {
1072   if (klass_filter != NULL) {
1073     if (obj-&gt;klass() != klass_filter) {
1074       return true;
1075     }
1076   }
1077   return false;
1078 }
1079 
1080 // helper function to tell if a field is a primitive field or not
1081 static inline bool is_primitive_field_type(char type) {
1082   return (type != &#39;L&#39; &amp;&amp; type != &#39;[&#39;);
1083 }
1084 
1085 // helper function to copy the value from location addr to jvalue.
1086 static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
1087   switch (value_type) {
1088     case JVMTI_PRIMITIVE_TYPE_BOOLEAN : { v-&gt;z = *(jboolean*)addr; break; }
1089     case JVMTI_PRIMITIVE_TYPE_BYTE    : { v-&gt;b = *(jbyte*)addr;    break; }
1090     case JVMTI_PRIMITIVE_TYPE_CHAR    : { v-&gt;c = *(jchar*)addr;    break; }
1091     case JVMTI_PRIMITIVE_TYPE_SHORT   : { v-&gt;s = *(jshort*)addr;   break; }
1092     case JVMTI_PRIMITIVE_TYPE_INT     : { v-&gt;i = *(jint*)addr;     break; }
1093     case JVMTI_PRIMITIVE_TYPE_LONG    : { v-&gt;j = *(jlong*)addr;    break; }
1094     case JVMTI_PRIMITIVE_TYPE_FLOAT   : { v-&gt;f = *(jfloat*)addr;   break; }
1095     case JVMTI_PRIMITIVE_TYPE_DOUBLE  : { v-&gt;d = *(jdouble*)addr;  break; }
1096     default: ShouldNotReachHere();
1097   }
1098 }
1099 
1100 // helper function to invoke string primitive value callback
1101 // returns visit control flags
1102 static jint invoke_string_value_callback(jvmtiStringPrimitiveValueCallback cb,
1103                                          CallbackWrapper* wrapper,
1104                                          oop str,
1105                                          void* user_data)
1106 {
1107   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
1108 
1109   typeArrayOop s_value = java_lang_String::value(str);
1110 
1111   // JDK-6584008: the value field may be null if a String instance is
1112   // partially constructed.
1113   if (s_value == NULL) {
1114     return 0;
1115   }
1116   // get the string value and length
1117   // (string value may be offset from the base)
1118   int s_len = java_lang_String::length(str);
1119   bool is_latin1 = java_lang_String::is_latin1(str);
1120   jchar* value;
1121   if (s_len &gt; 0) {
1122     if (!is_latin1) {
1123       value = s_value-&gt;char_at_addr(0);
1124     } else {
1125       // Inflate latin1 encoded string to UTF16
1126       jchar* buf = NEW_C_HEAP_ARRAY(jchar, s_len, mtInternal);
1127       for (int i = 0; i &lt; s_len; i++) {
1128         buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
1129       }
1130       value = &amp;buf[0];
1131     }
1132   } else {
1133     // Don&#39;t use char_at_addr(0) if length is 0
1134     value = (jchar*) s_value-&gt;base(T_CHAR);
1135   }
1136 
1137   // invoke the callback
1138   jint res = (*cb)(wrapper-&gt;klass_tag(),
1139                    wrapper-&gt;obj_size(),
1140                    wrapper-&gt;obj_tag_p(),
1141                    value,
1142                    (jint)s_len,
1143                    user_data);
1144 
1145   if (is_latin1 &amp;&amp; s_len &gt; 0) {
1146     FREE_C_HEAP_ARRAY(jchar, value);
1147   }
1148   return res;
1149 }
1150 
1151 // helper function to invoke string primitive value callback
1152 // returns visit control flags
1153 static jint invoke_array_primitive_value_callback(jvmtiArrayPrimitiveValueCallback cb,
1154                                                   CallbackWrapper* wrapper,
1155                                                   oop obj,
1156                                                   void* user_data)
1157 {
1158   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
1159 
1160   // get base address of first element
1161   typeArrayOop array = typeArrayOop(obj);
1162   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1163   void* elements = array-&gt;base(type);
1164 
1165   // jvmtiPrimitiveType is defined so this mapping is always correct
1166   jvmtiPrimitiveType elem_type = (jvmtiPrimitiveType)type2char(type);
1167 
1168   return (*cb)(wrapper-&gt;klass_tag(),
1169                wrapper-&gt;obj_size(),
1170                wrapper-&gt;obj_tag_p(),
1171                (jint)array-&gt;length(),
1172                elem_type,
1173                elements,
1174                user_data);
1175 }
1176 
1177 // helper function to invoke the primitive field callback for all static fields
1178 // of a given class
1179 static jint invoke_primitive_field_callback_for_static_fields
1180   (CallbackWrapper* wrapper,
1181    oop obj,
1182    jvmtiPrimitiveFieldCallback cb,
1183    void* user_data)
1184 {
1185   // for static fields only the index will be set
1186   static jvmtiHeapReferenceInfo reference_info = { 0 };
1187 
1188   assert(obj-&gt;klass() == SystemDictionary::Class_klass(), &quot;not a class&quot;);
1189   if (java_lang_Class::is_primitive(obj)) {
1190     return 0;
1191   }
1192   Klass* klass = java_lang_Class::as_Klass(obj);
1193 
1194   // ignore classes for object and type arrays
1195   if (!klass-&gt;is_instance_klass()) {
1196     return 0;
1197   }
1198 
1199   // ignore classes which aren&#39;t linked yet
1200   InstanceKlass* ik = InstanceKlass::cast(klass);
1201   if (!ik-&gt;is_linked()) {
1202     return 0;
1203   }
1204 
1205   // get the field map
1206   ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
1207 
1208   // invoke the callback for each static primitive field
1209   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
1210     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
1211 
1212     // ignore non-primitive fields
1213     char type = field-&gt;field_type();
1214     if (!is_primitive_field_type(type)) {
1215       continue;
1216     }
1217     // one-to-one mapping
1218     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1219 
1220     // get offset and field value
1221     int offset = field-&gt;field_offset();
1222     address addr = (address)klass-&gt;java_mirror() + offset;
1223     jvalue value;
1224     copy_to_jvalue(&amp;value, addr, value_type);
1225 
1226     // field index
1227     reference_info.field.index = field-&gt;field_index();
1228 
1229     // invoke the callback
1230     jint res = (*cb)(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
1231                      &amp;reference_info,
1232                      wrapper-&gt;klass_tag(),
1233                      wrapper-&gt;obj_tag_p(),
1234                      value,
1235                      value_type,
1236                      user_data);
1237     if (res &amp; JVMTI_VISIT_ABORT) {
1238       delete field_map;
1239       return res;
1240     }
1241   }
1242 
1243   delete field_map;
1244   return 0;
1245 }
1246 
1247 // helper function to invoke the primitive field callback for all instance fields
1248 // of a given object
1249 static jint invoke_primitive_field_callback_for_instance_fields(
1250   CallbackWrapper* wrapper,
1251   oop obj,
1252   jvmtiPrimitiveFieldCallback cb,
1253   void* user_data)
1254 {
1255   // for instance fields only the index will be set
1256   static jvmtiHeapReferenceInfo reference_info = { 0 };
1257 
1258   // get the map of the instance fields
1259   ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj);
1260 
1261   // invoke the callback for each instance primitive field
1262   for (int i=0; i&lt;fields-&gt;field_count(); i++) {
1263     ClassFieldDescriptor* field = fields-&gt;field_at(i);
1264 
1265     // ignore non-primitive fields
1266     char type = field-&gt;field_type();
1267     if (!is_primitive_field_type(type)) {
1268       continue;
1269     }
1270     // one-to-one mapping
1271     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1272 
1273     // get offset and field value
1274     int offset = field-&gt;field_offset();
1275     address addr = (address)obj + offset;
1276     jvalue value;
1277     copy_to_jvalue(&amp;value, addr, value_type);
1278 
1279     // field index
1280     reference_info.field.index = field-&gt;field_index();
1281 
1282     // invoke the callback
1283     jint res = (*cb)(JVMTI_HEAP_REFERENCE_FIELD,
1284                      &amp;reference_info,
1285                      wrapper-&gt;klass_tag(),
1286                      wrapper-&gt;obj_tag_p(),
1287                      value,
1288                      value_type,
1289                      user_data);
1290     if (res &amp; JVMTI_VISIT_ABORT) {
1291       return res;
1292     }
1293   }
1294   return 0;
1295 }
1296 
1297 
1298 // VM operation to iterate over all objects in the heap (both reachable
1299 // and unreachable)
1300 class VM_HeapIterateOperation: public VM_Operation {
1301  private:
1302   ObjectClosure* _blk;
1303   JvmtiTagMap* _tag_map;
1304 
1305  public:
1306   VM_HeapIterateOperation(ObjectClosure* blk, JvmtiTagMap* tag_map) {
1307     _blk = blk;
1308     _tag_map = tag_map;
1309   }
1310 
1311   VMOp_Type type() const { return VMOp_HeapIterateOperation; }
1312   void doit() {
1313     // Simulates barrier synchronization on safepoint.
1314     // This annotation is reasonably minimal in number of tsan callbacks.
1315     // By passing the lock directly, we are not actually locking it, just
1316     // telling TSAN we are to &quot;simulate&quot; the lock.
1317     TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));
1318 
1319     // allows class files maps to be cached during iteration
1320     ClassFieldMapCacheMark cm;
1321 
1322     // make sure that heap is parsable (fills TLABs with filler objects)
1323     Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1324 
1325     // Verify heap before iteration - if the heap gets corrupted then
1326     // JVMTI&#39;s IterateOverHeap will crash.
1327     if (VerifyBeforeIteration) {
1328       Universe::verify();
1329     }
1330 
1331     // do the iteration
1332     // If this operation encounters a bad object when using CMS,
1333     // consider using safe_object_iterate() which avoids perm gen
1334     // objects that may contain bad references.
1335     Universe::heap()-&gt;object_iterate(_blk);
1336   }
1337 
1338 };
1339 
1340 
1341 // An ObjectClosure used to support the deprecated IterateOverHeap and
1342 // IterateOverInstancesOfClass functions
1343 class IterateOverHeapObjectClosure: public ObjectClosure {
1344  private:
1345   JvmtiTagMap* _tag_map;
1346   Klass* _klass;
1347   jvmtiHeapObjectFilter _object_filter;
1348   jvmtiHeapObjectCallback _heap_object_callback;
1349   const void* _user_data;
1350 
1351   // accessors
1352   JvmtiTagMap* tag_map() const                    { return _tag_map; }
1353   jvmtiHeapObjectFilter object_filter() const     { return _object_filter; }
1354   jvmtiHeapObjectCallback object_callback() const { return _heap_object_callback; }
1355   Klass* klass() const                            { return _klass; }
1356   const void* user_data() const                   { return _user_data; }
1357 
1358   // indicates if iteration has been aborted
1359   bool _iteration_aborted;
1360   bool is_iteration_aborted() const               { return _iteration_aborted; }
1361   void set_iteration_aborted(bool aborted)        { _iteration_aborted = aborted; }
1362 
1363  public:
1364   IterateOverHeapObjectClosure(JvmtiTagMap* tag_map,
1365                                Klass* klass,
1366                                jvmtiHeapObjectFilter object_filter,
1367                                jvmtiHeapObjectCallback heap_object_callback,
1368                                const void* user_data) :
1369     _tag_map(tag_map),
1370     _klass(klass),
1371     _object_filter(object_filter),
1372     _heap_object_callback(heap_object_callback),
1373     _user_data(user_data),
1374     _iteration_aborted(false)
1375   {
1376   }
1377 
1378   void do_object(oop o);
1379 };
1380 
1381 // invoked for each object in the heap
1382 void IterateOverHeapObjectClosure::do_object(oop o) {
1383   // check if iteration has been halted
1384   if (is_iteration_aborted()) return;
1385 
1386   // instanceof check when filtering by klass
1387   if (klass() != NULL &amp;&amp; !o-&gt;is_a(klass())) {
1388     return;
1389   }
1390   // prepare for the calllback
1391   CallbackWrapper wrapper(tag_map(), o);
1392 
1393   // if the object is tagged and we&#39;re only interested in untagged objects
1394   // then don&#39;t invoke the callback. Similiarly, if the object is untagged
1395   // and we&#39;re only interested in tagged objects we skip the callback.
1396   if (wrapper.obj_tag() != 0) {
1397     if (object_filter() == JVMTI_HEAP_OBJECT_UNTAGGED) return;
1398   } else {
1399     if (object_filter() == JVMTI_HEAP_OBJECT_TAGGED) return;
1400   }
1401 
1402   // invoke the agent&#39;s callback
1403   jvmtiIterationControl control = (*object_callback())(wrapper.klass_tag(),
1404                                                        wrapper.obj_size(),
1405                                                        wrapper.obj_tag_p(),
1406                                                        (void*)user_data());
1407   if (control == JVMTI_ITERATION_ABORT) {
1408     set_iteration_aborted(true);
1409   }
1410 }
1411 
1412 // An ObjectClosure used to support the IterateThroughHeap function
1413 class IterateThroughHeapObjectClosure: public ObjectClosure {
1414  private:
1415   JvmtiTagMap* _tag_map;
1416   Klass* _klass;
1417   int _heap_filter;
1418   const jvmtiHeapCallbacks* _callbacks;
1419   const void* _user_data;
1420 
1421   // accessor functions
1422   JvmtiTagMap* tag_map() const                     { return _tag_map; }
1423   int heap_filter() const                          { return _heap_filter; }
1424   const jvmtiHeapCallbacks* callbacks() const      { return _callbacks; }
1425   Klass* klass() const                             { return _klass; }
1426   const void* user_data() const                    { return _user_data; }
1427 
1428   // indicates if the iteration has been aborted
1429   bool _iteration_aborted;
1430   bool is_iteration_aborted() const                { return _iteration_aborted; }
1431 
1432   // used to check the visit control flags. If the abort flag is set
1433   // then we set the iteration aborted flag so that the iteration completes
1434   // without processing any further objects
1435   bool check_flags_for_abort(jint flags) {
1436     bool is_abort = (flags &amp; JVMTI_VISIT_ABORT) != 0;
1437     if (is_abort) {
1438       _iteration_aborted = true;
1439     }
1440     return is_abort;
1441   }
1442 
1443  public:
1444   IterateThroughHeapObjectClosure(JvmtiTagMap* tag_map,
1445                                   Klass* klass,
1446                                   int heap_filter,
1447                                   const jvmtiHeapCallbacks* heap_callbacks,
1448                                   const void* user_data) :
1449     _tag_map(tag_map),
1450     _klass(klass),
1451     _heap_filter(heap_filter),
1452     _callbacks(heap_callbacks),
1453     _user_data(user_data),
1454     _iteration_aborted(false)
1455   {
1456   }
1457 
1458   void do_object(oop o);
1459 };
1460 
1461 // invoked for each object in the heap
1462 void IterateThroughHeapObjectClosure::do_object(oop obj) {
1463   // check if iteration has been halted
1464   if (is_iteration_aborted()) return;
1465 
1466   // apply class filter
1467   if (is_filtered_by_klass_filter(obj, klass())) return;
1468 
1469   // prepare for callback
1470   CallbackWrapper wrapper(tag_map(), obj);
1471 
1472   // check if filtered by the heap filter
1473   if (is_filtered_by_heap_filter(wrapper.obj_tag(), wrapper.klass_tag(), heap_filter())) {
1474     return;
1475   }
1476 
1477   // for arrays we need the length, otherwise -1
1478   bool is_array = obj-&gt;is_array();
1479   int len = is_array ? arrayOop(obj)-&gt;length() : -1;
1480 
1481   // invoke the object callback (if callback is provided)
1482   if (callbacks()-&gt;heap_iteration_callback != NULL) {
1483     jvmtiHeapIterationCallback cb = callbacks()-&gt;heap_iteration_callback;
1484     jint res = (*cb)(wrapper.klass_tag(),
1485                      wrapper.obj_size(),
1486                      wrapper.obj_tag_p(),
1487                      (jint)len,
1488                      (void*)user_data());
1489     if (check_flags_for_abort(res)) return;
1490   }
1491 
1492   // for objects and classes we report primitive fields if callback provided
1493   if (callbacks()-&gt;primitive_field_callback != NULL &amp;&amp; obj-&gt;is_instance()) {
1494     jint res;
1495     jvmtiPrimitiveFieldCallback cb = callbacks()-&gt;primitive_field_callback;
1496     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
1497       res = invoke_primitive_field_callback_for_static_fields(&amp;wrapper,
1498                                                                     obj,
1499                                                                     cb,
1500                                                                     (void*)user_data());
1501     } else {
1502       res = invoke_primitive_field_callback_for_instance_fields(&amp;wrapper,
1503                                                                       obj,
1504                                                                       cb,
1505                                                                       (void*)user_data());
1506     }
1507     if (check_flags_for_abort(res)) return;
1508   }
1509 
1510   // string callback
1511   if (!is_array &amp;&amp;
1512       callbacks()-&gt;string_primitive_value_callback != NULL &amp;&amp;
1513       obj-&gt;klass() == SystemDictionary::String_klass()) {
1514     jint res = invoke_string_value_callback(
1515                 callbacks()-&gt;string_primitive_value_callback,
1516                 &amp;wrapper,
1517                 obj,
1518                 (void*)user_data() );
1519     if (check_flags_for_abort(res)) return;
1520   }
1521 
1522   // array callback
1523   if (is_array &amp;&amp;
1524       callbacks()-&gt;array_primitive_value_callback != NULL &amp;&amp;
1525       obj-&gt;is_typeArray()) {
1526     jint res = invoke_array_primitive_value_callback(
1527                callbacks()-&gt;array_primitive_value_callback,
1528                &amp;wrapper,
1529                obj,
1530                (void*)user_data() );
1531     if (check_flags_for_abort(res)) return;
1532   }
1533 };
1534 
1535 
1536 // Deprecated function to iterate over all objects in the heap
1537 void JvmtiTagMap::iterate_over_heap(jvmtiHeapObjectFilter object_filter,
1538                                     Klass* klass,
1539                                     jvmtiHeapObjectCallback heap_object_callback,
1540                                     const void* user_data)
1541 {
1542   MutexLocker ml(Heap_lock);
1543   IterateOverHeapObjectClosure blk(this,
1544                                    klass,
1545                                    object_filter,
1546                                    heap_object_callback,
1547                                    user_data);
1548   VM_HeapIterateOperation op(&amp;blk, this);
1549   VMThread::execute(&amp;op);
1550 }
1551 
1552 
1553 // Iterates over all objects in the heap
1554 void JvmtiTagMap::iterate_through_heap(jint heap_filter,
1555                                        Klass* klass,
1556                                        const jvmtiHeapCallbacks* callbacks,
1557                                        const void* user_data)
1558 {
1559   MutexLocker ml(Heap_lock);
1560   IterateThroughHeapObjectClosure blk(this,
1561                                       klass,
1562                                       heap_filter,
1563                                       callbacks,
1564                                       user_data);
1565   VM_HeapIterateOperation op(&amp;blk, this);
1566   VMThread::execute(&amp;op);
1567 }
1568 
1569 // support class for get_objects_with_tags
1570 
1571 class TagObjectCollector : public JvmtiTagHashmapEntryClosure {
1572  private:
1573   JvmtiEnv* _env;
1574   jlong* _tags;
1575   jint _tag_count;
1576 
1577   GrowableArray&lt;jobject&gt;* _object_results;  // collected objects (JNI weak refs)
1578   GrowableArray&lt;uint64_t&gt;* _tag_results;    // collected tags
1579 
1580  public:
1581   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
1582     _env = env;
1583     _tags = (jlong*)tags;
1584     _tag_count = tag_count;
1585     _object_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;jobject&gt;(1,true);
1586     _tag_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;uint64_t&gt;(1,true);
1587   }
1588 
1589   ~TagObjectCollector() {
1590     delete _object_results;
1591     delete _tag_results;
1592   }
1593 
1594   // for each tagged object check if the tag value matches
1595   // - if it matches then we create a JNI local reference to the object
1596   // and record the reference and tag value.
1597   //
1598   void do_entry(JvmtiTagHashmapEntry* entry) {
1599     for (int i=0; i&lt;_tag_count; i++) {
1600       if (_tags[i] == entry-&gt;tag()) {
1601         // The reference in this tag map could be the only (implicitly weak)
1602         // reference to that object. If we hand it out, we need to keep it live wrt
1603         // SATB marking similar to other j.l.ref.Reference referents. This is
1604         // achieved by using a phantom load in the object() accessor.
1605         oop o = entry-&gt;object();
1606         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in_reserved(o), &quot;sanity check&quot;);
1607         jobject ref = JNIHandles::make_local(JavaThread::current(), o);
1608         _object_results-&gt;append(ref);
1609         _tag_results-&gt;append((uint64_t)entry-&gt;tag());
1610       }
1611     }
1612   }
1613 
1614   // return the results from the collection
1615   //
1616   jvmtiError result(jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1617     jvmtiError error;
1618     int count = _object_results-&gt;length();
1619     assert(count &gt;= 0, &quot;sanity check&quot;);
1620 
1621     // if object_result_ptr is not NULL then allocate the result and copy
1622     // in the object references.
1623     if (object_result_ptr != NULL) {
1624       error = _env-&gt;Allocate(count * sizeof(jobject), (unsigned char**)object_result_ptr);
1625       if (error != JVMTI_ERROR_NONE) {
1626         return error;
1627       }
1628       for (int i=0; i&lt;count; i++) {
1629         (*object_result_ptr)[i] = _object_results-&gt;at(i);
1630       }
1631     }
1632 
1633     // if tag_result_ptr is not NULL then allocate the result and copy
1634     // in the tag values.
1635     if (tag_result_ptr != NULL) {
1636       error = _env-&gt;Allocate(count * sizeof(jlong), (unsigned char**)tag_result_ptr);
1637       if (error != JVMTI_ERROR_NONE) {
1638         if (object_result_ptr != NULL) {
1639           _env-&gt;Deallocate((unsigned char*)object_result_ptr);
1640         }
1641         return error;
1642       }
1643       for (int i=0; i&lt;count; i++) {
1644         (*tag_result_ptr)[i] = (jlong)_tag_results-&gt;at(i);
1645       }
1646     }
1647 
1648     *count_ptr = count;
1649     return JVMTI_ERROR_NONE;
1650   }
1651 };
1652 
1653 // return the list of objects with the specified tags
1654 jvmtiError JvmtiTagMap::get_objects_with_tags(const jlong* tags,
1655   jint count, jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1656 
1657   TagObjectCollector collector(env(), tags, count);
1658   {
1659     // iterate over all tagged objects
1660     MutexLocker ml(lock());
1661     TSAN_ONLY(TsanMutexScope tms(lock()));
1662     entry_iterate(&amp;collector);
1663   }
1664   return collector.result(count_ptr, object_result_ptr, tag_result_ptr);
1665 }
1666 
1667 
1668 // ObjectMarker is used to support the marking objects when walking the
1669 // heap.
1670 //
1671 // This implementation uses the existing mark bits in an object for
1672 // marking. Objects that are marked must later have their headers restored.
1673 // As most objects are unlocked and don&#39;t have their identity hash computed
1674 // we don&#39;t have to save their headers. Instead we save the headers that
1675 // are &quot;interesting&quot;. Later when the headers are restored this implementation
1676 // restores all headers to their initial value and then restores the few
1677 // objects that had interesting headers.
1678 //
1679 // Future work: This implementation currently uses growable arrays to save
1680 // the oop and header of interesting objects. As an optimization we could
1681 // use the same technique as the GC and make use of the unused area
1682 // between top() and end().
1683 //
1684 
1685 // An ObjectClosure used to restore the mark bits of an object
1686 class RestoreMarksClosure : public ObjectClosure {
1687  public:
1688   void do_object(oop o) {
1689     if (o != NULL) {
1690       markOop mark = o-&gt;mark();
1691       if (mark-&gt;is_marked()) {
1692         o-&gt;init_mark();
1693       }
1694     }
1695   }
1696 };
1697 
1698 // ObjectMarker provides the mark and visited functions
1699 class ObjectMarker : AllStatic {
1700  private:
1701   // saved headers
1702   static GrowableArray&lt;oop&gt;* _saved_oop_stack;
1703   static GrowableArray&lt;markOop&gt;* _saved_mark_stack;
1704   static bool _needs_reset;                  // do we need to reset mark bits?
1705 
1706  public:
1707   static void init();                       // initialize
1708   static void done();                       // clean-up
1709 
1710   static inline void mark(oop o);           // mark an object
1711   static inline bool visited(oop o);        // check if object has been visited
1712 
1713   static inline bool needs_reset()            { return _needs_reset; }
1714   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
1715 };
1716 
1717 GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
1718 GrowableArray&lt;markOop&gt;* ObjectMarker::_saved_mark_stack = NULL;
1719 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
1720 
1721 // initialize ObjectMarker - prepares for object marking
1722 void ObjectMarker::init() {
1723   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1724 
1725   // prepare heap for iteration
1726   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1727 
1728   // create stacks for interesting headers
1729   _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markOop&gt;(4000, true);
1730   _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(4000, true);
1731 
1732   if (UseBiasedLocking) {
1733     BiasedLocking::preserve_marks();
1734   }
1735 }
1736 
1737 // Object marking is done so restore object headers
1738 void ObjectMarker::done() {
1739   // iterate over all objects and restore the mark bits to
1740   // their initial value
1741   RestoreMarksClosure blk;
1742   if (needs_reset()) {
1743     Universe::heap()-&gt;object_iterate(&amp;blk);
1744   } else {
1745     // We don&#39;t need to reset mark bits on this call, but reset the
1746     // flag to the default for the next call.
1747     set_needs_reset(true);
1748   }
1749 
1750   // now restore the interesting headers
1751   for (int i = 0; i &lt; _saved_oop_stack-&gt;length(); i++) {
1752     oop o = _saved_oop_stack-&gt;at(i);
1753     markOop mark = _saved_mark_stack-&gt;at(i);
1754     o-&gt;set_mark(mark);
1755   }
1756 
1757   if (UseBiasedLocking) {
1758     BiasedLocking::restore_marks();
1759   }
1760 
1761   // free the stacks
1762   delete _saved_oop_stack;
1763   delete _saved_mark_stack;
1764 }
1765 
1766 // mark an object
1767 inline void ObjectMarker::mark(oop o) {
1768   assert(Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
1769   assert(!o-&gt;mark()-&gt;is_marked(), &quot;should only mark an object once&quot;);
1770 
1771   // object&#39;s mark word
1772   markOop mark = o-&gt;mark();
1773 
1774   if (mark-&gt;must_be_preserved(o)) {
1775     _saved_mark_stack-&gt;push(mark);
1776     _saved_oop_stack-&gt;push(o);
1777   }
1778 
1779   // mark the object
1780   o-&gt;set_mark(markOopDesc::prototype()-&gt;set_marked());
1781 }
1782 
1783 // return true if object is marked
1784 inline bool ObjectMarker::visited(oop o) {
1785   return o-&gt;mark()-&gt;is_marked();
1786 }
1787 
1788 // Stack allocated class to help ensure that ObjectMarker is used
1789 // correctly. Constructor initializes ObjectMarker, destructor calls
1790 // ObjectMarker&#39;s done() function to restore object headers.
1791 class ObjectMarkerController : public StackObj {
1792  public:
1793   ObjectMarkerController() {
1794     ObjectMarker::init();
1795   }
1796   ~ObjectMarkerController() {
1797     ObjectMarker::done();
1798   }
1799 };
1800 
1801 
1802 // helper to map a jvmtiHeapReferenceKind to an old style jvmtiHeapRootKind
1803 // (not performance critical as only used for roots)
1804 static jvmtiHeapRootKind toJvmtiHeapRootKind(jvmtiHeapReferenceKind kind) {
1805   switch (kind) {
1806     case JVMTI_HEAP_REFERENCE_JNI_GLOBAL:   return JVMTI_HEAP_ROOT_JNI_GLOBAL;
1807     case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS: return JVMTI_HEAP_ROOT_SYSTEM_CLASS;
1808     case JVMTI_HEAP_REFERENCE_MONITOR:      return JVMTI_HEAP_ROOT_MONITOR;
1809     case JVMTI_HEAP_REFERENCE_STACK_LOCAL:  return JVMTI_HEAP_ROOT_STACK_LOCAL;
1810     case JVMTI_HEAP_REFERENCE_JNI_LOCAL:    return JVMTI_HEAP_ROOT_JNI_LOCAL;
1811     case JVMTI_HEAP_REFERENCE_THREAD:       return JVMTI_HEAP_ROOT_THREAD;
1812     case JVMTI_HEAP_REFERENCE_OTHER:        return JVMTI_HEAP_ROOT_OTHER;
1813     default: ShouldNotReachHere();          return JVMTI_HEAP_ROOT_OTHER;
1814   }
1815 }
1816 
1817 // Base class for all heap walk contexts. The base class maintains a flag
1818 // to indicate if the context is valid or not.
1819 class HeapWalkContext {
1820  private:
1821   bool _valid;
1822  public:
1823   HeapWalkContext(bool valid)                   { _valid = valid; }
1824   void invalidate()                             { _valid = false; }
1825   bool is_valid() const                         { return _valid; }
1826 };
1827 
1828 // A basic heap walk context for the deprecated heap walking functions.
1829 // The context for a basic heap walk are the callbacks and fields used by
1830 // the referrer caching scheme.
1831 class BasicHeapWalkContext: public HeapWalkContext {
1832  private:
1833   jvmtiHeapRootCallback _heap_root_callback;
1834   jvmtiStackReferenceCallback _stack_ref_callback;
1835   jvmtiObjectReferenceCallback _object_ref_callback;
1836 
1837   // used for caching
1838   oop _last_referrer;
1839   jlong _last_referrer_tag;
1840 
1841  public:
1842   BasicHeapWalkContext() : HeapWalkContext(false) { }
1843 
1844   BasicHeapWalkContext(jvmtiHeapRootCallback heap_root_callback,
1845                        jvmtiStackReferenceCallback stack_ref_callback,
1846                        jvmtiObjectReferenceCallback object_ref_callback) :
1847     HeapWalkContext(true),
1848     _heap_root_callback(heap_root_callback),
1849     _stack_ref_callback(stack_ref_callback),
1850     _object_ref_callback(object_ref_callback),
1851     _last_referrer(NULL),
1852     _last_referrer_tag(0) {
1853   }
1854 
1855   // accessors
1856   jvmtiHeapRootCallback heap_root_callback() const         { return _heap_root_callback; }
1857   jvmtiStackReferenceCallback stack_ref_callback() const   { return _stack_ref_callback; }
1858   jvmtiObjectReferenceCallback object_ref_callback() const { return _object_ref_callback;  }
1859 
1860   oop last_referrer() const               { return _last_referrer; }
1861   void set_last_referrer(oop referrer)    { _last_referrer = referrer; }
1862   jlong last_referrer_tag() const         { return _last_referrer_tag; }
1863   void set_last_referrer_tag(jlong value) { _last_referrer_tag = value; }
1864 };
1865 
1866 // The advanced heap walk context for the FollowReferences functions.
1867 // The context is the callbacks, and the fields used for filtering.
1868 class AdvancedHeapWalkContext: public HeapWalkContext {
1869  private:
1870   jint _heap_filter;
1871   Klass* _klass_filter;
1872   const jvmtiHeapCallbacks* _heap_callbacks;
1873 
1874  public:
1875   AdvancedHeapWalkContext() : HeapWalkContext(false) { }
1876 
1877   AdvancedHeapWalkContext(jint heap_filter,
1878                            Klass* klass_filter,
1879                            const jvmtiHeapCallbacks* heap_callbacks) :
1880     HeapWalkContext(true),
1881     _heap_filter(heap_filter),
1882     _klass_filter(klass_filter),
1883     _heap_callbacks(heap_callbacks) {
1884   }
1885 
1886   // accessors
1887   jint heap_filter() const         { return _heap_filter; }
1888   Klass* klass_filter() const      { return _klass_filter; }
1889 
1890   const jvmtiHeapReferenceCallback heap_reference_callback() const {
1891     return _heap_callbacks-&gt;heap_reference_callback;
1892   };
1893   const jvmtiPrimitiveFieldCallback primitive_field_callback() const {
1894     return _heap_callbacks-&gt;primitive_field_callback;
1895   }
1896   const jvmtiArrayPrimitiveValueCallback array_primitive_value_callback() const {
1897     return _heap_callbacks-&gt;array_primitive_value_callback;
1898   }
1899   const jvmtiStringPrimitiveValueCallback string_primitive_value_callback() const {
1900     return _heap_callbacks-&gt;string_primitive_value_callback;
1901   }
1902 };
1903 
1904 // The CallbackInvoker is a class with static functions that the heap walk can call
1905 // into to invoke callbacks. It works in one of two modes. The &quot;basic&quot; mode is
1906 // used for the deprecated IterateOverReachableObjects functions. The &quot;advanced&quot;
1907 // mode is for the newer FollowReferences function which supports a lot of
1908 // additional callbacks.
1909 class CallbackInvoker : AllStatic {
1910  private:
1911   // heap walk styles
1912   enum { basic, advanced };
1913   static int _heap_walk_type;
1914   static bool is_basic_heap_walk()           { return _heap_walk_type == basic; }
1915   static bool is_advanced_heap_walk()        { return _heap_walk_type == advanced; }
1916 
1917   // context for basic style heap walk
1918   static BasicHeapWalkContext _basic_context;
1919   static BasicHeapWalkContext* basic_context() {
1920     assert(_basic_context.is_valid(), &quot;invalid&quot;);
1921     return &amp;_basic_context;
1922   }
1923 
1924   // context for advanced style heap walk
1925   static AdvancedHeapWalkContext _advanced_context;
1926   static AdvancedHeapWalkContext* advanced_context() {
1927     assert(_advanced_context.is_valid(), &quot;invalid&quot;);
1928     return &amp;_advanced_context;
1929   }
1930 
1931   // context needed for all heap walks
1932   static JvmtiTagMap* _tag_map;
1933   static const void* _user_data;
1934   static GrowableArray&lt;oop&gt;* _visit_stack;
1935 
1936   // accessors
1937   static JvmtiTagMap* tag_map()                        { return _tag_map; }
1938   static const void* user_data()                       { return _user_data; }
1939   static GrowableArray&lt;oop&gt;* visit_stack()             { return _visit_stack; }
1940 
1941   // if the object hasn&#39;t been visited then push it onto the visit stack
1942   // so that it will be visited later
1943   static inline bool check_for_visit(oop obj) {
1944     if (!ObjectMarker::visited(obj)) visit_stack()-&gt;push(obj);
1945     return true;
1946   }
1947 
1948   // invoke basic style callbacks
1949   static inline bool invoke_basic_heap_root_callback
1950     (jvmtiHeapRootKind root_kind, oop obj);
1951   static inline bool invoke_basic_stack_ref_callback
1952     (jvmtiHeapRootKind root_kind, jlong thread_tag, jint depth, jmethodID method,
1953      int slot, oop obj);
1954   static inline bool invoke_basic_object_reference_callback
1955     (jvmtiObjectReferenceKind ref_kind, oop referrer, oop referree, jint index);
1956 
1957   // invoke advanced style callbacks
1958   static inline bool invoke_advanced_heap_root_callback
1959     (jvmtiHeapReferenceKind ref_kind, oop obj);
1960   static inline bool invoke_advanced_stack_ref_callback
1961     (jvmtiHeapReferenceKind ref_kind, jlong thread_tag, jlong tid, int depth,
1962      jmethodID method, jlocation bci, jint slot, oop obj);
1963   static inline bool invoke_advanced_object_reference_callback
1964     (jvmtiHeapReferenceKind ref_kind, oop referrer, oop referree, jint index);
1965 
1966   // used to report the value of primitive fields
1967   static inline bool report_primitive_field
1968     (jvmtiHeapReferenceKind ref_kind, oop obj, jint index, address addr, char type);
1969 
1970  public:
1971   // initialize for basic mode
1972   static void initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
1973                                              GrowableArray&lt;oop&gt;* visit_stack,
1974                                              const void* user_data,
1975                                              BasicHeapWalkContext context);
1976 
1977   // initialize for advanced mode
1978   static void initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
1979                                                 GrowableArray&lt;oop&gt;* visit_stack,
1980                                                 const void* user_data,
1981                                                 AdvancedHeapWalkContext context);
1982 
1983    // functions to report roots
1984   static inline bool report_simple_root(jvmtiHeapReferenceKind kind, oop o);
1985   static inline bool report_jni_local_root(jlong thread_tag, jlong tid, jint depth,
1986     jmethodID m, oop o);
1987   static inline bool report_stack_ref_root(jlong thread_tag, jlong tid, jint depth,
1988     jmethodID method, jlocation bci, jint slot, oop o);
1989 
1990   // functions to report references
1991   static inline bool report_array_element_reference(oop referrer, oop referree, jint index);
1992   static inline bool report_class_reference(oop referrer, oop referree);
1993   static inline bool report_class_loader_reference(oop referrer, oop referree);
1994   static inline bool report_signers_reference(oop referrer, oop referree);
1995   static inline bool report_protection_domain_reference(oop referrer, oop referree);
1996   static inline bool report_superclass_reference(oop referrer, oop referree);
1997   static inline bool report_interface_reference(oop referrer, oop referree);
1998   static inline bool report_static_field_reference(oop referrer, oop referree, jint slot);
1999   static inline bool report_field_reference(oop referrer, oop referree, jint slot);
2000   static inline bool report_constant_pool_reference(oop referrer, oop referree, jint index);
2001   static inline bool report_primitive_array_values(oop array);
2002   static inline bool report_string_value(oop str);
2003   static inline bool report_primitive_instance_field(oop o, jint index, address value, char type);
2004   static inline bool report_primitive_static_field(oop o, jint index, address value, char type);
2005 };
2006 
2007 // statics
2008 int CallbackInvoker::_heap_walk_type;
2009 BasicHeapWalkContext CallbackInvoker::_basic_context;
2010 AdvancedHeapWalkContext CallbackInvoker::_advanced_context;
2011 JvmtiTagMap* CallbackInvoker::_tag_map;
2012 const void* CallbackInvoker::_user_data;
2013 GrowableArray&lt;oop&gt;* CallbackInvoker::_visit_stack;
2014 
2015 // initialize for basic heap walk (IterateOverReachableObjects et al)
2016 void CallbackInvoker::initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
2017                                                      GrowableArray&lt;oop&gt;* visit_stack,
2018                                                      const void* user_data,
2019                                                      BasicHeapWalkContext context) {
2020   _tag_map = tag_map;
2021   _visit_stack = visit_stack;
2022   _user_data = user_data;
2023   _basic_context = context;
2024   _advanced_context.invalidate();       // will trigger assertion if used
2025   _heap_walk_type = basic;
2026 }
2027 
2028 // initialize for advanced heap walk (FollowReferences)
2029 void CallbackInvoker::initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
2030                                                         GrowableArray&lt;oop&gt;* visit_stack,
2031                                                         const void* user_data,
2032                                                         AdvancedHeapWalkContext context) {
2033   _tag_map = tag_map;
2034   _visit_stack = visit_stack;
2035   _user_data = user_data;
2036   _advanced_context = context;
2037   _basic_context.invalidate();      // will trigger assertion if used
2038   _heap_walk_type = advanced;
2039 }
2040 
2041 
2042 // invoke basic style heap root callback
2043 inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, oop obj) {
2044   // if we heap roots should be reported
2045   jvmtiHeapRootCallback cb = basic_context()-&gt;heap_root_callback();
2046   if (cb == NULL) {
2047     return check_for_visit(obj);
2048   }
2049 
2050   CallbackWrapper wrapper(tag_map(), obj);
2051   jvmtiIterationControl control = (*cb)(root_kind,
2052                                         wrapper.klass_tag(),
2053                                         wrapper.obj_size(),
2054                                         wrapper.obj_tag_p(),
2055                                         (void*)user_data());
2056   // push root to visit stack when following references
2057   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2058       basic_context()-&gt;object_ref_callback() != NULL) {
2059     visit_stack()-&gt;push(obj);
2060   }
2061   return control != JVMTI_ITERATION_ABORT;
2062 }
2063 
2064 // invoke basic style stack ref callback
2065 inline bool CallbackInvoker::invoke_basic_stack_ref_callback(jvmtiHeapRootKind root_kind,
2066                                                              jlong thread_tag,
2067                                                              jint depth,
2068                                                              jmethodID method,
2069                                                              int slot,
2070                                                              oop obj) {
2071   // if we stack refs should be reported
2072   jvmtiStackReferenceCallback cb = basic_context()-&gt;stack_ref_callback();
2073   if (cb == NULL) {
2074     return check_for_visit(obj);
2075   }
2076 
2077   CallbackWrapper wrapper(tag_map(), obj);
2078   jvmtiIterationControl control = (*cb)(root_kind,
2079                                         wrapper.klass_tag(),
2080                                         wrapper.obj_size(),
2081                                         wrapper.obj_tag_p(),
2082                                         thread_tag,
2083                                         depth,
2084                                         method,
2085                                         slot,
2086                                         (void*)user_data());
2087   // push root to visit stack when following references
2088   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2089       basic_context()-&gt;object_ref_callback() != NULL) {
2090     visit_stack()-&gt;push(obj);
2091   }
2092   return control != JVMTI_ITERATION_ABORT;
2093 }
2094 
2095 // invoke basic style object reference callback
2096 inline bool CallbackInvoker::invoke_basic_object_reference_callback(jvmtiObjectReferenceKind ref_kind,
2097                                                                     oop referrer,
2098                                                                     oop referree,
2099                                                                     jint index) {
2100 
2101   BasicHeapWalkContext* context = basic_context();
2102 
2103   // callback requires the referrer&#39;s tag. If it&#39;s the same referrer
2104   // as the last call then we use the cached value.
2105   jlong referrer_tag;
2106   if (referrer == context-&gt;last_referrer()) {
2107     referrer_tag = context-&gt;last_referrer_tag();
2108   } else {
2109     referrer_tag = tag_for(tag_map(), referrer);
2110   }
2111 
2112   // do the callback
2113   CallbackWrapper wrapper(tag_map(), referree);
2114   jvmtiObjectReferenceCallback cb = context-&gt;object_ref_callback();
2115   jvmtiIterationControl control = (*cb)(ref_kind,
2116                                         wrapper.klass_tag(),
2117                                         wrapper.obj_size(),
2118                                         wrapper.obj_tag_p(),
2119                                         referrer_tag,
2120                                         index,
2121                                         (void*)user_data());
2122 
2123   // record referrer and referrer tag. For self-references record the
2124   // tag value from the callback as this might differ from referrer_tag.
2125   context-&gt;set_last_referrer(referrer);
2126   if (referrer == referree) {
2127     context-&gt;set_last_referrer_tag(*wrapper.obj_tag_p());
2128   } else {
2129     context-&gt;set_last_referrer_tag(referrer_tag);
2130   }
2131 
2132   if (control == JVMTI_ITERATION_CONTINUE) {
2133     return check_for_visit(referree);
2134   } else {
2135     return control != JVMTI_ITERATION_ABORT;
2136   }
2137 }
2138 
2139 // invoke advanced style heap root callback
2140 inline bool CallbackInvoker::invoke_advanced_heap_root_callback(jvmtiHeapReferenceKind ref_kind,
2141                                                                 oop obj) {
2142   AdvancedHeapWalkContext* context = advanced_context();
2143 
2144   // check that callback is provided
2145   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2146   if (cb == NULL) {
2147     return check_for_visit(obj);
2148   }
2149 
2150   // apply class filter
2151   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2152     return check_for_visit(obj);
2153   }
2154 
2155   // setup the callback wrapper
2156   CallbackWrapper wrapper(tag_map(), obj);
2157 
2158   // apply tag filter
2159   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2160                                  wrapper.klass_tag(),
2161                                  context-&gt;heap_filter())) {
2162     return check_for_visit(obj);
2163   }
2164 
2165   // for arrays we need the length, otherwise -1
2166   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2167 
2168   // invoke the callback
2169   jint res  = (*cb)(ref_kind,
2170                     NULL, // referrer info
2171                     wrapper.klass_tag(),
2172                     0,    // referrer_class_tag is 0 for heap root
2173                     wrapper.obj_size(),
2174                     wrapper.obj_tag_p(),
2175                     NULL, // referrer_tag_p
2176                     len,
2177                     (void*)user_data());
2178   if (res &amp; JVMTI_VISIT_ABORT) {
2179     return false;// referrer class tag
2180   }
2181   if (res &amp; JVMTI_VISIT_OBJECTS) {
2182     check_for_visit(obj);
2183   }
2184   return true;
2185 }
2186 
2187 // report a reference from a thread stack to an object
2188 inline bool CallbackInvoker::invoke_advanced_stack_ref_callback(jvmtiHeapReferenceKind ref_kind,
2189                                                                 jlong thread_tag,
2190                                                                 jlong tid,
2191                                                                 int depth,
2192                                                                 jmethodID method,
2193                                                                 jlocation bci,
2194                                                                 jint slot,
2195                                                                 oop obj) {
2196   AdvancedHeapWalkContext* context = advanced_context();
2197 
2198   // check that callback is provider
2199   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2200   if (cb == NULL) {
2201     return check_for_visit(obj);
2202   }
2203 
2204   // apply class filter
2205   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2206     return check_for_visit(obj);
2207   }
2208 
2209   // setup the callback wrapper
2210   CallbackWrapper wrapper(tag_map(), obj);
2211 
2212   // apply tag filter
2213   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2214                                  wrapper.klass_tag(),
2215                                  context-&gt;heap_filter())) {
2216     return check_for_visit(obj);
2217   }
2218 
2219   // setup the referrer info
2220   jvmtiHeapReferenceInfo reference_info;
2221   reference_info.stack_local.thread_tag = thread_tag;
2222   reference_info.stack_local.thread_id = tid;
2223   reference_info.stack_local.depth = depth;
2224   reference_info.stack_local.method = method;
2225   reference_info.stack_local.location = bci;
2226   reference_info.stack_local.slot = slot;
2227 
2228   // for arrays we need the length, otherwise -1
2229   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2230 
2231   // call into the agent
2232   int res = (*cb)(ref_kind,
2233                   &amp;reference_info,
2234                   wrapper.klass_tag(),
2235                   0,    // referrer_class_tag is 0 for heap root (stack)
2236                   wrapper.obj_size(),
2237                   wrapper.obj_tag_p(),
2238                   NULL, // referrer_tag is 0 for root
2239                   len,
2240                   (void*)user_data());
2241 
2242   if (res &amp; JVMTI_VISIT_ABORT) {
2243     return false;
2244   }
2245   if (res &amp; JVMTI_VISIT_OBJECTS) {
2246     check_for_visit(obj);
2247   }
2248   return true;
2249 }
2250 
2251 // This mask is used to pass reference_info to a jvmtiHeapReferenceCallback
2252 // only for ref_kinds defined by the JVM TI spec. Otherwise, NULL is passed.
2253 #define REF_INFO_MASK  ((1 &lt;&lt; JVMTI_HEAP_REFERENCE_FIELD)         \
2254                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STATIC_FIELD)  \
2255                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT) \
2256                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_CONSTANT_POOL) \
2257                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STACK_LOCAL)   \
2258                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_JNI_LOCAL))
2259 
2260 // invoke the object reference callback to report a reference
2261 inline bool CallbackInvoker::invoke_advanced_object_reference_callback(jvmtiHeapReferenceKind ref_kind,
2262                                                                        oop referrer,
2263                                                                        oop obj,
2264                                                                        jint index)
2265 {
2266   // field index is only valid field in reference_info
2267   static jvmtiHeapReferenceInfo reference_info = { 0 };
2268 
2269   AdvancedHeapWalkContext* context = advanced_context();
2270 
2271   // check that callback is provider
2272   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2273   if (cb == NULL) {
2274     return check_for_visit(obj);
2275   }
2276 
2277   // apply class filter
2278   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2279     return check_for_visit(obj);
2280   }
2281 
2282   // setup the callback wrapper
2283   TwoOopCallbackWrapper wrapper(tag_map(), referrer, obj);
2284 
2285   // apply tag filter
2286   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2287                                  wrapper.klass_tag(),
2288                                  context-&gt;heap_filter())) {
2289     return check_for_visit(obj);
2290   }
2291 
2292   // field index is only valid field in reference_info
2293   reference_info.field.index = index;
2294 
2295   // for arrays we need the length, otherwise -1
2296   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2297 
2298   // invoke the callback
2299   int res = (*cb)(ref_kind,
2300                   (REF_INFO_MASK &amp; (1 &lt;&lt; ref_kind)) ? &amp;reference_info : NULL,
2301                   wrapper.klass_tag(),
2302                   wrapper.referrer_klass_tag(),
2303                   wrapper.obj_size(),
2304                   wrapper.obj_tag_p(),
2305                   wrapper.referrer_tag_p(),
2306                   len,
2307                   (void*)user_data());
2308 
2309   if (res &amp; JVMTI_VISIT_ABORT) {
2310     return false;
2311   }
2312   if (res &amp; JVMTI_VISIT_OBJECTS) {
2313     check_for_visit(obj);
2314   }
2315   return true;
2316 }
2317 
2318 // report a &quot;simple root&quot;
2319 inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, oop obj) {
2320   assert(kind != JVMTI_HEAP_REFERENCE_STACK_LOCAL &amp;&amp;
2321          kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL, &quot;not a simple root&quot;);
2322 
2323   if (is_basic_heap_walk()) {
2324     // map to old style root kind
2325     jvmtiHeapRootKind root_kind = toJvmtiHeapRootKind(kind);
2326     return invoke_basic_heap_root_callback(root_kind, obj);
2327   } else {
2328     assert(is_advanced_heap_walk(), &quot;wrong heap walk type&quot;);
2329     return invoke_advanced_heap_root_callback(kind, obj);
2330   }
2331 }
2332 
2333 
2334 // invoke the primitive array values
2335 inline bool CallbackInvoker::report_primitive_array_values(oop obj) {
2336   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
2337 
2338   AdvancedHeapWalkContext* context = advanced_context();
2339   assert(context-&gt;array_primitive_value_callback() != NULL, &quot;no callback&quot;);
2340 
2341   // apply class filter
2342   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2343     return true;
2344   }
2345 
2346   CallbackWrapper wrapper(tag_map(), obj);
2347 
2348   // apply tag filter
2349   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2350                                  wrapper.klass_tag(),
2351                                  context-&gt;heap_filter())) {
2352     return true;
2353   }
2354 
2355   // invoke the callback
2356   int res = invoke_array_primitive_value_callback(context-&gt;array_primitive_value_callback(),
2357                                                   &amp;wrapper,
2358                                                   obj,
2359                                                   (void*)user_data());
2360   return (!(res &amp; JVMTI_VISIT_ABORT));
2361 }
2362 
2363 // invoke the string value callback
2364 inline bool CallbackInvoker::report_string_value(oop str) {
2365   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
2366 
2367   AdvancedHeapWalkContext* context = advanced_context();
2368   assert(context-&gt;string_primitive_value_callback() != NULL, &quot;no callback&quot;);
2369 
2370   // apply class filter
2371   if (is_filtered_by_klass_filter(str, context-&gt;klass_filter())) {
2372     return true;
2373   }
2374 
2375   CallbackWrapper wrapper(tag_map(), str);
2376 
2377   // apply tag filter
2378   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2379                                  wrapper.klass_tag(),
2380                                  context-&gt;heap_filter())) {
2381     return true;
2382   }
2383 
2384   // invoke the callback
2385   int res = invoke_string_value_callback(context-&gt;string_primitive_value_callback(),
2386                                          &amp;wrapper,
2387                                          str,
2388                                          (void*)user_data());
2389   return (!(res &amp; JVMTI_VISIT_ABORT));
2390 }
2391 
2392 // invoke the primitive field callback
2393 inline bool CallbackInvoker::report_primitive_field(jvmtiHeapReferenceKind ref_kind,
2394                                                     oop obj,
2395                                                     jint index,
2396                                                     address addr,
2397                                                     char type)
2398 {
2399   // for primitive fields only the index will be set
2400   static jvmtiHeapReferenceInfo reference_info = { 0 };
2401 
2402   AdvancedHeapWalkContext* context = advanced_context();
2403   assert(context-&gt;primitive_field_callback() != NULL, &quot;no callback&quot;);
2404 
2405   // apply class filter
2406   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2407     return true;
2408   }
2409 
2410   CallbackWrapper wrapper(tag_map(), obj);
2411 
2412   // apply tag filter
2413   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2414                                  wrapper.klass_tag(),
2415                                  context-&gt;heap_filter())) {
2416     return true;
2417   }
2418 
2419   // the field index in the referrer
2420   reference_info.field.index = index;
2421 
2422   // map the type
2423   jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
2424 
2425   // setup the jvalue
2426   jvalue value;
2427   copy_to_jvalue(&amp;value, addr, value_type);
2428 
2429   jvmtiPrimitiveFieldCallback cb = context-&gt;primitive_field_callback();
2430   int res = (*cb)(ref_kind,
2431                   &amp;reference_info,
2432                   wrapper.klass_tag(),
2433                   wrapper.obj_tag_p(),
2434                   value,
2435                   value_type,
2436                   (void*)user_data());
2437   return (!(res &amp; JVMTI_VISIT_ABORT));
2438 }
2439 
2440 
2441 // instance field
2442 inline bool CallbackInvoker::report_primitive_instance_field(oop obj,
2443                                                              jint index,
2444                                                              address value,
2445                                                              char type) {
2446   return report_primitive_field(JVMTI_HEAP_REFERENCE_FIELD,
2447                                 obj,
2448                                 index,
2449                                 value,
2450                                 type);
2451 }
2452 
2453 // static field
2454 inline bool CallbackInvoker::report_primitive_static_field(oop obj,
2455                                                            jint index,
2456                                                            address value,
2457                                                            char type) {
2458   return report_primitive_field(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
2459                                 obj,
2460                                 index,
2461                                 value,
2462                                 type);
2463 }
2464 
2465 // report a JNI local (root object) to the profiler
2466 inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, oop obj) {
2467   if (is_basic_heap_walk()) {
2468     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_JNI_LOCAL,
2469                                            thread_tag,
2470                                            depth,
2471                                            m,
2472                                            -1,
2473                                            obj);
2474   } else {
2475     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_JNI_LOCAL,
2476                                               thread_tag, tid,
2477                                               depth,
2478                                               m,
2479                                               (jlocation)-1,
2480                                               -1,
2481                                               obj);
2482   }
2483 }
2484 
2485 
2486 // report a local (stack reference, root object)
2487 inline bool CallbackInvoker::report_stack_ref_root(jlong thread_tag,
2488                                                    jlong tid,
2489                                                    jint depth,
2490                                                    jmethodID method,
2491                                                    jlocation bci,
2492                                                    jint slot,
2493                                                    oop obj) {
2494   if (is_basic_heap_walk()) {
2495     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_STACK_LOCAL,
2496                                            thread_tag,
2497                                            depth,
2498                                            method,
2499                                            slot,
2500                                            obj);
2501   } else {
2502     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_STACK_LOCAL,
2503                                               thread_tag,
2504                                               tid,
2505                                               depth,
2506                                               method,
2507                                               bci,
2508                                               slot,
2509                                               obj);
2510   }
2511 }
2512 
2513 // report an object referencing a class.
2514 inline bool CallbackInvoker::report_class_reference(oop referrer, oop referree) {
2515   if (is_basic_heap_walk()) {
2516     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2517   } else {
2518     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS, referrer, referree, -1);
2519   }
2520 }
2521 
2522 // report a class referencing its class loader.
2523 inline bool CallbackInvoker::report_class_loader_reference(oop referrer, oop referree) {
2524   if (is_basic_heap_walk()) {
2525     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2526   } else {
2527     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2528   }
2529 }
2530 
2531 // report a class referencing its signers.
2532 inline bool CallbackInvoker::report_signers_reference(oop referrer, oop referree) {
2533   if (is_basic_heap_walk()) {
2534     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_SIGNERS, referrer, referree, -1);
2535   } else {
2536     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SIGNERS, referrer, referree, -1);
2537   }
2538 }
2539 
2540 // report a class referencing its protection domain..
2541 inline bool CallbackInvoker::report_protection_domain_reference(oop referrer, oop referree) {
2542   if (is_basic_heap_walk()) {
2543     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2544   } else {
2545     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2546   }
2547 }
2548 
2549 // report a class referencing its superclass.
2550 inline bool CallbackInvoker::report_superclass_reference(oop referrer, oop referree) {
2551   if (is_basic_heap_walk()) {
2552     // Send this to be consistent with past implementation
2553     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2554   } else {
2555     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SUPERCLASS, referrer, referree, -1);
2556   }
2557 }
2558 
2559 // report a class referencing one of its interfaces.
2560 inline bool CallbackInvoker::report_interface_reference(oop referrer, oop referree) {
2561   if (is_basic_heap_walk()) {
2562     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_INTERFACE, referrer, referree, -1);
2563   } else {
2564     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_INTERFACE, referrer, referree, -1);
2565   }
2566 }
2567 
2568 // report a class referencing one of its static fields.
2569 inline bool CallbackInvoker::report_static_field_reference(oop referrer, oop referree, jint slot) {
2570   if (is_basic_heap_walk()) {
2571     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2572   } else {
2573     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2574   }
2575 }
2576 
2577 // report an array referencing an element object
2578 inline bool CallbackInvoker::report_array_element_reference(oop referrer, oop referree, jint index) {
2579   if (is_basic_heap_walk()) {
2580     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2581   } else {
2582     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2583   }
2584 }
2585 
2586 // report an object referencing an instance field object
2587 inline bool CallbackInvoker::report_field_reference(oop referrer, oop referree, jint slot) {
2588   if (is_basic_heap_walk()) {
2589     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_FIELD, referrer, referree, slot);
2590   } else {
2591     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_FIELD, referrer, referree, slot);
2592   }
2593 }
2594 
2595 // report an array referencing an element object
2596 inline bool CallbackInvoker::report_constant_pool_reference(oop referrer, oop referree, jint index) {
2597   if (is_basic_heap_walk()) {
2598     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2599   } else {
2600     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2601   }
2602 }
2603 
2604 // A supporting closure used to process simple roots
2605 class SimpleRootsClosure : public OopClosure {
2606  private:
2607   jvmtiHeapReferenceKind _kind;
2608   bool _continue;
2609 
2610   jvmtiHeapReferenceKind root_kind()    { return _kind; }
2611 
2612  public:
2613   void set_kind(jvmtiHeapReferenceKind kind) {
2614     _kind = kind;
2615     _continue = true;
2616   }
2617 
2618   inline bool stopped() {
2619     return !_continue;
2620   }
2621 
2622   void do_oop(oop* obj_p) {
2623     // iteration has terminated
2624     if (stopped()) {
2625       return;
2626     }
2627 
2628     oop o = NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(obj_p);
2629     // ignore null
2630     if (o == NULL) {
2631       return;
2632     }
2633 
2634     assert(Universe::heap()-&gt;is_in_reserved(o), &quot;should be impossible&quot;);
2635 
2636     jvmtiHeapReferenceKind kind = root_kind();
2637     if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
2638       // SystemDictionary::oops_do reports the application
2639       // class loader as a root. We want this root to be reported as
2640       // a root kind of &quot;OTHER&quot; rather than &quot;SYSTEM_CLASS&quot;.
2641       if (!o-&gt;is_instance() || !InstanceKlass::cast(o-&gt;klass())-&gt;is_mirror_instance_klass()) {
2642         kind = JVMTI_HEAP_REFERENCE_OTHER;
2643       }
2644     }
2645 
2646     // invoke the callback
2647     _continue = CallbackInvoker::report_simple_root(kind, o);
2648 
2649   }
2650   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2651 };
2652 
2653 // A supporting closure used to process JNI locals
2654 class JNILocalRootsClosure : public OopClosure {
2655  private:
2656   jlong _thread_tag;
2657   jlong _tid;
2658   jint _depth;
2659   jmethodID _method;
2660   bool _continue;
2661  public:
2662   void set_context(jlong thread_tag, jlong tid, jint depth, jmethodID method) {
2663     _thread_tag = thread_tag;
2664     _tid = tid;
2665     _depth = depth;
2666     _method = method;
2667     _continue = true;
2668   }
2669 
2670   inline bool stopped() {
2671     return !_continue;
2672   }
2673 
2674   void do_oop(oop* obj_p) {
2675     // iteration has terminated
2676     if (stopped()) {
2677       return;
2678     }
2679 
2680     oop o = *obj_p;
2681     // ignore null
2682     if (o == NULL) {
2683       return;
2684     }
2685 
2686     // invoke the callback
2687     _continue = CallbackInvoker::report_jni_local_root(_thread_tag, _tid, _depth, _method, o);
2688   }
2689   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2690 };
2691 
2692 
2693 // A VM operation to iterate over objects that are reachable from
2694 // a set of roots or an initial object.
2695 //
2696 // For VM_HeapWalkOperation the set of roots used is :-
2697 //
2698 // - All JNI global references
2699 // - All inflated monitors
2700 // - All classes loaded by the boot class loader (or all classes
2701 //     in the event that class unloading is disabled)
2702 // - All java threads
2703 // - For each java thread then all locals and JNI local references
2704 //      on the thread&#39;s execution stack
2705 // - All visible/explainable objects from Universes::oops_do
2706 //
2707 class VM_HeapWalkOperation: public VM_Operation {
2708  private:
2709   enum {
2710     initial_visit_stack_size = 4000
2711   };
2712 
2713   bool _is_advanced_heap_walk;                      // indicates FollowReferences
2714   JvmtiTagMap* _tag_map;
2715   Handle _initial_object;
2716   GrowableArray&lt;oop&gt;* _visit_stack;                 // the visit stack
2717 
2718   bool _collecting_heap_roots;                      // are we collecting roots
2719   bool _following_object_refs;                      // are we following object references
2720 
2721   bool _reporting_primitive_fields;                 // optional reporting
2722   bool _reporting_primitive_array_values;
2723   bool _reporting_string_values;
2724 
2725   GrowableArray&lt;oop&gt;* create_visit_stack() {
2726     return new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(initial_visit_stack_size, true);
2727   }
2728 
2729   // accessors
2730   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
2731   JvmtiTagMap* tag_map() const                     { return _tag_map; }
2732   Handle initial_object() const                    { return _initial_object; }
2733 
2734   bool is_following_references() const             { return _following_object_refs; }
2735 
2736   bool is_reporting_primitive_fields()  const      { return _reporting_primitive_fields; }
2737   bool is_reporting_primitive_array_values() const { return _reporting_primitive_array_values; }
2738   bool is_reporting_string_values() const          { return _reporting_string_values; }
2739 
2740   GrowableArray&lt;oop&gt;* visit_stack() const          { return _visit_stack; }
2741 
2742   // iterate over the various object types
2743   inline bool iterate_over_array(oop o);
2744   inline bool iterate_over_type_array(oop o);
2745   inline bool iterate_over_class(oop o);
2746   inline bool iterate_over_object(oop o);
2747 
2748   // root collection
2749   inline bool collect_simple_roots();
2750   inline bool collect_stack_roots();
2751   inline bool collect_stack_roots(JavaThread* java_thread, JNILocalRootsClosure* blk);
2752 
2753   // visit an object
2754   inline bool visit(oop o);
2755 
2756  public:
2757   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2758                        Handle initial_object,
2759                        BasicHeapWalkContext callbacks,
2760                        const void* user_data);
2761 
2762   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2763                        Handle initial_object,
2764                        AdvancedHeapWalkContext callbacks,
2765                        const void* user_data);
2766 
2767   ~VM_HeapWalkOperation();
2768 
2769   VMOp_Type type() const { return VMOp_HeapWalkOperation; }
2770   void doit();
2771 };
2772 
2773 
2774 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2775                                            Handle initial_object,
2776                                            BasicHeapWalkContext callbacks,
2777                                            const void* user_data) {
2778   _is_advanced_heap_walk = false;
2779   _tag_map = tag_map;
2780   _initial_object = initial_object;
2781   _following_object_refs = (callbacks.object_ref_callback() != NULL);
2782   _reporting_primitive_fields = false;
2783   _reporting_primitive_array_values = false;
2784   _reporting_string_values = false;
2785   _visit_stack = create_visit_stack();
2786 
2787 
2788   CallbackInvoker::initialize_for_basic_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2789 }
2790 
2791 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2792                                            Handle initial_object,
2793                                            AdvancedHeapWalkContext callbacks,
2794                                            const void* user_data) {
2795   _is_advanced_heap_walk = true;
2796   _tag_map = tag_map;
2797   _initial_object = initial_object;
2798   _following_object_refs = true;
2799   _reporting_primitive_fields = (callbacks.primitive_field_callback() != NULL);;
2800   _reporting_primitive_array_values = (callbacks.array_primitive_value_callback() != NULL);;
2801   _reporting_string_values = (callbacks.string_primitive_value_callback() != NULL);;
2802   _visit_stack = create_visit_stack();
2803 
2804   CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2805 }
2806 
2807 VM_HeapWalkOperation::~VM_HeapWalkOperation() {
2808   if (_following_object_refs) {
2809     assert(_visit_stack != NULL, &quot;checking&quot;);
2810     delete _visit_stack;
2811     _visit_stack = NULL;
2812   }
2813 }
2814 
2815 // an array references its class and has a reference to
2816 // each element in the array
2817 inline bool VM_HeapWalkOperation::iterate_over_array(oop o) {
2818   objArrayOop array = objArrayOop(o);
2819 
2820   // array reference to its class
2821   oop mirror = ObjArrayKlass::cast(array-&gt;klass())-&gt;java_mirror();
2822   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2823     return false;
2824   }
2825 
2826   // iterate over the array and report each reference to a
2827   // non-null element
2828   for (int index=0; index&lt;array-&gt;length(); index++) {
2829     oop elem = array-&gt;obj_at(index);
2830     if (elem == NULL) {
2831       continue;
2832     }
2833 
2834     // report the array reference o[index] = elem
2835     if (!CallbackInvoker::report_array_element_reference(o, elem, index)) {
2836       return false;
2837     }
2838   }
2839   return true;
2840 }
2841 
2842 // a type array references its class
2843 inline bool VM_HeapWalkOperation::iterate_over_type_array(oop o) {
2844   Klass* k = o-&gt;klass();
2845   oop mirror = k-&gt;java_mirror();
2846   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2847     return false;
2848   }
2849 
2850   // report the array contents if required
2851   if (is_reporting_primitive_array_values()) {
2852     if (!CallbackInvoker::report_primitive_array_values(o)) {
2853       return false;
2854     }
2855   }
2856   return true;
2857 }
2858 
2859 #ifdef ASSERT
2860 // verify that a static oop field is in range
2861 static inline bool verify_static_oop(InstanceKlass* ik,
2862                                      oop mirror, int offset) {
2863   address obj_p = (address)mirror + offset;
2864   address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
2865   address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
2866   assert(end &gt;= start, &quot;sanity check&quot;);
2867 
2868   if (obj_p &gt;= start &amp;&amp; obj_p &lt; end) {
2869     return true;
2870   } else {
2871     return false;
2872   }
2873 }
2874 #endif // #ifdef ASSERT
2875 
2876 // a class references its super class, interfaces, class loader, ...
2877 // and finally its static fields
2878 inline bool VM_HeapWalkOperation::iterate_over_class(oop java_class) {
2879   int i;
2880   Klass* klass = java_lang_Class::as_Klass(java_class);
2881 
2882   if (klass-&gt;is_instance_klass()) {
2883     InstanceKlass* ik = InstanceKlass::cast(klass);
2884 
2885     // Ignore the class if it hasn&#39;t been initialized yet
2886     if (!ik-&gt;is_linked()) {
2887       return true;
2888     }
2889 
2890     // get the java mirror
2891     oop mirror = klass-&gt;java_mirror();
2892 
2893     // super (only if something more interesting than java.lang.Object)
2894     InstanceKlass* java_super = ik-&gt;java_super();
2895     if (java_super != NULL &amp;&amp; java_super != SystemDictionary::Object_klass()) {
2896       oop super = java_super-&gt;java_mirror();
2897       if (!CallbackInvoker::report_superclass_reference(mirror, super)) {
2898         return false;
2899       }
2900     }
2901 
2902     // class loader
2903     oop cl = ik-&gt;class_loader();
2904     if (cl != NULL) {
2905       if (!CallbackInvoker::report_class_loader_reference(mirror, cl)) {
2906         return false;
2907       }
2908     }
2909 
2910     // protection domain
2911     oop pd = ik-&gt;protection_domain();
2912     if (pd != NULL) {
2913       if (!CallbackInvoker::report_protection_domain_reference(mirror, pd)) {
2914         return false;
2915       }
2916     }
2917 
2918     // signers
2919     oop signers = ik-&gt;signers();
2920     if (signers != NULL) {
2921       if (!CallbackInvoker::report_signers_reference(mirror, signers)) {
2922         return false;
2923       }
2924     }
2925 
2926     // references from the constant pool
2927     {
2928       ConstantPool* pool = ik-&gt;constants();
2929       for (int i = 1; i &lt; pool-&gt;length(); i++) {
2930         constantTag tag = pool-&gt;tag_at(i).value();
2931         if (tag.is_string() || tag.is_klass() || tag.is_unresolved_klass()) {
2932           oop entry;
2933           if (tag.is_string()) {
2934             entry = pool-&gt;resolved_string_at(i);
2935             // If the entry is non-null it is resolved.
2936             if (entry == NULL) {
2937               continue;
2938             }
2939           } else if (tag.is_klass()) {
2940             entry = pool-&gt;resolved_klass_at(i)-&gt;java_mirror();
2941           } else {
2942             // Code generated by JIT and AOT compilers might not resolve constant
2943             // pool entries.  Treat them as resolved if they are loaded.
2944             assert(tag.is_unresolved_klass(), &quot;must be&quot;);
2945             constantPoolHandle cp(Thread::current(), pool);
2946             Klass* klass = ConstantPool::klass_at_if_loaded(cp, i);
2947             if (klass == NULL) {
2948               continue;
2949             }
2950             entry = klass-&gt;java_mirror();
2951           }
2952           if (!CallbackInvoker::report_constant_pool_reference(mirror, entry, (jint)i)) {
2953             return false;
2954           }
2955         }
2956       }
2957     }
2958 
2959     // interfaces
2960     // (These will already have been reported as references from the constant pool
2961     //  but are specified by IterateOverReachableObjects and must be reported).
2962     Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
2963     for (i = 0; i &lt; interfaces-&gt;length(); i++) {
2964       oop interf = interfaces-&gt;at(i)-&gt;java_mirror();
2965       if (interf == NULL) {
2966         continue;
2967       }
2968       if (!CallbackInvoker::report_interface_reference(mirror, interf)) {
2969         return false;
2970       }
2971     }
2972 
2973     // iterate over the static fields
2974 
2975     ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
2976     for (i=0; i&lt;field_map-&gt;field_count(); i++) {
2977       ClassFieldDescriptor* field = field_map-&gt;field_at(i);
2978       char type = field-&gt;field_type();
2979       if (!is_primitive_field_type(type)) {
2980         oop fld_o = mirror-&gt;obj_field(field-&gt;field_offset());
2981         assert(verify_static_oop(ik, mirror, field-&gt;field_offset()), &quot;sanity check&quot;);
2982         if (fld_o != NULL) {
2983           int slot = field-&gt;field_index();
2984           if (!CallbackInvoker::report_static_field_reference(mirror, fld_o, slot)) {
2985             delete field_map;
2986             return false;
2987           }
2988         }
2989       } else {
2990          if (is_reporting_primitive_fields()) {
2991            address addr = (address)mirror + field-&gt;field_offset();
2992            int slot = field-&gt;field_index();
2993            if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
2994              delete field_map;
2995              return false;
2996           }
2997         }
2998       }
2999     }
3000     delete field_map;
3001 
3002     return true;
3003   }
3004 
3005   return true;
3006 }
3007 
3008 // an object references a class and its instance fields
3009 // (static fields are ignored here as we report these as
3010 // references from the class).
3011 inline bool VM_HeapWalkOperation::iterate_over_object(oop o) {
3012   // reference to the class
3013   if (!CallbackInvoker::report_class_reference(o, o-&gt;klass()-&gt;java_mirror())) {
3014     return false;
3015   }
3016 
3017   // iterate over instance fields
3018   ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
3019   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
3020     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
3021     char type = field-&gt;field_type();
3022     if (!is_primitive_field_type(type)) {
3023       oop fld_o = o-&gt;obj_field(field-&gt;field_offset());
3024       // ignore any objects that aren&#39;t visible to profiler
3025       if (fld_o != NULL) {
3026         assert(Universe::heap()-&gt;is_in_reserved(fld_o), &quot;unsafe code should not &quot;
3027                &quot;have references to Klass* anymore&quot;);
3028         int slot = field-&gt;field_index();
3029         if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
3030           return false;
3031         }
3032       }
3033     } else {
3034       if (is_reporting_primitive_fields()) {
3035         // primitive instance field
3036         address addr = (address)o + field-&gt;field_offset();
3037         int slot = field-&gt;field_index();
3038         if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
3039           return false;
3040         }
3041       }
3042     }
3043   }
3044 
3045   // if the object is a java.lang.String
3046   if (is_reporting_string_values() &amp;&amp;
3047       o-&gt;klass() == SystemDictionary::String_klass()) {
3048     if (!CallbackInvoker::report_string_value(o)) {
3049       return false;
3050     }
3051   }
3052   return true;
3053 }
3054 
3055 
3056 // Collects all simple (non-stack) roots except for threads;
3057 // threads are handled in collect_stack_roots() as an optimization.
3058 // if there&#39;s a heap root callback provided then the callback is
3059 // invoked for each simple root.
3060 // if an object reference callback is provided then all simple
3061 // roots are pushed onto the marking stack so that they can be
3062 // processed later
3063 //
3064 inline bool VM_HeapWalkOperation::collect_simple_roots() {
3065   SimpleRootsClosure blk;
3066 
3067   // JNI globals
3068   blk.set_kind(JVMTI_HEAP_REFERENCE_JNI_GLOBAL);
3069   JNIHandles::oops_do(&amp;blk);
3070   if (blk.stopped()) {
3071     return false;
3072   }
3073 
3074   // Preloaded classes and loader from the system dictionary
3075   blk.set_kind(JVMTI_HEAP_REFERENCE_SYSTEM_CLASS);
3076   SystemDictionary::oops_do(&amp;blk);
3077   CLDToOopClosure cld_closure(&amp;blk, false);
3078   ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
3079   if (blk.stopped()) {
3080     return false;
3081   }
3082 
3083   // Inflated monitors
3084   blk.set_kind(JVMTI_HEAP_REFERENCE_MONITOR);
3085   ObjectSynchronizer::oops_do(&amp;blk);
3086   if (blk.stopped()) {
3087     return false;
3088   }
3089 
3090   // threads are now handled in collect_stack_roots()
3091 
3092   // Other kinds of roots maintained by HotSpot
3093   // Many of these won&#39;t be visible but others (such as instances of important
3094   // exceptions) will be visible.
3095   blk.set_kind(JVMTI_HEAP_REFERENCE_OTHER);
3096   Universe::oops_do(&amp;blk);
3097 
3098   return true;
3099 }
3100 
3101 // Walk the stack of a given thread and find all references (locals
3102 // and JNI calls) and report these as stack references
3103 inline bool VM_HeapWalkOperation::collect_stack_roots(JavaThread* java_thread,
3104                                                       JNILocalRootsClosure* blk)
3105 {
3106   oop threadObj = java_thread-&gt;threadObj();
3107   assert(threadObj != NULL, &quot;sanity check&quot;);
3108 
3109   // only need to get the thread&#39;s tag once per thread
3110   jlong thread_tag = tag_for(_tag_map, threadObj);
3111 
3112   // also need the thread id
3113   jlong tid = java_lang_Thread::thread_id(threadObj);
3114 
3115 
3116   if (java_thread-&gt;has_last_Java_frame()) {
3117 
3118     // vframes are resource allocated
3119     Thread* current_thread = Thread::current();
3120     ResourceMark rm(current_thread);
3121     HandleMark hm(current_thread);
3122 
3123     RegisterMap reg_map(java_thread);
3124     frame f = java_thread-&gt;last_frame();
3125     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
3126 
3127     bool is_top_frame = true;
3128     int depth = 0;
3129     frame* last_entry_frame = NULL;
3130 
3131     while (vf != NULL) {
3132       if (vf-&gt;is_java_frame()) {
3133 
3134         // java frame (interpreted, compiled, ...)
3135         javaVFrame *jvf = javaVFrame::cast(vf);
3136 
3137         // the jmethodID
3138         jmethodID method = jvf-&gt;method()-&gt;jmethod_id();
3139 
3140         if (!(jvf-&gt;method()-&gt;is_native())) {
3141           jlocation bci = (jlocation)jvf-&gt;bci();
3142           StackValueCollection* locals = jvf-&gt;locals();
3143           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
3144             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
3145               oop o = locals-&gt;obj_at(slot)();
3146               if (o == NULL) {
3147                 continue;
3148               }
3149 
3150               // stack reference
3151               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3152                                                    bci, slot, o)) {
3153                 return false;
3154               }
3155             }
3156           }
3157 
3158           StackValueCollection* exprs = jvf-&gt;expressions();
3159           for (int index=0; index &lt; exprs-&gt;size(); index++) {
3160             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
3161               oop o = exprs-&gt;obj_at(index)();
3162               if (o == NULL) {
3163                 continue;
3164               }
3165 
3166               // stack reference
3167               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3168                                                    bci, locals-&gt;size() + index, o)) {
3169                 return false;
3170               }
3171             }
3172           }
3173 
3174           // Follow oops from compiled nmethod
3175           if (jvf-&gt;cb() != NULL &amp;&amp; jvf-&gt;cb()-&gt;is_nmethod()) {
3176             blk-&gt;set_context(thread_tag, tid, depth, method);
3177             jvf-&gt;cb()-&gt;as_nmethod()-&gt;oops_do(blk);
3178           }
3179         } else {
3180           blk-&gt;set_context(thread_tag, tid, depth, method);
3181           if (is_top_frame) {
3182             // JNI locals for the top frame.
3183             java_thread-&gt;active_handles()-&gt;oops_do(blk);
3184           } else {
3185             if (last_entry_frame != NULL) {
3186               // JNI locals for the entry frame
3187               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
3188               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(blk);
3189             }
3190           }
3191         }
3192         last_entry_frame = NULL;
3193         depth++;
3194       } else {
3195         // externalVFrame - for an entry frame then we report the JNI locals
3196         // when we find the corresponding javaVFrame
3197         frame* fr = vf-&gt;frame_pointer();
3198         assert(fr != NULL, &quot;sanity check&quot;);
3199         if (fr-&gt;is_entry_frame()) {
3200           last_entry_frame = fr;
3201         }
3202       }
3203 
3204       vf = vf-&gt;sender();
3205       is_top_frame = false;
3206     }
3207   } else {
3208     // no last java frame but there may be JNI locals
3209     blk-&gt;set_context(thread_tag, tid, 0, (jmethodID)NULL);
3210     java_thread-&gt;active_handles()-&gt;oops_do(blk);
3211   }
3212   return true;
3213 }
3214 
3215 
3216 // Collects the simple roots for all threads and collects all
3217 // stack roots - for each thread it walks the execution
3218 // stack to find all references and local JNI refs.
3219 inline bool VM_HeapWalkOperation::collect_stack_roots() {
3220   JNILocalRootsClosure blk;
3221   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
3222     oop threadObj = thread-&gt;threadObj();
3223     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
3224       // Collect the simple root for this thread before we
3225       // collect its stack roots
3226       if (!CallbackInvoker::report_simple_root(JVMTI_HEAP_REFERENCE_THREAD,
3227                                                threadObj)) {
3228         return false;
3229       }
3230       if (!collect_stack_roots(thread, &amp;blk)) {
3231         return false;
3232       }
3233     }
3234   }
3235   return true;
3236 }
3237 
3238 // visit an object
3239 // first mark the object as visited
3240 // second get all the outbound references from this object (in other words, all
3241 // the objects referenced by this object).
3242 //
3243 bool VM_HeapWalkOperation::visit(oop o) {
3244   // mark object as visited
3245   assert(!ObjectMarker::visited(o), &quot;can&#39;t visit same object more than once&quot;);
3246   ObjectMarker::mark(o);
3247 
3248   // instance
3249   if (o-&gt;is_instance()) {
3250     if (o-&gt;klass() == SystemDictionary::Class_klass()) {
3251       if (!java_lang_Class::is_primitive(o)) {
3252         // a java.lang.Class
3253         return iterate_over_class(o);
3254       }
3255     } else {
3256       return iterate_over_object(o);
3257     }
3258   }
3259 
3260   // object array
3261   if (o-&gt;is_objArray()) {
3262     return iterate_over_array(o);
3263   }
3264 
3265   // type array
3266   if (o-&gt;is_typeArray()) {
3267     return iterate_over_type_array(o);
3268   }
3269 
3270   return true;
3271 }
3272 
3273 void VM_HeapWalkOperation::doit() {
3274   // This annotation is reasonably minimal in number of tsan callbacks.
3275   // By passing the lock directly, we are not actually locking it, just
3276   // telling TSAN we are to &quot;simulate&quot; the lock.
3277   TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));
3278 
3279   ResourceMark rm;
3280   ObjectMarkerController marker;
3281   ClassFieldMapCacheMark cm;
3282 
3283   assert(visit_stack()-&gt;is_empty(), &quot;visit stack must be empty&quot;);
3284 
3285   // the heap walk starts with an initial object or the heap roots
3286   if (initial_object().is_null()) {
3287     // If either collect_stack_roots() or collect_simple_roots()
3288     // returns false at this point, then there are no mark bits
3289     // to reset.
3290     ObjectMarker::set_needs_reset(false);
3291 
3292     // Calling collect_stack_roots() before collect_simple_roots()
3293     // can result in a big performance boost for an agent that is
3294     // focused on analyzing references in the thread stacks.
3295     if (!collect_stack_roots()) return;
3296 
3297     if (!collect_simple_roots()) return;
3298 
3299     // no early return so enable heap traversal to reset the mark bits
3300     ObjectMarker::set_needs_reset(true);
3301   } else {
3302     visit_stack()-&gt;push(initial_object()());
3303   }
3304 
3305   // object references required
3306   if (is_following_references()) {
3307 
3308     // visit each object until all reachable objects have been
3309     // visited or the callback asked to terminate the iteration.
3310     while (!visit_stack()-&gt;is_empty()) {
3311       oop o = visit_stack()-&gt;pop();
3312       if (!ObjectMarker::visited(o)) {
3313         if (!visit(o)) {
3314           break;
3315         }
3316       }
3317     }
3318   }
3319 }
3320 
3321 // iterate over all objects that are reachable from a set of roots
3322 void JvmtiTagMap::iterate_over_reachable_objects(jvmtiHeapRootCallback heap_root_callback,
3323                                                  jvmtiStackReferenceCallback stack_ref_callback,
3324                                                  jvmtiObjectReferenceCallback object_ref_callback,
3325                                                  const void* user_data) {
3326   MutexLocker ml(Heap_lock);
3327   BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);
3328   VM_HeapWalkOperation op(this, Handle(), context, user_data);
3329   VMThread::execute(&amp;op);
3330 }
3331 
3332 // iterate over all objects that are reachable from a given object
3333 void JvmtiTagMap::iterate_over_objects_reachable_from_object(jobject object,
3334                                                              jvmtiObjectReferenceCallback object_ref_callback,
3335                                                              const void* user_data) {
3336   oop obj = JNIHandles::resolve(object);
3337   Handle initial_object(Thread::current(), obj);
3338 
3339   MutexLocker ml(Heap_lock);
3340   BasicHeapWalkContext context(NULL, NULL, object_ref_callback);
3341   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3342   VMThread::execute(&amp;op);
3343 }
3344 
3345 // follow references from an initial object or the GC roots
3346 void JvmtiTagMap::follow_references(jint heap_filter,
3347                                     Klass* klass,
3348                                     jobject object,
3349                                     const jvmtiHeapCallbacks* callbacks,
3350                                     const void* user_data)
3351 {
3352   oop obj = JNIHandles::resolve(object);
3353   Handle initial_object(Thread::current(), obj);
3354 
3355   MutexLocker ml(Heap_lock);
3356   AdvancedHeapWalkContext context(heap_filter, klass, callbacks);
3357   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3358   VMThread::execute(&amp;op);
3359 }
3360 
3361 
3362 void JvmtiTagMap::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
3363   // No locks during VM bring-up (0 threads) and no safepoints after main
3364   // thread creation and before VMThread creation (1 thread); initial GC
3365   // verification can happen in that window which gets to here.
3366   assert(Threads::number_of_threads() &lt;= 1 ||
3367          SafepointSynchronize::is_at_safepoint(),
3368          &quot;must be executed at a safepoint&quot;);
3369   if (JvmtiEnv::environments_might_exist()) {
3370     JvmtiEnvIterator it;
3371     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
3372       JvmtiTagMap* tag_map = env-&gt;tag_map();
3373       if (tag_map != NULL &amp;&amp; !tag_map-&gt;is_empty()) {
3374         tag_map-&gt;do_weak_oops(is_alive, f);
3375       }
3376     }
3377   }
3378 }
3379 
3380 void JvmtiTagMap::do_weak_oops(BoolObjectClosure* is_alive, OopClosure* f) {
3381 
3382   // does this environment have the OBJECT_FREE event enabled
3383   bool post_object_free = env()-&gt;is_enabled(JVMTI_EVENT_OBJECT_FREE);
3384 
3385   // counters used for trace message
3386   int freed = 0;
3387   int moved = 0;
3388 
3389   JvmtiTagHashmap* hashmap = this-&gt;hashmap();
3390 
3391   // reenable sizing (if disabled)
3392   hashmap-&gt;set_resizing_enabled(true);
3393 
3394   // if the hashmap is empty then we can skip it
3395   if (hashmap-&gt;_entry_count == 0) {
3396     return;
3397   }
3398 
3399   // now iterate through each entry in the table
3400 
3401   JvmtiTagHashmapEntry** table = hashmap-&gt;table();
3402   int size = hashmap-&gt;size();
3403 
3404   JvmtiTagHashmapEntry* delayed_add = NULL;
3405 
3406   for (int pos = 0; pos &lt; size; ++pos) {
3407     JvmtiTagHashmapEntry* entry = table[pos];
3408     JvmtiTagHashmapEntry* prev = NULL;
3409 
3410     while (entry != NULL) {
3411       JvmtiTagHashmapEntry* next = entry-&gt;next();
3412 
3413       // has object been GC&#39;ed
3414       if (!is_alive-&gt;do_object_b(entry-&gt;object_peek())) {
3415         // grab the tag
3416         jlong tag = entry-&gt;tag();
3417         guarantee(tag != 0, &quot;checking&quot;);
3418 
3419         // remove GC&#39;ed entry from hashmap and return the
3420         // entry to the free list
3421         hashmap-&gt;remove(prev, pos, entry);
3422         destroy_entry(entry);
3423 
3424         // post the event to the profiler
3425         if (post_object_free) {
3426           JvmtiExport::post_object_free(env(), tag);
3427         }
3428 
3429         ++freed;
3430       } else {
3431         f-&gt;do_oop(entry-&gt;object_addr());
3432         oop new_oop = entry-&gt;object_peek();
3433 
3434         // if the object has moved then re-hash it and move its
3435         // entry to its new location.
3436         unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
3437         if (new_pos != (unsigned int)pos) {
3438           if (prev == NULL) {
3439             table[pos] = next;
3440           } else {
3441             prev-&gt;set_next(next);
3442           }
3443           if (new_pos &lt; (unsigned int)pos) {
3444             entry-&gt;set_next(table[new_pos]);
3445             table[new_pos] = entry;
3446           } else {
3447             // Delay adding this entry to it&#39;s new position as we&#39;d end up
3448             // hitting it again during this iteration.
3449             entry-&gt;set_next(delayed_add);
3450             delayed_add = entry;
3451           }
3452           moved++;
3453         } else {
3454           // object didn&#39;t move
3455           prev = entry;
3456         }
3457       }
3458 
3459       entry = next;
3460     }
3461   }
3462 
3463   // Re-add all the entries which were kept aside
3464   while (delayed_add != NULL) {
3465     JvmtiTagHashmapEntry* next = delayed_add-&gt;next();
3466     unsigned int pos = JvmtiTagHashmap::hash(delayed_add-&gt;object_peek(), size);
3467     delayed_add-&gt;set_next(table[pos]);
3468     table[pos] = delayed_add;
3469     delayed_add = next;
3470   }
3471 
3472   log_debug(jvmti, objecttagging)(&quot;(%d-&gt;%d, %d freed, %d total moves)&quot;,
3473                                   hashmap-&gt;_entry_count + freed, hashmap-&gt;_entry_count, freed, moved);
3474 }
    </pre>
  </body>
</html>
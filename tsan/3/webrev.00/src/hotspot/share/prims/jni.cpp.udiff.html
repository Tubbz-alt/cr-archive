<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="forte.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2012 Red Hat, Inc.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48,11 +48,11 @@</span>
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/arrayOop.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -63,19 +63,17 @@</span>
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/reflection.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88,11 +86,10 @@</span>
  #include &quot;utilities/histogram.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  #if INCLUDE_JVMCI
  #include &quot;jvmci/jvmciCompiler.hpp&quot;
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #endif
  
  static jint CurrentVersion = JNI_VERSION_10;
  
  #ifdef _WIN32
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,12 +270,12 @@</span>
  
    JNIHistogramElement::JNIHistogramElement(const char* elementName) {
      _name = elementName;
      uintx count = 0;
  
<span class="udiff-line-modified-removed">-     while (Atomic::cmpxchg(1, &amp;JNIHistogram_lock, 0) != 0) {</span>
<span class="udiff-line-modified-removed">-       while (OrderAccess::load_acquire(&amp;JNIHistogram_lock) != 0) {</span>
<span class="udiff-line-modified-added">+     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {</span>
<span class="udiff-line-modified-added">+       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {</span>
          count +=1;
          if ( (WarnOnStalledSpinLock &gt; 0)
            &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
            warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -331,11 +328,11 @@</span>
                           &quot;Class name exceeds maximum length of %d: %s&quot;,
                           Symbol::max_length(),
                           name);
        return 0;
      }
<span class="udiff-line-modified-removed">-     class_name = SymbolTable::new_symbol(name, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     class_name = SymbolTable::new_symbol(name);</span>
    }
    ResourceMark rm(THREAD);
    ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
    Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,11 +415,11 @@</span>
      } else {
        loader = Handle(THREAD, k-&gt;class_loader());
      }
    }
  
<span class="udiff-line-modified-removed">-   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol sym = SymbolTable::new_symbol(name);</span>
    result = find_class_from_class_loader(env, sym, true, loader,
                                          protection_domain, true, thread);
  
    if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
      trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,20 +558,20 @@</span>
           &quot;java_super computation depends on interface, array, other super&quot;);
    obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
    return obj;
  JNI_END
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))</span>
    JNIWrapper(&quot;IsSubclassOf&quot;);
  
    HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
  
    oop sub_mirror   = JNIHandles::resolve_non_null(sub);
    oop super_mirror = JNIHandles::resolve_non_null(super);
    if (java_lang_Class::is_primitive(sub_mirror) ||
        java_lang_Class::is_primitive(super_mirror)) {
<span class="udiff-line-modified-removed">-     jboolean ret = oopDesc::equals(sub_mirror, super_mirror);</span>
<span class="udiff-line-modified-added">+     jboolean ret = (sub_mirror == super_mirror);</span>
  
      HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
      return ret;
    }
    Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -696,11 +693,11 @@</span>
  
    HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))</span>
    JNIWrapper(&quot;ExceptionClear&quot;);
  
    HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
  
    // The jni code might be using this API to clear java thrown exception.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -793,21 +790,21 @@</span>
    JNIHandles::destroy_global(ref);
  
    HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
  JNI_END
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))</span>
    JNIWrapper(&quot;DeleteLocalRef&quot;);
  
    HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
  
    JNIHandles::destroy_local(obj);
  
    HOTSPOT_JNI_DELETELOCALREF_RETURN();
  JNI_END
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))</span>
    JNIWrapper(&quot;IsSameObject&quot;);
  
    HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
  
    jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -863,220 +860,112 @@</span>
  
  class JNI_ArgumentPusher : public SignatureIterator {
   protected:
    JavaCallArguments*  _arguments;
  
<span class="udiff-line-modified-removed">-   virtual void get_bool   () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_char   () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_short  () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_byte   () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_int    () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_long   () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_float  () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_double () = 0;</span>
<span class="udiff-line-modified-removed">-   virtual void get_object () = 0;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="udiff-line-modified-removed">-     this-&gt;_return_type = T_ILLEGAL;</span>
<span class="udiff-line-modified-added">+   void push_int(jint x)         { _arguments-&gt;push_int(x); }</span>
<span class="udiff-line-modified-added">+   void push_long(jlong x)       { _arguments-&gt;push_long(x); }</span>
<span class="udiff-line-modified-added">+   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }</span>
<span class="udiff-line-modified-added">+   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }</span>
<span class="udiff-line-modified-added">+   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   void push_boolean(jboolean b) {</span>
<span class="udiff-line-modified-added">+     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="udiff-line-modified-added">+     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="udiff-line-modified-added">+     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="udiff-line-modified-added">+     // SharedRuntime::generate_native_wrapper.</span>
<span class="udiff-line-modified-added">+     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   JNI_ArgumentPusher(Method* method)</span>
<span class="udiff-line-added">+     : SignatureIterator(method-&gt;signature(),</span>
<span class="udiff-line-added">+                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())</span>
<span class="udiff-line-added">+   {</span>
      _arguments = NULL;
    }
  
   public:
<span class="udiff-line-modified-removed">-   virtual void iterate( uint64_t fingerprint ) = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline void do_bool()                     { if (!is_return_type()) get_bool();   }</span>
<span class="udiff-line-removed">-   inline void do_char()                     { if (!is_return_type()) get_char();   }</span>
<span class="udiff-line-removed">-   inline void do_short()                    { if (!is_return_type()) get_short();  }</span>
<span class="udiff-line-removed">-   inline void do_byte()                     { if (!is_return_type()) get_byte();   }</span>
<span class="udiff-line-removed">-   inline void do_int()                      { if (!is_return_type()) get_int();    }</span>
<span class="udiff-line-removed">-   inline void do_long()                     { if (!is_return_type()) get_long();   }</span>
<span class="udiff-line-removed">-   inline void do_float()                    { if (!is_return_type()) get_float();  }</span>
<span class="udiff-line-removed">-   inline void do_double()                   { if (!is_return_type()) get_double(); }</span>
<span class="udiff-line-removed">-   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }</span>
<span class="udiff-line-removed">-   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array</span>
<span class="udiff-line-removed">-   inline void do_void()                     { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   JavaCallArguments* arguments()     { return _arguments; }</span>
<span class="udiff-line-removed">-   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }</span>
<span class="udiff-line-modified-added">+   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;</span>
  };
  
  
  class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
   protected:
    va_list _ap;
  
<span class="udiff-line-modified-removed">-   inline void get_bool()   {</span>
<span class="udiff-line-modified-removed">-     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="udiff-line-removed">-     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="udiff-line-removed">-     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="udiff-line-removed">-     // SharedRuntime::generate_native_wrapper.</span>
<span class="udiff-line-removed">-     jboolean b = va_arg(_ap, jint);</span>
<span class="udiff-line-removed">-     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
<span class="udiff-line-modified-added">+   void set_ap(va_list rap) {</span>
<span class="udiff-line-modified-added">+     va_copy(_ap, rap);</span>
    }
<span class="udiff-line-removed">-   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg</span>
<span class="udiff-line-removed">-   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg</span>
<span class="udiff-line-removed">-   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg</span>
<span class="udiff-line-removed">-   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }</span>
  
<span class="udiff-line-modified-removed">-   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>
<span class="udiff-line-modified-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="udiff-line-added">+   void do_type(BasicType type) {</span>
<span class="udiff-line-added">+     switch (type) {</span>
<span class="udiff-line-added">+     // these are coerced to int when using va_arg</span>
<span class="udiff-line-added">+     case T_BYTE:</span>
<span class="udiff-line-added">+     case T_CHAR:</span>
<span class="udiff-line-added">+     case T_SHORT:</span>
<span class="udiff-line-added">+     case T_INT:         push_int(va_arg(_ap, jint)); break;</span>
<span class="udiff-line-added">+     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;</span>
  
<span class="udiff-line-modified-removed">-   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }</span>
<span class="udiff-line-removed">-   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg</span>
<span class="udiff-line-removed">-   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }</span>
<span class="udiff-line-removed">-   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }</span>
<span class="udiff-line-modified-added">+     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>
  
<span class="udiff-line-modified-removed">-   inline void set_ap(va_list rap) {</span>
<span class="udiff-line-modified-removed">-     va_copy(_ap, rap);</span>
<span class="udiff-line-modified-added">+     case T_LONG:        push_long(va_arg(_ap, jlong)); break;</span>
<span class="udiff-line-modified-added">+     // float is coerced to double w/ va_arg</span>
<span class="udiff-line-added">+     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case T_ARRAY:</span>
<span class="udiff-line-added">+     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>
<span class="udiff-line-added">+     default:            ShouldNotReachHere();</span>
<span class="udiff-line-added">+     }</span>
    }
  
   public:
<span class="udiff-line-removed">-   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)</span>
<span class="udiff-line-removed">-        : JNI_ArgumentPusher(signature) {</span>
<span class="udiff-line-removed">-     set_ap(rap);</span>
<span class="udiff-line-removed">-   }</span>
    JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<span class="udiff-line-modified-removed">-       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
<span class="udiff-line-modified-added">+       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
      set_ap(rap);
    }
  
<span class="udiff-line-modified-removed">-   // Optimized path if we have the bitvector form of signature</span>
<span class="udiff-line-modified-removed">-   void iterate( uint64_t fingerprint ) {</span>
<span class="udiff-line-modified-removed">-     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="udiff-line-removed">-       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="udiff-line-removed">-                                   result_feature_mask);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="udiff-line-removed">-       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="udiff-line-removed">-       while ( 1 ) {</span>
<span class="udiff-line-removed">-         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="udiff-line-removed">-           case bool_parm:</span>
<span class="udiff-line-removed">-             get_bool();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case char_parm:</span>
<span class="udiff-line-removed">-             get_char();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case short_parm:</span>
<span class="udiff-line-removed">-             get_short();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case byte_parm:</span>
<span class="udiff-line-removed">-             get_byte();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case int_parm:</span>
<span class="udiff-line-removed">-             get_int();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case obj_parm:</span>
<span class="udiff-line-removed">-             get_object();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case long_parm:</span>
<span class="udiff-line-removed">-             get_long();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case float_parm:</span>
<span class="udiff-line-removed">-             get_float();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case double_parm:</span>
<span class="udiff-line-removed">-             get_double();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case done_parm:</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           default:</span>
<span class="udiff-line-removed">-             ShouldNotReachHere();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="udiff-line-modified-added">+     _arguments = arguments;</span>
<span class="udiff-line-modified-added">+     do_parameters_on(this);</span>
    }
  };
  
  
  class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
   protected:
    const jvalue *_ap;
  
<span class="udiff-line-removed">-   inline void get_bool()   {</span>
<span class="udiff-line-removed">-     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="udiff-line-removed">-     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="udiff-line-removed">-     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="udiff-line-removed">-     // SharedRuntime::generate_native_wrapper.</span>
<span class="udiff-line-removed">-     jboolean b = (_ap++)-&gt;z;</span>
<span class="udiff-line-removed">-     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }</span>
<span class="udiff-line-removed">-   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }</span>
<span class="udiff-line-removed">-   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }</span>
<span class="udiff-line-removed">-   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }</span>
<span class="udiff-line-removed">-   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }</span>
<span class="udiff-line-removed">-   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}</span>
<span class="udiff-line-removed">-   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }</span>
<span class="udiff-line-removed">- </span>
    inline void set_ap(const jvalue *rap) { _ap = rap; }
  
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)</span>
<span class="udiff-line-modified-removed">-        : JNI_ArgumentPusher(signature) {</span>
<span class="udiff-line-modified-removed">-     set_ap(rap);</span>
<span class="udiff-line-modified-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="udiff-line-modified-added">+   void do_type(BasicType type) {</span>
<span class="udiff-line-modified-added">+     switch (type) {</span>
<span class="udiff-line-modified-added">+     case T_CHAR:        push_int((_ap++)-&gt;c); break;</span>
<span class="udiff-line-added">+     case T_SHORT:       push_int((_ap++)-&gt;s); break;</span>
<span class="udiff-line-added">+     case T_BYTE:        push_int((_ap++)-&gt;b); break;</span>
<span class="udiff-line-added">+     case T_INT:         push_int((_ap++)-&gt;i); break;</span>
<span class="udiff-line-added">+     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;</span>
<span class="udiff-line-added">+     case T_LONG:        push_long((_ap++)-&gt;j); break;</span>
<span class="udiff-line-added">+     case T_FLOAT:       push_float((_ap++)-&gt;f); break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;</span>
<span class="udiff-line-added">+     case T_ARRAY:</span>
<span class="udiff-line-added">+     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>
<span class="udiff-line-added">+     default:            ShouldNotReachHere();</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  public:</span>
    JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<span class="udiff-line-modified-removed">-       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
<span class="udiff-line-modified-added">+       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
      set_ap(rap);
    }
  
<span class="udiff-line-modified-removed">-   // Optimized path if we have the bitvector form of signature</span>
<span class="udiff-line-modified-removed">-   void iterate( uint64_t fingerprint ) {</span>
<span class="udiff-line-modified-removed">-     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="udiff-line-removed">-       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="udiff-line-removed">-                                   result_feature_mask);</span>
<span class="udiff-line-removed">-       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="udiff-line-removed">-       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="udiff-line-removed">-       while ( 1 ) {</span>
<span class="udiff-line-removed">-         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="udiff-line-removed">-           case bool_parm:</span>
<span class="udiff-line-removed">-             get_bool();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case char_parm:</span>
<span class="udiff-line-removed">-             get_char();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case short_parm:</span>
<span class="udiff-line-removed">-             get_short();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case byte_parm:</span>
<span class="udiff-line-removed">-             get_byte();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case int_parm:</span>
<span class="udiff-line-removed">-             get_int();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case obj_parm:</span>
<span class="udiff-line-removed">-             get_object();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case long_parm:</span>
<span class="udiff-line-removed">-             get_long();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case float_parm:</span>
<span class="udiff-line-removed">-             get_float();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case double_parm:</span>
<span class="udiff-line-removed">-             get_double();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           case done_parm:</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           default:</span>
<span class="udiff-line-removed">-             ShouldNotReachHere();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="udiff-line-modified-added">+     _arguments = arguments;</span>
<span class="udiff-line-modified-added">+     do_parameters_on(this);</span>
    }
  };
  
  
  enum JNICallType {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1093,24 +982,23 @@</span>
    // Create object to hold arguments for the JavaCall, and associate it with
    // the jni parser
    ResourceMark rm(THREAD);
    int number_of_parameters = method-&gt;size_of_parameters();
    JavaCallArguments java_args(number_of_parameters);
<span class="udiff-line-removed">-   args-&gt;set_java_argument_object(&amp;java_args);</span>
  
    assert(method-&gt;is_static(), &quot;method should be static&quot;);
  
    // Fill out JavaCallArguments object
<span class="udiff-line-modified-removed">-   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
<span class="udiff-line-modified-added">+   args-&gt;push_arguments_on(&amp;java_args);</span>
    // Initialize result type
<span class="udiff-line-modified-removed">-   result-&gt;set_type(args-&gt;get_ret_type());</span>
<span class="udiff-line-modified-added">+   result-&gt;set_type(args-&gt;return_type());</span>
  
    // Invoke the method. Result is returned as oop.
    JavaCalls::call(result, method, &amp;java_args, CHECK);
  
    // Convert result
<span class="udiff-line-modified-removed">-   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(result-&gt;get_type())) {</span>
      result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1154,26 +1042,25 @@</span>
  
    // Create object to hold arguments for the JavaCall, and associate it with
    // the jni parser
    ResourceMark rm(THREAD);
    JavaCallArguments java_args(number_of_parameters);
<span class="udiff-line-removed">-   args-&gt;set_java_argument_object(&amp;java_args);</span>
  
    // handle arguments
    assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<span class="udiff-line-modified-removed">-   args-&gt;push_receiver(h_recv); // Push jobject handle</span>
<span class="udiff-line-modified-added">+   java_args.push_oop(h_recv); // Push jobject handle</span>
  
    // Fill out JavaCallArguments object
<span class="udiff-line-modified-removed">-   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
<span class="udiff-line-modified-added">+   args-&gt;push_arguments_on(&amp;java_args);</span>
    // Initialize result type
<span class="udiff-line-modified-removed">-   result-&gt;set_type(args-&gt;get_ret_type());</span>
<span class="udiff-line-modified-added">+   result-&gt;set_type(args-&gt;return_type());</span>
  
    // Invoke the method. Result is returned as oop.
    JavaCalls::call(result, method, &amp;java_args, CHECK);
  
    // Convert result
<span class="udiff-line-modified-removed">-   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(result-&gt;get_type())) {</span>
      result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1279,11 +1166,11 @@</span>
  
    HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
    return ret;
  JNI_END
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))</span>
    JNIWrapper(&quot;IsInstanceOf&quot;);
  
    HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
  
    jboolean ret = JNI_TRUE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1316,18 +1203,19 @@</span>
  
    if (name == NULL || signature == NULL) {
      THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
    }
  
<span class="udiff-line-added">+   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="udiff-line-added">+ </span>
    // Throw a NoSuchMethodError exception if we have an instance of a
    // primitive java.lang.Class
    if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
<span class="udiff-line-modified-removed">-     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);</span>
<span class="udiff-line-modified-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));</span>
    }
  
<span class="udiff-line-removed">-   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="udiff-line-removed">- </span>
    // Make sure class is linked and initialized before handing id&#39;s out to
    // Method*s.
    klass-&gt;initialize(CHECK_NULL);
  
    Method* m;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1344,11 +1232,12 @@</span>
      if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
        m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
      }
    }
    if (m == NULL || (m-&gt;is_static() != is_static)) {
<span class="udiff-line-modified-removed">-     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);</span>
<span class="udiff-line-modified-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));</span>
    }
    return m-&gt;jmethod_id();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2012,26 +1901,30 @@</span>
    JNIWrapper(&quot;GetFieldID&quot;);
    HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
    jfieldID ret = 0;
    DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
  
<span class="udiff-line-added">+   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="udiff-line-added">+ </span>
    // The class should have been loaded (we have an instance of the class
    // passed in) so the field and signature should already be in the symbol
    // table.  If they&#39;re not there, the field doesn&#39;t exist.
    TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
    TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
    if (fieldname == NULL || signame == NULL) {
<span class="udiff-line-modified-removed">-     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);</span>
<span class="udiff-line-modified-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));</span>
    }
<span class="udiff-line-modified-removed">-   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));</span>
<span class="udiff-line-modified-added">+ </span>
    // Make sure class is initialized before handing id&#39;s out to fields
    k-&gt;initialize(CHECK_NULL);
  
    fieldDescriptor fd;
    if (!k-&gt;is_instance_klass() ||
        !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
<span class="udiff-line-modified-removed">-     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);</span>
<span class="udiff-line-modified-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));</span>
    }
  
    // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
    // It may also have hash bits for k, if VerifyJNIFields is turned on.
    ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2062,11 +1955,11 @@</span>
    , EntryProbe, ReturnProbe) \
  \
    DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
    , ReturnProbe); \
  \
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \</span>
    JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
  \
    EntryProbe; \
    Return ret = 0;\
    DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2133,11 +2026,11 @@</span>
  }
  address jni_GetDoubleField_addr() {
    return (address)jni_GetDoubleField;
  }
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))</span>
    JNIWrapper(&quot;SetObjectField&quot;);
    HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
    oop o = JNIHandles::resolve_non_null(obj);
    Klass* k = o-&gt;klass();
    int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2145,21 +2038,21 @@</span>
    // jni_SetField_probe_nh() assumes that is not okay to create handles
    // and creates a ResetNoHandleMark.
    if (JvmtiExport::should_post_field_modification()) {
      jvalue field_value;
      field_value.l = value;
<span class="udiff-line-modified-removed">-     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, &#39;L&#39;, (jvalue *)&amp;field_value);</span>
<span class="udiff-line-modified-added">+     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);</span>
    }
    HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
    HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
  JNI_END
  
  
  #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
                          , EntryProbe, ReturnProbe) \
  \
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \</span>
    JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
  \
    EntryProbe; \
  \
    oop o = JNIHandles::resolve_non_null(obj); \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2171,38 +2064,38 @@</span>
    if (JvmtiExport::should_post_field_modification()) { \
      jvalue field_value; \
      field_value.unionType = value; \
      o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
    } \
<span class="udiff-line-modified-removed">-   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \</span>
<span class="udiff-line-modified-added">+   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \</span>
    o-&gt;Fieldname##_field_put(offset, value); \
    ReturnProbe; \
  JNI_END
  
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z</span>
                  , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b</span>
                  , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETBYTEFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jchar,    char,   Char,    &#39;C&#39;, c</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c</span>
                  , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETCHARFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jshort,   short,  Short,   &#39;S&#39;, s</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s</span>
                  , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETSHORTFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jint,     int,    Int,     &#39;I&#39;, i</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i</span>
                  , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETINTFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jlong,    long,   Long,    &#39;J&#39;, j</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j</span>
                  , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                  HOTSPOT_JNI_SETLONGFIELD_RETURN())
  // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jfloat,   float,  Float,   &#39;F&#39;, f</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f</span>
                  , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                  HOTSPOT_JNI_SETFLOATFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETFIELD(jdouble,  double, Double,  &#39;D&#39;, d</span>
<span class="udiff-line-modified-added">+ DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d</span>
                  , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                  HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
  
  DT_RETURN_MARK_DECL(ToReflectedField, jobject
                      , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2346,11 +2239,11 @@</span>
    // Keep JVMTI addition small and only check enabled flag here.
    // jni_SetField_probe() assumes that is okay to create handles.
    if (JvmtiExport::should_post_field_modification()) {
      jvalue field_value;
      field_value.l = value;
<span class="udiff-line-modified-removed">-     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, &#39;L&#39;, (jvalue *)&amp;field_value);</span>
<span class="udiff-line-modified-added">+     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);</span>
    }
    id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
    HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
  JNI_END
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2370,38 +2263,38 @@</span>
    if (JvmtiExport::should_post_field_modification()) { \
      jvalue field_value; \
      field_value.unionType = value; \
      JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
    } \
<span class="udiff-line-modified-removed">-   if (SigType == &#39;Z&#39;) { value = ((jboolean)value) &amp; 1; } \</span>
<span class="udiff-line-modified-added">+   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \</span>
    id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
    ReturnProbe;\
  JNI_END
  
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, &#39;Z&#39;, z</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z</span>
                        , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
                        HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    &#39;B&#39;, b</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b</span>
                        , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                        HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jchar,    char,   Char,    &#39;C&#39;, c</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c</span>
                        , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                        HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jshort,   short,  Short,   &#39;S&#39;, s</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s</span>
                        , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                        HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jint,     int,    Int,     &#39;I&#39;, i</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i</span>
                        , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                        HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jlong,    long,   Long,    &#39;J&#39;, j</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j</span>
                        , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                        HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
  // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   &#39;F&#39;, f</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f</span>
                        , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
                        HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
<span class="udiff-line-modified-removed">- DEFINE_SETSTATICFIELD(jdouble,  double, Double,  &#39;D&#39;, d</span>
<span class="udiff-line-modified-added">+ DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d</span>
                        , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
                        HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
  
  //
  // String Operations
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2421,22 +2314,22 @@</span>
    ret = (jstring) JNIHandles::make_local(env, string);
    return ret;
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))</span>
    JNIWrapper(&quot;GetStringLength&quot;);
    HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
    jsize ret = 0;
    oop s = JNIHandles::resolve_non_null(string);
    ret = java_lang_String::length(s);
   HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
    return ret;
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(</span>
    JNIEnv *env, jstring string, jboolean *isCopy))
    JNIWrapper(&quot;GetStringChars&quot;);
   HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
    jchar* buf = NULL;
    oop s = JNIHandles::resolve_non_null(string);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2467,11 +2360,11 @@</span>
    HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
    return buf;
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))</span>
    JNIWrapper(&quot;ReleaseStringChars&quot;);
    HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
    //%note jni_6
    if (chars != NULL) {
      // Since String objects are supposed to be immutable, don&#39;t copy any
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2539,11 +2432,11 @@</span>
    }
  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))</span>
    JNIWrapper(&quot;GetArrayLength&quot;);
   HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
    arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
    assert(a-&gt;is_array(), &quot;must be array&quot;);
    jsize ret = a-&gt;length();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2696,11 +2589,11 @@</span>
  
  
  #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
                                        , EntryProbe, ReturnProbe) \
  \
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(ElementType*, \</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(ElementType*, \</span>
            jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
    JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
    EntryProbe; \
    /* allocate an chunk of memory in c land */ \
    typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2758,11 +2651,11 @@</span>
  
  
  #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
                                            , EntryProbe, ReturnProbe);\
  \
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(void, \</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(void, \</span>
            jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
                                               ElementType *buf, jint mode)) \
    JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
    EntryProbe; \
    typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2903,91 +2796,10 @@</span>
  DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
                              , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
                              HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
  
  
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // Interception of natives</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // The RegisterNatives call being attempted tried to register with a method that</span>
<span class="udiff-line-removed">- // is not native.  Ask JVM TI what prefixes have been specified.  Then check</span>
<span class="udiff-line-removed">- // to see if the native method is now wrapped with the prefixes.  See the</span>
<span class="udiff-line-removed">- // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.</span>
<span class="udiff-line-removed">- static Method* find_prefixed_native(Klass* k, Symbol* name, Symbol* signature, TRAPS) {</span>
<span class="udiff-line-removed">- #if INCLUDE_JVMTI</span>
<span class="udiff-line-removed">-   ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-   Method* method;</span>
<span class="udiff-line-removed">-   int name_len = name-&gt;utf8_length();</span>
<span class="udiff-line-removed">-   char* name_str = name-&gt;as_utf8();</span>
<span class="udiff-line-removed">-   int prefix_count;</span>
<span class="udiff-line-removed">-   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; prefix_count; i++) {</span>
<span class="udiff-line-removed">-     char* prefix = prefixes[i];</span>
<span class="udiff-line-removed">-     int prefix_len = (int)strlen(prefix);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // try adding this prefix to the method name and see if it matches another method name</span>
<span class="udiff-line-removed">-     int trial_len = name_len + prefix_len;</span>
<span class="udiff-line-removed">-     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);</span>
<span class="udiff-line-removed">-     strcpy(trial_name_str, prefix);</span>
<span class="udiff-line-removed">-     strcat(trial_name_str, name_str);</span>
<span class="udiff-line-removed">-     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);</span>
<span class="udiff-line-removed">-     if (trial_name == NULL) {</span>
<span class="udiff-line-removed">-       continue; // no such symbol, so this prefix wasn&#39;t used, try the next prefix</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     method = k-&gt;lookup_method(trial_name, signature);</span>
<span class="udiff-line-removed">-     if (method == NULL) {</span>
<span class="udiff-line-removed">-       continue; // signature doesn&#39;t match, try the next prefix</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (method-&gt;is_native()) {</span>
<span class="udiff-line-removed">-       method-&gt;set_is_prefixed_native();</span>
<span class="udiff-line-removed">-       return method; // wahoo, we found a prefixed version of the method, return it</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     // found as non-native, so prefix is good, add it, probably just need more prefixes</span>
<span class="udiff-line-removed">-     name_len = trial_len;</span>
<span class="udiff-line-removed">-     name_str = trial_name_str;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMTI</span>
<span class="udiff-line-removed">-   return NULL; // not found</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) {</span>
<span class="udiff-line-removed">-   Method* method = k-&gt;lookup_method(name, signature);</span>
<span class="udiff-line-removed">-   if (method == NULL) {</span>
<span class="udiff-line-removed">-     ResourceMark rm;</span>
<span class="udiff-line-removed">-     stringStream st;</span>
<span class="udiff-line-removed">-     st.print(&quot;Method %s name or signature does not match&quot;,</span>
<span class="udiff-line-removed">-              Method::name_and_sig_as_C_string(k, name, signature));</span>
<span class="udiff-line-removed">-     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (!method-&gt;is_native()) {</span>
<span class="udiff-line-removed">-     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)</span>
<span class="udiff-line-removed">-     method = find_prefixed_native(k, name, signature, THREAD);</span>
<span class="udiff-line-removed">-     if (method == NULL) {</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       stringStream st;</span>
<span class="udiff-line-removed">-       st.print(&quot;Method %s is not declared as native&quot;,</span>
<span class="udiff-line-removed">-                Method::name_and_sig_as_C_string(k, name, signature));</span>
<span class="udiff-line-removed">-       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (entry != NULL) {</span>
<span class="udiff-line-removed">-     method-&gt;set_native_function(entry,</span>
<span class="udiff-line-removed">-       Method::native_bind_event_is_interesting);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     method-&gt;clear_native_function();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (PrintJNIResolving) {</span>
<span class="udiff-line-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;[Registering JNI native method %s.%s]&quot;,</span>
<span class="udiff-line-removed">-       method-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-removed">-       method-&gt;name()-&gt;as_C_string());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  DT_RETURN_MARK_DECL(RegisterNatives, jint
                      , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
  
  JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
                                      const JNINativeMethod *methods,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2997,10 +2809,24 @@</span>
    jint ret = 0;
    DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
  
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
  
<span class="udiff-line-added">+   // There are no restrictions on native code registering native methods, which</span>
<span class="udiff-line-added">+   // allows agents to redefine the bindings to native methods. But we issue a</span>
<span class="udiff-line-added">+   // warning if any code running outside of the boot/platform loader is rebinding</span>
<span class="udiff-line-added">+   // any native methods in classes loaded by the boot/platform loader.</span>
<span class="udiff-line-added">+   Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="udiff-line-added">+   bool do_warning = false;</span>
<span class="udiff-line-added">+   oop cl = k-&gt;class_loader();</span>
<span class="udiff-line-added">+   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {</span>
<span class="udiff-line-added">+     // If no caller class, or caller class has a different loader, then</span>
<span class="udiff-line-added">+     // issue a warning below.</span>
<span class="udiff-line-added">+     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
    for (int index = 0; index &lt; nMethods; index++) {
      const char* meth_name = methods[index].name;
      const char* meth_sig = methods[index].signature;
      int meth_name_len = (int)strlen(meth_name);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3009,19 +2835,25 @@</span>
      // table.  If they&#39;re not there, the method doesn&#39;t exist.
      TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
      TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
  
      if (name == NULL || signature == NULL) {
<span class="udiff-line-modified-removed">-       ResourceMark rm;</span>
<span class="udiff-line-modified-added">+       ResourceMark rm(THREAD);</span>
        stringStream st;
        st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
        // Must return negative value on failure
        THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
      }
  
<span class="udiff-line-modified-removed">-     bool res = register_native(k, name, signature,</span>
<span class="udiff-line-modified-removed">-                                (address) methods[index].fnPtr, THREAD);</span>
<span class="udiff-line-modified-added">+     if (do_warning) {</span>
<span class="udiff-line-modified-added">+       ResourceMark rm(THREAD);</span>
<span class="udiff-line-added">+       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;</span>
<span class="udiff-line-added">+               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool res = Method::register_native(k, name, signature,</span>
<span class="udiff-line-added">+                                        (address) methods[index].fnPtr, THREAD);</span>
      if (!res) {
        ret = -1;
        break;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3256,11 +3088,11 @@</span>
    JNIHandles::destroy_weak_global(ref);
    HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
  JNI_END
  
  
<span class="udiff-line-modified-removed">- JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))</span>
<span class="udiff-line-modified-added">+ JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))</span>
    JNIWrapper(&quot;jni_ExceptionCheck&quot;);
   HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
    jni_check_async_exceptions(thread);
    jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
   HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3282,11 +3114,11 @@</span>
  
  static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
    Handle loader;            // null (bootstrap) loader
    Handle protection_domain; // null protection domain
  
<span class="udiff-line-modified-removed">-   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol sym = SymbolTable::new_symbol(name);</span>
    jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
  
    if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
      trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3308,11 +3140,11 @@</span>
  static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
    if (directBufferSupportInitializeFailed) {
      return false;
    }
  
<span class="udiff-line-modified-removed">-   if (Atomic::cmpxchg(1, &amp;directBufferSupportInitializeStarted, 0) == 0) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {</span>
      if (!lookupDirectBufferClasses(env)) {
        directBufferSupportInitializeFailed = 1;
        return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3764,18 +3596,17 @@</span>
  void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
    intptr_t *a = (intptr_t *) jni_functions();
    intptr_t *b = (intptr_t *) new_jni_NativeInterface;
    for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
<span class="udiff-line-modified-removed">-     Atomic::store(*b++, a++);</span>
<span class="udiff-line-modified-added">+     Atomic::store(a++, *b++);</span>
    }
  }
  
  void quicken_jni_functions() {
    // Replace Get&lt;Primitive&gt;Field with fast versions
<span class="udiff-line-modified-removed">-   if (UseFastJNIAccessors &amp;&amp; !JvmtiExport::can_post_field_access()</span>
<span class="udiff-line-removed">-       &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {</span>
<span class="udiff-line-modified-added">+   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {</span>
      address func;
      func = JNI_FastGetField::generate_fast_get_boolean_field();
      if (func != (address)-1) {
        jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3887,13 +3718,13 @@</span>
    // but __sync_lock_test_and_set is not guaranteed to do what we want
    // on all architectures.  So we check it works before relying on it.
  #if defined(ZERO) &amp;&amp; defined(ASSERT)
    {
      jint a = 0xcafebabe;
<span class="udiff-line-modified-removed">-     jint b = Atomic::xchg((jint) 0xdeadbeef, &amp;a);</span>
<span class="udiff-line-modified-added">+     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);</span>
      void *c = &amp;a;
<span class="udiff-line-modified-removed">-     void *d = Atomic::xchg(&amp;b, &amp;c);</span>
<span class="udiff-line-modified-added">+     void *d = Atomic::xchg(&amp;c, &amp;b);</span>
      assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
      assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
    }
  #endif // ZERO &amp;&amp; ASSERT
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3905,14 +3736,14 @@</span>
    // one thread can call this method at a time
  
    // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
    // the add/dec implementations are dependent on whether we are running
    // on a multiprocessor Atomic::xchg does not have this problem.
<span class="udiff-line-modified-removed">-   if (Atomic::xchg(1, &amp;vm_created) == 1) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::xchg(&amp;vm_created, 1) == 1) {</span>
      return JNI_EEXIST;   // already created, or create attempt in progress
    }
<span class="udiff-line-modified-removed">-   if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {</span>
      return JNI_ERR;  // someone tried and failed and retry not allowed.
    }
  
    assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3967,11 +3798,11 @@</span>
      // functions in order to properly handle error conditions.
      VMError::test_error_handler();
  #endif
  
      // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
<span class="udiff-line-modified-removed">-     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
<span class="udiff-line-modified-added">+     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
    } else {
      // If create_vm exits because of a pending exception, exit with that
      // exception.  In the future when we figure out how to reclaim memory,
      // we may be able to exit with JNI_ERR and allow the calling application
      // to continue.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3992,11 +3823,11 @@</span>
      // Creation failed. We must reset vm_created
      *vm = 0;
      *(JNIEnv**)penv = 0;
      // reset vm_created last to avoid race condition. Use OrderAccess to
      // control both compiler and architectural-based reordering.
<span class="udiff-line-modified-removed">-     OrderAccess::release_store(&amp;vm_created, 0);</span>
<span class="udiff-line-modified-added">+     Atomic::release_store(&amp;vm_created, 0);</span>
    }
  
    // Flush stdout and stderr before exit.
    fflush(stdout);
    fflush(stderr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4069,11 +3900,11 @@</span>
      // Should not change thread state, VM is gone
      vm_created = 0;
      res = JNI_OK;
      return res;
    } else {
<span class="udiff-line-modified-removed">-     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
<span class="udiff-line-modified-added">+     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
      res = JNI_ERR;
      return res;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4130,18 +3961,17 @@</span>
  
    thread-&gt;initialize_tlab();
  
    thread-&gt;cache_global_variables();
  
<span class="udiff-line-modified-removed">-   // Crucial that we do not have a safepoint check for this thread, since it has</span>
<span class="udiff-line-modified-added">+   // This thread will not do a safepoint check, since it has</span>
    // not been added to the Thread list yet.
<span class="udiff-line-modified-removed">-   { Threads_lock-&gt;lock_without_safepoint_check();</span>
<span class="udiff-line-modified-added">+   { MutexLocker ml(Threads_lock);</span>
      // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
      // avoid this thread trying to do a GC before it is added to the thread-list
      thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
      Threads::add(thread, daemon);
<span class="udiff-line-removed">-     Threads_lock-&gt;unlock();</span>
    }
    // Create thread group and name info from attach arguments
    oop group = NULL;
    char* thread_name = NULL;
    if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4164,11 +3994,11 @@</span>
      }
    }
  
    if (attach_failed) {
      // Added missing cleanup
<span class="udiff-line-modified-removed">-     thread-&gt;cleanup_failed_attach_current_thread();</span>
<span class="udiff-line-modified-added">+     thread-&gt;cleanup_failed_attach_current_thread(daemon);</span>
      return JNI_ERR;
    }
  
    // mark the thread as no longer attaching
    // this uses a fence to push the change through so we don&#39;t have
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4191,11 +4021,11 @@</span>
    // Now leaving the VM, so change thread_state. This is normally automatically taken care
    // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
    // using ThreadStateTransition::transition, we do a callback to the safepoint code if
    // needed.
  
<span class="udiff-line-modified-removed">-   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);</span>
<span class="udiff-line-modified-added">+   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);</span>
  
    // Perform any platform dependent FPU setup
    os::setup_fpu();
  
    return JNI_OK;
</pre>
<center><a href="forte.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
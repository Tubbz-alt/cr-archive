<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiImpl.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiH.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiImpl.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;classfile/systemDictionary.hpp&quot;



  27 #include &quot;interpreter/interpreter.hpp&quot;
  28 #include &quot;interpreter/oopMapCache.hpp&quot;
  29 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logStream.hpp&quot;
  32 #include &quot;memory/allocation.inline.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/jvmtiAgentThread.hpp&quot;
  37 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  38 #include &quot;prims/jvmtiImpl.hpp&quot;
  39 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
<span class="line-removed">  40 #include &quot;runtime/atomic.hpp&quot;</span>
  41 #include &quot;runtime/deoptimization.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/serviceThread.hpp&quot;
  48 #include &quot;runtime/signature.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;runtime/vframe.hpp&quot;
  52 #include &quot;runtime/vframe_hp.hpp&quot;
  53 #include &quot;runtime/vmOperations.hpp&quot;
  54 #include &quot;utilities/exceptions.hpp&quot;
  55 
  56 //
  57 // class JvmtiAgentThread
  58 //
  59 // JavaThread used to wrap a thread started by an agent
  60 // using the JVMTI method RunAgentThread.
</pre>
<hr />
<pre>
 153 }
 154 
 155 // get the value of the index element in the collection
 156 GrowableElement* GrowableCache::at(int index) {
 157   GrowableElement *e = (GrowableElement *) _elements-&gt;at(index);
 158   assert(e != NULL, &quot;e != NULL&quot;);
 159   return e;
 160 }
 161 
 162 int GrowableCache::find(GrowableElement* e) {
 163   return _elements-&gt;find(e, GrowableCache::equals);
 164 }
 165 
 166 // append a copy of the element to the end of the collection
 167 void GrowableCache::append(GrowableElement* e) {
 168   GrowableElement *new_e = e-&gt;clone();
 169   _elements-&gt;append(new_e);
 170   recache();
 171 }
 172 
<span class="line-removed"> 173 // insert a copy of the element using lessthan()</span>
<span class="line-removed"> 174 void GrowableCache::insert(GrowableElement* e) {</span>
<span class="line-removed"> 175   GrowableElement *new_e = e-&gt;clone();</span>
<span class="line-removed"> 176   _elements-&gt;append(new_e);</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178   int n = length()-2;</span>
<span class="line-removed"> 179   for (int i=n; i&gt;=0; i--) {</span>
<span class="line-removed"> 180     GrowableElement *e1 = _elements-&gt;at(i);</span>
<span class="line-removed"> 181     GrowableElement *e2 = _elements-&gt;at(i+1);</span>
<span class="line-removed"> 182     if (e2-&gt;lessThan(e1)) {</span>
<span class="line-removed"> 183       _elements-&gt;at_put(i+1, e1);</span>
<span class="line-removed"> 184       _elements-&gt;at_put(i,   e2);</span>
<span class="line-removed"> 185     }</span>
<span class="line-removed"> 186   }</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188   recache();</span>
<span class="line-removed"> 189 }</span>
<span class="line-removed"> 190 </span>
 191 // remove the element at index
 192 void GrowableCache::remove (int index) {
 193   GrowableElement *e = _elements-&gt;at(index);
 194   assert(e != NULL, &quot;e != NULL&quot;);
 195   _elements-&gt;remove(e);
 196   delete e;
 197   recache();
 198 }
 199 
 200 // clear out all elements, release all heap space and
 201 // let our listener know that things have changed.
 202 void GrowableCache::clear() {
 203   int len = _elements-&gt;length();
 204   for (int i=0; i&lt;len; i++) {
 205     delete _elements-&gt;at(i);
 206   }
 207   _elements-&gt;clear();
 208   recache();
 209 }
 210 
<span class="line-removed"> 211 void GrowableCache::oops_do(OopClosure* f) {</span>
<span class="line-removed"> 212   int len = _elements-&gt;length();</span>
<span class="line-removed"> 213   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed"> 214     GrowableElement *e = _elements-&gt;at(i);</span>
<span class="line-removed"> 215     e-&gt;oops_do(f);</span>
<span class="line-removed"> 216   }</span>
<span class="line-removed"> 217 }</span>
<span class="line-removed"> 218 </span>
<span class="line-removed"> 219 void GrowableCache::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed"> 220   int len = _elements-&gt;length();</span>
<span class="line-removed"> 221   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed"> 222     GrowableElement *e = _elements-&gt;at(i);</span>
<span class="line-removed"> 223     e-&gt;metadata_do(f);</span>
<span class="line-removed"> 224   }</span>
<span class="line-removed"> 225 }</span>
<span class="line-removed"> 226 </span>
<span class="line-removed"> 227 void GrowableCache::gc_epilogue() {</span>
<span class="line-removed"> 228   int len = _elements-&gt;length();</span>
<span class="line-removed"> 229   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed"> 230     _cache[i] = _elements-&gt;at(i)-&gt;getCacheValue();</span>
<span class="line-removed"> 231   }</span>
<span class="line-removed"> 232 }</span>
<span class="line-removed"> 233 </span>
 234 //
 235 // class JvmtiBreakpoint
 236 //
 237 
<span class="line-modified"> 238 JvmtiBreakpoint::JvmtiBreakpoint() {</span>
<span class="line-modified"> 239   _method = NULL;</span>
<span class="line-modified"> 240   _bci    = 0;</span>
<span class="line-modified"> 241   _class_holder = NULL;</span>







 242 }
 243 
<span class="line-modified"> 244 JvmtiBreakpoint::JvmtiBreakpoint(Method* m_method, jlocation location) {</span>
<span class="line-modified"> 245   _method        = m_method;</span>
<span class="line-modified"> 246   _class_holder  = _method-&gt;method_holder()-&gt;klass_holder();</span>
<span class="line-modified"> 247 #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-modified"> 248   // _class_holder can&#39;t be wrapped in a Handle, because JvmtiBreakpoints are</span>
<span class="line-removed"> 249   // sometimes allocated on the heap.</span>
<span class="line-removed"> 250   //</span>
<span class="line-removed"> 251   // The code handling JvmtiBreakpoints allocated on the stack can&#39;t be</span>
<span class="line-removed"> 252   // interrupted by a GC until _class_holder is reachable by the GC via the</span>
<span class="line-removed"> 253   // oops_do method.</span>
<span class="line-removed"> 254   Thread::current()-&gt;allow_unhandled_oop(&amp;_class_holder);</span>
<span class="line-removed"> 255 #endif // CHECK_UNHANDLED_OOPS</span>
<span class="line-removed"> 256   assert(_method != NULL, &quot;_method != NULL&quot;);</span>
<span class="line-removed"> 257   _bci           = (int) location;</span>
<span class="line-removed"> 258   assert(_bci &gt;= 0, &quot;_bci &gt;= 0&quot;);</span>
 259 }
 260 
 261 void JvmtiBreakpoint::copy(JvmtiBreakpoint&amp; bp) {
 262   _method   = bp._method;
 263   _bci      = bp._bci;
<span class="line-modified"> 264   _class_holder = bp._class_holder;</span>
<span class="line-modified"> 265 }</span>
<span class="line-modified"> 266 </span>
<span class="line-modified"> 267 bool JvmtiBreakpoint::lessThan(JvmtiBreakpoint&amp; bp) {</span>
<span class="line-modified"> 268   Unimplemented();</span>
<span class="line-modified"> 269   return false;</span>

 270 }
 271 
 272 bool JvmtiBreakpoint::equals(JvmtiBreakpoint&amp; bp) {
 273   return _method   == bp._method
 274     &amp;&amp;   _bci      == bp._bci;
 275 }
 276 
<span class="line-removed"> 277 bool JvmtiBreakpoint::is_valid() {</span>
<span class="line-removed"> 278   // class loader can be NULL</span>
<span class="line-removed"> 279   return _method != NULL &amp;&amp;</span>
<span class="line-removed"> 280          _bci &gt;= 0;</span>
<span class="line-removed"> 281 }</span>
<span class="line-removed"> 282 </span>
 283 address JvmtiBreakpoint::getBcp() const {
 284   return _method-&gt;bcp_from(_bci);
 285 }
 286 
 287 void JvmtiBreakpoint::each_method_version_do(method_action meth_act) {
 288   ((Method*)_method-&gt;*meth_act)(_bci);
 289 
 290   // add/remove breakpoint to/from versions of the method that are EMCP.
 291   Thread *thread = Thread::current();
 292   InstanceKlass* ik = _method-&gt;method_holder();
 293   Symbol* m_name = _method-&gt;name();
 294   Symbol* m_signature = _method-&gt;signature();
 295 
 296   // search previous versions if they exist
 297   for (InstanceKlass* pv_node = ik-&gt;previous_versions();
 298        pv_node != NULL;
 299        pv_node = pv_node-&gt;previous_versions()) {
 300     Array&lt;Method*&gt;* methods = pv_node-&gt;methods();
 301 
 302     for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
 336 
 337 //
 338 // class VM_ChangeBreakpoints
 339 //
 340 // Modify the Breakpoints data structure at a safepoint
 341 //
 342 
 343 void VM_ChangeBreakpoints::doit() {
 344   switch (_operation) {
 345   case SET_BREAKPOINT:
 346     _breakpoints-&gt;set_at_safepoint(*_bp);
 347     break;
 348   case CLEAR_BREAKPOINT:
 349     _breakpoints-&gt;clear_at_safepoint(*_bp);
 350     break;
 351   default:
 352     assert(false, &quot;Unknown operation&quot;);
 353   }
 354 }
 355 
<span class="line-removed"> 356 void VM_ChangeBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed"> 357   // The JvmtiBreakpoints in _breakpoints will be visited via</span>
<span class="line-removed"> 358   // JvmtiExport::oops_do.</span>
<span class="line-removed"> 359   if (_bp != NULL) {</span>
<span class="line-removed"> 360     _bp-&gt;oops_do(f);</span>
<span class="line-removed"> 361   }</span>
<span class="line-removed"> 362 }</span>
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364 void VM_ChangeBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed"> 365   // Walk metadata in breakpoints to keep from being deallocated with RedefineClasses</span>
<span class="line-removed"> 366   if (_bp != NULL) {</span>
<span class="line-removed"> 367     _bp-&gt;metadata_do(f);</span>
<span class="line-removed"> 368   }</span>
<span class="line-removed"> 369 }</span>
<span class="line-removed"> 370 </span>
 371 //
 372 // class JvmtiBreakpoints
 373 //
 374 // a JVMTI internal collection of JvmtiBreakpoint
 375 //
 376 
 377 JvmtiBreakpoints::JvmtiBreakpoints(void listener_fun(void *,address *)) {
 378   _bps.initialize(this,listener_fun);
 379 }
 380 
 381 JvmtiBreakpoints:: ~JvmtiBreakpoints() {}
 382 
<span class="line-removed"> 383 void  JvmtiBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed"> 384   _bps.oops_do(f);</span>
<span class="line-removed"> 385 }</span>
<span class="line-removed"> 386 </span>
<span class="line-removed"> 387 void  JvmtiBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed"> 388   _bps.metadata_do(f);</span>
<span class="line-removed"> 389 }</span>
<span class="line-removed"> 390 </span>
<span class="line-removed"> 391 void JvmtiBreakpoints::gc_epilogue() {</span>
<span class="line-removed"> 392   _bps.gc_epilogue();</span>
<span class="line-removed"> 393 }</span>
<span class="line-removed"> 394 </span>
 395 void JvmtiBreakpoints::print() {
 396 #ifndef PRODUCT
 397   LogTarget(Trace, jvmti) log;
 398   LogStream log_stream(log);
 399 
 400   int n = _bps.length();
 401   for (int i=0; i&lt;n; i++) {
 402     JvmtiBreakpoint&amp; bp = _bps.at(i);
 403     log_stream.print(&quot;%d: &quot;, i);
 404     bp.print_on(&amp;log_stream);
 405     log_stream.cr();
 406   }
 407 #endif
 408 }
 409 
 410 
 411 void JvmtiBreakpoints::set_at_safepoint(JvmtiBreakpoint&amp; bp) {
 412   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 413 
 414   int i = _bps.find(bp);
</pre>
<hr />
<pre>
 483 address *         JvmtiCurrentBreakpoints::_breakpoint_list    = NULL;
 484 
 485 
 486 JvmtiBreakpoints&amp; JvmtiCurrentBreakpoints::get_jvmti_breakpoints() {
 487   if (_jvmti_breakpoints != NULL) return (*_jvmti_breakpoints);
 488   _jvmti_breakpoints = new JvmtiBreakpoints(listener_fun);
 489   assert(_jvmti_breakpoints != NULL, &quot;_jvmti_breakpoints != NULL&quot;);
 490   return (*_jvmti_breakpoints);
 491 }
 492 
 493 void  JvmtiCurrentBreakpoints::listener_fun(void *this_obj, address *cache) {
 494   JvmtiBreakpoints *this_jvmti = (JvmtiBreakpoints *) this_obj;
 495   assert(this_jvmti != NULL, &quot;this_jvmti != NULL&quot;);
 496 
 497   debug_only(int n = this_jvmti-&gt;length(););
 498   assert(cache[n] == NULL, &quot;cache must be NULL terminated&quot;);
 499 
 500   set_breakpoint_list(cache);
 501 }
 502 
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504 void JvmtiCurrentBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed"> 505   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed"> 506     _jvmti_breakpoints-&gt;oops_do(f);</span>
<span class="line-removed"> 507   }</span>
<span class="line-removed"> 508 }</span>
<span class="line-removed"> 509 </span>
<span class="line-removed"> 510 void JvmtiCurrentBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed"> 511   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed"> 512     _jvmti_breakpoints-&gt;metadata_do(f);</span>
<span class="line-removed"> 513   }</span>
<span class="line-removed"> 514 }</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516 void JvmtiCurrentBreakpoints::gc_epilogue() {</span>
<span class="line-removed"> 517   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed"> 518     _jvmti_breakpoints-&gt;gc_epilogue();</span>
<span class="line-removed"> 519   }</span>
<span class="line-removed"> 520 }</span>
<span class="line-removed"> 521 </span>
 522 ///////////////////////////////////////////////////////////////
 523 //
 524 // class VM_GetOrSetLocal
 525 //
 526 
 527 // Constructor for non-object getter
 528 VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type)
 529   : _thread(thread)
 530   , _calling_thread(NULL)
 531   , _depth(depth)
 532   , _index(index)
 533   , _type(type)
 534   , _jvf(NULL)
 535   , _set(false)
 536   , _result(JVMTI_ERROR_NONE)
 537 {
 538 }
 539 
 540 // Constructor for object or non-object setter
 541 VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value)
</pre>
<hr />
<pre>
 587   javaVFrame *jvf = (javaVFrame*)vf;
 588 
 589   if (!vf-&gt;is_java_frame()) {
 590     _result = JVMTI_ERROR_OPAQUE_FRAME;
 591     return NULL;
 592   }
 593   return jvf;
 594 }
 595 
 596 // Check that the klass is assignable to a type with the given signature.
 597 // Another solution could be to use the function Klass::is_subtype_of(type).
 598 // But the type class can be forced to load/initialize eagerly in such a case.
 599 // This may cause unexpected consequences like CFLH or class-init JVMTI events.
 600 // It is better to avoid such a behavior.
 601 bool VM_GetOrSetLocal::is_assignable(const char* ty_sign, Klass* klass, Thread* thread) {
 602   assert(ty_sign != NULL, &quot;type signature must not be NULL&quot;);
 603   assert(thread != NULL, &quot;thread must not be NULL&quot;);
 604   assert(klass != NULL, &quot;klass must not be NULL&quot;);
 605 
 606   int len = (int) strlen(ty_sign);
<span class="line-modified"> 607   if (ty_sign[0] == &#39;L&#39; &amp;&amp; ty_sign[len-1] == &#39;;&#39;) { // Need pure class/interface name</span>

 608     ty_sign++;
 609     len -= 2;
 610   }
<span class="line-modified"> 611   TempNewSymbol ty_sym = SymbolTable::new_symbol(ty_sign, len, thread);</span>
 612   if (klass-&gt;name() == ty_sym) {
 613     return true;
 614   }
 615   // Compare primary supers
 616   int super_depth = klass-&gt;super_depth();
 617   int idx;
 618   for (idx = 0; idx &lt; super_depth; idx++) {
 619     if (klass-&gt;primary_super_of_depth(idx)-&gt;name() == ty_sym) {
 620       return true;
 621     }
 622   }
 623   // Compare secondary supers
 624   const Array&lt;Klass*&gt;* sec_supers = klass-&gt;secondary_supers();
 625   for (idx = 0; idx &lt; sec_supers-&gt;length(); idx++) {
 626     if (((Klass*) sec_supers-&gt;at(idx))-&gt;name() == ty_sym) {
 627       return true;
 628     }
 629   }
 630   return false;
 631 }
</pre>
<hr />
<pre>
 644   }
 645   int signature_idx = -1;
 646   int vf_bci = jvf-&gt;bci();
 647   LocalVariableTableElement* table = method_oop-&gt;localvariable_table_start();
 648   for (int i = 0; i &lt; num_entries; i++) {
 649     int start_bci = table[i].start_bci;
 650     int end_bci = start_bci + table[i].length;
 651 
 652     // Here we assume that locations of LVT entries
 653     // with the same slot number cannot be overlapped
 654     if (_index == (jint) table[i].slot &amp;&amp; start_bci &lt;= vf_bci &amp;&amp; vf_bci &lt;= end_bci) {
 655       signature_idx = (int) table[i].descriptor_cp_index;
 656       break;
 657     }
 658   }
 659   if (signature_idx == -1) {
 660     _result = JVMTI_ERROR_INVALID_SLOT;
 661     return false;       // Incorrect slot index
 662   }
 663   Symbol*   sign_sym  = method_oop-&gt;constants()-&gt;symbol_at(signature_idx);
<span class="line-modified"> 664   const char* signature = (const char *) sign_sym-&gt;as_utf8();</span>
<span class="line-removed"> 665   BasicType slot_type = char2type(signature[0]);</span>
 666 
 667   switch (slot_type) {
 668   case T_BYTE:
 669   case T_SHORT:
 670   case T_CHAR:
 671   case T_BOOLEAN:
 672     slot_type = T_INT;
 673     break;
 674   case T_ARRAY:
 675     slot_type = T_OBJECT;
 676     break;
 677   default:
 678     break;
 679   };
 680   if (_type != slot_type) {
 681     _result = JVMTI_ERROR_TYPE_MISMATCH;
 682     return false;
 683   }
 684 
 685   jobject jobj = _value.l;
 686   if (_set &amp;&amp; slot_type == T_OBJECT &amp;&amp; jobj != NULL) { // NULL reference is allowed
 687     // Check that the jobject class matches the return type signature.
 688     JavaThread* cur_thread = JavaThread::current();
 689     HandleMark hm(cur_thread);
 690 
 691     Handle obj(cur_thread, JNIHandles::resolve_external_guard(jobj));
 692     NULL_CHECK(obj, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
 693     Klass* ob_k = obj-&gt;klass();
 694     NULL_CHECK(ob_k, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
 695 

 696     if (!is_assignable(signature, ob_k, cur_thread)) {
 697       _result = JVMTI_ERROR_TYPE_MISMATCH;
 698       return false;
 699     }
 700   }
 701   return true;
 702 }
 703 
 704 bool VM_GetOrSetLocal::check_slot_type_no_lvt(javaVFrame* jvf) {
 705   Method* method_oop = jvf-&gt;method();
 706   jint extra_slot = (_type == T_LONG || _type == T_DOUBLE) ? 1 : 0;
 707 
 708   if (_index &lt; 0 || _index + extra_slot &gt;= method_oop-&gt;max_locals()) {
 709     _result = JVMTI_ERROR_INVALID_SLOT;
 710     return false;
 711   }
 712   StackValueCollection *locals = _jvf-&gt;locals();
 713   BasicType slot_type = locals-&gt;at(_index)-&gt;type();
 714 
 715   if (slot_type == T_CONFLICT) {
</pre>
<hr />
<pre>
 722       _result = JVMTI_ERROR_INVALID_SLOT;
 723       return false;
 724     }
 725   }
 726   if (_type != slot_type &amp;&amp; (_type == T_OBJECT || slot_type != T_INT)) {
 727     _result = JVMTI_ERROR_TYPE_MISMATCH;
 728     return false;
 729   }
 730   return true;
 731 }
 732 
 733 static bool can_be_deoptimized(vframe* vf) {
 734   return (vf-&gt;is_compiled_frame() &amp;&amp; vf-&gt;fr().can_be_deoptimized());
 735 }
 736 
 737 bool VM_GetOrSetLocal::doit_prologue() {
 738   _jvf = get_java_vframe();
 739   NULL_CHECK(_jvf, false);
 740 
 741   Method* method_oop = _jvf-&gt;method();
<span class="line-modified"> 742   if (method_oop-&gt;is_native()) {</span>
<span class="line-modified"> 743     if (getting_receiver() &amp;&amp; !method_oop-&gt;is_static()) {</span>
<span class="line-modified"> 744       return true;</span>
<span class="line-removed"> 745     } else {</span>
<span class="line-removed"> 746       _result = JVMTI_ERROR_OPAQUE_FRAME;</span>
 747       return false;
 748     }






 749   }
 750 



 751   if (method_oop-&gt;has_localvariable_table()) {
 752     return check_slot_type_lvt(_jvf);
<span class="line-removed"> 753   } else {</span>
<span class="line-removed"> 754     return check_slot_type_no_lvt(_jvf);</span>
 755   }
 756   return true;
 757 }
 758 
 759 void VM_GetOrSetLocal::doit() {
 760   InterpreterOopMap oop_mask;
 761   _jvf-&gt;method()-&gt;mask_for(_jvf-&gt;bci(), &amp;oop_mask);
 762   if (oop_mask.is_dead(_index)) {
 763     // The local can be invalid and uninitialized in the scope of current bci
 764     _result = JVMTI_ERROR_INVALID_SLOT;
 765     return;
 766   }
 767   if (_set) {
 768     // Force deoptimization of frame if compiled because it&#39;s
 769     // possible the compiler emitted some locals as constant values,
 770     // meaning they are not mutable.
 771     if (can_be_deoptimized(_jvf)) {
 772 
 773       // Schedule deoptimization so that eventually the local
 774       // update will be written to an interpreter frame.
 775       Deoptimization::deoptimize_frame(_jvf-&gt;thread(), _jvf-&gt;fr().id());
 776 
 777       // Now store a new value for the local which will be applied
 778       // once deoptimization occurs. Note however that while this
 779       // write is deferred until deoptimization actually happens
 780       // can vframe created after this point will have its locals
 781       // reflecting this update so as far as anyone can see the
 782       // write has already taken place.
 783 
 784       // If we are updating an oop then get the oop from the handle
 785       // since the handle will be long gone by the time the deopt
 786       // happens. The oop stored in the deferred local will be
 787       // gc&#39;d on its own.
 788       if (_type == T_OBJECT) {
<span class="line-modified"> 789         _value.l = (jobject) (JNIHandles::resolve_external_guard(_value.l));</span>
 790       }
 791       // Re-read the vframe so we can see that it is deoptimized
 792       // [ Only need because of assert in update_local() ]
 793       _jvf = get_java_vframe();
 794       ((compiledVFrame*)_jvf)-&gt;update_local(_type, _index, _value);
 795       return;
 796     }
 797     StackValueCollection *locals = _jvf-&gt;locals();
 798     HandleMark hm;
 799 
 800     switch (_type) {
 801       case T_INT:    locals-&gt;set_int_at   (_index, _value.i); break;
 802       case T_LONG:   locals-&gt;set_long_at  (_index, _value.j); break;
 803       case T_FLOAT:  locals-&gt;set_float_at (_index, _value.f); break;
 804       case T_DOUBLE: locals-&gt;set_double_at(_index, _value.d); break;
 805       case T_OBJECT: {
 806         Handle ob_h(Thread::current(), JNIHandles::resolve_external_guard(_value.l));
 807         locals-&gt;set_obj_at (_index, ob_h);
 808         break;
 809       }
</pre>
<hr />
<pre>
 879   return true;
 880 }
 881 
 882 bool JvmtiSuspendControl::resume(JavaThread *java_thread) {
 883   // external suspend should have caught resuming a thread twice
 884   assert(java_thread-&gt;is_being_ext_suspended(), &quot;thread should be suspended&quot;);
 885 
 886   // resume thread
 887   {
 888     // must always grab Threads_lock, see JVM_SuspendThread
 889     MutexLocker ml(Threads_lock);
 890     java_thread-&gt;java_resume();
 891   }
 892 
 893   return true;
 894 }
 895 
 896 
 897 void JvmtiSuspendControl::print() {
 898 #ifndef PRODUCT

 899   LogStreamHandle(Trace, jvmti) log_stream;
 900   log_stream.print(&quot;Suspended Threads: [&quot;);
 901   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
 902 #ifdef JVMTI_TRACE
 903     const char *name   = JvmtiTrace::safe_get_thread_name(thread);
 904 #else
 905     const char *name   = &quot;&quot;;
 906 #endif /*JVMTI_TRACE */
 907     log_stream.print(&quot;%s(%c &quot;, name, thread-&gt;is_being_ext_suspended() ? &#39;S&#39; : &#39;_&#39;);
 908     if (!thread-&gt;has_last_Java_frame()) {
 909       log_stream.print(&quot;no stack&quot;);
 910     }
 911     log_stream.print(&quot;) &quot;);
 912   }
 913   log_stream.print_cr(&quot;]&quot;);
 914 #endif
 915 }
 916 
 917 JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_load_event(
 918     nmethod* nm) {
 919   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_LOAD);
 920   event._event_data.compiled_method_load = nm;
<span class="line-removed"> 921   // Keep the nmethod alive until the ServiceThread can process</span>
<span class="line-removed"> 922   // this deferred event.</span>
<span class="line-removed"> 923   nmethodLocker::lock_nmethod(nm);</span>
 924   return event;
 925 }
 926 
 927 JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_unload_event(
<span class="line-modified"> 928     nmethod* nm, jmethodID id, const void* code) {</span>
 929   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_UNLOAD);
<span class="line-removed"> 930   event._event_data.compiled_method_unload.nm = nm;</span>
 931   event._event_data.compiled_method_unload.method_id = id;
 932   event._event_data.compiled_method_unload.code_begin = code;
<span class="line-removed"> 933   // Keep the nmethod alive until the ServiceThread can process</span>
<span class="line-removed"> 934   // this deferred event. This will keep the memory for the</span>
<span class="line-removed"> 935   // generated code from being reused too early. We pass</span>
<span class="line-removed"> 936   // zombie_ok == true here so that our nmethod that was just</span>
<span class="line-removed"> 937   // made into a zombie can be locked.</span>
<span class="line-removed"> 938   nmethodLocker::lock_nmethod(nm, true /* zombie_ok */);</span>
 939   return event;
 940 }
 941 
 942 JvmtiDeferredEvent JvmtiDeferredEvent::dynamic_code_generated_event(
 943       const char* name, const void* code_begin, const void* code_end) {
 944   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_DYNAMIC_CODE_GENERATED);
 945   // Need to make a copy of the name since we don&#39;t know how long
 946   // the event poster will keep it around after we enqueue the
 947   // deferred event and return. strdup() failure is handled in
 948   // the post() routine below.
 949   event._event_data.dynamic_code_generated.name = os::strdup(name);
 950   event._event_data.dynamic_code_generated.code_begin = code_begin;
 951   event._event_data.dynamic_code_generated.code_end = code_end;
 952   return event;
 953 }
 954 










 955 void JvmtiDeferredEvent::post() {
<span class="line-modified"> 956   assert(ServiceThread::is_service_thread(Thread::current()),</span>
 957          &quot;Service thread must post enqueued events&quot;);
 958   switch(_type) {
 959     case TYPE_COMPILED_METHOD_LOAD: {
 960       nmethod* nm = _event_data.compiled_method_load;
 961       JvmtiExport::post_compiled_method_load(nm);
<span class="line-removed"> 962       // done with the deferred event so unlock the nmethod</span>
<span class="line-removed"> 963       nmethodLocker::unlock_nmethod(nm);</span>
 964       break;
 965     }
 966     case TYPE_COMPILED_METHOD_UNLOAD: {
<span class="line-removed"> 967       nmethod* nm = _event_data.compiled_method_unload.nm;</span>
 968       JvmtiExport::post_compiled_method_unload(
 969         _event_data.compiled_method_unload.method_id,
 970         _event_data.compiled_method_unload.code_begin);
<span class="line-removed"> 971       // done with the deferred event so unlock the nmethod</span>
<span class="line-removed"> 972       nmethodLocker::unlock_nmethod(nm);</span>
 973       break;
 974     }
 975     case TYPE_DYNAMIC_CODE_GENERATED: {
 976       JvmtiExport::post_dynamic_code_generated_internal(
 977         // if strdup failed give the event a default name
 978         (_event_data.dynamic_code_generated.name == NULL)
 979           ? &quot;unknown_code&quot; : _event_data.dynamic_code_generated.name,
 980         _event_data.dynamic_code_generated.code_begin,
 981         _event_data.dynamic_code_generated.code_end);
 982       if (_event_data.dynamic_code_generated.name != NULL) {
 983         // release our copy
 984         os::free((void *)_event_data.dynamic_code_generated.name);
 985       }
 986       break;
 987     }











 988     default:
 989       ShouldNotReachHere();
 990   }
 991 }
 992 
<span class="line-modified"> 993 JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_tail = NULL;</span>
<span class="line-modified"> 994 JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_head = NULL;</span>



 995 
<span class="line-modified"> 996 bool JvmtiDeferredEventQueue::has_events() {</span>
<span class="line-modified"> 997   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>
<span class="line-modified"> 998   return _queue_head != NULL;</span>









 999 }
1000 
<span class="line-modified">1001 void JvmtiDeferredEventQueue::enqueue(const JvmtiDeferredEvent&amp; event) {</span>
<span class="line-modified">1002   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>





1003 













1004   // Events get added to the end of the queue (and are pulled off the front).
1005   QueueNode* node = new QueueNode(event);
1006   if (_queue_tail == NULL) {
1007     _queue_tail = _queue_head = node;
1008   } else {
1009     assert(_queue_tail-&gt;next() == NULL, &quot;Must be the last element in the list&quot;);
1010     _queue_tail-&gt;set_next(node);
1011     _queue_tail = node;
1012   }
1013 
<span class="line-removed">1014   Service_lock-&gt;notify_all();</span>
1015   assert((_queue_head == NULL) == (_queue_tail == NULL),
1016          &quot;Inconsistent queue markers&quot;);
1017 }
1018 
1019 JvmtiDeferredEvent JvmtiDeferredEventQueue::dequeue() {
<span class="line-removed">1020   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>
<span class="line-removed">1021 </span>
1022   assert(_queue_head != NULL, &quot;Nothing to dequeue&quot;);
1023 
1024   if (_queue_head == NULL) {
1025     // Just in case this happens in product; it shouldn&#39;t but let&#39;s not crash
1026     return JvmtiDeferredEvent();
1027   }
1028 
1029   QueueNode* node = _queue_head;
1030   _queue_head = _queue_head-&gt;next();
1031   if (_queue_head == NULL) {
1032     _queue_tail = NULL;
1033   }
1034 
1035   assert((_queue_head == NULL) == (_queue_tail == NULL),
1036          &quot;Inconsistent queue markers&quot;);
1037 
1038   JvmtiDeferredEvent event = node-&gt;event();
1039   delete node;
1040   return event;
1041 }



























</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;classfile/symbolTable.hpp&quot;</span>
  27 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">  28 #include &quot;code/nmethod.hpp&quot;</span>
<span class="line-added">  29 #include &quot;gc/shared/oopStorage.hpp&quot;</span>
<span class="line-added">  30 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/oopMapCache.hpp&quot;
  33 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logStream.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/instanceKlass.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;prims/jvmtiAgentThread.hpp&quot;
  41 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  42 #include &quot;prims/jvmtiImpl.hpp&quot;
  43 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;

  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/os.hpp&quot;
  50 #include &quot;runtime/serviceThread.hpp&quot;
  51 #include &quot;runtime/signature.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;runtime/threadSMR.hpp&quot;
  54 #include &quot;runtime/vframe.hpp&quot;
  55 #include &quot;runtime/vframe_hp.hpp&quot;
  56 #include &quot;runtime/vmOperations.hpp&quot;
  57 #include &quot;utilities/exceptions.hpp&quot;
  58 
  59 //
  60 // class JvmtiAgentThread
  61 //
  62 // JavaThread used to wrap a thread started by an agent
  63 // using the JVMTI method RunAgentThread.
</pre>
<hr />
<pre>
 156 }
 157 
 158 // get the value of the index element in the collection
 159 GrowableElement* GrowableCache::at(int index) {
 160   GrowableElement *e = (GrowableElement *) _elements-&gt;at(index);
 161   assert(e != NULL, &quot;e != NULL&quot;);
 162   return e;
 163 }
 164 
 165 int GrowableCache::find(GrowableElement* e) {
 166   return _elements-&gt;find(e, GrowableCache::equals);
 167 }
 168 
 169 // append a copy of the element to the end of the collection
 170 void GrowableCache::append(GrowableElement* e) {
 171   GrowableElement *new_e = e-&gt;clone();
 172   _elements-&gt;append(new_e);
 173   recache();
 174 }
 175 


















 176 // remove the element at index
 177 void GrowableCache::remove (int index) {
 178   GrowableElement *e = _elements-&gt;at(index);
 179   assert(e != NULL, &quot;e != NULL&quot;);
 180   _elements-&gt;remove(e);
 181   delete e;
 182   recache();
 183 }
 184 
 185 // clear out all elements, release all heap space and
 186 // let our listener know that things have changed.
 187 void GrowableCache::clear() {
 188   int len = _elements-&gt;length();
 189   for (int i=0; i&lt;len; i++) {
 190     delete _elements-&gt;at(i);
 191   }
 192   _elements-&gt;clear();
 193   recache();
 194 }
 195 























 196 //
 197 // class JvmtiBreakpoint
 198 //
 199 
<span class="line-modified"> 200 JvmtiBreakpoint::JvmtiBreakpoint(Method* m_method, jlocation location)</span>
<span class="line-modified"> 201     : _method(m_method), _bci((int)location), _class_holder(NULL) {</span>
<span class="line-modified"> 202   assert(_method != NULL, &quot;No method for breakpoint.&quot;);</span>
<span class="line-modified"> 203   assert(_bci &gt;= 0, &quot;Negative bci for breakpoint.&quot;);</span>
<span class="line-added"> 204   oop class_holder_oop  = _method-&gt;method_holder()-&gt;klass_holder();</span>
<span class="line-added"> 205   _class_holder = OopStorageSet::vm_global()-&gt;allocate();</span>
<span class="line-added"> 206   if (_class_holder == NULL) {</span>
<span class="line-added"> 207     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-added"> 208                           &quot;Cannot create breakpoint oop handle&quot;);</span>
<span class="line-added"> 209   }</span>
<span class="line-added"> 210   NativeAccess&lt;&gt;::oop_store(_class_holder, class_holder_oop);</span>
 211 }
 212 
<span class="line-modified"> 213 JvmtiBreakpoint::~JvmtiBreakpoint() {</span>
<span class="line-modified"> 214   if (_class_holder != NULL) {</span>
<span class="line-modified"> 215     NativeAccess&lt;&gt;::oop_store(_class_holder, (oop)NULL);</span>
<span class="line-modified"> 216     OopStorageSet::vm_global()-&gt;release(_class_holder);</span>
<span class="line-modified"> 217   }</span>










 218 }
 219 
 220 void JvmtiBreakpoint::copy(JvmtiBreakpoint&amp; bp) {
 221   _method   = bp._method;
 222   _bci      = bp._bci;
<span class="line-modified"> 223   _class_holder = OopStorageSet::vm_global()-&gt;allocate();</span>
<span class="line-modified"> 224   if (_class_holder == NULL) {</span>
<span class="line-modified"> 225     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-modified"> 226                           &quot;Cannot create breakpoint oop handle&quot;);</span>
<span class="line-modified"> 227   }</span>
<span class="line-modified"> 228   oop resolved_ch = NativeAccess&lt;&gt;::oop_load(bp._class_holder);</span>
<span class="line-added"> 229   NativeAccess&lt;&gt;::oop_store(_class_holder, resolved_ch);</span>
 230 }
 231 
 232 bool JvmtiBreakpoint::equals(JvmtiBreakpoint&amp; bp) {
 233   return _method   == bp._method
 234     &amp;&amp;   _bci      == bp._bci;
 235 }
 236 






 237 address JvmtiBreakpoint::getBcp() const {
 238   return _method-&gt;bcp_from(_bci);
 239 }
 240 
 241 void JvmtiBreakpoint::each_method_version_do(method_action meth_act) {
 242   ((Method*)_method-&gt;*meth_act)(_bci);
 243 
 244   // add/remove breakpoint to/from versions of the method that are EMCP.
 245   Thread *thread = Thread::current();
 246   InstanceKlass* ik = _method-&gt;method_holder();
 247   Symbol* m_name = _method-&gt;name();
 248   Symbol* m_signature = _method-&gt;signature();
 249 
 250   // search previous versions if they exist
 251   for (InstanceKlass* pv_node = ik-&gt;previous_versions();
 252        pv_node != NULL;
 253        pv_node = pv_node-&gt;previous_versions()) {
 254     Array&lt;Method*&gt;* methods = pv_node-&gt;methods();
 255 
 256     for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
 290 
 291 //
 292 // class VM_ChangeBreakpoints
 293 //
 294 // Modify the Breakpoints data structure at a safepoint
 295 //
 296 
 297 void VM_ChangeBreakpoints::doit() {
 298   switch (_operation) {
 299   case SET_BREAKPOINT:
 300     _breakpoints-&gt;set_at_safepoint(*_bp);
 301     break;
 302   case CLEAR_BREAKPOINT:
 303     _breakpoints-&gt;clear_at_safepoint(*_bp);
 304     break;
 305   default:
 306     assert(false, &quot;Unknown operation&quot;);
 307   }
 308 }
 309 















 310 //
 311 // class JvmtiBreakpoints
 312 //
 313 // a JVMTI internal collection of JvmtiBreakpoint
 314 //
 315 
 316 JvmtiBreakpoints::JvmtiBreakpoints(void listener_fun(void *,address *)) {
 317   _bps.initialize(this,listener_fun);
 318 }
 319 
 320 JvmtiBreakpoints:: ~JvmtiBreakpoints() {}
 321 












 322 void JvmtiBreakpoints::print() {
 323 #ifndef PRODUCT
 324   LogTarget(Trace, jvmti) log;
 325   LogStream log_stream(log);
 326 
 327   int n = _bps.length();
 328   for (int i=0; i&lt;n; i++) {
 329     JvmtiBreakpoint&amp; bp = _bps.at(i);
 330     log_stream.print(&quot;%d: &quot;, i);
 331     bp.print_on(&amp;log_stream);
 332     log_stream.cr();
 333   }
 334 #endif
 335 }
 336 
 337 
 338 void JvmtiBreakpoints::set_at_safepoint(JvmtiBreakpoint&amp; bp) {
 339   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 340 
 341   int i = _bps.find(bp);
</pre>
<hr />
<pre>
 410 address *         JvmtiCurrentBreakpoints::_breakpoint_list    = NULL;
 411 
 412 
 413 JvmtiBreakpoints&amp; JvmtiCurrentBreakpoints::get_jvmti_breakpoints() {
 414   if (_jvmti_breakpoints != NULL) return (*_jvmti_breakpoints);
 415   _jvmti_breakpoints = new JvmtiBreakpoints(listener_fun);
 416   assert(_jvmti_breakpoints != NULL, &quot;_jvmti_breakpoints != NULL&quot;);
 417   return (*_jvmti_breakpoints);
 418 }
 419 
 420 void  JvmtiCurrentBreakpoints::listener_fun(void *this_obj, address *cache) {
 421   JvmtiBreakpoints *this_jvmti = (JvmtiBreakpoints *) this_obj;
 422   assert(this_jvmti != NULL, &quot;this_jvmti != NULL&quot;);
 423 
 424   debug_only(int n = this_jvmti-&gt;length(););
 425   assert(cache[n] == NULL, &quot;cache must be NULL terminated&quot;);
 426 
 427   set_breakpoint_list(cache);
 428 }
 429 



















 430 ///////////////////////////////////////////////////////////////
 431 //
 432 // class VM_GetOrSetLocal
 433 //
 434 
 435 // Constructor for non-object getter
 436 VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type)
 437   : _thread(thread)
 438   , _calling_thread(NULL)
 439   , _depth(depth)
 440   , _index(index)
 441   , _type(type)
 442   , _jvf(NULL)
 443   , _set(false)
 444   , _result(JVMTI_ERROR_NONE)
 445 {
 446 }
 447 
 448 // Constructor for object or non-object setter
 449 VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value)
</pre>
<hr />
<pre>
 495   javaVFrame *jvf = (javaVFrame*)vf;
 496 
 497   if (!vf-&gt;is_java_frame()) {
 498     _result = JVMTI_ERROR_OPAQUE_FRAME;
 499     return NULL;
 500   }
 501   return jvf;
 502 }
 503 
 504 // Check that the klass is assignable to a type with the given signature.
 505 // Another solution could be to use the function Klass::is_subtype_of(type).
 506 // But the type class can be forced to load/initialize eagerly in such a case.
 507 // This may cause unexpected consequences like CFLH or class-init JVMTI events.
 508 // It is better to avoid such a behavior.
 509 bool VM_GetOrSetLocal::is_assignable(const char* ty_sign, Klass* klass, Thread* thread) {
 510   assert(ty_sign != NULL, &quot;type signature must not be NULL&quot;);
 511   assert(thread != NULL, &quot;thread must not be NULL&quot;);
 512   assert(klass != NULL, &quot;klass must not be NULL&quot;);
 513 
 514   int len = (int) strlen(ty_sign);
<span class="line-modified"> 515   if (ty_sign[0] == JVM_SIGNATURE_CLASS &amp;&amp;</span>
<span class="line-added"> 516       ty_sign[len-1] == JVM_SIGNATURE_ENDCLASS) { // Need pure class/interface name</span>
 517     ty_sign++;
 518     len -= 2;
 519   }
<span class="line-modified"> 520   TempNewSymbol ty_sym = SymbolTable::new_symbol(ty_sign, len);</span>
 521   if (klass-&gt;name() == ty_sym) {
 522     return true;
 523   }
 524   // Compare primary supers
 525   int super_depth = klass-&gt;super_depth();
 526   int idx;
 527   for (idx = 0; idx &lt; super_depth; idx++) {
 528     if (klass-&gt;primary_super_of_depth(idx)-&gt;name() == ty_sym) {
 529       return true;
 530     }
 531   }
 532   // Compare secondary supers
 533   const Array&lt;Klass*&gt;* sec_supers = klass-&gt;secondary_supers();
 534   for (idx = 0; idx &lt; sec_supers-&gt;length(); idx++) {
 535     if (((Klass*) sec_supers-&gt;at(idx))-&gt;name() == ty_sym) {
 536       return true;
 537     }
 538   }
 539   return false;
 540 }
</pre>
<hr />
<pre>
 553   }
 554   int signature_idx = -1;
 555   int vf_bci = jvf-&gt;bci();
 556   LocalVariableTableElement* table = method_oop-&gt;localvariable_table_start();
 557   for (int i = 0; i &lt; num_entries; i++) {
 558     int start_bci = table[i].start_bci;
 559     int end_bci = start_bci + table[i].length;
 560 
 561     // Here we assume that locations of LVT entries
 562     // with the same slot number cannot be overlapped
 563     if (_index == (jint) table[i].slot &amp;&amp; start_bci &lt;= vf_bci &amp;&amp; vf_bci &lt;= end_bci) {
 564       signature_idx = (int) table[i].descriptor_cp_index;
 565       break;
 566     }
 567   }
 568   if (signature_idx == -1) {
 569     _result = JVMTI_ERROR_INVALID_SLOT;
 570     return false;       // Incorrect slot index
 571   }
 572   Symbol*   sign_sym  = method_oop-&gt;constants()-&gt;symbol_at(signature_idx);
<span class="line-modified"> 573   BasicType slot_type = Signature::basic_type(sign_sym);</span>

 574 
 575   switch (slot_type) {
 576   case T_BYTE:
 577   case T_SHORT:
 578   case T_CHAR:
 579   case T_BOOLEAN:
 580     slot_type = T_INT;
 581     break;
 582   case T_ARRAY:
 583     slot_type = T_OBJECT;
 584     break;
 585   default:
 586     break;
 587   };
 588   if (_type != slot_type) {
 589     _result = JVMTI_ERROR_TYPE_MISMATCH;
 590     return false;
 591   }
 592 
 593   jobject jobj = _value.l;
 594   if (_set &amp;&amp; slot_type == T_OBJECT &amp;&amp; jobj != NULL) { // NULL reference is allowed
 595     // Check that the jobject class matches the return type signature.
 596     JavaThread* cur_thread = JavaThread::current();
 597     HandleMark hm(cur_thread);
 598 
 599     Handle obj(cur_thread, JNIHandles::resolve_external_guard(jobj));
 600     NULL_CHECK(obj, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
 601     Klass* ob_k = obj-&gt;klass();
 602     NULL_CHECK(ob_k, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
 603 
<span class="line-added"> 604     const char* signature = (const char *) sign_sym-&gt;as_utf8();</span>
 605     if (!is_assignable(signature, ob_k, cur_thread)) {
 606       _result = JVMTI_ERROR_TYPE_MISMATCH;
 607       return false;
 608     }
 609   }
 610   return true;
 611 }
 612 
 613 bool VM_GetOrSetLocal::check_slot_type_no_lvt(javaVFrame* jvf) {
 614   Method* method_oop = jvf-&gt;method();
 615   jint extra_slot = (_type == T_LONG || _type == T_DOUBLE) ? 1 : 0;
 616 
 617   if (_index &lt; 0 || _index + extra_slot &gt;= method_oop-&gt;max_locals()) {
 618     _result = JVMTI_ERROR_INVALID_SLOT;
 619     return false;
 620   }
 621   StackValueCollection *locals = _jvf-&gt;locals();
 622   BasicType slot_type = locals-&gt;at(_index)-&gt;type();
 623 
 624   if (slot_type == T_CONFLICT) {
</pre>
<hr />
<pre>
 631       _result = JVMTI_ERROR_INVALID_SLOT;
 632       return false;
 633     }
 634   }
 635   if (_type != slot_type &amp;&amp; (_type == T_OBJECT || slot_type != T_INT)) {
 636     _result = JVMTI_ERROR_TYPE_MISMATCH;
 637     return false;
 638   }
 639   return true;
 640 }
 641 
 642 static bool can_be_deoptimized(vframe* vf) {
 643   return (vf-&gt;is_compiled_frame() &amp;&amp; vf-&gt;fr().can_be_deoptimized());
 644 }
 645 
 646 bool VM_GetOrSetLocal::doit_prologue() {
 647   _jvf = get_java_vframe();
 648   NULL_CHECK(_jvf, false);
 649 
 650   Method* method_oop = _jvf-&gt;method();
<span class="line-modified"> 651   if (getting_receiver()) {</span>
<span class="line-modified"> 652     if (method_oop-&gt;is_static()) {</span>
<span class="line-modified"> 653       _result = JVMTI_ERROR_INVALID_SLOT;</span>


 654       return false;
 655     }
<span class="line-added"> 656     return true;</span>
<span class="line-added"> 657   }</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659   if (method_oop-&gt;is_native()) {</span>
<span class="line-added"> 660     _result = JVMTI_ERROR_OPAQUE_FRAME;</span>
<span class="line-added"> 661     return false;</span>
 662   }
 663 
<span class="line-added"> 664   if (!check_slot_type_no_lvt(_jvf)) {</span>
<span class="line-added"> 665     return false;</span>
<span class="line-added"> 666   }</span>
 667   if (method_oop-&gt;has_localvariable_table()) {
 668     return check_slot_type_lvt(_jvf);


 669   }
 670   return true;
 671 }
 672 
 673 void VM_GetOrSetLocal::doit() {
 674   InterpreterOopMap oop_mask;
 675   _jvf-&gt;method()-&gt;mask_for(_jvf-&gt;bci(), &amp;oop_mask);
 676   if (oop_mask.is_dead(_index)) {
 677     // The local can be invalid and uninitialized in the scope of current bci
 678     _result = JVMTI_ERROR_INVALID_SLOT;
 679     return;
 680   }
 681   if (_set) {
 682     // Force deoptimization of frame if compiled because it&#39;s
 683     // possible the compiler emitted some locals as constant values,
 684     // meaning they are not mutable.
 685     if (can_be_deoptimized(_jvf)) {
 686 
 687       // Schedule deoptimization so that eventually the local
 688       // update will be written to an interpreter frame.
 689       Deoptimization::deoptimize_frame(_jvf-&gt;thread(), _jvf-&gt;fr().id());
 690 
 691       // Now store a new value for the local which will be applied
 692       // once deoptimization occurs. Note however that while this
 693       // write is deferred until deoptimization actually happens
 694       // can vframe created after this point will have its locals
 695       // reflecting this update so as far as anyone can see the
 696       // write has already taken place.
 697 
 698       // If we are updating an oop then get the oop from the handle
 699       // since the handle will be long gone by the time the deopt
 700       // happens. The oop stored in the deferred local will be
 701       // gc&#39;d on its own.
 702       if (_type == T_OBJECT) {
<span class="line-modified"> 703         _value.l = cast_from_oop&lt;jobject&gt;(JNIHandles::resolve_external_guard(_value.l));</span>
 704       }
 705       // Re-read the vframe so we can see that it is deoptimized
 706       // [ Only need because of assert in update_local() ]
 707       _jvf = get_java_vframe();
 708       ((compiledVFrame*)_jvf)-&gt;update_local(_type, _index, _value);
 709       return;
 710     }
 711     StackValueCollection *locals = _jvf-&gt;locals();
 712     HandleMark hm;
 713 
 714     switch (_type) {
 715       case T_INT:    locals-&gt;set_int_at   (_index, _value.i); break;
 716       case T_LONG:   locals-&gt;set_long_at  (_index, _value.j); break;
 717       case T_FLOAT:  locals-&gt;set_float_at (_index, _value.f); break;
 718       case T_DOUBLE: locals-&gt;set_double_at(_index, _value.d); break;
 719       case T_OBJECT: {
 720         Handle ob_h(Thread::current(), JNIHandles::resolve_external_guard(_value.l));
 721         locals-&gt;set_obj_at (_index, ob_h);
 722         break;
 723       }
</pre>
<hr />
<pre>
 793   return true;
 794 }
 795 
 796 bool JvmtiSuspendControl::resume(JavaThread *java_thread) {
 797   // external suspend should have caught resuming a thread twice
 798   assert(java_thread-&gt;is_being_ext_suspended(), &quot;thread should be suspended&quot;);
 799 
 800   // resume thread
 801   {
 802     // must always grab Threads_lock, see JVM_SuspendThread
 803     MutexLocker ml(Threads_lock);
 804     java_thread-&gt;java_resume();
 805   }
 806 
 807   return true;
 808 }
 809 
 810 
 811 void JvmtiSuspendControl::print() {
 812 #ifndef PRODUCT
<span class="line-added"> 813   ResourceMark rm;</span>
 814   LogStreamHandle(Trace, jvmti) log_stream;
 815   log_stream.print(&quot;Suspended Threads: [&quot;);
 816   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
 817 #ifdef JVMTI_TRACE
 818     const char *name   = JvmtiTrace::safe_get_thread_name(thread);
 819 #else
 820     const char *name   = &quot;&quot;;
 821 #endif /*JVMTI_TRACE */
 822     log_stream.print(&quot;%s(%c &quot;, name, thread-&gt;is_being_ext_suspended() ? &#39;S&#39; : &#39;_&#39;);
 823     if (!thread-&gt;has_last_Java_frame()) {
 824       log_stream.print(&quot;no stack&quot;);
 825     }
 826     log_stream.print(&quot;) &quot;);
 827   }
 828   log_stream.print_cr(&quot;]&quot;);
 829 #endif
 830 }
 831 
 832 JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_load_event(
 833     nmethod* nm) {
 834   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_LOAD);
 835   event._event_data.compiled_method_load = nm;



 836   return event;
 837 }
 838 
 839 JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_unload_event(
<span class="line-modified"> 840     jmethodID id, const void* code) {</span>
 841   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_UNLOAD);

 842   event._event_data.compiled_method_unload.method_id = id;
 843   event._event_data.compiled_method_unload.code_begin = code;






 844   return event;
 845 }
 846 
 847 JvmtiDeferredEvent JvmtiDeferredEvent::dynamic_code_generated_event(
 848       const char* name, const void* code_begin, const void* code_end) {
 849   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_DYNAMIC_CODE_GENERATED);
 850   // Need to make a copy of the name since we don&#39;t know how long
 851   // the event poster will keep it around after we enqueue the
 852   // deferred event and return. strdup() failure is handled in
 853   // the post() routine below.
 854   event._event_data.dynamic_code_generated.name = os::strdup(name);
 855   event._event_data.dynamic_code_generated.code_begin = code_begin;
 856   event._event_data.dynamic_code_generated.code_end = code_end;
 857   return event;
 858 }
 859 
<span class="line-added"> 860 JvmtiDeferredEvent JvmtiDeferredEvent::class_unload_event(const char* name) {</span>
<span class="line-added"> 861   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_CLASS_UNLOAD);</span>
<span class="line-added"> 862   // Need to make a copy of the name since we don&#39;t know how long</span>
<span class="line-added"> 863   // the event poster will keep it around after we enqueue the</span>
<span class="line-added"> 864   // deferred event and return. strdup() failure is handled in</span>
<span class="line-added"> 865   // the post() routine below.</span>
<span class="line-added"> 866   event._event_data.class_unload.name = os::strdup(name);</span>
<span class="line-added"> 867   return event;</span>
<span class="line-added"> 868 }</span>
<span class="line-added"> 869 </span>
 870 void JvmtiDeferredEvent::post() {
<span class="line-modified"> 871   assert(Thread::current()-&gt;is_service_thread(),</span>
 872          &quot;Service thread must post enqueued events&quot;);
 873   switch(_type) {
 874     case TYPE_COMPILED_METHOD_LOAD: {
 875       nmethod* nm = _event_data.compiled_method_load;
 876       JvmtiExport::post_compiled_method_load(nm);


 877       break;
 878     }
 879     case TYPE_COMPILED_METHOD_UNLOAD: {

 880       JvmtiExport::post_compiled_method_unload(
 881         _event_data.compiled_method_unload.method_id,
 882         _event_data.compiled_method_unload.code_begin);


 883       break;
 884     }
 885     case TYPE_DYNAMIC_CODE_GENERATED: {
 886       JvmtiExport::post_dynamic_code_generated_internal(
 887         // if strdup failed give the event a default name
 888         (_event_data.dynamic_code_generated.name == NULL)
 889           ? &quot;unknown_code&quot; : _event_data.dynamic_code_generated.name,
 890         _event_data.dynamic_code_generated.code_begin,
 891         _event_data.dynamic_code_generated.code_end);
 892       if (_event_data.dynamic_code_generated.name != NULL) {
 893         // release our copy
 894         os::free((void *)_event_data.dynamic_code_generated.name);
 895       }
 896       break;
 897     }
<span class="line-added"> 898     case TYPE_CLASS_UNLOAD: {</span>
<span class="line-added"> 899       JvmtiExport::post_class_unload_internal(</span>
<span class="line-added"> 900         // if strdup failed give the event a default name</span>
<span class="line-added"> 901         (_event_data.class_unload.name == NULL)</span>
<span class="line-added"> 902           ? &quot;unknown_class&quot; : _event_data.class_unload.name);</span>
<span class="line-added"> 903       if (_event_data.class_unload.name != NULL) {</span>
<span class="line-added"> 904         // release our copy</span>
<span class="line-added"> 905         os::free((void *)_event_data.class_unload.name);</span>
<span class="line-added"> 906       }</span>
<span class="line-added"> 907       break;</span>
<span class="line-added"> 908     }</span>
 909     default:
 910       ShouldNotReachHere();
 911   }
 912 }
 913 
<span class="line-modified"> 914 void JvmtiDeferredEvent::post_compiled_method_load_event(JvmtiEnv* env) {</span>
<span class="line-modified"> 915   assert(_type == TYPE_COMPILED_METHOD_LOAD, &quot;only user of this method&quot;);</span>
<span class="line-added"> 916   nmethod* nm = _event_data.compiled_method_load;</span>
<span class="line-added"> 917   JvmtiExport::post_compiled_method_load(env, nm);</span>
<span class="line-added"> 918 }</span>
 919 
<span class="line-modified"> 920 void JvmtiDeferredEvent::run_nmethod_entry_barriers() {</span>
<span class="line-modified"> 921   if (_type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-modified"> 922     _event_data.compiled_method_load-&gt;run_nmethod_entry_barrier();</span>
<span class="line-added"> 923   }</span>
<span class="line-added"> 924 }</span>
<span class="line-added"> 925 </span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927 // Keep the nmethod for compiled_method_load from being unloaded.</span>
<span class="line-added"> 928 void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-added"> 929   if (cf != NULL &amp;&amp; _type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-added"> 930     cf-&gt;do_code_blob(_event_data.compiled_method_load);</span>
<span class="line-added"> 931   }</span>
 932 }
 933 
<span class="line-modified"> 934 // The sweeper calls this and marks the nmethods here on the stack so that</span>
<span class="line-modified"> 935 // they cannot be turned into zombies while in the queue.</span>
<span class="line-added"> 936 void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added"> 937   if (cf != NULL &amp;&amp; _type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-added"> 938     cf-&gt;do_code_blob(_event_data.compiled_method_load);</span>
<span class="line-added"> 939   }</span>
<span class="line-added"> 940 }</span>
 941 
<span class="line-added"> 942 </span>
<span class="line-added"> 943 bool JvmtiDeferredEventQueue::has_events() {</span>
<span class="line-added"> 944   // We save the queued events before the live phase and post them when it starts.</span>
<span class="line-added"> 945   // This code could skip saving the events on the queue before the live</span>
<span class="line-added"> 946   // phase and ignore them, but this would change how we do things now.</span>
<span class="line-added"> 947   // Starting the service thread earlier causes this to be called before the live phase begins.</span>
<span class="line-added"> 948   // The events on the queue should all be posted after the live phase so this is an</span>
<span class="line-added"> 949   // ok check.  Before the live phase, DynamicCodeGenerated events are posted directly.</span>
<span class="line-added"> 950   // If we add other types of events to the deferred queue, this could get ugly.</span>
<span class="line-added"> 951   return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE  &amp;&amp; _queue_head != NULL;</span>
<span class="line-added"> 952 }</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954 void JvmtiDeferredEventQueue::enqueue(JvmtiDeferredEvent event) {</span>
 955   // Events get added to the end of the queue (and are pulled off the front).
 956   QueueNode* node = new QueueNode(event);
 957   if (_queue_tail == NULL) {
 958     _queue_tail = _queue_head = node;
 959   } else {
 960     assert(_queue_tail-&gt;next() == NULL, &quot;Must be the last element in the list&quot;);
 961     _queue_tail-&gt;set_next(node);
 962     _queue_tail = node;
 963   }
 964 

 965   assert((_queue_head == NULL) == (_queue_tail == NULL),
 966          &quot;Inconsistent queue markers&quot;);
 967 }
 968 
 969 JvmtiDeferredEvent JvmtiDeferredEventQueue::dequeue() {


 970   assert(_queue_head != NULL, &quot;Nothing to dequeue&quot;);
 971 
 972   if (_queue_head == NULL) {
 973     // Just in case this happens in product; it shouldn&#39;t but let&#39;s not crash
 974     return JvmtiDeferredEvent();
 975   }
 976 
 977   QueueNode* node = _queue_head;
 978   _queue_head = _queue_head-&gt;next();
 979   if (_queue_head == NULL) {
 980     _queue_tail = NULL;
 981   }
 982 
 983   assert((_queue_head == NULL) == (_queue_tail == NULL),
 984          &quot;Inconsistent queue markers&quot;);
 985 
 986   JvmtiDeferredEvent event = node-&gt;event();
 987   delete node;
 988   return event;
 989 }
<span class="line-added"> 990 </span>
<span class="line-added"> 991 void JvmtiDeferredEventQueue::post(JvmtiEnv* env) {</span>
<span class="line-added"> 992   // Post and destroy queue nodes</span>
<span class="line-added"> 993   while (_queue_head != NULL) {</span>
<span class="line-added"> 994      JvmtiDeferredEvent event = dequeue();</span>
<span class="line-added"> 995      event.post_compiled_method_load_event(env);</span>
<span class="line-added"> 996   }</span>
<span class="line-added"> 997 }</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999 void JvmtiDeferredEventQueue::run_nmethod_entry_barriers() {</span>
<span class="line-added">1000   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">1001      node-&gt;event().run_nmethod_entry_barriers();</span>
<span class="line-added">1002   }</span>
<span class="line-added">1003 }</span>
<span class="line-added">1004 </span>
<span class="line-added">1005 </span>
<span class="line-added">1006 void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-added">1007   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">1008      node-&gt;event().oops_do(f, cf);</span>
<span class="line-added">1009   }</span>
<span class="line-added">1010 }</span>
<span class="line-added">1011 </span>
<span class="line-added">1012 void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added">1013   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">1014      node-&gt;event().nmethods_do(cf);</span>
<span class="line-added">1015   }</span>
<span class="line-added">1016 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiH.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiImpl.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
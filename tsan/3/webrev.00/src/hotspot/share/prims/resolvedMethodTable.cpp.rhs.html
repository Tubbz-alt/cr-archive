<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/resolvedMethodTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="line-added"> 28 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/access.inline.hpp&quot;
<a name="3" id="anc3"></a>
 34 #include &quot;oops/method.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 35 #include &quot;oops/oop.inline.hpp&quot;</span>
 36 #include &quot;oops/weakHandle.inline.hpp&quot;
 37 #include &quot;prims/resolvedMethodTable.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added"> 38 #include &quot;runtime/atomic.hpp&quot;</span>
 39 #include &quot;runtime/handles.inline.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added"> 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
<a name="7" id="anc7"></a><span class="line-modified"> 43 #include &quot;runtime/timerTrace.hpp&quot;</span>
<span class="line-added"> 44 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;</span>
<span class="line-added"> 45 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;</span>
 46 #include &quot;utilities/macros.hpp&quot;
 47 
<a name="8" id="anc8"></a><span class="line-added"> 48 // 2^24 is max size</span>
<span class="line-added"> 49 static const size_t END_SIZE = 24;</span>
<span class="line-added"> 50 // If a chain gets to 32 something might be wrong</span>
<span class="line-added"> 51 static const size_t GROW_HINT = 32;</span>
 52 
<a name="9" id="anc9"></a><span class="line-modified"> 53 static const size_t ResolvedMethodTableSizeLog = 10;</span>


 54 
<a name="10" id="anc10"></a><span class="line-modified"> 55 unsigned int method_hash(const Method* method) {</span>
<span class="line-modified"> 56   unsigned int name_hash = method-&gt;name()-&gt;identity_hash();</span>
<span class="line-modified"> 57   unsigned int signature_hash = method-&gt;signature()-&gt;identity_hash();</span>
<span class="line-modified"> 58   return name_hash ^ signature_hash;</span>



 59 }
 60 
<a name="11" id="anc11"></a><span class="line-modified"> 61 typedef ConcurrentHashTable&lt;ResolvedMethodTableConfig,</span>
<span class="line-modified"> 62                             mtClass&gt; ResolvedMethodTableHash;</span>
 63 
<a name="12" id="anc12"></a><span class="line-modified"> 64 class ResolvedMethodTableConfig : public AllStatic {</span>
<span class="line-modified"> 65  private:</span>
<span class="line-modified"> 66  public:</span>
<span class="line-modified"> 67   typedef WeakHandle&lt;vm_resolved_method_table_data&gt; Value;</span>
 68 
<a name="13" id="anc13"></a><span class="line-modified"> 69   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
<span class="line-modified"> 70     oop val_oop = value.peek();</span>
<span class="line-modified"> 71     if (val_oop == NULL) {</span>
<span class="line-modified"> 72       *is_dead = true;</span>
<span class="line-modified"> 73       return 0;</span>







 74     }
<a name="14" id="anc14"></a><span class="line-added"> 75     *is_dead = false;</span>
<span class="line-added"> 76     Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="line-added"> 77     return method_hash(method);</span>
 78   }
<a name="15" id="anc15"></a>

 79 
<a name="16" id="anc16"></a><span class="line-modified"> 80   // We use default allocation/deallocation but counted</span>
<span class="line-modified"> 81   static void* allocate_node(size_t size, Value const&amp; value) {</span>
<span class="line-modified"> 82     ResolvedMethodTable::item_added();</span>
<span class="line-modified"> 83     return AllocateHeap(size, mtClass);</span>
<span class="line-modified"> 84   }</span>
<span class="line-added"> 85   static void free_node(void* memory, Value const&amp; value) {</span>
<span class="line-added"> 86     value.release();</span>
<span class="line-added"> 87     FreeHeap(memory);</span>
<span class="line-added"> 88     ResolvedMethodTable::item_removed();</span>
<span class="line-added"> 89   }</span>
<span class="line-added"> 90 };</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92 static ResolvedMethodTableHash* _local_table           = NULL;</span>
<span class="line-added"> 93 static size_t                   _current_size          = (size_t)1 &lt;&lt; ResolvedMethodTableSizeLog;</span>
 94 
<a name="17" id="anc17"></a><span class="line-added"> 95 volatile bool            ResolvedMethodTable::_has_work              = false;</span>
 96 
<a name="18" id="anc18"></a><span class="line-modified"> 97 volatile size_t          _items_count           = 0;</span>
<span class="line-modified"> 98 volatile size_t          _uncleaned_items_count = 0;</span>
<span class="line-modified"> 99 </span>
<span class="line-modified">100 void ResolvedMethodTable::create_table() {</span>
<span class="line-added">101   _local_table  = new ResolvedMethodTableHash(ResolvedMethodTableSizeLog, END_SIZE, GROW_HINT);</span>
<span class="line-added">102   log_trace(membername, table)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-added">103                                _current_size, ResolvedMethodTableSizeLog);</span>
104 }
105 
<a name="19" id="anc19"></a><span class="line-modified">106 size_t ResolvedMethodTable::table_size() {</span>
<span class="line-modified">107   return (size_t)1 &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="line-added">108 }</span>
109 
<a name="20" id="anc20"></a><span class="line-modified">110 class ResolvedMethodTableLookup : StackObj {</span>
<span class="line-modified">111  private:</span>
<span class="line-added">112   Thread*       _thread;</span>
<span class="line-added">113   uintx         _hash;</span>
<span class="line-added">114   const Method* _method;</span>
<span class="line-added">115   Handle        _found;</span>
116 
<a name="21" id="anc21"></a><span class="line-modified">117  public:</span>
<span class="line-modified">118   ResolvedMethodTableLookup(Thread* thread, uintx hash, const Method* key)</span>
<span class="line-modified">119     : _thread(thread), _hash(hash), _method(key) {</span>
<span class="line-modified">120   }</span>
<span class="line-added">121   uintx get_hash() const {</span>
<span class="line-added">122     return _hash;</span>
123   }
<a name="22" id="anc22"></a><span class="line-added">124   bool equals(WeakHandle&lt;vm_resolved_method_table_data&gt;* value, bool* is_dead) {</span>
<span class="line-added">125     oop val_oop = value-&gt;peek();</span>
<span class="line-added">126     if (val_oop == NULL) {</span>
<span class="line-added">127       // dead oop, mark this hash dead for cleaning</span>
<span class="line-added">128       *is_dead = true;</span>
<span class="line-added">129       return false;</span>
<span class="line-added">130     }</span>
<span class="line-added">131     bool equals = _method == java_lang_invoke_ResolvedMethodName::vmtarget(val_oop);</span>
<span class="line-added">132     if (!equals) {</span>
<span class="line-added">133       return false;</span>
<span class="line-added">134     }</span>
<span class="line-added">135     // Need to resolve weak handle and Handleize through possible safepoint.</span>
<span class="line-added">136     _found = Handle(_thread, value-&gt;resolve());</span>
<span class="line-added">137     return true;</span>
<span class="line-added">138   }</span>
<span class="line-added">139 };</span>
140 
<a name="23" id="anc23"></a>







141 
<a name="24" id="anc24"></a><span class="line-modified">142 class ResolvedMethodGet : public StackObj {</span>
<span class="line-added">143   Thread*       _thread;</span>
<span class="line-added">144   const Method* _method;</span>
<span class="line-added">145   Handle        _return;</span>
<span class="line-added">146 public:</span>
<span class="line-added">147   ResolvedMethodGet(Thread* thread, const Method* method) : _thread(thread), _method(method) {}</span>
<span class="line-added">148   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">149     oop result = val-&gt;resolve();</span>
<span class="line-added">150     assert(result != NULL, &quot;Result should be reachable&quot;);</span>
<span class="line-added">151     _return = Handle(_thread, result);</span>
<span class="line-added">152     log_get();</span>
<span class="line-added">153   }</span>
<span class="line-added">154   oop get_res_oop() {</span>
<span class="line-added">155     return _return();</span>
<span class="line-added">156   }</span>
<span class="line-added">157   void log_get() {</span>
<span class="line-added">158     LogTarget(Trace, membername, table) log;</span>
<span class="line-added">159     if (log.is_enabled()) {</span>
<span class="line-added">160       ResourceMark rm;</span>
<span class="line-added">161       log.print(&quot;ResolvedMethod entry found for %s&quot;,</span>
<span class="line-added">162                 _method-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">163     }</span>
<span class="line-added">164   }</span>
<span class="line-added">165 };</span>
<span class="line-added">166 </span>
<span class="line-added">167 oop ResolvedMethodTable::find_method(const Method* method) {</span>
<span class="line-added">168   Thread* thread = Thread::current();</span>
<span class="line-added">169 </span>
<span class="line-added">170   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="line-added">171   ResolvedMethodGet rmg(thread, method);</span>
<span class="line-added">172   _local_table-&gt;get(thread, lookup, rmg);</span>
<span class="line-added">173 </span>
<span class="line-added">174   return rmg.get_res_oop();</span>
<span class="line-added">175 }</span>
176 
<a name="25" id="anc25"></a><span class="line-modified">177 static void log_insert(const Method* method) {</span>
<span class="line-modified">178   LogTarget(Debug, membername, table) log;</span>
<span class="line-modified">179   if (log.is_enabled()) {</span>
<span class="line-modified">180     ResourceMark rm;</span>
<span class="line-added">181     log.print(&quot;ResolvedMethod entry added for %s&quot;,</span>
<span class="line-added">182               method-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">183   }</span>
184 }
185 
<a name="26" id="anc26"></a><span class="line-modified">186 oop ResolvedMethodTable::add_method(const Method* method, Handle rmethod_name) {</span>
<span class="line-modified">187   Thread* thread = Thread::current();</span>
<span class="line-modified">188 </span>
<span class="line-added">189   ResolvedMethodTableLookup lookup(thread, method_hash(method), method);</span>
<span class="line-added">190   ResolvedMethodGet rmg(thread, method);</span>
191 
<a name="27" id="anc27"></a><span class="line-modified">192   while (true) {</span>
<span class="line-modified">193     if (_local_table-&gt;get(thread, lookup, rmg)) {</span>
<span class="line-modified">194       return rmg.get_res_oop();</span>
<span class="line-modified">195     }</span>
<span class="line-modified">196     WeakHandle&lt;vm_resolved_method_table_data&gt; wh = WeakHandle&lt;vm_resolved_method_table_data&gt;::create(rmethod_name);</span>
<span class="line-modified">197     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.</span>
<span class="line-modified">198     if (_local_table-&gt;insert(thread, lookup, wh)) {</span>
<span class="line-modified">199       log_insert(method);</span>
<span class="line-modified">200       return wh.resolve();</span>

201     }
<a name="28" id="anc28"></a>
202   }
<a name="29" id="anc29"></a><span class="line-modified">203 }</span>
<span class="line-modified">204 </span>
<span class="line-modified">205 void ResolvedMethodTable::item_added() {</span>
<span class="line-modified">206   Atomic::inc(&amp;_items_count);</span>
<span class="line-added">207 }</span>
208 
<a name="30" id="anc30"></a><span class="line-modified">209 void ResolvedMethodTable::item_removed() {</span>
<span class="line-added">210   Atomic::dec(&amp;_items_count);</span>
<span class="line-added">211   log_trace(membername, table) (&quot;ResolvedMethod entry removed&quot;);</span>
212 }
213 
<a name="31" id="anc31"></a><span class="line-modified">214 double ResolvedMethodTable::get_load_factor() {</span>
<span class="line-modified">215   return (double)_items_count/_current_size;</span>
<span class="line-added">216 }</span>
217 
<a name="32" id="anc32"></a><span class="line-modified">218 double ResolvedMethodTable::get_dead_factor() {</span>
<span class="line-modified">219   return (double)_uncleaned_items_count/_current_size;</span>
<span class="line-added">220 }</span>
221 
<a name="33" id="anc33"></a><span class="line-modified">222 static const double PREF_AVG_LIST_LEN = 2.0;</span>
<span class="line-modified">223 // If we have as many dead items as 50% of the number of bucket</span>
<span class="line-modified">224 static const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;</span>
<span class="line-added">225 </span>
<span class="line-added">226 void ResolvedMethodTable::check_concurrent_work() {</span>
<span class="line-added">227   if (_has_work) {</span>
<span class="line-added">228     return;</span>
<span class="line-added">229   }</span>
<span class="line-added">230 </span>
<span class="line-added">231   double load_factor = get_load_factor();</span>
<span class="line-added">232   double dead_factor = get_dead_factor();</span>
<span class="line-added">233   // We should clean/resize if we have more dead than alive,</span>
<span class="line-added">234   // more items than preferred load factor or</span>
<span class="line-added">235   // more dead items than water mark.</span>
<span class="line-added">236   if ((dead_factor &gt; load_factor) ||</span>
<span class="line-added">237       (load_factor &gt; PREF_AVG_LIST_LEN) ||</span>
<span class="line-added">238       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {</span>
<span class="line-added">239     log_debug(membername, table)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,</span>
<span class="line-added">240                                  load_factor, dead_factor);</span>
<span class="line-added">241     trigger_concurrent_work();</span>
<span class="line-added">242   }</span>
<span class="line-added">243 }</span>
<span class="line-added">244 </span>
<span class="line-added">245 void ResolvedMethodTable::trigger_concurrent_work() {</span>
<span class="line-added">246   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">247   _has_work = true;</span>
248   Service_lock-&gt;notify_all();
249 }
250 
<a name="34" id="anc34"></a><span class="line-modified">251 void ResolvedMethodTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-modified">252   _has_work = false;</span>
<span class="line-modified">253   double load_factor = get_load_factor();</span>
<span class="line-modified">254   log_debug(membername, table)(&quot;Concurrent work, live factor: %g&quot;, load_factor);</span>
<span class="line-modified">255   // We prefer growing, since that also removes dead items</span>
<span class="line-modified">256   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {</span>
<span class="line-modified">257     grow(jt);</span>
<span class="line-modified">258   } else {</span>
<span class="line-modified">259     clean_dead_entries(jt);</span>
<span class="line-modified">260   }</span>
<span class="line-modified">261 }</span>
<span class="line-modified">262 </span>
<span class="line-modified">263 void ResolvedMethodTable::grow(JavaThread* jt) {</span>
<span class="line-modified">264   ResolvedMethodTableHash::GrowTask gt(_local_table);</span>
<span class="line-modified">265   if (!gt.prepare(jt)) {</span>
<span class="line-modified">266     return;</span>
<span class="line-modified">267   }</span>
<span class="line-modified">268   log_trace(membername, table)(&quot;Started to grow&quot;);</span>
<span class="line-modified">269   {</span>
<span class="line-modified">270     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="line-modified">271     while (gt.do_task(jt)) {</span>
<span class="line-modified">272       gt.pause(jt);</span>
<span class="line-modified">273       {</span>
<span class="line-added">274         ThreadBlockInVM tbivm(jt);</span>
275       }
<a name="35" id="anc35"></a><span class="line-modified">276       gt.cont(jt);</span>
<span class="line-modified">277     }</span>
<span class="line-added">278   }</span>
<span class="line-added">279   gt.done(jt);</span>
<span class="line-added">280   _current_size = table_size();</span>
<span class="line-added">281   log_info(membername, table)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);</span>
<span class="line-added">282 }</span>
<span class="line-added">283 </span>
<span class="line-added">284 struct ResolvedMethodTableDoDelete : StackObj {</span>
<span class="line-added">285   void operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">286     /* do nothing */</span>
<span class="line-added">287   }</span>
<span class="line-added">288 };</span>
<span class="line-added">289 </span>
<span class="line-added">290 struct ResolvedMethodTableDeleteCheck : StackObj {</span>
<span class="line-added">291   long _count;</span>
<span class="line-added">292   long _item;</span>
<span class="line-added">293   ResolvedMethodTableDeleteCheck() : _count(0), _item(0) {}</span>
<span class="line-added">294   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-added">295     ++_item;</span>
<span class="line-added">296     oop tmp = val-&gt;peek();</span>
<span class="line-added">297     if (tmp == NULL) {</span>
<span class="line-added">298       ++_count;</span>
<span class="line-added">299       return true;</span>
<span class="line-added">300     } else {</span>
<span class="line-added">301       return false;</span>
302     }
303   }
<a name="36" id="anc36"></a><span class="line-modified">304 };</span>
<span class="line-modified">305 </span>
<span class="line-modified">306 void ResolvedMethodTable::clean_dead_entries(JavaThread* jt) {</span>
<span class="line-modified">307   ResolvedMethodTableHash::BulkDeleteTask bdt(_local_table);</span>
<span class="line-modified">308   if (!bdt.prepare(jt)) {</span>
<span class="line-modified">309     return;</span>
<span class="line-modified">310   }</span>
<span class="line-modified">311   ResolvedMethodTableDeleteCheck stdc;</span>
<span class="line-modified">312   ResolvedMethodTableDoDelete stdd;</span>
<span class="line-modified">313   {</span>
<span class="line-modified">314     TraceTime timer(&quot;Clean&quot;, TRACETIME_LOG(Debug, membername, table, perf));</span>
<span class="line-modified">315     while(bdt.do_task(jt, stdc, stdd)) {</span>
<span class="line-modified">316       bdt.pause(jt);</span>
<span class="line-modified">317       {</span>
<span class="line-modified">318         ThreadBlockInVM tbivm(jt);</span>



319       }
<a name="37" id="anc37"></a><span class="line-modified">320       bdt.cont(jt);</span>
321     }
<a name="38" id="anc38"></a><span class="line-added">322     bdt.done(jt);</span>
323   }
<a name="39" id="anc39"></a><span class="line-added">324   log_info(membername, table)(&quot;Cleaned %ld of %ld&quot;, stdc._count, stdc._item);</span>
<span class="line-added">325 }</span>
<span class="line-added">326 void ResolvedMethodTable::reset_dead_counter() {</span>
<span class="line-added">327   _uncleaned_items_count = 0;</span>
<span class="line-added">328 }</span>
<span class="line-added">329 </span>
<span class="line-added">330 void ResolvedMethodTable::inc_dead_counter(size_t ndead) {</span>
<span class="line-added">331   size_t total = Atomic::add(&amp;_uncleaned_items_count, ndead);</span>
<span class="line-added">332   log_trace(membername, table)(</span>
<span class="line-added">333      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,</span>
<span class="line-added">334      _uncleaned_items_count, ndead, total);</span>
<span class="line-added">335 }</span>
<span class="line-added">336 </span>
<span class="line-added">337 // After the parallel walk this method must be called to trigger</span>
<span class="line-added">338 // cleaning. Note it might trigger a resize instead.</span>
<span class="line-added">339 void ResolvedMethodTable::finish_dead_counter() {</span>
<span class="line-added">340   check_concurrent_work();</span>
341 }
<a name="40" id="anc40"></a>
342 
343 #if INCLUDE_JVMTI
<a name="41" id="anc41"></a><span class="line-added">344 class AdjustMethodEntries : public StackObj {</span>
<span class="line-added">345   bool* _trace_name_printed;</span>
<span class="line-added">346 public:</span>
<span class="line-added">347   AdjustMethodEntries(bool* trace_name_printed) : _trace_name_printed(trace_name_printed) {};</span>
<span class="line-added">348   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* entry) {</span>
<span class="line-added">349     oop mem_name = entry-&gt;peek();</span>
<span class="line-added">350     if (mem_name == NULL) {</span>
<span class="line-added">351       // Removed</span>
<span class="line-added">352       return true;</span>
<span class="line-added">353     }</span>
<span class="line-added">354 </span>
<span class="line-added">355     Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);</span>
<span class="line-added">356 </span>
<span class="line-added">357     if (old_method-&gt;is_old()) {</span>
<span class="line-added">358 </span>
<span class="line-added">359       Method* new_method = (old_method-&gt;is_deleted()) ?</span>
<span class="line-added">360                             Universe::throw_no_such_method_error() :</span>
<span class="line-added">361                             old_method-&gt;get_new_method();</span>
<span class="line-added">362       java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, new_method);</span>
<span class="line-added">363 </span>
<span class="line-added">364       ResourceMark rm;</span>
<span class="line-added">365       if (!(*_trace_name_printed)) {</span>
<span class="line-added">366         log_info(redefine, class, update)(&quot;adjust: name=%s&quot;, old_method-&gt;method_holder()-&gt;external_name());</span>
<span class="line-added">367          *_trace_name_printed = true;</span>
<span class="line-added">368       }</span>
<span class="line-added">369       log_debug(redefine, class, update, constantpool)</span>
<span class="line-added">370         (&quot;ResolvedMethod method update: %s(%s)&quot;,</span>
<span class="line-added">371          new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());</span>
<span class="line-added">372     }</span>
<span class="line-added">373 </span>
<span class="line-added">374     return true;</span>
<span class="line-added">375   }</span>
<span class="line-added">376 };</span>
<span class="line-added">377 </span>
378 // It is called at safepoint only for RedefineClasses
379 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
380   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
381   // For each entry in RMT, change to new method
<a name="42" id="anc42"></a><span class="line-modified">382   AdjustMethodEntries adjust(trace_name_printed);</span>
<span class="line-modified">383   _local_table-&gt;do_safepoint_scan(adjust);</span>
<span class="line-modified">384 }</span>
<span class="line-modified">385 #endif // INCLUDE_JVMTI</span>
<span class="line-modified">386 </span>
<span class="line-modified">387 // Verification</span>
<span class="line-modified">388 class VerifyResolvedMethod : StackObj {</span>
<span class="line-modified">389  public:</span>
<span class="line-modified">390   bool operator()(WeakHandle&lt;vm_resolved_method_table_data&gt;* val) {</span>
<span class="line-modified">391     oop obj = val-&gt;peek();</span>
<span class="line-modified">392     if (obj != NULL) {</span>
<span class="line-modified">393       Method* method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(obj);</span>
<span class="line-modified">394       guarantee(method-&gt;is_method(), &quot;Must be&quot;);</span>
<span class="line-modified">395       guarantee(!method-&gt;is_old(), &quot;Must be&quot;);</span>














396     }
<a name="43" id="anc43"></a><span class="line-added">397     return true;</span>
<span class="line-added">398   };</span>
<span class="line-added">399 };</span>
<span class="line-added">400 </span>
<span class="line-added">401 size_t ResolvedMethodTable::items_count() {</span>
<span class="line-added">402   return _items_count;</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
<span class="line-added">405 void ResolvedMethodTable::verify() {</span>
<span class="line-added">406   VerifyResolvedMethod vcs;</span>
<span class="line-added">407   if (!_local_table-&gt;try_scan(Thread::current(), vcs)) {</span>
<span class="line-added">408     log_info(membername, table)(&quot;verify unavailable at this moment&quot;);</span>
409   }
410 }
<a name="44" id="anc44"></a>
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
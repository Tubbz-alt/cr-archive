diff a/src/hotspot/share/prims/jvmtiExport.hpp b/src/hotspot/share/prims/jvmtiExport.hpp
--- a/src/hotspot/share/prims/jvmtiExport.hpp
+++ b/src/hotspot/share/prims/jvmtiExport.hpp
@@ -89,10 +89,11 @@
   JVMTI_SUPPORT_FLAG(can_post_method_exit)
   JVMTI_SUPPORT_FLAG(can_pop_frame)
   JVMTI_SUPPORT_FLAG(can_force_early_return)
 
   JVMTI_SUPPORT_FLAG(early_vmstart_recorded)
+  JVMTI_SUPPORT_FLAG(can_get_owned_monitor_info) // includes can_get_owned_monitor_stack_depth_info
 
   friend class JvmtiEventControllerPrivate;  // should only modify these flags
   JVMTI_SUPPORT_FLAG(should_post_single_step)
   JVMTI_SUPPORT_FLAG(should_post_field_access)
   JVMTI_SUPPORT_FLAG(should_post_field_modification)
@@ -157,30 +158,28 @@
   // posts a DynamicCodeGenerated event (internal/private implementation).
   // The public post_dynamic_code_generated* functions make use of the
   // internal implementation.  Also called from JvmtiDeferredEvent::post()
   static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
 
+  static void post_class_unload_internal(const char *name) NOT_JVMTI_RETURN;
  private:
 
   // GenerateEvents support to allow posting of CompiledMethodLoad and
   // DynamicCodeGenerated events for a given environment.
   friend class JvmtiCodeBlobEvents;
 
-  static void post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,
-                                        const void *code_begin, const jint map_length,
-                                        const jvmtiAddrLocationMap* map) NOT_JVMTI_RETURN;
   static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
                                           const void *code_end) NOT_JVMTI_RETURN;
 
   // This flag indicates whether RedefineClasses() has ever redefined
   // one or more classes during the lifetime of the VM. The flag should
   // only be set by the friend class and can be queried by other sub
   // systems as needed to relax invariant checks.
-  static bool _has_redefined_a_class;
+  static uint64_t _redefinition_count;
   friend class VM_RedefineClasses;
-  inline static void set_has_redefined_a_class() {
-    JVMTI_ONLY(_has_redefined_a_class = true;)
+  inline static void increment_redefinition_count() {
+    JVMTI_ONLY(_redefinition_count++;)
   }
   // Flag to indicate if the compiler has recorded all dependencies. When the
   // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
   // records all dependencies from startup. However if the capability is first
   // enabled some time later then the dependencies recorded by the compiler
@@ -188,14 +187,20 @@
   // dependency information is complete or not.
   static bool _all_dependencies_are_recorded;
 
  public:
   inline static bool has_redefined_a_class() {
-    JVMTI_ONLY(return _has_redefined_a_class);
+    JVMTI_ONLY(return _redefinition_count != 0);
     NOT_JVMTI(return false);
   }
 
+  // Only set in safepoint, so no memory ordering needed.
+  inline static uint64_t redefinition_count() {
+    JVMTI_ONLY(return _redefinition_count);
+    NOT_JVMTI(return 0);
+  }
+
   inline static bool all_dependencies_are_recorded() {
     return _all_dependencies_are_recorded;
   }
 
   inline static void set_all_dependencies_are_recorded(bool on) {
@@ -334,10 +339,11 @@
   static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
                                         Handle h_protection_domain,
                                         unsigned char **data_ptr, unsigned char **end_ptr,
                                         JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
   static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;
+  static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;
   static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
   static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
 
   // used to post a CompiledMethodUnload event
   static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
@@ -388,11 +394,10 @@
   static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
   static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
 
   static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
   static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;
-  static void gc_epilogue() NOT_JVMTI_RETURN;
 
   static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
 
 #if INCLUDE_SERVICES
   // attach support
@@ -420,11 +425,11 @@
   address _code_end;
 
  public:
   JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
     assert(name != NULL, "all code blobs must be named");
-    strncpy(_name, name, sizeof(_name));
+    strncpy(_name, name, sizeof(_name) - 1);
     _name[sizeof(_name)-1] = '\0';
     _code_begin = code_begin;
     _code_end = code_end;
   }
   char* name()                  { return _name; }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiImpl.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiH.xsl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiImpl.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,11 ***</span>
<span class="line-new-header">--- 21,15 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">+ #include &quot;code/nmethod.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/oopStorage.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,11 ***</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiAgentThread.hpp&quot;
  #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  #include &quot;prims/jvmtiImpl.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
<span class="line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
<span class="line-new-header">--- 39,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,28 ***</span>
    GrowableElement *new_e = e-&gt;clone();
    _elements-&gt;append(new_e);
    recache();
  }
  
<span class="line-removed">- // insert a copy of the element using lessthan()</span>
<span class="line-removed">- void GrowableCache::insert(GrowableElement* e) {</span>
<span class="line-removed">-   GrowableElement *new_e = e-&gt;clone();</span>
<span class="line-removed">-   _elements-&gt;append(new_e);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int n = length()-2;</span>
<span class="line-removed">-   for (int i=n; i&gt;=0; i--) {</span>
<span class="line-removed">-     GrowableElement *e1 = _elements-&gt;at(i);</span>
<span class="line-removed">-     GrowableElement *e2 = _elements-&gt;at(i+1);</span>
<span class="line-removed">-     if (e2-&gt;lessThan(e1)) {</span>
<span class="line-removed">-       _elements-&gt;at_put(i+1, e1);</span>
<span class="line-removed">-       _elements-&gt;at_put(i,   e2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   recache();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // remove the element at index
  void GrowableCache::remove (int index) {
    GrowableElement *e = _elements-&gt;at(index);
    assert(e != NULL, &quot;e != NULL&quot;);
    _elements-&gt;remove(e);
<span class="line-new-header">--- 171,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,82 ***</span>
    }
    _elements-&gt;clear();
    recache();
  }
  
<span class="line-removed">- void GrowableCache::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   int len = _elements-&gt;length();</span>
<span class="line-removed">-   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed">-     GrowableElement *e = _elements-&gt;at(i);</span>
<span class="line-removed">-     e-&gt;oops_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void GrowableCache::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">-   int len = _elements-&gt;length();</span>
<span class="line-removed">-   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed">-     GrowableElement *e = _elements-&gt;at(i);</span>
<span class="line-removed">-     e-&gt;metadata_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void GrowableCache::gc_epilogue() {</span>
<span class="line-removed">-   int len = _elements-&gt;length();</span>
<span class="line-removed">-   for (int i=0; i&lt;len; i++) {</span>
<span class="line-removed">-     _cache[i] = _elements-&gt;at(i)-&gt;getCacheValue();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //
  // class JvmtiBreakpoint
  //
  
<span class="line-modified">! JvmtiBreakpoint::JvmtiBreakpoint() {</span>
<span class="line-modified">!   _method = NULL;</span>
<span class="line-modified">!   _bci    = 0;</span>
<span class="line-modified">!   _class_holder = NULL;</span>
  }
  
<span class="line-modified">! JvmtiBreakpoint::JvmtiBreakpoint(Method* m_method, jlocation location) {</span>
<span class="line-modified">!   _method        = m_method;</span>
<span class="line-modified">!   _class_holder  = _method-&gt;method_holder()-&gt;klass_holder();</span>
<span class="line-modified">! #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-modified">!   // _class_holder can&#39;t be wrapped in a Handle, because JvmtiBreakpoints are</span>
<span class="line-removed">-   // sometimes allocated on the heap.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // The code handling JvmtiBreakpoints allocated on the stack can&#39;t be</span>
<span class="line-removed">-   // interrupted by a GC until _class_holder is reachable by the GC via the</span>
<span class="line-removed">-   // oops_do method.</span>
<span class="line-removed">-   Thread::current()-&gt;allow_unhandled_oop(&amp;_class_holder);</span>
<span class="line-removed">- #endif // CHECK_UNHANDLED_OOPS</span>
<span class="line-removed">-   assert(_method != NULL, &quot;_method != NULL&quot;);</span>
<span class="line-removed">-   _bci           = (int) location;</span>
<span class="line-removed">-   assert(_bci &gt;= 0, &quot;_bci &gt;= 0&quot;);</span>
  }
  
  void JvmtiBreakpoint::copy(JvmtiBreakpoint&amp; bp) {
    _method   = bp._method;
    _bci      = bp._bci;
<span class="line-modified">!   _class_holder = bp._class_holder;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool JvmtiBreakpoint::lessThan(JvmtiBreakpoint&amp; bp) {</span>
<span class="line-modified">!   Unimplemented();</span>
<span class="line-modified">!   return false;</span>
  }
  
  bool JvmtiBreakpoint::equals(JvmtiBreakpoint&amp; bp) {
    return _method   == bp._method
      &amp;&amp;   _bci      == bp._bci;
  }
  
<span class="line-removed">- bool JvmtiBreakpoint::is_valid() {</span>
<span class="line-removed">-   // class loader can be NULL</span>
<span class="line-removed">-   return _method != NULL &amp;&amp;</span>
<span class="line-removed">-          _bci &gt;= 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  address JvmtiBreakpoint::getBcp() const {
    return _method-&gt;bcp_from(_bci);
  }
  
  void JvmtiBreakpoint::each_method_version_do(method_action meth_act) {
<span class="line-new-header">--- 191,51 ---</span>
    }
    _elements-&gt;clear();
    recache();
  }
  
  //
  // class JvmtiBreakpoint
  //
  
<span class="line-modified">! JvmtiBreakpoint::JvmtiBreakpoint(Method* m_method, jlocation location)</span>
<span class="line-modified">!     : _method(m_method), _bci((int)location), _class_holder(NULL) {</span>
<span class="line-modified">!   assert(_method != NULL, &quot;No method for breakpoint.&quot;);</span>
<span class="line-modified">!   assert(_bci &gt;= 0, &quot;Negative bci for breakpoint.&quot;);</span>
<span class="line-added">+   oop class_holder_oop  = _method-&gt;method_holder()-&gt;klass_holder();</span>
<span class="line-added">+   _class_holder = OopStorageSet::vm_global()-&gt;allocate();</span>
<span class="line-added">+   if (_class_holder == NULL) {</span>
<span class="line-added">+     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-added">+                           &quot;Cannot create breakpoint oop handle&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   NativeAccess&lt;&gt;::oop_store(_class_holder, class_holder_oop);</span>
  }
  
<span class="line-modified">! JvmtiBreakpoint::~JvmtiBreakpoint() {</span>
<span class="line-modified">!   if (_class_holder != NULL) {</span>
<span class="line-modified">!     NativeAccess&lt;&gt;::oop_store(_class_holder, (oop)NULL);</span>
<span class="line-modified">!     OopStorageSet::vm_global()-&gt;release(_class_holder);</span>
<span class="line-modified">!   }</span>
  }
  
  void JvmtiBreakpoint::copy(JvmtiBreakpoint&amp; bp) {
    _method   = bp._method;
    _bci      = bp._bci;
<span class="line-modified">!   _class_holder = OopStorageSet::vm_global()-&gt;allocate();</span>
<span class="line-modified">!   if (_class_holder == NULL) {</span>
<span class="line-modified">!     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-modified">!                           &quot;Cannot create breakpoint oop handle&quot;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   oop resolved_ch = NativeAccess&lt;&gt;::oop_load(bp._class_holder);</span>
<span class="line-added">+   NativeAccess&lt;&gt;::oop_store(_class_holder, resolved_ch);</span>
  }
  
  bool JvmtiBreakpoint::equals(JvmtiBreakpoint&amp; bp) {
    return _method   == bp._method
      &amp;&amp;   _bci      == bp._bci;
  }
  
  address JvmtiBreakpoint::getBcp() const {
    return _method-&gt;bcp_from(_bci);
  }
  
  void JvmtiBreakpoint::each_method_version_do(method_action meth_act) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,25 ***</span>
    default:
      assert(false, &quot;Unknown operation&quot;);
    }
  }
  
<span class="line-removed">- void VM_ChangeBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   // The JvmtiBreakpoints in _breakpoints will be visited via</span>
<span class="line-removed">-   // JvmtiExport::oops_do.</span>
<span class="line-removed">-   if (_bp != NULL) {</span>
<span class="line-removed">-     _bp-&gt;oops_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void VM_ChangeBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">-   // Walk metadata in breakpoints to keep from being deallocated with RedefineClasses</span>
<span class="line-removed">-   if (_bp != NULL) {</span>
<span class="line-removed">-     _bp-&gt;metadata_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //
  // class JvmtiBreakpoints
  //
  // a JVMTI internal collection of JvmtiBreakpoint
  //
<span class="line-new-header">--- 305,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,22 ***</span>
    _bps.initialize(this,listener_fun);
  }
  
  JvmtiBreakpoints:: ~JvmtiBreakpoints() {}
  
<span class="line-removed">- void  JvmtiBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   _bps.oops_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void  JvmtiBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">-   _bps.metadata_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JvmtiBreakpoints::gc_epilogue() {</span>
<span class="line-removed">-   _bps.gc_epilogue();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JvmtiBreakpoints::print() {
  #ifndef PRODUCT
    LogTarget(Trace, jvmti) log;
    LogStream log_stream(log);
  
<span class="line-new-header">--- 317,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,29 ***</span>
    assert(cache[n] == NULL, &quot;cache must be NULL terminated&quot;);
  
    set_breakpoint_list(cache);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- void JvmtiCurrentBreakpoints::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed">-     _jvmti_breakpoints-&gt;oops_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JvmtiCurrentBreakpoints::metadata_do(void f(Metadata*)) {</span>
<span class="line-removed">-   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed">-     _jvmti_breakpoints-&gt;metadata_do(f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JvmtiCurrentBreakpoints::gc_epilogue() {</span>
<span class="line-removed">-   if (_jvmti_breakpoints != NULL) {</span>
<span class="line-removed">-     _jvmti_breakpoints-&gt;gc_epilogue();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  ///////////////////////////////////////////////////////////////
  //
  // class VM_GetOrSetLocal
  //
  
<span class="line-new-header">--- 425,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,15 ***</span>
    assert(ty_sign != NULL, &quot;type signature must not be NULL&quot;);
    assert(thread != NULL, &quot;thread must not be NULL&quot;);
    assert(klass != NULL, &quot;klass must not be NULL&quot;);
  
    int len = (int) strlen(ty_sign);
<span class="line-modified">!   if (ty_sign[0] == &#39;L&#39; &amp;&amp; ty_sign[len-1] == &#39;;&#39;) { // Need pure class/interface name</span>
      ty_sign++;
      len -= 2;
    }
<span class="line-modified">!   TempNewSymbol ty_sym = SymbolTable::new_symbol(ty_sign, len, thread);</span>
    if (klass-&gt;name() == ty_sym) {
      return true;
    }
    // Compare primary supers
    int super_depth = klass-&gt;super_depth();
<span class="line-new-header">--- 510,16 ---</span>
    assert(ty_sign != NULL, &quot;type signature must not be NULL&quot;);
    assert(thread != NULL, &quot;thread must not be NULL&quot;);
    assert(klass != NULL, &quot;klass must not be NULL&quot;);
  
    int len = (int) strlen(ty_sign);
<span class="line-modified">!   if (ty_sign[0] == JVM_SIGNATURE_CLASS &amp;&amp;</span>
<span class="line-added">+       ty_sign[len-1] == JVM_SIGNATURE_ENDCLASS) { // Need pure class/interface name</span>
      ty_sign++;
      len -= 2;
    }
<span class="line-modified">!   TempNewSymbol ty_sym = SymbolTable::new_symbol(ty_sign, len);</span>
    if (klass-&gt;name() == ty_sym) {
      return true;
    }
    // Compare primary supers
    int super_depth = klass-&gt;super_depth();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,12 ***</span>
    if (signature_idx == -1) {
      _result = JVMTI_ERROR_INVALID_SLOT;
      return false;       // Incorrect slot index
    }
    Symbol*   sign_sym  = method_oop-&gt;constants()-&gt;symbol_at(signature_idx);
<span class="line-modified">!   const char* signature = (const char *) sign_sym-&gt;as_utf8();</span>
<span class="line-removed">-   BasicType slot_type = char2type(signature[0]);</span>
  
    switch (slot_type) {
    case T_BYTE:
    case T_SHORT:
    case T_CHAR:
<span class="line-new-header">--- 568,11 ---</span>
    if (signature_idx == -1) {
      _result = JVMTI_ERROR_INVALID_SLOT;
      return false;       // Incorrect slot index
    }
    Symbol*   sign_sym  = method_oop-&gt;constants()-&gt;symbol_at(signature_idx);
<span class="line-modified">!   BasicType slot_type = Signature::basic_type(sign_sym);</span>
  
    switch (slot_type) {
    case T_BYTE:
    case T_SHORT:
    case T_CHAR:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,10 ***</span>
<span class="line-new-header">--- 599,11 ---</span>
      Handle obj(cur_thread, JNIHandles::resolve_external_guard(jobj));
      NULL_CHECK(obj, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
      Klass* ob_k = obj-&gt;klass();
      NULL_CHECK(ob_k, (_result = JVMTI_ERROR_INVALID_OBJECT, false));
  
<span class="line-added">+     const char* signature = (const char *) sign_sym-&gt;as_utf8();</span>
      if (!is_assignable(signature, ob_k, cur_thread)) {
        _result = JVMTI_ERROR_TYPE_MISMATCH;
        return false;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,23 ***</span>
  bool VM_GetOrSetLocal::doit_prologue() {
    _jvf = get_java_vframe();
    NULL_CHECK(_jvf, false);
  
    Method* method_oop = _jvf-&gt;method();
<span class="line-modified">!   if (method_oop-&gt;is_native()) {</span>
<span class="line-modified">!     if (getting_receiver() &amp;&amp; !method_oop-&gt;is_static()) {</span>
<span class="line-modified">!       return true;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       _result = JVMTI_ERROR_OPAQUE_FRAME;</span>
        return false;
      }
    }
  
    if (method_oop-&gt;has_localvariable_table()) {
      return check_slot_type_lvt(_jvf);
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return check_slot_type_no_lvt(_jvf);</span>
    }
    return true;
  }
  
  void VM_GetOrSetLocal::doit() {
<span class="line-new-header">--- 646,28 ---</span>
  bool VM_GetOrSetLocal::doit_prologue() {
    _jvf = get_java_vframe();
    NULL_CHECK(_jvf, false);
  
    Method* method_oop = _jvf-&gt;method();
<span class="line-modified">!   if (getting_receiver()) {</span>
<span class="line-modified">!     if (method_oop-&gt;is_static()) {</span>
<span class="line-modified">!       _result = JVMTI_ERROR_INVALID_SLOT;</span>
        return false;
      }
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (method_oop-&gt;is_native()) {</span>
<span class="line-added">+     _result = JVMTI_ERROR_OPAQUE_FRAME;</span>
<span class="line-added">+     return false;</span>
    }
  
<span class="line-added">+   if (!check_slot_type_no_lvt(_jvf)) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
    if (method_oop-&gt;has_localvariable_table()) {
      return check_slot_type_lvt(_jvf);
    }
    return true;
  }
  
  void VM_GetOrSetLocal::doit() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,11 ***</span>
        // If we are updating an oop then get the oop from the handle
        // since the handle will be long gone by the time the deopt
        // happens. The oop stored in the deferred local will be
        // gc&#39;d on its own.
        if (_type == T_OBJECT) {
<span class="line-modified">!         _value.l = (jobject) (JNIHandles::resolve_external_guard(_value.l));</span>
        }
        // Re-read the vframe so we can see that it is deoptimized
        // [ Only need because of assert in update_local() ]
        _jvf = get_java_vframe();
        ((compiledVFrame*)_jvf)-&gt;update_local(_type, _index, _value);
<span class="line-new-header">--- 698,11 ---</span>
        // If we are updating an oop then get the oop from the handle
        // since the handle will be long gone by the time the deopt
        // happens. The oop stored in the deferred local will be
        // gc&#39;d on its own.
        if (_type == T_OBJECT) {
<span class="line-modified">!         _value.l = cast_from_oop&lt;jobject&gt;(JNIHandles::resolve_external_guard(_value.l));</span>
        }
        // Re-read the vframe so we can see that it is deoptimized
        // [ Only need because of assert in update_local() ]
        _jvf = get_java_vframe();
        ((compiledVFrame*)_jvf)-&gt;update_local(_type, _index, _value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,10 ***</span>
<span class="line-new-header">--- 808,11 ---</span>
  }
  
  
  void JvmtiSuspendControl::print() {
  #ifndef PRODUCT
<span class="line-added">+   ResourceMark rm;</span>
    LogStreamHandle(Trace, jvmti) log_stream;
    log_stream.print(&quot;Suspended Threads: [&quot;);
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
  #ifdef JVMTI_TRACE
      const char *name   = JvmtiTrace::safe_get_thread_name(thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,28 ***</span>
  
  JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_load_event(
      nmethod* nm) {
    JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_LOAD);
    event._event_data.compiled_method_load = nm;
<span class="line-removed">-   // Keep the nmethod alive until the ServiceThread can process</span>
<span class="line-removed">-   // this deferred event.</span>
<span class="line-removed">-   nmethodLocker::lock_nmethod(nm);</span>
    return event;
  }
  
  JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_unload_event(
<span class="line-modified">!     nmethod* nm, jmethodID id, const void* code) {</span>
    JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_UNLOAD);
<span class="line-removed">-   event._event_data.compiled_method_unload.nm = nm;</span>
    event._event_data.compiled_method_unload.method_id = id;
    event._event_data.compiled_method_unload.code_begin = code;
<span class="line-removed">-   // Keep the nmethod alive until the ServiceThread can process</span>
<span class="line-removed">-   // this deferred event. This will keep the memory for the</span>
<span class="line-removed">-   // generated code from being reused too early. We pass</span>
<span class="line-removed">-   // zombie_ok == true here so that our nmethod that was just</span>
<span class="line-removed">-   // made into a zombie can be locked.</span>
<span class="line-removed">-   nmethodLocker::lock_nmethod(nm, true /* zombie_ok */);</span>
    return event;
  }
  
  JvmtiDeferredEvent JvmtiDeferredEvent::dynamic_code_generated_event(
        const char* name, const void* code_begin, const void* code_end) {
<span class="line-new-header">--- 831,18 ---</span>
  
  JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_load_event(
      nmethod* nm) {
    JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_LOAD);
    event._event_data.compiled_method_load = nm;
    return event;
  }
  
  JvmtiDeferredEvent JvmtiDeferredEvent::compiled_method_unload_event(
<span class="line-modified">!     jmethodID id, const void* code) {</span>
    JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_COMPILED_METHOD_UNLOAD);
    event._event_data.compiled_method_unload.method_id = id;
    event._event_data.compiled_method_unload.code_begin = code;
    return event;
  }
  
  JvmtiDeferredEvent JvmtiDeferredEvent::dynamic_code_generated_event(
        const char* name, const void* code_begin, const void* code_end) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 950,28 ***</span>
    event._event_data.dynamic_code_generated.code_begin = code_begin;
    event._event_data.dynamic_code_generated.code_end = code_end;
    return event;
  }
  
  void JvmtiDeferredEvent::post() {
<span class="line-modified">!   assert(ServiceThread::is_service_thread(Thread::current()),</span>
           &quot;Service thread must post enqueued events&quot;);
    switch(_type) {
      case TYPE_COMPILED_METHOD_LOAD: {
        nmethod* nm = _event_data.compiled_method_load;
        JvmtiExport::post_compiled_method_load(nm);
<span class="line-removed">-       // done with the deferred event so unlock the nmethod</span>
<span class="line-removed">-       nmethodLocker::unlock_nmethod(nm);</span>
        break;
      }
      case TYPE_COMPILED_METHOD_UNLOAD: {
<span class="line-removed">-       nmethod* nm = _event_data.compiled_method_unload.nm;</span>
        JvmtiExport::post_compiled_method_unload(
          _event_data.compiled_method_unload.method_id,
          _event_data.compiled_method_unload.code_begin);
<span class="line-removed">-       // done with the deferred event so unlock the nmethod</span>
<span class="line-removed">-       nmethodLocker::unlock_nmethod(nm);</span>
        break;
      }
      case TYPE_DYNAMIC_CODE_GENERATED: {
        JvmtiExport::post_dynamic_code_generated_internal(
          // if strdup failed give the event a default name
<span class="line-new-header">--- 855,33 ---</span>
    event._event_data.dynamic_code_generated.code_begin = code_begin;
    event._event_data.dynamic_code_generated.code_end = code_end;
    return event;
  }
  
<span class="line-added">+ JvmtiDeferredEvent JvmtiDeferredEvent::class_unload_event(const char* name) {</span>
<span class="line-added">+   JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_CLASS_UNLOAD);</span>
<span class="line-added">+   // Need to make a copy of the name since we don&#39;t know how long</span>
<span class="line-added">+   // the event poster will keep it around after we enqueue the</span>
<span class="line-added">+   // deferred event and return. strdup() failure is handled in</span>
<span class="line-added">+   // the post() routine below.</span>
<span class="line-added">+   event._event_data.class_unload.name = os::strdup(name);</span>
<span class="line-added">+   return event;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JvmtiDeferredEvent::post() {
<span class="line-modified">!   assert(Thread::current()-&gt;is_service_thread(),</span>
           &quot;Service thread must post enqueued events&quot;);
    switch(_type) {
      case TYPE_COMPILED_METHOD_LOAD: {
        nmethod* nm = _event_data.compiled_method_load;
        JvmtiExport::post_compiled_method_load(nm);
        break;
      }
      case TYPE_COMPILED_METHOD_UNLOAD: {
        JvmtiExport::post_compiled_method_unload(
          _event_data.compiled_method_unload.method_id,
          _event_data.compiled_method_unload.code_begin);
        break;
      }
      case TYPE_DYNAMIC_CODE_GENERATED: {
        JvmtiExport::post_dynamic_code_generated_internal(
          // if strdup failed give the event a default name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,44 ***</span>
          // release our copy
          os::free((void *)_event_data.dynamic_code_generated.name);
        }
        break;
      }
      default:
        ShouldNotReachHere();
    }
  }
  
<span class="line-modified">! JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_tail = NULL;</span>
<span class="line-modified">! JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_head = NULL;</span>
  
<span class="line-modified">! bool JvmtiDeferredEventQueue::has_events() {</span>
<span class="line-modified">!   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>
<span class="line-modified">!   return _queue_head != NULL;</span>
  }
  
<span class="line-modified">! void JvmtiDeferredEventQueue::enqueue(const JvmtiDeferredEvent&amp; event) {</span>
<span class="line-modified">!   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>
  
    // Events get added to the end of the queue (and are pulled off the front).
    QueueNode* node = new QueueNode(event);
    if (_queue_tail == NULL) {
      _queue_tail = _queue_head = node;
    } else {
      assert(_queue_tail-&gt;next() == NULL, &quot;Must be the last element in the list&quot;);
      _queue_tail-&gt;set_next(node);
      _queue_tail = node;
    }
  
<span class="line-removed">-   Service_lock-&gt;notify_all();</span>
    assert((_queue_head == NULL) == (_queue_tail == NULL),
           &quot;Inconsistent queue markers&quot;);
  }
  
  JvmtiDeferredEvent JvmtiDeferredEventQueue::dequeue() {
<span class="line-removed">-   assert(Service_lock-&gt;owned_by_self(), &quot;Must own Service_lock&quot;);</span>
<span class="line-removed">- </span>
    assert(_queue_head != NULL, &quot;Nothing to dequeue&quot;);
  
    if (_queue_head == NULL) {
      // Just in case this happens in product; it shouldn&#39;t but let&#39;s not crash
      return JvmtiDeferredEvent();
<span class="line-new-header">--- 893,82 ---</span>
          // release our copy
          os::free((void *)_event_data.dynamic_code_generated.name);
        }
        break;
      }
<span class="line-added">+     case TYPE_CLASS_UNLOAD: {</span>
<span class="line-added">+       JvmtiExport::post_class_unload_internal(</span>
<span class="line-added">+         // if strdup failed give the event a default name</span>
<span class="line-added">+         (_event_data.class_unload.name == NULL)</span>
<span class="line-added">+           ? &quot;unknown_class&quot; : _event_data.class_unload.name);</span>
<span class="line-added">+       if (_event_data.class_unload.name != NULL) {</span>
<span class="line-added">+         // release our copy</span>
<span class="line-added">+         os::free((void *)_event_data.class_unload.name);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
      default:
        ShouldNotReachHere();
    }
  }
  
<span class="line-modified">! void JvmtiDeferredEvent::post_compiled_method_load_event(JvmtiEnv* env) {</span>
<span class="line-modified">!   assert(_type == TYPE_COMPILED_METHOD_LOAD, &quot;only user of this method&quot;);</span>
<span class="line-added">+   nmethod* nm = _event_data.compiled_method_load;</span>
<span class="line-added">+   JvmtiExport::post_compiled_method_load(env, nm);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JvmtiDeferredEvent::run_nmethod_entry_barriers() {</span>
<span class="line-modified">!   if (_type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-modified">!     _event_data.compiled_method_load-&gt;run_nmethod_entry_barrier();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // Keep the nmethod for compiled_method_load from being unloaded.</span>
<span class="line-added">+ void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-added">+   if (cf != NULL &amp;&amp; _type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-added">+     cf-&gt;do_code_blob(_event_data.compiled_method_load);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! // The sweeper calls this and marks the nmethods here on the stack so that</span>
<span class="line-modified">! // they cannot be turned into zombies while in the queue.</span>
<span class="line-added">+ void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added">+   if (cf != NULL &amp;&amp; _type == TYPE_COMPILED_METHOD_LOAD) {</span>
<span class="line-added">+     cf-&gt;do_code_blob(_event_data.compiled_method_load);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ </span>
<span class="line-added">+ bool JvmtiDeferredEventQueue::has_events() {</span>
<span class="line-added">+   // We save the queued events before the live phase and post them when it starts.</span>
<span class="line-added">+   // This code could skip saving the events on the queue before the live</span>
<span class="line-added">+   // phase and ignore them, but this would change how we do things now.</span>
<span class="line-added">+   // Starting the service thread earlier causes this to be called before the live phase begins.</span>
<span class="line-added">+   // The events on the queue should all be posted after the live phase so this is an</span>
<span class="line-added">+   // ok check.  Before the live phase, DynamicCodeGenerated events are posted directly.</span>
<span class="line-added">+   // If we add other types of events to the deferred queue, this could get ugly.</span>
<span class="line-added">+   return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE  &amp;&amp; _queue_head != NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiDeferredEventQueue::enqueue(JvmtiDeferredEvent event) {</span>
    // Events get added to the end of the queue (and are pulled off the front).
    QueueNode* node = new QueueNode(event);
    if (_queue_tail == NULL) {
      _queue_tail = _queue_head = node;
    } else {
      assert(_queue_tail-&gt;next() == NULL, &quot;Must be the last element in the list&quot;);
      _queue_tail-&gt;set_next(node);
      _queue_tail = node;
    }
  
    assert((_queue_head == NULL) == (_queue_tail == NULL),
           &quot;Inconsistent queue markers&quot;);
  }
  
  JvmtiDeferredEvent JvmtiDeferredEventQueue::dequeue() {
    assert(_queue_head != NULL, &quot;Nothing to dequeue&quot;);
  
    if (_queue_head == NULL) {
      // Just in case this happens in product; it shouldn&#39;t but let&#39;s not crash
      return JvmtiDeferredEvent();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1037,5 ***</span>
<span class="line-new-header">--- 985,32 ---</span>
  
    JvmtiDeferredEvent event = node-&gt;event();
    delete node;
    return event;
  }
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiDeferredEventQueue::post(JvmtiEnv* env) {</span>
<span class="line-added">+   // Post and destroy queue nodes</span>
<span class="line-added">+   while (_queue_head != NULL) {</span>
<span class="line-added">+      JvmtiDeferredEvent event = dequeue();</span>
<span class="line-added">+      event.post_compiled_method_load_event(env);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiDeferredEventQueue::run_nmethod_entry_barriers() {</span>
<span class="line-added">+   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">+      node-&gt;event().run_nmethod_entry_barriers();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-added">+   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">+      node-&gt;event().oops_do(f, cf);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {</span>
<span class="line-added">+   for(QueueNode* node = _queue_head; node != NULL; node = node-&gt;next()) {</span>
<span class="line-added">+      node-&gt;event().nmethods_do(cf);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="jvmtiH.xsl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiImpl.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiExport.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIEXPORT_HPP
 26 #define SHARE_PRIMS_JVMTIEXPORT_HPP
 27 
 28 #include &quot;jvmtifiles/jvmti.h&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/iterator.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;oops/oopsHierarchy.hpp&quot;
 33 #include &quot;runtime/frame.hpp&quot;
 34 #include &quot;runtime/handles.hpp&quot;
 35 #include &quot;utilities/globalDefinitions.hpp&quot;
 36 #include &quot;utilities/growableArray.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
 39 // Must be included after jvmti.h.
 40 #include &quot;jvmticmlr.h&quot;
 41 
 42 // Forward declarations
 43 
 44 class JvmtiEventControllerPrivate;
 45 class JvmtiManageCapabilities;
 46 class JvmtiEnv;
 47 class JvmtiThreadState;
 48 
 49 #define JVMTI_SUPPORT_FLAG(key)                                           \
 50   private:                                                                \
 51   static bool  _##key;                                                    \
 52   public:                                                                 \
 53   inline static void set_##key(bool on) {                                 \
 54     JVMTI_ONLY(_##key = (on != 0));                                       \
 55     NOT_JVMTI(report_unsupported(on));                                    \
 56   }                                                                       \
 57   inline static bool key() {                                              \
 58     JVMTI_ONLY(return _##key);                                            \
 59     NOT_JVMTI(return false);                                              \
 60   }
 61 
 62 
 63 // This class contains the JVMTI interface for the rest of hotspot.
 64 //
 65 class JvmtiExport : public AllStatic {
 66   friend class VMStructs;
 67   friend class CompileReplay;
 68 
 69  private:
 70 
 71 #if INCLUDE_JVMTI
 72   static int         _field_access_count;
 73   static int         _field_modification_count;
 74 
 75   static bool        _can_access_local_variables;
 76   static bool        _can_hotswap_or_post_breakpoint;
 77   static bool        _can_modify_any_class;
 78   static bool        _can_walk_any_space;
 79 #endif // INCLUDE_JVMTI
 80 
 81   JVMTI_SUPPORT_FLAG(can_get_source_debug_extension)
 82   JVMTI_SUPPORT_FLAG(can_maintain_original_method_order)
 83   JVMTI_SUPPORT_FLAG(can_post_interpreter_events)
 84   JVMTI_SUPPORT_FLAG(can_post_on_exceptions)
 85   JVMTI_SUPPORT_FLAG(can_post_breakpoint)
 86   JVMTI_SUPPORT_FLAG(can_post_field_access)
 87   JVMTI_SUPPORT_FLAG(can_post_field_modification)
 88   JVMTI_SUPPORT_FLAG(can_post_method_entry)
 89   JVMTI_SUPPORT_FLAG(can_post_method_exit)
 90   JVMTI_SUPPORT_FLAG(can_pop_frame)
 91   JVMTI_SUPPORT_FLAG(can_force_early_return)
 92 
 93   JVMTI_SUPPORT_FLAG(early_vmstart_recorded)
<a name="1" id="anc1"></a>
 94 
 95   friend class JvmtiEventControllerPrivate;  // should only modify these flags
 96   JVMTI_SUPPORT_FLAG(should_post_single_step)
 97   JVMTI_SUPPORT_FLAG(should_post_field_access)
 98   JVMTI_SUPPORT_FLAG(should_post_field_modification)
 99   JVMTI_SUPPORT_FLAG(should_post_class_load)
100   JVMTI_SUPPORT_FLAG(should_post_class_prepare)
101   JVMTI_SUPPORT_FLAG(should_post_class_unload)
102   JVMTI_SUPPORT_FLAG(should_post_native_method_bind)
103   JVMTI_SUPPORT_FLAG(should_post_compiled_method_load)
104   JVMTI_SUPPORT_FLAG(should_post_compiled_method_unload)
105   JVMTI_SUPPORT_FLAG(should_post_dynamic_code_generated)
106   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_enter)
107   JVMTI_SUPPORT_FLAG(should_post_monitor_contended_entered)
108   JVMTI_SUPPORT_FLAG(should_post_monitor_wait)
109   JVMTI_SUPPORT_FLAG(should_post_monitor_waited)
110   JVMTI_SUPPORT_FLAG(should_post_data_dump)
111   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_start)
112   JVMTI_SUPPORT_FLAG(should_post_garbage_collection_finish)
113   JVMTI_SUPPORT_FLAG(should_post_on_exceptions)
114 
115   // ------ the below maybe don&#39;t have to be (but are for now)
116   // fixed conditions here ------------
117   // any events can be enabled
118   JVMTI_SUPPORT_FLAG(should_post_thread_life)
119   JVMTI_SUPPORT_FLAG(should_post_object_free)
120   JVMTI_SUPPORT_FLAG(should_post_resource_exhausted)
121 
122   // we are holding objects on the heap - need to talk to GC - e.g.
123   // breakpoint info
124   JVMTI_SUPPORT_FLAG(should_clean_up_heap_objects)
125   JVMTI_SUPPORT_FLAG(should_post_vm_object_alloc)
126   JVMTI_SUPPORT_FLAG(should_post_sampled_object_alloc)
127 
128   // If flag cannot be implemented, give an error if on=true
129   static void report_unsupported(bool on);
130 
131   // these should only be called by the friend class
132   friend class JvmtiManageCapabilities;
133   inline static void set_can_modify_any_class(bool on) {
134     JVMTI_ONLY(_can_modify_any_class = (on != 0);)
135   }
136   inline static void set_can_access_local_variables(bool on) {
137     JVMTI_ONLY(_can_access_local_variables = (on != 0);)
138   }
139   inline static void set_can_hotswap_or_post_breakpoint(bool on) {
140     JVMTI_ONLY(_can_hotswap_or_post_breakpoint = (on != 0);)
141   }
142   inline static void set_can_walk_any_space(bool on) {
143     JVMTI_ONLY(_can_walk_any_space = (on != 0);)
144   }
145 
146   enum {
147     JVMTI_VERSION_MASK   = 0x70000000,
148     JVMTI_VERSION_VALUE  = 0x30000000,
149     JVMDI_VERSION_VALUE  = 0x20000000
150   };
151 
152   static void post_field_modification(JavaThread *thread, Method* method, address location,
153                                       Klass* field_klass, Handle object, jfieldID field,
154                                       char sig_type, jvalue *value);
155 
156 
157   // posts a DynamicCodeGenerated event (internal/private implementation).
158   // The public post_dynamic_code_generated* functions make use of the
159   // internal implementation.  Also called from JvmtiDeferredEvent::post()
160   static void post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
161 
<a name="2" id="anc2"></a>
162  private:
163 
164   // GenerateEvents support to allow posting of CompiledMethodLoad and
165   // DynamicCodeGenerated events for a given environment.
166   friend class JvmtiCodeBlobEvents;
167 
<a name="3" id="anc3"></a><span class="line-removed">168   static void post_compiled_method_load(JvmtiEnv* env, const jmethodID method, const jint length,</span>
<span class="line-removed">169                                         const void *code_begin, const jint map_length,</span>
<span class="line-removed">170                                         const jvmtiAddrLocationMap* map) NOT_JVMTI_RETURN;</span>
171   static void post_dynamic_code_generated(JvmtiEnv* env, const char *name, const void *code_begin,
172                                           const void *code_end) NOT_JVMTI_RETURN;
173 
174   // This flag indicates whether RedefineClasses() has ever redefined
175   // one or more classes during the lifetime of the VM. The flag should
176   // only be set by the friend class and can be queried by other sub
177   // systems as needed to relax invariant checks.
<a name="4" id="anc4"></a><span class="line-modified">178   static bool _has_redefined_a_class;</span>
179   friend class VM_RedefineClasses;
<a name="5" id="anc5"></a><span class="line-modified">180   inline static void set_has_redefined_a_class() {</span>
<span class="line-modified">181     JVMTI_ONLY(_has_redefined_a_class = true;)</span>
182   }
183   // Flag to indicate if the compiler has recorded all dependencies. When the
184   // can_redefine_classes capability is enabled in the OnLoad phase then the compiler
185   // records all dependencies from startup. However if the capability is first
186   // enabled some time later then the dependencies recorded by the compiler
187   // are incomplete. This flag is used by RedefineClasses to know if the
188   // dependency information is complete or not.
189   static bool _all_dependencies_are_recorded;
190 
191  public:
192   inline static bool has_redefined_a_class() {
<a name="6" id="anc6"></a><span class="line-modified">193     JVMTI_ONLY(return _has_redefined_a_class);</span>
194     NOT_JVMTI(return false);
195   }
196 
<a name="7" id="anc7"></a>





197   inline static bool all_dependencies_are_recorded() {
198     return _all_dependencies_are_recorded;
199   }
200 
201   inline static void set_all_dependencies_are_recorded(bool on) {
202     _all_dependencies_are_recorded = (on != 0);
203   }
204 
205   // Add read edges to the unnamed modules of the bootstrap and app class loaders
206   static void add_default_read_edges(Handle h_module, TRAPS) NOT_JVMTI_RETURN;
207 
208   // Add a read edge to the module
209   static jvmtiError add_module_reads(Handle module, Handle to_module, TRAPS);
210 
211   // Updates a module to export a package
212   static jvmtiError add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS);
213 
214   // Updates a module to open a package
215   static jvmtiError add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS);
216 
217   // Add a used service to the module
218   static jvmtiError add_module_uses(Handle module, Handle service, TRAPS);
219 
220   // Add a service provider to the module
221   static jvmtiError add_module_provides(Handle module, Handle service, Handle impl_class, TRAPS);
222 
223   // let JVMTI know that the JVM_OnLoad code is running
224   static void enter_onload_phase() NOT_JVMTI_RETURN;
225 
226   // let JVMTI know that the VM isn&#39;t up yet (and JVM_OnLoad code isn&#39;t running)
227   static void enter_primordial_phase() NOT_JVMTI_RETURN;
228 
229   // let JVMTI know that the VM isn&#39;t up yet but JNI is live
230   static void enter_early_start_phase() NOT_JVMTI_RETURN;
231   static void enter_start_phase() NOT_JVMTI_RETURN;
232 
233   // let JVMTI know that the VM is fully up and running now
234   static void enter_live_phase() NOT_JVMTI_RETURN;
235 
236   // ------ can_* conditions (below) are set at OnLoad and never changed ------------
237   inline static bool can_modify_any_class()                       {
238     JVMTI_ONLY(return _can_modify_any_class);
239     NOT_JVMTI(return false);
240   }
241   inline static bool can_access_local_variables()                 {
242     JVMTI_ONLY(return _can_access_local_variables);
243     NOT_JVMTI(return false);
244   }
245   inline static bool can_hotswap_or_post_breakpoint()             {
246     JVMTI_ONLY(return _can_hotswap_or_post_breakpoint);
247     NOT_JVMTI(return false);
248   }
249   inline static bool can_walk_any_space()                         {
250     JVMTI_ONLY(return _can_walk_any_space);
251     NOT_JVMTI(return false);
252   }
253 
254   // field access management
255   static address  get_field_access_count_addr() NOT_JVMTI_RETURN_(0);
256 
257   // field modification management
258   static address  get_field_modification_count_addr() NOT_JVMTI_RETURN_(0);
259 
260   // -----------------
261 
262   static bool is_jvmti_version(jint version)                      {
263     JVMTI_ONLY(return (version &amp; JVMTI_VERSION_MASK) == JVMTI_VERSION_VALUE);
264     NOT_JVMTI(return false);
265   }
266   static bool is_jvmdi_version(jint version)                      {
267     JVMTI_ONLY(return (version &amp; JVMTI_VERSION_MASK) == JVMDI_VERSION_VALUE);
268     NOT_JVMTI(return false);
269   }
270   static jint get_jvmti_interface(JavaVM *jvm, void **penv, jint version) NOT_JVMTI_RETURN_(0);
271   static void decode_version_values(jint version, int * major, int * minor,
272                                     int * micro) NOT_JVMTI_RETURN;
273 
274   // single stepping management methods
275   static void at_single_stepping_point(JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
276   static void expose_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN;
277   static bool hide_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN_(false);
278 
279   // Methods that notify the debugger that something interesting has happened in the VM.
280   static void post_early_vm_start        () NOT_JVMTI_RETURN;
281   static void post_vm_start              () NOT_JVMTI_RETURN;
282   static void post_vm_initialized        () NOT_JVMTI_RETURN;
283   static void post_vm_death              () NOT_JVMTI_RETURN;
284 
285   static void post_single_step           (JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
286   static void post_raw_breakpoint        (JavaThread *thread, Method* method, address location) NOT_JVMTI_RETURN;
287 
288   static void post_exception_throw       (JavaThread *thread, Method* method, address location, oop exception) NOT_JVMTI_RETURN;
289   static void notice_unwind_due_to_exception (JavaThread *thread, Method* method, address location, oop exception, bool in_handler_frame) NOT_JVMTI_RETURN;
290 
291   static oop jni_GetField_probe          (JavaThread *thread, jobject jobj,
292     oop obj, Klass* klass, jfieldID fieldID, bool is_static)
293     NOT_JVMTI_RETURN_(NULL);
294   static oop jni_GetField_probe_nh       (JavaThread *thread, jobject jobj,
295     oop obj, Klass* klass, jfieldID fieldID, bool is_static)
296     NOT_JVMTI_RETURN_(NULL);
297   static void post_field_access_by_jni   (JavaThread *thread, oop obj,
298     Klass* klass, jfieldID fieldID, bool is_static) NOT_JVMTI_RETURN;
299   static void post_field_access          (JavaThread *thread, Method* method,
300     address location, Klass* field_klass, Handle object, jfieldID field) NOT_JVMTI_RETURN;
301   static oop jni_SetField_probe          (JavaThread *thread, jobject jobj,
302     oop obj, Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
303     jvalue *value) NOT_JVMTI_RETURN_(NULL);
304   static oop jni_SetField_probe_nh       (JavaThread *thread, jobject jobj,
305     oop obj, Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
306     jvalue *value) NOT_JVMTI_RETURN_(NULL);
307   static void post_field_modification_by_jni(JavaThread *thread, oop obj,
308     Klass* klass, jfieldID fieldID, bool is_static, char sig_type,
309     jvalue *value);
310   static void post_raw_field_modification(JavaThread *thread, Method* method,
311     address location, Klass* field_klass, Handle object, jfieldID field,
312     char sig_type, jvalue *value) NOT_JVMTI_RETURN;
313 
314   static void post_method_entry          (JavaThread *thread, Method* method, frame current_frame) NOT_JVMTI_RETURN;
315   static void post_method_exit           (JavaThread *thread, Method* method, frame current_frame) NOT_JVMTI_RETURN;
316 
317   static void post_class_load            (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
318   static void post_class_unload          (Klass* klass) NOT_JVMTI_RETURN;
319   static void post_class_prepare         (JavaThread *thread, Klass* klass) NOT_JVMTI_RETURN;
320 
321   static void post_thread_start          (JavaThread *thread) NOT_JVMTI_RETURN;
322   static void post_thread_end            (JavaThread *thread) NOT_JVMTI_RETURN;
323 
324   // Support for java.lang.instrument agent loading.
325   static bool _should_post_class_file_load_hook;
326   inline static void set_should_post_class_file_load_hook(bool on)     { _should_post_class_file_load_hook = on;  }
327   inline static bool should_post_class_file_load_hook()           {
328     JVMTI_ONLY(return _should_post_class_file_load_hook);
329     NOT_JVMTI(return false;)
330   }
331   static bool is_early_phase() NOT_JVMTI_RETURN_(false);
332   static bool has_early_class_hook_env() NOT_JVMTI_RETURN_(false);
333   // Return true if the class was modified by the hook.
334   static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,
335                                         Handle h_protection_domain,
336                                         unsigned char **data_ptr, unsigned char **end_ptr,
337                                         JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);
338   static void post_native_method_bind(Method* method, address* function_ptr) NOT_JVMTI_RETURN;
<a name="8" id="anc8"></a>
339   static void post_compiled_method_load(nmethod *nm) NOT_JVMTI_RETURN;
340   static void post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) NOT_JVMTI_RETURN;
341 
342   // used to post a CompiledMethodUnload event
343   static void post_compiled_method_unload(jmethodID mid, const void *code_begin) NOT_JVMTI_RETURN;
344 
345   // similiar to post_dynamic_code_generated except that it can be used to
346   // post a DynamicCodeGenerated event while holding locks in the VM. Any event
347   // posted using this function is recorded by the enclosing event collector
348   // -- JvmtiDynamicCodeEventCollector.
349   static void post_dynamic_code_generated_while_holding_locks(const char* name, address code_begin, address code_end) NOT_JVMTI_RETURN;
350 
351   static void post_garbage_collection_finish() NOT_JVMTI_RETURN;
352   static void post_garbage_collection_start() NOT_JVMTI_RETURN;
353   static void post_data_dump() NOT_JVMTI_RETURN;
354   static void post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
355   static void post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) NOT_JVMTI_RETURN;
356   static void post_monitor_wait(JavaThread *thread, oop obj, jlong timeout) NOT_JVMTI_RETURN;
357   static void post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) NOT_JVMTI_RETURN;
358   static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;
359   static void post_resource_exhausted(jint resource_exhausted_flags, const char* detail) NOT_JVMTI_RETURN;
360   static void record_vm_internal_object_allocation(oop object) NOT_JVMTI_RETURN;
361   // Post objects collected by vm_object_alloc_event_collector.
362   static void post_vm_object_alloc(JavaThread *thread, oop object) NOT_JVMTI_RETURN;
363   // Collects vm internal objects for later event posting.
364   inline static void vm_object_alloc_event_collector(oop object) {
365     if (should_post_vm_object_alloc()) {
366       record_vm_internal_object_allocation(object);
367     }
368   }
369 
370   static void record_sampled_internal_object_allocation(oop object) NOT_JVMTI_RETURN;
371   // Post objects collected by sampled_object_alloc_event_collector.
372   static void post_sampled_object_alloc(JavaThread *thread, oop object) NOT_JVMTI_RETURN;
373 
374   // Collects vm internal objects for later event posting.
375   inline static void sampled_object_alloc_event_collector(oop object) {
376     if (should_post_sampled_object_alloc()) {
377       record_sampled_internal_object_allocation(object);
378     }
379   }
380 
381   inline static void post_array_size_exhausted() {
382     if (should_post_resource_exhausted()) {
383       post_resource_exhausted(JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
384                               &quot;Requested array size exceeds VM limit&quot;);
385     }
386   }
387 
388   static void cleanup_thread             (JavaThread* thread) NOT_JVMTI_RETURN;
389   static void clear_detected_exception   (JavaThread* thread) NOT_JVMTI_RETURN;
390 
391   static void oops_do(OopClosure* f) NOT_JVMTI_RETURN;
392   static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) NOT_JVMTI_RETURN;
<a name="9" id="anc9"></a><span class="line-removed">393   static void gc_epilogue() NOT_JVMTI_RETURN;</span>
394 
395   static void transition_pending_onload_raw_monitors() NOT_JVMTI_RETURN;
396 
397 #if INCLUDE_SERVICES
398   // attach support
399   static jint load_agent_library(const char *agent, const char *absParam, const char *options, outputStream* out) NOT_JVMTI_RETURN_(JNI_ERR);
400 #endif
401 
402   // SetNativeMethodPrefix support
403   static char** get_all_native_method_prefixes(int* count_ptr) NOT_JVMTI_RETURN_(NULL);
404 
405   // JavaThread lifecycle support:
406   static jvmtiError cv_external_thread_to_JavaThread(ThreadsList * t_list,
407                                                      jthread thread,
408                                                      JavaThread ** jt_pp,
409                                                      oop * thread_oop_p);
410   static jvmtiError cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
411                                          JavaThread ** jt_pp);
412 };
413 
414 // Support class used by JvmtiDynamicCodeEventCollector and others. It
415 // describes a single code blob by name and address range.
416 class JvmtiCodeBlobDesc : public CHeapObj&lt;mtInternal&gt; {
417  private:
418   char _name[64];
419   address _code_begin;
420   address _code_end;
421 
422  public:
423   JvmtiCodeBlobDesc(const char *name, address code_begin, address code_end) {
424     assert(name != NULL, &quot;all code blobs must be named&quot;);
<a name="10" id="anc10"></a><span class="line-modified">425     strncpy(_name, name, sizeof(_name));</span>
426     _name[sizeof(_name)-1] = &#39;\0&#39;;
427     _code_begin = code_begin;
428     _code_end = code_end;
429   }
430   char* name()                  { return _name; }
431   address code_begin()          { return _code_begin; }
432   address code_end()            { return _code_end; }
433 };
434 
435 // JvmtiEventCollector is a helper class to setup thread for
436 // event collection.
437 class JvmtiEventCollector : public StackObj {
438  private:
439   JvmtiEventCollector* _prev;  // Save previous one to support nested event collector.
440   bool _unset_jvmti_thread_state;
441 
442  public:
443   JvmtiEventCollector() : _prev(NULL), _unset_jvmti_thread_state(false) {}
444 
445   void setup_jvmti_thread_state(); // Set this collector in current thread, returns if success.
446   void unset_jvmti_thread_state(); // Reset previous collector in current thread.
447   virtual bool is_dynamic_code_event()   { return false; }
448   virtual bool is_vm_object_alloc_event(){ return false; }
449   virtual bool is_sampled_object_alloc_event(){ return false; }
450   JvmtiEventCollector *get_prev()        { return _prev; }
451 };
452 
453 // A JvmtiDynamicCodeEventCollector is a helper class for the JvmtiExport
454 // interface. It collects &quot;dynamic code generated&quot; events that are posted
455 // while holding locks. When the event collector goes out of scope the
456 // events will be posted.
457 //
458 // Usage :-
459 //
460 // {
461 //   JvmtiDynamicCodeEventCollector event_collector;
462 //   :
463 //   { MutexLocker ml(...)
464 //     :
465 //     JvmtiExport::post_dynamic_code_generated_while_holding_locks(...)
466 //   }
467 //   // event collector goes out of scope =&gt; post events to profiler.
468 // }
469 
470 class JvmtiDynamicCodeEventCollector : public JvmtiEventCollector {
471  private:
472   GrowableArray&lt;JvmtiCodeBlobDesc*&gt;* _code_blobs;           // collected code blob events
473 
474   friend class JvmtiExport;
475   void register_stub(const char* name, address start, address end);
476 
477  public:
478   JvmtiDynamicCodeEventCollector()  NOT_JVMTI_RETURN;
479   ~JvmtiDynamicCodeEventCollector() NOT_JVMTI_RETURN;
480   bool is_dynamic_code_event()   { return true; }
481 
482 };
483 
484 // Used as a base class for object allocation collection and then posting
485 // the allocations to any event notification callbacks.
486 //
487 class JvmtiObjectAllocEventCollector : public JvmtiEventCollector {
488  protected:
489   GrowableArray&lt;oop&gt;* _allocated;      // field to record collected allocated object oop.
490   bool _enable;                   // This flag is enabled in constructor if set up in the thread state
491                                   // and disabled in destructor before posting event. To avoid
492                                   // collection of objects allocated while running java code inside
493                                   // agent post_X_object_alloc() event handler.
494   void (*_post_callback)(JavaThread*, oop); // what callback to use when destroying the collector.
495 
496   //GC support
497   void oops_do(OopClosure* f);
498 
499   friend class JvmtiExport;
500 
501   // Record allocated object oop.
502   inline void record_allocation(oop obj);
503 
504   //GC support
505   static void oops_do_for_all_threads(OopClosure* f);
506 
507  public:
508   JvmtiObjectAllocEventCollector()  NOT_JVMTI_RETURN;
509 
510   void generate_call_for_allocated();
511 
512   bool is_enabled()                 { return _enable; }
513   void set_enabled(bool on)         { _enable = on; }
514 };
515 
516 // Used to record vm internally allocated object oops and post
517 // vm object alloc event for objects visible to java world.
518 // Constructor enables JvmtiThreadState flag and all vm allocated
519 // objects are recorded in a growable array. When destructor is
520 // called the vm object alloc event is posted for each object
521 // visible to java world.
522 // See jvm.cpp file for its usage.
523 //
524 class JvmtiVMObjectAllocEventCollector : public JvmtiObjectAllocEventCollector {
525  public:
526   JvmtiVMObjectAllocEventCollector()  NOT_JVMTI_RETURN;
527   ~JvmtiVMObjectAllocEventCollector()  NOT_JVMTI_RETURN;
528   virtual bool is_vm_object_alloc_event()   { return true; }
529 };
530 
531 // Used to record sampled allocated object oops and post
532 // sampled object alloc event.
533 // Constructor enables JvmtiThreadState flag and all sampled allocated
534 // objects are recorded in a growable array. When destructor is
535 // called the sampled object alloc event is posted for each sampled object.
536 // See jvm.cpp file for its usage.
537 //
538 class JvmtiSampledObjectAllocEventCollector : public JvmtiObjectAllocEventCollector {
539  public:
540   JvmtiSampledObjectAllocEventCollector()  NOT_JVMTI_RETURN;
541   ~JvmtiSampledObjectAllocEventCollector()  NOT_JVMTI_RETURN;
542   bool is_sampled_object_alloc_event()    { return true; }
543   static bool object_alloc_is_safe_to_sample() NOT_JVMTI_RETURN_(false);
544 };
545 
546 // Marker class to disable the posting of VMObjectAlloc events
547 // within its scope.
548 //
549 // Usage :-
550 //
551 // {
552 //   NoJvmtiVMObjectAllocMark njm;
553 //   :
554 //   // VMObjAlloc event will not be posted
555 //   JvmtiExport::vm_object_alloc_event_collector(obj);
556 //   :
557 // }
558 
559 class NoJvmtiVMObjectAllocMark : public StackObj {
560  private:
561   // enclosing collector if enabled, NULL otherwise
562   JvmtiVMObjectAllocEventCollector *_collector;
563 
564   bool was_enabled()    { return _collector != NULL; }
565 
566  public:
567   NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;
568   ~NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;
569 };
570 
571 
572 // Base class for reporting GC events to JVMTI.
573 class JvmtiGCMarker : public StackObj {
574  public:
575   JvmtiGCMarker() NOT_JVMTI_RETURN;
576   ~JvmtiGCMarker() NOT_JVMTI_RETURN;
577 };
578 
579 // JvmtiHideSingleStepping is a helper class for hiding
580 // internal single step events.
581 class JvmtiHideSingleStepping : public StackObj {
582  private:
583   bool         _single_step_hidden;
584   JavaThread * _thread;
585 
586  public:
587   JvmtiHideSingleStepping(JavaThread * thread) {
588     assert(thread != NULL, &quot;sanity check&quot;);
589 
590     _single_step_hidden = false;
591     _thread = thread;
592     if (JvmtiExport::should_post_single_step()) {
593       _single_step_hidden = JvmtiExport::hide_single_stepping(_thread);
594     }
595   }
596 
597   ~JvmtiHideSingleStepping() {
598     if (_single_step_hidden) {
599       JvmtiExport::expose_single_stepping(_thread);
600     }
601   }
602 };
603 
604 #endif // SHARE_PRIMS_JVMTIEXPORT_HPP
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
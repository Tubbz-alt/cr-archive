<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/stackwalk.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="resolvedMethodTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/stackwalk.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;memory/oopFactory.hpp&quot;

 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;oops/objArrayOop.inline.hpp&quot;
 34 #include &quot;prims/stackwalk.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/javaCalls.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;runtime/vframe.inline.hpp&quot;
 40 #include &quot;utilities/globalDefinitions.hpp&quot;
 41 
 42 // setup and cleanup actions
 43 void BaseFrameStream::setup_magic_on_entry(objArrayHandle frames_array) {
 44   frames_array-&gt;obj_at_put(magic_pos, _thread-&gt;threadObj());
 45   _anchor = address_value();
 46   assert(check_magic(frames_array), &quot;invalid magic&quot;);
 47 }
 48 
 49 bool BaseFrameStream::check_magic(objArrayHandle frames_array) {
 50   oop   m1 = frames_array-&gt;obj_at(magic_pos);
 51   jlong m2 = _anchor;
<span class="line-modified"> 52   if (oopDesc::equals(m1, _thread-&gt;threadObj()) &amp;&amp; m2 == address_value())  return true;</span>
 53   return false;
 54 }
 55 
 56 bool BaseFrameStream::cleanup_magic_on_exit(objArrayHandle frames_array) {
 57   bool ok = check_magic(frames_array);
 58   frames_array-&gt;obj_at_put(magic_pos, NULL);
 59   _anchor = 0L;
 60   return ok;
 61 }
 62 
 63 JavaFrameStream::JavaFrameStream(JavaThread* thread, int mode)
 64   : BaseFrameStream(thread), _vfst(thread) {
 65   _need_method_info = StackWalk::need_method_info(mode);
 66 }
 67 
 68 void JavaFrameStream::next() { _vfst.next();}
 69 
 70 // Returns the BaseFrameStream for the current stack being traversed.
 71 //
 72 // Parameters:
 73 //  thread         Current Java thread.
 74 //  magic          Magic value used for each stack walking
 75 //  frames_array   User-supplied buffers.  The 0th element is reserved
 76 //                 for this BaseFrameStream to use
 77 //
 78 BaseFrameStream* BaseFrameStream::from_current(JavaThread* thread, jlong magic,
 79                                                objArrayHandle frames_array)
 80 {
 81   assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;&quot;);
 82   oop m1 = frames_array-&gt;obj_at(magic_pos);
<span class="line-modified"> 83   if (!oopDesc::equals(m1, thread-&gt;threadObj())) return NULL;</span>
 84   if (magic == 0L)                    return NULL;
 85   BaseFrameStream* stream = (BaseFrameStream*) (intptr_t) magic;
 86   if (!stream-&gt;is_valid_in(thread, frames_array))   return NULL;
 87   return stream;
 88 }
 89 
 90 // Unpacks one or more frames into user-supplied buffers.
 91 // Updates the end index, and returns the number of unpacked frames.
 92 // Always start with the existing vfst.method and bci.
 93 // Do not call vfst.next to advance over the last returned value.
 94 // In other words, do not leave any stale data in the vfst.
 95 //
 96 // Parameters:
 97 //   mode             Restrict which frames to be decoded.
 98 //   BaseFrameStream  stream of frames
 99 //   max_nframes      Maximum number of frames to be filled.
100 //   start_index      Start index to the user-supplied buffers.
101 //   frames_array     Buffer to store Class or StackFrame in, starting at start_index.
102 //                    frames array is a Class&lt;?&gt;[] array when only getting caller
103 //                    reference, and a StackFrameInfo[] array (or derivative)
</pre>
<hr />
<pre>
134           ls.cr();
135         }
136         continue;
137       }
138     }
139 
140     int index = end_index++;
141     LogTarget(Debug, stackwalk) lt;
142     if (lt.is_enabled()) {
143       ResourceMark rm(THREAD);
144       LogStream ls(lt);
145       ls.print(&quot;  %d: frame method: &quot;, index);
146       method-&gt;print_short_name(&amp;ls);
147       ls.print_cr(&quot; bci=%d&quot;, stream.bci());
148     }
149 
150     if (!need_method_info(mode) &amp;&amp; get_caller_class(mode) &amp;&amp;
151           index == start_index &amp;&amp; method-&gt;caller_sensitive()) {
152       ResourceMark rm(THREAD);
153       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),
<span class="line-modified">154         err_msg(&quot;StackWalker::getCallerClass called from @CallerSensitive %s method&quot;,</span>
<span class="line-modified">155                 method-&gt;name_and_sig_as_C_string()));</span>
156     }
157     // fill in StackFrameInfo and initialize MemberName
<span class="line-modified">158     stream.fill_frame(index, frames_array, method, CHECK_0);</span>
159     if (++frames_decoded &gt;= max_nframes)  break;
160   }
161   return frames_decoded;
162 }
163 
164 // Fill in the LiveStackFrameInfo at the given index in frames_array
165 void LiveFrameStream::fill_frame(int index, objArrayHandle  frames_array,
166                                  const methodHandle&amp; method, TRAPS) {
167   HandleMark hm(THREAD);
168   Handle stackFrame(THREAD, frames_array-&gt;obj_at(index));
169   fill_live_stackframe(stackFrame, method, CHECK);
170 }
171 
172 // Fill in the StackFrameInfo at the given index in frames_array
173 void JavaFrameStream::fill_frame(int index, objArrayHandle  frames_array,
174                                  const methodHandle&amp; method, TRAPS) {
175   if (_need_method_info) {
176     HandleMark hm(THREAD);
177     Handle stackFrame(THREAD, frames_array-&gt;obj_at(index));
178     fill_stackframe(stackFrame, method, CHECK);
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;memory/oopFactory.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;oops/objArrayOop.inline.hpp&quot;
 35 #include &quot;prims/stackwalk.hpp&quot;
 36 #include &quot;runtime/globals.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/javaCalls.hpp&quot;
 39 #include &quot;runtime/thread.inline.hpp&quot;
 40 #include &quot;runtime/vframe.inline.hpp&quot;
 41 #include &quot;utilities/globalDefinitions.hpp&quot;
 42 
 43 // setup and cleanup actions
 44 void BaseFrameStream::setup_magic_on_entry(objArrayHandle frames_array) {
 45   frames_array-&gt;obj_at_put(magic_pos, _thread-&gt;threadObj());
 46   _anchor = address_value();
 47   assert(check_magic(frames_array), &quot;invalid magic&quot;);
 48 }
 49 
 50 bool BaseFrameStream::check_magic(objArrayHandle frames_array) {
 51   oop   m1 = frames_array-&gt;obj_at(magic_pos);
 52   jlong m2 = _anchor;
<span class="line-modified"> 53   if (m1 == _thread-&gt;threadObj() &amp;&amp; m2 == address_value())  return true;</span>
 54   return false;
 55 }
 56 
 57 bool BaseFrameStream::cleanup_magic_on_exit(objArrayHandle frames_array) {
 58   bool ok = check_magic(frames_array);
 59   frames_array-&gt;obj_at_put(magic_pos, NULL);
 60   _anchor = 0L;
 61   return ok;
 62 }
 63 
 64 JavaFrameStream::JavaFrameStream(JavaThread* thread, int mode)
 65   : BaseFrameStream(thread), _vfst(thread) {
 66   _need_method_info = StackWalk::need_method_info(mode);
 67 }
 68 
 69 void JavaFrameStream::next() { _vfst.next();}
 70 
 71 // Returns the BaseFrameStream for the current stack being traversed.
 72 //
 73 // Parameters:
 74 //  thread         Current Java thread.
 75 //  magic          Magic value used for each stack walking
 76 //  frames_array   User-supplied buffers.  The 0th element is reserved
 77 //                 for this BaseFrameStream to use
 78 //
 79 BaseFrameStream* BaseFrameStream::from_current(JavaThread* thread, jlong magic,
 80                                                objArrayHandle frames_array)
 81 {
 82   assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;&quot;);
 83   oop m1 = frames_array-&gt;obj_at(magic_pos);
<span class="line-modified"> 84   if (m1 != thread-&gt;threadObj()) return NULL;</span>
 85   if (magic == 0L)                    return NULL;
 86   BaseFrameStream* stream = (BaseFrameStream*) (intptr_t) magic;
 87   if (!stream-&gt;is_valid_in(thread, frames_array))   return NULL;
 88   return stream;
 89 }
 90 
 91 // Unpacks one or more frames into user-supplied buffers.
 92 // Updates the end index, and returns the number of unpacked frames.
 93 // Always start with the existing vfst.method and bci.
 94 // Do not call vfst.next to advance over the last returned value.
 95 // In other words, do not leave any stale data in the vfst.
 96 //
 97 // Parameters:
 98 //   mode             Restrict which frames to be decoded.
 99 //   BaseFrameStream  stream of frames
100 //   max_nframes      Maximum number of frames to be filled.
101 //   start_index      Start index to the user-supplied buffers.
102 //   frames_array     Buffer to store Class or StackFrame in, starting at start_index.
103 //                    frames array is a Class&lt;?&gt;[] array when only getting caller
104 //                    reference, and a StackFrameInfo[] array (or derivative)
</pre>
<hr />
<pre>
135           ls.cr();
136         }
137         continue;
138       }
139     }
140 
141     int index = end_index++;
142     LogTarget(Debug, stackwalk) lt;
143     if (lt.is_enabled()) {
144       ResourceMark rm(THREAD);
145       LogStream ls(lt);
146       ls.print(&quot;  %d: frame method: &quot;, index);
147       method-&gt;print_short_name(&amp;ls);
148       ls.print_cr(&quot; bci=%d&quot;, stream.bci());
149     }
150 
151     if (!need_method_info(mode) &amp;&amp; get_caller_class(mode) &amp;&amp;
152           index == start_index &amp;&amp; method-&gt;caller_sensitive()) {
153       ResourceMark rm(THREAD);
154       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),
<span class="line-modified">155         err_msg(&quot;StackWalker::getCallerClass called from @CallerSensitive &#39;%s&#39; method&quot;,</span>
<span class="line-modified">156                 method-&gt;external_name()));</span>
157     }
158     // fill in StackFrameInfo and initialize MemberName
<span class="line-modified">159     stream.fill_frame(index, frames_array, methodHandle(THREAD, method), CHECK_0);</span>
160     if (++frames_decoded &gt;= max_nframes)  break;
161   }
162   return frames_decoded;
163 }
164 
165 // Fill in the LiveStackFrameInfo at the given index in frames_array
166 void LiveFrameStream::fill_frame(int index, objArrayHandle  frames_array,
167                                  const methodHandle&amp; method, TRAPS) {
168   HandleMark hm(THREAD);
169   Handle stackFrame(THREAD, frames_array-&gt;obj_at(index));
170   fill_live_stackframe(stackFrame, method, CHECK);
171 }
172 
173 // Fill in the StackFrameInfo at the given index in frames_array
174 void JavaFrameStream::fill_frame(int index, objArrayHandle  frames_array,
175                                  const methodHandle&amp; method, TRAPS) {
176   if (_need_method_info) {
177     HandleMark hm(THREAD);
178     Handle stackFrame(THREAD, frames_array-&gt;obj_at(index));
179     fill_stackframe(stackFrame, method, CHECK);
</pre>
</td>
</tr>
</table>
<center><a href="resolvedMethodTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
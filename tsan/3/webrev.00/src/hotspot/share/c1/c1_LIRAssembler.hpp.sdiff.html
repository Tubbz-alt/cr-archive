<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIRAssembler.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRAssembler.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64     if (_pending_non_safepoint != NULL) {
 65       if (_pending_non_safepoint_offset &lt; before_pc_offset)
 66         record_non_safepoint_debug_info();
 67       _pending_non_safepoint = NULL;
 68     }
 69   }
 70   void process_debug_info(LIR_Op* op);
 71   void record_non_safepoint_debug_info();
 72 
 73   // unified bailout support
 74   void bailout(const char* msg) const { compilation()-&gt;bailout(msg); }
 75   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
 76 
 77   // code emission patterns and accessors
 78   void check_codespace();
 79   bool needs_icache(ciMethod* method) const;
 80 
 81   // returns offset of icache check
 82   int check_icache();
 83 



 84   void jobject2reg(jobject o, Register reg);
 85   void jobject2reg_with_patching(Register reg, CodeEmitInfo* info);
 86 
 87   void metadata2reg(Metadata* o, Register reg);
 88   void klass2reg_with_patching(Register reg, CodeEmitInfo* info);
 89 
 90   void emit_stubs(CodeStubList* stub_list);
 91 
 92   // addresses
 93   Address as_Address(LIR_Address* addr);
 94   Address as_Address_lo(LIR_Address* addr);
 95   Address as_Address_hi(LIR_Address* addr);
 96 
 97   // debug information
 98   void add_call_info(int pc_offset, CodeEmitInfo* cinfo);
 99   void add_debug_info_for_branch(CodeEmitInfo* info);
100   void add_debug_info_for_div0(int pc_offset, CodeEmitInfo* cinfo);
101   void add_debug_info_for_div0_here(CodeEmitInfo* info);
102   ImplicitNullCheckStub* add_debug_info_for_null_check(int pc_offset, CodeEmitInfo* cinfo);
103   ImplicitNullCheckStub* add_debug_info_for_null_check_here(CodeEmitInfo* info);
104 
<span class="line-removed">105   void set_24bit_FPU();</span>
<span class="line-removed">106   void reset_FPU();</span>
<span class="line-removed">107   void fpop();</span>
<span class="line-removed">108   void fxch(int i);</span>
<span class="line-removed">109   void fld(int i);</span>
<span class="line-removed">110   void ffree(int i);</span>
<span class="line-removed">111 </span>
112   void breakpoint();
113   void push(LIR_Opr opr);
114   void pop(LIR_Opr opr);
115 
116   // patching
117   void append_patching_stub(PatchingStub* stub);
118   void patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info);
119 
120   void comp_op(LIR_Condition condition, LIR_Opr src, LIR_Opr result, LIR_Op2* op);
121 
122   PatchingStub::PatchID patching_id(CodeEmitInfo* info);
123 
124  public:
125   LIR_Assembler(Compilation* c);
126   ~LIR_Assembler();
127   C1_MacroAssembler* masm() const                { return _masm; }
128   Compilation* compilation() const               { return _compilation; }
129   ciMethod* method() const                       { return compilation()-&gt;method(); }
130 
131   CodeOffsets* offsets() const                   { return _compilation-&gt;offsets(); }
</pre>
</td>
<td>
<hr />
<pre>
 64     if (_pending_non_safepoint != NULL) {
 65       if (_pending_non_safepoint_offset &lt; before_pc_offset)
 66         record_non_safepoint_debug_info();
 67       _pending_non_safepoint = NULL;
 68     }
 69   }
 70   void process_debug_info(LIR_Op* op);
 71   void record_non_safepoint_debug_info();
 72 
 73   // unified bailout support
 74   void bailout(const char* msg) const { compilation()-&gt;bailout(msg); }
 75   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
 76 
 77   // code emission patterns and accessors
 78   void check_codespace();
 79   bool needs_icache(ciMethod* method) const;
 80 
 81   // returns offset of icache check
 82   int check_icache();
 83 
<span class="line-added"> 84   bool needs_clinit_barrier_on_entry(ciMethod* method) const;</span>
<span class="line-added"> 85   void clinit_barrier(ciMethod* method);</span>
<span class="line-added"> 86 </span>
 87   void jobject2reg(jobject o, Register reg);
 88   void jobject2reg_with_patching(Register reg, CodeEmitInfo* info);
 89 
 90   void metadata2reg(Metadata* o, Register reg);
 91   void klass2reg_with_patching(Register reg, CodeEmitInfo* info);
 92 
 93   void emit_stubs(CodeStubList* stub_list);
 94 
 95   // addresses
 96   Address as_Address(LIR_Address* addr);
 97   Address as_Address_lo(LIR_Address* addr);
 98   Address as_Address_hi(LIR_Address* addr);
 99 
100   // debug information
101   void add_call_info(int pc_offset, CodeEmitInfo* cinfo);
102   void add_debug_info_for_branch(CodeEmitInfo* info);
103   void add_debug_info_for_div0(int pc_offset, CodeEmitInfo* cinfo);
104   void add_debug_info_for_div0_here(CodeEmitInfo* info);
105   ImplicitNullCheckStub* add_debug_info_for_null_check(int pc_offset, CodeEmitInfo* cinfo);
106   ImplicitNullCheckStub* add_debug_info_for_null_check_here(CodeEmitInfo* info);
107 







108   void breakpoint();
109   void push(LIR_Opr opr);
110   void pop(LIR_Opr opr);
111 
112   // patching
113   void append_patching_stub(PatchingStub* stub);
114   void patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info);
115 
116   void comp_op(LIR_Condition condition, LIR_Opr src, LIR_Opr result, LIR_Op2* op);
117 
118   PatchingStub::PatchID patching_id(CodeEmitInfo* info);
119 
120  public:
121   LIR_Assembler(Compilation* c);
122   ~LIR_Assembler();
123   C1_MacroAssembler* masm() const                { return _masm; }
124   Compilation* compilation() const               { return _compilation; }
125   ciMethod* method() const                       { return compilation()-&gt;method(); }
126 
127   CodeOffsets* offsets() const                   { return _compilation-&gt;offsets(); }
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
364   void inline_bailout(const char* msg);
365   BlockBegin* header_block(BlockBegin* entry, BlockBegin::Flag f, ValueStack* state);
366   BlockBegin* setup_start_block(int osr_bci, BlockBegin* std_entry, BlockBegin* osr_entry, ValueStack* init_state);
367   void setup_osr_entry_block();
368   void clear_inline_bailout();
369   ValueStack* state_at_entry();
370   void push_root_scope(IRScope* scope, BlockList* bci2block, BlockBegin* start);
371   void push_scope(ciMethod* callee, BlockBegin* continuation);
372   void push_scope_for_jsr(BlockBegin* jsr_continuation, int jsr_dest_bci);
373   void pop_scope();
374   void pop_scope_for_jsr();
375 
376   void append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile);
377   void append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile);
378   void append_unsafe_get_raw(ciMethod* callee, BasicType t);
379   void append_unsafe_put_raw(ciMethod* callee, BasicType t);
380   void append_unsafe_CAS(ciMethod* callee);
381   void append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add);
382   void append_char_access(ciMethod* callee, bool is_store);
383 
<span class="line-modified">384   void print_inlining(ciMethod* callee, const char* msg = NULL, bool success = true);</span>
385 
386   void profile_call(ciMethod* callee, Value recv, ciKlass* predicted_holder, Values* obj_args, bool inlined);
387   void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = NULL, int bci = -1);
388   void profile_invocation(ciMethod* inlinee, ValueStack* state);
389 
390   // Shortcuts to profiling control.
391   bool is_profiling()          { return _compilation-&gt;is_profiling();          }
392   bool count_invocations()     { return _compilation-&gt;count_invocations();     }
393   bool count_backedges()       { return _compilation-&gt;count_backedges();       }
394   bool profile_branches()      { return _compilation-&gt;profile_branches();      }
395   bool profile_calls()         { return _compilation-&gt;profile_calls();         }
396   bool profile_inlined_calls() { return _compilation-&gt;profile_inlined_calls(); }
397   bool profile_checkcasts()    { return _compilation-&gt;profile_checkcasts();    }
398   bool profile_parameters()    { return _compilation-&gt;profile_parameters();    }
399   bool profile_arguments()     { return _compilation-&gt;profile_arguments();     }
400   bool profile_return()        { return _compilation-&gt;profile_return();        }
401 
402   Values* args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver);
403   Values* collect_args_for_profiling(Values* args, ciMethod* target, bool may_have_receiver);
404   void check_args_for_profiling(Values* obj_args, int expected);
</pre>
</td>
<td>
<hr />
<pre>
364   void inline_bailout(const char* msg);
365   BlockBegin* header_block(BlockBegin* entry, BlockBegin::Flag f, ValueStack* state);
366   BlockBegin* setup_start_block(int osr_bci, BlockBegin* std_entry, BlockBegin* osr_entry, ValueStack* init_state);
367   void setup_osr_entry_block();
368   void clear_inline_bailout();
369   ValueStack* state_at_entry();
370   void push_root_scope(IRScope* scope, BlockList* bci2block, BlockBegin* start);
371   void push_scope(ciMethod* callee, BlockBegin* continuation);
372   void push_scope_for_jsr(BlockBegin* jsr_continuation, int jsr_dest_bci);
373   void pop_scope();
374   void pop_scope_for_jsr();
375 
376   void append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile);
377   void append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile);
378   void append_unsafe_get_raw(ciMethod* callee, BasicType t);
379   void append_unsafe_put_raw(ciMethod* callee, BasicType t);
380   void append_unsafe_CAS(ciMethod* callee);
381   void append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add);
382   void append_char_access(ciMethod* callee, bool is_store);
383 
<span class="line-modified">384   void print_inlining(ciMethod* callee, const char* msg, bool success = true);</span>
385 
386   void profile_call(ciMethod* callee, Value recv, ciKlass* predicted_holder, Values* obj_args, bool inlined);
387   void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = NULL, int bci = -1);
388   void profile_invocation(ciMethod* inlinee, ValueStack* state);
389 
390   // Shortcuts to profiling control.
391   bool is_profiling()          { return _compilation-&gt;is_profiling();          }
392   bool count_invocations()     { return _compilation-&gt;count_invocations();     }
393   bool count_backedges()       { return _compilation-&gt;count_backedges();       }
394   bool profile_branches()      { return _compilation-&gt;profile_branches();      }
395   bool profile_calls()         { return _compilation-&gt;profile_calls();         }
396   bool profile_inlined_calls() { return _compilation-&gt;profile_inlined_calls(); }
397   bool profile_checkcasts()    { return _compilation-&gt;profile_checkcasts();    }
398   bool profile_parameters()    { return _compilation-&gt;profile_parameters();    }
399   bool profile_arguments()     { return _compilation-&gt;profile_arguments();     }
400   bool profile_return()        { return _compilation-&gt;profile_return();        }
401 
402   Values* args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver);
403   Values* collect_args_for_profiling(Values* args, ciMethod* target, bool may_have_receiver);
404   void check_args_for_profiling(Values* obj_args, int expected);
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
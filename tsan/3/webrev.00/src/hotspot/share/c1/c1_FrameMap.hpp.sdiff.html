<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_FrameMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Compilation.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_FrameMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
168 
169   // for outgoing calls, these also update the reserved area to
170   // include space for arguments and any ABI area.
171   CallingConvention* c_calling_convention(const BasicTypeArray* signature);
172   CallingConvention* java_calling_convention(const BasicTypeArray* signature, bool outgoing);
173 
174   // deopt support
175   ByteSize sp_offset_for_orig_pc() { return sp_offset_for_monitor_base(_num_monitors); }
176 
177   static LIR_Opr as_opr(Register r) {
178     return LIR_OprFact::single_cpu(cpu_reg2rnr(r));
179   }
180   static LIR_Opr as_oop_opr(Register r) {
181     return LIR_OprFact::single_cpu_oop(cpu_reg2rnr(r));
182   }
183 
184   static LIR_Opr as_metadata_opr(Register r) {
185     return LIR_OprFact::single_cpu_metadata(cpu_reg2rnr(r));
186   }
187 




188   FrameMap(ciMethod* method, int monitors, int reserved_argument_area_size);
189   bool finalize_frame(int nof_slots);
190 
191   int   reserved_argument_area_size () const     { return _reserved_argument_area_size; }
192   int   framesize                   () const     { assert(_framesize != -1, &quot;hasn&#39;t been calculated&quot;); return _framesize; }
193   ByteSize framesize_in_bytes       () const     { return in_ByteSize(framesize() * 4); }
194   int   num_monitors                () const     { return _num_monitors; }
195   int   num_spills                  () const     { assert(_num_spills &gt;= 0, &quot;not set&quot;); return _num_spills; }
196   int   argcount              () const     { assert(_argcount &gt;= 0, &quot;not set&quot;); return _argcount; }
197 
198   int oop_map_arg_count() const { return _oop_map_arg_count; }
199 
200   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
201 
202   // convenience routines
203   Address address_for_slot(int index, int sp_adjust = 0) const {
204     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
205   }
206   Address address_for_double_slot(int index, int sp_adjust = 0) const {
207     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));
</pre>
</td>
<td>
<hr />
<pre>
168 
169   // for outgoing calls, these also update the reserved area to
170   // include space for arguments and any ABI area.
171   CallingConvention* c_calling_convention(const BasicTypeArray* signature);
172   CallingConvention* java_calling_convention(const BasicTypeArray* signature, bool outgoing);
173 
174   // deopt support
175   ByteSize sp_offset_for_orig_pc() { return sp_offset_for_monitor_base(_num_monitors); }
176 
177   static LIR_Opr as_opr(Register r) {
178     return LIR_OprFact::single_cpu(cpu_reg2rnr(r));
179   }
180   static LIR_Opr as_oop_opr(Register r) {
181     return LIR_OprFact::single_cpu_oop(cpu_reg2rnr(r));
182   }
183 
184   static LIR_Opr as_metadata_opr(Register r) {
185     return LIR_OprFact::single_cpu_metadata(cpu_reg2rnr(r));
186   }
187 
<span class="line-added">188   static LIR_Opr as_address_opr(Register r) {</span>
<span class="line-added">189     return LIR_OprFact::single_cpu_address(cpu_reg2rnr(r));</span>
<span class="line-added">190   }</span>
<span class="line-added">191 </span>
192   FrameMap(ciMethod* method, int monitors, int reserved_argument_area_size);
193   bool finalize_frame(int nof_slots);
194 
195   int   reserved_argument_area_size () const     { return _reserved_argument_area_size; }
196   int   framesize                   () const     { assert(_framesize != -1, &quot;hasn&#39;t been calculated&quot;); return _framesize; }
197   ByteSize framesize_in_bytes       () const     { return in_ByteSize(framesize() * 4); }
198   int   num_monitors                () const     { return _num_monitors; }
199   int   num_spills                  () const     { assert(_num_spills &gt;= 0, &quot;not set&quot;); return _num_spills; }
200   int   argcount              () const     { assert(_argcount &gt;= 0, &quot;not set&quot;); return _argcount; }
201 
202   int oop_map_arg_count() const { return _oop_map_arg_count; }
203 
204   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
205 
206   // convenience routines
207   Address address_for_slot(int index, int sp_adjust = 0) const {
208     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
209   }
210   Address address_for_double_slot(int index, int sp_adjust = 0) const {
211     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));
</pre>
</td>
</tr>
</table>
<center><a href="c1_Compilation.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
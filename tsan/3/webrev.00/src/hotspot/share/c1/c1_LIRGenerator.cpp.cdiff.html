<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,16 ***</span>
<span class="line-new-header">--- 34,18 ---</span>
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;ci/ciObjArray.hpp&quot;
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
<span class="line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #ifdef ASSERT
  #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  #else
  #define __ gen()-&gt;lir()-&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,17 ***</span>
  
  
  LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
    assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
  
<span class="line-modified">!   if (RoundFPResults &amp;&amp; UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {</span>
<span class="line-modified">!     LIR_Opr result = new_register(T_FLOAT);</span>
<span class="line-modified">!     set_vreg_flag(result, must_start_in_memory);</span>
<span class="line-modified">!     assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);</span>
<span class="line-modified">!     assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);</span>
<span class="line-modified">!     __ roundfp(opr, LIR_OprFact::illegalOpr, result);</span>
<span class="line-modified">!     return result;</span>
    }
    return opr;
  }
  
  
<span class="line-new-header">--- 898,23 ---</span>
  
  
  LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
    assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
  
<span class="line-modified">!   if (strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified">! #ifdef IA32</span>
<span class="line-modified">!     if (UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {</span>
<span class="line-modified">!       LIR_Opr result = new_register(T_FLOAT);</span>
<span class="line-modified">!       set_vreg_flag(result, must_start_in_memory);</span>
<span class="line-modified">!       assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);</span>
<span class="line-modified">!       assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);</span>
<span class="line-added">+       __ roundfp(opr, LIR_OprFact::illegalOpr, result);</span>
<span class="line-added">+       return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     Unimplemented();</span>
<span class="line-added">+ #endif // IA32</span>
    }
    return opr;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1298,11 ***</span>
    if (x-&gt;needs_null_check()) {
      info = state_for(x);
    }
  
    __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);
<span class="line-modified">!   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::intConst(0));</span>
    __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
  }
  
  
  // Example: Thread.currentThread()
<span class="line-new-header">--- 1306,11 ---</span>
    if (x-&gt;needs_null_check()) {
      info = state_for(x);
    }
  
    __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);
<span class="line-modified">!   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));</span>
    __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
  }
  
  
  // Example: Thread.currentThread()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1544,11 ***</span>
  
  void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
    assert(x-&gt;is_pinned(),&quot;&quot;);
    bool needs_range_check = x-&gt;compute_needs_range_check();
    bool use_length = x-&gt;length() != NULL;
<span class="line-modified">!   bool obj_store = x-&gt;elt_type() == T_ARRAY || x-&gt;elt_type() == T_OBJECT;</span>
    bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||
                                           !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||
                                           x-&gt;should_profile());
  
    LIRItem array(x-&gt;array(), this);
<span class="line-new-header">--- 1552,11 ---</span>
  
  void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
    assert(x-&gt;is_pinned(),&quot;&quot;);
    bool needs_range_check = x-&gt;compute_needs_range_check();
    bool use_length = x-&gt;length() != NULL;
<span class="line-modified">!   bool obj_store = is_reference_type(x-&gt;elt_type());</span>
    bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||
                                           !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||
                                           x-&gt;should_profile());
  
    LIRItem array(x-&gt;array(), this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1948,10 ***</span>
<span class="line-new-header">--- 1956,12 ---</span>
    }
  }
  
  
  void LIRGenerator::do_RoundFP(RoundFP* x) {
<span class="line-added">+   assert(strict_fp_requires_explicit_rounding, &quot;not required&quot;);</span>
<span class="line-added">+ </span>
    LIRItem input(x-&gt;input(), this);
    input.load_item();
    LIR_Opr input_opr = input.result();
    assert(input_opr-&gt;is_register(), &quot;why round if value is not in a register?&quot;);
    assert(input_opr-&gt;is_single_fpu() || input_opr-&gt;is_double_fpu(), &quot;input should be floating-point value&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2161,11 ***</span>
      decorators |= MO_SEQ_CST;
    }
    if (type == T_BOOLEAN) {
      decorators |= C1_MASK_BOOLEAN;
    }
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
  
    LIR_Opr result = rlock_result(x, type);
    access_load_at(decorators, type,
<span class="line-new-header">--- 2171,11 ---</span>
      decorators |= MO_SEQ_CST;
    }
    if (type == T_BOOLEAN) {
      decorators |= C1_MASK_BOOLEAN;
    }
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
  
    LIR_Opr result = rlock_result(x, type);
    access_load_at(decorators, type,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2188,11 ***</span>
    off.load_item();
  
    set_no_result(x);
  
    DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
    if (x-&gt;is_volatile()) {
      decorators |= MO_SEQ_CST;
    }
<span class="line-new-header">--- 2198,11 ---</span>
    off.load_item();
  
    set_no_result(x);
  
    DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
    if (x-&gt;is_volatile()) {
      decorators |= MO_SEQ_CST;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2205,11 ***</span>
    LIRItem off(x-&gt;offset(), this);
    LIRItem value(x-&gt;value(), this);
  
    DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
  
    LIR_Opr result;
    if (x-&gt;is_add()) {
<span class="line-new-header">--- 2215,11 ---</span>
    LIRItem off(x-&gt;offset(), this);
    LIRItem value(x-&gt;value(), this);
  
    DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
  
    LIR_Opr result;
    if (x-&gt;is_add()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2222,11 ***</span>
  
  void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
    int lng = x-&gt;length();
  
    for (int i = 0; i &lt; lng; i++) {
<span class="line-modified">!     SwitchRange* one_range = x-&gt;at(i);</span>
      int low_key = one_range-&gt;low_key();
      int high_key = one_range-&gt;high_key();
      BlockBegin* dest = one_range-&gt;sux();
      if (low_key == high_key) {
        __ cmp(lir_cond_equal, value, low_key);
<span class="line-new-header">--- 2232,11 ---</span>
  
  void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
    int lng = x-&gt;length();
  
    for (int i = 0; i &lt; lng; i++) {
<span class="line-modified">!     C1SwitchRange* one_range = x-&gt;at(i);</span>
      int low_key = one_range-&gt;low_key();
      int high_key = one_range-&gt;high_key();
      BlockBegin* dest = one_range-&gt;sux();
      if (low_key == high_key) {
        __ cmp(lir_cond_equal, value, low_key);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2254,22 ***</span>
    int len = x-&gt;length();
    if (len &gt; 0) {
      BlockBegin* sux = x-&gt;sux_at(0);
      int key = x-&gt;lo_key();
      BlockBegin* default_sux = x-&gt;default_sux();
<span class="line-modified">!     SwitchRange* range = new SwitchRange(key, sux);</span>
      for (int i = 0; i &lt; len; i++, key++) {
        BlockBegin* new_sux = x-&gt;sux_at(i);
        if (sux == new_sux) {
          // still in same range
          range-&gt;set_high_key(key);
        } else {
          // skip tests which explicitly dispatch to the default
          if (sux != default_sux) {
            res-&gt;append(range);
          }
<span class="line-modified">!         range = new SwitchRange(key, new_sux);</span>
        }
        sux = new_sux;
      }
      if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
    }
<span class="line-new-header">--- 2264,22 ---</span>
    int len = x-&gt;length();
    if (len &gt; 0) {
      BlockBegin* sux = x-&gt;sux_at(0);
      int key = x-&gt;lo_key();
      BlockBegin* default_sux = x-&gt;default_sux();
<span class="line-modified">!     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
      for (int i = 0; i &lt; len; i++, key++) {
        BlockBegin* new_sux = x-&gt;sux_at(i);
        if (sux == new_sux) {
          // still in same range
          range-&gt;set_high_key(key);
        } else {
          // skip tests which explicitly dispatch to the default
          if (sux != default_sux) {
            res-&gt;append(range);
          }
<span class="line-modified">!         range = new C1SwitchRange(key, new_sux);</span>
        }
        sux = new_sux;
      }
      if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2283,11 ***</span>
    int len = x-&gt;length();
    if (len &gt; 0) {
      BlockBegin* default_sux = x-&gt;default_sux();
      int key = x-&gt;key_at(0);
      BlockBegin* sux = x-&gt;sux_at(0);
<span class="line-modified">!     SwitchRange* range = new SwitchRange(key, sux);</span>
      for (int i = 1; i &lt; len; i++) {
        int new_key = x-&gt;key_at(i);
        BlockBegin* new_sux = x-&gt;sux_at(i);
        if (key+1 == new_key &amp;&amp; sux == new_sux) {
          // still in same range
<span class="line-new-header">--- 2293,11 ---</span>
    int len = x-&gt;length();
    if (len &gt; 0) {
      BlockBegin* default_sux = x-&gt;default_sux();
      int key = x-&gt;key_at(0);
      BlockBegin* sux = x-&gt;sux_at(0);
<span class="line-modified">!     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
      for (int i = 1; i &lt; len; i++) {
        int new_key = x-&gt;key_at(i);
        BlockBegin* new_sux = x-&gt;sux_at(i);
        if (key+1 == new_key &amp;&amp; sux == new_sux) {
          // still in same range
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2295,11 ***</span>
        } else {
          // skip tests which explicitly dispatch to the default
          if (range-&gt;sux() != default_sux) {
            res-&gt;append(range);
          }
<span class="line-modified">!         range = new SwitchRange(new_key, new_sux);</span>
        }
        key = new_key;
        sux = new_sux;
      }
      if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
<span class="line-new-header">--- 2305,11 ---</span>
        } else {
          // skip tests which explicitly dispatch to the default
          if (range-&gt;sux() != default_sux) {
            res-&gt;append(range);
          }
<span class="line-modified">!         range = new C1SwitchRange(new_key, new_sux);</span>
        }
        key = new_key;
        sux = new_sux;
      }
      if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2598,11 ***</span>
        LIR_Opr mdp = LIR_OprFact::illegalOpr;
        for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
          LIR_Opr src = args-&gt;at(i);
          assert(!src-&gt;is_illegal(), &quot;check&quot;);
          BasicType t = src-&gt;type();
<span class="line-modified">!         if (t == T_OBJECT || t == T_ARRAY) {</span>
            intptr_t profiled_k = parameters-&gt;type(j);
            Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
            ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
                                          in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
                                          profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
<span class="line-new-header">--- 2608,11 ---</span>
        LIR_Opr mdp = LIR_OprFact::illegalOpr;
        for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
          LIR_Opr src = args-&gt;at(i);
          assert(!src-&gt;is_illegal(), &quot;check&quot;);
          BasicType t = src-&gt;type();
<span class="line-modified">!         if (is_reference_type(t)) {</span>
            intptr_t profiled_k = parameters-&gt;type(j);
            Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
            ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
                                          in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
                                          profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3277,11 ***</span>
<span class="line-new-header">--- 3287,18 ---</span>
    }
  }
  
  void LIRGenerator::increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci) {
    if (compilation()-&gt;count_backedges()) {
<span class="line-added">+ #if defined(X86) &amp;&amp; !defined(_LP64)</span>
<span class="line-added">+     // BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.</span>
<span class="line-added">+     LIR_Opr left_copy = new_register(left-&gt;type());</span>
<span class="line-added">+     __ move(left, left_copy);</span>
<span class="line-added">+     __ cmp(cond, left_copy, right);</span>
<span class="line-added">+ #else</span>
      __ cmp(cond, left, right);
<span class="line-added">+ #endif</span>
      LIR_Opr step = new_register(T_INT);
      LIR_Opr plus_one = LIR_OprFact::intConst(InvocationCounter::count_increment);
      LIR_Opr zero = LIR_OprFact::intConst(0);
      __ cmove(cond,
          (left_bci &lt; bci) ? plus_one : zero,
</pre>
<center><a href="c1_LIRAssembler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
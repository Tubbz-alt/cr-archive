<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRGenerator.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_LIRGENERATOR_HPP
 26 #define SHARE_C1_C1_LIRGENERATOR_HPP
 27 
 28 #include &quot;c1/c1_Decorators.hpp&quot;
 29 #include &quot;c1/c1_Instruction.hpp&quot;
 30 #include &quot;c1/c1_LIR.hpp&quot;
 31 #include &quot;ci/ciMethodData.hpp&quot;
 32 #include &quot;gc/shared/barrierSet.hpp&quot;
 33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;utilities/sizes.hpp&quot;
 36 
 37 class BarrierSetC1;
 38 
 39 // The classes responsible for code emission and register allocation
 40 
 41 
 42 class LIRGenerator;
 43 class LIREmitter;
 44 class Invoke;
<a name="2" id="anc2"></a><span class="line-removed"> 45 class SwitchRange;</span>
 46 class LIRItem;
 47 
 48 typedef GrowableArray&lt;LIRItem*&gt; LIRItemList;
 49 
<a name="3" id="anc3"></a><span class="line-modified"> 50 class SwitchRange: public CompilationResourceObj {</span>
 51  private:
 52   int _low_key;
 53   int _high_key;
 54   BlockBegin* _sux;
 55  public:
<a name="4" id="anc4"></a><span class="line-modified"> 56   SwitchRange(int start_key, BlockBegin* sux): _low_key(start_key), _high_key(start_key), _sux(sux) {}</span>
 57   void set_high_key(int key) { _high_key = key; }
 58 
 59   int high_key() const { return _high_key; }
 60   int low_key() const { return _low_key; }
 61   BlockBegin* sux() const { return _sux; }
 62 };
 63 
<a name="5" id="anc5"></a><span class="line-modified"> 64 typedef GrowableArray&lt;SwitchRange*&gt; SwitchRangeArray;</span>
<span class="line-modified"> 65 typedef GrowableArray&lt;SwitchRange*&gt; SwitchRangeList;</span>
 66 
 67 class ResolveNode;
 68 
 69 typedef GrowableArray&lt;ResolveNode*&gt; NodeList;
 70 
 71 // Node objects form a directed graph of LIR_Opr
 72 // Edges between Nodes represent moves from one Node to its destinations
 73 class ResolveNode: public CompilationResourceObj {
 74  private:
 75   LIR_Opr    _operand;       // the source or destinaton
 76   NodeList   _destinations;  // for the operand
 77   bool       _assigned;      // Value assigned to this Node?
 78   bool       _visited;       // Node already visited?
 79   bool       _start_node;    // Start node already visited?
 80 
 81  public:
 82   ResolveNode(LIR_Opr operand)
 83     : _operand(operand)
 84     , _assigned(false)
 85     , _visited(false)
 86     , _start_node(false) {};
 87 
 88   // accessors
 89   LIR_Opr operand() const           { return _operand; }
 90   int no_of_destinations() const    { return _destinations.length(); }
 91   ResolveNode* destination_at(int i)     { return _destinations.at(i); }
 92   bool assigned() const             { return _assigned; }
 93   bool visited() const              { return _visited; }
 94   bool start_node() const           { return _start_node; }
 95 
 96   // modifiers
 97   void append(ResolveNode* dest)         { _destinations.append(dest); }
 98   void set_assigned()               { _assigned = true; }
 99   void set_visited()                { _visited = true; }
100   void set_start_node()             { _start_node = true; }
101 };
102 
103 
104 // This is shared state to be used by the PhiResolver so the operand
105 // arrays don&#39;t have to be reallocated for each resolution.
106 class PhiResolverState: public CompilationResourceObj {
107   friend class PhiResolver;
108 
109  private:
110   NodeList _virtual_operands; // Nodes where the operand is a virtual register
111   NodeList _other_operands;   // Nodes where the operand is not a virtual register
112   NodeList _vreg_table;       // Mapping from virtual register to Node
113 
114  public:
115   PhiResolverState() {}
116 
117   void reset();
118 };
119 
120 
121 // class used to move value of phi operand to phi function
122 class PhiResolver: public CompilationResourceObj {
123  private:
124   LIRGenerator*     _gen;
125   PhiResolverState&amp; _state; // temporary state cached by LIRGenerator
126 
127   ResolveNode*   _loop;
128   LIR_Opr _temp;
129 
130   // access to shared state arrays
131   NodeList&amp; virtual_operands() { return _state._virtual_operands; }
132   NodeList&amp; other_operands()   { return _state._other_operands;   }
133   NodeList&amp; vreg_table()       { return _state._vreg_table;       }
134 
135   ResolveNode* create_node(LIR_Opr opr, bool source);
136   ResolveNode* source_node(LIR_Opr opr)      { return create_node(opr, true); }
137   ResolveNode* destination_node(LIR_Opr opr) { return create_node(opr, false); }
138 
139   void emit_move(LIR_Opr src, LIR_Opr dest);
140   void move_to_temp(LIR_Opr src);
141   void move_temp_to(LIR_Opr dest);
142   void move(ResolveNode* src, ResolveNode* dest);
143 
144   LIRGenerator* gen() {
145     return _gen;
146   }
147 
148  public:
149   PhiResolver(LIRGenerator* _lir_gen);
150   ~PhiResolver();
151 
152   void move(LIR_Opr src, LIR_Opr dest);
153 };
154 
155 
156 // only the classes below belong in the same file
157 class LIRGenerator: public InstructionVisitor, public BlockClosure {
158  // LIRGenerator should never get instatiated on the heap.
159  private:
160   void* operator new(size_t size) throw();
161   void* operator new[](size_t size) throw();
162   void operator delete(void* p) { ShouldNotReachHere(); }
163   void operator delete[](void* p) { ShouldNotReachHere(); }
164 
165   Compilation*  _compilation;
166   ciMethod*     _method;    // method that we are compiling
167   PhiResolverState  _resolver_state;
168   BlockBegin*   _block;
169   int           _virtual_register_number;
170   Values        _instruction_for_operand;
171   BitMap2D      _vreg_flags; // flags which can be set on a per-vreg basis
172   LIR_List*     _lir;
173 
174   LIRGenerator* gen() {
175     return this;
176   }
177 
178   void print_if_not_loaded(const NewInstance* new_instance) PRODUCT_RETURN;
179 
180  public:
181 #ifdef ASSERT
182   LIR_List* lir(const char * file, int line) const {
183     _lir-&gt;set_file_and_line(file, line);
184     return _lir;
185   }
186 #endif
187   LIR_List* lir() const {
188     return _lir;
189   }
190 
191  private:
192   // a simple cache of constants used within a block
193   GrowableArray&lt;LIR_Const*&gt;       _constants;
194   LIR_OprList                     _reg_for_constants;
195   Values                          _unpinned_constants;
196 
197   friend class PhiResolver;
198 
199  public:
200   // unified bailout support
201   void bailout(const char* msg) const            { compilation()-&gt;bailout(msg); }
202   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
203 
204   void block_do_prolog(BlockBegin* block);
205   void block_do_epilog(BlockBegin* block);
206 
207   // register allocation
208   LIR_Opr rlock(Value instr);                      // lock a free register
209   LIR_Opr rlock_result(Value instr);
210   LIR_Opr rlock_result(Value instr, BasicType type);
211   LIR_Opr rlock_byte(BasicType type);
212   LIR_Opr rlock_callee_saved(BasicType type);
213 
214   // get a constant into a register and get track of what register was used
215   LIR_Opr load_constant(Constant* x);
216   LIR_Opr load_constant(LIR_Const* constant);
217 
218   // Given an immediate value, return an operand usable in logical ops.
219   LIR_Opr load_immediate(int x, BasicType type);
220 
221   void  set_result(Value x, LIR_Opr opr)           {
222     assert(opr-&gt;is_valid(), &quot;must set to valid value&quot;);
223     assert(x-&gt;operand()-&gt;is_illegal(), &quot;operand should never change&quot;);
224     assert(!opr-&gt;is_register() || opr-&gt;is_virtual(), &quot;should never set result to a physical register&quot;);
225     x-&gt;set_operand(opr);
226     assert(opr == x-&gt;operand(), &quot;must be&quot;);
227     if (opr-&gt;is_virtual()) {
228       _instruction_for_operand.at_put_grow(opr-&gt;vreg_number(), x, NULL);
229     }
230   }
231   void  set_no_result(Value x)                     { assert(!x-&gt;has_uses(), &quot;can&#39;t have use&quot;); x-&gt;clear_operand(); }
232 
233   friend class LIRItem;
234 
235   LIR_Opr round_item(LIR_Opr opr);
236   LIR_Opr force_to_spill(LIR_Opr value, BasicType t);
237 
238   PhiResolverState&amp; resolver_state() { return _resolver_state; }
239 
240   void  move_to_phi(PhiResolver* resolver, Value cur_val, Value sux_val);
241   void  move_to_phi(ValueStack* cur_state);
242 
243   // platform dependent
244   LIR_Opr getThreadPointer();
245 
246  private:
247   // code emission
248   void do_ArithmeticOp_Long(ArithmeticOp* x);
249   void do_ArithmeticOp_Int (ArithmeticOp* x);
250   void do_ArithmeticOp_FPU (ArithmeticOp* x);
251 
252   void do_RegisterFinalizer(Intrinsic* x);
253   void do_isInstance(Intrinsic* x);
254   void do_isPrimitive(Intrinsic* x);
255   void do_getClass(Intrinsic* x);
256   void do_currentThread(Intrinsic* x);
257   void do_FmaIntrinsic(Intrinsic* x);
258   void do_MathIntrinsic(Intrinsic* x);
259   void do_LibmIntrinsic(Intrinsic* x);
260   void do_ArrayCopy(Intrinsic* x);
261   void do_CompareAndSwap(Intrinsic* x, ValueType* type);
262   void do_NIOCheckIndex(Intrinsic* x);
263   void do_FPIntrinsics(Intrinsic* x);
264   void do_Reference_get(Intrinsic* x);
265   void do_update_CRC32(Intrinsic* x);
266   void do_update_CRC32C(Intrinsic* x);
267   void do_vectorizedMismatch(Intrinsic* x);
268 
269  public:
270   LIR_Opr call_runtime(BasicTypeArray* signature, LIRItemList* args, address entry, ValueType* result_type, CodeEmitInfo* info);
271   LIR_Opr call_runtime(BasicTypeArray* signature, LIR_OprList* args, address entry, ValueType* result_type, CodeEmitInfo* info);
272 
273   // convenience functions
274   LIR_Opr call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info);
275   LIR_Opr call_runtime(Value arg1, Value arg2, address entry, ValueType* result_type, CodeEmitInfo* info);
276 
277   // Access API
278 
279  private:
280   BarrierSetC1 *_barrier_set;
281 
282  public:
283   void access_store_at(DecoratorSet decorators, BasicType type,
284                        LIRItem&amp; base, LIR_Opr offset, LIR_Opr value,
285                        CodeEmitInfo* patch_info = NULL, CodeEmitInfo* store_emit_info = NULL);
286 
287   void access_load_at(DecoratorSet decorators, BasicType type,
288                       LIRItem&amp; base, LIR_Opr offset, LIR_Opr result,
289                       CodeEmitInfo* patch_info = NULL, CodeEmitInfo* load_emit_info = NULL);
290 
291   void access_load(DecoratorSet decorators, BasicType type,
292                    LIR_Opr addr, LIR_Opr result);
293 
294   LIR_Opr access_atomic_cmpxchg_at(DecoratorSet decorators, BasicType type,
295                                    LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
296 
297   LIR_Opr access_atomic_xchg_at(DecoratorSet decorators, BasicType type,
298                                 LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value);
299 
300   LIR_Opr access_atomic_add_at(DecoratorSet decorators, BasicType type,
301                                LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value);
302 
303   LIR_Opr access_resolve(DecoratorSet decorators, LIR_Opr obj);
304 
305   // These need to guarantee JMM volatile semantics are preserved on each platform
306   // and requires one implementation per architecture.
307   LIR_Opr atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
308   LIR_Opr atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; new_value);
309   LIR_Opr atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; new_value);
310 
311 #ifdef CARDTABLEBARRIERSET_POST_BARRIER_HELPER
312   virtual void CardTableBarrierSet_post_barrier_helper(LIR_OprDesc* addr, LIR_Const* card_table_base);
313 #endif
314 
315   // specific implementations
316   void array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci);
317 
318   static LIR_Opr result_register_for(ValueType* type, bool callee = false);
319 
320   ciObject* get_jobject_constant(Value value);
321 
322   LIRItemList* invoke_visit_arguments(Invoke* x);
323   void invoke_load_arguments(Invoke* x, LIRItemList* args, const LIR_OprList* arg_list);
324 
325   void trace_block_entry(BlockBegin* block);
326 
327   // volatile field operations are never patchable because a klass
328   // must be loaded to know it&#39;s volatile which means that the offset
329   // it always known as well.
330   void volatile_field_store(LIR_Opr value, LIR_Address* address, CodeEmitInfo* info);
331   void volatile_field_load(LIR_Address* address, LIR_Opr result, CodeEmitInfo* info);
332 
333   void put_Object_unsafe(LIR_Opr src, LIR_Opr offset, LIR_Opr data, BasicType type, bool is_volatile);
334   void get_Object_unsafe(LIR_Opr dest, LIR_Opr src, LIR_Opr offset, BasicType type, bool is_volatile);
335 
336   void arithmetic_call_op (Bytecodes::Code code, LIR_Opr result, LIR_OprList* args);
337 
338   void increment_counter(address counter, BasicType type, int step = 1);
339   void increment_counter(LIR_Address* addr, int step = 1);
340 
341   // is_strictfp is only needed for mul and div (and only generates different code on i486)
342   void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp, CodeEmitInfo* info = NULL);
343   // machine dependent.  returns true if it emitted code for the multiply
344   bool strength_reduce_multiply(LIR_Opr left, jint constant, LIR_Opr result, LIR_Opr tmp);
345 
346   void store_stack_parameter (LIR_Opr opr, ByteSize offset_from_sp_in_bytes);
347 
348   void klass2reg_with_patching(LIR_Opr r, ciMetadata* obj, CodeEmitInfo* info, bool need_resolve = false);
349 
350   // this loads the length and compares against the index
351   void array_range_check          (LIR_Opr array, LIR_Opr index, CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info);
352   // For java.nio.Buffer.checkIndex
353   void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);
354 
355   void arithmetic_op_int  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp);
356   void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL);
357   void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp = LIR_OprFact::illegalOpr);
358 
359   void shift_op   (Bytecodes::Code code, LIR_Opr dst_reg, LIR_Opr value, LIR_Opr count, LIR_Opr tmp);
360 
361   void logic_op   (Bytecodes::Code code, LIR_Opr dst_reg, LIR_Opr left, LIR_Opr right);
362 
363   void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info);
364   void monitor_exit  (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no);
365 
366   void new_instance    (LIR_Opr  dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr  scratch1, LIR_Opr  scratch2, LIR_Opr  scratch3,  LIR_Opr scratch4, LIR_Opr  klass_reg, CodeEmitInfo* info);
367 
368   // machine dependent
369   void cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info);
370   void cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info);
371 
372   void arraycopy_helper(Intrinsic* x, int* flags, ciArrayKlass** expected_type);
373 
374   // returns a LIR_Address to address an array location.  May also
375   // emit some code as part of address calculation.  If
376   // needs_card_mark is true then compute the full address for use by
377   // both the store and the card mark.
378   LIR_Address* generate_address(LIR_Opr base,
379                                 LIR_Opr index, int shift,
380                                 int disp,
381                                 BasicType type);
382   LIR_Address* generate_address(LIR_Opr base, int disp, BasicType type) {
383     return generate_address(base, LIR_OprFact::illegalOpr, 0, disp, type);
384   }
385   LIR_Address* emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr, BasicType type);
386 
387   // the helper for generate_address
388   void add_large_constant(LIR_Opr src, int c, LIR_Opr dest);
389 
390   // machine preferences and characteristics
391   bool can_inline_as_constant(Value i S390_ONLY(COMMA int bits = 20)) const;
392   bool can_inline_as_constant(LIR_Const* c) const;
393   bool can_store_as_constant(Value i, BasicType type) const;
394 
395   LIR_Opr safepoint_poll_register();
396 
397   void profile_branch(If* if_instr, If::Condition cond);
398   void increment_event_counter_impl(CodeEmitInfo* info,
399                                     ciMethod *method, LIR_Opr step, int frequency,
400                                     int bci, bool backedge, bool notify);
401   void increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge);
402   void increment_invocation_counter(CodeEmitInfo *info) {
403     if (compilation()-&gt;count_invocations()) {
404       increment_event_counter(info, LIR_OprFact::intConst(InvocationCounter::count_increment), InvocationEntryBci, false);
405     }
406   }
407   void increment_backedge_counter(CodeEmitInfo* info, int bci) {
408     if (compilation()-&gt;count_backedges()) {
409       increment_event_counter(info, LIR_OprFact::intConst(InvocationCounter::count_increment), bci, true);
410     }
411   }
412   void increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci);
413   void increment_backedge_counter(CodeEmitInfo* info, LIR_Opr step, int bci) {
414     if (compilation()-&gt;count_backedges()) {
415       increment_event_counter(info, step, bci, true);
416     }
417   }
418   void decrement_age(CodeEmitInfo* info);
419   CodeEmitInfo* state_for(Instruction* x, ValueStack* state, bool ignore_xhandler = false);
420   CodeEmitInfo* state_for(Instruction* x);
421 
422   // allocates a virtual register for this instruction if
423   // one isn&#39;t already allocated.  Only for Phi and Local.
424   LIR_Opr operand_for_instruction(Instruction *x);
425 
426   void set_block(BlockBegin* block)              { _block = block; }
427 
428   void block_prolog(BlockBegin* block);
429   void block_epilog(BlockBegin* block);
430 
431   void do_root (Instruction* instr);
432   void walk    (Instruction* instr);
433 
434   void bind_block_entry(BlockBegin* block);
435   void start_block(BlockBegin* block);
436 
437   LIR_Opr new_register(BasicType type);
438   LIR_Opr new_register(Value value)              { return new_register(as_BasicType(value-&gt;type())); }
439   LIR_Opr new_register(ValueType* type)          { return new_register(as_BasicType(type)); }
440 
441   // returns a register suitable for doing pointer math
442   LIR_Opr new_pointer_register() {
443 #ifdef _LP64
444     return new_register(T_LONG);
445 #else
446     return new_register(T_INT);
447 #endif
448   }
449 
450   static LIR_Condition lir_cond(If::Condition cond) {
451     LIR_Condition l = lir_cond_unknown;
452     switch (cond) {
453     case If::eql: l = lir_cond_equal;        break;
454     case If::neq: l = lir_cond_notEqual;     break;
455     case If::lss: l = lir_cond_less;         break;
456     case If::leq: l = lir_cond_lessEqual;    break;
457     case If::geq: l = lir_cond_greaterEqual; break;
458     case If::gtr: l = lir_cond_greater;      break;
459     case If::aeq: l = lir_cond_aboveEqual;   break;
460     case If::beq: l = lir_cond_belowEqual;   break;
461     default: fatal(&quot;You must pass valid If::Condition&quot;);
462     };
463     return l;
464   }
465 
466 #ifdef __SOFTFP__
467   void do_soft_float_compare(If *x);
468 #endif // __SOFTFP__
469 
470   SwitchRangeArray* create_lookup_ranges(TableSwitch* x);
471   SwitchRangeArray* create_lookup_ranges(LookupSwitch* x);
472   void do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux);
473 
474 #ifdef JFR_HAVE_INTRINSICS
475   void do_ClassIDIntrinsic(Intrinsic* x);
476   void do_getEventWriter(Intrinsic* x);
477 #endif
478 
479   void do_RuntimeCall(address routine, Intrinsic* x);
480 
481   ciKlass* profile_type(ciMethodData* md, int md_first_offset, int md_offset, intptr_t profiled_k,
482                         Value arg, LIR_Opr&amp; mdp, bool not_null, ciKlass* signature_at_call_k,
483                         ciKlass* callee_signature_k);
484   void profile_arguments(ProfileCall* x);
485   void profile_parameters(Base* x);
486   void profile_parameters_at_call(ProfileCall* x);
487   LIR_Opr mask_boolean(LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info);
488   LIR_Opr maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info);
489 
490  public:
491   Compilation*  compilation() const              { return _compilation; }
492   FrameMap*     frame_map() const                { return _compilation-&gt;frame_map(); }
493   ciMethod*     method() const                   { return _method; }
494   BlockBegin*   block() const                    { return _block; }
495   IRScope*      scope() const                    { return block()-&gt;scope(); }
496 
497   int max_virtual_register_number() const        { return _virtual_register_number; }
498 
499   void block_do(BlockBegin* block);
500 
501   // Flags that can be set on vregs
502   enum VregFlag {
503       must_start_in_memory = 0  // needs to be assigned a memory location at beginning, but may then be loaded in a register
504     , callee_saved     = 1    // must be in a callee saved register
505     , byte_reg         = 2    // must be in a byte register
506     , num_vreg_flags
507 
508   };
509 
510   LIRGenerator(Compilation* compilation, ciMethod* method)
511     : _compilation(compilation)
512     , _method(method)
513     , _virtual_register_number(LIR_OprDesc::vreg_base)
514     , _vreg_flags(num_vreg_flags)
515     , _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c1()) {
516   }
517 
518   // for virtual registers, maps them back to Phi&#39;s or Local&#39;s
519   Instruction* instruction_for_opr(LIR_Opr opr);
520   Instruction* instruction_for_vreg(int reg_num);
521 
522   void set_vreg_flag   (int vreg_num, VregFlag f);
523   bool is_vreg_flag_set(int vreg_num, VregFlag f);
524   void set_vreg_flag   (LIR_Opr opr,  VregFlag f) { set_vreg_flag(opr-&gt;vreg_number(), f); }
525   bool is_vreg_flag_set(LIR_Opr opr,  VregFlag f) { return is_vreg_flag_set(opr-&gt;vreg_number(), f); }
526 
527   // statics
528   static LIR_Opr exceptionOopOpr();
529   static LIR_Opr exceptionPcOpr();
530   static LIR_Opr divInOpr();
531   static LIR_Opr divOutOpr();
532   static LIR_Opr remOutOpr();
533 #ifdef S390
534   // On S390 we can do ldiv, lrem without RT call.
535   static LIR_Opr ldivInOpr();
536   static LIR_Opr ldivOutOpr();
537   static LIR_Opr lremOutOpr();
538 #endif
539   static LIR_Opr shiftCountOpr();
540   LIR_Opr syncLockOpr();
541   LIR_Opr syncTempOpr();
542   LIR_Opr atomicLockOpr();
543 
544   // returns a register suitable for saving the thread in a
545   // call_runtime_leaf if one is needed.
546   LIR_Opr getThreadTemp();
547 
548   // visitor functionality
549   virtual void do_Phi            (Phi*             x);
550   virtual void do_Local          (Local*           x);
551   virtual void do_Constant       (Constant*        x);
552   virtual void do_LoadField      (LoadField*       x);
553   virtual void do_StoreField     (StoreField*      x);
554   virtual void do_ArrayLength    (ArrayLength*     x);
555   virtual void do_LoadIndexed    (LoadIndexed*     x);
556   virtual void do_StoreIndexed   (StoreIndexed*    x);
557   virtual void do_NegateOp       (NegateOp*        x);
558   virtual void do_ArithmeticOp   (ArithmeticOp*    x);
559   virtual void do_ShiftOp        (ShiftOp*         x);
560   virtual void do_LogicOp        (LogicOp*         x);
561   virtual void do_CompareOp      (CompareOp*       x);
562   virtual void do_IfOp           (IfOp*            x);
563   virtual void do_Convert        (Convert*         x);
564   virtual void do_NullCheck      (NullCheck*       x);
565   virtual void do_TypeCast       (TypeCast*        x);
566   virtual void do_Invoke         (Invoke*          x);
567   virtual void do_NewInstance    (NewInstance*     x);
568   virtual void do_NewTypeArray   (NewTypeArray*    x);
569   virtual void do_NewObjectArray (NewObjectArray*  x);
570   virtual void do_NewMultiArray  (NewMultiArray*   x);
571   virtual void do_CheckCast      (CheckCast*       x);
572   virtual void do_InstanceOf     (InstanceOf*      x);
573   virtual void do_MonitorEnter   (MonitorEnter*    x);
574   virtual void do_MonitorExit    (MonitorExit*     x);
575   virtual void do_Intrinsic      (Intrinsic*       x);
576   virtual void do_BlockBegin     (BlockBegin*      x);
577   virtual void do_Goto           (Goto*            x);
578   virtual void do_If             (If*              x);
579   virtual void do_IfInstanceOf   (IfInstanceOf*    x);
580   virtual void do_TableSwitch    (TableSwitch*     x);
581   virtual void do_LookupSwitch   (LookupSwitch*    x);
582   virtual void do_Return         (Return*          x);
583   virtual void do_Throw          (Throw*           x);
584   virtual void do_Base           (Base*            x);
585   virtual void do_OsrEntry       (OsrEntry*        x);
586   virtual void do_ExceptionObject(ExceptionObject* x);
587   virtual void do_RoundFP        (RoundFP*         x);
588   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);
589   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);
590   virtual void do_UnsafeGetObject(UnsafeGetObject* x);
591   virtual void do_UnsafePutObject(UnsafePutObject* x);
592   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);
593   virtual void do_ProfileCall    (ProfileCall*     x);
594   virtual void do_ProfileReturnType (ProfileReturnType* x);
595   virtual void do_ProfileInvoke  (ProfileInvoke*   x);
596   virtual void do_RuntimeCall    (RuntimeCall*     x);
597   virtual void do_MemBar         (MemBar*          x);
598   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x);
599 #ifdef ASSERT
600   virtual void do_Assert         (Assert*          x);
601 #endif
602 
603 #ifdef C1_LIRGENERATOR_MD_HPP
604 #include C1_LIRGENERATOR_MD_HPP
605 #endif
606 };
607 
608 
609 class LIRItem: public CompilationResourceObj {
610  private:
611   Value         _value;
612   LIRGenerator* _gen;
613   LIR_Opr       _result;
614   bool          _destroys_register;
615   LIR_Opr       _new_result;
616 
617   LIRGenerator* gen() const { return _gen; }
618 
619  public:
620   LIRItem(Value value, LIRGenerator* gen) {
621     _destroys_register = false;
622     _gen = gen;
623     set_instruction(value);
624   }
625 
626   LIRItem(LIRGenerator* gen) {
627     _destroys_register = false;
628     _gen = gen;
629     _result = LIR_OprFact::illegalOpr;
630     set_instruction(NULL);
631   }
632 
633   void set_instruction(Value value) {
634     _value = value;
635     _result = LIR_OprFact::illegalOpr;
636     if (_value != NULL) {
637       _gen-&gt;walk(_value);
638       _result = _value-&gt;operand();
639     }
640     _new_result = LIR_OprFact::illegalOpr;
641   }
642 
643   Value value() const          { return _value;          }
644   ValueType* type() const      { return value()-&gt;type(); }
645   LIR_Opr result()             {
646     assert(!_destroys_register || (!_result-&gt;is_register() || _result-&gt;is_virtual()),
647            &quot;shouldn&#39;t use set_destroys_register with physical regsiters&quot;);
648     if (_destroys_register &amp;&amp; _result-&gt;is_register()) {
649       if (_new_result-&gt;is_illegal()) {
650         _new_result = _gen-&gt;new_register(type());
651         gen()-&gt;lir()-&gt;move(_result, _new_result);
652       }
653       return _new_result;
654     } else {
655       return _result;
656     }
657     return _result;
658   }
659 
660   void set_result(LIR_Opr opr);
661 
662   void load_item();
663   void load_byte_item();
664   void load_nonconstant(S390_ONLY(int bits = 20));
665   // load any values which can&#39;t be expressed as part of a single store instruction
666   void load_for_store(BasicType store_type);
667   void load_item_force(LIR_Opr reg);
668 
669   void dont_load_item() {
670     // do nothing
671   }
672 
673   void set_destroys_register() {
674     _destroys_register = true;
675   }
676 
677   bool is_constant() const { return value()-&gt;as_Constant() != NULL; }
678   bool is_stack()          { return result()-&gt;is_stack(); }
679   bool is_register()       { return result()-&gt;is_register(); }
680 
681   ciObject* get_jobject_constant() const;
682   jint      get_jint_constant() const;
683   jlong     get_jlong_constant() const;
684   jfloat    get_jfloat_constant() const;
685   jdouble   get_jdouble_constant() const;
686   jint      get_address_constant() const;
687 };
688 
689 #endif // SHARE_C1_C1_LIRGENERATOR_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
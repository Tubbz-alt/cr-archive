<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/c1/c1_Runtime1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_RangeCheckElimination.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Runtime1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,10 +35,11 @@</span>
  #include &quot;code/codeBlob.hpp&quot;
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;code/vtableStubs.hpp&quot;
<span class="udiff-line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,17 +47,17 @@</span>
  #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,10 +292,16 @@</span>
  const char* Runtime1::name_for_address(address entry) {
    for (int id = 0; id &lt; number_of_ids; id++) {
      if (entry == entry_for((StubID)id)) return name_for((StubID)id);
    }
  
<span class="udiff-line-added">+   BarrierSetC1* bsc1 = BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
<span class="udiff-line-added">+   const char* name = bsc1-&gt;rtcall_name_for_address(entry);</span>
<span class="udiff-line-added">+   if (name != NULL) {</span>
<span class="udiff-line-added">+     return name;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  #define FUNCTION_CASE(a, f) \
    if ((intptr_t)a == CAST_FROM_FN_PTR(intptr_t, f))  return #f
  
    FUNCTION_CASE(entry, os::javaTimeMillis);
    FUNCTION_CASE(entry, os::javaTimeNanos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,11 +579,11 @@</span>
        stringStream tempst;
        assert(nm-&gt;method() != NULL, &quot;Unexpected NULL method()&quot;);
        tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
                     &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
                     nm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<span class="udiff-line-modified-removed">-       Exceptions::log_exception(exception, tempst);</span>
<span class="udiff-line-modified-added">+       Exceptions::log_exception(exception, tempst.as_string());</span>
      }
      // for AbortVMOnException flag
      Exceptions::debug_check_abort(exception);
  
      // Clear out the exception oop and pc since looking up an
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -696,23 +703,15 @@</span>
    NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(thread, obj);
<span class="udiff-line-modified-removed">-   if (UseBiasedLocking) {</span>
<span class="udiff-line-modified-removed">-     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::fast_enter(h_obj, lock-&gt;lock(), true, CHECK);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (UseFastLocking) {</span>
<span class="udiff-line-removed">-       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="udiff-line-removed">-       assert(obj == lock-&gt;obj(), &quot;must match&quot;);</span>
<span class="udiff-line-removed">-       ObjectSynchronizer::slow_enter(h_obj, lock-&gt;lock(), THREAD);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       lock-&gt;set_obj(obj);</span>
<span class="udiff-line-removed">-       ObjectSynchronizer::fast_enter(h_obj, lock-&gt;lock(), false, THREAD);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (!UseFastLocking) {</span>
<span class="udiff-line-modified-added">+     lock-&gt;set_obj(obj);</span>
    }
<span class="udiff-line-added">+   assert(obj == lock-&gt;obj(), &quot;must match&quot;);</span>
<span class="udiff-line-added">+   ObjectSynchronizer::enter(h_obj, lock-&gt;lock(), THREAD);</span>
  JRT_END
  
  
  JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
    NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,16 +720,11 @@</span>
    // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
    EXCEPTION_MARK;
  
    oop obj = lock-&gt;obj();
    assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
<span class="udiff-line-modified-removed">-   if (UseFastLocking) {</span>
<span class="udiff-line-removed">-     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::slow_exit(obj, lock-&gt;lock(), THREAD);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::fast_exit(obj, lock-&gt;lock(), THREAD);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   ObjectSynchronizer::exit(obj, lock-&gt;lock(), THREAD);</span>
  JRT_END
  
  // Cf. OptoRuntime::deoptimize_caller_frame
  JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
    // Called from within the owner thread, so no need for safepoint
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1044,11 +1038,11 @@</span>
    }
  
    // Now copy code back
  
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml_patch (Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml_patch (THREAD, Patching_lock, Mutex::_no_safepoint_check_flag);</span>
      //
      // Deoptimization may have happened while we waited for the lock.
      // In that case we don&#39;t bother to do any patching we just return
      // and let the deopt happen
      if (!caller_is_deopted()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1263,11 +1257,11 @@</span>
    }
  
    // If we are patching in a non-perm oop, make sure the nmethod
    // is on the right list.
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml_code (CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml_code (THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
      guarantee(nm != NULL, &quot;only nmethods can contain non-perm oops&quot;);
  
      // Since we&#39;ve patched some oops in the nmethod,
      // (re)register it with the heap.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1426,11 +1420,11 @@</span>
  
    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
    assert (nm != NULL, &quot;no more nmethod?&quot;);
    nm-&gt;make_not_entrant();
  
<span class="udiff-line-modified-removed">-   methodHandle m(nm-&gt;method());</span>
<span class="udiff-line-modified-added">+   methodHandle m(thread, nm-&gt;method());</span>
    MethodData* mdo = m-&gt;method_data();
  
    if (mdo == NULL &amp;&amp; !HAS_PENDING_EXCEPTION) {
      // Build an MDO.  Ignore errors like OutOfMemory;
      // that simply means we won&#39;t have an MDO to update.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1447,11 +1441,11 @@</span>
    }
  
    if (TracePredicateFailedTraps) {
      stringStream ss1, ss2;
      vframeStream vfst(thread);
<span class="udiff-line-modified-removed">-     methodHandle inlinee = methodHandle(vfst.method());</span>
<span class="udiff-line-modified-added">+     Method* inlinee = vfst.method();</span>
      inlinee-&gt;print_short_name(&amp;ss1);
      m-&gt;print_short_name(&amp;ss2);
      tty-&gt;print_cr(&quot;Predicate failed trap in method %s at bci %d inlined in %s at pc &quot; INTPTR_FORMAT, ss1.as_string(), vfst.bci(), ss2.as_string(), p2i(caller_frame.pc()));
    }
  
</pre>
<center><a href="c1_RangeCheckElimination.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_InstructionPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 27 #include &quot;c1/c1_ValueStack.hpp&quot;
 28 #include &quot;ci/ciArray.hpp&quot;
 29 #include &quot;ci/ciInstance.hpp&quot;
 30 #include &quot;ci/ciObject.hpp&quot;
 31 
 32 
 33 #ifndef PRODUCT
 34 
 35 const char* InstructionPrinter::basic_type_name(BasicType type) {
<a name="2" id="anc2"></a><span class="line-modified"> 36   switch (type) {</span>
<span class="line-modified"> 37     case T_BOOLEAN: return &quot;boolean&quot;;</span>
<span class="line-modified"> 38     case T_BYTE   : return &quot;byte&quot;;</span>
<span class="line-removed"> 39     case T_CHAR   : return &quot;char&quot;;</span>
<span class="line-removed"> 40     case T_SHORT  : return &quot;short&quot;;</span>
<span class="line-removed"> 41     case T_INT    : return &quot;int&quot;;</span>
<span class="line-removed"> 42     case T_LONG   : return &quot;long&quot;;</span>
<span class="line-removed"> 43     case T_FLOAT  : return &quot;float&quot;;</span>
<span class="line-removed"> 44     case T_DOUBLE : return &quot;double&quot;;</span>
<span class="line-removed"> 45     case T_ARRAY  : return &quot;array&quot;;</span>
<span class="line-removed"> 46     case T_OBJECT : return &quot;object&quot;;</span>
<span class="line-removed"> 47     default       : return &quot;???&quot;;</span>
 48   }
<a name="3" id="anc3"></a>
 49 }
 50 
 51 
 52 const char* InstructionPrinter::cond_name(If::Condition cond) {
 53   switch (cond) {
 54     case If::eql: return &quot;==&quot;;
 55     case If::neq: return &quot;!=&quot;;
 56     case If::lss: return &quot;&lt;&quot;;
 57     case If::leq: return &quot;&lt;=&quot;;
 58     case If::gtr: return &quot;&gt;&quot;;
 59     case If::geq: return &quot;&gt;=&quot;;
 60     case If::aeq: return &quot;|&gt;=|&quot;;
 61     case If::beq: return &quot;|&lt;=|&quot;;
 62     default:
 63       ShouldNotReachHere();
 64       return NULL;
 65   }
 66 }
 67 
 68 
 69 const char* InstructionPrinter::op_name(Bytecodes::Code op) {
 70   switch (op) {
 71     // arithmetic ops
 72     case Bytecodes::_iadd : // fall through
 73     case Bytecodes::_ladd : // fall through
 74     case Bytecodes::_fadd : // fall through
 75     case Bytecodes::_dadd : return &quot;+&quot;;
 76     case Bytecodes::_isub : // fall through
 77     case Bytecodes::_lsub : // fall through
 78     case Bytecodes::_fsub : // fall through
 79     case Bytecodes::_dsub : return &quot;-&quot;;
 80     case Bytecodes::_imul : // fall through
 81     case Bytecodes::_lmul : // fall through
 82     case Bytecodes::_fmul : // fall through
 83     case Bytecodes::_dmul : return &quot;*&quot;;
 84     case Bytecodes::_idiv : // fall through
 85     case Bytecodes::_ldiv : // fall through
 86     case Bytecodes::_fdiv : // fall through
 87     case Bytecodes::_ddiv : return &quot;/&quot;;
 88     case Bytecodes::_irem : // fall through
 89     case Bytecodes::_lrem : // fall through
 90     case Bytecodes::_frem : // fall through
 91     case Bytecodes::_drem : return &quot;%&quot;;
 92     // shift ops
 93     case Bytecodes::_ishl : // fall through
 94     case Bytecodes::_lshl : return &quot;&lt;&lt;&quot;;
 95     case Bytecodes::_ishr : // fall through
 96     case Bytecodes::_lshr : return &quot;&gt;&gt;&quot;;
 97     case Bytecodes::_iushr: // fall through
 98     case Bytecodes::_lushr: return &quot;&gt;&gt;&gt;&quot;;
 99     // logic ops
100     case Bytecodes::_iand : // fall through
101     case Bytecodes::_land : return &quot;&amp;&quot;;
102     case Bytecodes::_ior  : // fall through
103     case Bytecodes::_lor  : return &quot;|&quot;;
104     case Bytecodes::_ixor : // fall through
105     case Bytecodes::_lxor : return &quot;^&quot;;
106     default               : return Bytecodes::name(op);
107   }
108 }
109 
110 
111 bool InstructionPrinter::is_illegal_phi(Value v) {
112   Phi* phi = v ? v-&gt;as_Phi() : NULL;
113   if (phi &amp;&amp; phi-&gt;is_illegal()) {
114     return true;
115   }
116   return false;
117 }
118 
119 
120 bool InstructionPrinter::is_phi_of_block(Value v, BlockBegin* b) {
121   Phi* phi = v ? v-&gt;as_Phi() : NULL;
122   return phi &amp;&amp; phi-&gt;block() == b;
123 }
124 
125 
126 void InstructionPrinter::print_klass(ciKlass* klass) {
127   klass-&gt;name()-&gt;print_symbol_on(output());
128 }
129 
130 
131 void InstructionPrinter::print_object(Value obj) {
132   ValueType* type = obj-&gt;type();
133   if (type-&gt;as_ObjectConstant() != NULL) {
134     ciObject* value = type-&gt;as_ObjectConstant()-&gt;value();
135     if (value-&gt;is_null_object()) {
136       output()-&gt;print(&quot;null&quot;);
137     } else if (!value-&gt;is_loaded()) {
138       output()-&gt;print(&quot;&lt;unloaded object &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(value));
139     } else {
140       output()-&gt;print(&quot;&lt;object &quot; INTPTR_FORMAT &quot; klass=&quot;, p2i(value-&gt;constant_encoding()));
141       print_klass(value-&gt;klass());
142       output()-&gt;print(&quot;&gt;&quot;);
143     }
144   } else if (type-&gt;as_InstanceConstant() != NULL) {
145     ciInstance* value = type-&gt;as_InstanceConstant()-&gt;value();
146     if (value-&gt;is_loaded()) {
147       output()-&gt;print(&quot;&lt;instance &quot; INTPTR_FORMAT &quot; klass=&quot;, p2i(value-&gt;constant_encoding()));
148       print_klass(value-&gt;klass());
149       output()-&gt;print(&quot;&gt;&quot;);
150     } else {
151       output()-&gt;print(&quot;&lt;unloaded instance &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(value));
152     }
153   } else if (type-&gt;as_ArrayConstant() != NULL) {
154     output()-&gt;print(&quot;&lt;array &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(type-&gt;as_ArrayConstant()-&gt;value()-&gt;constant_encoding()));
155   } else if (type-&gt;as_ClassConstant() != NULL) {
156     ciInstanceKlass* klass = type-&gt;as_ClassConstant()-&gt;value();
157     if (!klass-&gt;is_loaded()) {
158       output()-&gt;print(&quot;&lt;unloaded&gt; &quot;);
159     }
160     output()-&gt;print(&quot;class &quot;);
161     print_klass(klass);
162   } else if (type-&gt;as_MethodConstant() != NULL) {
163     ciMethod* m = type-&gt;as_MethodConstant()-&gt;value();
164     output()-&gt;print(&quot;&lt;method %s.%s&gt;&quot;, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
165   } else {
166     output()-&gt;print(&quot;???&quot;);
167   }
168 }
169 
170 
171 void InstructionPrinter::print_temp(Value value) {
172   output()-&gt;print(&quot;%c%d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id());
173 }
174 
175 
176 void InstructionPrinter::print_field(AccessField* field) {
177   print_value(field-&gt;obj());
178   output()-&gt;print(&quot;._%d&quot;, field-&gt;offset());
179 }
180 
181 
182 void InstructionPrinter::print_indexed(AccessIndexed* indexed) {
183   print_value(indexed-&gt;array());
184   output()-&gt;put(&#39;[&#39;);
185   print_value(indexed-&gt;index());
186   output()-&gt;put(&#39;]&#39;);
187   if (indexed-&gt;length() != NULL) {
188     output()-&gt;put(&#39;(&#39;);
189     print_value(indexed-&gt;length());
190     output()-&gt;put(&#39;)&#39;);
191   }
192 }
193 
194 
195 void InstructionPrinter::print_monitor(AccessMonitor* monitor) {
196   output()-&gt;print(&quot;monitor[%d](&quot;, monitor-&gt;monitor_no());
197   print_value(monitor-&gt;obj());
198   output()-&gt;put(&#39;)&#39;);
199 }
200 
201 
202 void InstructionPrinter::print_op2(Op2* instr) {
203   print_value(instr-&gt;x());
204   output()-&gt;print(&quot; %s &quot;, op_name(instr-&gt;op()));
205   print_value(instr-&gt;y());
206 }
207 
208 
209 void InstructionPrinter::print_value(Value value) {
210   if (value == NULL) {
211     output()-&gt;print(&quot;NULL&quot;);
212   } else {
213     print_temp(value);
214   }
215 }
216 
217 
218 void InstructionPrinter::print_instr(Instruction* instr) {
219   instr-&gt;visit(this);
220 }
221 
222 
223 void InstructionPrinter::print_stack(ValueStack* stack) {
224   int start_position = output()-&gt;position();
225   if (stack-&gt;stack_is_empty()) {
226     output()-&gt;print(&quot;empty stack&quot;);
227   } else {
228     output()-&gt;print(&quot;stack [&quot;);
229     for (int i = 0; i &lt; stack-&gt;stack_size();) {
230       if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
231       output()-&gt;print(&quot;%d:&quot;, i);
232       Value value = stack-&gt;stack_at_inc(i);
233       print_value(value);
234       Phi* phi = value-&gt;as_Phi();
235       if (phi != NULL) {
236         if (phi-&gt;operand()-&gt;is_valid()) {
237           output()-&gt;print(&quot; &quot;);
238           phi-&gt;operand()-&gt;print(output());
239         }
240       }
241     }
242     output()-&gt;put(&#39;]&#39;);
243   }
244   if (!stack-&gt;no_active_locks()) {
245     // print out the lines on the line below this
246     // one at the same indentation level.
247     output()-&gt;cr();
248     fill_to(start_position, &#39; &#39;);
249     output()-&gt;print(&quot;locks [&quot;);
250     for (int i = i = 0; i &lt; stack-&gt;locks_size(); i++) {
251       Value t = stack-&gt;lock_at(i);
252       if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
253       output()-&gt;print(&quot;%d:&quot;, i);
254       if (t == NULL) {
255         // synchronized methods push null on the lock stack
256         output()-&gt;print(&quot;this&quot;);
257       } else {
258         print_value(t);
259       }
260     }
261     output()-&gt;print(&quot;]&quot;);
262   }
263 }
264 
265 
266 void InstructionPrinter::print_inline_level(BlockBegin* block) {
267   output()-&gt;print_cr(&quot;inlining depth %d&quot;, block-&gt;scope()-&gt;level());
268 }
269 
270 
271 void InstructionPrinter::print_unsafe_op(UnsafeOp* op, const char* name) {
272   output()-&gt;print(&quot;%s&quot;, name);
273   output()-&gt;print(&quot;.(&quot;);
274 }
275 
276 void InstructionPrinter::print_unsafe_raw_op(UnsafeRawOp* op, const char* name) {
277   print_unsafe_op(op, name);
278   output()-&gt;print(&quot;base &quot;);
279   print_value(op-&gt;base());
280   if (op-&gt;has_index()) {
281     output()-&gt;print(&quot;, index &quot;); print_value(op-&gt;index());
282     output()-&gt;print(&quot;, log2_scale %d&quot;, op-&gt;log2_scale());
283   }
284 }
285 
286 
287 void InstructionPrinter::print_unsafe_object_op(UnsafeObjectOp* op, const char* name) {
288   print_unsafe_op(op, name);
289   print_value(op-&gt;object());
290   output()-&gt;print(&quot;, &quot;);
291   print_value(op-&gt;offset());
292 }
293 
294 
295 void InstructionPrinter::print_phi(int i, Value v, BlockBegin* b) {
296   Phi* phi = v-&gt;as_Phi();
297   output()-&gt;print(&quot;%2d  &quot;, i);
298   print_value(v);
299   // print phi operands
300   if (phi &amp;&amp; phi-&gt;block() == b) {
301     output()-&gt;print(&quot; [&quot;);
302     for (int j = 0; j &lt; phi-&gt;operand_count(); j ++) {
303       output()-&gt;print(&quot; &quot;);
304       Value opd = phi-&gt;operand_at(j);
305       if (opd) print_value(opd);
306       else output()-&gt;print(&quot;NULL&quot;);
307     }
308     output()-&gt;print(&quot;] &quot;);
309   }
310   print_alias(v);
311 }
312 
313 
314 void InstructionPrinter::print_alias(Value v) {
315   if (v != v-&gt;subst()) {
316     output()-&gt;print(&quot;alias &quot;); print_value(v-&gt;subst());
317   }
318 }
319 
320 
321 void InstructionPrinter::fill_to(int pos, char filler) {
322   while (output()-&gt;position() &lt; pos) output()-&gt;put(filler);
323 }
324 
325 
326 void InstructionPrinter::print_head() {
327   const char filler = &#39;_&#39;;
328   fill_to(bci_pos  , filler); output()-&gt;print(&quot;bci&quot;  );
329   fill_to(use_pos  , filler); output()-&gt;print(&quot;use&quot;  );
330   fill_to(temp_pos , filler); output()-&gt;print(&quot;tid&quot;  );
331   fill_to(instr_pos, filler); output()-&gt;print(&quot;instr&quot;);
332   fill_to(end_pos  , filler);
333   output()-&gt;cr();
334 }
335 
336 
337 void InstructionPrinter::print_line(Instruction* instr) {
338   // print instruction data on one line
339   if (instr-&gt;is_pinned()) output()-&gt;put(&#39;.&#39;);
<a name="4" id="anc4"></a><span class="line-modified">340   fill_to(bci_pos  ); output()-&gt;print(&quot;%d&quot;, instr-&gt;printable_bci());</span>


341   fill_to(use_pos  ); output()-&gt;print(&quot;%d&quot;, instr-&gt;use_count());
342   fill_to(temp_pos ); print_temp(instr);
343   fill_to(instr_pos); print_instr(instr);
344   output()-&gt;cr();
345   // add a line for StateSplit instructions w/ non-empty stacks
346   // (make it robust so we can print incomplete instructions)
347   StateSplit* split = instr-&gt;as_StateSplit();
348   if (split != NULL &amp;&amp; split-&gt;state() != NULL &amp;&amp; !split-&gt;state()-&gt;stack_is_empty()) {
349     fill_to(instr_pos); print_stack(split-&gt;state());
350     output()-&gt;cr();
351   }
352 }
353 
354 
355 void InstructionPrinter::do_Phi(Phi* x) {
356   output()-&gt;print(&quot;phi function&quot;);  // make that more detailed later
357   if (x-&gt;is_illegal())
358     output()-&gt;print(&quot; (illegal)&quot;);
359 }
360 
361 
362 void InstructionPrinter::do_Local(Local* x) {
363   output()-&gt;print(&quot;local[index %d]&quot;, x-&gt;java_index());
364 }
365 
366 
367 void InstructionPrinter::do_Constant(Constant* x) {
368   ValueType* t = x-&gt;type();
369   switch (t-&gt;tag()) {
370     case intTag    : output()-&gt;print(&quot;%d&quot;  , t-&gt;as_IntConstant   ()-&gt;value());    break;
371     case longTag   : output()-&gt;print(JLONG_FORMAT, t-&gt;as_LongConstant()-&gt;value()); output()-&gt;print(&quot;L&quot;); break;
372     case floatTag  : output()-&gt;print(&quot;%g&quot;  , t-&gt;as_FloatConstant ()-&gt;value());    break;
373     case doubleTag : output()-&gt;print(&quot;%gD&quot; , t-&gt;as_DoubleConstant()-&gt;value());    break;
374     case objectTag : print_object(x);                                        break;
375     case addressTag: output()-&gt;print(&quot;bci:%d&quot;, t-&gt;as_AddressConstant()-&gt;value()); break;
376     default        : output()-&gt;print(&quot;???&quot;);                                      break;
377   }
378 }
379 
380 
381 void InstructionPrinter::do_LoadField(LoadField* x) {
382   print_field(x);
383   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;field()-&gt;type()-&gt;basic_type()));
384   output()-&gt;print(&quot; %s&quot;, x-&gt;field()-&gt;name()-&gt;as_utf8());
385 }
386 
387 
388 void InstructionPrinter::do_StoreField(StoreField* x) {
389   print_field(x);
390   output()-&gt;print(&quot; := &quot;);
391   print_value(x-&gt;value());
392   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;field()-&gt;type()-&gt;basic_type()));
393   output()-&gt;print(&quot; %s&quot;, x-&gt;field()-&gt;name()-&gt;as_utf8());
394 }
395 
396 
397 void InstructionPrinter::do_ArrayLength(ArrayLength* x) {
398   print_value(x-&gt;array());
399   output()-&gt;print(&quot;.length&quot;);
400 }
401 
402 
403 void InstructionPrinter::do_LoadIndexed(LoadIndexed* x) {
404   print_indexed(x);
405   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;elt_type()));
406   if (x-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) {
407     output()-&gt;print(&quot; [rc]&quot;);
408   }
409 }
410 
411 
412 void InstructionPrinter::do_StoreIndexed(StoreIndexed* x) {
413   print_indexed(x);
414   output()-&gt;print(&quot; := &quot;);
415   print_value(x-&gt;value());
416   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;elt_type()));
417   if (x-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) {
418     output()-&gt;print(&quot; [rc]&quot;);
419   }
420 }
421 
422 void InstructionPrinter::do_NegateOp(NegateOp* x) {
423   output()-&gt;put(&#39;-&#39;);
424   print_value(x-&gt;x());
425 }
426 
427 
428 void InstructionPrinter::do_ArithmeticOp(ArithmeticOp* x) {
429   print_op2(x);
430 }
431 
432 
433 void InstructionPrinter::do_ShiftOp(ShiftOp* x) {
434   print_op2(x);
435 }
436 
437 
438 void InstructionPrinter::do_LogicOp(LogicOp* x) {
439   print_op2(x);
440 }
441 
442 
443 void InstructionPrinter::do_CompareOp(CompareOp* x) {
444   print_op2(x);
445 }
446 
447 
448 void InstructionPrinter::do_IfOp(IfOp* x) {
449   print_value(x-&gt;x());
450   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
451   print_value(x-&gt;y());
452   output()-&gt;print(&quot; ? &quot;);
453   print_value(x-&gt;tval());
454   output()-&gt;print(&quot; : &quot;);
455   print_value(x-&gt;fval());
456 }
457 
458 
459 void InstructionPrinter::do_Convert(Convert* x) {
460   output()-&gt;print(&quot;%s(&quot;, Bytecodes::name(x-&gt;op()));
461   print_value(x-&gt;value());
462   output()-&gt;put(&#39;)&#39;);
463 }
464 
465 
466 void InstructionPrinter::do_NullCheck(NullCheck* x) {
467   output()-&gt;print(&quot;null_check(&quot;);
468   print_value(x-&gt;obj());
469   output()-&gt;put(&#39;)&#39;);
470   if (!x-&gt;can_trap()) {
471     output()-&gt;print(&quot; (eliminated)&quot;);
472   }
473 }
474 
475 
476 void InstructionPrinter::do_TypeCast(TypeCast* x) {
477   output()-&gt;print(&quot;type_cast(&quot;);
478   print_value(x-&gt;obj());
479   output()-&gt;print(&quot;) &quot;);
480   if (x-&gt;declared_type()-&gt;is_klass())
481     print_klass(x-&gt;declared_type()-&gt;as_klass());
482   else
483     output()-&gt;print(&quot;%s&quot;, type2name(x-&gt;declared_type()-&gt;basic_type()));
484 }
485 
486 
487 void InstructionPrinter::do_Invoke(Invoke* x) {
488   if (x-&gt;receiver() != NULL) {
489     print_value(x-&gt;receiver());
490     output()-&gt;print(&quot;.&quot;);
491   }
492 
493   output()-&gt;print(&quot;%s(&quot;, Bytecodes::name(x-&gt;code()));
494   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
495     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
496     print_value(x-&gt;argument_at(i));
497   }
498   output()-&gt;print_cr(&quot;)&quot;);
499   fill_to(instr_pos);
500   output()-&gt;print(&quot;%s.%s%s&quot;,
501              x-&gt;target()-&gt;holder()-&gt;name()-&gt;as_utf8(),
502              x-&gt;target()-&gt;name()-&gt;as_utf8(),
503              x-&gt;target()-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
504 }
505 
506 
507 void InstructionPrinter::do_NewInstance(NewInstance* x) {
508   output()-&gt;print(&quot;new instance &quot;);
509   print_klass(x-&gt;klass());
510 }
511 
512 
513 void InstructionPrinter::do_NewTypeArray(NewTypeArray* x) {
514   output()-&gt;print(&quot;new %s array [&quot;, basic_type_name(x-&gt;elt_type()));
515   print_value(x-&gt;length());
516   output()-&gt;put(&#39;]&#39;);
517 }
518 
519 
520 void InstructionPrinter::do_NewObjectArray(NewObjectArray* x) {
521   output()-&gt;print(&quot;new object array [&quot;);
522   print_value(x-&gt;length());
523   output()-&gt;print(&quot;] &quot;);
524   print_klass(x-&gt;klass());
525 }
526 
527 
528 void InstructionPrinter::do_NewMultiArray(NewMultiArray* x) {
529   output()-&gt;print(&quot;new multi array [&quot;);
530   Values* dims = x-&gt;dims();
531   for (int i = 0; i &lt; dims-&gt;length(); i++) {
532     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
533     print_value(dims-&gt;at(i));
534   }
535   output()-&gt;print(&quot;] &quot;);
536   print_klass(x-&gt;klass());
537 }
538 
539 
540 void InstructionPrinter::do_MonitorEnter(MonitorEnter* x) {
541   output()-&gt;print(&quot;enter &quot;);
542   print_monitor(x);
543 }
544 
545 
546 void InstructionPrinter::do_MonitorExit(MonitorExit* x) {
547   output()-&gt;print(&quot;exit &quot;);
548   print_monitor(x);
549 }
550 
551 
552 void InstructionPrinter::do_Intrinsic(Intrinsic* x) {
553   const char* name = vmIntrinsics::name_at(x-&gt;id());
554   if (name[0] == &#39;_&#39;)  name++;  // strip leading bug from _hashCode, etc.
555   const char* kname = vmSymbols::name_for(vmIntrinsics::class_for(x-&gt;id()));
556   if (strchr(name, &#39;_&#39;) == NULL) {
557     kname = NULL;
558   } else {
559     const char* kptr = strrchr(kname, &#39;/&#39;);
560     if (kptr != NULL)  kname = kptr + 1;
561   }
562   if (kname == NULL)
563     output()-&gt;print(&quot;%s(&quot;, name);
564   else
565     output()-&gt;print(&quot;%s.%s(&quot;, kname, name);
566   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
567     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
568     print_value(x-&gt;argument_at(i));
569   }
570   output()-&gt;put(&#39;)&#39;);
571 }
572 
573 
574 void InstructionPrinter::do_BlockBegin(BlockBegin* x) {
575   // print block id
576   BlockEnd* end = x-&gt;end();
577   output()-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
578 
579   // print flags
580   bool printed_flag = false;
581   if (x-&gt;is_set(BlockBegin::std_entry_flag)) {
582     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
583     output()-&gt;print(&quot;S&quot;); printed_flag = true;
584   }
585   if (x-&gt;is_set(BlockBegin::osr_entry_flag)) {
586     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
587     output()-&gt;print(&quot;O&quot;); printed_flag = true;
588   }
589   if (x-&gt;is_set(BlockBegin::exception_entry_flag)) {
590     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
591     output()-&gt;print(&quot;E&quot;); printed_flag = true;
592   }
593   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
594     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
595     output()-&gt;print(&quot;s&quot;); printed_flag = true;
596   }
597   if (x-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
598     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
599     output()-&gt;print(&quot;LH&quot;); printed_flag = true;
600   }
601   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
602     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
603     output()-&gt;print(&quot;b&quot;); printed_flag = true;
604   }
605   if (x-&gt;is_set(BlockBegin::was_visited_flag)) {
606     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
607     output()-&gt;print(&quot;V&quot;); printed_flag = true;
608   }
609   if (printed_flag) output()-&gt;print(&quot;) &quot;);
610 
611   // print block bci range
612   output()-&gt;print(&quot;[%d, %d]&quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
613 
614   // print block successors
615   if (end != NULL &amp;&amp; end-&gt;number_of_sux() &gt; 0) {
616     output()-&gt;print(&quot; -&gt;&quot;);
617     for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
618       output()-&gt;print(&quot; B%d&quot;, end-&gt;sux_at(i)-&gt;block_id());
619     }
620   }
621   // print exception handlers
622   if (x-&gt;number_of_exception_handlers() &gt; 0) {
623     output()-&gt;print(&quot; (xhandlers &quot;);
624     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
625       if (i &gt; 0) output()-&gt;print(&quot; &quot;);
626       output()-&gt;print(&quot;B%d&quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
627     }
628     output()-&gt;put(&#39;)&#39;);
629   }
630 
631   // print dominator block
632   if (x-&gt;dominator() != NULL) {
633     output()-&gt;print(&quot; dom B%d&quot;, x-&gt;dominator()-&gt;block_id());
634   }
635 
636   // print predecessors and successors
637   if (x-&gt;successors()-&gt;length() &gt; 0) {
638     output()-&gt;print(&quot; sux:&quot;);
639     for (int i = 0; i &lt; x-&gt;successors()-&gt;length(); i ++) {
640       output()-&gt;print(&quot; B%d&quot;, x-&gt;successors()-&gt;at(i)-&gt;block_id());
641     }
642   }
643 
644   if (x-&gt;number_of_preds() &gt; 0) {
645     output()-&gt;print(&quot; pred:&quot;);
646     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
647       output()-&gt;print(&quot; B%d&quot;, x-&gt;pred_at(i)-&gt;block_id());
648     }
649   }
650 
651   if (!_print_phis) {
652     return;
653   }
654 
655   // print phi functions
656   bool has_phis_in_locals = false;
657   bool has_phis_on_stack = false;
658 
659   if (x-&gt;end() &amp;&amp; x-&gt;end()-&gt;state()) {
660     ValueStack* state = x-&gt;state();
661 
662     int i = 0;
663     while (!has_phis_on_stack &amp;&amp; i &lt; state-&gt;stack_size()) {
664       Value v = state-&gt;stack_at_inc(i);
665       has_phis_on_stack = is_phi_of_block(v, x);
666     }
667 
668     do {
669       for (i = 0; !has_phis_in_locals &amp;&amp; i &lt; state-&gt;locals_size();) {
670         Value v = state-&gt;local_at(i);
671         has_phis_in_locals = is_phi_of_block(v, x);
672         // also ignore illegal HiWords
673         if (v &amp;&amp; !v-&gt;type()-&gt;is_illegal()) i += v-&gt;type()-&gt;size(); else i ++;
674       }
675       state = state-&gt;caller_state();
676     } while (state != NULL);
677 
678   }
679 
680   // print values in locals
681   if (has_phis_in_locals) {
682     output()-&gt;cr(); output()-&gt;print_cr(&quot;Locals:&quot;);
683 
684     ValueStack* state = x-&gt;state();
685     do {
686       for (int i = 0; i &lt; state-&gt;locals_size();) {
687         Value v = state-&gt;local_at(i);
688         if (v) {
689           print_phi(i, v, x); output()-&gt;cr();
690           // also ignore illegal HiWords
691           i += (v-&gt;type()-&gt;is_illegal() ? 1 : v-&gt;type()-&gt;size());
692         } else {
693           i ++;
694         }
695       }
696       output()-&gt;cr();
697       state = state-&gt;caller_state();
698     } while (state != NULL);
699   }
700 
701   // print values on stack
702   if (has_phis_on_stack) {
703     output()-&gt;print_cr(&quot;Stack:&quot;);
704     int i = 0;
705     while (i &lt; x-&gt;state()-&gt;stack_size()) {
706       int o = i;
707       Value v = x-&gt;state()-&gt;stack_at_inc(i);
708       if (v) {
709         print_phi(o, v, x); output()-&gt;cr();
710       }
711     }
712   }
713 }
714 
715 
716 void InstructionPrinter::do_CheckCast(CheckCast* x) {
717   output()-&gt;print(&quot;checkcast(&quot;);
718   print_value(x-&gt;obj());
719   output()-&gt;print(&quot;) &quot;);
720   print_klass(x-&gt;klass());
721 }
722 
723 
724 void InstructionPrinter::do_InstanceOf(InstanceOf* x) {
725   output()-&gt;print(&quot;instanceof(&quot;);
726   print_value(x-&gt;obj());
727   output()-&gt;print(&quot;) &quot;);
728   print_klass(x-&gt;klass());
729 }
730 
731 
732 void InstructionPrinter::do_Goto(Goto* x) {
733   output()-&gt;print(&quot;goto B%d&quot;, x-&gt;default_sux()-&gt;block_id());
734   if (x-&gt;is_safepoint()) output()-&gt;print(&quot; (safepoint)&quot;);
735 }
736 
737 
738 void InstructionPrinter::do_If(If* x) {
739   output()-&gt;print(&quot;if &quot;);
740   print_value(x-&gt;x());
741   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
742   print_value(x-&gt;y());
743   output()-&gt;print(&quot; then B%d else B%d&quot;, x-&gt;sux_at(0)-&gt;block_id(), x-&gt;sux_at(1)-&gt;block_id());
744   if (x-&gt;is_safepoint()) output()-&gt;print(&quot; (safepoint)&quot;);
745 }
746 
747 
748 void InstructionPrinter::do_IfInstanceOf(IfInstanceOf* x) {
749   output()-&gt;print(&quot;&lt;IfInstanceOf&gt;&quot;);
750 }
751 
752 
753 void InstructionPrinter::do_TableSwitch(TableSwitch* x) {
754   output()-&gt;print(&quot;tableswitch &quot;);
755   if (x-&gt;is_safepoint()) output()-&gt;print(&quot;(safepoint) &quot;);
756   print_value(x-&gt;tag());
757   output()-&gt;cr();
758   int l = x-&gt;length();
759   for (int i = 0; i &lt; l; i++) {
760     fill_to(instr_pos);
761     output()-&gt;print_cr(&quot;case %5d: B%d&quot;, x-&gt;lo_key() + i, x-&gt;sux_at(i)-&gt;block_id());
762   }
763   fill_to(instr_pos);
764   output()-&gt;print(&quot;default   : B%d&quot;, x-&gt;default_sux()-&gt;block_id());
765 }
766 
767 
768 void InstructionPrinter::do_LookupSwitch(LookupSwitch* x) {
769   output()-&gt;print(&quot;lookupswitch &quot;);
770   if (x-&gt;is_safepoint()) output()-&gt;print(&quot;(safepoint) &quot;);
771   print_value(x-&gt;tag());
772   output()-&gt;cr();
773   int l = x-&gt;length();
774   for (int i = 0; i &lt; l; i++) {
775     fill_to(instr_pos);
776     output()-&gt;print_cr(&quot;case %5d: B%d&quot;, x-&gt;key_at(i), x-&gt;sux_at(i)-&gt;block_id());
777   }
778   fill_to(instr_pos);
779   output()-&gt;print(&quot;default   : B%d&quot;, x-&gt;default_sux()-&gt;block_id());
780 }
781 
782 
783 void InstructionPrinter::do_Return(Return* x) {
784   if (x-&gt;result() == NULL) {
785     output()-&gt;print(&quot;return&quot;);
786   } else {
787     output()-&gt;print(&quot;%creturn &quot;, x-&gt;type()-&gt;tchar());
788     print_value(x-&gt;result());
789   }
790 }
791 
792 
793 void InstructionPrinter::do_Throw(Throw* x) {
794   output()-&gt;print(&quot;throw &quot;);
795   print_value(x-&gt;exception());
796 }
797 
798 
799 void InstructionPrinter::do_Base(Base* x) {
800   output()-&gt;print(&quot;std entry B%d&quot;, x-&gt;std_entry()-&gt;block_id());
801   if (x-&gt;number_of_sux() &gt; 1) {
802     output()-&gt;print(&quot; osr entry B%d&quot;, x-&gt;osr_entry()-&gt;block_id());
803   }
804 }
805 
806 
807 void InstructionPrinter::do_OsrEntry(OsrEntry* x) {
808   output()-&gt;print(&quot;osr entry&quot;);
809 }
810 
811 
812 void InstructionPrinter::do_ExceptionObject(ExceptionObject* x) {
813   output()-&gt;print(&quot;incoming exception&quot;);
814 }
815 
816 
817 void InstructionPrinter::do_RoundFP(RoundFP* x) {
818   output()-&gt;print(&quot;round_fp &quot;);
819   print_value(x-&gt;input());
820 }
821 
822 
823 void InstructionPrinter::do_UnsafeGetRaw(UnsafeGetRaw* x) {
824   print_unsafe_raw_op(x, &quot;UnsafeGetRaw&quot;);
825   output()-&gt;put(&#39;)&#39;);
826 }
827 
828 
829 void InstructionPrinter::do_UnsafePutRaw(UnsafePutRaw* x) {
830   print_unsafe_raw_op(x, &quot;UnsafePutRaw&quot;);
831   output()-&gt;print(&quot;, value &quot;);
832   print_value(x-&gt;value());
833   output()-&gt;put(&#39;)&#39;);
834 }
835 
836 
837 void InstructionPrinter::do_UnsafeGetObject(UnsafeGetObject* x) {
838   print_unsafe_object_op(x, &quot;UnsafeGetObject&quot;);
839   output()-&gt;put(&#39;)&#39;);
840 }
841 
842 
843 void InstructionPrinter::do_UnsafePutObject(UnsafePutObject* x) {
844   print_unsafe_object_op(x, &quot;UnsafePutObject&quot;);
845   output()-&gt;print(&quot;, value &quot;);
846   print_value(x-&gt;value());
847   output()-&gt;put(&#39;)&#39;);
848 }
849 
850 void InstructionPrinter::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
851   print_unsafe_object_op(x, x-&gt;is_add()?&quot;UnsafeGetAndSetObject (add)&quot;:&quot;UnsafeGetAndSetObject&quot;);
852   output()-&gt;print(&quot;, value &quot;);
853   print_value(x-&gt;value());
854   output()-&gt;put(&#39;)&#39;);
855 }
856 
857 void InstructionPrinter::do_RangeCheckPredicate(RangeCheckPredicate* x) {
858 
859   if (x-&gt;x() != NULL &amp;&amp; x-&gt;y() != NULL) {
860     output()-&gt;print(&quot;if &quot;);
861     print_value(x-&gt;x());
862     output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
863     print_value(x-&gt;y());
864     output()-&gt;print(&quot; then deoptimize!&quot;);
865   } else {
866     output()-&gt;print(&quot;always deoptimize!&quot;);
867   }
868 }
869 
870 #ifdef ASSERT
871 void InstructionPrinter::do_Assert(Assert* x) {
872   output()-&gt;print(&quot;assert &quot;);
873   print_value(x-&gt;x());
874   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
875   print_value(x-&gt;y());
876 }
877 #endif
878 
879 void InstructionPrinter::do_ProfileCall(ProfileCall* x) {
880   output()-&gt;print(&quot;profile &quot;);
881   print_value(x-&gt;recv());
882   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;method()-&gt;name()-&gt;as_utf8());
883   if (x-&gt;known_holder() != NULL) {
884     output()-&gt;print(&quot;, &quot;);
885     print_klass(x-&gt;known_holder());
886     output()-&gt;print(&quot; &quot;);
887   }
888   for (int i = 0; i &lt; x-&gt;nb_profiled_args(); i++) {
889     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
890     print_value(x-&gt;profiled_arg_at(i));
891     if (x-&gt;arg_needs_null_check(i)) {
892       output()-&gt;print(&quot; [NC]&quot;);
893     }
894   }
895   output()-&gt;put(&#39;)&#39;);
896 }
897 
898 void InstructionPrinter::do_ProfileReturnType(ProfileReturnType* x) {
899   output()-&gt;print(&quot;profile ret type &quot;);
900   print_value(x-&gt;ret());
901   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;method()-&gt;name()-&gt;as_utf8());
902   output()-&gt;put(&#39;)&#39;);
903 }
904 void InstructionPrinter::do_ProfileInvoke(ProfileInvoke* x) {
905   output()-&gt;print(&quot;profile_invoke &quot;);
906   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;inlinee()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;inlinee()-&gt;name()-&gt;as_utf8());
907   output()-&gt;put(&#39;)&#39;);
908 
909 }
910 
911 void InstructionPrinter::do_RuntimeCall(RuntimeCall* x) {
912   output()-&gt;print(&quot;call_rt %s(&quot;, x-&gt;entry_name());
913   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
914     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
915     print_value(x-&gt;argument_at(i));
916   }
917   output()-&gt;put(&#39;)&#39;);
918 }
919 
920 void InstructionPrinter::do_MemBar(MemBar* x) {
921   LIR_Code code = x-&gt;code();
922   switch (code) {
923   case lir_membar_acquire   : output()-&gt;print(&quot;membar_acquire&quot;); break;
924   case lir_membar_release   : output()-&gt;print(&quot;membar_release&quot;); break;
925   case lir_membar           : output()-&gt;print(&quot;membar&quot;); break;
926   case lir_membar_loadload  : output()-&gt;print(&quot;membar_loadload&quot;); break;
927   case lir_membar_storestore: output()-&gt;print(&quot;membar_storestore&quot;); break;
928   case lir_membar_loadstore : output()-&gt;print(&quot;membar_loadstore&quot;); break;
929   case lir_membar_storeload : output()-&gt;print(&quot;membar_storeload&quot;); break;
930   default                   : ShouldNotReachHere(); break;
931   }
932 }
933 
934 #endif // PRODUCT
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_IR.hpp&quot;
  27 #include &quot;c1/c1_Instruction.hpp&quot;
  28 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  32 #include &quot;utilities/bitMap.inline.hpp&quot;</span>
  33 
  34 
  35 // Implementation of Instruction
  36 
  37 
  38 int Instruction::dominator_depth() {
  39   int result = -1;
  40   if (block()) {
  41     result = block()-&gt;dominator_depth();
  42   }
  43   assert(result != -1 || this-&gt;as_Local(), &quot;Only locals have dominator depth -1&quot;);
  44   return result;
  45 }
  46 
  47 Instruction::Condition Instruction::mirror(Condition cond) {
  48   switch (cond) {
  49     case eql: return eql;
  50     case neq: return neq;
  51     case lss: return gtr;
  52     case leq: return geq;
  53     case gtr: return lss;
  54     case geq: return leq;
  55     case aeq: return beq;
  56     case beq: return aeq;
  57   }
  58   ShouldNotReachHere();
  59   return eql;
  60 }
  61 
  62 
  63 Instruction::Condition Instruction::negate(Condition cond) {
  64   switch (cond) {
  65     case eql: return neq;
  66     case neq: return eql;
  67     case lss: return geq;
  68     case leq: return gtr;
  69     case gtr: return leq;
  70     case geq: return lss;
  71     case aeq: assert(false, &quot;Above equal cannot be negated&quot;);
  72     case beq: assert(false, &quot;Below equal cannot be negated&quot;);
  73   }
  74   ShouldNotReachHere();
  75   return eql;
  76 }
  77 
  78 void Instruction::update_exception_state(ValueStack* state) {
  79   if (state != NULL &amp;&amp; (state-&gt;kind() == ValueStack::EmptyExceptionState || state-&gt;kind() == ValueStack::ExceptionState)) {
  80     assert(state-&gt;kind() == ValueStack::EmptyExceptionState || Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;unexpected state kind&quot;);
  81     _exception_state = state;
  82   } else {
  83     _exception_state = NULL;
  84   }
  85 }
  86 
  87 // Prev without need to have BlockBegin
  88 Instruction* Instruction::prev() {
  89   Instruction* p = NULL;
  90   Instruction* q = block();
  91   while (q != this) {
  92     assert(q != NULL, &quot;this is not in the block&#39;s instruction list&quot;);
  93     p = q; q = q-&gt;next();
  94   }
  95   return p;
  96 }
  97 
  98 
  99 void Instruction::state_values_do(ValueVisitor* f) {
 100   if (state_before() != NULL) {
 101     state_before()-&gt;values_do(f);
 102   }
 103   if (exception_state() != NULL){
 104     exception_state()-&gt;values_do(f);
 105   }
 106 }
 107 
 108 ciType* Instruction::exact_type() const {
 109   ciType* t =  declared_type();
 110   if (t != NULL &amp;&amp; t-&gt;is_klass()) {
 111     return t-&gt;as_klass()-&gt;exact_klass();
 112   }
 113   return NULL;
 114 }
 115 
 116 
 117 #ifndef PRODUCT
 118 void Instruction::check_state(ValueStack* state) {
 119   if (state != NULL) {
 120     state-&gt;verify();
 121   }
 122 }
 123 
 124 
 125 void Instruction::print() {
 126   InstructionPrinter ip;
 127   print(ip);
 128 }
 129 
 130 
 131 void Instruction::print_line() {
 132   InstructionPrinter ip;
 133   ip.print_line(this);
 134 }
 135 
 136 
 137 void Instruction::print(InstructionPrinter&amp; ip) {
 138   ip.print_head();
 139   ip.print_line(this);
 140   tty-&gt;cr();
 141 }
 142 #endif // PRODUCT
 143 
 144 
 145 // perform constant and interval tests on index value
 146 bool AccessIndexed::compute_needs_range_check() {
 147   if (length()) {
 148     Constant* clength = length()-&gt;as_Constant();
 149     Constant* cindex = index()-&gt;as_Constant();
 150     if (clength &amp;&amp; cindex) {
 151       IntConstant* l = clength-&gt;type()-&gt;as_IntConstant();
 152       IntConstant* i = cindex-&gt;type()-&gt;as_IntConstant();
 153       if (l &amp;&amp; i &amp;&amp; i-&gt;value() &lt; l-&gt;value() &amp;&amp; i-&gt;value() &gt;= 0) {
 154         return false;
 155       }
 156     }
 157   }
 158 
 159   if (!this-&gt;check_flag(NeedsRangeCheckFlag)) {
 160     return false;
 161   }
 162 
 163   return true;
 164 }
 165 
 166 
 167 ciType* Constant::exact_type() const {
 168   if (type()-&gt;is_object() &amp;&amp; type()-&gt;as_ObjectType()-&gt;is_loaded()) {
 169     return type()-&gt;as_ObjectType()-&gt;exact_type();
 170   }
 171   return NULL;
 172 }
 173 
 174 ciType* LoadIndexed::exact_type() const {
 175   ciType* array_type = array()-&gt;exact_type();
 176   if (array_type != NULL) {
 177     assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 178     ciArrayKlass* ak = (ciArrayKlass*)array_type;
 179 
 180     if (ak-&gt;element_type()-&gt;is_instance_klass()) {
 181       ciInstanceKlass* ik = (ciInstanceKlass*)ak-&gt;element_type();
 182       if (ik-&gt;is_loaded() &amp;&amp; ik-&gt;is_final()) {
 183         return ik;
 184       }
 185     }
 186   }
 187   return Instruction::exact_type();
 188 }
 189 
 190 
 191 ciType* LoadIndexed::declared_type() const {
 192   ciType* array_type = array()-&gt;declared_type();
 193   if (array_type == NULL || !array_type-&gt;is_loaded()) {
 194     return NULL;
 195   }
 196   assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 197   ciArrayKlass* ak = (ciArrayKlass*)array_type;
 198   return ak-&gt;element_type();
 199 }
 200 
 201 
 202 ciType* LoadField::declared_type() const {
 203   return field()-&gt;type();
 204 }
 205 
 206 
 207 ciType* NewTypeArray::exact_type() const {
 208   return ciTypeArrayKlass::make(elt_type());
 209 }
 210 
 211 ciType* NewObjectArray::exact_type() const {
 212   return ciObjArrayKlass::make(klass());
 213 }
 214 
 215 ciType* NewArray::declared_type() const {
 216   return exact_type();
 217 }
 218 
 219 ciType* NewInstance::exact_type() const {
 220   return klass();
 221 }
 222 
 223 ciType* NewInstance::declared_type() const {
 224   return exact_type();
 225 }
 226 
 227 ciType* CheckCast::declared_type() const {
 228   return klass();
 229 }
 230 
 231 // Implementation of ArithmeticOp
 232 
 233 bool ArithmeticOp::is_commutative() const {
 234   switch (op()) {
 235     case Bytecodes::_iadd: // fall through
 236     case Bytecodes::_ladd: // fall through
 237     case Bytecodes::_fadd: // fall through
 238     case Bytecodes::_dadd: // fall through
 239     case Bytecodes::_imul: // fall through
 240     case Bytecodes::_lmul: // fall through
 241     case Bytecodes::_fmul: // fall through
 242     case Bytecodes::_dmul: return true;
 243     default              : return false;
 244   }
 245 }
 246 
 247 
 248 bool ArithmeticOp::can_trap() const {
 249   switch (op()) {
 250     case Bytecodes::_idiv: // fall through
 251     case Bytecodes::_ldiv: // fall through
 252     case Bytecodes::_irem: // fall through
 253     case Bytecodes::_lrem: return true;
 254     default              : return false;
 255   }
 256 }
 257 
 258 
 259 // Implementation of LogicOp
 260 
 261 bool LogicOp::is_commutative() const {
 262 #ifdef ASSERT
 263   switch (op()) {
 264     case Bytecodes::_iand: // fall through
 265     case Bytecodes::_land: // fall through
 266     case Bytecodes::_ior : // fall through
 267     case Bytecodes::_lor : // fall through
 268     case Bytecodes::_ixor: // fall through
 269     case Bytecodes::_lxor: break;
 270     default              : ShouldNotReachHere(); break;
 271   }
 272 #endif
 273   // all LogicOps are commutative
 274   return true;
 275 }
 276 
 277 
 278 // Implementation of IfOp
 279 
 280 bool IfOp::is_commutative() const {
 281   return cond() == eql || cond() == neq;
 282 }
 283 
 284 
 285 // Implementation of StateSplit
 286 
 287 void StateSplit::substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block) {
 288   NOT_PRODUCT(bool assigned = false;)
 289   for (int i = 0; i &lt; list.length(); i++) {
 290     BlockBegin** b = list.adr_at(i);
 291     if (*b == old_block) {
 292       *b = new_block;
 293       NOT_PRODUCT(assigned = true;)
 294     }
 295   }
 296   assert(assigned == true, &quot;should have assigned at least once&quot;);
 297 }
 298 
 299 
 300 IRScope* StateSplit::scope() const {
 301   return _state-&gt;scope();
 302 }
 303 
 304 
 305 void StateSplit::state_values_do(ValueVisitor* f) {
 306   Instruction::state_values_do(f);
 307   if (state() != NULL) state()-&gt;values_do(f);
 308 }
 309 
 310 
 311 void BlockBegin::state_values_do(ValueVisitor* f) {
 312   StateSplit::state_values_do(f);
 313 
 314   if (is_set(BlockBegin::exception_entry_flag)) {
 315     for (int i = 0; i &lt; number_of_exception_states(); i++) {
 316       exception_state_at(i)-&gt;values_do(f);
 317     }
 318   }
 319 }
 320 
 321 
 322 // Implementation of Invoke
 323 
 324 
 325 Invoke::Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
 326                int vtable_index, ciMethod* target, ValueStack* state_before)
 327   : StateSplit(result_type, state_before)
 328   , _code(code)
 329   , _recv(recv)
 330   , _args(args)
 331   , _vtable_index(vtable_index)
 332   , _target(target)
 333 {
 334   set_flag(TargetIsLoadedFlag,   target-&gt;is_loaded());
 335   set_flag(TargetIsFinalFlag,    target_is_loaded() &amp;&amp; target-&gt;is_final_method());
 336   set_flag(TargetIsStrictfpFlag, target_is_loaded() &amp;&amp; target-&gt;is_strict());
 337 
 338   assert(args != NULL, &quot;args must exist&quot;);
 339 #ifdef ASSERT
 340   AssertValues assert_value;
 341   values_do(&amp;assert_value);
 342 #endif
 343 
 344   // provide an initial guess of signature size.
 345   _signature = new BasicTypeList(number_of_arguments() + (has_receiver() ? 1 : 0));
 346   if (has_receiver()) {
 347     _signature-&gt;append(as_BasicType(receiver()-&gt;type()));
 348   }
 349   for (int i = 0; i &lt; number_of_arguments(); i++) {
 350     ValueType* t = argument_at(i)-&gt;type();
 351     BasicType bt = as_BasicType(t);
 352     _signature-&gt;append(bt);
 353   }
 354 }
 355 
 356 
 357 void Invoke::state_values_do(ValueVisitor* f) {
 358   StateSplit::state_values_do(f);
 359   if (state_before() != NULL) state_before()-&gt;values_do(f);
 360   if (state()        != NULL) state()-&gt;values_do(f);
 361 }
 362 
 363 ciType* Invoke::declared_type() const {
 364   ciSignature* declared_signature = state()-&gt;scope()-&gt;method()-&gt;get_declared_signature_at_bci(state()-&gt;bci());
 365   ciType *t = declared_signature-&gt;return_type();
 366   assert(t-&gt;basic_type() != T_VOID, &quot;need return value of void method?&quot;);
 367   return t;
 368 }
 369 
 370 // Implementation of Contant
 371 intx Constant::hash() const {
 372   if (state_before() == NULL) {
 373     switch (type()-&gt;tag()) {
 374     case intTag:
 375       return HASH2(name(), type()-&gt;as_IntConstant()-&gt;value());
 376     case addressTag:
 377       return HASH2(name(), type()-&gt;as_AddressConstant()-&gt;value());
 378     case longTag:
 379       {
 380         jlong temp = type()-&gt;as_LongConstant()-&gt;value();
 381         return HASH3(name(), high(temp), low(temp));
 382       }
 383     case floatTag:
 384       return HASH2(name(), jint_cast(type()-&gt;as_FloatConstant()-&gt;value()));
 385     case doubleTag:
 386       {
 387         jlong temp = jlong_cast(type()-&gt;as_DoubleConstant()-&gt;value());
 388         return HASH3(name(), high(temp), low(temp));
 389       }
 390     case objectTag:
 391       assert(type()-&gt;as_ObjectType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 392       return HASH2(name(), type()-&gt;as_ObjectType()-&gt;constant_value());
 393     case metaDataTag:
 394       assert(type()-&gt;as_MetadataType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 395       return HASH2(name(), type()-&gt;as_MetadataType()-&gt;constant_value());
 396     default:
 397       ShouldNotReachHere();
 398     }
 399   }
 400   return 0;
 401 }
 402 
 403 bool Constant::is_equal(Value v) const {
 404   if (v-&gt;as_Constant() == NULL) return false;
 405 
 406   switch (type()-&gt;tag()) {
 407     case intTag:
 408       {
 409         IntConstant* t1 =    type()-&gt;as_IntConstant();
 410         IntConstant* t2 = v-&gt;type()-&gt;as_IntConstant();
 411         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 412                 t1-&gt;value() == t2-&gt;value());
 413       }
 414     case longTag:
 415       {
 416         LongConstant* t1 =    type()-&gt;as_LongConstant();
 417         LongConstant* t2 = v-&gt;type()-&gt;as_LongConstant();
 418         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 419                 t1-&gt;value() == t2-&gt;value());
 420       }
 421     case floatTag:
 422       {
 423         FloatConstant* t1 =    type()-&gt;as_FloatConstant();
 424         FloatConstant* t2 = v-&gt;type()-&gt;as_FloatConstant();
 425         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 426                 jint_cast(t1-&gt;value()) == jint_cast(t2-&gt;value()));
 427       }
 428     case doubleTag:
 429       {
 430         DoubleConstant* t1 =    type()-&gt;as_DoubleConstant();
 431         DoubleConstant* t2 = v-&gt;type()-&gt;as_DoubleConstant();
 432         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 433                 jlong_cast(t1-&gt;value()) == jlong_cast(t2-&gt;value()));
 434       }
 435     case objectTag:
 436       {
 437         ObjectType* t1 =    type()-&gt;as_ObjectType();
 438         ObjectType* t2 = v-&gt;type()-&gt;as_ObjectType();
 439         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 440                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 441                 t1-&gt;constant_value() == t2-&gt;constant_value());
 442       }
 443     case metaDataTag:
 444       {
 445         MetadataType* t1 =    type()-&gt;as_MetadataType();
 446         MetadataType* t2 = v-&gt;type()-&gt;as_MetadataType();
 447         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 448                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 449                 t1-&gt;constant_value() == t2-&gt;constant_value());
 450       }
 451     default:
 452       return false;
 453   }
 454 }
 455 
 456 Constant::CompareResult Constant::compare(Instruction::Condition cond, Value right) const {
 457   Constant* rc = right-&gt;as_Constant();
 458   // other is not a constant
 459   if (rc == NULL) return not_comparable;
 460 
 461   ValueType* lt = type();
 462   ValueType* rt = rc-&gt;type();
 463   // different types
 464   if (lt-&gt;base() != rt-&gt;base()) return not_comparable;
 465   switch (lt-&gt;tag()) {
 466   case intTag: {
 467     int x = lt-&gt;as_IntConstant()-&gt;value();
 468     int y = rt-&gt;as_IntConstant()-&gt;value();
 469     switch (cond) {
 470     case If::eql: return x == y ? cond_true : cond_false;
 471     case If::neq: return x != y ? cond_true : cond_false;
 472     case If::lss: return x &lt;  y ? cond_true : cond_false;
 473     case If::leq: return x &lt;= y ? cond_true : cond_false;
 474     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 475     case If::geq: return x &gt;= y ? cond_true : cond_false;
 476     default     : break;
 477     }
 478     break;
 479   }
 480   case longTag: {
 481     jlong x = lt-&gt;as_LongConstant()-&gt;value();
 482     jlong y = rt-&gt;as_LongConstant()-&gt;value();
 483     switch (cond) {
 484     case If::eql: return x == y ? cond_true : cond_false;
 485     case If::neq: return x != y ? cond_true : cond_false;
 486     case If::lss: return x &lt;  y ? cond_true : cond_false;
 487     case If::leq: return x &lt;= y ? cond_true : cond_false;
 488     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 489     case If::geq: return x &gt;= y ? cond_true : cond_false;
 490     default     : break;
 491     }
 492     break;
 493   }
 494   case objectTag: {
 495     ciObject* xvalue = lt-&gt;as_ObjectType()-&gt;constant_value();
 496     ciObject* yvalue = rt-&gt;as_ObjectType()-&gt;constant_value();
 497     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 498     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 499       switch (cond) {
 500       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 501       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 502       default     : break;
 503       }
 504     }
 505     break;
 506   }
 507   case metaDataTag: {
 508     ciMetadata* xvalue = lt-&gt;as_MetadataType()-&gt;constant_value();
 509     ciMetadata* yvalue = rt-&gt;as_MetadataType()-&gt;constant_value();
 510     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 511     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 512       switch (cond) {
 513       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 514       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 515       default     : break;
 516       }
 517     }
 518     break;
 519   }
 520   default:
 521     break;
 522   }
 523   return not_comparable;
 524 }
 525 
 526 
 527 // Implementation of BlockBegin
 528 
 529 void BlockBegin::set_end(BlockEnd* end) {
 530   assert(end != NULL, &quot;should not reset block end to NULL&quot;);
 531   if (end == _end) {
 532     return;
 533   }
 534   clear_end();
 535 
 536   // Set the new end
 537   _end = end;
 538 
 539   _successors.clear();
 540   // Now reset successors list based on BlockEnd
 541   for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
 542     BlockBegin* sux = end-&gt;sux_at(i);
 543     _successors.append(sux);
 544     sux-&gt;_predecessors.append(this);
 545   }
 546   _end-&gt;set_begin(this);
 547 }
 548 
 549 
 550 void BlockBegin::clear_end() {
 551   // Must make the predecessors/successors match up with the
 552   // BlockEnd&#39;s notion.
 553   if (_end != NULL) {
 554     // disconnect from the old end
 555     _end-&gt;set_begin(NULL);
 556 
 557     // disconnect this block from it&#39;s current successors
 558     for (int i = 0; i &lt; _successors.length(); i++) {
 559       _successors.at(i)-&gt;remove_predecessor(this);
 560     }
 561     _end = NULL;
 562   }
 563 }
 564 
 565 
 566 void BlockBegin::disconnect_edge(BlockBegin* from, BlockBegin* to) {
 567   // disconnect any edges between from and to
 568 #ifndef PRODUCT
 569   if (PrintIR &amp;&amp; Verbose) {
 570     tty-&gt;print_cr(&quot;Disconnected edge B%d -&gt; B%d&quot;, from-&gt;block_id(), to-&gt;block_id());
 571   }
 572 #endif
 573   for (int s = 0; s &lt; from-&gt;number_of_sux();) {
 574     BlockBegin* sux = from-&gt;sux_at(s);
 575     if (sux == to) {
 576       int index = sux-&gt;_predecessors.find(from);
 577       if (index &gt;= 0) {
 578         sux-&gt;_predecessors.remove_at(index);
 579       }
 580       from-&gt;_successors.remove_at(s);
 581     } else {
 582       s++;
 583     }
 584   }
 585 }
 586 
 587 
 588 void BlockBegin::disconnect_from_graph() {
 589   // disconnect this block from all other blocks
 590   for (int p = 0; p &lt; number_of_preds(); p++) {
 591     pred_at(p)-&gt;remove_successor(this);
 592   }
 593   for (int s = 0; s &lt; number_of_sux(); s++) {
 594     sux_at(s)-&gt;remove_predecessor(this);
 595   }
 596 }
 597 
 598 void BlockBegin::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 599   // modify predecessors before substituting successors
 600   for (int i = 0; i &lt; number_of_sux(); i++) {
 601     if (sux_at(i) == old_sux) {
 602       // remove old predecessor before adding new predecessor
 603       // otherwise there is a dead predecessor in the list
 604       new_sux-&gt;remove_predecessor(old_sux);
 605       new_sux-&gt;add_predecessor(this);
 606     }
 607   }
 608   old_sux-&gt;remove_predecessor(this);
 609   end()-&gt;substitute_sux(old_sux, new_sux);
 610 }
 611 
 612 
 613 
 614 // In general it is not possible to calculate a value for the field &quot;depth_first_number&quot;
 615 // of the inserted block, without recomputing the values of the other blocks
 616 // in the CFG. Therefore the value of &quot;depth_first_number&quot; in BlockBegin becomes meaningless.
 617 BlockBegin* BlockBegin::insert_block_between(BlockBegin* sux) {
 618   int bci = sux-&gt;bci();
 619   // critical edge splitting may introduce a goto after a if and array
 620   // bound check elimination may insert a predicate between the if and
 621   // goto. The bci of the goto can&#39;t be the one of the if otherwise
 622   // the state and bci are inconsistent and a deoptimization triggered
 623   // by the predicate would lead to incorrect execution/a crash.
 624   BlockBegin* new_sux = new BlockBegin(bci);
 625 
 626   // mark this block (special treatment when block order is computed)
 627   new_sux-&gt;set(critical_edge_split_flag);
 628 
 629   // This goto is not a safepoint.
 630   Goto* e = new Goto(sux, false);
 631   new_sux-&gt;set_next(e, bci);
 632   new_sux-&gt;set_end(e);
 633   // setup states
 634   ValueStack* s = end()-&gt;state();
 635   new_sux-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 636   e-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 637   assert(new_sux-&gt;state()-&gt;locals_size() == s-&gt;locals_size(), &quot;local size mismatch!&quot;);
 638   assert(new_sux-&gt;state()-&gt;stack_size() == s-&gt;stack_size(), &quot;stack size mismatch!&quot;);
 639   assert(new_sux-&gt;state()-&gt;locks_size() == s-&gt;locks_size(), &quot;locks size mismatch!&quot;);
 640 
 641   // link predecessor to new block
 642   end()-&gt;substitute_sux(sux, new_sux);
 643 
 644   // The ordering needs to be the same, so remove the link that the
 645   // set_end call above added and substitute the new_sux for this
 646   // block.
 647   sux-&gt;remove_predecessor(new_sux);
 648 
 649   // the successor could be the target of a switch so it might have
 650   // multiple copies of this predecessor, so substitute the new_sux
 651   // for the first and delete the rest.
 652   bool assigned = false;
 653   BlockList&amp; list = sux-&gt;_predecessors;
 654   for (int i = 0; i &lt; list.length(); i++) {
 655     BlockBegin** b = list.adr_at(i);
 656     if (*b == this) {
 657       if (assigned) {
 658         list.remove_at(i);
 659         // reprocess this index
 660         i--;
 661       } else {
 662         assigned = true;
 663         *b = new_sux;
 664       }
 665       // link the new block back to it&#39;s predecessors.
 666       new_sux-&gt;add_predecessor(this);
 667     }
 668   }
 669   assert(assigned == true, &quot;should have assigned at least once&quot;);
 670   return new_sux;
 671 }
 672 
 673 
 674 void BlockBegin::remove_successor(BlockBegin* pred) {
 675   int idx;
 676   while ((idx = _successors.find(pred)) &gt;= 0) {
 677     _successors.remove_at(idx);
 678   }
 679 }
 680 
 681 
 682 void BlockBegin::add_predecessor(BlockBegin* pred) {
 683   _predecessors.append(pred);
 684 }
 685 
 686 
 687 void BlockBegin::remove_predecessor(BlockBegin* pred) {
 688   int idx;
 689   while ((idx = _predecessors.find(pred)) &gt;= 0) {
 690     _predecessors.remove_at(idx);
 691   }
 692 }
 693 
 694 
 695 void BlockBegin::add_exception_handler(BlockBegin* b) {
 696   assert(b != NULL &amp;&amp; (b-&gt;is_set(exception_entry_flag)), &quot;exception handler must exist&quot;);
 697   // add only if not in the list already
 698   if (!_exception_handlers.contains(b)) _exception_handlers.append(b);
 699 }
 700 
 701 int BlockBegin::add_exception_state(ValueStack* state) {
 702   assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;);
 703   if (_exception_states == NULL) {
 704     _exception_states = new ValueStackStack(4);
 705   }
 706   _exception_states-&gt;append(state);
 707   return _exception_states-&gt;length() - 1;
 708 }
 709 
 710 
 711 void BlockBegin::iterate_preorder(boolArray&amp; mark, BlockClosure* closure) {
 712   if (!mark.at(block_id())) {
 713     mark.at_put(block_id(), true);
 714     closure-&gt;block_do(this);
 715     BlockEnd* e = end(); // must do this after block_do because block_do may change it!
 716     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_preorder(mark, closure); }
 717     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_preorder(mark, closure); }
 718   }
 719 }
 720 
 721 
 722 void BlockBegin::iterate_postorder(boolArray&amp; mark, BlockClosure* closure) {
 723   if (!mark.at(block_id())) {
 724     mark.at_put(block_id(), true);
 725     BlockEnd* e = end();
 726     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_postorder(mark, closure); }
 727     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_postorder(mark, closure); }
 728     closure-&gt;block_do(this);
 729   }
 730 }
 731 
 732 
 733 void BlockBegin::iterate_preorder(BlockClosure* closure) {
 734   int mark_len = number_of_blocks();
 735   boolArray mark(mark_len, mark_len, false);
 736   iterate_preorder(mark, closure);
 737 }
 738 
 739 
 740 void BlockBegin::iterate_postorder(BlockClosure* closure) {
 741   int mark_len = number_of_blocks();
 742   boolArray mark(mark_len, mark_len, false);
 743   iterate_postorder(mark, closure);
 744 }
 745 
 746 
 747 void BlockBegin::block_values_do(ValueVisitor* f) {
 748   for (Instruction* n = this; n != NULL; n = n-&gt;next()) n-&gt;values_do(f);
 749 }
 750 
 751 
 752 #ifndef PRODUCT
 753    #define TRACE_PHI(code) if (PrintPhiFunctions) { code; }
 754 #else
 755    #define TRACE_PHI(coce)
 756 #endif
 757 
 758 
 759 bool BlockBegin::try_merge(ValueStack* new_state) {
 760   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d&quot;, block_id()));
 761 
 762   // local variables used for state iteration
 763   int index;
 764   Value new_value, existing_value;
 765 
 766   ValueStack* existing_state = state();
 767   if (existing_state == NULL) {
 768     TRACE_PHI(tty-&gt;print_cr(&quot;first call of try_merge for this block&quot;));
 769 
 770     if (is_set(BlockBegin::was_visited_flag)) {
 771       // this actually happens for complicated jsr/ret structures
 772       return false; // BAILOUT in caller
 773     }
 774 
 775     // copy state because it is altered
 776     new_state = new_state-&gt;copy(ValueStack::BlockBeginState, bci());
 777 
 778     // Use method liveness to invalidate dead locals
 779     MethodLivenessResult liveness = new_state-&gt;scope()-&gt;method()-&gt;liveness_at_bci(bci());
 780     if (liveness.is_valid()) {
 781       assert((int)liveness.size() == new_state-&gt;locals_size(), &quot;error in use of liveness&quot;);
 782 
 783       for_each_local_value(new_state, index, new_value) {
 784         if (!liveness.at(index) || new_value-&gt;type()-&gt;is_illegal()) {
 785           new_state-&gt;invalidate_local(index);
 786           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating dead local %d&quot;, index));
 787         }
 788       }
 789     }
 790 
 791     if (is_set(BlockBegin::parser_loop_header_flag)) {
 792       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, initializing phi functions&quot;));
 793 
 794       for_each_stack_value(new_state, index, new_value) {
 795         new_state-&gt;setup_phi_for_stack(this, index);
 796         TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, new_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;stack_at(index)-&gt;id(), index));
 797       }
 798 
 799       BitMap&amp; requires_phi_function = new_state-&gt;scope()-&gt;requires_phi_function();
 800 
 801       for_each_local_value(new_state, index, new_value) {
 802         bool requires_phi = requires_phi_function.at(index) || (new_value-&gt;type()-&gt;is_double_word() &amp;&amp; requires_phi_function.at(index + 1));
 803         if (requires_phi || !SelectivePhiFunctions) {
 804           new_state-&gt;setup_phi_for_local(this, index);
 805           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, new_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;local_at(index)-&gt;id(), index));
 806         }
 807       }
 808     }
 809 
 810     // initialize state of block
 811     set_state(new_state);
 812 
 813   } else if (existing_state-&gt;is_same(new_state)) {
 814     TRACE_PHI(tty-&gt;print_cr(&quot;exisiting state found&quot;));
 815 
 816     assert(existing_state-&gt;scope() == new_state-&gt;scope(), &quot;not matching&quot;);
 817     assert(existing_state-&gt;locals_size() == new_state-&gt;locals_size(), &quot;not matching&quot;);
 818     assert(existing_state-&gt;stack_size() == new_state-&gt;stack_size(), &quot;not matching&quot;);
 819 
 820     if (is_set(BlockBegin::was_visited_flag)) {
 821       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, phis must be present&quot;));
 822 
 823       if (!is_set(BlockBegin::parser_loop_header_flag)) {
 824         // this actually happens for complicated jsr/ret structures
 825         return false; // BAILOUT in caller
 826       }
 827 
 828       for_each_local_value(existing_state, index, existing_value) {
 829         Value new_value = new_state-&gt;local_at(index);
 830         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 831           Phi* existing_phi = existing_value-&gt;as_Phi();
 832           if (existing_phi == NULL) {
 833             return false; // BAILOUT in caller
 834           }
 835           // Invalidate the phi function here. This case is very rare except for
 836           // JVMTI capability &quot;can_access_local_variables&quot;.
 837           // In really rare cases we will bail out in LIRGenerator::move_to_phi.
 838           existing_phi-&gt;make_illegal();
 839           existing_state-&gt;invalidate_local(index);
 840           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 841         }
 842       }
 843 
 844 #ifdef ASSERT
 845       // check that all necessary phi functions are present
 846       for_each_stack_value(existing_state, index, existing_value) {
 847         assert(existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;block() == this, &quot;phi function required&quot;);
 848       }
 849       for_each_local_value(existing_state, index, existing_value) {
 850         assert(existing_value == new_state-&gt;local_at(index) || (existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;as_Phi()-&gt;block() == this), &quot;phi function required&quot;);
 851       }
 852 #endif
 853 
 854     } else {
 855       TRACE_PHI(tty-&gt;print_cr(&quot;creating phi functions on demand&quot;));
 856 
 857       // create necessary phi functions for stack
 858       for_each_stack_value(existing_state, index, existing_value) {
 859         Value new_value = new_state-&gt;stack_at(index);
 860         Phi* existing_phi = existing_value-&gt;as_Phi();
 861 
 862         if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 863           existing_state-&gt;setup_phi_for_stack(this, index);
 864           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, existing_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;stack_at(index)-&gt;id(), index));
 865         }
 866       }
 867 
 868       // create necessary phi functions for locals
 869       for_each_local_value(existing_state, index, existing_value) {
 870         Value new_value = new_state-&gt;local_at(index);
 871         Phi* existing_phi = existing_value-&gt;as_Phi();
 872 
 873         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 874           existing_state-&gt;invalidate_local(index);
 875           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 876         } else if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 877           existing_state-&gt;setup_phi_for_local(this, index);
 878           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, existing_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;local_at(index)-&gt;id(), index));
 879         }
 880       }
 881     }
 882 
 883     assert(existing_state-&gt;caller_state() == new_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
 884 
 885   } else {
 886     assert(false, &quot;stack or locks not matching (invalid bytecodes)&quot;);
 887     return false;
 888   }
 889 
 890   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d successful&quot;, block_id()));
 891 
 892   return true;
 893 }
 894 
 895 
 896 #ifndef PRODUCT
 897 void BlockBegin::print_block() {
 898   InstructionPrinter ip;
 899   print_block(ip, false);
 900 }
 901 
 902 
 903 void BlockBegin::print_block(InstructionPrinter&amp; ip, bool live_only) {
 904   ip.print_instr(this); tty-&gt;cr();
 905   ip.print_stack(this-&gt;state()); tty-&gt;cr();
 906   ip.print_inline_level(this);
 907   ip.print_head();
 908   for (Instruction* n = next(); n != NULL; n = n-&gt;next()) {
 909     if (!live_only || n-&gt;is_pinned() || n-&gt;use_count() &gt; 0) {
 910       ip.print_line(n);
 911     }
 912   }
 913   tty-&gt;cr();
 914 }
 915 #endif // PRODUCT
 916 
 917 
 918 // Implementation of BlockList
 919 
 920 void BlockList::iterate_forward (BlockClosure* closure) {
 921   const int l = length();
 922   for (int i = 0; i &lt; l; i++) closure-&gt;block_do(at(i));
 923 }
 924 
 925 
 926 void BlockList::iterate_backward(BlockClosure* closure) {
 927   for (int i = length() - 1; i &gt;= 0; i--) closure-&gt;block_do(at(i));
 928 }
 929 
 930 
 931 void BlockList::blocks_do(void f(BlockBegin*)) {
 932   for (int i = length() - 1; i &gt;= 0; i--) f(at(i));
 933 }
 934 
 935 
 936 void BlockList::values_do(ValueVisitor* f) {
 937   for (int i = length() - 1; i &gt;= 0; i--) at(i)-&gt;block_values_do(f);
 938 }
 939 
 940 
 941 #ifndef PRODUCT
 942 void BlockList::print(bool cfg_only, bool live_only) {
 943   InstructionPrinter ip;
 944   for (int i = 0; i &lt; length(); i++) {
 945     BlockBegin* block = at(i);
 946     if (cfg_only) {
 947       ip.print_instr(block); tty-&gt;cr();
 948     } else {
 949       block-&gt;print_block(ip, live_only);
 950     }
 951   }
 952 }
 953 #endif // PRODUCT
 954 
 955 
 956 // Implementation of BlockEnd
 957 
 958 void BlockEnd::set_begin(BlockBegin* begin) {
 959   BlockList* sux = NULL;
 960   if (begin != NULL) {
 961     sux = begin-&gt;successors();
 962   } else if (this-&gt;begin() != NULL) {
 963     // copy our sux list
 964     BlockList* sux = new BlockList(this-&gt;begin()-&gt;number_of_sux());
 965     for (int i = 0; i &lt; this-&gt;begin()-&gt;number_of_sux(); i++) {
 966       sux-&gt;append(this-&gt;begin()-&gt;sux_at(i));
 967     }
 968   }
 969   _sux = sux;
 970 }
 971 
 972 
 973 void BlockEnd::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 974   substitute(*_sux, old_sux, new_sux);
 975 }
 976 
 977 
 978 // Implementation of Phi
 979 
 980 // Normal phi functions take their operands from the last instruction of the
 981 // predecessor. Special handling is needed for xhanlder entries because there
 982 // the state of arbitrary instructions are needed.
 983 
 984 Value Phi::operand_at(int i) const {
 985   ValueStack* state;
 986   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 987     state = _block-&gt;exception_state_at(i);
 988   } else {
 989     state = _block-&gt;pred_at(i)-&gt;end()-&gt;state();
 990   }
 991   assert(state != NULL, &quot;&quot;);
 992 
 993   if (is_local()) {
 994     return state-&gt;local_at(local_index());
 995   } else {
 996     return state-&gt;stack_at(stack_index());
 997   }
 998 }
 999 
1000 
1001 int Phi::operand_count() const {
1002   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1003     return _block-&gt;number_of_exception_states();
1004   } else {
1005     return _block-&gt;number_of_preds();
1006   }
1007 }
1008 
1009 #ifdef ASSERT
1010 // Constructor of Assert
1011 Assert::Assert(Value x, Condition cond, bool unordered_is_true, Value y) : Instruction(illegalType)
1012   , _x(x)
1013   , _cond(cond)
1014   , _y(y)
1015 {
1016   set_flag(UnorderedIsTrueFlag, unordered_is_true);
1017   assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1018   pin();
1019 
1020   stringStream strStream;
1021   Compilation::current()-&gt;method()-&gt;print_name(&amp;strStream);
1022 
1023   stringStream strStream1;
1024   InstructionPrinter ip1(1, &amp;strStream1);
1025   ip1.print_instr(x);
1026 
1027   stringStream strStream2;
1028   InstructionPrinter ip2(1, &amp;strStream2);
1029   ip2.print_instr(y);
1030 
1031   stringStream ss;
1032   ss.print(&quot;Assertion %s %s %s in method %s&quot;, strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());
1033 
1034   _message = ss.as_string();
1035 }
1036 #endif
1037 
1038 void RangeCheckPredicate::check_state() {
1039   assert(state()-&gt;kind() != ValueStack::EmptyExceptionState &amp;&amp; state()-&gt;kind() != ValueStack::ExceptionState, &quot;will deopt with empty state&quot;);
1040 }
1041 
1042 void ProfileInvoke::state_values_do(ValueVisitor* f) {
1043   if (state() != NULL) state()-&gt;values_do(f);
1044 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
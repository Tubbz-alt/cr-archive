<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_CodeStubs.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Canonicalizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Compilation.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_CodeStubs.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
106     visitor-&gt;do_input(_method);
107   }
108 
109 #ifndef PRODUCT
110   virtual void print_name(outputStream* out) const { out-&gt;print(&quot;CounterOverflowStub&quot;); }
111 #endif // PRODUCT
112 
113 };
114 
115 class ConversionStub: public CodeStub {
116  private:
117   Bytecodes::Code _bytecode;
118   LIR_Opr         _input;
119   LIR_Opr         _result;
120 
121   static float float_zero;
122   static double double_zero;
123  public:
124   ConversionStub(Bytecodes::Code bytecode, LIR_Opr input, LIR_Opr result)
125     : _bytecode(bytecode), _input(input), _result(result) {

126   }
127 
128   Bytecodes::Code bytecode() { return _bytecode; }
129   LIR_Opr         input()    { return _input; }
130   LIR_Opr         result()   { return _result; }
131 
132   virtual void emit_code(LIR_Assembler* e);
133   virtual void visit(LIR_OpVisitState* visitor) {
134     visitor-&gt;do_slow_case();
135     visitor-&gt;do_input(_input);
136     visitor-&gt;do_output(_result);
137   }
138 #ifndef PRODUCT
139   virtual void print_name(outputStream* out) const { out-&gt;print(&quot;ConversionStub&quot;); }
140 #endif // PRODUCT
141 };
142 
143 
144 // Throws ArrayIndexOutOfBoundsException by default but can be
145 // configured to throw IndexOutOfBoundsException in constructor
</pre>
<hr />
<pre>
392 
393   PatchingStub(MacroAssembler* masm, PatchID id, int index = -1):
394       _id(id)
395     , _info(NULL)
396     , _index(index) {
397     // force alignment of patch sites so we
398     // can guarantee atomic writes to the patch site.
399     align_patch_site(masm);
400     _pc_start = masm-&gt;pc();
401     masm-&gt;bind(_patch_site_entry);
402   }
403 
404   void install(MacroAssembler* masm, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info) {
405     _info = info;
406     _obj = obj;
407     masm-&gt;bind(_patch_site_continuation);
408     _bytes_to_copy = masm-&gt;pc() - pc_start();
409     if (_id == PatchingStub::access_field_id) {
410       // embed a fixed offset to handle long patches which need to be offset by a word.
411       // the patching code will just add the field offset field to this offset so
<span class="line-modified">412       // that we can refernce either the high or low word of a double word field.</span>
413       int field_offset = 0;
414       switch (patch_code) {
415       case lir_patch_low:         field_offset = lo_word_offset_in_bytes; break;
416       case lir_patch_high:        field_offset = hi_word_offset_in_bytes; break;
417       case lir_patch_normal:      field_offset = 0;                       break;
418       default: ShouldNotReachHere();
419       }
420       NativeMovRegMem* n_move = nativeMovRegMem_at(pc_start());
421       n_move-&gt;set_offset(field_offset);


422     } else if (_id == load_klass_id || _id == load_mirror_id || _id == load_appendix_id) {
423       assert(_obj != noreg, &quot;must have register object for load_klass/load_mirror&quot;);
424 #ifdef ASSERT
425       // verify that we&#39;re pointing at a NativeMovConstReg
426       nativeMovConstReg_at(pc_start());
427 #endif
428     } else {
429       ShouldNotReachHere();
430     }
431     assert(_bytes_to_copy &lt;= (masm-&gt;pc() - pc_start()), &quot;not enough bytes&quot;);
432   }
433 
434   address pc_start() const                       { return _pc_start; }
435   PatchID id() const                             { return _id; }
436 
437   virtual void emit_code(LIR_Assembler* e);
438   virtual CodeEmitInfo* info() const             { return _info; }
439   virtual void visit(LIR_OpVisitState* visitor) {
440     visitor-&gt;do_slow_case(_info);
441   }
</pre>
</td>
<td>
<hr />
<pre>
106     visitor-&gt;do_input(_method);
107   }
108 
109 #ifndef PRODUCT
110   virtual void print_name(outputStream* out) const { out-&gt;print(&quot;CounterOverflowStub&quot;); }
111 #endif // PRODUCT
112 
113 };
114 
115 class ConversionStub: public CodeStub {
116  private:
117   Bytecodes::Code _bytecode;
118   LIR_Opr         _input;
119   LIR_Opr         _result;
120 
121   static float float_zero;
122   static double double_zero;
123  public:
124   ConversionStub(Bytecodes::Code bytecode, LIR_Opr input, LIR_Opr result)
125     : _bytecode(bytecode), _input(input), _result(result) {
<span class="line-added">126     NOT_IA32( ShouldNotReachHere(); ) // used only on x86-32</span>
127   }
128 
129   Bytecodes::Code bytecode() { return _bytecode; }
130   LIR_Opr         input()    { return _input; }
131   LIR_Opr         result()   { return _result; }
132 
133   virtual void emit_code(LIR_Assembler* e);
134   virtual void visit(LIR_OpVisitState* visitor) {
135     visitor-&gt;do_slow_case();
136     visitor-&gt;do_input(_input);
137     visitor-&gt;do_output(_result);
138   }
139 #ifndef PRODUCT
140   virtual void print_name(outputStream* out) const { out-&gt;print(&quot;ConversionStub&quot;); }
141 #endif // PRODUCT
142 };
143 
144 
145 // Throws ArrayIndexOutOfBoundsException by default but can be
146 // configured to throw IndexOutOfBoundsException in constructor
</pre>
<hr />
<pre>
393 
394   PatchingStub(MacroAssembler* masm, PatchID id, int index = -1):
395       _id(id)
396     , _info(NULL)
397     , _index(index) {
398     // force alignment of patch sites so we
399     // can guarantee atomic writes to the patch site.
400     align_patch_site(masm);
401     _pc_start = masm-&gt;pc();
402     masm-&gt;bind(_patch_site_entry);
403   }
404 
405   void install(MacroAssembler* masm, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info) {
406     _info = info;
407     _obj = obj;
408     masm-&gt;bind(_patch_site_continuation);
409     _bytes_to_copy = masm-&gt;pc() - pc_start();
410     if (_id == PatchingStub::access_field_id) {
411       // embed a fixed offset to handle long patches which need to be offset by a word.
412       // the patching code will just add the field offset field to this offset so
<span class="line-modified">413       // that we can reference either the high or low word of a double word field.</span>
414       int field_offset = 0;
415       switch (patch_code) {
416       case lir_patch_low:         field_offset = lo_word_offset_in_bytes; break;
417       case lir_patch_high:        field_offset = hi_word_offset_in_bytes; break;
418       case lir_patch_normal:      field_offset = 0;                       break;
419       default: ShouldNotReachHere();
420       }
421       NativeMovRegMem* n_move = nativeMovRegMem_at(pc_start());
422       n_move-&gt;set_offset(field_offset);
<span class="line-added">423       // Copy will never get executed, so only copy the part which is required for patching.</span>
<span class="line-added">424       _bytes_to_copy = MAX2(n_move-&gt;num_bytes_to_end_of_patch(), (int)NativeGeneralJump::instruction_size);</span>
425     } else if (_id == load_klass_id || _id == load_mirror_id || _id == load_appendix_id) {
426       assert(_obj != noreg, &quot;must have register object for load_klass/load_mirror&quot;);
427 #ifdef ASSERT
428       // verify that we&#39;re pointing at a NativeMovConstReg
429       nativeMovConstReg_at(pc_start());
430 #endif
431     } else {
432       ShouldNotReachHere();
433     }
434     assert(_bytes_to_copy &lt;= (masm-&gt;pc() - pc_start()), &quot;not enough bytes&quot;);
435   }
436 
437   address pc_start() const                       { return _pc_start; }
438   PatchID id() const                             { return _id; }
439 
440   virtual void emit_code(LIR_Assembler* e);
441   virtual CodeEmitInfo* info() const             { return _info; }
442   virtual void visit(LIR_OpVisitState* visitor) {
443     visitor-&gt;do_slow_case(_info);
444   }
</pre>
</td>
</tr>
</table>
<center><a href="c1_Canonicalizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Compilation.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
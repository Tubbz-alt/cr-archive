<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciObjArray.hpp&quot;
  36 #include &quot;ci/ciUtilities.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  39 #include &quot;oops/klass.inline.hpp&quot;</span>
  40 #include &quot;runtime/arguments.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;
  45 #include &quot;utilities/macros.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  46 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  47 
  48 #ifdef ASSERT
  49 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  50 #else
  51 #define __ gen()-&gt;lir()-&gt;
  52 #endif
  53 
  54 #ifndef PATCHED_ADDR
  55 #define PATCHED_ADDR  (max_jint)
  56 #endif
  57 
  58 void PhiResolverState::reset() {
  59   _virtual_operands.clear();
  60   _other_operands.clear();
  61   _vreg_table.clear();
  62 }
  63 
  64 
  65 //--------------------------------------------------------------
  66 // PhiResolver
  67 
  68 // Resolves cycles:
  69 //
  70 //  r1 := r2  becomes  temp := r1
  71 //  r2 := r1           r1 := r2
  72 //                     r2 := temp
  73 // and orders moves:
  74 //
  75 //  r2 := r3  becomes  r1 := r2
  76 //  r1 := r2           r2 := r3
  77 
  78 PhiResolver::PhiResolver(LIRGenerator* gen)
  79  : _gen(gen)
  80  , _state(gen-&gt;resolver_state())
  81  , _temp(LIR_OprFact::illegalOpr)
  82 {
  83   // reinitialize the shared state arrays
  84   _state.reset();
  85 }
  86 
  87 
  88 void PhiResolver::emit_move(LIR_Opr src, LIR_Opr dest) {
  89   assert(src-&gt;is_valid(), &quot;&quot;);
  90   assert(dest-&gt;is_valid(), &quot;&quot;);
  91   __ move(src, dest);
  92 }
  93 
  94 
  95 void PhiResolver::move_temp_to(LIR_Opr dest) {
  96   assert(_temp-&gt;is_valid(), &quot;&quot;);
  97   emit_move(_temp, dest);
  98   NOT_PRODUCT(_temp = LIR_OprFact::illegalOpr);
  99 }
 100 
 101 
 102 void PhiResolver::move_to_temp(LIR_Opr src) {
 103   assert(_temp-&gt;is_illegal(), &quot;&quot;);
 104   _temp = _gen-&gt;new_register(src-&gt;type());
 105   emit_move(src, _temp);
 106 }
 107 
 108 
 109 // Traverse assignment graph in depth first order and generate moves in post order
 110 // ie. two assignments: b := c, a := b start with node c:
 111 // Call graph: move(NULL, c) -&gt; move(c, b) -&gt; move(b, a)
 112 // Generates moves in this order: move b to a and move c to b
 113 // ie. cycle a := b, b := a start with node a
 114 // Call graph: move(NULL, a) -&gt; move(a, b) -&gt; move(b, a)
 115 // Generates moves in this order: move b to temp, move a to b, move temp to a
 116 void PhiResolver::move(ResolveNode* src, ResolveNode* dest) {
 117   if (!dest-&gt;visited()) {
 118     dest-&gt;set_visited();
 119     for (int i = dest-&gt;no_of_destinations()-1; i &gt;= 0; i --) {
 120       move(dest, dest-&gt;destination_at(i));
 121     }
 122   } else if (!dest-&gt;start_node()) {
 123     // cylce in graph detected
 124     assert(_loop == NULL, &quot;only one loop valid!&quot;);
 125     _loop = dest;
 126     move_to_temp(src-&gt;operand());
 127     return;
 128   } // else dest is a start node
 129 
 130   if (!dest-&gt;assigned()) {
 131     if (_loop == dest) {
 132       move_temp_to(dest-&gt;operand());
 133       dest-&gt;set_assigned();
 134     } else if (src != NULL) {
 135       emit_move(src-&gt;operand(), dest-&gt;operand());
 136       dest-&gt;set_assigned();
 137     }
 138   }
 139 }
 140 
 141 
 142 PhiResolver::~PhiResolver() {
 143   int i;
 144   // resolve any cycles in moves from and to virtual registers
 145   for (i = virtual_operands().length() - 1; i &gt;= 0; i --) {
 146     ResolveNode* node = virtual_operands().at(i);
 147     if (!node-&gt;visited()) {
 148       _loop = NULL;
 149       move(NULL, node);
 150       node-&gt;set_start_node();
 151       assert(_temp-&gt;is_illegal(), &quot;move_temp_to() call missing&quot;);
 152     }
 153   }
 154 
 155   // generate move for move from non virtual register to abitrary destination
 156   for (i = other_operands().length() - 1; i &gt;= 0; i --) {
 157     ResolveNode* node = other_operands().at(i);
 158     for (int j = node-&gt;no_of_destinations() - 1; j &gt;= 0; j --) {
 159       emit_move(node-&gt;operand(), node-&gt;destination_at(j)-&gt;operand());
 160     }
 161   }
 162 }
 163 
 164 
 165 ResolveNode* PhiResolver::create_node(LIR_Opr opr, bool source) {
 166   ResolveNode* node;
 167   if (opr-&gt;is_virtual()) {
 168     int vreg_num = opr-&gt;vreg_number();
 169     node = vreg_table().at_grow(vreg_num, NULL);
 170     assert(node == NULL || node-&gt;operand() == opr, &quot;&quot;);
 171     if (node == NULL) {
 172       node = new ResolveNode(opr);
 173       vreg_table().at_put(vreg_num, node);
 174     }
 175     // Make sure that all virtual operands show up in the list when
 176     // they are used as the source of a move.
 177     if (source &amp;&amp; !virtual_operands().contains(node)) {
 178       virtual_operands().append(node);
 179     }
 180   } else {
 181     assert(source, &quot;&quot;);
 182     node = new ResolveNode(opr);
 183     other_operands().append(node);
 184   }
 185   return node;
 186 }
 187 
 188 
 189 void PhiResolver::move(LIR_Opr src, LIR_Opr dest) {
 190   assert(dest-&gt;is_virtual(), &quot;&quot;);
 191   // tty-&gt;print(&quot;move &quot;); src-&gt;print(); tty-&gt;print(&quot; to &quot;); dest-&gt;print(); tty-&gt;cr();
 192   assert(src-&gt;is_valid(), &quot;&quot;);
 193   assert(dest-&gt;is_valid(), &quot;&quot;);
 194   ResolveNode* source = source_node(src);
 195   source-&gt;append(destination_node(dest));
 196 }
 197 
 198 
 199 //--------------------------------------------------------------
 200 // LIRItem
 201 
 202 void LIRItem::set_result(LIR_Opr opr) {
 203   assert(value()-&gt;operand()-&gt;is_illegal() || value()-&gt;operand()-&gt;is_constant(), &quot;operand should never change&quot;);
 204   value()-&gt;set_operand(opr);
 205 
 206   if (opr-&gt;is_virtual()) {
 207     _gen-&gt;_instruction_for_operand.at_put_grow(opr-&gt;vreg_number(), value(), NULL);
 208   }
 209 
 210   _result = opr;
 211 }
 212 
 213 void LIRItem::load_item() {
 214   if (result()-&gt;is_illegal()) {
 215     // update the items result
 216     _result = value()-&gt;operand();
 217   }
 218   if (!result()-&gt;is_register()) {
 219     LIR_Opr reg = _gen-&gt;new_register(value()-&gt;type());
 220     __ move(result(), reg);
 221     if (result()-&gt;is_constant()) {
 222       _result = reg;
 223     } else {
 224       set_result(reg);
 225     }
 226   }
 227 }
 228 
 229 
 230 void LIRItem::load_for_store(BasicType type) {
 231   if (_gen-&gt;can_store_as_constant(value(), type)) {
 232     _result = value()-&gt;operand();
 233     if (!_result-&gt;is_constant()) {
 234       _result = LIR_OprFact::value_type(value()-&gt;type());
 235     }
 236   } else if (type == T_BYTE || type == T_BOOLEAN) {
 237     load_byte_item();
 238   } else {
 239     load_item();
 240   }
 241 }
 242 
 243 void LIRItem::load_item_force(LIR_Opr reg) {
 244   LIR_Opr r = result();
 245   if (r != reg) {
 246 #if !defined(ARM) &amp;&amp; !defined(E500V2)
 247     if (r-&gt;type() != reg-&gt;type()) {
 248       // moves between different types need an intervening spill slot
 249       r = _gen-&gt;force_to_spill(r, reg-&gt;type());
 250     }
 251 #endif
 252     __ move(r, reg);
 253     _result = reg;
 254   }
 255 }
 256 
 257 ciObject* LIRItem::get_jobject_constant() const {
 258   ObjectType* oc = type()-&gt;as_ObjectType();
 259   if (oc) {
 260     return oc-&gt;constant_value();
 261   }
 262   return NULL;
 263 }
 264 
 265 
 266 jint LIRItem::get_jint_constant() const {
 267   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 268   assert(type()-&gt;as_IntConstant() != NULL, &quot;type check&quot;);
 269   return type()-&gt;as_IntConstant()-&gt;value();
 270 }
 271 
 272 
 273 jint LIRItem::get_address_constant() const {
 274   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 275   assert(type()-&gt;as_AddressConstant() != NULL, &quot;type check&quot;);
 276   return type()-&gt;as_AddressConstant()-&gt;value();
 277 }
 278 
 279 
 280 jfloat LIRItem::get_jfloat_constant() const {
 281   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 282   assert(type()-&gt;as_FloatConstant() != NULL, &quot;type check&quot;);
 283   return type()-&gt;as_FloatConstant()-&gt;value();
 284 }
 285 
 286 
 287 jdouble LIRItem::get_jdouble_constant() const {
 288   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 289   assert(type()-&gt;as_DoubleConstant() != NULL, &quot;type check&quot;);
 290   return type()-&gt;as_DoubleConstant()-&gt;value();
 291 }
 292 
 293 
 294 jlong LIRItem::get_jlong_constant() const {
 295   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 296   assert(type()-&gt;as_LongConstant() != NULL, &quot;type check&quot;);
 297   return type()-&gt;as_LongConstant()-&gt;value();
 298 }
 299 
 300 
 301 
 302 //--------------------------------------------------------------
 303 
 304 
 305 void LIRGenerator::block_do_prolog(BlockBegin* block) {
 306 #ifndef PRODUCT
 307   if (PrintIRWithLIR) {
 308     block-&gt;print();
 309   }
 310 #endif
 311 
 312   // set up the list of LIR instructions
 313   assert(block-&gt;lir() == NULL, &quot;LIR list already computed for this block&quot;);
 314   _lir = new LIR_List(compilation(), block);
 315   block-&gt;set_lir(_lir);
 316 
 317   __ branch_destination(block-&gt;label());
 318 
 319   if (LIRTraceExecution &amp;&amp;
 320       Compilation::current()-&gt;hir()-&gt;start()-&gt;block_id() != block-&gt;block_id() &amp;&amp;
 321       !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 322     assert(block-&gt;lir()-&gt;instructions_list()-&gt;length() == 1, &quot;should come right after br_dst&quot;);
 323     trace_block_entry(block);
 324   }
 325 }
 326 
 327 
 328 void LIRGenerator::block_do_epilog(BlockBegin* block) {
 329 #ifndef PRODUCT
 330   if (PrintIRWithLIR) {
 331     tty-&gt;cr();
 332   }
 333 #endif
 334 
 335   // LIR_Opr for unpinned constants shouldn&#39;t be referenced by other
 336   // blocks so clear them out after processing the block.
 337   for (int i = 0; i &lt; _unpinned_constants.length(); i++) {
 338     _unpinned_constants.at(i)-&gt;clear_operand();
 339   }
 340   _unpinned_constants.trunc_to(0);
 341 
 342   // clear our any registers for other local constants
 343   _constants.trunc_to(0);
 344   _reg_for_constants.trunc_to(0);
 345 }
 346 
 347 
 348 void LIRGenerator::block_do(BlockBegin* block) {
 349   CHECK_BAILOUT();
 350 
 351   block_do_prolog(block);
 352   set_block(block);
 353 
 354   for (Instruction* instr = block; instr != NULL; instr = instr-&gt;next()) {
 355     if (instr-&gt;is_pinned()) do_root(instr);
 356   }
 357 
 358   set_block(NULL);
 359   block_do_epilog(block);
 360 }
 361 
 362 
 363 //-------------------------LIRGenerator-----------------------------
 364 
 365 // This is where the tree-walk starts; instr must be root;
 366 void LIRGenerator::do_root(Value instr) {
 367   CHECK_BAILOUT();
 368 
 369   InstructionMark im(compilation(), instr);
 370 
 371   assert(instr-&gt;is_pinned(), &quot;use only with roots&quot;);
 372   assert(instr-&gt;subst() == instr, &quot;shouldn&#39;t have missed substitution&quot;);
 373 
 374   instr-&gt;visit(this);
 375 
 376   assert(!instr-&gt;has_uses() || instr-&gt;operand()-&gt;is_valid() ||
 377          instr-&gt;as_Constant() != NULL || bailed_out(), &quot;invalid item set&quot;);
 378 }
 379 
 380 
 381 // This is called for each node in tree; the walk stops if a root is reached
 382 void LIRGenerator::walk(Value instr) {
 383   InstructionMark im(compilation(), instr);
 384   //stop walk when encounter a root
 385   if ((instr-&gt;is_pinned() &amp;&amp; instr-&gt;as_Phi() == NULL) || instr-&gt;operand()-&gt;is_valid()) {
 386     assert(instr-&gt;operand() != LIR_OprFact::illegalOpr || instr-&gt;as_Constant() != NULL, &quot;this root has not yet been visited&quot;);
 387   } else {
 388     assert(instr-&gt;subst() == instr, &quot;shouldn&#39;t have missed substitution&quot;);
 389     instr-&gt;visit(this);
 390     // assert(instr-&gt;use_count() &gt; 0 || instr-&gt;as_Phi() != NULL, &quot;leaf instruction must have a use&quot;);
 391   }
 392 }
 393 
 394 
 395 CodeEmitInfo* LIRGenerator::state_for(Instruction* x, ValueStack* state, bool ignore_xhandler) {
 396   assert(state != NULL, &quot;state must be defined&quot;);
 397 
 398 #ifndef PRODUCT
 399   state-&gt;verify();
 400 #endif
 401 
 402   ValueStack* s = state;
 403   for_each_state(s) {
 404     if (s-&gt;kind() == ValueStack::EmptyExceptionState) {
 405       assert(s-&gt;stack_size() == 0 &amp;&amp; s-&gt;locals_size() == 0 &amp;&amp; (s-&gt;locks_size() == 0 || s-&gt;locks_size() == 1), &quot;state must be empty&quot;);
 406       continue;
 407     }
 408 
 409     int index;
 410     Value value;
 411     for_each_stack_value(s, index, value) {
 412       assert(value-&gt;subst() == value, &quot;missed substitution&quot;);
 413       if (!value-&gt;is_pinned() &amp;&amp; value-&gt;as_Constant() == NULL &amp;&amp; value-&gt;as_Local() == NULL) {
 414         walk(value);
 415         assert(value-&gt;operand()-&gt;is_valid(), &quot;must be evaluated now&quot;);
 416       }
 417     }
 418 
 419     int bci = s-&gt;bci();
 420     IRScope* scope = s-&gt;scope();
 421     ciMethod* method = scope-&gt;method();
 422 
 423     MethodLivenessResult liveness = method-&gt;liveness_at_bci(bci);
 424     if (bci == SynchronizationEntryBCI) {
 425       if (x-&gt;as_ExceptionObject() || x-&gt;as_Throw()) {
 426         // all locals are dead on exit from the synthetic unlocker
 427         liveness.clear();
 428       } else {
 429         assert(x-&gt;as_MonitorEnter() || x-&gt;as_ProfileInvoke(), &quot;only other cases are MonitorEnter and ProfileInvoke&quot;);
 430       }
 431     }
 432     if (!liveness.is_valid()) {
 433       // Degenerate or breakpointed method.
 434       bailout(&quot;Degenerate or breakpointed method&quot;);
 435     } else {
 436       assert((int)liveness.size() == s-&gt;locals_size(), &quot;error in use of liveness&quot;);
 437       for_each_local_value(s, index, value) {
 438         assert(value-&gt;subst() == value, &quot;missed substition&quot;);
 439         if (liveness.at(index) &amp;&amp; !value-&gt;type()-&gt;is_illegal()) {
 440           if (!value-&gt;is_pinned() &amp;&amp; value-&gt;as_Constant() == NULL &amp;&amp; value-&gt;as_Local() == NULL) {
 441             walk(value);
 442             assert(value-&gt;operand()-&gt;is_valid(), &quot;must be evaluated now&quot;);
 443           }
 444         } else {
 445           // NULL out this local so that linear scan can assume that all non-NULL values are live.
 446           s-&gt;invalidate_local(index);
 447         }
 448       }
 449     }
 450   }
 451 
 452   return new CodeEmitInfo(state, ignore_xhandler ? NULL : x-&gt;exception_handlers(), x-&gt;check_flag(Instruction::DeoptimizeOnException));
 453 }
 454 
 455 
 456 CodeEmitInfo* LIRGenerator::state_for(Instruction* x) {
 457   return state_for(x, x-&gt;exception_state());
 458 }
 459 
 460 
 461 void LIRGenerator::klass2reg_with_patching(LIR_Opr r, ciMetadata* obj, CodeEmitInfo* info, bool need_resolve) {
 462   /* C2 relies on constant pool entries being resolved (ciTypeFlow), so if TieredCompilation
 463    * is active and the class hasn&#39;t yet been resolved we need to emit a patch that resolves
 464    * the class. */
 465   if ((TieredCompilation &amp;&amp; need_resolve) || !obj-&gt;is_loaded() || PatchALot) {
 466     assert(info != NULL, &quot;info must be set if class is not loaded&quot;);
 467     __ klass2reg_patch(NULL, r, info);
 468   } else {
 469     // no patching needed
 470     __ metadata2reg(obj-&gt;constant_encoding(), r);
 471   }
 472 }
 473 
 474 
 475 void LIRGenerator::array_range_check(LIR_Opr array, LIR_Opr index,
 476                                     CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info) {
 477   CodeStub* stub = new RangeCheckStub(range_check_info, index, array);
 478   if (index-&gt;is_constant()) {
 479     cmp_mem_int(lir_cond_belowEqual, array, arrayOopDesc::length_offset_in_bytes(),
 480                 index-&gt;as_jint(), null_check_info);
 481     __ branch(lir_cond_belowEqual, T_INT, stub); // forward branch
 482   } else {
 483     cmp_reg_mem(lir_cond_aboveEqual, index, array,
 484                 arrayOopDesc::length_offset_in_bytes(), T_INT, null_check_info);
 485     __ branch(lir_cond_aboveEqual, T_INT, stub); // forward branch
 486   }
 487 }
 488 
 489 
 490 void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {
 491   CodeStub* stub = new RangeCheckStub(info, index);
 492   if (index-&gt;is_constant()) {
 493     cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index-&gt;as_jint(), info);
 494     __ branch(lir_cond_belowEqual, T_INT, stub); // forward branch
 495   } else {
 496     cmp_reg_mem(lir_cond_aboveEqual, index, buffer,
 497                 java_nio_Buffer::limit_offset(), T_INT, info);
 498     __ branch(lir_cond_aboveEqual, T_INT, stub); // forward branch
 499   }
 500   __ move(index, result);
 501 }
 502 
 503 
 504 
 505 void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp_op, CodeEmitInfo* info) {
 506   LIR_Opr result_op = result;
 507   LIR_Opr left_op   = left;
 508   LIR_Opr right_op  = right;
 509 
 510   if (TwoOperandLIRForm &amp;&amp; left_op != result_op) {
 511     assert(right_op != result_op, &quot;malformed&quot;);
 512     __ move(left_op, result_op);
 513     left_op = result_op;
 514   }
 515 
 516   switch(code) {
 517     case Bytecodes::_dadd:
 518     case Bytecodes::_fadd:
 519     case Bytecodes::_ladd:
 520     case Bytecodes::_iadd:  __ add(left_op, right_op, result_op); break;
 521     case Bytecodes::_fmul:
 522     case Bytecodes::_lmul:  __ mul(left_op, right_op, result_op); break;
 523 
 524     case Bytecodes::_dmul:
 525       {
 526         if (is_strictfp) {
 527           __ mul_strictfp(left_op, right_op, result_op, tmp_op); break;
 528         } else {
 529           __ mul(left_op, right_op, result_op); break;
 530         }
 531       }
 532       break;
 533 
 534     case Bytecodes::_imul:
 535       {
 536         bool did_strength_reduce = false;
 537 
 538         if (right-&gt;is_constant()) {
 539           jint c = right-&gt;as_jint();
 540           if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 541             // do not need tmp here
 542             __ shift_left(left_op, exact_log2(c), result_op);
 543             did_strength_reduce = true;
 544           } else {
 545             did_strength_reduce = strength_reduce_multiply(left_op, c, result_op, tmp_op);
 546           }
 547         }
 548         // we couldn&#39;t strength reduce so just emit the multiply
 549         if (!did_strength_reduce) {
 550           __ mul(left_op, right_op, result_op);
 551         }
 552       }
 553       break;
 554 
 555     case Bytecodes::_dsub:
 556     case Bytecodes::_fsub:
 557     case Bytecodes::_lsub:
 558     case Bytecodes::_isub: __ sub(left_op, right_op, result_op); break;
 559 
 560     case Bytecodes::_fdiv: __ div (left_op, right_op, result_op); break;
 561     // ldiv and lrem are implemented with a direct runtime call
 562 
 563     case Bytecodes::_ddiv:
 564       {
 565         if (is_strictfp) {
 566           __ div_strictfp (left_op, right_op, result_op, tmp_op); break;
 567         } else {
 568           __ div (left_op, right_op, result_op); break;
 569         }
 570       }
 571       break;
 572 
 573     case Bytecodes::_drem:
 574     case Bytecodes::_frem: __ rem (left_op, right_op, result_op); break;
 575 
 576     default: ShouldNotReachHere();
 577   }
 578 }
 579 
 580 
 581 void LIRGenerator::arithmetic_op_int(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp) {
 582   arithmetic_op(code, result, left, right, false, tmp);
 583 }
 584 
 585 
 586 void LIRGenerator::arithmetic_op_long(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info) {
 587   arithmetic_op(code, result, left, right, false, LIR_OprFact::illegalOpr, info);
 588 }
 589 
 590 
 591 void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp) {
 592   arithmetic_op(code, result, left, right, is_strictfp, tmp);
 593 }
 594 
 595 
 596 void LIRGenerator::shift_op(Bytecodes::Code code, LIR_Opr result_op, LIR_Opr value, LIR_Opr count, LIR_Opr tmp) {
 597 
 598   if (TwoOperandLIRForm &amp;&amp; value != result_op
 599       // Only 32bit right shifts require two operand form on S390.
 600       S390_ONLY(&amp;&amp; (code == Bytecodes::_ishr || code == Bytecodes::_iushr))) {
 601     assert(count != result_op, &quot;malformed&quot;);
 602     __ move(value, result_op);
 603     value = result_op;
 604   }
 605 
 606   assert(count-&gt;is_constant() || count-&gt;is_register(), &quot;must be&quot;);
 607   switch(code) {
 608   case Bytecodes::_ishl:
 609   case Bytecodes::_lshl: __ shift_left(value, count, result_op, tmp); break;
 610   case Bytecodes::_ishr:
 611   case Bytecodes::_lshr: __ shift_right(value, count, result_op, tmp); break;
 612   case Bytecodes::_iushr:
 613   case Bytecodes::_lushr: __ unsigned_shift_right(value, count, result_op, tmp); break;
 614   default: ShouldNotReachHere();
 615   }
 616 }
 617 
 618 
 619 void LIRGenerator::logic_op (Bytecodes::Code code, LIR_Opr result_op, LIR_Opr left_op, LIR_Opr right_op) {
 620   if (TwoOperandLIRForm &amp;&amp; left_op != result_op) {
 621     assert(right_op != result_op, &quot;malformed&quot;);
 622     __ move(left_op, result_op);
 623     left_op = result_op;
 624   }
 625 
 626   switch(code) {
 627     case Bytecodes::_iand:
 628     case Bytecodes::_land:  __ logical_and(left_op, right_op, result_op); break;
 629 
 630     case Bytecodes::_ior:
 631     case Bytecodes::_lor:   __ logical_or(left_op, right_op, result_op);  break;
 632 
 633     case Bytecodes::_ixor:
 634     case Bytecodes::_lxor:  __ logical_xor(left_op, right_op, result_op); break;
 635 
 636     default: ShouldNotReachHere();
 637   }
 638 }
 639 
 640 
 641 void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) {
 642   if (!GenerateSynchronizationCode) return;
 643   // for slow path, use debug info for state after successful locking
 644   CodeStub* slow_path = new MonitorEnterStub(object, lock, info);
 645   __ load_stack_address_monitor(monitor_no, lock);
 646   // for handling NullPointerException, use debug info representing just the lock stack before this monitorenter
 647   __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);
 648 }
 649 
 650 
 651 void LIRGenerator::monitor_exit(LIR_Opr object, LIR_Opr lock, LIR_Opr new_hdr, LIR_Opr scratch, int monitor_no) {
 652   if (!GenerateSynchronizationCode) return;
 653   // setup registers
 654   LIR_Opr hdr = lock;
 655   lock = new_hdr;
 656   CodeStub* slow_path = new MonitorExitStub(lock, UseFastLocking, monitor_no);
 657   __ load_stack_address_monitor(monitor_no, lock);
 658   __ unlock_object(hdr, object, lock, scratch, slow_path);
 659 }
 660 
 661 #ifndef PRODUCT
 662 void LIRGenerator::print_if_not_loaded(const NewInstance* new_instance) {
 663   if (PrintNotLoaded &amp;&amp; !new_instance-&gt;klass()-&gt;is_loaded()) {
 664     tty-&gt;print_cr(&quot;   ###class not loaded at new bci %d&quot;, new_instance-&gt;printable_bci());
 665   } else if (PrintNotLoaded &amp;&amp; (TieredCompilation &amp;&amp; new_instance-&gt;is_unresolved())) {
 666     tty-&gt;print_cr(&quot;   ###class not resolved at new bci %d&quot;, new_instance-&gt;printable_bci());
 667   }
 668 }
 669 #endif
 670 
 671 void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {
 672   klass2reg_with_patching(klass_reg, klass, info, is_unresolved);
 673   // If klass is not loaded we do not know if the klass has finalizers:
 674   if (UseFastNewInstance &amp;&amp; klass-&gt;is_loaded()
 675       &amp;&amp; !Klass::layout_helper_needs_slow_path(klass-&gt;layout_helper())) {
 676 
 677     Runtime1::StubID stub_id = klass-&gt;is_initialized() ? Runtime1::fast_new_instance_id : Runtime1::fast_new_instance_init_check_id;
 678 
 679     CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, stub_id);
 680 
 681     assert(klass-&gt;is_loaded(), &quot;must be loaded&quot;);
 682     // allocate space for instance
 683     assert(klass-&gt;size_helper() &gt;= 0, &quot;illegal instance size&quot;);
 684     const int instance_size = align_object_size(klass-&gt;size_helper());
 685     __ allocate_object(dst, scratch1, scratch2, scratch3, scratch4,
 686                        oopDesc::header_size(), instance_size, klass_reg, !klass-&gt;is_initialized(), slow_path);
 687   } else {
 688     CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);
 689     __ branch(lir_cond_always, T_ILLEGAL, slow_path);
 690     __ branch_destination(slow_path-&gt;continuation());
 691   }
 692 }
 693 
 694 
 695 static bool is_constant_zero(Instruction* inst) {
 696   IntConstant* c = inst-&gt;type()-&gt;as_IntConstant();
 697   if (c) {
 698     return (c-&gt;value() == 0);
 699   }
 700   return false;
 701 }
 702 
 703 
 704 static bool positive_constant(Instruction* inst) {
 705   IntConstant* c = inst-&gt;type()-&gt;as_IntConstant();
 706   if (c) {
 707     return (c-&gt;value() &gt;= 0);
 708   }
 709   return false;
 710 }
 711 
 712 
 713 static ciArrayKlass* as_array_klass(ciType* type) {
 714   if (type != NULL &amp;&amp; type-&gt;is_array_klass() &amp;&amp; type-&gt;is_loaded()) {
 715     return (ciArrayKlass*)type;
 716   } else {
 717     return NULL;
 718   }
 719 }
 720 
 721 static ciType* phi_declared_type(Phi* phi) {
 722   ciType* t = phi-&gt;operand_at(0)-&gt;declared_type();
 723   if (t == NULL) {
 724     return NULL;
 725   }
 726   for(int i = 1; i &lt; phi-&gt;operand_count(); i++) {
 727     if (t != phi-&gt;operand_at(i)-&gt;declared_type()) {
 728       return NULL;
 729     }
 730   }
 731   return t;
 732 }
 733 
 734 void LIRGenerator::arraycopy_helper(Intrinsic* x, int* flagsp, ciArrayKlass** expected_typep) {
 735   Instruction* src     = x-&gt;argument_at(0);
 736   Instruction* src_pos = x-&gt;argument_at(1);
 737   Instruction* dst     = x-&gt;argument_at(2);
 738   Instruction* dst_pos = x-&gt;argument_at(3);
 739   Instruction* length  = x-&gt;argument_at(4);
 740 
 741   // first try to identify the likely type of the arrays involved
 742   ciArrayKlass* expected_type = NULL;
 743   bool is_exact = false, src_objarray = false, dst_objarray = false;
 744   {
 745     ciArrayKlass* src_exact_type    = as_array_klass(src-&gt;exact_type());
 746     ciArrayKlass* src_declared_type = as_array_klass(src-&gt;declared_type());
 747     Phi* phi;
 748     if (src_declared_type == NULL &amp;&amp; (phi = src-&gt;as_Phi()) != NULL) {
 749       src_declared_type = as_array_klass(phi_declared_type(phi));
 750     }
 751     ciArrayKlass* dst_exact_type    = as_array_klass(dst-&gt;exact_type());
 752     ciArrayKlass* dst_declared_type = as_array_klass(dst-&gt;declared_type());
 753     if (dst_declared_type == NULL &amp;&amp; (phi = dst-&gt;as_Phi()) != NULL) {
 754       dst_declared_type = as_array_klass(phi_declared_type(phi));
 755     }
 756 
 757     if (src_exact_type != NULL &amp;&amp; src_exact_type == dst_exact_type) {
 758       // the types exactly match so the type is fully known
 759       is_exact = true;
 760       expected_type = src_exact_type;
 761     } else if (dst_exact_type != NULL &amp;&amp; dst_exact_type-&gt;is_obj_array_klass()) {
 762       ciArrayKlass* dst_type = (ciArrayKlass*) dst_exact_type;
 763       ciArrayKlass* src_type = NULL;
 764       if (src_exact_type != NULL &amp;&amp; src_exact_type-&gt;is_obj_array_klass()) {
 765         src_type = (ciArrayKlass*) src_exact_type;
 766       } else if (src_declared_type != NULL &amp;&amp; src_declared_type-&gt;is_obj_array_klass()) {
 767         src_type = (ciArrayKlass*) src_declared_type;
 768       }
 769       if (src_type != NULL) {
 770         if (src_type-&gt;element_type()-&gt;is_subtype_of(dst_type-&gt;element_type())) {
 771           is_exact = true;
 772           expected_type = dst_type;
 773         }
 774       }
 775     }
 776     // at least pass along a good guess
 777     if (expected_type == NULL) expected_type = dst_exact_type;
 778     if (expected_type == NULL) expected_type = src_declared_type;
 779     if (expected_type == NULL) expected_type = dst_declared_type;
 780 
 781     src_objarray = (src_exact_type &amp;&amp; src_exact_type-&gt;is_obj_array_klass()) || (src_declared_type &amp;&amp; src_declared_type-&gt;is_obj_array_klass());
 782     dst_objarray = (dst_exact_type &amp;&amp; dst_exact_type-&gt;is_obj_array_klass()) || (dst_declared_type &amp;&amp; dst_declared_type-&gt;is_obj_array_klass());
 783   }
 784 
 785   // if a probable array type has been identified, figure out if any
 786   // of the required checks for a fast case can be elided.
 787   int flags = LIR_OpArrayCopy::all_flags;
 788 
 789   if (!src_objarray)
 790     flags &amp;= ~LIR_OpArrayCopy::src_objarray;
 791   if (!dst_objarray)
 792     flags &amp;= ~LIR_OpArrayCopy::dst_objarray;
 793 
 794   if (!x-&gt;arg_needs_null_check(0))
 795     flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 796   if (!x-&gt;arg_needs_null_check(2))
 797     flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 798 
 799 
 800   if (expected_type != NULL) {
 801     Value length_limit = NULL;
 802 
 803     IfOp* ifop = length-&gt;as_IfOp();
 804     if (ifop != NULL) {
 805       // look for expressions like min(v, a.length) which ends up as
 806       //   x &gt; y ? y : x  or  x &gt;= y ? y : x
 807       if ((ifop-&gt;cond() == If::gtr || ifop-&gt;cond() == If::geq) &amp;&amp;
 808           ifop-&gt;x() == ifop-&gt;fval() &amp;&amp;
 809           ifop-&gt;y() == ifop-&gt;tval()) {
 810         length_limit = ifop-&gt;y();
 811       }
 812     }
 813 
 814     // try to skip null checks and range checks
 815     NewArray* src_array = src-&gt;as_NewArray();
 816     if (src_array != NULL) {
 817       flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 818       if (length_limit != NULL &amp;&amp;
 819           src_array-&gt;length() == length_limit &amp;&amp;
 820           is_constant_zero(src_pos)) {
 821         flags &amp;= ~LIR_OpArrayCopy::src_range_check;
 822       }
 823     }
 824 
 825     NewArray* dst_array = dst-&gt;as_NewArray();
 826     if (dst_array != NULL) {
 827       flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 828       if (length_limit != NULL &amp;&amp;
 829           dst_array-&gt;length() == length_limit &amp;&amp;
 830           is_constant_zero(dst_pos)) {
 831         flags &amp;= ~LIR_OpArrayCopy::dst_range_check;
 832       }
 833     }
 834 
 835     // check from incoming constant values
 836     if (positive_constant(src_pos))
 837       flags &amp;= ~LIR_OpArrayCopy::src_pos_positive_check;
 838     if (positive_constant(dst_pos))
 839       flags &amp;= ~LIR_OpArrayCopy::dst_pos_positive_check;
 840     if (positive_constant(length))
 841       flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 842 
 843     // see if the range check can be elided, which might also imply
 844     // that src or dst is non-null.
 845     ArrayLength* al = length-&gt;as_ArrayLength();
 846     if (al != NULL) {
 847       if (al-&gt;array() == src) {
 848         // it&#39;s the length of the source array
 849         flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 850         flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 851         if (is_constant_zero(src_pos))
 852           flags &amp;= ~LIR_OpArrayCopy::src_range_check;
 853       }
 854       if (al-&gt;array() == dst) {
 855         // it&#39;s the length of the destination array
 856         flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 857         flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 858         if (is_constant_zero(dst_pos))
 859           flags &amp;= ~LIR_OpArrayCopy::dst_range_check;
 860       }
 861     }
 862     if (is_exact) {
 863       flags &amp;= ~LIR_OpArrayCopy::type_check;
 864     }
 865   }
 866 
 867   IntConstant* src_int = src_pos-&gt;type()-&gt;as_IntConstant();
 868   IntConstant* dst_int = dst_pos-&gt;type()-&gt;as_IntConstant();
 869   if (src_int &amp;&amp; dst_int) {
 870     int s_offs = src_int-&gt;value();
 871     int d_offs = dst_int-&gt;value();
 872     if (src_int-&gt;value() &gt;= dst_int-&gt;value()) {
 873       flags &amp;= ~LIR_OpArrayCopy::overlapping;
 874     }
 875     if (expected_type != NULL) {
 876       BasicType t = expected_type-&gt;element_type()-&gt;basic_type();
 877       int element_size = type2aelembytes(t);
 878       if (((arrayOopDesc::base_offset_in_bytes(t) + s_offs * element_size) % HeapWordSize == 0) &amp;&amp;
 879           ((arrayOopDesc::base_offset_in_bytes(t) + d_offs * element_size) % HeapWordSize == 0)) {
 880         flags &amp;= ~LIR_OpArrayCopy::unaligned;
 881       }
 882     }
 883   } else if (src_pos == dst_pos || is_constant_zero(dst_pos)) {
 884     // src and dest positions are the same, or dst is zero so assume
 885     // nonoverlapping copy.
 886     flags &amp;= ~LIR_OpArrayCopy::overlapping;
 887   }
 888 
 889   if (src == dst) {
 890     // moving within a single array so no type checks are needed
 891     if (flags &amp; LIR_OpArrayCopy::type_check) {
 892       flags &amp;= ~LIR_OpArrayCopy::type_check;
 893     }
 894   }
 895   *flagsp = flags;
 896   *expected_typep = (ciArrayKlass*)expected_type;
 897 }
 898 
 899 
 900 LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
 901   assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
 902 
<a name="4" id="anc4"></a><span class="line-modified"> 903   if (strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified"> 904 #ifdef IA32</span>
<span class="line-modified"> 905     if (UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {</span>
<span class="line-modified"> 906       LIR_Opr result = new_register(T_FLOAT);</span>
<span class="line-modified"> 907       set_vreg_flag(result, must_start_in_memory);</span>
<span class="line-modified"> 908       assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);</span>
<span class="line-modified"> 909       assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);</span>
<span class="line-added"> 910       __ roundfp(opr, LIR_OprFact::illegalOpr, result);</span>
<span class="line-added"> 911       return result;</span>
<span class="line-added"> 912     }</span>
<span class="line-added"> 913 #else</span>
<span class="line-added"> 914     Unimplemented();</span>
<span class="line-added"> 915 #endif // IA32</span>
 916   }
 917   return opr;
 918 }
 919 
 920 
 921 LIR_Opr LIRGenerator::force_to_spill(LIR_Opr value, BasicType t) {
 922   assert(type2size[t] == type2size[value-&gt;type()],
 923          &quot;size mismatch: t=%s, value-&gt;type()=%s&quot;, type2name(t), type2name(value-&gt;type()));
 924   if (!value-&gt;is_register()) {
 925     // force into a register
 926     LIR_Opr r = new_register(value-&gt;type());
 927     __ move(value, r);
 928     value = r;
 929   }
 930 
 931   // create a spill location
 932   LIR_Opr tmp = new_register(t);
 933   set_vreg_flag(tmp, LIRGenerator::must_start_in_memory);
 934 
 935   // move from register to spill
 936   __ move(value, tmp);
 937   return tmp;
 938 }
 939 
 940 void LIRGenerator::profile_branch(If* if_instr, If::Condition cond) {
 941   if (if_instr-&gt;should_profile()) {
 942     ciMethod* method = if_instr-&gt;profiled_method();
 943     assert(method != NULL, &quot;method should be set if branch is profiled&quot;);
 944     ciMethodData* md = method-&gt;method_data_or_null();
 945     assert(md != NULL, &quot;Sanity&quot;);
 946     ciProfileData* data = md-&gt;bci_to_data(if_instr-&gt;profiled_bci());
 947     assert(data != NULL, &quot;must have profiling data&quot;);
 948     assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
 949     int taken_count_offset     = md-&gt;byte_offset_of_slot(data, BranchData::taken_offset());
 950     int not_taken_count_offset = md-&gt;byte_offset_of_slot(data, BranchData::not_taken_offset());
 951     if (if_instr-&gt;is_swapped()) {
 952       int t = taken_count_offset;
 953       taken_count_offset = not_taken_count_offset;
 954       not_taken_count_offset = t;
 955     }
 956 
 957     LIR_Opr md_reg = new_register(T_METADATA);
 958     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
 959 
 960     LIR_Opr data_offset_reg = new_pointer_register();
 961     __ cmove(lir_cond(cond),
 962              LIR_OprFact::intptrConst(taken_count_offset),
 963              LIR_OprFact::intptrConst(not_taken_count_offset),
 964              data_offset_reg, as_BasicType(if_instr-&gt;x()-&gt;type()));
 965 
 966     // MDO cells are intptr_t, so the data_reg width is arch-dependent.
 967     LIR_Opr data_reg = new_pointer_register();
 968     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
 969     __ move(data_addr, data_reg);
 970     // Use leal instead of add to avoid destroying condition codes on x86
 971     LIR_Address* fake_incr_value = new LIR_Address(data_reg, DataLayout::counter_increment, T_INT);
 972     __ leal(LIR_OprFact::address(fake_incr_value), data_reg);
 973     __ move(data_reg, data_addr);
 974   }
 975 }
 976 
 977 // Phi technique:
 978 // This is about passing live values from one basic block to the other.
 979 // In code generated with Java it is rather rare that more than one
 980 // value is on the stack from one basic block to the other.
 981 // We optimize our technique for efficient passing of one value
 982 // (of type long, int, double..) but it can be extended.
 983 // When entering or leaving a basic block, all registers and all spill
 984 // slots are release and empty. We use the released registers
 985 // and spill slots to pass the live values from one block
 986 // to the other. The topmost value, i.e., the value on TOS of expression
 987 // stack is passed in registers. All other values are stored in spilling
 988 // area. Every Phi has an index which designates its spill slot
 989 // At exit of a basic block, we fill the register(s) and spill slots.
 990 // At entry of a basic block, the block_prolog sets up the content of phi nodes
 991 // and locks necessary registers and spilling slots.
 992 
 993 
 994 // move current value to referenced phi function
 995 void LIRGenerator::move_to_phi(PhiResolver* resolver, Value cur_val, Value sux_val) {
 996   Phi* phi = sux_val-&gt;as_Phi();
 997   // cur_val can be null without phi being null in conjunction with inlining
 998   if (phi != NULL &amp;&amp; cur_val != NULL &amp;&amp; cur_val != phi &amp;&amp; !phi-&gt;is_illegal()) {
 999     Phi* cur_phi = cur_val-&gt;as_Phi();
1000     if (cur_phi != NULL &amp;&amp; cur_phi-&gt;is_illegal()) {
1001       // Phi and local would need to get invalidated
1002       // (which is unexpected for Linear Scan).
1003       // But this case is very rare so we simply bail out.
1004       bailout(&quot;propagation of illegal phi&quot;);
1005       return;
1006     }
1007     LIR_Opr operand = cur_val-&gt;operand();
1008     if (operand-&gt;is_illegal()) {
1009       assert(cur_val-&gt;as_Constant() != NULL || cur_val-&gt;as_Local() != NULL,
1010              &quot;these can be produced lazily&quot;);
1011       operand = operand_for_instruction(cur_val);
1012     }
1013     resolver-&gt;move(operand, operand_for_instruction(phi));
1014   }
1015 }
1016 
1017 
1018 // Moves all stack values into their PHI position
1019 void LIRGenerator::move_to_phi(ValueStack* cur_state) {
1020   BlockBegin* bb = block();
1021   if (bb-&gt;number_of_sux() == 1) {
1022     BlockBegin* sux = bb-&gt;sux_at(0);
1023     assert(sux-&gt;number_of_preds() &gt; 0, &quot;invalid CFG&quot;);
1024 
1025     // a block with only one predecessor never has phi functions
1026     if (sux-&gt;number_of_preds() &gt; 1) {
1027       PhiResolver resolver(this);
1028 
1029       ValueStack* sux_state = sux-&gt;state();
1030       Value sux_value;
1031       int index;
1032 
1033       assert(cur_state-&gt;scope() == sux_state-&gt;scope(), &quot;not matching&quot;);
1034       assert(cur_state-&gt;locals_size() == sux_state-&gt;locals_size(), &quot;not matching&quot;);
1035       assert(cur_state-&gt;stack_size() == sux_state-&gt;stack_size(), &quot;not matching&quot;);
1036 
1037       for_each_stack_value(sux_state, index, sux_value) {
1038         move_to_phi(&amp;resolver, cur_state-&gt;stack_at(index), sux_value);
1039       }
1040 
1041       for_each_local_value(sux_state, index, sux_value) {
1042         move_to_phi(&amp;resolver, cur_state-&gt;local_at(index), sux_value);
1043       }
1044 
1045       assert(cur_state-&gt;caller_state() == sux_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
1046     }
1047   }
1048 }
1049 
1050 
1051 LIR_Opr LIRGenerator::new_register(BasicType type) {
1052   int vreg = _virtual_register_number;
1053   // add a little fudge factor for the bailout, since the bailout is
1054   // only checked periodically.  This gives a few extra registers to
1055   // hand out before we really run out, which helps us keep from
1056   // tripping over assertions.
1057   if (vreg + 20 &gt;= LIR_OprDesc::vreg_max) {
1058     bailout(&quot;out of virtual registers&quot;);
1059     if (vreg + 2 &gt;= LIR_OprDesc::vreg_max) {
1060       // wrap it around
1061       _virtual_register_number = LIR_OprDesc::vreg_base;
1062     }
1063   }
1064   _virtual_register_number += 1;
1065   return LIR_OprFact::virtual_register(vreg, type);
1066 }
1067 
1068 
1069 // Try to lock using register in hint
1070 LIR_Opr LIRGenerator::rlock(Value instr) {
1071   return new_register(instr-&gt;type());
1072 }
1073 
1074 
1075 // does an rlock and sets result
1076 LIR_Opr LIRGenerator::rlock_result(Value x) {
1077   LIR_Opr reg = rlock(x);
1078   set_result(x, reg);
1079   return reg;
1080 }
1081 
1082 
1083 // does an rlock and sets result
1084 LIR_Opr LIRGenerator::rlock_result(Value x, BasicType type) {
1085   LIR_Opr reg;
1086   switch (type) {
1087   case T_BYTE:
1088   case T_BOOLEAN:
1089     reg = rlock_byte(type);
1090     break;
1091   default:
1092     reg = rlock(x);
1093     break;
1094   }
1095 
1096   set_result(x, reg);
1097   return reg;
1098 }
1099 
1100 
1101 //---------------------------------------------------------------------
1102 ciObject* LIRGenerator::get_jobject_constant(Value value) {
1103   ObjectType* oc = value-&gt;type()-&gt;as_ObjectType();
1104   if (oc) {
1105     return oc-&gt;constant_value();
1106   }
1107   return NULL;
1108 }
1109 
1110 
1111 void LIRGenerator::do_ExceptionObject(ExceptionObject* x) {
1112   assert(block()-&gt;is_set(BlockBegin::exception_entry_flag), &quot;ExceptionObject only allowed in exception handler block&quot;);
1113   assert(block()-&gt;next() == x, &quot;ExceptionObject must be first instruction of block&quot;);
1114 
1115   // no moves are created for phi functions at the begin of exception
1116   // handlers, so assign operands manually here
1117   for_each_phi_fun(block(), phi,
1118                    if (!phi-&gt;is_illegal()) { operand_for_instruction(phi); });
1119 
1120   LIR_Opr thread_reg = getThreadPointer();
1121   __ move_wide(new LIR_Address(thread_reg, in_bytes(JavaThread::exception_oop_offset()), T_OBJECT),
1122                exceptionOopOpr());
1123   __ move_wide(LIR_OprFact::oopConst(NULL),
1124                new LIR_Address(thread_reg, in_bytes(JavaThread::exception_oop_offset()), T_OBJECT));
1125   __ move_wide(LIR_OprFact::oopConst(NULL),
1126                new LIR_Address(thread_reg, in_bytes(JavaThread::exception_pc_offset()), T_OBJECT));
1127 
1128   LIR_Opr result = new_register(T_OBJECT);
1129   __ move(exceptionOopOpr(), result);
1130   set_result(x, result);
1131 }
1132 
1133 
1134 //----------------------------------------------------------------------
1135 //----------------------------------------------------------------------
1136 //----------------------------------------------------------------------
1137 //----------------------------------------------------------------------
1138 //                        visitor functions
1139 //----------------------------------------------------------------------
1140 //----------------------------------------------------------------------
1141 //----------------------------------------------------------------------
1142 //----------------------------------------------------------------------
1143 
1144 void LIRGenerator::do_Phi(Phi* x) {
1145   // phi functions are never visited directly
1146   ShouldNotReachHere();
1147 }
1148 
1149 
1150 // Code for a constant is generated lazily unless the constant is frequently used and can&#39;t be inlined.
1151 void LIRGenerator::do_Constant(Constant* x) {
1152   if (x-&gt;state_before() != NULL) {
1153     // Any constant with a ValueStack requires patching so emit the patch here
1154     LIR_Opr reg = rlock_result(x);
1155     CodeEmitInfo* info = state_for(x, x-&gt;state_before());
1156     __ oop2reg_patch(NULL, reg, info);
1157   } else if (x-&gt;use_count() &gt; 1 &amp;&amp; !can_inline_as_constant(x)) {
1158     if (!x-&gt;is_pinned()) {
1159       // unpinned constants are handled specially so that they can be
1160       // put into registers when they are used multiple times within a
1161       // block.  After the block completes their operand will be
1162       // cleared so that other blocks can&#39;t refer to that register.
1163       set_result(x, load_constant(x));
1164     } else {
1165       LIR_Opr res = x-&gt;operand();
1166       if (!res-&gt;is_valid()) {
1167         res = LIR_OprFact::value_type(x-&gt;type());
1168       }
1169       if (res-&gt;is_constant()) {
1170         LIR_Opr reg = rlock_result(x);
1171         __ move(res, reg);
1172       } else {
1173         set_result(x, res);
1174       }
1175     }
1176   } else {
1177     set_result(x, LIR_OprFact::value_type(x-&gt;type()));
1178   }
1179 }
1180 
1181 
1182 void LIRGenerator::do_Local(Local* x) {
1183   // operand_for_instruction has the side effect of setting the result
1184   // so there&#39;s no need to do it here.
1185   operand_for_instruction(x);
1186 }
1187 
1188 
1189 void LIRGenerator::do_IfInstanceOf(IfInstanceOf* x) {
1190   Unimplemented();
1191 }
1192 
1193 
1194 void LIRGenerator::do_Return(Return* x) {
1195   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
1196     BasicTypeList signature;
1197     signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
1198     signature.append(T_METADATA); // Method*
1199     LIR_OprList* args = new LIR_OprList();
1200     args-&gt;append(getThreadPointer());
1201     LIR_Opr meth = new_register(T_METADATA);
1202     __ metadata2reg(method()-&gt;constant_encoding(), meth);
1203     args-&gt;append(meth);
1204     call_runtime(&amp;signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, NULL);
1205   }
1206 
1207   if (x-&gt;type()-&gt;is_void()) {
1208     __ return_op(LIR_OprFact::illegalOpr);
1209   } else {
1210     LIR_Opr reg = result_register_for(x-&gt;type(), /*callee=*/true);
1211     LIRItem result(x-&gt;result(), this);
1212 
1213     result.load_item_force(reg);
1214     __ return_op(result.result());
1215   }
1216   set_no_result(x);
1217 }
1218 
1219 // Examble: ref.get()
1220 // Combination of LoadField and g1 pre-write barrier
1221 void LIRGenerator::do_Reference_get(Intrinsic* x) {
1222 
1223   const int referent_offset = java_lang_ref_Reference::referent_offset;
1224   guarantee(referent_offset &gt; 0, &quot;referent offset not initialized&quot;);
1225 
1226   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1227 
1228   LIRItem reference(x-&gt;argument_at(0), this);
1229   reference.load_item();
1230 
1231   // need to perform the null check on the reference objecy
1232   CodeEmitInfo* info = NULL;
1233   if (x-&gt;needs_null_check()) {
1234     info = state_for(x);
1235   }
1236 
1237   LIR_Opr result = rlock_result(x, T_OBJECT);
1238   access_load_at(IN_HEAP | ON_WEAK_OOP_REF, T_OBJECT,
1239                  reference, LIR_OprFact::intConst(referent_offset), result);
1240 }
1241 
1242 // Example: clazz.isInstance(object)
1243 void LIRGenerator::do_isInstance(Intrinsic* x) {
1244   assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
1245 
1246   // TODO could try to substitute this node with an equivalent InstanceOf
1247   // if clazz is known to be a constant Class. This will pick up newly found
1248   // constants after HIR construction. I&#39;ll leave this to a future change.
1249 
1250   // as a first cut, make a simple leaf call to runtime to stay platform independent.
1251   // could follow the aastore example in a future change.
1252 
1253   LIRItem clazz(x-&gt;argument_at(0), this);
1254   LIRItem object(x-&gt;argument_at(1), this);
1255   clazz.load_item();
1256   object.load_item();
1257   LIR_Opr result = rlock_result(x);
1258 
1259   // need to perform null check on clazz
1260   if (x-&gt;needs_null_check()) {
1261     CodeEmitInfo* info = state_for(x);
1262     __ null_check(clazz.result(), info);
1263   }
1264 
1265   LIR_Opr call_result = call_runtime(clazz.value(), object.value(),
1266                                      CAST_FROM_FN_PTR(address, Runtime1::is_instance_of),
1267                                      x-&gt;type(),
1268                                      NULL); // NULL CodeEmitInfo results in a leaf call
1269   __ move(call_result, result);
1270 }
1271 
1272 // Example: object.getClass ()
1273 void LIRGenerator::do_getClass(Intrinsic* x) {
1274   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1275 
1276   LIRItem rcvr(x-&gt;argument_at(0), this);
1277   rcvr.load_item();
1278   LIR_Opr temp = new_register(T_METADATA);
1279   LIR_Opr result = rlock_result(x);
1280 
1281   // need to perform the null check on the rcvr
1282   CodeEmitInfo* info = NULL;
1283   if (x-&gt;needs_null_check()) {
1284     info = state_for(x);
1285   }
1286 
1287   // FIXME T_ADDRESS should actually be T_METADATA but it can&#39;t because the
1288   // meaning of these two is mixed up (see JDK-8026837).
1289   __ move(new LIR_Address(rcvr.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), temp, info);
1290   __ move_wide(new LIR_Address(temp, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);
1291   // mirror = ((OopHandle)mirror)-&gt;resolve();
1292   access_load(IN_NATIVE, T_OBJECT,
1293               LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), result);
1294 }
1295 
1296 // java.lang.Class::isPrimitive()
1297 void LIRGenerator::do_isPrimitive(Intrinsic* x) {
1298   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1299 
1300   LIRItem rcvr(x-&gt;argument_at(0), this);
1301   rcvr.load_item();
1302   LIR_Opr temp = new_register(T_METADATA);
1303   LIR_Opr result = rlock_result(x);
1304 
1305   CodeEmitInfo* info = NULL;
1306   if (x-&gt;needs_null_check()) {
1307     info = state_for(x);
1308   }
1309 
1310   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);
<a name="5" id="anc5"></a><span class="line-modified">1311   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));</span>
1312   __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
1313 }
1314 
1315 
1316 // Example: Thread.currentThread()
1317 void LIRGenerator::do_currentThread(Intrinsic* x) {
1318   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
1319   LIR_Opr reg = rlock_result(x);
1320   __ move_wide(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_OBJECT), reg);
1321 }
1322 
1323 
1324 void LIRGenerator::do_RegisterFinalizer(Intrinsic* x) {
1325   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1326   LIRItem receiver(x-&gt;argument_at(0), this);
1327 
1328   receiver.load_item();
1329   BasicTypeList signature;
1330   signature.append(T_OBJECT); // receiver
1331   LIR_OprList* args = new LIR_OprList();
1332   args-&gt;append(receiver.result());
1333   CodeEmitInfo* info = state_for(x, x-&gt;state());
1334   call_runtime(&amp;signature, args,
1335                CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::register_finalizer_id)),
1336                voidType, info);
1337 
1338   set_no_result(x);
1339 }
1340 
1341 
1342 //------------------------local access--------------------------------------
1343 
1344 LIR_Opr LIRGenerator::operand_for_instruction(Instruction* x) {
1345   if (x-&gt;operand()-&gt;is_illegal()) {
1346     Constant* c = x-&gt;as_Constant();
1347     if (c != NULL) {
1348       x-&gt;set_operand(LIR_OprFact::value_type(c-&gt;type()));
1349     } else {
1350       assert(x-&gt;as_Phi() || x-&gt;as_Local() != NULL, &quot;only for Phi and Local&quot;);
1351       // allocate a virtual register for this local or phi
1352       x-&gt;set_operand(rlock(x));
1353       _instruction_for_operand.at_put_grow(x-&gt;operand()-&gt;vreg_number(), x, NULL);
1354     }
1355   }
1356   return x-&gt;operand();
1357 }
1358 
1359 
1360 Instruction* LIRGenerator::instruction_for_opr(LIR_Opr opr) {
1361   if (opr-&gt;is_virtual()) {
1362     return instruction_for_vreg(opr-&gt;vreg_number());
1363   }
1364   return NULL;
1365 }
1366 
1367 
1368 Instruction* LIRGenerator::instruction_for_vreg(int reg_num) {
1369   if (reg_num &lt; _instruction_for_operand.length()) {
1370     return _instruction_for_operand.at(reg_num);
1371   }
1372   return NULL;
1373 }
1374 
1375 
1376 void LIRGenerator::set_vreg_flag(int vreg_num, VregFlag f) {
1377   if (_vreg_flags.size_in_bits() == 0) {
1378     BitMap2D temp(100, num_vreg_flags);
1379     _vreg_flags = temp;
1380   }
1381   _vreg_flags.at_put_grow(vreg_num, f, true);
1382 }
1383 
1384 bool LIRGenerator::is_vreg_flag_set(int vreg_num, VregFlag f) {
1385   if (!_vreg_flags.is_valid_index(vreg_num, f)) {
1386     return false;
1387   }
1388   return _vreg_flags.at(vreg_num, f);
1389 }
1390 
1391 
1392 // Block local constant handling.  This code is useful for keeping
1393 // unpinned constants and constants which aren&#39;t exposed in the IR in
1394 // registers.  Unpinned Constant instructions have their operands
1395 // cleared when the block is finished so that other blocks can&#39;t end
1396 // up referring to their registers.
1397 
1398 LIR_Opr LIRGenerator::load_constant(Constant* x) {
1399   assert(!x-&gt;is_pinned(), &quot;only for unpinned constants&quot;);
1400   _unpinned_constants.append(x);
1401   return load_constant(LIR_OprFact::value_type(x-&gt;type())-&gt;as_constant_ptr());
1402 }
1403 
1404 
1405 LIR_Opr LIRGenerator::load_constant(LIR_Const* c) {
1406   BasicType t = c-&gt;type();
1407   for (int i = 0; i &lt; _constants.length(); i++) {
1408     LIR_Const* other = _constants.at(i);
1409     if (t == other-&gt;type()) {
1410       switch (t) {
1411       case T_INT:
1412       case T_FLOAT:
1413         if (c-&gt;as_jint_bits() != other-&gt;as_jint_bits()) continue;
1414         break;
1415       case T_LONG:
1416       case T_DOUBLE:
1417         if (c-&gt;as_jint_hi_bits() != other-&gt;as_jint_hi_bits()) continue;
1418         if (c-&gt;as_jint_lo_bits() != other-&gt;as_jint_lo_bits()) continue;
1419         break;
1420       case T_OBJECT:
1421         if (c-&gt;as_jobject() != other-&gt;as_jobject()) continue;
1422         break;
1423       default:
1424         break;
1425       }
1426       return _reg_for_constants.at(i);
1427     }
1428   }
1429 
1430   LIR_Opr result = new_register(t);
1431   __ move((LIR_Opr)c, result);
1432   _constants.append(c);
1433   _reg_for_constants.append(result);
1434   return result;
1435 }
1436 
1437 //------------------------field access--------------------------------------
1438 
1439 void LIRGenerator::do_CompareAndSwap(Intrinsic* x, ValueType* type) {
1440   assert(x-&gt;number_of_arguments() == 4, &quot;wrong type&quot;);
1441   LIRItem obj   (x-&gt;argument_at(0), this);  // object
1442   LIRItem offset(x-&gt;argument_at(1), this);  // offset of field
1443   LIRItem cmp   (x-&gt;argument_at(2), this);  // value to compare with field
1444   LIRItem val   (x-&gt;argument_at(3), this);  // replace field with val if matches cmp
1445   assert(obj.type()-&gt;tag() == objectTag, &quot;invalid type&quot;);
1446 
1447   // In 64bit the type can be long, sparc doesn&#39;t have this assert
1448   // assert(offset.type()-&gt;tag() == intTag, &quot;invalid type&quot;);
1449 
1450   assert(cmp.type()-&gt;tag() == type-&gt;tag(), &quot;invalid type&quot;);
1451   assert(val.type()-&gt;tag() == type-&gt;tag(), &quot;invalid type&quot;);
1452 
1453   LIR_Opr result = access_atomic_cmpxchg_at(IN_HEAP, as_BasicType(type),
1454                                             obj, offset, cmp, val);
1455   set_result(x, result);
1456 }
1457 
1458 // Comment copied form templateTable_i486.cpp
1459 // ----------------------------------------------------------------------------
1460 // Volatile variables demand their effects be made known to all CPU&#39;s in
1461 // order.  Store buffers on most chips allow reads &amp; writes to reorder; the
1462 // JMM&#39;s ReadAfterWrite.java test fails in -Xint mode without some kind of
1463 // memory barrier (i.e., it&#39;s not sufficient that the interpreter does not
1464 // reorder volatile references, the hardware also must not reorder them).
1465 //
1466 // According to the new Java Memory Model (JMM):
1467 // (1) All volatiles are serialized wrt to each other.
1468 // ALSO reads &amp; writes act as aquire &amp; release, so:
1469 // (2) A read cannot let unrelated NON-volatile memory refs that happen after
1470 // the read float up to before the read.  It&#39;s OK for non-volatile memory refs
1471 // that happen before the volatile read to float down below it.
1472 // (3) Similar a volatile write cannot let unrelated NON-volatile memory refs
1473 // that happen BEFORE the write float down to after the write.  It&#39;s OK for
1474 // non-volatile memory refs that happen after the volatile write to float up
1475 // before it.
1476 //
1477 // We only put in barriers around volatile refs (they are expensive), not
1478 // _between_ memory refs (that would require us to track the flavor of the
1479 // previous memory refs).  Requirements (2) and (3) require some barriers
1480 // before volatile stores and after volatile loads.  These nearly cover
1481 // requirement (1) but miss the volatile-store-volatile-load case.  This final
1482 // case is placed after volatile-stores although it could just as well go
1483 // before volatile-loads.
1484 
1485 
1486 void LIRGenerator::do_StoreField(StoreField* x) {
1487   bool needs_patching = x-&gt;needs_patching();
1488   bool is_volatile = x-&gt;field()-&gt;is_volatile();
1489   BasicType field_type = x-&gt;field_type();
1490 
1491   CodeEmitInfo* info = NULL;
1492   if (needs_patching) {
1493     assert(x-&gt;explicit_null_check() == NULL, &quot;can&#39;t fold null check into patching field access&quot;);
1494     info = state_for(x, x-&gt;state_before());
1495   } else if (x-&gt;needs_null_check()) {
1496     NullCheck* nc = x-&gt;explicit_null_check();
1497     if (nc == NULL) {
1498       info = state_for(x);
1499     } else {
1500       info = state_for(nc);
1501     }
1502   }
1503 
1504   LIRItem object(x-&gt;obj(), this);
1505   LIRItem value(x-&gt;value(),  this);
1506 
1507   object.load_item();
1508 
1509   if (is_volatile || needs_patching) {
1510     // load item if field is volatile (fewer special cases for volatiles)
1511     // load item if field not initialized
1512     // load item if field not constant
1513     // because of code patching we cannot inline constants
1514     if (field_type == T_BYTE || field_type == T_BOOLEAN) {
1515       value.load_byte_item();
1516     } else  {
1517       value.load_item();
1518     }
1519   } else {
1520     value.load_for_store(field_type);
1521   }
1522 
1523   set_no_result(x);
1524 
1525 #ifndef PRODUCT
1526   if (PrintNotLoaded &amp;&amp; needs_patching) {
1527     tty-&gt;print_cr(&quot;   ###class not loaded at store_%s bci %d&quot;,
1528                   x-&gt;is_static() ?  &quot;static&quot; : &quot;field&quot;, x-&gt;printable_bci());
1529   }
1530 #endif
1531 
1532   if (x-&gt;needs_null_check() &amp;&amp;
1533       (needs_patching ||
1534        MacroAssembler::needs_explicit_null_check(x-&gt;offset()))) {
1535     // Emit an explicit null check because the offset is too large.
1536     // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
1537     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
1538     __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
1539   }
1540 
1541   DecoratorSet decorators = IN_HEAP;
1542   if (is_volatile) {
1543     decorators |= MO_SEQ_CST;
1544   }
1545   if (needs_patching) {
1546     decorators |= C1_NEEDS_PATCHING;
1547   }
1548 
1549   access_store_at(decorators, field_type, object, LIR_OprFact::intConst(x-&gt;offset()),
1550                   value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);
1551 }
1552 
1553 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1554   assert(x-&gt;is_pinned(),&quot;&quot;);
1555   bool needs_range_check = x-&gt;compute_needs_range_check();
1556   bool use_length = x-&gt;length() != NULL;
<a name="6" id="anc6"></a><span class="line-modified">1557   bool obj_store = is_reference_type(x-&gt;elt_type());</span>
1558   bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||
1559                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||
1560                                          x-&gt;should_profile());
1561 
1562   LIRItem array(x-&gt;array(), this);
1563   LIRItem index(x-&gt;index(), this);
1564   LIRItem value(x-&gt;value(), this);
1565   LIRItem length(this);
1566 
1567   array.load_item();
1568   index.load_nonconstant();
1569 
1570   if (use_length &amp;&amp; needs_range_check) {
1571     length.set_instruction(x-&gt;length());
1572     length.load_item();
1573 
1574   }
1575   if (needs_store_check || x-&gt;check_boolean()) {
1576     value.load_item();
1577   } else {
1578     value.load_for_store(x-&gt;elt_type());
1579   }
1580 
1581   set_no_result(x);
1582 
1583   // the CodeEmitInfo must be duplicated for each different
1584   // LIR-instruction because spilling can occur anywhere between two
1585   // instructions and so the debug information must be different
1586   CodeEmitInfo* range_check_info = state_for(x);
1587   CodeEmitInfo* null_check_info = NULL;
1588   if (x-&gt;needs_null_check()) {
1589     null_check_info = new CodeEmitInfo(range_check_info);
1590   }
1591 
1592   if (GenerateRangeChecks &amp;&amp; needs_range_check) {
1593     if (use_length) {
1594       __ cmp(lir_cond_belowEqual, length.result(), index.result());
1595       __ branch(lir_cond_belowEqual, T_INT, new RangeCheckStub(range_check_info, index.result(), array.result()));
1596     } else {
1597       array_range_check(array.result(), index.result(), null_check_info, range_check_info);
1598       // range_check also does the null check
1599       null_check_info = NULL;
1600     }
1601   }
1602 
1603   if (GenerateArrayStoreCheck &amp;&amp; needs_store_check) {
1604     CodeEmitInfo* store_check_info = new CodeEmitInfo(range_check_info);
1605     array_store_check(value.result(), array.result(), store_check_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1606   }
1607 
1608   DecoratorSet decorators = IN_HEAP | IS_ARRAY;
1609   if (x-&gt;check_boolean()) {
1610     decorators |= C1_MASK_BOOLEAN;
1611   }
1612 
1613   access_store_at(decorators, x-&gt;elt_type(), array, index.result(), value.result(),
1614                   NULL, null_check_info);
1615 }
1616 
1617 void LIRGenerator::access_load_at(DecoratorSet decorators, BasicType type,
1618                                   LIRItem&amp; base, LIR_Opr offset, LIR_Opr result,
1619                                   CodeEmitInfo* patch_info, CodeEmitInfo* load_emit_info) {
1620   decorators |= ACCESS_READ;
1621   LIRAccess access(this, decorators, base, offset, type, patch_info, load_emit_info);
1622   if (access.is_raw()) {
1623     _barrier_set-&gt;BarrierSetC1::load_at(access, result);
1624   } else {
1625     _barrier_set-&gt;load_at(access, result);
1626   }
1627 }
1628 
1629 void LIRGenerator::access_load(DecoratorSet decorators, BasicType type,
1630                                LIR_Opr addr, LIR_Opr result) {
1631   decorators |= ACCESS_READ;
1632   LIRAccess access(this, decorators, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, type);
1633   access.set_resolved_addr(addr);
1634   if (access.is_raw()) {
1635     _barrier_set-&gt;BarrierSetC1::load(access, result);
1636   } else {
1637     _barrier_set-&gt;load(access, result);
1638   }
1639 }
1640 
1641 void LIRGenerator::access_store_at(DecoratorSet decorators, BasicType type,
1642                                    LIRItem&amp; base, LIR_Opr offset, LIR_Opr value,
1643                                    CodeEmitInfo* patch_info, CodeEmitInfo* store_emit_info) {
1644   decorators |= ACCESS_WRITE;
1645   LIRAccess access(this, decorators, base, offset, type, patch_info, store_emit_info);
1646   if (access.is_raw()) {
1647     _barrier_set-&gt;BarrierSetC1::store_at(access, value);
1648   } else {
1649     _barrier_set-&gt;store_at(access, value);
1650   }
1651 }
1652 
1653 LIR_Opr LIRGenerator::access_atomic_cmpxchg_at(DecoratorSet decorators, BasicType type,
1654                                                LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
1655   decorators |= ACCESS_READ;
1656   decorators |= ACCESS_WRITE;
1657   // Atomic operations are SEQ_CST by default
1658   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1659   LIRAccess access(this, decorators, base, offset, type);
1660   if (access.is_raw()) {
1661     return _barrier_set-&gt;BarrierSetC1::atomic_cmpxchg_at(access, cmp_value, new_value);
1662   } else {
1663     return _barrier_set-&gt;atomic_cmpxchg_at(access, cmp_value, new_value);
1664   }
1665 }
1666 
1667 LIR_Opr LIRGenerator::access_atomic_xchg_at(DecoratorSet decorators, BasicType type,
1668                                             LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value) {
1669   decorators |= ACCESS_READ;
1670   decorators |= ACCESS_WRITE;
1671   // Atomic operations are SEQ_CST by default
1672   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1673   LIRAccess access(this, decorators, base, offset, type);
1674   if (access.is_raw()) {
1675     return _barrier_set-&gt;BarrierSetC1::atomic_xchg_at(access, value);
1676   } else {
1677     return _barrier_set-&gt;atomic_xchg_at(access, value);
1678   }
1679 }
1680 
1681 LIR_Opr LIRGenerator::access_atomic_add_at(DecoratorSet decorators, BasicType type,
1682                                            LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value) {
1683   decorators |= ACCESS_READ;
1684   decorators |= ACCESS_WRITE;
1685   // Atomic operations are SEQ_CST by default
1686   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1687   LIRAccess access(this, decorators, base, offset, type);
1688   if (access.is_raw()) {
1689     return _barrier_set-&gt;BarrierSetC1::atomic_add_at(access, value);
1690   } else {
1691     return _barrier_set-&gt;atomic_add_at(access, value);
1692   }
1693 }
1694 
1695 LIR_Opr LIRGenerator::access_resolve(DecoratorSet decorators, LIR_Opr obj) {
1696   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
1697   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
1698     decorators |= ACCESS_READ | ACCESS_WRITE;
1699   }
1700 
1701   return _barrier_set-&gt;resolve(this, decorators, obj);
1702 }
1703 
1704 void LIRGenerator::do_LoadField(LoadField* x) {
1705   bool needs_patching = x-&gt;needs_patching();
1706   bool is_volatile = x-&gt;field()-&gt;is_volatile();
1707   BasicType field_type = x-&gt;field_type();
1708 
1709   CodeEmitInfo* info = NULL;
1710   if (needs_patching) {
1711     assert(x-&gt;explicit_null_check() == NULL, &quot;can&#39;t fold null check into patching field access&quot;);
1712     info = state_for(x, x-&gt;state_before());
1713   } else if (x-&gt;needs_null_check()) {
1714     NullCheck* nc = x-&gt;explicit_null_check();
1715     if (nc == NULL) {
1716       info = state_for(x);
1717     } else {
1718       info = state_for(nc);
1719     }
1720   }
1721 
1722   LIRItem object(x-&gt;obj(), this);
1723 
1724   object.load_item();
1725 
1726 #ifndef PRODUCT
1727   if (PrintNotLoaded &amp;&amp; needs_patching) {
1728     tty-&gt;print_cr(&quot;   ###class not loaded at load_%s bci %d&quot;,
1729                   x-&gt;is_static() ?  &quot;static&quot; : &quot;field&quot;, x-&gt;printable_bci());
1730   }
1731 #endif
1732 
1733   bool stress_deopt = StressLoopInvariantCodeMotion &amp;&amp; info &amp;&amp; info-&gt;deoptimize_on_exception();
1734   if (x-&gt;needs_null_check() &amp;&amp;
1735       (needs_patching ||
1736        MacroAssembler::needs_explicit_null_check(x-&gt;offset()) ||
1737        stress_deopt)) {
1738     LIR_Opr obj = object.result();
1739     if (stress_deopt) {
1740       obj = new_register(T_OBJECT);
1741       __ move(LIR_OprFact::oopConst(NULL), obj);
1742     }
1743     // Emit an explicit null check because the offset is too large.
1744     // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
1745     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
1746     __ null_check(obj, new CodeEmitInfo(info), /* deoptimize */ needs_patching);
1747   }
1748 
1749   DecoratorSet decorators = IN_HEAP;
1750   if (is_volatile) {
1751     decorators |= MO_SEQ_CST;
1752   }
1753   if (needs_patching) {
1754     decorators |= C1_NEEDS_PATCHING;
1755   }
1756 
1757   LIR_Opr result = rlock_result(x, field_type);
1758   access_load_at(decorators, field_type,
1759                  object, LIR_OprFact::intConst(x-&gt;offset()), result,
1760                  info ? new CodeEmitInfo(info) : NULL, info);
1761 }
1762 
1763 
1764 //------------------------java.nio.Buffer.checkIndex------------------------
1765 
1766 // int java.nio.Buffer.checkIndex(int)
1767 void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {
1768   // NOTE: by the time we are in checkIndex() we are guaranteed that
1769   // the buffer is non-null (because checkIndex is package-private and
1770   // only called from within other methods in the buffer).
1771   assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
1772   LIRItem buf  (x-&gt;argument_at(0), this);
1773   LIRItem index(x-&gt;argument_at(1), this);
1774   buf.load_item();
1775   index.load_item();
1776 
1777   LIR_Opr result = rlock_result(x);
1778   if (GenerateRangeChecks) {
1779     CodeEmitInfo* info = state_for(x);
1780     CodeStub* stub = new RangeCheckStub(info, index.result());
1781     LIR_Opr buf_obj = access_resolve(IS_NOT_NULL | ACCESS_READ, buf.result());
1782     if (index.result()-&gt;is_constant()) {
1783       cmp_mem_int(lir_cond_belowEqual, buf_obj, java_nio_Buffer::limit_offset(), index.result()-&gt;as_jint(), info);
1784       __ branch(lir_cond_belowEqual, T_INT, stub);
1785     } else {
1786       cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf_obj,
1787                   java_nio_Buffer::limit_offset(), T_INT, info);
1788       __ branch(lir_cond_aboveEqual, T_INT, stub);
1789     }
1790     __ move(index.result(), result);
1791   } else {
1792     // Just load the index into the result register
1793     __ move(index.result(), result);
1794   }
1795 }
1796 
1797 
1798 //------------------------array access--------------------------------------
1799 
1800 
1801 void LIRGenerator::do_ArrayLength(ArrayLength* x) {
1802   LIRItem array(x-&gt;array(), this);
1803   array.load_item();
1804   LIR_Opr reg = rlock_result(x);
1805 
1806   CodeEmitInfo* info = NULL;
1807   if (x-&gt;needs_null_check()) {
1808     NullCheck* nc = x-&gt;explicit_null_check();
1809     if (nc == NULL) {
1810       info = state_for(x);
1811     } else {
1812       info = state_for(nc);
1813     }
1814     if (StressLoopInvariantCodeMotion &amp;&amp; info-&gt;deoptimize_on_exception()) {
1815       LIR_Opr obj = new_register(T_OBJECT);
1816       __ move(LIR_OprFact::oopConst(NULL), obj);
1817       __ null_check(obj, new CodeEmitInfo(info));
1818     }
1819   }
1820   __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), reg, info, lir_patch_none);
1821 }
1822 
1823 
1824 void LIRGenerator::do_LoadIndexed(LoadIndexed* x) {
1825   bool use_length = x-&gt;length() != NULL;
1826   LIRItem array(x-&gt;array(), this);
1827   LIRItem index(x-&gt;index(), this);
1828   LIRItem length(this);
1829   bool needs_range_check = x-&gt;compute_needs_range_check();
1830 
1831   if (use_length &amp;&amp; needs_range_check) {
1832     length.set_instruction(x-&gt;length());
1833     length.load_item();
1834   }
1835 
1836   array.load_item();
1837   if (index.is_constant() &amp;&amp; can_inline_as_constant(x-&gt;index())) {
1838     // let it be a constant
1839     index.dont_load_item();
1840   } else {
1841     index.load_item();
1842   }
1843 
1844   CodeEmitInfo* range_check_info = state_for(x);
1845   CodeEmitInfo* null_check_info = NULL;
1846   if (x-&gt;needs_null_check()) {
1847     NullCheck* nc = x-&gt;explicit_null_check();
1848     if (nc != NULL) {
1849       null_check_info = state_for(nc);
1850     } else {
1851       null_check_info = range_check_info;
1852     }
1853     if (StressLoopInvariantCodeMotion &amp;&amp; null_check_info-&gt;deoptimize_on_exception()) {
1854       LIR_Opr obj = new_register(T_OBJECT);
1855       __ move(LIR_OprFact::oopConst(NULL), obj);
1856       __ null_check(obj, new CodeEmitInfo(null_check_info));
1857     }
1858   }
1859 
1860   if (GenerateRangeChecks &amp;&amp; needs_range_check) {
1861     if (StressLoopInvariantCodeMotion &amp;&amp; range_check_info-&gt;deoptimize_on_exception()) {
1862       __ branch(lir_cond_always, T_ILLEGAL, new RangeCheckStub(range_check_info, index.result(), array.result()));
1863     } else if (use_length) {
1864       // TODO: use a (modified) version of array_range_check that does not require a
1865       //       constant length to be loaded to a register
1866       __ cmp(lir_cond_belowEqual, length.result(), index.result());
1867       __ branch(lir_cond_belowEqual, T_INT, new RangeCheckStub(range_check_info, index.result(), array.result()));
1868     } else {
1869       array_range_check(array.result(), index.result(), null_check_info, range_check_info);
1870       // The range check performs the null check, so clear it out for the load
1871       null_check_info = NULL;
1872     }
1873   }
1874 
1875   DecoratorSet decorators = IN_HEAP | IS_ARRAY;
1876 
1877   LIR_Opr result = rlock_result(x, x-&gt;elt_type());
1878   access_load_at(decorators, x-&gt;elt_type(),
1879                  array, index.result(), result,
1880                  NULL, null_check_info);
1881 }
1882 
1883 
1884 void LIRGenerator::do_NullCheck(NullCheck* x) {
1885   if (x-&gt;can_trap()) {
1886     LIRItem value(x-&gt;obj(), this);
1887     value.load_item();
1888     CodeEmitInfo* info = state_for(x);
1889     __ null_check(value.result(), info);
1890   }
1891 }
1892 
1893 
1894 void LIRGenerator::do_TypeCast(TypeCast* x) {
1895   LIRItem value(x-&gt;obj(), this);
1896   value.load_item();
1897   // the result is the same as from the node we are casting
1898   set_result(x, value.result());
1899 }
1900 
1901 
1902 void LIRGenerator::do_Throw(Throw* x) {
1903   LIRItem exception(x-&gt;exception(), this);
1904   exception.load_item();
1905   set_no_result(x);
1906   LIR_Opr exception_opr = exception.result();
1907   CodeEmitInfo* info = state_for(x, x-&gt;state());
1908 
1909 #ifndef PRODUCT
1910   if (PrintC1Statistics) {
1911     increment_counter(Runtime1::throw_count_address(), T_INT);
1912   }
1913 #endif
1914 
1915   // check if the instruction has an xhandler in any of the nested scopes
1916   bool unwind = false;
1917   if (info-&gt;exception_handlers()-&gt;length() == 0) {
1918     // this throw is not inside an xhandler
1919     unwind = true;
1920   } else {
1921     // get some idea of the throw type
1922     bool type_is_exact = true;
1923     ciType* throw_type = x-&gt;exception()-&gt;exact_type();
1924     if (throw_type == NULL) {
1925       type_is_exact = false;
1926       throw_type = x-&gt;exception()-&gt;declared_type();
1927     }
1928     if (throw_type != NULL &amp;&amp; throw_type-&gt;is_instance_klass()) {
1929       ciInstanceKlass* throw_klass = (ciInstanceKlass*)throw_type;
1930       unwind = !x-&gt;exception_handlers()-&gt;could_catch(throw_klass, type_is_exact);
1931     }
1932   }
1933 
1934   // do null check before moving exception oop into fixed register
1935   // to avoid a fixed interval with an oop during the null check.
1936   // Use a copy of the CodeEmitInfo because debug information is
1937   // different for null_check and throw.
1938   if (x-&gt;exception()-&gt;as_NewInstance() == NULL &amp;&amp; x-&gt;exception()-&gt;as_ExceptionObject() == NULL) {
1939     // if the exception object wasn&#39;t created using new then it might be null.
1940     __ null_check(exception_opr, new CodeEmitInfo(info, x-&gt;state()-&gt;copy(ValueStack::ExceptionState, x-&gt;state()-&gt;bci())));
1941   }
1942 
1943   if (compilation()-&gt;env()-&gt;jvmti_can_post_on_exceptions()) {
1944     // we need to go through the exception lookup path to get JVMTI
1945     // notification done
1946     unwind = false;
1947   }
1948 
1949   // move exception oop into fixed register
1950   __ move(exception_opr, exceptionOopOpr());
1951 
1952   if (unwind) {
1953     __ unwind_exception(exceptionOopOpr());
1954   } else {
1955     __ throw_exception(exceptionPcOpr(), exceptionOopOpr(), info);
1956   }
1957 }
1958 
1959 
1960 void LIRGenerator::do_RoundFP(RoundFP* x) {
<a name="7" id="anc7"></a><span class="line-added">1961   assert(strict_fp_requires_explicit_rounding, &quot;not required&quot;);</span>
<span class="line-added">1962 </span>
1963   LIRItem input(x-&gt;input(), this);
1964   input.load_item();
1965   LIR_Opr input_opr = input.result();
1966   assert(input_opr-&gt;is_register(), &quot;why round if value is not in a register?&quot;);
1967   assert(input_opr-&gt;is_single_fpu() || input_opr-&gt;is_double_fpu(), &quot;input should be floating-point value&quot;);
1968   if (input_opr-&gt;is_single_fpu()) {
1969     set_result(x, round_item(input_opr)); // This code path not currently taken
1970   } else {
1971     LIR_Opr result = new_register(T_DOUBLE);
1972     set_vreg_flag(result, must_start_in_memory);
1973     __ roundfp(input_opr, LIR_OprFact::illegalOpr, result);
1974     set_result(x, result);
1975   }
1976 }
1977 
1978 // Here UnsafeGetRaw may have x-&gt;base() and x-&gt;index() be int or long
1979 // on both 64 and 32 bits. Expecting x-&gt;base() to be always long on 64bit.
1980 void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {
1981   LIRItem base(x-&gt;base(), this);
1982   LIRItem idx(this);
1983 
1984   base.load_item();
1985   if (x-&gt;has_index()) {
1986     idx.set_instruction(x-&gt;index());
1987     idx.load_nonconstant();
1988   }
1989 
1990   LIR_Opr reg = rlock_result(x, x-&gt;basic_type());
1991 
1992   int   log2_scale = 0;
1993   if (x-&gt;has_index()) {
1994     log2_scale = x-&gt;log2_scale();
1995   }
1996 
1997   assert(!x-&gt;has_index() || idx.value() == x-&gt;index(), &quot;should match&quot;);
1998 
1999   LIR_Opr base_op = base.result();
2000   LIR_Opr index_op = idx.result();
2001 #ifndef _LP64
2002   if (base_op-&gt;type() == T_LONG) {
2003     base_op = new_register(T_INT);
2004     __ convert(Bytecodes::_l2i, base.result(), base_op);
2005   }
2006   if (x-&gt;has_index()) {
2007     if (index_op-&gt;type() == T_LONG) {
2008       LIR_Opr long_index_op = index_op;
2009       if (index_op-&gt;is_constant()) {
2010         long_index_op = new_register(T_LONG);
2011         __ move(index_op, long_index_op);
2012       }
2013       index_op = new_register(T_INT);
2014       __ convert(Bytecodes::_l2i, long_index_op, index_op);
2015     } else {
2016       assert(x-&gt;index()-&gt;type()-&gt;tag() == intTag, &quot;must be&quot;);
2017     }
2018   }
2019   // At this point base and index should be all ints.
2020   assert(base_op-&gt;type() == T_INT &amp;&amp; !base_op-&gt;is_constant(), &quot;base should be an non-constant int&quot;);
2021   assert(!x-&gt;has_index() || index_op-&gt;type() == T_INT, &quot;index should be an int&quot;);
2022 #else
2023   if (x-&gt;has_index()) {
2024     if (index_op-&gt;type() == T_INT) {
2025       if (!index_op-&gt;is_constant()) {
2026         index_op = new_register(T_LONG);
2027         __ convert(Bytecodes::_i2l, idx.result(), index_op);
2028       }
2029     } else {
2030       assert(index_op-&gt;type() == T_LONG, &quot;must be&quot;);
2031       if (index_op-&gt;is_constant()) {
2032         index_op = new_register(T_LONG);
2033         __ move(idx.result(), index_op);
2034       }
2035     }
2036   }
2037   // At this point base is a long non-constant
2038   // Index is a long register or a int constant.
2039   // We allow the constant to stay an int because that would allow us a more compact encoding by
2040   // embedding an immediate offset in the address expression. If we have a long constant, we have to
2041   // move it into a register first.
2042   assert(base_op-&gt;type() == T_LONG &amp;&amp; !base_op-&gt;is_constant(), &quot;base must be a long non-constant&quot;);
2043   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_INT &amp;&amp; index_op-&gt;is_constant()) ||
2044                             (index_op-&gt;type() == T_LONG &amp;&amp; !index_op-&gt;is_constant()), &quot;unexpected index type&quot;);
2045 #endif
2046 
2047   BasicType dst_type = x-&gt;basic_type();
2048 
2049   LIR_Address* addr;
2050   if (index_op-&gt;is_constant()) {
2051     assert(log2_scale == 0, &quot;must not have a scale&quot;);
2052     assert(index_op-&gt;type() == T_INT, &quot;only int constants supported&quot;);
2053     addr = new LIR_Address(base_op, index_op-&gt;as_jint(), dst_type);
2054   } else {
2055 #ifdef X86
2056     addr = new LIR_Address(base_op, index_op, LIR_Address::Scale(log2_scale), 0, dst_type);
2057 #elif defined(GENERATE_ADDRESS_IS_PREFERRED)
2058     addr = generate_address(base_op, index_op, log2_scale, 0, dst_type);
2059 #else
2060     if (index_op-&gt;is_illegal() || log2_scale == 0) {
2061       addr = new LIR_Address(base_op, index_op, dst_type);
2062     } else {
2063       LIR_Opr tmp = new_pointer_register();
2064       __ shift_left(index_op, log2_scale, tmp);
2065       addr = new LIR_Address(base_op, tmp, dst_type);
2066     }
2067 #endif
2068   }
2069 
2070   if (x-&gt;may_be_unaligned() &amp;&amp; (dst_type == T_LONG || dst_type == T_DOUBLE)) {
2071     __ unaligned_move(addr, reg);
2072   } else {
2073     if (dst_type == T_OBJECT &amp;&amp; x-&gt;is_wide()) {
2074       __ move_wide(addr, reg);
2075     } else {
2076       __ move(addr, reg);
2077     }
2078   }
2079 }
2080 
2081 
2082 void LIRGenerator::do_UnsafePutRaw(UnsafePutRaw* x) {
2083   int  log2_scale = 0;
2084   BasicType type = x-&gt;basic_type();
2085 
2086   if (x-&gt;has_index()) {
2087     log2_scale = x-&gt;log2_scale();
2088   }
2089 
2090   LIRItem base(x-&gt;base(), this);
2091   LIRItem value(x-&gt;value(), this);
2092   LIRItem idx(this);
2093 
2094   base.load_item();
2095   if (x-&gt;has_index()) {
2096     idx.set_instruction(x-&gt;index());
2097     idx.load_item();
2098   }
2099 
2100   if (type == T_BYTE || type == T_BOOLEAN) {
2101     value.load_byte_item();
2102   } else {
2103     value.load_item();
2104   }
2105 
2106   set_no_result(x);
2107 
2108   LIR_Opr base_op = base.result();
2109   LIR_Opr index_op = idx.result();
2110 
2111 #ifdef GENERATE_ADDRESS_IS_PREFERRED
2112   LIR_Address* addr = generate_address(base_op, index_op, log2_scale, 0, x-&gt;basic_type());
2113 #else
2114 #ifndef _LP64
2115   if (base_op-&gt;type() == T_LONG) {
2116     base_op = new_register(T_INT);
2117     __ convert(Bytecodes::_l2i, base.result(), base_op);
2118   }
2119   if (x-&gt;has_index()) {
2120     if (index_op-&gt;type() == T_LONG) {
2121       index_op = new_register(T_INT);
2122       __ convert(Bytecodes::_l2i, idx.result(), index_op);
2123     }
2124   }
2125   // At this point base and index should be all ints and not constants
2126   assert(base_op-&gt;type() == T_INT &amp;&amp; !base_op-&gt;is_constant(), &quot;base should be an non-constant int&quot;);
2127   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_INT &amp;&amp; !index_op-&gt;is_constant()), &quot;index should be an non-constant int&quot;);
2128 #else
2129   if (x-&gt;has_index()) {
2130     if (index_op-&gt;type() == T_INT) {
2131       index_op = new_register(T_LONG);
2132       __ convert(Bytecodes::_i2l, idx.result(), index_op);
2133     }
2134   }
2135   // At this point base and index are long and non-constant
2136   assert(base_op-&gt;type() == T_LONG &amp;&amp; !base_op-&gt;is_constant(), &quot;base must be a non-constant long&quot;);
2137   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_LONG &amp;&amp; !index_op-&gt;is_constant()), &quot;index must be a non-constant long&quot;);
2138 #endif
2139 
2140   if (log2_scale != 0) {
2141     // temporary fix (platform dependent code without shift on Intel would be better)
2142     // TODO: ARM also allows embedded shift in the address
2143     LIR_Opr tmp = new_pointer_register();
2144     if (TwoOperandLIRForm) {
2145       __ move(index_op, tmp);
2146       index_op = tmp;
2147     }
2148     __ shift_left(index_op, log2_scale, tmp);
2149     if (!TwoOperandLIRForm) {
2150       index_op = tmp;
2151     }
2152   }
2153 
2154   LIR_Address* addr = new LIR_Address(base_op, index_op, x-&gt;basic_type());
2155 #endif // !GENERATE_ADDRESS_IS_PREFERRED
2156   __ move(value.result(), addr);
2157 }
2158 
2159 
2160 void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {
2161   BasicType type = x-&gt;basic_type();
2162   LIRItem src(x-&gt;object(), this);
2163   LIRItem off(x-&gt;offset(), this);
2164 
2165   off.load_item();
2166   src.load_item();
2167 
2168   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
2169 
2170   if (x-&gt;is_volatile()) {
2171     decorators |= MO_SEQ_CST;
2172   }
2173   if (type == T_BOOLEAN) {
2174     decorators |= C1_MASK_BOOLEAN;
2175   }
<a name="8" id="anc8"></a><span class="line-modified">2176   if (is_reference_type(type)) {</span>
2177     decorators |= ON_UNKNOWN_OOP_REF;
2178   }
2179 
2180   LIR_Opr result = rlock_result(x, type);
2181   access_load_at(decorators, type,
2182                  src, off.result(), result);
2183 }
2184 
2185 
2186 void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {
2187   BasicType type = x-&gt;basic_type();
2188   LIRItem src(x-&gt;object(), this);
2189   LIRItem off(x-&gt;offset(), this);
2190   LIRItem data(x-&gt;value(), this);
2191 
2192   src.load_item();
2193   if (type == T_BOOLEAN || type == T_BYTE) {
2194     data.load_byte_item();
2195   } else {
2196     data.load_item();
2197   }
2198   off.load_item();
2199 
2200   set_no_result(x);
2201 
2202   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
<a name="9" id="anc9"></a><span class="line-modified">2203   if (is_reference_type(type)) {</span>
2204     decorators |= ON_UNKNOWN_OOP_REF;
2205   }
2206   if (x-&gt;is_volatile()) {
2207     decorators |= MO_SEQ_CST;
2208   }
2209   access_store_at(decorators, type, src, off.result(), data.result());
2210 }
2211 
2212 void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
2213   BasicType type = x-&gt;basic_type();
2214   LIRItem src(x-&gt;object(), this);
2215   LIRItem off(x-&gt;offset(), this);
2216   LIRItem value(x-&gt;value(), this);
2217 
2218   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
2219 
<a name="10" id="anc10"></a><span class="line-modified">2220   if (is_reference_type(type)) {</span>
2221     decorators |= ON_UNKNOWN_OOP_REF;
2222   }
2223 
2224   LIR_Opr result;
2225   if (x-&gt;is_add()) {
2226     result = access_atomic_add_at(decorators, type, src, off, value);
2227   } else {
2228     result = access_atomic_xchg_at(decorators, type, src, off, value);
2229   }
2230   set_result(x, result);
2231 }
2232 
2233 void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
2234   int lng = x-&gt;length();
2235 
2236   for (int i = 0; i &lt; lng; i++) {
<a name="11" id="anc11"></a><span class="line-modified">2237     C1SwitchRange* one_range = x-&gt;at(i);</span>
2238     int low_key = one_range-&gt;low_key();
2239     int high_key = one_range-&gt;high_key();
2240     BlockBegin* dest = one_range-&gt;sux();
2241     if (low_key == high_key) {
2242       __ cmp(lir_cond_equal, value, low_key);
2243       __ branch(lir_cond_equal, T_INT, dest);
2244     } else if (high_key - low_key == 1) {
2245       __ cmp(lir_cond_equal, value, low_key);
2246       __ branch(lir_cond_equal, T_INT, dest);
2247       __ cmp(lir_cond_equal, value, high_key);
2248       __ branch(lir_cond_equal, T_INT, dest);
2249     } else {
2250       LabelObj* L = new LabelObj();
2251       __ cmp(lir_cond_less, value, low_key);
2252       __ branch(lir_cond_less, T_INT, L-&gt;label());
2253       __ cmp(lir_cond_lessEqual, value, high_key);
2254       __ branch(lir_cond_lessEqual, T_INT, dest);
2255       __ branch_destination(L-&gt;label());
2256     }
2257   }
2258   __ jump(default_sux);
2259 }
2260 
2261 
2262 SwitchRangeArray* LIRGenerator::create_lookup_ranges(TableSwitch* x) {
2263   SwitchRangeList* res = new SwitchRangeList();
2264   int len = x-&gt;length();
2265   if (len &gt; 0) {
2266     BlockBegin* sux = x-&gt;sux_at(0);
2267     int key = x-&gt;lo_key();
2268     BlockBegin* default_sux = x-&gt;default_sux();
<a name="12" id="anc12"></a><span class="line-modified">2269     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
2270     for (int i = 0; i &lt; len; i++, key++) {
2271       BlockBegin* new_sux = x-&gt;sux_at(i);
2272       if (sux == new_sux) {
2273         // still in same range
2274         range-&gt;set_high_key(key);
2275       } else {
2276         // skip tests which explicitly dispatch to the default
2277         if (sux != default_sux) {
2278           res-&gt;append(range);
2279         }
<a name="13" id="anc13"></a><span class="line-modified">2280         range = new C1SwitchRange(key, new_sux);</span>
2281       }
2282       sux = new_sux;
2283     }
2284     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2285   }
2286   return res;
2287 }
2288 
2289 
2290 // we expect the keys to be sorted by increasing value
2291 SwitchRangeArray* LIRGenerator::create_lookup_ranges(LookupSwitch* x) {
2292   SwitchRangeList* res = new SwitchRangeList();
2293   int len = x-&gt;length();
2294   if (len &gt; 0) {
2295     BlockBegin* default_sux = x-&gt;default_sux();
2296     int key = x-&gt;key_at(0);
2297     BlockBegin* sux = x-&gt;sux_at(0);
<a name="14" id="anc14"></a><span class="line-modified">2298     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
2299     for (int i = 1; i &lt; len; i++) {
2300       int new_key = x-&gt;key_at(i);
2301       BlockBegin* new_sux = x-&gt;sux_at(i);
2302       if (key+1 == new_key &amp;&amp; sux == new_sux) {
2303         // still in same range
2304         range-&gt;set_high_key(new_key);
2305       } else {
2306         // skip tests which explicitly dispatch to the default
2307         if (range-&gt;sux() != default_sux) {
2308           res-&gt;append(range);
2309         }
<a name="15" id="anc15"></a><span class="line-modified">2310         range = new C1SwitchRange(new_key, new_sux);</span>
2311       }
2312       key = new_key;
2313       sux = new_sux;
2314     }
2315     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2316   }
2317   return res;
2318 }
2319 
2320 
2321 void LIRGenerator::do_TableSwitch(TableSwitch* x) {
2322   LIRItem tag(x-&gt;tag(), this);
2323   tag.load_item();
2324   set_no_result(x);
2325 
2326   if (x-&gt;is_safepoint()) {
2327     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2328   }
2329 
2330   // move values into phi locations
2331   move_to_phi(x-&gt;state());
2332 
2333   int lo_key = x-&gt;lo_key();
2334   int len = x-&gt;length();
2335   assert(lo_key &lt;= (lo_key + (len - 1)), &quot;integer overflow&quot;);
2336   LIR_Opr value = tag.result();
2337 
2338   if (compilation()-&gt;env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp; UseSwitchProfiling) {
2339     ciMethod* method = x-&gt;state()-&gt;scope()-&gt;method();
2340     ciMethodData* md = method-&gt;method_data_or_null();
2341     assert(md != NULL, &quot;Sanity&quot;);
2342     ciProfileData* data = md-&gt;bci_to_data(x-&gt;state()-&gt;bci());
2343     assert(data != NULL, &quot;must have profiling data&quot;);
2344     assert(data-&gt;is_MultiBranchData(), &quot;bad profile data?&quot;);
2345     int default_count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::default_count_offset());
2346     LIR_Opr md_reg = new_register(T_METADATA);
2347     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2348     LIR_Opr data_offset_reg = new_pointer_register();
2349     LIR_Opr tmp_reg = new_pointer_register();
2350 
2351     __ move(LIR_OprFact::intptrConst(default_count_offset), data_offset_reg);
2352     for (int i = 0; i &lt; len; i++) {
2353       int count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::case_count_offset(i));
2354       __ cmp(lir_cond_equal, value, i + lo_key);
2355       __ move(data_offset_reg, tmp_reg);
2356       __ cmove(lir_cond_equal,
2357                LIR_OprFact::intptrConst(count_offset),
2358                tmp_reg,
2359                data_offset_reg, T_INT);
2360     }
2361 
2362     LIR_Opr data_reg = new_pointer_register();
2363     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
2364     __ move(data_addr, data_reg);
2365     __ add(data_reg, LIR_OprFact::intptrConst(1), data_reg);
2366     __ move(data_reg, data_addr);
2367   }
2368 
2369   if (UseTableRanges) {
2370     do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
2371   } else {
2372     for (int i = 0; i &lt; len; i++) {
2373       __ cmp(lir_cond_equal, value, i + lo_key);
2374       __ branch(lir_cond_equal, T_INT, x-&gt;sux_at(i));
2375     }
2376     __ jump(x-&gt;default_sux());
2377   }
2378 }
2379 
2380 
2381 void LIRGenerator::do_LookupSwitch(LookupSwitch* x) {
2382   LIRItem tag(x-&gt;tag(), this);
2383   tag.load_item();
2384   set_no_result(x);
2385 
2386   if (x-&gt;is_safepoint()) {
2387     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2388   }
2389 
2390   // move values into phi locations
2391   move_to_phi(x-&gt;state());
2392 
2393   LIR_Opr value = tag.result();
2394   int len = x-&gt;length();
2395 
2396   if (compilation()-&gt;env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp; UseSwitchProfiling) {
2397     ciMethod* method = x-&gt;state()-&gt;scope()-&gt;method();
2398     ciMethodData* md = method-&gt;method_data_or_null();
2399     assert(md != NULL, &quot;Sanity&quot;);
2400     ciProfileData* data = md-&gt;bci_to_data(x-&gt;state()-&gt;bci());
2401     assert(data != NULL, &quot;must have profiling data&quot;);
2402     assert(data-&gt;is_MultiBranchData(), &quot;bad profile data?&quot;);
2403     int default_count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::default_count_offset());
2404     LIR_Opr md_reg = new_register(T_METADATA);
2405     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2406     LIR_Opr data_offset_reg = new_pointer_register();
2407     LIR_Opr tmp_reg = new_pointer_register();
2408 
2409     __ move(LIR_OprFact::intptrConst(default_count_offset), data_offset_reg);
2410     for (int i = 0; i &lt; len; i++) {
2411       int count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::case_count_offset(i));
2412       __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
2413       __ move(data_offset_reg, tmp_reg);
2414       __ cmove(lir_cond_equal,
2415                LIR_OprFact::intptrConst(count_offset),
2416                tmp_reg,
2417                data_offset_reg, T_INT);
2418     }
2419 
2420     LIR_Opr data_reg = new_pointer_register();
2421     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
2422     __ move(data_addr, data_reg);
2423     __ add(data_reg, LIR_OprFact::intptrConst(1), data_reg);
2424     __ move(data_reg, data_addr);
2425   }
2426 
2427   if (UseTableRanges) {
2428     do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
2429   } else {
2430     int len = x-&gt;length();
2431     for (int i = 0; i &lt; len; i++) {
2432       __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
2433       __ branch(lir_cond_equal, T_INT, x-&gt;sux_at(i));
2434     }
2435     __ jump(x-&gt;default_sux());
2436   }
2437 }
2438 
2439 
2440 void LIRGenerator::do_Goto(Goto* x) {
2441   set_no_result(x);
2442 
2443   if (block()-&gt;next()-&gt;as_OsrEntry()) {
2444     // need to free up storage used for OSR entry point
2445     LIR_Opr osrBuffer = block()-&gt;next()-&gt;operand();
2446     BasicTypeList signature;
2447     signature.append(NOT_LP64(T_INT) LP64_ONLY(T_LONG)); // pass a pointer to osrBuffer
2448     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
2449     __ move(osrBuffer, cc-&gt;args()-&gt;at(0));
2450     __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_end),
2451                          getThreadTemp(), LIR_OprFact::illegalOpr, cc-&gt;args());
2452   }
2453 
2454   if (x-&gt;is_safepoint()) {
2455     ValueStack* state = x-&gt;state_before() ? x-&gt;state_before() : x-&gt;state();
2456 
2457     // increment backedge counter if needed
2458     CodeEmitInfo* info = state_for(x, state);
2459     increment_backedge_counter(info, x-&gt;profiled_bci());
2460     CodeEmitInfo* safepoint_info = state_for(x, state);
2461     __ safepoint(safepoint_poll_register(), safepoint_info);
2462   }
2463 
2464   // Gotos can be folded Ifs, handle this case.
2465   if (x-&gt;should_profile()) {
2466     ciMethod* method = x-&gt;profiled_method();
2467     assert(method != NULL, &quot;method should be set if branch is profiled&quot;);
2468     ciMethodData* md = method-&gt;method_data_or_null();
2469     assert(md != NULL, &quot;Sanity&quot;);
2470     ciProfileData* data = md-&gt;bci_to_data(x-&gt;profiled_bci());
2471     assert(data != NULL, &quot;must have profiling data&quot;);
2472     int offset;
2473     if (x-&gt;direction() == Goto::taken) {
2474       assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
2475       offset = md-&gt;byte_offset_of_slot(data, BranchData::taken_offset());
2476     } else if (x-&gt;direction() == Goto::not_taken) {
2477       assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
2478       offset = md-&gt;byte_offset_of_slot(data, BranchData::not_taken_offset());
2479     } else {
2480       assert(data-&gt;is_JumpData(), &quot;need JumpData for branches&quot;);
2481       offset = md-&gt;byte_offset_of_slot(data, JumpData::taken_offset());
2482     }
2483     LIR_Opr md_reg = new_register(T_METADATA);
2484     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2485 
2486     increment_counter(new LIR_Address(md_reg, offset,
2487                                       NOT_LP64(T_INT) LP64_ONLY(T_LONG)), DataLayout::counter_increment);
2488   }
2489 
2490   // emit phi-instruction move after safepoint since this simplifies
2491   // describing the state as the safepoint.
2492   move_to_phi(x-&gt;state());
2493 
2494   __ jump(x-&gt;default_sux());
2495 }
2496 
2497 /**
2498  * Emit profiling code if needed for arguments, parameters, return value types
2499  *
2500  * @param md                    MDO the code will update at runtime
2501  * @param md_base_offset        common offset in the MDO for this profile and subsequent ones
2502  * @param md_offset             offset in the MDO (on top of md_base_offset) for this profile
2503  * @param profiled_k            current profile
2504  * @param obj                   IR node for the object to be profiled
2505  * @param mdp                   register to hold the pointer inside the MDO (md + md_base_offset).
2506  *                              Set once we find an update to make and use for next ones.
2507  * @param not_null              true if we know obj cannot be null
2508  * @param signature_at_call_k   signature at call for obj
2509  * @param callee_signature_k    signature of callee for obj
2510  *                              at call and callee signatures differ at method handle call
2511  * @return                      the only klass we know will ever be seen at this profile point
2512  */
2513 ciKlass* LIRGenerator::profile_type(ciMethodData* md, int md_base_offset, int md_offset, intptr_t profiled_k,
2514                                     Value obj, LIR_Opr&amp; mdp, bool not_null, ciKlass* signature_at_call_k,
2515                                     ciKlass* callee_signature_k) {
2516   ciKlass* result = NULL;
2517   bool do_null = !not_null &amp;&amp; !TypeEntries::was_null_seen(profiled_k);
2518   bool do_update = !TypeEntries::is_type_unknown(profiled_k);
2519   // known not to be null or null bit already set and already set to
2520   // unknown: nothing we can do to improve profiling
2521   if (!do_null &amp;&amp; !do_update) {
2522     return result;
2523   }
2524 
2525   ciKlass* exact_klass = NULL;
2526   Compilation* comp = Compilation::current();
2527   if (do_update) {
2528     // try to find exact type, using CHA if possible, so that loading
2529     // the klass from the object can be avoided
2530     ciType* type = obj-&gt;exact_type();
2531     if (type == NULL) {
2532       type = obj-&gt;declared_type();
2533       type = comp-&gt;cha_exact_type(type);
2534     }
2535     assert(type == NULL || type-&gt;is_klass(), &quot;type should be class&quot;);
2536     exact_klass = (type != NULL &amp;&amp; type-&gt;is_loaded()) ? (ciKlass*)type : NULL;
2537 
2538     do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;
2539   }
2540 
2541   if (!do_null &amp;&amp; !do_update) {
2542     return result;
2543   }
2544 
2545   ciKlass* exact_signature_k = NULL;
2546   if (do_update) {
2547     // Is the type from the signature exact (the only one possible)?
2548     exact_signature_k = signature_at_call_k-&gt;exact_klass();
2549     if (exact_signature_k == NULL) {
2550       exact_signature_k = comp-&gt;cha_exact_type(signature_at_call_k);
2551     } else {
2552       result = exact_signature_k;
2553       // Known statically. No need to emit any code: prevent
2554       // LIR_Assembler::emit_profile_type() from emitting useless code
2555       profiled_k = ciTypeEntries::with_status(result, profiled_k);
2556     }
2557     // exact_klass and exact_signature_k can be both non NULL but
2558     // different if exact_klass is loaded after the ciObject for
2559     // exact_signature_k is created.
2560     if (exact_klass == NULL &amp;&amp; exact_signature_k != NULL &amp;&amp; exact_klass != exact_signature_k) {
2561       // sometimes the type of the signature is better than the best type
2562       // the compiler has
2563       exact_klass = exact_signature_k;
2564     }
2565     if (callee_signature_k != NULL &amp;&amp;
2566         callee_signature_k != signature_at_call_k) {
2567       ciKlass* improved_klass = callee_signature_k-&gt;exact_klass();
2568       if (improved_klass == NULL) {
2569         improved_klass = comp-&gt;cha_exact_type(callee_signature_k);
2570       }
2571       if (exact_klass == NULL &amp;&amp; improved_klass != NULL &amp;&amp; exact_klass != improved_klass) {
2572         exact_klass = exact_signature_k;
2573       }
2574     }
2575     do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;
2576   }
2577 
2578   if (!do_null &amp;&amp; !do_update) {
2579     return result;
2580   }
2581 
2582   if (mdp == LIR_OprFact::illegalOpr) {
2583     mdp = new_register(T_METADATA);
2584     __ metadata2reg(md-&gt;constant_encoding(), mdp);
2585     if (md_base_offset != 0) {
2586       LIR_Address* base_type_address = new LIR_Address(mdp, md_base_offset, T_ADDRESS);
2587       mdp = new_pointer_register();
2588       __ leal(LIR_OprFact::address(base_type_address), mdp);
2589     }
2590   }
2591   LIRItem value(obj, this);
2592   value.load_item();
2593   __ profile_type(new LIR_Address(mdp, md_offset, T_METADATA),
2594                   value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);
2595   return result;
2596 }
2597 
2598 // profile parameters on entry to the root of the compilation
2599 void LIRGenerator::profile_parameters(Base* x) {
2600   if (compilation()-&gt;profile_parameters()) {
2601     CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
2602     ciMethodData* md = scope()-&gt;method()-&gt;method_data_or_null();
2603     assert(md != NULL, &quot;Sanity&quot;);
2604 
2605     if (md-&gt;parameters_type_data() != NULL) {
2606       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
2607       ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
2608       LIR_Opr mdp = LIR_OprFact::illegalOpr;
2609       for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
2610         LIR_Opr src = args-&gt;at(i);
2611         assert(!src-&gt;is_illegal(), &quot;check&quot;);
2612         BasicType t = src-&gt;type();
<a name="16" id="anc16"></a><span class="line-modified">2613         if (is_reference_type(t)) {</span>
2614           intptr_t profiled_k = parameters-&gt;type(j);
2615           Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
2616           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
2617                                         in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
2618                                         profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
2619           // If the profile is known statically set it once for all and do not emit any code
2620           if (exact != NULL) {
2621             md-&gt;set_parameter_type(j, exact);
2622           }
2623           j++;
2624         }
2625         java_index += type2size[t];
2626       }
2627     }
2628   }
2629 }
2630 
2631 void LIRGenerator::do_Base(Base* x) {
2632   __ std_entry(LIR_OprFact::illegalOpr);
2633   // Emit moves from physical registers / stack slots to virtual registers
2634   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
2635   IRScope* irScope = compilation()-&gt;hir()-&gt;top_scope();
2636   int java_index = 0;
2637   for (int i = 0; i &lt; args-&gt;length(); i++) {
2638     LIR_Opr src = args-&gt;at(i);
2639     assert(!src-&gt;is_illegal(), &quot;check&quot;);
2640     BasicType t = src-&gt;type();
2641 
2642     // Types which are smaller than int are passed as int, so
2643     // correct the type which passed.
2644     switch (t) {
2645     case T_BYTE:
2646     case T_BOOLEAN:
2647     case T_SHORT:
2648     case T_CHAR:
2649       t = T_INT;
2650       break;
2651     default:
2652       break;
2653     }
2654 
2655     LIR_Opr dest = new_register(t);
2656     __ move(src, dest);
2657 
2658     // Assign new location to Local instruction for this local
2659     Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
2660     assert(local != NULL, &quot;Locals for incoming arguments must have been created&quot;);
2661 #ifndef __SOFTFP__
2662     // The java calling convention passes double as long and float as int.
2663     assert(as_ValueType(t)-&gt;tag() == local-&gt;type()-&gt;tag(), &quot;check&quot;);
2664 #endif // __SOFTFP__
2665     local-&gt;set_operand(dest);
2666     _instruction_for_operand.at_put_grow(dest-&gt;vreg_number(), local, NULL);
2667     java_index += type2size[t];
2668   }
2669 
2670   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
2671     BasicTypeList signature;
2672     signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
2673     signature.append(T_METADATA); // Method*
2674     LIR_OprList* args = new LIR_OprList();
2675     args-&gt;append(getThreadPointer());
2676     LIR_Opr meth = new_register(T_METADATA);
2677     __ metadata2reg(method()-&gt;constant_encoding(), meth);
2678     args-&gt;append(meth);
2679     call_runtime(&amp;signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, NULL);
2680   }
2681 
2682   if (method()-&gt;is_synchronized()) {
2683     LIR_Opr obj;
2684     if (method()-&gt;is_static()) {
2685       obj = new_register(T_OBJECT);
2686       __ oop2reg(method()-&gt;holder()-&gt;java_mirror()-&gt;constant_encoding(), obj);
2687     } else {
2688       Local* receiver = x-&gt;state()-&gt;local_at(0)-&gt;as_Local();
2689       assert(receiver != NULL, &quot;must already exist&quot;);
2690       obj = receiver-&gt;operand();
2691     }
2692     assert(obj-&gt;is_valid(), &quot;must be valid&quot;);
2693 
2694     if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
2695       LIR_Opr lock = syncLockOpr();
2696       __ load_stack_address_monitor(0, lock);
2697 
2698       CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, x-&gt;check_flag(Instruction::DeoptimizeOnException));
2699       CodeStub* slow_path = new MonitorEnterStub(obj, lock, info);
2700 
2701       // receiver is guaranteed non-NULL so don&#39;t need CodeEmitInfo
2702       __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, NULL);
2703     }
2704   }
2705   if (compilation()-&gt;age_code()) {
2706     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);
2707     decrement_age(info);
2708   }
2709   // increment invocation counters if needed
2710   if (!method()-&gt;is_accessor()) { // Accessors do not have MDOs, so no counting.
2711     profile_parameters(x);
2712     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, false);
2713     increment_invocation_counter(info);
2714   }
2715 
2716   // all blocks with a successor must end with an unconditional jump
2717   // to the successor even if they are consecutive
2718   __ jump(x-&gt;default_sux());
2719 }
2720 
2721 
2722 void LIRGenerator::do_OsrEntry(OsrEntry* x) {
2723   // construct our frame and model the production of incoming pointer
2724   // to the OSR buffer.
2725   __ osr_entry(LIR_Assembler::osrBufferPointer());
2726   LIR_Opr result = rlock_result(x);
2727   __ move(LIR_Assembler::osrBufferPointer(), result);
2728 }
2729 
2730 
2731 void LIRGenerator::invoke_load_arguments(Invoke* x, LIRItemList* args, const LIR_OprList* arg_list) {
2732   assert(args-&gt;length() == arg_list-&gt;length(),
2733          &quot;args=%d, arg_list=%d&quot;, args-&gt;length(), arg_list-&gt;length());
2734   for (int i = x-&gt;has_receiver() ? 1 : 0; i &lt; args-&gt;length(); i++) {
2735     LIRItem* param = args-&gt;at(i);
2736     LIR_Opr loc = arg_list-&gt;at(i);
2737     if (loc-&gt;is_register()) {
2738       param-&gt;load_item_force(loc);
2739     } else {
2740       LIR_Address* addr = loc-&gt;as_address_ptr();
2741       param-&gt;load_for_store(addr-&gt;type());
2742       if (addr-&gt;type() == T_OBJECT) {
2743         __ move_wide(param-&gt;result(), addr);
2744       } else
2745         if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
2746           __ unaligned_move(param-&gt;result(), addr);
2747         } else {
2748           __ move(param-&gt;result(), addr);
2749         }
2750     }
2751   }
2752 
2753   if (x-&gt;has_receiver()) {
2754     LIRItem* receiver = args-&gt;at(0);
2755     LIR_Opr loc = arg_list-&gt;at(0);
2756     if (loc-&gt;is_register()) {
2757       receiver-&gt;load_item_force(loc);
2758     } else {
2759       assert(loc-&gt;is_address(), &quot;just checking&quot;);
2760       receiver-&gt;load_for_store(T_OBJECT);
2761       __ move_wide(receiver-&gt;result(), loc-&gt;as_address_ptr());
2762     }
2763   }
2764 }
2765 
2766 
2767 // Visits all arguments, returns appropriate items without loading them
2768 LIRItemList* LIRGenerator::invoke_visit_arguments(Invoke* x) {
2769   LIRItemList* argument_items = new LIRItemList();
2770   if (x-&gt;has_receiver()) {
2771     LIRItem* receiver = new LIRItem(x-&gt;receiver(), this);
2772     argument_items-&gt;append(receiver);
2773   }
2774   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
2775     LIRItem* param = new LIRItem(x-&gt;argument_at(i), this);
2776     argument_items-&gt;append(param);
2777   }
2778   return argument_items;
2779 }
2780 
2781 
2782 // The invoke with receiver has following phases:
2783 //   a) traverse and load/lock receiver;
2784 //   b) traverse all arguments -&gt; item-array (invoke_visit_argument)
2785 //   c) push receiver on stack
2786 //   d) load each of the items and push on stack
2787 //   e) unlock receiver
2788 //   f) move receiver into receiver-register %o0
2789 //   g) lock result registers and emit call operation
2790 //
2791 // Before issuing a call, we must spill-save all values on stack
2792 // that are in caller-save register. &quot;spill-save&quot; moves those registers
2793 // either in a free callee-save register or spills them if no free
2794 // callee save register is available.
2795 //
2796 // The problem is where to invoke spill-save.
2797 // - if invoked between e) and f), we may lock callee save
2798 //   register in &quot;spill-save&quot; that destroys the receiver register
2799 //   before f) is executed
2800 // - if we rearrange f) to be earlier (by loading %o0) it
2801 //   may destroy a value on the stack that is currently in %o0
2802 //   and is waiting to be spilled
2803 // - if we keep the receiver locked while doing spill-save,
2804 //   we cannot spill it as it is spill-locked
2805 //
2806 void LIRGenerator::do_Invoke(Invoke* x) {
2807   CallingConvention* cc = frame_map()-&gt;java_calling_convention(x-&gt;signature(), true);
2808 
2809   LIR_OprList* arg_list = cc-&gt;args();
2810   LIRItemList* args = invoke_visit_arguments(x);
2811   LIR_Opr receiver = LIR_OprFact::illegalOpr;
2812 
2813   // setup result register
2814   LIR_Opr result_register = LIR_OprFact::illegalOpr;
2815   if (x-&gt;type() != voidType) {
2816     result_register = result_register_for(x-&gt;type());
2817   }
2818 
2819   CodeEmitInfo* info = state_for(x, x-&gt;state());
2820 
2821   invoke_load_arguments(x, args, arg_list);
2822 
2823   if (x-&gt;has_receiver()) {
2824     args-&gt;at(0)-&gt;load_item_force(LIR_Assembler::receiverOpr());
2825     receiver = args-&gt;at(0)-&gt;result();
2826   }
2827 
2828   // emit invoke code
2829   assert(receiver-&gt;is_illegal() || receiver-&gt;is_equal(LIR_Assembler::receiverOpr()), &quot;must match&quot;);
2830 
2831   // JSR 292
2832   // Preserve the SP over MethodHandle call sites, if needed.
2833   ciMethod* target = x-&gt;target();
2834   bool is_method_handle_invoke = (// %%% FIXME: Are both of these relevant?
2835                                   target-&gt;is_method_handle_intrinsic() ||
2836                                   target-&gt;is_compiled_lambda_form());
2837   if (is_method_handle_invoke) {
2838     info-&gt;set_is_method_handle_invoke(true);
2839     if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {
2840         __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());
2841     }
2842   }
2843 
2844   switch (x-&gt;code()) {
2845     case Bytecodes::_invokestatic:
2846       __ call_static(target, result_register,
2847                      SharedRuntime::get_resolve_static_call_stub(),
2848                      arg_list, info);
2849       break;
2850     case Bytecodes::_invokespecial:
2851     case Bytecodes::_invokevirtual:
2852     case Bytecodes::_invokeinterface:
2853       // for loaded and final (method or class) target we still produce an inline cache,
2854       // in order to be able to call mixed mode
2855       if (x-&gt;code() == Bytecodes::_invokespecial || x-&gt;target_is_final()) {
2856         __ call_opt_virtual(target, receiver, result_register,
2857                             SharedRuntime::get_resolve_opt_virtual_call_stub(),
2858                             arg_list, info);
2859       } else if (x-&gt;vtable_index() &lt; 0) {
2860         __ call_icvirtual(target, receiver, result_register,
2861                           SharedRuntime::get_resolve_virtual_call_stub(),
2862                           arg_list, info);
2863       } else {
2864         int entry_offset = in_bytes(Klass::vtable_start_offset()) + x-&gt;vtable_index() * vtableEntry::size_in_bytes();
2865         int vtable_offset = entry_offset + vtableEntry::method_offset_in_bytes();
2866         __ call_virtual(target, receiver, result_register, vtable_offset, arg_list, info);
2867       }
2868       break;
2869     case Bytecodes::_invokedynamic: {
2870       __ call_dynamic(target, receiver, result_register,
2871                       SharedRuntime::get_resolve_static_call_stub(),
2872                       arg_list, info);
2873       break;
2874     }
2875     default:
2876       fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(x-&gt;code()));
2877       break;
2878   }
2879 
2880   // JSR 292
2881   // Restore the SP after MethodHandle call sites, if needed.
2882   if (is_method_handle_invoke
2883       &amp;&amp; FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {
2884     __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());
2885   }
2886 
2887   if (x-&gt;type()-&gt;is_float() || x-&gt;type()-&gt;is_double()) {
2888     // Force rounding of results from non-strictfp when in strictfp
2889     // scope (or when we don&#39;t know the strictness of the callee, to
2890     // be safe.)
2891     if (method()-&gt;is_strict()) {
2892       if (!x-&gt;target_is_loaded() || !x-&gt;target_is_strictfp()) {
2893         result_register = round_item(result_register);
2894       }
2895     }
2896   }
2897 
2898   if (result_register-&gt;is_valid()) {
2899     LIR_Opr result = rlock_result(x);
2900     __ move(result_register, result);
2901   }
2902 }
2903 
2904 
2905 void LIRGenerator::do_FPIntrinsics(Intrinsic* x) {
2906   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
2907   LIRItem value       (x-&gt;argument_at(0), this);
2908   LIR_Opr reg = rlock_result(x);
2909   value.load_item();
2910   LIR_Opr tmp = force_to_spill(value.result(), as_BasicType(x-&gt;type()));
2911   __ move(tmp, reg);
2912 }
2913 
2914 
2915 
2916 // Code for  :  x-&gt;x() {x-&gt;cond()} x-&gt;y() ? x-&gt;tval() : x-&gt;fval()
2917 void LIRGenerator::do_IfOp(IfOp* x) {
2918 #ifdef ASSERT
2919   {
2920     ValueTag xtag = x-&gt;x()-&gt;type()-&gt;tag();
2921     ValueTag ttag = x-&gt;tval()-&gt;type()-&gt;tag();
2922     assert(xtag == intTag || xtag == objectTag, &quot;cannot handle others&quot;);
2923     assert(ttag == addressTag || ttag == intTag || ttag == objectTag || ttag == longTag, &quot;cannot handle others&quot;);
2924     assert(ttag == x-&gt;fval()-&gt;type()-&gt;tag(), &quot;cannot handle others&quot;);
2925   }
2926 #endif
2927 
2928   LIRItem left(x-&gt;x(), this);
2929   LIRItem right(x-&gt;y(), this);
2930   left.load_item();
2931   if (can_inline_as_constant(right.value())) {
2932     right.dont_load_item();
2933   } else {
2934     right.load_item();
2935   }
2936 
2937   LIRItem t_val(x-&gt;tval(), this);
2938   LIRItem f_val(x-&gt;fval(), this);
2939   t_val.dont_load_item();
2940   f_val.dont_load_item();
2941   LIR_Opr reg = rlock_result(x);
2942 
2943   __ cmp(lir_cond(x-&gt;cond()), left.result(), right.result());
2944   __ cmove(lir_cond(x-&gt;cond()), t_val.result(), f_val.result(), reg, as_BasicType(x-&gt;x()-&gt;type()));
2945 }
2946 
2947 #ifdef JFR_HAVE_INTRINSICS
2948 void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {
2949   CodeEmitInfo* info = state_for(x);
2950   CodeEmitInfo* info2 = new CodeEmitInfo(info); // Clone for the second null check
2951 
2952   assert(info != NULL, &quot;must have info&quot;);
2953   LIRItem arg(x-&gt;argument_at(0), this);
2954 
2955   arg.load_item();
2956   LIR_Opr klass = new_register(T_METADATA);
2957   __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), klass, info);
2958   LIR_Opr id = new_register(T_LONG);
2959   ByteSize offset = KLASS_TRACE_ID_OFFSET;
2960   LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);
2961 
2962   __ move(trace_id_addr, id);
2963   __ logical_or(id, LIR_OprFact::longConst(0x01l), id);
2964   __ store(id, trace_id_addr);
2965 
2966 #ifdef TRACE_ID_META_BITS
2967   __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);
2968 #endif
2969 #ifdef TRACE_ID_SHIFT
2970   __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);
2971 #endif
2972 
2973   __ move(id, rlock_result(x));
2974 }
2975 
2976 void LIRGenerator::do_getEventWriter(Intrinsic* x) {
2977   LabelObj* L_end = new LabelObj();
2978 
2979   LIR_Address* jobj_addr = new LIR_Address(getThreadPointer(),
2980                                            in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR),
2981                                            T_OBJECT);
2982   LIR_Opr result = rlock_result(x);
2983   __ move_wide(jobj_addr, result);
2984   __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(NULL));
2985   __ branch(lir_cond_equal, T_OBJECT, L_end-&gt;label());
2986 
2987   LIR_Opr jobj = new_register(T_OBJECT);
2988   __ move(result, jobj);
2989   access_load(IN_NATIVE, T_OBJECT, LIR_OprFact::address(new LIR_Address(jobj, T_OBJECT)), result);
2990 
2991   __ branch_destination(L_end-&gt;label());
2992 }
2993 
2994 #endif
2995 
2996 
2997 void LIRGenerator::do_RuntimeCall(address routine, Intrinsic* x) {
2998   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
2999   // Enforce computation of _reserved_argument_area_size which is required on some platforms.
3000   BasicTypeList signature;
3001   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
3002   LIR_Opr reg = result_register_for(x-&gt;type());
3003   __ call_runtime_leaf(routine, getThreadTemp(),
3004                        reg, new LIR_OprList());
3005   LIR_Opr result = rlock_result(x);
3006   __ move(reg, result);
3007 }
3008 
3009 
3010 
3011 void LIRGenerator::do_Intrinsic(Intrinsic* x) {
3012   switch (x-&gt;id()) {
3013   case vmIntrinsics::_intBitsToFloat      :
3014   case vmIntrinsics::_doubleToRawLongBits :
3015   case vmIntrinsics::_longBitsToDouble    :
3016   case vmIntrinsics::_floatToRawIntBits   : {
3017     do_FPIntrinsics(x);
3018     break;
3019   }
3020 
3021 #ifdef JFR_HAVE_INTRINSICS
3022   case vmIntrinsics::_getClassId:
3023     do_ClassIDIntrinsic(x);
3024     break;
3025   case vmIntrinsics::_getEventWriter:
3026     do_getEventWriter(x);
3027     break;
3028   case vmIntrinsics::_counterTime:
3029     do_RuntimeCall(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), x);
3030     break;
3031 #endif
3032 
3033   case vmIntrinsics::_currentTimeMillis:
3034     do_RuntimeCall(CAST_FROM_FN_PTR(address, os::javaTimeMillis), x);
3035     break;
3036 
3037   case vmIntrinsics::_nanoTime:
3038     do_RuntimeCall(CAST_FROM_FN_PTR(address, os::javaTimeNanos), x);
3039     break;
3040 
3041   case vmIntrinsics::_Object_init:    do_RegisterFinalizer(x); break;
3042   case vmIntrinsics::_isInstance:     do_isInstance(x);    break;
3043   case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;
3044   case vmIntrinsics::_getClass:       do_getClass(x);      break;
3045   case vmIntrinsics::_currentThread:  do_currentThread(x); break;
3046 
3047   case vmIntrinsics::_dlog:           // fall through
3048   case vmIntrinsics::_dlog10:         // fall through
3049   case vmIntrinsics::_dabs:           // fall through
3050   case vmIntrinsics::_dsqrt:          // fall through
3051   case vmIntrinsics::_dtan:           // fall through
3052   case vmIntrinsics::_dsin :          // fall through
3053   case vmIntrinsics::_dcos :          // fall through
3054   case vmIntrinsics::_dexp :          // fall through
3055   case vmIntrinsics::_dpow :          do_MathIntrinsic(x); break;
3056   case vmIntrinsics::_arraycopy:      do_ArrayCopy(x);     break;
3057 
3058   case vmIntrinsics::_fmaD:           do_FmaIntrinsic(x); break;
3059   case vmIntrinsics::_fmaF:           do_FmaIntrinsic(x); break;
3060 
3061   // java.nio.Buffer.checkIndex
3062   case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;
3063 
3064   case vmIntrinsics::_compareAndSetReference:
3065     do_CompareAndSwap(x, objectType);
3066     break;
3067   case vmIntrinsics::_compareAndSetInt:
3068     do_CompareAndSwap(x, intType);
3069     break;
3070   case vmIntrinsics::_compareAndSetLong:
3071     do_CompareAndSwap(x, longType);
3072     break;
3073 
3074   case vmIntrinsics::_loadFence :
3075     __ membar_acquire();
3076     break;
3077   case vmIntrinsics::_storeFence:
3078     __ membar_release();
3079     break;
3080   case vmIntrinsics::_fullFence :
3081     __ membar();
3082     break;
3083   case vmIntrinsics::_onSpinWait:
3084     __ on_spin_wait();
3085     break;
3086   case vmIntrinsics::_Reference_get:
3087     do_Reference_get(x);
3088     break;
3089 
3090   case vmIntrinsics::_updateCRC32:
3091   case vmIntrinsics::_updateBytesCRC32:
3092   case vmIntrinsics::_updateByteBufferCRC32:
3093     do_update_CRC32(x);
3094     break;
3095 
3096   case vmIntrinsics::_updateBytesCRC32C:
3097   case vmIntrinsics::_updateDirectByteBufferCRC32C:
3098     do_update_CRC32C(x);
3099     break;
3100 
3101   case vmIntrinsics::_vectorizedMismatch:
3102     do_vectorizedMismatch(x);
3103     break;
3104 
3105   default: ShouldNotReachHere(); break;
3106   }
3107 }
3108 
3109 void LIRGenerator::profile_arguments(ProfileCall* x) {
3110   if (compilation()-&gt;profile_arguments()) {
3111     int bci = x-&gt;bci_of_invoke();
3112     ciMethodData* md = x-&gt;method()-&gt;method_data_or_null();
3113     assert(md != NULL, &quot;Sanity&quot;);
3114     ciProfileData* data = md-&gt;bci_to_data(bci);
3115     if (data != NULL) {
3116       if ((data-&gt;is_CallTypeData() &amp;&amp; data-&gt;as_CallTypeData()-&gt;has_arguments()) ||
3117           (data-&gt;is_VirtualCallTypeData() &amp;&amp; data-&gt;as_VirtualCallTypeData()-&gt;has_arguments())) {
3118         ByteSize extra = data-&gt;is_CallTypeData() ? CallTypeData::args_data_offset() : VirtualCallTypeData::args_data_offset();
3119         int base_offset = md-&gt;byte_offset_of_slot(data, extra);
3120         LIR_Opr mdp = LIR_OprFact::illegalOpr;
3121         ciTypeStackSlotEntries* args = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;args() : ((ciVirtualCallTypeData*)data)-&gt;args();
3122 
3123         Bytecodes::Code bc = x-&gt;method()-&gt;java_code_at_bci(bci);
3124         int start = 0;
3125         int stop = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;number_of_arguments() : ((ciVirtualCallTypeData*)data)-&gt;number_of_arguments();
3126         if (x-&gt;callee()-&gt;is_loaded() &amp;&amp; x-&gt;callee()-&gt;is_static() &amp;&amp; Bytecodes::has_receiver(bc)) {
3127           // first argument is not profiled at call (method handle invoke)
3128           assert(x-&gt;method()-&gt;raw_code_at_bci(bci) == Bytecodes::_invokehandle, &quot;invokehandle expected&quot;);
3129           start = 1;
3130         }
3131         ciSignature* callee_signature = x-&gt;callee()-&gt;signature();
3132         // method handle call to virtual method
3133         bool has_receiver = x-&gt;callee()-&gt;is_loaded() &amp;&amp; !x-&gt;callee()-&gt;is_static() &amp;&amp; !Bytecodes::has_receiver(bc);
3134         ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x-&gt;callee()-&gt;holder() : NULL);
3135 
3136         bool ignored_will_link;
3137         ciSignature* signature_at_call = NULL;
3138         x-&gt;method()-&gt;get_method_at_bci(bci, ignored_will_link, &amp;signature_at_call);
3139         ciSignatureStream signature_at_call_stream(signature_at_call);
3140 
3141         // if called through method handle invoke, some arguments may have been popped
3142         for (int i = 0; i &lt; stop &amp;&amp; i+start &lt; x-&gt;nb_profiled_args(); i++) {
3143           int off = in_bytes(TypeEntriesAtCall::argument_type_offset(i)) - in_bytes(TypeEntriesAtCall::args_data_offset());
3144           ciKlass* exact = profile_type(md, base_offset, off,
3145               args-&gt;type(i), x-&gt;profiled_arg_at(i+start), mdp,
3146               !x-&gt;arg_needs_null_check(i+start),
3147               signature_at_call_stream.next_klass(), callee_signature_stream.next_klass());
3148           if (exact != NULL) {
3149             md-&gt;set_argument_type(bci, i, exact);
3150           }
3151         }
3152       } else {
3153 #ifdef ASSERT
3154         Bytecodes::Code code = x-&gt;method()-&gt;raw_code_at_bci(x-&gt;bci_of_invoke());
3155         int n = x-&gt;nb_profiled_args();
3156         assert(MethodData::profile_parameters() &amp;&amp; (MethodData::profile_arguments_jsr292_only() ||
3157             (x-&gt;inlined() &amp;&amp; ((code == Bytecodes::_invokedynamic &amp;&amp; n &lt;= 1) || (code == Bytecodes::_invokehandle &amp;&amp; n &lt;= 2)))),
3158             &quot;only at JSR292 bytecodes&quot;);
3159 #endif
3160       }
3161     }
3162   }
3163 }
3164 
3165 // profile parameters on entry to an inlined method
3166 void LIRGenerator::profile_parameters_at_call(ProfileCall* x) {
3167   if (compilation()-&gt;profile_parameters() &amp;&amp; x-&gt;inlined()) {
3168     ciMethodData* md = x-&gt;callee()-&gt;method_data_or_null();
3169     if (md != NULL) {
3170       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
3171       if (parameters_type_data != NULL) {
3172         ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
3173         LIR_Opr mdp = LIR_OprFact::illegalOpr;
3174         bool has_receiver = !x-&gt;callee()-&gt;is_static();
3175         ciSignature* sig = x-&gt;callee()-&gt;signature();
3176         ciSignatureStream sig_stream(sig, has_receiver ? x-&gt;callee()-&gt;holder() : NULL);
3177         int i = 0; // to iterate on the Instructions
3178         Value arg = x-&gt;recv();
3179         bool not_null = false;
3180         int bci = x-&gt;bci_of_invoke();
3181         Bytecodes::Code bc = x-&gt;method()-&gt;java_code_at_bci(bci);
3182         // The first parameter is the receiver so that&#39;s what we start
3183         // with if it exists. One exception is method handle call to
3184         // virtual method: the receiver is in the args list
3185         if (arg == NULL || !Bytecodes::has_receiver(bc)) {
3186           i = 1;
3187           arg = x-&gt;profiled_arg_at(0);
3188           not_null = !x-&gt;arg_needs_null_check(0);
3189         }
3190         int k = 0; // to iterate on the profile data
3191         for (;;) {
3192           intptr_t profiled_k = parameters-&gt;type(k);
3193           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
3194                                         in_bytes(ParametersTypeData::type_offset(k)) - in_bytes(ParametersTypeData::type_offset(0)),
3195                                         profiled_k, arg, mdp, not_null, sig_stream.next_klass(), NULL);
3196           // If the profile is known statically set it once for all and do not emit any code
3197           if (exact != NULL) {
3198             md-&gt;set_parameter_type(k, exact);
3199           }
3200           k++;
3201           if (k &gt;= parameters_type_data-&gt;number_of_parameters()) {
3202 #ifdef ASSERT
3203             int extra = 0;
3204             if (MethodData::profile_arguments() &amp;&amp; TypeProfileParmsLimit != -1 &amp;&amp;
3205                 x-&gt;nb_profiled_args() &gt;= TypeProfileParmsLimit &amp;&amp;
3206                 x-&gt;recv() != NULL &amp;&amp; Bytecodes::has_receiver(bc)) {
3207               extra += 1;
3208             }
3209             assert(i == x-&gt;nb_profiled_args() - extra || (TypeProfileParmsLimit != -1 &amp;&amp; TypeProfileArgsLimit &gt; TypeProfileParmsLimit), &quot;unused parameters?&quot;);
3210 #endif
3211             break;
3212           }
3213           arg = x-&gt;profiled_arg_at(i);
3214           not_null = !x-&gt;arg_needs_null_check(i);
3215           i++;
3216         }
3217       }
3218     }
3219   }
3220 }
3221 
3222 void LIRGenerator::do_ProfileCall(ProfileCall* x) {
3223   // Need recv in a temporary register so it interferes with the other temporaries
3224   LIR_Opr recv = LIR_OprFact::illegalOpr;
3225   LIR_Opr mdo = new_register(T_METADATA);
3226   // tmp is used to hold the counters on SPARC
3227   LIR_Opr tmp = new_pointer_register();
3228 
3229   if (x-&gt;nb_profiled_args() &gt; 0) {
3230     profile_arguments(x);
3231   }
3232 
3233   // profile parameters on inlined method entry including receiver
3234   if (x-&gt;recv() != NULL || x-&gt;nb_profiled_args() &gt; 0) {
3235     profile_parameters_at_call(x);
3236   }
3237 
3238   if (x-&gt;recv() != NULL) {
3239     LIRItem value(x-&gt;recv(), this);
3240     value.load_item();
3241     recv = new_register(T_OBJECT);
3242     __ move(value.result(), recv);
3243   }
3244   __ profile_call(x-&gt;method(), x-&gt;bci_of_invoke(), x-&gt;callee(), mdo, recv, tmp, x-&gt;known_holder());
3245 }
3246 
3247 void LIRGenerator::do_ProfileReturnType(ProfileReturnType* x) {
3248   int bci = x-&gt;bci_of_invoke();
3249   ciMethodData* md = x-&gt;method()-&gt;method_data_or_null();
3250   assert(md != NULL, &quot;Sanity&quot;);
3251   ciProfileData* data = md-&gt;bci_to_data(bci);
3252   if (data != NULL) {
3253     assert(data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData(), &quot;wrong profile data type&quot;);
3254     ciReturnTypeEntry* ret = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;ret() : ((ciVirtualCallTypeData*)data)-&gt;ret();
3255     LIR_Opr mdp = LIR_OprFact::illegalOpr;
3256 
3257     bool ignored_will_link;
3258     ciSignature* signature_at_call = NULL;
3259     x-&gt;method()-&gt;get_method_at_bci(bci, ignored_will_link, &amp;signature_at_call);
3260 
3261     // The offset within the MDO of the entry to update may be too large
3262     // to be used in load/store instructions on some platforms. So have
3263     // profile_type() compute the address of the profile in a register.
3264     ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(data, ret-&gt;type_offset()), 0,
3265         ret-&gt;type(), x-&gt;ret(), mdp,
3266         !x-&gt;needs_null_check(),
3267         signature_at_call-&gt;return_type()-&gt;as_klass(),
3268         x-&gt;callee()-&gt;signature()-&gt;return_type()-&gt;as_klass());
3269     if (exact != NULL) {
3270       md-&gt;set_return_type(bci, exact);
3271     }
3272   }
3273 }
3274 
3275 void LIRGenerator::do_ProfileInvoke(ProfileInvoke* x) {
3276   // We can safely ignore accessors here, since c2 will inline them anyway,
3277   // accessors are also always mature.
3278   if (!x-&gt;inlinee()-&gt;is_accessor()) {
3279     CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
3280     // Notify the runtime very infrequently only to take care of counter overflows
3281     int freq_log = Tier23InlineeNotifyFreqLog;
3282     double scale;
3283     if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3284       freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3285     }
3286     increment_event_counter_impl(info, x-&gt;inlinee(), LIR_OprFact::intConst(InvocationCounter::count_increment), right_n_bits(freq_log), InvocationEntryBci, false, true);
3287   }
3288 }
3289 
3290 void LIRGenerator::increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci) {
3291   if (compilation()-&gt;count_backedges()) {
<a name="17" id="anc17"></a><span class="line-added">3292 #if defined(X86) &amp;&amp; !defined(_LP64)</span>
<span class="line-added">3293     // BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.</span>
<span class="line-added">3294     LIR_Opr left_copy = new_register(left-&gt;type());</span>
<span class="line-added">3295     __ move(left, left_copy);</span>
<span class="line-added">3296     __ cmp(cond, left_copy, right);</span>
<span class="line-added">3297 #else</span>
3298     __ cmp(cond, left, right);
<a name="18" id="anc18"></a><span class="line-added">3299 #endif</span>
3300     LIR_Opr step = new_register(T_INT);
3301     LIR_Opr plus_one = LIR_OprFact::intConst(InvocationCounter::count_increment);
3302     LIR_Opr zero = LIR_OprFact::intConst(0);
3303     __ cmove(cond,
3304         (left_bci &lt; bci) ? plus_one : zero,
3305         (right_bci &lt; bci) ? plus_one : zero,
3306         step, left-&gt;type());
3307     increment_backedge_counter(info, step, bci);
3308   }
3309 }
3310 
3311 
3312 void LIRGenerator::increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge) {
3313   int freq_log = 0;
3314   int level = compilation()-&gt;env()-&gt;comp_level();
3315   if (level == CompLevel_limited_profile) {
3316     freq_log = (backedge ? Tier2BackedgeNotifyFreqLog : Tier2InvokeNotifyFreqLog);
3317   } else if (level == CompLevel_full_profile) {
3318     freq_log = (backedge ? Tier3BackedgeNotifyFreqLog : Tier3InvokeNotifyFreqLog);
3319   } else {
3320     ShouldNotReachHere();
3321   }
3322   // Increment the appropriate invocation/backedge counter and notify the runtime.
3323   double scale;
3324   if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3325     freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3326   }
3327   increment_event_counter_impl(info, info-&gt;scope()-&gt;method(), step, right_n_bits(freq_log), bci, backedge, true);
3328 }
3329 
3330 void LIRGenerator::decrement_age(CodeEmitInfo* info) {
3331   ciMethod* method = info-&gt;scope()-&gt;method();
3332   MethodCounters* mc_adr = method-&gt;ensure_method_counters();
3333   if (mc_adr != NULL) {
3334     LIR_Opr mc = new_pointer_register();
3335     __ move(LIR_OprFact::intptrConst(mc_adr), mc);
3336     int offset = in_bytes(MethodCounters::nmethod_age_offset());
3337     LIR_Address* counter = new LIR_Address(mc, offset, T_INT);
3338     LIR_Opr result = new_register(T_INT);
3339     __ load(counter, result);
3340     __ sub(result, LIR_OprFact::intConst(1), result);
3341     __ store(result, counter);
3342     // DeoptimizeStub will reexecute from the current state in code info.
3343     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_tenured,
3344                                          Deoptimization::Action_make_not_entrant);
3345     __ cmp(lir_cond_lessEqual, result, LIR_OprFact::intConst(0));
3346     __ branch(lir_cond_lessEqual, T_INT, deopt);
3347   }
3348 }
3349 
3350 
3351 void LIRGenerator::increment_event_counter_impl(CodeEmitInfo* info,
3352                                                 ciMethod *method, LIR_Opr step, int frequency,
3353                                                 int bci, bool backedge, bool notify) {
3354   assert(frequency == 0 || is_power_of_2(frequency + 1), &quot;Frequency must be x^2 - 1 or 0&quot;);
3355   int level = _compilation-&gt;env()-&gt;comp_level();
3356   assert(level &gt; CompLevel_simple, &quot;Shouldn&#39;t be here&quot;);
3357 
3358   int offset = -1;
3359   LIR_Opr counter_holder = NULL;
3360   if (level == CompLevel_limited_profile) {
3361     MethodCounters* counters_adr = method-&gt;ensure_method_counters();
3362     if (counters_adr == NULL) {
3363       bailout(&quot;method counters allocation failed&quot;);
3364       return;
3365     }
3366     counter_holder = new_pointer_register();
3367     __ move(LIR_OprFact::intptrConst(counters_adr), counter_holder);
3368     offset = in_bytes(backedge ? MethodCounters::backedge_counter_offset() :
3369                                  MethodCounters::invocation_counter_offset());
3370   } else if (level == CompLevel_full_profile) {
3371     counter_holder = new_register(T_METADATA);
3372     offset = in_bytes(backedge ? MethodData::backedge_counter_offset() :
3373                                  MethodData::invocation_counter_offset());
3374     ciMethodData* md = method-&gt;method_data_or_null();
3375     assert(md != NULL, &quot;Sanity&quot;);
3376     __ metadata2reg(md-&gt;constant_encoding(), counter_holder);
3377   } else {
3378     ShouldNotReachHere();
3379   }
3380   LIR_Address* counter = new LIR_Address(counter_holder, offset, T_INT);
3381   LIR_Opr result = new_register(T_INT);
3382   __ load(counter, result);
3383   __ add(result, step, result);
3384   __ store(result, counter);
3385   if (notify &amp;&amp; (!backedge || UseOnStackReplacement)) {
3386     LIR_Opr meth = LIR_OprFact::metadataConst(method-&gt;constant_encoding());
3387     // The bci for info can point to cmp for if&#39;s we want the if bci
3388     CodeStub* overflow = new CounterOverflowStub(info, bci, meth);
3389     int freq = frequency &lt;&lt; InvocationCounter::count_shift;
3390     if (freq == 0) {
3391       if (!step-&gt;is_constant()) {
3392         __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
3393         __ branch(lir_cond_notEqual, T_ILLEGAL, overflow);
3394       } else {
3395         __ branch(lir_cond_always, T_ILLEGAL, overflow);
3396       }
3397     } else {
3398       LIR_Opr mask = load_immediate(freq, T_INT);
3399       if (!step-&gt;is_constant()) {
3400         // If step is 0, make sure the overflow check below always fails
3401         __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
3402         __ cmove(lir_cond_notEqual, result, LIR_OprFact::intConst(InvocationCounter::count_increment), result, T_INT);
3403       }
3404       __ logical_and(result, mask, result);
3405       __ cmp(lir_cond_equal, result, LIR_OprFact::intConst(0));
3406       __ branch(lir_cond_equal, T_INT, overflow);
3407     }
3408     __ branch_destination(overflow-&gt;continuation());
3409   }
3410 }
3411 
3412 void LIRGenerator::do_RuntimeCall(RuntimeCall* x) {
3413   LIR_OprList* args = new LIR_OprList(x-&gt;number_of_arguments());
3414   BasicTypeList* signature = new BasicTypeList(x-&gt;number_of_arguments());
3415 
3416   if (x-&gt;pass_thread()) {
3417     signature-&gt;append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
3418     args-&gt;append(getThreadPointer());
3419   }
3420 
3421   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
3422     Value a = x-&gt;argument_at(i);
3423     LIRItem* item = new LIRItem(a, this);
3424     item-&gt;load_item();
3425     args-&gt;append(item-&gt;result());
3426     signature-&gt;append(as_BasicType(a-&gt;type()));
3427   }
3428 
3429   LIR_Opr result = call_runtime(signature, args, x-&gt;entry(), x-&gt;type(), NULL);
3430   if (x-&gt;type() == voidType) {
3431     set_no_result(x);
3432   } else {
3433     __ move(result, rlock_result(x));
3434   }
3435 }
3436 
3437 #ifdef ASSERT
3438 void LIRGenerator::do_Assert(Assert *x) {
3439   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
3440   If::Condition cond = x-&gt;cond();
3441 
3442   LIRItem xitem(x-&gt;x(), this);
3443   LIRItem yitem(x-&gt;y(), this);
3444   LIRItem* xin = &amp;xitem;
3445   LIRItem* yin = &amp;yitem;
3446 
3447   assert(tag == intTag, &quot;Only integer assertions are valid!&quot;);
3448 
3449   xin-&gt;load_item();
3450   yin-&gt;dont_load_item();
3451 
3452   set_no_result(x);
3453 
3454   LIR_Opr left = xin-&gt;result();
3455   LIR_Opr right = yin-&gt;result();
3456 
3457   __ lir_assert(lir_cond(x-&gt;cond()), left, right, x-&gt;message(), true);
3458 }
3459 #endif
3460 
3461 void LIRGenerator::do_RangeCheckPredicate(RangeCheckPredicate *x) {
3462 
3463 
3464   Instruction *a = x-&gt;x();
3465   Instruction *b = x-&gt;y();
3466   if (!a || StressRangeCheckElimination) {
3467     assert(!b || StressRangeCheckElimination, &quot;B must also be null&quot;);
3468 
3469     CodeEmitInfo *info = state_for(x, x-&gt;state());
3470     CodeStub* stub = new PredicateFailedStub(info);
3471 
3472     __ jump(stub);
3473   } else if (a-&gt;type()-&gt;as_IntConstant() &amp;&amp; b-&gt;type()-&gt;as_IntConstant()) {
3474     int a_int = a-&gt;type()-&gt;as_IntConstant()-&gt;value();
3475     int b_int = b-&gt;type()-&gt;as_IntConstant()-&gt;value();
3476 
3477     bool ok = false;
3478 
3479     switch(x-&gt;cond()) {
3480       case Instruction::eql: ok = (a_int == b_int); break;
3481       case Instruction::neq: ok = (a_int != b_int); break;
3482       case Instruction::lss: ok = (a_int &lt; b_int); break;
3483       case Instruction::leq: ok = (a_int &lt;= b_int); break;
3484       case Instruction::gtr: ok = (a_int &gt; b_int); break;
3485       case Instruction::geq: ok = (a_int &gt;= b_int); break;
3486       case Instruction::aeq: ok = ((unsigned int)a_int &gt;= (unsigned int)b_int); break;
3487       case Instruction::beq: ok = ((unsigned int)a_int &lt;= (unsigned int)b_int); break;
3488       default: ShouldNotReachHere();
3489     }
3490 
3491     if (ok) {
3492 
3493       CodeEmitInfo *info = state_for(x, x-&gt;state());
3494       CodeStub* stub = new PredicateFailedStub(info);
3495 
3496       __ jump(stub);
3497     }
3498   } else {
3499 
3500     ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
3501     If::Condition cond = x-&gt;cond();
3502     LIRItem xitem(x-&gt;x(), this);
3503     LIRItem yitem(x-&gt;y(), this);
3504     LIRItem* xin = &amp;xitem;
3505     LIRItem* yin = &amp;yitem;
3506 
3507     assert(tag == intTag, &quot;Only integer deoptimizations are valid!&quot;);
3508 
3509     xin-&gt;load_item();
3510     yin-&gt;dont_load_item();
3511     set_no_result(x);
3512 
3513     LIR_Opr left = xin-&gt;result();
3514     LIR_Opr right = yin-&gt;result();
3515 
3516     CodeEmitInfo *info = state_for(x, x-&gt;state());
3517     CodeStub* stub = new PredicateFailedStub(info);
3518 
3519     __ cmp(lir_cond(cond), left, right);
3520     __ branch(lir_cond(cond), right-&gt;type(), stub);
3521   }
3522 }
3523 
3524 
3525 LIR_Opr LIRGenerator::call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info) {
3526   LIRItemList args(1);
3527   LIRItem value(arg1, this);
3528   args.append(&amp;value);
3529   BasicTypeList signature;
3530   signature.append(as_BasicType(arg1-&gt;type()));
3531 
3532   return call_runtime(&amp;signature, &amp;args, entry, result_type, info);
3533 }
3534 
3535 
3536 LIR_Opr LIRGenerator::call_runtime(Value arg1, Value arg2, address entry, ValueType* result_type, CodeEmitInfo* info) {
3537   LIRItemList args(2);
3538   LIRItem value1(arg1, this);
3539   LIRItem value2(arg2, this);
3540   args.append(&amp;value1);
3541   args.append(&amp;value2);
3542   BasicTypeList signature;
3543   signature.append(as_BasicType(arg1-&gt;type()));
3544   signature.append(as_BasicType(arg2-&gt;type()));
3545 
3546   return call_runtime(&amp;signature, &amp;args, entry, result_type, info);
3547 }
3548 
3549 
3550 LIR_Opr LIRGenerator::call_runtime(BasicTypeArray* signature, LIR_OprList* args,
3551                                    address entry, ValueType* result_type, CodeEmitInfo* info) {
3552   // get a result register
3553   LIR_Opr phys_reg = LIR_OprFact::illegalOpr;
3554   LIR_Opr result = LIR_OprFact::illegalOpr;
3555   if (result_type-&gt;tag() != voidTag) {
3556     result = new_register(result_type);
3557     phys_reg = result_register_for(result_type);
3558   }
3559 
3560   // move the arguments into the correct location
3561   CallingConvention* cc = frame_map()-&gt;c_calling_convention(signature);
3562   assert(cc-&gt;length() == args-&gt;length(), &quot;argument mismatch&quot;);
3563   for (int i = 0; i &lt; args-&gt;length(); i++) {
3564     LIR_Opr arg = args-&gt;at(i);
3565     LIR_Opr loc = cc-&gt;at(i);
3566     if (loc-&gt;is_register()) {
3567       __ move(arg, loc);
3568     } else {
3569       LIR_Address* addr = loc-&gt;as_address_ptr();
3570 //           if (!can_store_as_constant(arg)) {
3571 //             LIR_Opr tmp = new_register(arg-&gt;type());
3572 //             __ move(arg, tmp);
3573 //             arg = tmp;
3574 //           }
3575       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
3576         __ unaligned_move(arg, addr);
3577       } else {
3578         __ move(arg, addr);
3579       }
3580     }
3581   }
3582 
3583   if (info) {
3584     __ call_runtime(entry, getThreadTemp(), phys_reg, cc-&gt;args(), info);
3585   } else {
3586     __ call_runtime_leaf(entry, getThreadTemp(), phys_reg, cc-&gt;args());
3587   }
3588   if (result-&gt;is_valid()) {
3589     __ move(phys_reg, result);
3590   }
3591   return result;
3592 }
3593 
3594 
3595 LIR_Opr LIRGenerator::call_runtime(BasicTypeArray* signature, LIRItemList* args,
3596                                    address entry, ValueType* result_type, CodeEmitInfo* info) {
3597   // get a result register
3598   LIR_Opr phys_reg = LIR_OprFact::illegalOpr;
3599   LIR_Opr result = LIR_OprFact::illegalOpr;
3600   if (result_type-&gt;tag() != voidTag) {
3601     result = new_register(result_type);
3602     phys_reg = result_register_for(result_type);
3603   }
3604 
3605   // move the arguments into the correct location
3606   CallingConvention* cc = frame_map()-&gt;c_calling_convention(signature);
3607 
3608   assert(cc-&gt;length() == args-&gt;length(), &quot;argument mismatch&quot;);
3609   for (int i = 0; i &lt; args-&gt;length(); i++) {
3610     LIRItem* arg = args-&gt;at(i);
3611     LIR_Opr loc = cc-&gt;at(i);
3612     if (loc-&gt;is_register()) {
3613       arg-&gt;load_item_force(loc);
3614     } else {
3615       LIR_Address* addr = loc-&gt;as_address_ptr();
3616       arg-&gt;load_for_store(addr-&gt;type());
3617       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
3618         __ unaligned_move(arg-&gt;result(), addr);
3619       } else {
3620         __ move(arg-&gt;result(), addr);
3621       }
3622     }
3623   }
3624 
3625   if (info) {
3626     __ call_runtime(entry, getThreadTemp(), phys_reg, cc-&gt;args(), info);
3627   } else {
3628     __ call_runtime_leaf(entry, getThreadTemp(), phys_reg, cc-&gt;args());
3629   }
3630   if (result-&gt;is_valid()) {
3631     __ move(phys_reg, result);
3632   }
3633   return result;
3634 }
3635 
3636 void LIRGenerator::do_MemBar(MemBar* x) {
3637   LIR_Code code = x-&gt;code();
3638   switch(code) {
3639   case lir_membar_acquire   : __ membar_acquire(); break;
3640   case lir_membar_release   : __ membar_release(); break;
3641   case lir_membar           : __ membar(); break;
3642   case lir_membar_loadload  : __ membar_loadload(); break;
3643   case lir_membar_storestore: __ membar_storestore(); break;
3644   case lir_membar_loadstore : __ membar_loadstore(); break;
3645   case lir_membar_storeload : __ membar_storeload(); break;
3646   default                   : ShouldNotReachHere(); break;
3647   }
3648 }
3649 
3650 LIR_Opr LIRGenerator::mask_boolean(LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info) {
3651   LIR_Opr value_fixed = rlock_byte(T_BYTE);
3652   if (TwoOperandLIRForm) {
3653     __ move(value, value_fixed);
3654     __ logical_and(value_fixed, LIR_OprFact::intConst(1), value_fixed);
3655   } else {
3656     __ logical_and(value, LIR_OprFact::intConst(1), value_fixed);
3657   }
3658   LIR_Opr klass = new_register(T_METADATA);
3659   __ move(new LIR_Address(array, oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, null_check_info);
3660   null_check_info = NULL;
3661   LIR_Opr layout = new_register(T_INT);
3662   __ move(new LIR_Address(klass, in_bytes(Klass::layout_helper_offset()), T_INT), layout);
3663   int diffbit = Klass::layout_helper_boolean_diffbit();
3664   __ logical_and(layout, LIR_OprFact::intConst(diffbit), layout);
3665   __ cmp(lir_cond_notEqual, layout, LIR_OprFact::intConst(0));
3666   __ cmove(lir_cond_notEqual, value_fixed, value, value_fixed, T_BYTE);
3667   value = value_fixed;
3668   return value;
3669 }
3670 
3671 LIR_Opr LIRGenerator::maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info) {
3672   if (x-&gt;check_boolean()) {
3673     value = mask_boolean(array, value, null_check_info);
3674   }
3675   return value;
3676 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
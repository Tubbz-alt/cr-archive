<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Canonicalizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  27 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  28 #include &quot;c1/c1_ValueStack.hpp&quot;
  29 #include &quot;ci/ciArray.hpp&quot;
  30 #include &quot;runtime/sharedRuntime.hpp&quot;
  31 
  32 
  33 class PrintValueVisitor: public ValueVisitor {
  34   void visit(Value* vp) {
  35     (*vp)-&gt;print_line();
  36   }
  37 };
  38 
  39 void Canonicalizer::set_canonical(Value x) {
  40   assert(x != NULL, &quot;value must exist&quot;);
  41   // Note: we can not currently substitute root nodes which show up in
  42   // the instruction stream (because the instruction list is embedded
  43   // in the instructions).
  44   if (canonical() != x) {
  45 #ifndef PRODUCT
  46     if (!x-&gt;has_printable_bci()) {
  47       x-&gt;set_printable_bci(bci());
  48     }
  49 #endif
  50     if (PrintCanonicalization) {
  51       PrintValueVisitor do_print_value;
  52       canonical()-&gt;input_values_do(&amp;do_print_value);
  53       canonical()-&gt;print_line();
  54       tty-&gt;print_cr(&quot;canonicalized to:&quot;);
  55       x-&gt;input_values_do(&amp;do_print_value);
  56       x-&gt;print_line();
  57       tty-&gt;cr();
  58     }
  59     assert(_canonical-&gt;type()-&gt;tag() == x-&gt;type()-&gt;tag(), &quot;types must match&quot;);
  60     _canonical = x;
  61   }
  62 }
  63 
  64 
  65 void Canonicalizer::move_const_to_right(Op2* x) {
  66   if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;is_commutative()) x-&gt;swap_operands();
  67 }
  68 
  69 
  70 void Canonicalizer::do_Op2(Op2* x) {
  71   if (x-&gt;x() == x-&gt;y()) {
  72     switch (x-&gt;op()) {
  73     case Bytecodes::_isub: set_constant(0); return;
  74     case Bytecodes::_lsub: set_constant(jlong_cast(0)); return;
  75     case Bytecodes::_iand: // fall through
  76     case Bytecodes::_land: // fall through
  77     case Bytecodes::_ior : // fall through
  78     case Bytecodes::_lor : set_canonical(x-&gt;x()); return;
  79     case Bytecodes::_ixor: set_constant(0); return;
  80     case Bytecodes::_lxor: set_constant(jlong_cast(0)); return;
  81     default              : break;
  82     }
  83   }
  84 
  85   if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;y()-&gt;type()-&gt;is_constant()) {
  86     // do constant folding for selected operations
  87     switch (x-&gt;type()-&gt;tag()) {
  88       case intTag:
  89         { jint a = x-&gt;x()-&gt;type()-&gt;as_IntConstant()-&gt;value();
  90           jint b = x-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value();
  91           switch (x-&gt;op()) {
  92             case Bytecodes::_iadd: set_constant(a + b); return;
  93             case Bytecodes::_isub: set_constant(a - b); return;
  94             case Bytecodes::_imul: set_constant(a * b); return;
  95             case Bytecodes::_idiv:
  96               if (b != 0) {
  97                 if (a == min_jint &amp;&amp; b == -1) {
  98                   set_constant(min_jint);
  99                 } else {
 100                   set_constant(a / b);
 101                 }
 102                 return;
 103               }
 104               break;
 105             case Bytecodes::_irem:
 106               if (b != 0) {
 107                 if (a == min_jint &amp;&amp; b == -1) {
 108                   set_constant(0);
 109                 } else {
 110                   set_constant(a % b);
 111                 }
 112                 return;
 113               }
 114               break;
 115             case Bytecodes::_iand: set_constant(a &amp; b); return;
 116             case Bytecodes::_ior : set_constant(a | b); return;
 117             case Bytecodes::_ixor: set_constant(a ^ b); return;
 118             default              : break;
 119           }
 120         }
 121         break;
 122       case longTag:
 123         { jlong a = x-&gt;x()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 124           jlong b = x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 125           switch (x-&gt;op()) {
 126             case Bytecodes::_ladd: set_constant(a + b); return;
 127             case Bytecodes::_lsub: set_constant(a - b); return;
 128             case Bytecodes::_lmul: set_constant(a * b); return;
 129             case Bytecodes::_ldiv:
 130               if (b != 0) {
 131                 set_constant(SharedRuntime::ldiv(b, a));
 132                 return;
 133               }
 134               break;
 135             case Bytecodes::_lrem:
 136               if (b != 0) {
 137                 set_constant(SharedRuntime::lrem(b, a));
 138                 return;
 139               }
 140               break;
 141             case Bytecodes::_land: set_constant(a &amp; b); return;
 142             case Bytecodes::_lor : set_constant(a | b); return;
 143             case Bytecodes::_lxor: set_constant(a ^ b); return;
 144             default              : break;
 145           }
 146         }
 147         break;
 148       default:
 149         // other cases not implemented (must be extremely careful with floats &amp; doubles!)
 150         break;
 151     }
 152   }
 153   // make sure constant is on the right side, if any
 154   move_const_to_right(x);
 155 
 156   if (x-&gt;y()-&gt;type()-&gt;is_constant()) {
 157     // do constant folding for selected operations
 158     switch (x-&gt;type()-&gt;tag()) {
 159       case intTag:
 160         if (x-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0) {
 161           switch (x-&gt;op()) {
 162             case Bytecodes::_iadd: set_canonical(x-&gt;x()); return;
 163             case Bytecodes::_isub: set_canonical(x-&gt;x()); return;
 164             case Bytecodes::_imul: set_constant(0); return;
 165               // Note: for div and rem, make sure that C semantics
 166               //       corresponds to Java semantics!
 167             case Bytecodes::_iand: set_constant(0); return;
 168             case Bytecodes::_ior : set_canonical(x-&gt;x()); return;
 169             default              : break;
 170           }
 171         }
 172         break;
 173       case longTag:
 174         if (x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value() == (jlong)0) {
 175           switch (x-&gt;op()) {
 176             case Bytecodes::_ladd: set_canonical(x-&gt;x()); return;
 177             case Bytecodes::_lsub: set_canonical(x-&gt;x()); return;
 178             case Bytecodes::_lmul: set_constant((jlong)0); return;
 179               // Note: for div and rem, make sure that C semantics
 180               //       corresponds to Java semantics!
 181             case Bytecodes::_land: set_constant((jlong)0); return;
 182             case Bytecodes::_lor : set_canonical(x-&gt;x()); return;
 183             default              : break;
 184           }
 185         }
 186         break;
 187       default:
 188         break;
 189     }
 190   }
 191 }
 192 
 193 
 194 void Canonicalizer::do_Phi            (Phi*             x) {}
 195 void Canonicalizer::do_Constant       (Constant*        x) {}
 196 void Canonicalizer::do_Local          (Local*           x) {}
 197 void Canonicalizer::do_LoadField      (LoadField*       x) {}
 198 
 199 // checks if v is in the block that is currently processed by
 200 // GraphBuilder. This is the only block that has not BlockEnd yet.
 201 static bool in_current_block(Value v) {
 202   int max_distance = 4;
 203   while (max_distance &gt; 0 &amp;&amp; v != NULL &amp;&amp; v-&gt;as_BlockEnd() == NULL) {
 204     v = v-&gt;next();
 205     max_distance--;
 206   }
 207   return v == NULL;
 208 }
 209 
 210 void Canonicalizer::do_StoreField     (StoreField*      x) {
 211   // If a value is going to be stored into a field or array some of
 212   // the conversions emitted by javac are unneeded because the fields
 213   // are packed to their natural size.
 214   Convert* conv = x-&gt;value()-&gt;as_Convert();
 215   if (conv) {
 216     Value value = NULL;
 217     BasicType type = x-&gt;field()-&gt;type()-&gt;basic_type();
 218     switch (conv-&gt;op()) {
 219     case Bytecodes::_i2b: if (type == T_BYTE)  value = conv-&gt;value(); break;
 220     case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) value = conv-&gt;value(); break;
 221     case Bytecodes::_i2c: if (type == T_CHAR  || type == T_BYTE)  value = conv-&gt;value(); break;
 222     default             : break;
 223     }
 224     // limit this optimization to current block
 225     if (value != NULL &amp;&amp; in_current_block(conv)) {
 226       set_canonical(new StoreField(x-&gt;obj(), x-&gt;offset(), x-&gt;field(), value, x-&gt;is_static(),
 227                                    x-&gt;state_before(), x-&gt;needs_patching()));
 228       return;
 229     }
 230   }
 231 
 232 }
 233 
 234 void Canonicalizer::do_ArrayLength    (ArrayLength*     x) {
 235   NewArray*  na;
 236   Constant*  ct;
 237   LoadField* lf;
 238 
 239   if ((na = x-&gt;array()-&gt;as_NewArray()) != NULL) {
 240     // New arrays might have the known length.
 241     // Do not use the Constant itself, but create a new Constant
 242     // with same value Otherwise a Constant is live over multiple
 243     // blocks without being registered in a state array.
 244     Constant* length;
 245     if (na-&gt;length() != NULL &amp;&amp;
 246         (length = na-&gt;length()-&gt;as_Constant()) != NULL) {
 247       assert(length-&gt;type()-&gt;as_IntConstant() != NULL, &quot;array length must be integer&quot;);
 248       set_constant(length-&gt;type()-&gt;as_IntConstant()-&gt;value());
 249     }
 250 
 251   } else if ((ct = x-&gt;array()-&gt;as_Constant()) != NULL) {
 252     // Constant arrays have constant lengths.
 253     ArrayConstant* cnst = ct-&gt;type()-&gt;as_ArrayConstant();
 254     if (cnst != NULL) {
 255       set_constant(cnst-&gt;value()-&gt;length());
 256     }
 257 
 258   } else if ((lf = x-&gt;array()-&gt;as_LoadField()) != NULL) {
 259     ciField* field = lf-&gt;field();
 260     if (field-&gt;is_static_constant()) {
 261       // Constant field loads are usually folded during parsing.
 262       // But it doesn&#39;t happen with PatchALot, ScavengeRootsInCode &lt; 2, or when
 263       // holder class is being initialized during parsing (for static fields).
 264       ciObject* c = field-&gt;constant_value().as_object();
 265       if (!c-&gt;is_null_object()) {
 266         set_constant(c-&gt;as_array()-&gt;length());
 267       }
 268     }
 269   }
 270 }
 271 
 272 void Canonicalizer::do_LoadIndexed    (LoadIndexed*     x) {
 273   StableArrayConstant* array = x-&gt;array()-&gt;type()-&gt;as_StableArrayConstant();
 274   IntConstant* index = x-&gt;index()-&gt;type()-&gt;as_IntConstant();
 275 
 276   assert(array == NULL || FoldStableValues, &quot;not enabled&quot;);
 277 
 278   // Constant fold loads from stable arrays.
 279   if (!x-&gt;mismatched() &amp;&amp; array != NULL &amp;&amp; index != NULL) {
 280     jint idx = index-&gt;value();
 281     if (idx &lt; 0 || idx &gt;= array-&gt;value()-&gt;length()) {
 282       // Leave the load as is. The range check will handle it.
 283       return;
 284     }
 285 
 286     ciConstant field_val = array-&gt;value()-&gt;element_value(idx);
 287     if (!field_val.is_null_or_zero()) {
 288       jint dimension = array-&gt;dimension();
 289       assert(dimension &lt;= array-&gt;value()-&gt;array_type()-&gt;dimension(), &quot;inconsistent info&quot;);
 290       ValueType* value = NULL;
 291       if (dimension &gt; 1) {
 292         // Preserve information about the dimension for the element.
 293         assert(field_val.as_object()-&gt;is_array(), &quot;not an array&quot;);
 294         value = new StableArrayConstant(field_val.as_object()-&gt;as_array(), dimension - 1);
 295       } else {
 296         assert(dimension == 1, &quot;sanity&quot;);
 297         value = as_ValueType(field_val);
 298       }
 299       set_canonical(new Constant(value));
 300     }
 301   }
 302 }
 303 
 304 void Canonicalizer::do_StoreIndexed   (StoreIndexed*    x) {
 305   // If a value is going to be stored into a field or array some of
 306   // the conversions emitted by javac are unneeded because the fields
 307   // are packed to their natural size.
 308   Convert* conv = x-&gt;value()-&gt;as_Convert();
 309   if (conv) {
 310     Value value = NULL;
 311     BasicType type = x-&gt;elt_type();
 312     switch (conv-&gt;op()) {
 313     case Bytecodes::_i2b: if (type == T_BYTE)  value = conv-&gt;value(); break;
 314     case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) value = conv-&gt;value(); break;
 315     case Bytecodes::_i2c: if (type == T_CHAR  || type == T_BYTE) value = conv-&gt;value(); break;
 316     default             : break;
 317     }
 318     // limit this optimization to current block
 319     if (value != NULL &amp;&amp; in_current_block(conv)) {
 320       set_canonical(new StoreIndexed(x-&gt;array(), x-&gt;index(), x-&gt;length(),
 321                                      x-&gt;elt_type(), value, x-&gt;state_before(),
 322                                      x-&gt;check_boolean()));
 323       return;
 324     }
 325   }
 326 }
 327 
 328 
 329 void Canonicalizer::do_NegateOp(NegateOp* x) {
 330   ValueType* t = x-&gt;x()-&gt;type();
 331   if (t-&gt;is_constant()) {
 332     switch (t-&gt;tag()) {
 333       case intTag   : set_constant(-t-&gt;as_IntConstant   ()-&gt;value()); return;
 334       case longTag  : set_constant(-t-&gt;as_LongConstant  ()-&gt;value()); return;
 335       case floatTag : set_constant(-t-&gt;as_FloatConstant ()-&gt;value()); return;
 336       case doubleTag: set_constant(-t-&gt;as_DoubleConstant()-&gt;value()); return;
 337       default       : ShouldNotReachHere();
 338     }
 339   }
 340 }
 341 
 342 
 343 void Canonicalizer::do_ArithmeticOp   (ArithmeticOp*    x) { do_Op2(x); }
 344 
 345 
 346 void Canonicalizer::do_ShiftOp        (ShiftOp*         x) {
 347   ValueType* t = x-&gt;x()-&gt;type();
 348   ValueType* t2 = x-&gt;y()-&gt;type();
 349   if (t-&gt;is_constant()) {
 350     switch (t-&gt;tag()) {
 351     case intTag   : if (t-&gt;as_IntConstant()-&gt;value() == 0)         { set_constant(0); return; } break;
 352     case longTag  : if (t-&gt;as_LongConstant()-&gt;value() == (jlong)0) { set_constant(jlong_cast(0)); return; } break;
 353     default       : ShouldNotReachHere();
 354     }
 355     if (t2-&gt;is_constant()) {
 356       if (t-&gt;tag() == intTag) {
<a name="2" id="anc2"></a><span class="line-modified"> 357         jint value = t-&gt;as_IntConstant()-&gt;value();</span>
<span class="line-modified"> 358         jint shift = t2-&gt;as_IntConstant()-&gt;value();</span>


 359         switch (x-&gt;op()) {
<a name="3" id="anc3"></a><span class="line-modified"> 360           case Bytecodes::_ishl:  set_constant(java_shift_left(value, shift)); return;</span>
<span class="line-modified"> 361           case Bytecodes::_ishr:  set_constant(java_shift_right(value, shift)); return;</span>
<span class="line-modified"> 362           case Bytecodes::_iushr: set_constant(java_shift_right_unsigned(value, shift)); return;</span>
 363           default:                break;
 364         }
 365       } else if (t-&gt;tag() == longTag) {
 366         jlong value = t-&gt;as_LongConstant()-&gt;value();
<a name="4" id="anc4"></a><span class="line-modified"> 367         jint shift = t2-&gt;as_IntConstant()-&gt;value();</span>


 368         switch (x-&gt;op()) {
<a name="5" id="anc5"></a><span class="line-modified"> 369           case Bytecodes::_lshl:  set_constant(java_shift_left(value, shift)); return;</span>
<span class="line-modified"> 370           case Bytecodes::_lshr:  set_constant(java_shift_right(value, shift)); return;</span>
<span class="line-modified"> 371           case Bytecodes::_lushr: set_constant(java_shift_right_unsigned(value, shift)); return;</span>
 372           default:                break;
 373         }
 374       }
 375     }
 376   }
 377   if (t2-&gt;is_constant()) {
 378     switch (t2-&gt;tag()) {
 379       case intTag   : if (t2-&gt;as_IntConstant()-&gt;value() == 0)  set_canonical(x-&gt;x()); return;
 380       case longTag  : if (t2-&gt;as_LongConstant()-&gt;value() == (jlong)0)  set_canonical(x-&gt;x()); return;
 381       default       : ShouldNotReachHere(); return;
 382     }
 383   }
 384 }
 385 
 386 
 387 void Canonicalizer::do_LogicOp        (LogicOp*         x) { do_Op2(x); }
 388 void Canonicalizer::do_CompareOp      (CompareOp*       x) {
 389   if (x-&gt;x() == x-&gt;y()) {
 390     switch (x-&gt;x()-&gt;type()-&gt;tag()) {
 391       case longTag: set_constant(0); break;
 392       case floatTag: {
 393         FloatConstant* fc = x-&gt;x()-&gt;type()-&gt;as_FloatConstant();
 394         if (fc) {
 395           if (g_isnan(fc-&gt;value())) {
 396             set_constant(x-&gt;op() == Bytecodes::_fcmpl ? -1 : 1);
 397           } else {
 398             set_constant(0);
 399           }
 400         }
 401         break;
 402       }
 403       case doubleTag: {
 404         DoubleConstant* dc = x-&gt;x()-&gt;type()-&gt;as_DoubleConstant();
 405         if (dc) {
 406           if (g_isnan(dc-&gt;value())) {
 407             set_constant(x-&gt;op() == Bytecodes::_dcmpl ? -1 : 1);
 408           } else {
 409             set_constant(0);
 410           }
 411         }
 412         break;
 413       }
 414       default:
 415         break;
 416     }
 417   } else if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;y()-&gt;type()-&gt;is_constant()) {
 418     switch (x-&gt;x()-&gt;type()-&gt;tag()) {
 419       case longTag: {
 420         jlong vx = x-&gt;x()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 421         jlong vy = x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 422         if (vx == vy)
 423           set_constant(0);
 424         else if (vx &lt; vy)
 425           set_constant(-1);
 426         else
 427           set_constant(1);
 428         break;
 429       }
 430 
 431       case floatTag: {
 432         float vx = x-&gt;x()-&gt;type()-&gt;as_FloatConstant()-&gt;value();
 433         float vy = x-&gt;y()-&gt;type()-&gt;as_FloatConstant()-&gt;value();
 434         if (g_isnan(vx) || g_isnan(vy))
 435           set_constant(x-&gt;op() == Bytecodes::_fcmpl ? -1 : 1);
 436         else if (vx == vy)
 437           set_constant(0);
 438         else if (vx &lt; vy)
 439           set_constant(-1);
 440         else
 441           set_constant(1);
 442         break;
 443       }
 444 
 445       case doubleTag: {
 446         double vx = x-&gt;x()-&gt;type()-&gt;as_DoubleConstant()-&gt;value();
 447         double vy = x-&gt;y()-&gt;type()-&gt;as_DoubleConstant()-&gt;value();
 448         if (g_isnan(vx) || g_isnan(vy))
 449           set_constant(x-&gt;op() == Bytecodes::_dcmpl ? -1 : 1);
 450         else if (vx == vy)
 451           set_constant(0);
 452         else if (vx &lt; vy)
 453           set_constant(-1);
 454         else
 455           set_constant(1);
 456         break;
 457       }
 458 
 459       default:
 460         break;
 461     }
 462   }
 463 }
 464 
 465 
 466 void Canonicalizer::do_IfInstanceOf(IfInstanceOf*    x) {}
 467 
 468 void Canonicalizer::do_IfOp(IfOp* x) {
 469   // Caution: do not use do_Op2(x) here for now since
 470   //          we map the condition to the op for now!
 471   move_const_to_right(x);
 472 }
 473 
 474 
 475 void Canonicalizer::do_Intrinsic      (Intrinsic*       x) {
 476   switch (x-&gt;id()) {
 477   case vmIntrinsics::_floatToRawIntBits   : {
 478     FloatConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_FloatConstant();
 479     if (c != NULL) {
 480       JavaValue v;
 481       v.set_jfloat(c-&gt;value());
 482       set_constant(v.get_jint());
 483     }
 484     break;
 485   }
 486   case vmIntrinsics::_intBitsToFloat      : {
 487     IntConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_IntConstant();
 488     if (c != NULL) {
 489       JavaValue v;
 490       v.set_jint(c-&gt;value());
 491       set_constant(v.get_jfloat());
 492     }
 493     break;
 494   }
 495   case vmIntrinsics::_doubleToRawLongBits : {
 496     DoubleConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_DoubleConstant();
 497     if (c != NULL) {
 498       JavaValue v;
 499       v.set_jdouble(c-&gt;value());
 500       set_constant(v.get_jlong());
 501     }
 502     break;
 503   }
 504   case vmIntrinsics::_longBitsToDouble    : {
 505     LongConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_LongConstant();
 506     if (c != NULL) {
 507       JavaValue v;
 508       v.set_jlong(c-&gt;value());
 509       set_constant(v.get_jdouble());
 510     }
 511     break;
 512   }
 513   case vmIntrinsics::_isInstance          : {
 514     assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 515 
 516     InstanceConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_InstanceConstant();
 517     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_null_object()) {
 518       // ciInstance::java_mirror_type() returns non-NULL only for Java mirrors
 519       ciType* t = c-&gt;value()-&gt;java_mirror_type();
 520       if (t-&gt;is_klass()) {
 521         // substitute cls.isInstance(obj) of a constant Class into
 522         // an InstantOf instruction
 523         InstanceOf* i = new InstanceOf(t-&gt;as_klass(), x-&gt;argument_at(1), x-&gt;state_before());
 524         set_canonical(i);
 525         // and try to canonicalize even further
 526         do_InstanceOf(i);
 527       } else {
 528         assert(t-&gt;is_primitive_type(), &quot;should be a primitive type&quot;);
 529         // cls.isInstance(obj) always returns false for primitive classes
 530         set_constant(0);
 531       }
 532     }
 533     break;
 534   }
 535   case vmIntrinsics::_isPrimitive        : {
 536     assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 537 
 538     // Class.isPrimitive is known on constant classes:
 539     InstanceConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_InstanceConstant();
 540     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_null_object()) {
 541       ciType* t = c-&gt;value()-&gt;java_mirror_type();
 542       set_constant(t-&gt;is_primitive_type());
 543     }
 544     break;
 545   }
 546   default:
 547     break;
 548   }
 549 }
 550 
 551 void Canonicalizer::do_Convert        (Convert*         x) {
 552   if (x-&gt;value()-&gt;type()-&gt;is_constant()) {
 553     switch (x-&gt;op()) {
 554     case Bytecodes::_i2b:  set_constant((int)((x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &lt;&lt; 24) &gt;&gt; 24)); break;
 555     case Bytecodes::_i2s:  set_constant((int)((x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &lt;&lt; 16) &gt;&gt; 16)); break;
 556     case Bytecodes::_i2c:  set_constant((int)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &amp; ((1&lt;&lt;16)-1))); break;
 557     case Bytecodes::_i2l:  set_constant((jlong)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));             break;
 558     case Bytecodes::_i2f:  set_constant((float)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));             break;
 559     case Bytecodes::_i2d:  set_constant((double)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));            break;
 560     case Bytecodes::_l2i:  set_constant((int)(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value()));              break;
 561     case Bytecodes::_l2f:  set_constant(SharedRuntime::l2f(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value())); break;
 562     case Bytecodes::_l2d:  set_constant(SharedRuntime::l2d(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value())); break;
 563     case Bytecodes::_f2d:  set_constant((double)(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value()));          break;
 564     case Bytecodes::_f2i:  set_constant(SharedRuntime::f2i(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value())); break;
 565     case Bytecodes::_f2l:  set_constant(SharedRuntime::f2l(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value())); break;
 566     case Bytecodes::_d2f:  set_constant((float)(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value()));          break;
 567     case Bytecodes::_d2i:  set_constant(SharedRuntime::d2i(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value())); break;
 568     case Bytecodes::_d2l:  set_constant(SharedRuntime::d2l(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value())); break;
 569     default:
 570       ShouldNotReachHere();
 571     }
 572   }
 573 
 574   Value value = x-&gt;value();
 575   BasicType type = T_ILLEGAL;
 576   LoadField* lf = value-&gt;as_LoadField();
 577   if (lf) {
 578     type = lf-&gt;field_type();
 579   } else {
 580     LoadIndexed* li = value-&gt;as_LoadIndexed();
 581     if (li) {
 582       type = li-&gt;elt_type();
 583     } else {
 584       Convert* conv = value-&gt;as_Convert();
 585       if (conv) {
 586         switch (conv-&gt;op()) {
 587           case Bytecodes::_i2b: type = T_BYTE;  break;
 588           case Bytecodes::_i2s: type = T_SHORT; break;
 589           case Bytecodes::_i2c: type = T_CHAR;  break;
 590           default             :                 break;
 591         }
 592       }
 593     }
 594   }
 595   if (type != T_ILLEGAL) {
 596     switch (x-&gt;op()) {
 597       case Bytecodes::_i2b: if (type == T_BYTE)                    set_canonical(x-&gt;value()); break;
 598       case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) set_canonical(x-&gt;value()); break;
 599       case Bytecodes::_i2c: if (type == T_CHAR)                    set_canonical(x-&gt;value()); break;
 600       default             :                                                                   break;
 601     }
 602   } else {
 603     Op2* op2 = x-&gt;value()-&gt;as_Op2();
 604     if (op2 &amp;&amp; op2-&gt;op() == Bytecodes::_iand &amp;&amp; op2-&gt;y()-&gt;type()-&gt;is_constant()) {
 605       jint safebits = 0;
 606       jint mask = op2-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 607       switch (x-&gt;op()) {
 608         case Bytecodes::_i2b: safebits = 0x7f;   break;
 609         case Bytecodes::_i2s: safebits = 0x7fff; break;
 610         case Bytecodes::_i2c: safebits = 0xffff; break;
 611         default             :                    break;
 612       }
 613       // When casting a masked integer to a smaller signed type, if
 614       // the mask doesn&#39;t include the sign bit the cast isn&#39;t needed.
 615       if (safebits &amp;&amp; (mask &amp; ~safebits) == 0) {
 616         set_canonical(x-&gt;value());
 617       }
 618     }
 619   }
 620 
 621 }
 622 
 623 void Canonicalizer::do_NullCheck      (NullCheck*       x) {
 624   if (x-&gt;obj()-&gt;as_NewArray() != NULL || x-&gt;obj()-&gt;as_NewInstance() != NULL) {
 625     set_canonical(x-&gt;obj());
 626   } else {
 627     Constant* con = x-&gt;obj()-&gt;as_Constant();
 628     if (con) {
 629       ObjectType* c = con-&gt;type()-&gt;as_ObjectType();
 630       if (c &amp;&amp; c-&gt;is_loaded()) {
 631         ObjectConstant* oc = c-&gt;as_ObjectConstant();
 632         if (!oc || !oc-&gt;value()-&gt;is_null_object()) {
 633           set_canonical(con);
 634         }
 635       }
 636     }
 637   }
 638 }
 639 
 640 void Canonicalizer::do_TypeCast       (TypeCast*        x) {}
 641 void Canonicalizer::do_Invoke         (Invoke*          x) {}
 642 void Canonicalizer::do_NewInstance    (NewInstance*     x) {}
 643 void Canonicalizer::do_NewTypeArray   (NewTypeArray*    x) {}
 644 void Canonicalizer::do_NewObjectArray (NewObjectArray*  x) {}
 645 void Canonicalizer::do_NewMultiArray  (NewMultiArray*   x) {}
 646 void Canonicalizer::do_CheckCast      (CheckCast*       x) {
 647   if (x-&gt;klass()-&gt;is_loaded()) {
 648     Value obj = x-&gt;obj();
 649     ciType* klass = obj-&gt;exact_type();
 650     if (klass == NULL) {
 651       klass = obj-&gt;declared_type();
 652     }
 653     if (klass != NULL &amp;&amp; klass-&gt;is_loaded()) {
 654       bool is_interface = klass-&gt;is_instance_klass() &amp;&amp;
 655                           klass-&gt;as_instance_klass()-&gt;is_interface();
 656       // Interface casts can&#39;t be statically optimized away since verifier doesn&#39;t
 657       // enforce interface types in bytecode.
 658       if (!is_interface &amp;&amp; klass-&gt;is_subtype_of(x-&gt;klass())) {
 659         set_canonical(obj);
 660         return;
 661       }
 662     }
 663     // checkcast of null returns null
 664     if (obj-&gt;as_Constant() &amp;&amp; obj-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object()) {
 665       set_canonical(obj);
 666     }
 667   }
 668 }
 669 void Canonicalizer::do_InstanceOf     (InstanceOf*      x) {
 670   if (x-&gt;klass()-&gt;is_loaded()) {
 671     Value obj = x-&gt;obj();
 672     ciType* exact = obj-&gt;exact_type();
 673     if (exact != NULL &amp;&amp; exact-&gt;is_loaded() &amp;&amp; (obj-&gt;as_NewInstance() || obj-&gt;as_NewArray())) {
 674       set_constant(exact-&gt;is_subtype_of(x-&gt;klass()) ? 1 : 0);
 675       return;
 676     }
 677     // instanceof null returns false
 678     if (obj-&gt;as_Constant() &amp;&amp; obj-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object()) {
 679       set_constant(0);
 680     }
 681   }
 682 
 683 }
 684 void Canonicalizer::do_MonitorEnter   (MonitorEnter*    x) {}
 685 void Canonicalizer::do_MonitorExit    (MonitorExit*     x) {}
 686 void Canonicalizer::do_BlockBegin     (BlockBegin*      x) {}
 687 void Canonicalizer::do_Goto           (Goto*            x) {}
 688 
 689 
 690 static bool is_true(jlong x, If::Condition cond, jlong y) {
 691   switch (cond) {
 692     case If::eql: return x == y;
 693     case If::neq: return x != y;
 694     case If::lss: return x &lt;  y;
 695     case If::leq: return x &lt;= y;
 696     case If::gtr: return x &gt;  y;
 697     case If::geq: return x &gt;= y;
 698     default:
 699       ShouldNotReachHere();
 700       return false;
 701   }
 702 }
 703 
 704 static bool is_safepoint(BlockEnd* x, BlockBegin* sux) {
 705   // An Instruction with multiple successors, x, is replaced by a Goto
 706   // to a single successor, sux. Is a safepoint check needed = was the
 707   // instruction being replaced a safepoint and the single remaining
 708   // successor a back branch?
 709   return x-&gt;is_safepoint() &amp;&amp; (sux-&gt;bci() &lt; x-&gt;state_before()-&gt;bci());
 710 }
 711 
 712 void Canonicalizer::do_If(If* x) {
 713   // move const to right
 714   if (x-&gt;x()-&gt;type()-&gt;is_constant()) x-&gt;swap_operands();
 715   // simplify
 716   const Value l = x-&gt;x(); ValueType* lt = l-&gt;type();
 717   const Value r = x-&gt;y(); ValueType* rt = r-&gt;type();
 718 
 719   if (l == r &amp;&amp; !lt-&gt;is_float_kind()) {
 720     // pattern: If (a cond a) =&gt; simplify to Goto
 721     BlockBegin* sux = NULL;
 722     switch (x-&gt;cond()) {
 723     case If::eql: sux = x-&gt;sux_for(true);  break;
 724     case If::neq: sux = x-&gt;sux_for(false); break;
 725     case If::lss: sux = x-&gt;sux_for(false); break;
 726     case If::leq: sux = x-&gt;sux_for(true);  break;
 727     case If::gtr: sux = x-&gt;sux_for(false); break;
 728     case If::geq: sux = x-&gt;sux_for(true);  break;
 729     default: ShouldNotReachHere();
 730     }
 731     // If is a safepoint then the debug information should come from the state_before of the If.
 732     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 733     return;
 734   }
 735 
 736   if (lt-&gt;is_constant() &amp;&amp; rt-&gt;is_constant()) {
 737     if (x-&gt;x()-&gt;as_Constant() != NULL) {
 738       // pattern: If (lc cond rc) =&gt; simplify to: Goto
 739       BlockBegin* sux = x-&gt;x()-&gt;as_Constant()-&gt;compare(x-&gt;cond(), x-&gt;y(),
 740                                                        x-&gt;sux_for(true),
 741                                                        x-&gt;sux_for(false));
 742       if (sux != NULL) {
 743         // If is a safepoint then the debug information should come from the state_before of the If.
 744         set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 745       }
 746     }
 747   } else if (rt-&gt;as_IntConstant() != NULL) {
 748     // pattern: If (l cond rc) =&gt; investigate further
 749     const jint rc = rt-&gt;as_IntConstant()-&gt;value();
 750     if (l-&gt;as_CompareOp() != NULL) {
 751       // pattern: If ((a cmp b) cond rc) =&gt; simplify to: If (x cond y) or: Goto
 752       CompareOp* cmp = l-&gt;as_CompareOp();
 753       bool unordered_is_less = cmp-&gt;op() == Bytecodes::_fcmpl || cmp-&gt;op() == Bytecodes::_dcmpl;
 754       BlockBegin* lss_sux = x-&gt;sux_for(is_true(-1, x-&gt;cond(), rc)); // successor for a &lt; b
 755       BlockBegin* eql_sux = x-&gt;sux_for(is_true( 0, x-&gt;cond(), rc)); // successor for a = b
 756       BlockBegin* gtr_sux = x-&gt;sux_for(is_true(+1, x-&gt;cond(), rc)); // successor for a &gt; b
 757       BlockBegin* nan_sux = unordered_is_less ? lss_sux : gtr_sux ; // successor for unordered
 758       // Note: At this point all successors (lss_sux, eql_sux, gtr_sux, nan_sux) are
 759       //       equal to x-&gt;tsux() or x-&gt;fsux(). Furthermore, nan_sux equals either
 760       //       lss_sux or gtr_sux.
 761       if (lss_sux == eql_sux &amp;&amp; eql_sux == gtr_sux) {
 762         // all successors identical =&gt; simplify to: Goto
 763         set_canonical(new Goto(lss_sux, x-&gt;state_before(), x-&gt;is_safepoint()));
 764       } else {
 765         // two successors differ and two successors are the same =&gt; simplify to: If (x cmp y)
 766         // determine new condition &amp; successors
 767         If::Condition cond = If::eql;
 768         BlockBegin* tsux = NULL;
 769         BlockBegin* fsux = NULL;
 770              if (lss_sux == eql_sux) { cond = If::leq; tsux = lss_sux; fsux = gtr_sux; }
 771         else if (lss_sux == gtr_sux) { cond = If::neq; tsux = lss_sux; fsux = eql_sux; }
 772         else if (eql_sux == gtr_sux) { cond = If::geq; tsux = eql_sux; fsux = lss_sux; }
 773         else                         { ShouldNotReachHere();                           }
 774         If* canon = new If(cmp-&gt;x(), cond, nan_sux == tsux, cmp-&gt;y(), tsux, fsux, cmp-&gt;state_before(), x-&gt;is_safepoint());
 775         if (cmp-&gt;x() == cmp-&gt;y()) {
 776           do_If(canon);
 777         } else {
 778           if (compilation()-&gt;profile_branches() || compilation()-&gt;count_backedges()) {
 779             // TODO: If profiling, leave floating point comparisons unoptimized.
 780             // We currently do not support profiling of the unordered case.
 781             switch(cmp-&gt;op()) {
 782               case Bytecodes::_fcmpl: case Bytecodes::_fcmpg:
 783               case Bytecodes::_dcmpl: case Bytecodes::_dcmpg:
 784                 set_canonical(x);
 785                 return;
 786               default:
 787                 break;
 788             }
 789           }
 790           set_bci(cmp-&gt;state_before()-&gt;bci());
 791           set_canonical(canon);
 792         }
 793       }
 794     } else if (l-&gt;as_InstanceOf() != NULL) {
 795       // NOTE: Code permanently disabled for now since it leaves the old InstanceOf
 796       //       instruction in the graph (it is pinned). Need to fix this at some point.
 797       //       It should also be left in the graph when generating a profiled method version or Goto
 798       //       has to know that it was an InstanceOf.
 799       return;
 800       // pattern: If ((obj instanceof klass) cond rc) =&gt; simplify to: IfInstanceOf or: Goto
 801       InstanceOf* inst = l-&gt;as_InstanceOf();
 802       BlockBegin* is_inst_sux = x-&gt;sux_for(is_true(1, x-&gt;cond(), rc)); // successor for instanceof == 1
 803       BlockBegin* no_inst_sux = x-&gt;sux_for(is_true(0, x-&gt;cond(), rc)); // successor for instanceof == 0
 804       if (is_inst_sux == no_inst_sux &amp;&amp; inst-&gt;is_loaded()) {
 805         // both successors identical and klass is loaded =&gt; simplify to: Goto
 806         set_canonical(new Goto(is_inst_sux, x-&gt;state_before(), x-&gt;is_safepoint()));
 807       } else {
 808         // successors differ =&gt; simplify to: IfInstanceOf
 809         set_canonical(new IfInstanceOf(inst-&gt;klass(), inst-&gt;obj(), true, inst-&gt;state_before()-&gt;bci(), is_inst_sux, no_inst_sux));
 810       }
 811     }
 812   } else if (rt == objectNull &amp;&amp;
 813            (l-&gt;as_NewInstance() || l-&gt;as_NewArray() ||
 814              (l-&gt;as_Local() &amp;&amp; l-&gt;as_Local()-&gt;is_receiver()))) {
 815     if (x-&gt;cond() == Instruction::eql) {
 816       BlockBegin* sux = x-&gt;fsux();
 817       set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 818     } else {
 819       assert(x-&gt;cond() == Instruction::neq, &quot;only other valid case&quot;);
 820       BlockBegin* sux = x-&gt;tsux();
 821       set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 822     }
 823   }
 824 }
 825 
 826 
 827 void Canonicalizer::do_TableSwitch(TableSwitch* x) {
 828   if (x-&gt;tag()-&gt;type()-&gt;is_constant()) {
 829     int v = x-&gt;tag()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 830     BlockBegin* sux = x-&gt;default_sux();
 831     if (v &gt;= x-&gt;lo_key() &amp;&amp; v &lt;= x-&gt;hi_key()) {
 832       sux = x-&gt;sux_at(v - x-&gt;lo_key());
 833     }
 834     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 835   } else if (x-&gt;number_of_sux() == 1) {
 836     // NOTE: Code permanently disabled for now since the switch statement&#39;s
 837     //       tag expression may produce side-effects in which case it must
 838     //       be executed.
 839     return;
 840     // simplify to Goto
 841     set_canonical(new Goto(x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 842   } else if (x-&gt;number_of_sux() == 2) {
 843     // NOTE: Code permanently disabled for now since it produces two new nodes
 844     //       (Constant &amp; If) and the Canonicalizer cannot return them correctly
 845     //       yet. For now we copied the corresponding code directly into the
 846     //       GraphBuilder (i.e., we should never reach here).
 847     return;
 848     // simplify to If
 849     assert(x-&gt;lo_key() == x-&gt;hi_key(), &quot;keys must be the same&quot;);
 850     Constant* key = new Constant(new IntConstant(x-&gt;lo_key()));
 851     set_canonical(new If(x-&gt;tag(), If::eql, true, key, x-&gt;sux_at(0), x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 852   }
 853 }
 854 
 855 
 856 void Canonicalizer::do_LookupSwitch(LookupSwitch* x) {
 857   if (x-&gt;tag()-&gt;type()-&gt;is_constant()) {
 858     int v = x-&gt;tag()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 859     BlockBegin* sux = x-&gt;default_sux();
 860     for (int i = 0; i &lt; x-&gt;length(); i++) {
 861       if (v == x-&gt;key_at(i)) {
 862         sux = x-&gt;sux_at(i);
 863       }
 864     }
 865     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 866   } else if (x-&gt;number_of_sux() == 1) {
 867     // NOTE: Code permanently disabled for now since the switch statement&#39;s
 868     //       tag expression may produce side-effects in which case it must
 869     //       be executed.
 870     return;
 871     // simplify to Goto
 872     set_canonical(new Goto(x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 873   } else if (x-&gt;number_of_sux() == 2) {
 874     // NOTE: Code permanently disabled for now since it produces two new nodes
 875     //       (Constant &amp; If) and the Canonicalizer cannot return them correctly
 876     //       yet. For now we copied the corresponding code directly into the
 877     //       GraphBuilder (i.e., we should never reach here).
 878     return;
 879     // simplify to If
 880     assert(x-&gt;length() == 1, &quot;length must be the same&quot;);
 881     Constant* key = new Constant(new IntConstant(x-&gt;key_at(0)));
 882     set_canonical(new If(x-&gt;tag(), If::eql, true, key, x-&gt;sux_at(0), x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 883   }
 884 }
 885 
 886 
 887 void Canonicalizer::do_Return         (Return*          x) {}
 888 void Canonicalizer::do_Throw          (Throw*           x) {}
 889 void Canonicalizer::do_Base           (Base*            x) {}
 890 void Canonicalizer::do_OsrEntry       (OsrEntry*        x) {}
 891 void Canonicalizer::do_ExceptionObject(ExceptionObject* x) {}
 892 
 893 static bool match_index_and_scale(Instruction*  instr,
 894                                   Instruction** index,
 895                                   int*          log2_scale) {
 896   // Skip conversion ops. This works only on 32bit because of the implicit l2i that the
 897   // unsafe performs.
 898 #ifndef _LP64
 899   Convert* convert = instr-&gt;as_Convert();
 900   if (convert != NULL &amp;&amp; convert-&gt;op() == Bytecodes::_i2l) {
 901     assert(convert-&gt;value()-&gt;type() == intType, &quot;invalid input type&quot;);
 902     instr = convert-&gt;value();
 903   }
 904 #endif
 905 
 906   ShiftOp* shift = instr-&gt;as_ShiftOp();
 907   if (shift != NULL) {
 908     if (shift-&gt;op() == Bytecodes::_lshl) {
 909       assert(shift-&gt;x()-&gt;type() == longType, &quot;invalid input type&quot;);
 910     } else {
 911 #ifndef _LP64
 912       if (shift-&gt;op() == Bytecodes::_ishl) {
 913         assert(shift-&gt;x()-&gt;type() == intType, &quot;invalid input type&quot;);
 914       } else {
 915         return false;
 916       }
 917 #else
 918       return false;
 919 #endif
 920     }
 921 
 922 
 923     // Constant shift value?
 924     Constant* con = shift-&gt;y()-&gt;as_Constant();
 925     if (con == NULL) return false;
 926     // Well-known type and value?
 927     IntConstant* val = con-&gt;type()-&gt;as_IntConstant();
 928     assert(val != NULL, &quot;Should be an int constant&quot;);
 929 
 930     *index = shift-&gt;x();
 931     int tmp_scale = val-&gt;value();
 932     if (tmp_scale &gt;= 0 &amp;&amp; tmp_scale &lt; 4) {
 933       *log2_scale = tmp_scale;
 934       return true;
 935     } else {
 936       return false;
 937     }
 938   }
 939 
 940   ArithmeticOp* arith = instr-&gt;as_ArithmeticOp();
 941   if (arith != NULL) {
 942     // See if either arg is a known constant
 943     Constant* con = arith-&gt;x()-&gt;as_Constant();
 944     if (con != NULL) {
 945       *index = arith-&gt;y();
 946     } else {
 947       con = arith-&gt;y()-&gt;as_Constant();
 948       if (con == NULL) return false;
 949       *index = arith-&gt;x();
 950     }
 951     long const_value;
 952     // Check for integer multiply
 953     if (arith-&gt;op() == Bytecodes::_lmul) {
 954       assert((*index)-&gt;type() == longType, &quot;invalid input type&quot;);
 955       LongConstant* val = con-&gt;type()-&gt;as_LongConstant();
 956       assert(val != NULL, &quot;expecting a long constant&quot;);
 957       const_value = val-&gt;value();
 958     } else {
 959 #ifndef _LP64
 960       if (arith-&gt;op() == Bytecodes::_imul) {
 961         assert((*index)-&gt;type() == intType, &quot;invalid input type&quot;);
 962         IntConstant* val = con-&gt;type()-&gt;as_IntConstant();
 963         assert(val != NULL, &quot;expecting an int constant&quot;);
 964         const_value = val-&gt;value();
 965       } else {
 966         return false;
 967       }
 968 #else
 969       return false;
 970 #endif
 971     }
 972     switch (const_value) {
 973     case 1: *log2_scale = 0; return true;
 974     case 2: *log2_scale = 1; return true;
 975     case 4: *log2_scale = 2; return true;
 976     case 8: *log2_scale = 3; return true;
 977     default:            return false;
 978     }
 979   }
 980 
 981   // Unknown instruction sequence; don&#39;t touch it
 982   return false;
 983 }
 984 
 985 
 986 static bool match(UnsafeRawOp* x,
 987                   Instruction** base,
 988                   Instruction** index,
 989                   int*          log2_scale) {
 990   ArithmeticOp* root = x-&gt;base()-&gt;as_ArithmeticOp();
 991   if (root == NULL) return false;
 992   // Limit ourselves to addition for now
 993   if (root-&gt;op() != Bytecodes::_ladd) return false;
 994 
 995   bool match_found = false;
 996   // Try to find shift or scale op
 997   if (match_index_and_scale(root-&gt;y(), index, log2_scale)) {
 998     *base = root-&gt;x();
 999     match_found = true;
1000   } else if (match_index_and_scale(root-&gt;x(), index, log2_scale)) {
1001     *base = root-&gt;y();
1002     match_found = true;
1003   } else if (NOT_LP64(root-&gt;y()-&gt;as_Convert() != NULL) LP64_ONLY(false)) {
1004     // Skipping i2l works only on 32bit because of the implicit l2i that the unsafe performs.
1005     // 64bit needs a real sign-extending conversion.
1006     Convert* convert = root-&gt;y()-&gt;as_Convert();
1007     if (convert-&gt;op() == Bytecodes::_i2l) {
1008       assert(convert-&gt;value()-&gt;type() == intType, &quot;should be an int&quot;);
1009       // pick base and index, setting scale at 1
1010       *base  = root-&gt;x();
1011       *index = convert-&gt;value();
1012       *log2_scale = 0;
1013       match_found = true;
1014     }
1015   }
1016   // The default solution
1017   if (!match_found) {
1018     *base = root-&gt;x();
1019     *index = root-&gt;y();
1020     *log2_scale = 0;
1021   }
1022 
1023   // If the value is pinned then it will be always be computed so
1024   // there&#39;s no profit to reshaping the expression.
1025   return !root-&gt;is_pinned();
1026 }
1027 
1028 
1029 void Canonicalizer::do_UnsafeRawOp(UnsafeRawOp* x) {
1030   Instruction* base = NULL;
1031   Instruction* index = NULL;
1032   int          log2_scale;
1033 
1034   if (match(x, &amp;base, &amp;index, &amp;log2_scale)) {
1035     x-&gt;set_base(base);
1036     x-&gt;set_index(index);
1037     x-&gt;set_log2_scale(log2_scale);
1038     if (PrintUnsafeOptimization) {
1039       tty-&gt;print_cr(&quot;Canonicalizer: UnsafeRawOp id %d: base = id %d, index = id %d, log2_scale = %d&quot;,
1040                     x-&gt;id(), x-&gt;base()-&gt;id(), x-&gt;index()-&gt;id(), x-&gt;log2_scale());
1041     }
1042   }
1043 }
1044 
1045 void Canonicalizer::do_RoundFP(RoundFP* x) {}
1046 void Canonicalizer::do_UnsafeGetRaw(UnsafeGetRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }
1047 void Canonicalizer::do_UnsafePutRaw(UnsafePutRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }
1048 void Canonicalizer::do_UnsafeGetObject(UnsafeGetObject* x) {}
1049 void Canonicalizer::do_UnsafePutObject(UnsafePutObject* x) {}
1050 void Canonicalizer::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}
1051 void Canonicalizer::do_ProfileCall(ProfileCall* x) {}
1052 void Canonicalizer::do_ProfileReturnType(ProfileReturnType* x) {}
1053 void Canonicalizer::do_ProfileInvoke(ProfileInvoke* x) {}
1054 void Canonicalizer::do_RuntimeCall(RuntimeCall* x) {}
1055 void Canonicalizer::do_RangeCheckPredicate(RangeCheckPredicate* x) {}
1056 #ifdef ASSERT
1057 void Canonicalizer::do_Assert(Assert* x) {}
1058 #endif
1059 void Canonicalizer::do_MemBar(MemBar* x) {}
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
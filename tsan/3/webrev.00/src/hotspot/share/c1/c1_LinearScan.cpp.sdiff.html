<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LinearScan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
<span class="line-modified">  93 #ifdef X86</span>
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
</pre>
<hr />
<pre>
2636       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2637       _scope_value_cache.at_put(cache_idx, sv);
2638     }
2639 
2640     // check if cached value is correct
2641     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2642 
2643     scope_values-&gt;append(sv);
2644     return 1;
2645 
2646 #ifdef X86
2647   } else if (opr-&gt;is_single_xmm()) {
2648     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2649     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2650 
2651     scope_values-&gt;append(sv);
2652     return 1;
2653 #endif
2654 
2655   } else if (opr-&gt;is_single_fpu()) {
<span class="line-modified">2656 #ifdef X86</span>
2657     // the exact location of fpu stack values is only known
2658     // during fpu stack allocation, so the stack allocator object
2659     // must be present
2660     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2661     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2662     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);


2663 #endif
2664 
2665     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2666     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2667 #ifndef __SOFTFP__
2668 #ifndef VM_LITTLE_ENDIAN
2669     // On S390 a (single precision) float value occupies only the high
2670     // word of the full double register. So when the double register is
2671     // stored to memory (e.g. by the RegisterSaver), then the float value
2672     // is found at offset 0. I.e. the code below is not needed on S390.
2673 #ifndef S390
2674     if (! float_saved_as_double) {
2675       // On big endian system, we may have an issue if float registers use only
2676       // the low half of the (same) double registers.
2677       // Both the float and the double could have the same regnr but would correspond
2678       // to two different addresses once saved.
2679 
2680       // get next safely (no assertion checks)
2681       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2682       if (next-&gt;is_reg() &amp;&amp;
</pre>
<hr />
<pre>
2747       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2748       second = _int_0_scope_value;
2749 #  else
2750       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2751       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2752       if (true) {
2753         VMReg rname_second = rname_first-&gt;next();
2754         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2755       }
2756 #  endif
2757 #endif
2758 
2759     } else if (opr-&gt;is_double_fpu()) {
2760       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2761       // the double as float registers in the native ordering. On X86,
2762       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2763       // the low-order word of the double and fpu_regnrLo + 1 is the
2764       // name for the other half.  *first and *second must represent the
2765       // least and most significant words, respectively.
2766 
<span class="line-modified">2767 #ifdef X86</span>
2768       // the exact location of fpu stack values is only known
2769       // during fpu stack allocation, so the stack allocator object
2770       // must be present
2771       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2772       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2773       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2774 
2775       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2776 #endif



2777 #ifdef SPARC
2778       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2779 #endif
2780 #ifdef ARM32
2781       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2782 #endif
2783 #ifdef PPC32
2784       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2785 #endif
2786 
2787 #ifdef VM_LITTLE_ENDIAN
2788       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2789 #else
2790       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2791 #endif
2792 
2793 #ifdef _LP64
2794       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2795       second = _int_0_scope_value;
2796 #else
</pre>
</td>
<td>
<hr />
<pre>
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
<span class="line-modified">  93 #ifdef IA32</span>
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
</pre>
<hr />
<pre>
2636       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2637       _scope_value_cache.at_put(cache_idx, sv);
2638     }
2639 
2640     // check if cached value is correct
2641     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2642 
2643     scope_values-&gt;append(sv);
2644     return 1;
2645 
2646 #ifdef X86
2647   } else if (opr-&gt;is_single_xmm()) {
2648     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2649     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2650 
2651     scope_values-&gt;append(sv);
2652     return 1;
2653 #endif
2654 
2655   } else if (opr-&gt;is_single_fpu()) {
<span class="line-modified">2656 #ifdef IA32</span>
2657     // the exact location of fpu stack values is only known
2658     // during fpu stack allocation, so the stack allocator object
2659     // must be present
2660     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2661     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2662     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
<span class="line-added">2663 #elif defined(AMD64)</span>
<span class="line-added">2664     assert(false, &quot;FPU not used on x86-64&quot;);</span>
2665 #endif
2666 
2667     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2668     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2669 #ifndef __SOFTFP__
2670 #ifndef VM_LITTLE_ENDIAN
2671     // On S390 a (single precision) float value occupies only the high
2672     // word of the full double register. So when the double register is
2673     // stored to memory (e.g. by the RegisterSaver), then the float value
2674     // is found at offset 0. I.e. the code below is not needed on S390.
2675 #ifndef S390
2676     if (! float_saved_as_double) {
2677       // On big endian system, we may have an issue if float registers use only
2678       // the low half of the (same) double registers.
2679       // Both the float and the double could have the same regnr but would correspond
2680       // to two different addresses once saved.
2681 
2682       // get next safely (no assertion checks)
2683       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2684       if (next-&gt;is_reg() &amp;&amp;
</pre>
<hr />
<pre>
2749       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2750       second = _int_0_scope_value;
2751 #  else
2752       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2753       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2754       if (true) {
2755         VMReg rname_second = rname_first-&gt;next();
2756         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2757       }
2758 #  endif
2759 #endif
2760 
2761     } else if (opr-&gt;is_double_fpu()) {
2762       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2763       // the double as float registers in the native ordering. On X86,
2764       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2765       // the low-order word of the double and fpu_regnrLo + 1 is the
2766       // name for the other half.  *first and *second must represent the
2767       // least and most significant words, respectively.
2768 
<span class="line-modified">2769 #ifdef IA32</span>
2770       // the exact location of fpu stack values is only known
2771       // during fpu stack allocation, so the stack allocator object
2772       // must be present
2773       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2774       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2775       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2776 
2777       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2778 #endif
<span class="line-added">2779 #ifdef AMD64</span>
<span class="line-added">2780       assert(false, &quot;FPU not used on x86-64&quot;);</span>
<span class="line-added">2781 #endif</span>
2782 #ifdef SPARC
2783       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2784 #endif
2785 #ifdef ARM32
2786       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2787 #endif
2788 #ifdef PPC32
2789       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2790 #endif
2791 
2792 #ifdef VM_LITTLE_ENDIAN
2793       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2794 #else
2795       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2796 #endif
2797 
2798 #ifdef _LP64
2799       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2800       second = _int_0_scope_value;
2801 #else
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
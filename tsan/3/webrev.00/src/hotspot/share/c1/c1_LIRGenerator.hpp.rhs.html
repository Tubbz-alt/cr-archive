<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRGenerator.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_LIRGENERATOR_HPP
 26 #define SHARE_C1_C1_LIRGENERATOR_HPP
 27 
 28 #include &quot;c1/c1_Decorators.hpp&quot;
 29 #include &quot;c1/c1_Instruction.hpp&quot;
 30 #include &quot;c1/c1_LIR.hpp&quot;
 31 #include &quot;ci/ciMethodData.hpp&quot;
 32 #include &quot;gc/shared/barrierSet.hpp&quot;
 33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;utilities/sizes.hpp&quot;
 36 
 37 class BarrierSetC1;
 38 
 39 // The classes responsible for code emission and register allocation
 40 
 41 
 42 class LIRGenerator;
 43 class LIREmitter;
 44 class Invoke;
<a name="2" id="anc2"></a>
 45 class LIRItem;
 46 
 47 typedef GrowableArray&lt;LIRItem*&gt; LIRItemList;
 48 
<a name="3" id="anc3"></a><span class="line-modified"> 49 class C1SwitchRange: public CompilationResourceObj {</span>
 50  private:
 51   int _low_key;
 52   int _high_key;
 53   BlockBegin* _sux;
 54  public:
<a name="4" id="anc4"></a><span class="line-modified"> 55   C1SwitchRange(int start_key, BlockBegin* sux): _low_key(start_key), _high_key(start_key), _sux(sux) {}</span>
 56   void set_high_key(int key) { _high_key = key; }
 57 
 58   int high_key() const { return _high_key; }
 59   int low_key() const { return _low_key; }
 60   BlockBegin* sux() const { return _sux; }
 61 };
 62 
<a name="5" id="anc5"></a><span class="line-modified"> 63 typedef GrowableArray&lt;C1SwitchRange*&gt; SwitchRangeArray;</span>
<span class="line-modified"> 64 typedef GrowableArray&lt;C1SwitchRange*&gt; SwitchRangeList;</span>
 65 
 66 class ResolveNode;
 67 
 68 typedef GrowableArray&lt;ResolveNode*&gt; NodeList;
 69 
 70 // Node objects form a directed graph of LIR_Opr
 71 // Edges between Nodes represent moves from one Node to its destinations
 72 class ResolveNode: public CompilationResourceObj {
 73  private:
 74   LIR_Opr    _operand;       // the source or destinaton
 75   NodeList   _destinations;  // for the operand
 76   bool       _assigned;      // Value assigned to this Node?
 77   bool       _visited;       // Node already visited?
 78   bool       _start_node;    // Start node already visited?
 79 
 80  public:
 81   ResolveNode(LIR_Opr operand)
 82     : _operand(operand)
 83     , _assigned(false)
 84     , _visited(false)
 85     , _start_node(false) {};
 86 
 87   // accessors
 88   LIR_Opr operand() const           { return _operand; }
 89   int no_of_destinations() const    { return _destinations.length(); }
 90   ResolveNode* destination_at(int i)     { return _destinations.at(i); }
 91   bool assigned() const             { return _assigned; }
 92   bool visited() const              { return _visited; }
 93   bool start_node() const           { return _start_node; }
 94 
 95   // modifiers
 96   void append(ResolveNode* dest)         { _destinations.append(dest); }
 97   void set_assigned()               { _assigned = true; }
 98   void set_visited()                { _visited = true; }
 99   void set_start_node()             { _start_node = true; }
100 };
101 
102 
103 // This is shared state to be used by the PhiResolver so the operand
104 // arrays don&#39;t have to be reallocated for each resolution.
105 class PhiResolverState: public CompilationResourceObj {
106   friend class PhiResolver;
107 
108  private:
109   NodeList _virtual_operands; // Nodes where the operand is a virtual register
110   NodeList _other_operands;   // Nodes where the operand is not a virtual register
111   NodeList _vreg_table;       // Mapping from virtual register to Node
112 
113  public:
114   PhiResolverState() {}
115 
116   void reset();
117 };
118 
119 
120 // class used to move value of phi operand to phi function
121 class PhiResolver: public CompilationResourceObj {
122  private:
123   LIRGenerator*     _gen;
124   PhiResolverState&amp; _state; // temporary state cached by LIRGenerator
125 
126   ResolveNode*   _loop;
127   LIR_Opr _temp;
128 
129   // access to shared state arrays
130   NodeList&amp; virtual_operands() { return _state._virtual_operands; }
131   NodeList&amp; other_operands()   { return _state._other_operands;   }
132   NodeList&amp; vreg_table()       { return _state._vreg_table;       }
133 
134   ResolveNode* create_node(LIR_Opr opr, bool source);
135   ResolveNode* source_node(LIR_Opr opr)      { return create_node(opr, true); }
136   ResolveNode* destination_node(LIR_Opr opr) { return create_node(opr, false); }
137 
138   void emit_move(LIR_Opr src, LIR_Opr dest);
139   void move_to_temp(LIR_Opr src);
140   void move_temp_to(LIR_Opr dest);
141   void move(ResolveNode* src, ResolveNode* dest);
142 
143   LIRGenerator* gen() {
144     return _gen;
145   }
146 
147  public:
148   PhiResolver(LIRGenerator* _lir_gen);
149   ~PhiResolver();
150 
151   void move(LIR_Opr src, LIR_Opr dest);
152 };
153 
154 
155 // only the classes below belong in the same file
156 class LIRGenerator: public InstructionVisitor, public BlockClosure {
157  // LIRGenerator should never get instatiated on the heap.
158  private:
159   void* operator new(size_t size) throw();
160   void* operator new[](size_t size) throw();
161   void operator delete(void* p) { ShouldNotReachHere(); }
162   void operator delete[](void* p) { ShouldNotReachHere(); }
163 
164   Compilation*  _compilation;
165   ciMethod*     _method;    // method that we are compiling
166   PhiResolverState  _resolver_state;
167   BlockBegin*   _block;
168   int           _virtual_register_number;
169   Values        _instruction_for_operand;
170   BitMap2D      _vreg_flags; // flags which can be set on a per-vreg basis
171   LIR_List*     _lir;
172 
173   LIRGenerator* gen() {
174     return this;
175   }
176 
177   void print_if_not_loaded(const NewInstance* new_instance) PRODUCT_RETURN;
178 
179  public:
180 #ifdef ASSERT
181   LIR_List* lir(const char * file, int line) const {
182     _lir-&gt;set_file_and_line(file, line);
183     return _lir;
184   }
185 #endif
186   LIR_List* lir() const {
187     return _lir;
188   }
189 
190  private:
191   // a simple cache of constants used within a block
192   GrowableArray&lt;LIR_Const*&gt;       _constants;
193   LIR_OprList                     _reg_for_constants;
194   Values                          _unpinned_constants;
195 
196   friend class PhiResolver;
197 
198  public:
199   // unified bailout support
200   void bailout(const char* msg) const            { compilation()-&gt;bailout(msg); }
201   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
202 
203   void block_do_prolog(BlockBegin* block);
204   void block_do_epilog(BlockBegin* block);
205 
206   // register allocation
207   LIR_Opr rlock(Value instr);                      // lock a free register
208   LIR_Opr rlock_result(Value instr);
209   LIR_Opr rlock_result(Value instr, BasicType type);
210   LIR_Opr rlock_byte(BasicType type);
211   LIR_Opr rlock_callee_saved(BasicType type);
212 
213   // get a constant into a register and get track of what register was used
214   LIR_Opr load_constant(Constant* x);
215   LIR_Opr load_constant(LIR_Const* constant);
216 
217   // Given an immediate value, return an operand usable in logical ops.
218   LIR_Opr load_immediate(int x, BasicType type);
219 
220   void  set_result(Value x, LIR_Opr opr)           {
221     assert(opr-&gt;is_valid(), &quot;must set to valid value&quot;);
222     assert(x-&gt;operand()-&gt;is_illegal(), &quot;operand should never change&quot;);
223     assert(!opr-&gt;is_register() || opr-&gt;is_virtual(), &quot;should never set result to a physical register&quot;);
224     x-&gt;set_operand(opr);
225     assert(opr == x-&gt;operand(), &quot;must be&quot;);
226     if (opr-&gt;is_virtual()) {
227       _instruction_for_operand.at_put_grow(opr-&gt;vreg_number(), x, NULL);
228     }
229   }
230   void  set_no_result(Value x)                     { assert(!x-&gt;has_uses(), &quot;can&#39;t have use&quot;); x-&gt;clear_operand(); }
231 
232   friend class LIRItem;
233 
234   LIR_Opr round_item(LIR_Opr opr);
235   LIR_Opr force_to_spill(LIR_Opr value, BasicType t);
236 
237   PhiResolverState&amp; resolver_state() { return _resolver_state; }
238 
239   void  move_to_phi(PhiResolver* resolver, Value cur_val, Value sux_val);
240   void  move_to_phi(ValueStack* cur_state);
241 
242   // platform dependent
243   LIR_Opr getThreadPointer();
244 
245  private:
246   // code emission
247   void do_ArithmeticOp_Long(ArithmeticOp* x);
248   void do_ArithmeticOp_Int (ArithmeticOp* x);
249   void do_ArithmeticOp_FPU (ArithmeticOp* x);
250 
251   void do_RegisterFinalizer(Intrinsic* x);
252   void do_isInstance(Intrinsic* x);
253   void do_isPrimitive(Intrinsic* x);
254   void do_getClass(Intrinsic* x);
255   void do_currentThread(Intrinsic* x);
256   void do_FmaIntrinsic(Intrinsic* x);
257   void do_MathIntrinsic(Intrinsic* x);
258   void do_LibmIntrinsic(Intrinsic* x);
259   void do_ArrayCopy(Intrinsic* x);
260   void do_CompareAndSwap(Intrinsic* x, ValueType* type);
261   void do_NIOCheckIndex(Intrinsic* x);
262   void do_FPIntrinsics(Intrinsic* x);
263   void do_Reference_get(Intrinsic* x);
264   void do_update_CRC32(Intrinsic* x);
265   void do_update_CRC32C(Intrinsic* x);
266   void do_vectorizedMismatch(Intrinsic* x);
267 
268  public:
269   LIR_Opr call_runtime(BasicTypeArray* signature, LIRItemList* args, address entry, ValueType* result_type, CodeEmitInfo* info);
270   LIR_Opr call_runtime(BasicTypeArray* signature, LIR_OprList* args, address entry, ValueType* result_type, CodeEmitInfo* info);
271 
272   // convenience functions
273   LIR_Opr call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info);
274   LIR_Opr call_runtime(Value arg1, Value arg2, address entry, ValueType* result_type, CodeEmitInfo* info);
275 
276   // Access API
277 
278  private:
279   BarrierSetC1 *_barrier_set;
280 
281  public:
282   void access_store_at(DecoratorSet decorators, BasicType type,
283                        LIRItem&amp; base, LIR_Opr offset, LIR_Opr value,
284                        CodeEmitInfo* patch_info = NULL, CodeEmitInfo* store_emit_info = NULL);
285 
286   void access_load_at(DecoratorSet decorators, BasicType type,
287                       LIRItem&amp; base, LIR_Opr offset, LIR_Opr result,
288                       CodeEmitInfo* patch_info = NULL, CodeEmitInfo* load_emit_info = NULL);
289 
290   void access_load(DecoratorSet decorators, BasicType type,
291                    LIR_Opr addr, LIR_Opr result);
292 
293   LIR_Opr access_atomic_cmpxchg_at(DecoratorSet decorators, BasicType type,
294                                    LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
295 
296   LIR_Opr access_atomic_xchg_at(DecoratorSet decorators, BasicType type,
297                                 LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value);
298 
299   LIR_Opr access_atomic_add_at(DecoratorSet decorators, BasicType type,
300                                LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value);
301 
302   LIR_Opr access_resolve(DecoratorSet decorators, LIR_Opr obj);
303 
304   // These need to guarantee JMM volatile semantics are preserved on each platform
305   // and requires one implementation per architecture.
306   LIR_Opr atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
307   LIR_Opr atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; new_value);
308   LIR_Opr atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; new_value);
309 
310 #ifdef CARDTABLEBARRIERSET_POST_BARRIER_HELPER
311   virtual void CardTableBarrierSet_post_barrier_helper(LIR_OprDesc* addr, LIR_Const* card_table_base);
312 #endif
313 
314   // specific implementations
315   void array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci);
316 
317   static LIR_Opr result_register_for(ValueType* type, bool callee = false);
318 
319   ciObject* get_jobject_constant(Value value);
320 
321   LIRItemList* invoke_visit_arguments(Invoke* x);
322   void invoke_load_arguments(Invoke* x, LIRItemList* args, const LIR_OprList* arg_list);
323 
324   void trace_block_entry(BlockBegin* block);
325 
326   // volatile field operations are never patchable because a klass
327   // must be loaded to know it&#39;s volatile which means that the offset
328   // it always known as well.
329   void volatile_field_store(LIR_Opr value, LIR_Address* address, CodeEmitInfo* info);
330   void volatile_field_load(LIR_Address* address, LIR_Opr result, CodeEmitInfo* info);
331 
332   void put_Object_unsafe(LIR_Opr src, LIR_Opr offset, LIR_Opr data, BasicType type, bool is_volatile);
333   void get_Object_unsafe(LIR_Opr dest, LIR_Opr src, LIR_Opr offset, BasicType type, bool is_volatile);
334 
335   void arithmetic_call_op (Bytecodes::Code code, LIR_Opr result, LIR_OprList* args);
336 
337   void increment_counter(address counter, BasicType type, int step = 1);
338   void increment_counter(LIR_Address* addr, int step = 1);
339 
340   // is_strictfp is only needed for mul and div (and only generates different code on i486)
341   void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp, CodeEmitInfo* info = NULL);
342   // machine dependent.  returns true if it emitted code for the multiply
343   bool strength_reduce_multiply(LIR_Opr left, jint constant, LIR_Opr result, LIR_Opr tmp);
344 
345   void store_stack_parameter (LIR_Opr opr, ByteSize offset_from_sp_in_bytes);
346 
347   void klass2reg_with_patching(LIR_Opr r, ciMetadata* obj, CodeEmitInfo* info, bool need_resolve = false);
348 
349   // this loads the length and compares against the index
350   void array_range_check          (LIR_Opr array, LIR_Opr index, CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info);
351   // For java.nio.Buffer.checkIndex
352   void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);
353 
354   void arithmetic_op_int  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp);
355   void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL);
356   void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp = LIR_OprFact::illegalOpr);
357 
358   void shift_op   (Bytecodes::Code code, LIR_Opr dst_reg, LIR_Opr value, LIR_Opr count, LIR_Opr tmp);
359 
360   void logic_op   (Bytecodes::Code code, LIR_Opr dst_reg, LIR_Opr left, LIR_Opr right);
361 
362   void monitor_enter (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info);
363   void monitor_exit  (LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no);
364 
365   void new_instance    (LIR_Opr  dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr  scratch1, LIR_Opr  scratch2, LIR_Opr  scratch3,  LIR_Opr scratch4, LIR_Opr  klass_reg, CodeEmitInfo* info);
366 
367   // machine dependent
368   void cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info);
369   void cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info);
370 
371   void arraycopy_helper(Intrinsic* x, int* flags, ciArrayKlass** expected_type);
372 
373   // returns a LIR_Address to address an array location.  May also
374   // emit some code as part of address calculation.  If
375   // needs_card_mark is true then compute the full address for use by
376   // both the store and the card mark.
377   LIR_Address* generate_address(LIR_Opr base,
378                                 LIR_Opr index, int shift,
379                                 int disp,
380                                 BasicType type);
381   LIR_Address* generate_address(LIR_Opr base, int disp, BasicType type) {
382     return generate_address(base, LIR_OprFact::illegalOpr, 0, disp, type);
383   }
384   LIR_Address* emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr, BasicType type);
385 
386   // the helper for generate_address
387   void add_large_constant(LIR_Opr src, int c, LIR_Opr dest);
388 
389   // machine preferences and characteristics
390   bool can_inline_as_constant(Value i S390_ONLY(COMMA int bits = 20)) const;
391   bool can_inline_as_constant(LIR_Const* c) const;
392   bool can_store_as_constant(Value i, BasicType type) const;
393 
394   LIR_Opr safepoint_poll_register();
395 
396   void profile_branch(If* if_instr, If::Condition cond);
397   void increment_event_counter_impl(CodeEmitInfo* info,
398                                     ciMethod *method, LIR_Opr step, int frequency,
399                                     int bci, bool backedge, bool notify);
400   void increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge);
401   void increment_invocation_counter(CodeEmitInfo *info) {
402     if (compilation()-&gt;count_invocations()) {
403       increment_event_counter(info, LIR_OprFact::intConst(InvocationCounter::count_increment), InvocationEntryBci, false);
404     }
405   }
406   void increment_backedge_counter(CodeEmitInfo* info, int bci) {
407     if (compilation()-&gt;count_backedges()) {
408       increment_event_counter(info, LIR_OprFact::intConst(InvocationCounter::count_increment), bci, true);
409     }
410   }
411   void increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci);
412   void increment_backedge_counter(CodeEmitInfo* info, LIR_Opr step, int bci) {
413     if (compilation()-&gt;count_backedges()) {
414       increment_event_counter(info, step, bci, true);
415     }
416   }
417   void decrement_age(CodeEmitInfo* info);
418   CodeEmitInfo* state_for(Instruction* x, ValueStack* state, bool ignore_xhandler = false);
419   CodeEmitInfo* state_for(Instruction* x);
420 
421   // allocates a virtual register for this instruction if
422   // one isn&#39;t already allocated.  Only for Phi and Local.
423   LIR_Opr operand_for_instruction(Instruction *x);
424 
425   void set_block(BlockBegin* block)              { _block = block; }
426 
427   void block_prolog(BlockBegin* block);
428   void block_epilog(BlockBegin* block);
429 
430   void do_root (Instruction* instr);
431   void walk    (Instruction* instr);
432 
433   void bind_block_entry(BlockBegin* block);
434   void start_block(BlockBegin* block);
435 
436   LIR_Opr new_register(BasicType type);
437   LIR_Opr new_register(Value value)              { return new_register(as_BasicType(value-&gt;type())); }
438   LIR_Opr new_register(ValueType* type)          { return new_register(as_BasicType(type)); }
439 
440   // returns a register suitable for doing pointer math
441   LIR_Opr new_pointer_register() {
442 #ifdef _LP64
443     return new_register(T_LONG);
444 #else
445     return new_register(T_INT);
446 #endif
447   }
448 
449   static LIR_Condition lir_cond(If::Condition cond) {
450     LIR_Condition l = lir_cond_unknown;
451     switch (cond) {
452     case If::eql: l = lir_cond_equal;        break;
453     case If::neq: l = lir_cond_notEqual;     break;
454     case If::lss: l = lir_cond_less;         break;
455     case If::leq: l = lir_cond_lessEqual;    break;
456     case If::geq: l = lir_cond_greaterEqual; break;
457     case If::gtr: l = lir_cond_greater;      break;
458     case If::aeq: l = lir_cond_aboveEqual;   break;
459     case If::beq: l = lir_cond_belowEqual;   break;
460     default: fatal(&quot;You must pass valid If::Condition&quot;);
461     };
462     return l;
463   }
464 
465 #ifdef __SOFTFP__
466   void do_soft_float_compare(If *x);
467 #endif // __SOFTFP__
468 
469   SwitchRangeArray* create_lookup_ranges(TableSwitch* x);
470   SwitchRangeArray* create_lookup_ranges(LookupSwitch* x);
471   void do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux);
472 
473 #ifdef JFR_HAVE_INTRINSICS
474   void do_ClassIDIntrinsic(Intrinsic* x);
475   void do_getEventWriter(Intrinsic* x);
476 #endif
477 
478   void do_RuntimeCall(address routine, Intrinsic* x);
479 
480   ciKlass* profile_type(ciMethodData* md, int md_first_offset, int md_offset, intptr_t profiled_k,
481                         Value arg, LIR_Opr&amp; mdp, bool not_null, ciKlass* signature_at_call_k,
482                         ciKlass* callee_signature_k);
483   void profile_arguments(ProfileCall* x);
484   void profile_parameters(Base* x);
485   void profile_parameters_at_call(ProfileCall* x);
486   LIR_Opr mask_boolean(LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info);
487   LIR_Opr maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info);
488 
489  public:
490   Compilation*  compilation() const              { return _compilation; }
491   FrameMap*     frame_map() const                { return _compilation-&gt;frame_map(); }
492   ciMethod*     method() const                   { return _method; }
493   BlockBegin*   block() const                    { return _block; }
494   IRScope*      scope() const                    { return block()-&gt;scope(); }
495 
496   int max_virtual_register_number() const        { return _virtual_register_number; }
497 
498   void block_do(BlockBegin* block);
499 
500   // Flags that can be set on vregs
501   enum VregFlag {
502       must_start_in_memory = 0  // needs to be assigned a memory location at beginning, but may then be loaded in a register
503     , callee_saved     = 1    // must be in a callee saved register
504     , byte_reg         = 2    // must be in a byte register
505     , num_vreg_flags
506 
507   };
508 
509   LIRGenerator(Compilation* compilation, ciMethod* method)
510     : _compilation(compilation)
511     , _method(method)
512     , _virtual_register_number(LIR_OprDesc::vreg_base)
513     , _vreg_flags(num_vreg_flags)
514     , _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c1()) {
515   }
516 
517   // for virtual registers, maps them back to Phi&#39;s or Local&#39;s
518   Instruction* instruction_for_opr(LIR_Opr opr);
519   Instruction* instruction_for_vreg(int reg_num);
520 
521   void set_vreg_flag   (int vreg_num, VregFlag f);
522   bool is_vreg_flag_set(int vreg_num, VregFlag f);
523   void set_vreg_flag   (LIR_Opr opr,  VregFlag f) { set_vreg_flag(opr-&gt;vreg_number(), f); }
524   bool is_vreg_flag_set(LIR_Opr opr,  VregFlag f) { return is_vreg_flag_set(opr-&gt;vreg_number(), f); }
525 
526   // statics
527   static LIR_Opr exceptionOopOpr();
528   static LIR_Opr exceptionPcOpr();
529   static LIR_Opr divInOpr();
530   static LIR_Opr divOutOpr();
531   static LIR_Opr remOutOpr();
532 #ifdef S390
533   // On S390 we can do ldiv, lrem without RT call.
534   static LIR_Opr ldivInOpr();
535   static LIR_Opr ldivOutOpr();
536   static LIR_Opr lremOutOpr();
537 #endif
538   static LIR_Opr shiftCountOpr();
539   LIR_Opr syncLockOpr();
540   LIR_Opr syncTempOpr();
541   LIR_Opr atomicLockOpr();
542 
543   // returns a register suitable for saving the thread in a
544   // call_runtime_leaf if one is needed.
545   LIR_Opr getThreadTemp();
546 
547   // visitor functionality
548   virtual void do_Phi            (Phi*             x);
549   virtual void do_Local          (Local*           x);
550   virtual void do_Constant       (Constant*        x);
551   virtual void do_LoadField      (LoadField*       x);
552   virtual void do_StoreField     (StoreField*      x);
553   virtual void do_ArrayLength    (ArrayLength*     x);
554   virtual void do_LoadIndexed    (LoadIndexed*     x);
555   virtual void do_StoreIndexed   (StoreIndexed*    x);
556   virtual void do_NegateOp       (NegateOp*        x);
557   virtual void do_ArithmeticOp   (ArithmeticOp*    x);
558   virtual void do_ShiftOp        (ShiftOp*         x);
559   virtual void do_LogicOp        (LogicOp*         x);
560   virtual void do_CompareOp      (CompareOp*       x);
561   virtual void do_IfOp           (IfOp*            x);
562   virtual void do_Convert        (Convert*         x);
563   virtual void do_NullCheck      (NullCheck*       x);
564   virtual void do_TypeCast       (TypeCast*        x);
565   virtual void do_Invoke         (Invoke*          x);
566   virtual void do_NewInstance    (NewInstance*     x);
567   virtual void do_NewTypeArray   (NewTypeArray*    x);
568   virtual void do_NewObjectArray (NewObjectArray*  x);
569   virtual void do_NewMultiArray  (NewMultiArray*   x);
570   virtual void do_CheckCast      (CheckCast*       x);
571   virtual void do_InstanceOf     (InstanceOf*      x);
572   virtual void do_MonitorEnter   (MonitorEnter*    x);
573   virtual void do_MonitorExit    (MonitorExit*     x);
574   virtual void do_Intrinsic      (Intrinsic*       x);
575   virtual void do_BlockBegin     (BlockBegin*      x);
576   virtual void do_Goto           (Goto*            x);
577   virtual void do_If             (If*              x);
578   virtual void do_IfInstanceOf   (IfInstanceOf*    x);
579   virtual void do_TableSwitch    (TableSwitch*     x);
580   virtual void do_LookupSwitch   (LookupSwitch*    x);
581   virtual void do_Return         (Return*          x);
582   virtual void do_Throw          (Throw*           x);
583   virtual void do_Base           (Base*            x);
584   virtual void do_OsrEntry       (OsrEntry*        x);
585   virtual void do_ExceptionObject(ExceptionObject* x);
586   virtual void do_RoundFP        (RoundFP*         x);
587   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);
588   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);
589   virtual void do_UnsafeGetObject(UnsafeGetObject* x);
590   virtual void do_UnsafePutObject(UnsafePutObject* x);
591   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);
592   virtual void do_ProfileCall    (ProfileCall*     x);
593   virtual void do_ProfileReturnType (ProfileReturnType* x);
594   virtual void do_ProfileInvoke  (ProfileInvoke*   x);
595   virtual void do_RuntimeCall    (RuntimeCall*     x);
596   virtual void do_MemBar         (MemBar*          x);
597   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x);
598 #ifdef ASSERT
599   virtual void do_Assert         (Assert*          x);
600 #endif
601 
602 #ifdef C1_LIRGENERATOR_MD_HPP
603 #include C1_LIRGENERATOR_MD_HPP
604 #endif
605 };
606 
607 
608 class LIRItem: public CompilationResourceObj {
609  private:
610   Value         _value;
611   LIRGenerator* _gen;
612   LIR_Opr       _result;
613   bool          _destroys_register;
614   LIR_Opr       _new_result;
615 
616   LIRGenerator* gen() const { return _gen; }
617 
618  public:
619   LIRItem(Value value, LIRGenerator* gen) {
620     _destroys_register = false;
621     _gen = gen;
622     set_instruction(value);
623   }
624 
625   LIRItem(LIRGenerator* gen) {
626     _destroys_register = false;
627     _gen = gen;
628     _result = LIR_OprFact::illegalOpr;
629     set_instruction(NULL);
630   }
631 
632   void set_instruction(Value value) {
633     _value = value;
634     _result = LIR_OprFact::illegalOpr;
635     if (_value != NULL) {
636       _gen-&gt;walk(_value);
637       _result = _value-&gt;operand();
638     }
639     _new_result = LIR_OprFact::illegalOpr;
640   }
641 
642   Value value() const          { return _value;          }
643   ValueType* type() const      { return value()-&gt;type(); }
644   LIR_Opr result()             {
645     assert(!_destroys_register || (!_result-&gt;is_register() || _result-&gt;is_virtual()),
646            &quot;shouldn&#39;t use set_destroys_register with physical regsiters&quot;);
647     if (_destroys_register &amp;&amp; _result-&gt;is_register()) {
648       if (_new_result-&gt;is_illegal()) {
649         _new_result = _gen-&gt;new_register(type());
650         gen()-&gt;lir()-&gt;move(_result, _new_result);
651       }
652       return _new_result;
653     } else {
654       return _result;
655     }
656     return _result;
657   }
658 
659   void set_result(LIR_Opr opr);
660 
661   void load_item();
662   void load_byte_item();
663   void load_nonconstant(S390_ONLY(int bits = 20));
664   // load any values which can&#39;t be expressed as part of a single store instruction
665   void load_for_store(BasicType store_type);
666   void load_item_force(LIR_Opr reg);
667 
668   void dont_load_item() {
669     // do nothing
670   }
671 
672   void set_destroys_register() {
673     _destroys_register = true;
674   }
675 
676   bool is_constant() const { return value()-&gt;as_Constant() != NULL; }
677   bool is_stack()          { return result()-&gt;is_stack(); }
678   bool is_register()       { return result()-&gt;is_register(); }
679 
680   ciObject* get_jobject_constant() const;
681   jint      get_jint_constant() const;
682   jlong     get_jlong_constant() const;
683   jfloat    get_jfloat_constant() const;
684   jdouble   get_jdouble_constant() const;
685   jint      get_address_constant() const;
686 };
687 
688 #endif // SHARE_C1_C1_LIRGENERATOR_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_ValueStack.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_IR.hpp&quot;
 27 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 28 #include &quot;c1/c1_ValueStack.hpp&quot;
 29 
 30 
 31 // Implementation of ValueStack
 32 
 33 ValueStack::ValueStack(IRScope* scope, ValueStack* caller_state)
 34 : _scope(scope)
 35 , _caller_state(caller_state)
 36 , _bci(-99)
 37 , _kind(Parsing)
 38 , _locals(scope-&gt;method()-&gt;max_locals(), scope-&gt;method()-&gt;max_locals(), NULL)
 39 , _stack(scope-&gt;method()-&gt;max_stack())
 40 , _locks(NULL)
 41 {
 42   verify();
 43 }
 44 
 45 ValueStack::ValueStack(ValueStack* copy_from, Kind kind, int bci)
 46   : _scope(copy_from-&gt;scope())
 47   , _caller_state(copy_from-&gt;caller_state())
 48   , _bci(bci)
 49   , _kind(kind)
 50   , _locals(copy_from-&gt;locals_size_for_copy(kind))
 51   , _stack(copy_from-&gt;stack_size_for_copy(kind))
 52   , _locks(copy_from-&gt;locks_size() == 0 ? NULL : new Values(copy_from-&gt;locks_size()))
 53 {
 54   assert(kind != EmptyExceptionState || !Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;need locals&quot;);
 55   if (kind != EmptyExceptionState) {
 56     _locals.appendAll(&amp;copy_from-&gt;_locals);
 57   }
 58 
 59   if (kind != ExceptionState &amp;&amp; kind != EmptyExceptionState) {
 60     _stack.appendAll(&amp;copy_from-&gt;_stack);
 61   }
 62 
 63   if (copy_from-&gt;locks_size() &gt; 0) {
 64     _locks-&gt;appendAll(copy_from-&gt;_locks);
 65   }
 66 
 67   verify();
 68 }
 69 
 70 int ValueStack::locals_size_for_copy(Kind kind) const {
 71   if (kind != EmptyExceptionState) {
 72     return locals_size();
 73   }
 74   return 0;
 75 }
 76 
 77 int ValueStack::stack_size_for_copy(Kind kind) const {
 78   if (kind != ExceptionState &amp;&amp; kind != EmptyExceptionState) {
 79     if (kind == Parsing) {
 80       // stack will be modified, so reserve enough space to avoid resizing
 81       return scope()-&gt;method()-&gt;max_stack();
 82     } else {
 83       // stack will not be modified, so do not waste space
 84       return stack_size();
 85     }
 86   }
 87   return 0;
 88 }
 89 
 90 bool ValueStack::is_same(ValueStack* s) {
 91   if (scope() != s-&gt;scope()) return false;
 92   if (caller_state() != s-&gt;caller_state()) return false;
 93 
 94   if (locals_size() != s-&gt;locals_size()) return false;
 95   if (stack_size() != s-&gt;stack_size()) return false;
 96   if (locks_size() != s-&gt;locks_size()) return false;
 97 
 98   // compare each stack element with the corresponding stack element of s
 99   int index;
100   Value value;
101   for_each_stack_value(this, index, value) {
102     if (value-&gt;type()-&gt;tag() != s-&gt;stack_at(index)-&gt;type()-&gt;tag()) return false;
103   }
104   for (int i = 0; i &lt; locks_size(); i++) {
105     value = lock_at(i);
106     if (value != NULL &amp;&amp; value != s-&gt;lock_at(i)) {
107       return false;
108     }
109   }
110   return true;
111 }
112 
113 void ValueStack::clear_locals() {
114   for (int i = _locals.length() - 1; i &gt;= 0; i--) {
115     _locals.at_put(i, NULL);
116   }
117 }
118 
119 
120 void ValueStack::pin_stack_for_linear_scan() {
121   for_each_state_value(this, v,
122     if (v-&gt;as_Constant() == NULL &amp;&amp; v-&gt;as_Local() == NULL) {
123       v-&gt;pin(Instruction::PinStackForStateSplit);
124     }
125   );
126 }
127 
128 
129 // apply function to all values of a list; factored out from values_do(f)
130 void ValueStack::apply(const Values&amp; list, ValueVisitor* f) {
131   for (int i = 0; i &lt; list.length(); i++) {
132     Value* va = list.adr_at(i);
133     Value v0 = *va;
134     if (v0 != NULL &amp;&amp; !v0-&gt;type()-&gt;is_illegal()) {
135       f-&gt;visit(va);
136 #ifdef ASSERT
137       Value v1 = *va;
138       assert(v1-&gt;type()-&gt;is_illegal() || v0-&gt;type()-&gt;tag() == v1-&gt;type()-&gt;tag(), &quot;types must match&quot;);
139       assert(!v1-&gt;type()-&gt;is_double_word() || list.at(i + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
140 #endif
141       if (v0-&gt;type()-&gt;is_double_word()) i++;
142     }
143   }
144 }
145 
146 
147 void ValueStack::values_do(ValueVisitor* f) {
148   ValueStack* state = this;
149   for_each_state(state) {
150     apply(state-&gt;_locals, f);
151     apply(state-&gt;_stack, f);
152     if (state-&gt;_locks != NULL) {
153       apply(*state-&gt;_locks, f);
154     }
155   }
156 }
157 
158 
159 Values* ValueStack::pop_arguments(int argument_size) {
160   assert(stack_size() &gt;= argument_size, &quot;stack too small or too many arguments&quot;);
161   int base = stack_size() - argument_size;
162   Values* args = new Values(argument_size);
163   for (int i = base; i &lt; stack_size();) args-&gt;push(stack_at_inc(i));
164   truncate_stack(base);
165   return args;
166 }
167 
168 
169 int ValueStack::total_locks_size() const {
170   int num_locks = 0;
171   const ValueStack* state = this;
172   for_each_state(state) {
173     num_locks += state-&gt;locks_size();
174   }
175   return num_locks;
176 }
177 
178 int ValueStack::lock(Value obj) {
179   if (_locks == NULL) {
180     _locks = new Values();
181   }
182   _locks-&gt;push(obj);
183   int num_locks = total_locks_size();
184   scope()-&gt;set_min_number_of_locks(num_locks);
185   return num_locks - 1;
186 }
187 
188 
189 int ValueStack::unlock() {
190   assert(locks_size() &gt; 0, &quot;sanity&quot;);
191   _locks-&gt;pop();
192   return total_locks_size();
193 }
194 
195 
196 void ValueStack::setup_phi_for_stack(BlockBegin* b, int index) {
197   assert(stack_at(index)-&gt;as_Phi() == NULL || stack_at(index)-&gt;as_Phi()-&gt;block() != b, &quot;phi function already created&quot;);
198 
199   ValueType* t = stack_at(index)-&gt;type();
200   Value phi = new Phi(t, b, -index - 1);
201   _stack.at_put(index, phi);
202 
203   assert(!t-&gt;is_double_word() || _stack.at(index + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
204 }
205 
206 void ValueStack::setup_phi_for_local(BlockBegin* b, int index) {
207   assert(local_at(index)-&gt;as_Phi() == NULL || local_at(index)-&gt;as_Phi()-&gt;block() != b, &quot;phi function already created&quot;);
208 
209   ValueType* t = local_at(index)-&gt;type();
210   Value phi = new Phi(t, b, index);
211   store_local(index, phi);
212 }
213 
214 #ifndef PRODUCT
215 
216 void ValueStack::print() {
217   scope()-&gt;method()-&gt;print_name();
218   tty-&gt;cr();
219   if (stack_is_empty()) {
220     tty-&gt;print_cr(&quot;empty stack&quot;);
221   } else {
222     InstructionPrinter ip;
223     for (int i = 0; i &lt; stack_size();) {
224       Value t = stack_at_inc(i);
225       tty-&gt;print(&quot;%2d  &quot;, i);
226       tty-&gt;print(&quot;%c%d &quot;, t-&gt;type()-&gt;tchar(), t-&gt;id());
227       ip.print_instr(t);
228       tty-&gt;cr();
229     }
230   }
231   if (!no_active_locks()) {
232     InstructionPrinter ip;
233     for (int i = 0; i &lt; locks_size(); i++) {
234       Value t = lock_at(i);
235       tty-&gt;print(&quot;lock %2d  &quot;, i);
236       if (t == NULL) {
237         tty-&gt;print(&quot;this&quot;);
238       } else {
239         tty-&gt;print(&quot;%c%d &quot;, t-&gt;type()-&gt;tchar(), t-&gt;id());
240         ip.print_instr(t);
241       }
242       tty-&gt;cr();
243     }
244   }
245   if (locals_size() &gt; 0) {
246     InstructionPrinter ip;
247     for (int i = 0; i &lt; locals_size();) {
248       Value l = _locals.at(i);
249       tty-&gt;print(&quot;local %d &quot;, i);
250       if (l == NULL) {
251         tty-&gt;print(&quot;null&quot;);
252         i ++;
253       } else {
254         tty-&gt;print(&quot;%c%d &quot;, l-&gt;type()-&gt;tchar(), l-&gt;id());
255         ip.print_instr(l);
256         if (l-&gt;type()-&gt;is_illegal() || l-&gt;type()-&gt;is_single_word()) i ++; else i += 2;
257       }
258       tty-&gt;cr();
259     }
260   }
261 
262   if (caller_state() != NULL) {
263     caller_state()-&gt;print();
264   }
265 }
266 
267 
268 void ValueStack::verify() {
269   assert(scope() != NULL, &quot;scope must exist&quot;);
270   if (caller_state() != NULL) {
271     assert(caller_state()-&gt;scope() == scope()-&gt;caller(), &quot;invalid caller scope&quot;);
272     caller_state()-&gt;verify();
273   }
274 
275   if (kind() == Parsing) {
276     assert(bci() == -99, &quot;bci not defined during parsing&quot;);
277   } else {
278     assert(bci() &gt;= -1, &quot;bci out of range&quot;);
279     assert(bci() &lt; scope()-&gt;method()-&gt;code_size(), &quot;bci out of range&quot;);
280     assert(bci() == SynchronizationEntryBCI || Bytecodes::is_defined(scope()-&gt;method()-&gt;java_code_at_bci(bci())), &quot;make sure bci points at a real bytecode&quot;);
281     assert(scope()-&gt;method()-&gt;liveness_at_bci(bci()).is_valid(), &quot;liveness at bci must be valid&quot;);
282   }
283 
284   int i;
285   for (i = 0; i &lt; stack_size(); i++) {
286     Value v = _stack.at(i);
287     if (v == NULL) {
288       assert(_stack.at(i - 1)-&gt;type()-&gt;is_double_word(), &quot;only hi-words are NULL on stack&quot;);
289     } else if (v-&gt;type()-&gt;is_double_word()) {
290       assert(_stack.at(i + 1) == NULL, &quot;hi-word must be NULL&quot;);
291     }
292   }
293 
294   for (i = 0; i &lt; locals_size(); i++) {
295     Value v = _locals.at(i);
296     if (v != NULL &amp;&amp; v-&gt;type()-&gt;is_double_word()) {
297       assert(_locals.at(i + 1) == NULL, &quot;hi-word must be NULL&quot;);
298     }
299   }
300 
301   for_each_state_value(this, v,
302     assert(v != NULL, &quot;just test if state-iteration succeeds&quot;);
303   );
304 }
305 #endif // PRODUCT
    </pre>
  </body>
</html>
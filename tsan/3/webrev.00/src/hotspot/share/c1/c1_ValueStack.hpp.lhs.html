<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_ValueStack.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_VALUESTACK_HPP
 26 #define SHARE_C1_C1_VALUESTACK_HPP
 27 
 28 #include &quot;c1/c1_Instruction.hpp&quot;
 29 
 30 class ValueStack: public CompilationResourceObj {
 31  public:
 32   enum Kind {
 33     Parsing,             // During abstract interpretation in GraphBuilder
 34     CallerState,         // Caller state when inlining
 35     StateBefore,         // Before before execution of instruction
 36     StateAfter,          // After execution of instruction
 37     ExceptionState,      // Exception handling of instruction
 38     EmptyExceptionState, // Exception handling of instructions not covered by an xhandler
 39     BlockBeginState      // State of BlockBegin instruction with phi functions of this block
 40   };
 41 
 42  private:
 43   IRScope* _scope;                               // the enclosing scope
 44   ValueStack* _caller_state;
 45   int      _bci;
 46   Kind     _kind;
 47 
 48   Values   _locals;                              // the locals
 49   Values   _stack;                               // the expression stack
 50   Values*  _locks;                               // the monitor stack (holding the locked values)
 51 
 52   Value check(ValueTag tag, Value t) {
 53     assert(tag == t-&gt;type()-&gt;tag() || tag == objectTag &amp;&amp; t-&gt;type()-&gt;tag() == addressTag, &quot;types must correspond&quot;);
 54     return t;
 55   }
 56 
 57   Value check(ValueTag tag, Value t, Value h) {
 58     assert(h == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
 59     return check(tag, t);
 60   }
 61 
 62   // helper routine
 63   static void apply(const Values&amp; list, ValueVisitor* f);
 64 
 65   // for simplified copying
 66   ValueStack(ValueStack* copy_from, Kind kind, int bci);
 67 
<a name="1" id="anc1"></a>

 68  public:
 69   // creation
 70   ValueStack(IRScope* scope, ValueStack* caller_state);
 71 
 72   ValueStack* copy()                             { return new ValueStack(this, _kind, _bci); }
 73   ValueStack* copy(Kind new_kind, int new_bci)   { return new ValueStack(this, new_kind, new_bci); }
 74   ValueStack* copy_for_parsing()                 { return new ValueStack(this, Parsing, -99); }
 75 
 76   void set_caller_state(ValueStack* s)           {
 77     assert(kind() == EmptyExceptionState ||
 78            (Compilation::current()-&gt;env()-&gt;should_retain_local_variables() &amp;&amp; kind() == ExceptionState),
 79            &quot;only EmptyExceptionStates can be modified&quot;);
 80     _caller_state = s;
 81   }
 82 
 83   bool is_same(ValueStack* s);                   // returns true if this &amp; s&#39;s types match (w/o checking locals)
 84 
 85   // accessors
 86   IRScope* scope() const                         { return _scope; }
 87   ValueStack* caller_state() const               { return _caller_state; }
 88   int bci() const                                { return _bci; }
 89   Kind kind() const                              { return _kind; }
 90 
 91   int locals_size() const                        { return _locals.length(); }
 92   int stack_size() const                         { return _stack.length(); }
 93   int locks_size() const                         { return _locks == NULL ? 0 : _locks-&gt;length(); }
 94   bool stack_is_empty() const                    { return _stack.is_empty(); }
 95   bool no_active_locks() const                   { return _locks == NULL || _locks-&gt;is_empty(); }
 96   int total_locks_size() const;
 97 
 98   // locals access
 99   void clear_locals();                           // sets all locals to NULL;
100 
101   void invalidate_local(int i) {
102     assert(!_locals.at(i)-&gt;type()-&gt;is_double_word() ||
103            _locals.at(i + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
104     _locals.at_put(i, NULL);
105   }
106 
107   Value local_at(int i) const {
108     Value x = _locals.at(i);
109     assert(x == NULL || !x-&gt;type()-&gt;is_double_word() ||
110            _locals.at(i + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
111     return x;
112   }
113 
114   void store_local(int i, Value x) {
115     // When overwriting local i, check if i - 1 was the start of a
116     // double word local and kill it.
117     if (i &gt; 0) {
118       Value prev = _locals.at(i - 1);
119       if (prev != NULL &amp;&amp; prev-&gt;type()-&gt;is_double_word()) {
120         _locals.at_put(i - 1, NULL);
121       }
122     }
123 
124     _locals.at_put(i, x);
125     if (x-&gt;type()-&gt;is_double_word()) {
126       // hi-word of doubleword value is always NULL
127       _locals.at_put(i + 1, NULL);
128     }
129   }
130 
131   // stack access
132   Value stack_at(int i) const {
133     Value x = _stack.at(i);
134     assert(!x-&gt;type()-&gt;is_double_word() ||
135            _stack.at(i + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
136     return x;
137   }
138 
139   Value stack_at_inc(int&amp; i) const {
140     Value x = stack_at(i);
141     i += x-&gt;type()-&gt;size();
142     return x;
143   }
144 
145   void stack_at_put(int i, Value x) {
146     _stack.at_put(i, x);
147   }
148 
149   // pinning support
150   void pin_stack_for_linear_scan();
151 
152   // iteration
153   void values_do(ValueVisitor* f);
154 
155   // untyped manipulation (for dup_x1, etc.)
156   void truncate_stack(int size)                  { _stack.trunc_to(size); }
157   void raw_push(Value t)                         { _stack.push(t); }
158   Value raw_pop()                                { return _stack.pop(); }
159 
160   // typed manipulation
161   void ipush(Value t)                            { _stack.push(check(intTag    , t)); }
162   void fpush(Value t)                            { _stack.push(check(floatTag  , t)); }
163   void apush(Value t)                            { _stack.push(check(objectTag , t)); }
164   void rpush(Value t)                            { _stack.push(check(addressTag, t)); }
165   void lpush(Value t)                            { _stack.push(check(longTag   , t)); _stack.push(NULL); }
166   void dpush(Value t)                            { _stack.push(check(doubleTag , t)); _stack.push(NULL); }
167 
168   void push(ValueType* type, Value t) {
169     switch (type-&gt;tag()) {
170       case intTag    : ipush(t); return;
171       case longTag   : lpush(t); return;
172       case floatTag  : fpush(t); return;
173       case doubleTag : dpush(t); return;
174       case objectTag : apush(t); return;
175       case addressTag: rpush(t); return;
176       default        : ShouldNotReachHere(); return;
177     }
178   }
179 
180   Value ipop()                                   { return check(intTag    , _stack.pop()); }
181   Value fpop()                                   { return check(floatTag  , _stack.pop()); }
182   Value apop()                                   { return check(objectTag , _stack.pop()); }
183   Value rpop()                                   { return check(addressTag, _stack.pop()); }
184   Value lpop()                                   { Value h = _stack.pop(); return check(longTag  , _stack.pop(), h); }
185   Value dpop()                                   { Value h = _stack.pop(); return check(doubleTag, _stack.pop(), h); }
186 
187   Value pop(ValueType* type) {
188     switch (type-&gt;tag()) {
189       case intTag    : return ipop();
190       case longTag   : return lpop();
191       case floatTag  : return fpop();
192       case doubleTag : return dpop();
193       case objectTag : return apop();
194       case addressTag: return rpop();
195       default        : ShouldNotReachHere(); return NULL;
196     }
197   }
198 
199   Values* pop_arguments(int argument_size);
200 
201   // locks access
202   int lock  (Value obj);
203   int unlock();
204   Value lock_at(int i) const                     { return _locks-&gt;at(i); }
205 
206   // SSA form IR support
207   void setup_phi_for_stack(BlockBegin* b, int index);
208   void setup_phi_for_local(BlockBegin* b, int index);
209 
210   // debugging
211   void print()  PRODUCT_RETURN;
212   void verify() PRODUCT_RETURN;
213 };
214 
215 
216 
217 // Macro definitions for simple iteration of stack and local values of a ValueStack
218 // The macros can be used like a for-loop. All variables (state, index and value)
219 // must be defined before the loop.
220 // When states are nested because of inlining, the stack of the innermost state
221 // cumulates also the stack of the nested states. In contrast, the locals of all
222 // states must be iterated each.
223 // Use the following code pattern to iterate all stack values and all nested local values:
224 //
225 // ValueStack* state = ...   // state that is iterated
226 // int index;                // current loop index (overwritten in loop)
227 // Value value;              // value at current loop index (overwritten in loop)
228 //
229 // for_each_stack_value(state, index, value {
230 //   do something with value and index
231 // }
232 //
233 // for_each_state(state) {
234 //   for_each_local_value(state, index, value) {
235 //     do something with value and index
236 //   }
237 // }
238 // as an invariant, state is NULL now
239 
240 
241 // construct a unique variable name with the line number where the macro is used
242 #define temp_var3(x) temp__ ## x
243 #define temp_var2(x) temp_var3(x)
244 #define temp_var     temp_var2(__LINE__)
245 
246 #define for_each_state(state)  \
247   for (; state != NULL; state = state-&gt;caller_state())
248 
249 #define for_each_local_value(state, index, value)                                              \
250   int temp_var = state-&gt;locals_size();                                                         \
251   for (index = 0;                                                                              \
252        index &lt; temp_var &amp;&amp; (value = state-&gt;local_at(index), true);                             \
253        index += (value == NULL || value-&gt;type()-&gt;is_illegal() ? 1 : value-&gt;type()-&gt;size()))    \
254     if (value != NULL)
255 
256 
257 #define for_each_stack_value(state, index, value)                                              \
258   int temp_var = state-&gt;stack_size();                                                          \
259   for (index = 0;                                                                              \
260        index &lt; temp_var &amp;&amp; (value = state-&gt;stack_at(index), true);                             \
261        index += value-&gt;type()-&gt;size())
262 
263 
264 #define for_each_lock_value(state, index, value)                                               \
265   int temp_var = state-&gt;locks_size();                                                          \
266   for (index = 0;                                                                              \
267        index &lt; temp_var &amp;&amp; (value = state-&gt;lock_at(index), true);                              \
268        index++)                                                                                \
269     if (value != NULL)
270 
271 
272 // Macro definition for simple iteration of all state values of a ValueStack
273 // Because the code cannot be executed in a single loop, the code must be passed
274 // as a macro parameter.
275 // Use the following code pattern to iterate all stack values and all nested local values:
276 //
277 // ValueStack* state = ...   // state that is iterated
278 // for_each_state_value(state, value,
279 //   do something with value (note that this is a macro parameter)
280 // );
281 
282 #define for_each_state_value(v_state, v_value, v_code)                                         \
283 {                                                                                              \
284   int cur_index;                                                                               \
285   ValueStack* cur_state = v_state;                                                             \
286   Value v_value;                                                                               \
287   for_each_state(cur_state) {                                                                  \
288     {                                                                                            \
289       for_each_local_value(cur_state, cur_index, v_value) {                                      \
290         v_code;                                                                                  \
291       }                                                                                          \
292     }                                                                                          \
293     {                                                                                            \
294       for_each_stack_value(cur_state, cur_index, v_value) {                                      \
295         v_code;                                                                                  \
296       }                                                                                          \
297     }                                                                                            \
298   }                                                                                            \
299 }
300 
301 
302 // Macro definition for simple iteration of all phi functions of a block, i.e all
303 // phi functions of the ValueStack where the block matches.
304 // Use the following code pattern to iterate all phi functions of a block:
305 //
306 // BlockBegin* block = ...   // block that is iterated
307 // for_each_phi_function(block, phi,
308 //   do something with the phi function phi (note that this is a macro parameter)
309 // );
310 
311 #define for_each_phi_fun(v_block, v_phi, v_code)                                               \
312 {                                                                                              \
313   int cur_index;                                                                               \
314   ValueStack* cur_state = v_block-&gt;state();                                                    \
315   Value value;                                                                                 \
316   {                                                                                            \
317     for_each_stack_value(cur_state, cur_index, value) {                                        \
318       Phi* v_phi = value-&gt;as_Phi();                                                            \
319       if (v_phi != NULL &amp;&amp; v_phi-&gt;block() == v_block) {                                        \
320         v_code;                                                                                \
321       }                                                                                        \
322     }                                                                                          \
323   }                                                                                            \
324   {                                                                                            \
325     for_each_local_value(cur_state, cur_index, value) {                                        \
326       Phi* v_phi = value-&gt;as_Phi();                                                            \
327       if (v_phi != NULL &amp;&amp; v_phi-&gt;block() == v_block) {                                        \
328         v_code;                                                                                \
329       }                                                                                        \
330     }                                                                                          \
331   }                                                                                            \
332 }
333 
334 #endif // SHARE_C1_C1_VALUESTACK_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
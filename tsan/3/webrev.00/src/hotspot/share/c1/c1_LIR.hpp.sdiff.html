<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 871 class    LIR_OpTypeCheck;
 872 class    LIR_OpCompareAndSwap;
 873 class    LIR_OpProfileCall;
 874 class    LIR_OpProfileType;
 875 #ifdef ASSERT
 876 class    LIR_OpAssert;
 877 #endif
 878 
 879 // LIR operation codes
 880 enum LIR_Code {
 881     lir_none
 882   , begin_op0
 883       , lir_word_align
 884       , lir_label
 885       , lir_nop
 886       , lir_backwardbranch_target
 887       , lir_std_entry
 888       , lir_osr_entry
 889       , lir_build_frame
 890       , lir_fpop_raw
<span class="line-removed"> 891       , lir_24bit_FPU</span>
<span class="line-removed"> 892       , lir_reset_FPU</span>
 893       , lir_breakpoint
 894       , lir_rtcall
 895       , lir_membar
 896       , lir_membar_acquire
 897       , lir_membar_release
 898       , lir_membar_loadload
 899       , lir_membar_storestore
 900       , lir_membar_loadstore
 901       , lir_membar_storeload
 902       , lir_get_thread
 903       , lir_on_spin_wait
 904   , end_op0
 905   , begin_op1
 906       , lir_fxch
 907       , lir_fld
<span class="line-removed"> 908       , lir_ffree</span>
 909       , lir_push
 910       , lir_pop
 911       , lir_null_check
 912       , lir_return
 913       , lir_leal
 914       , lir_branch
 915       , lir_cond_float_branch
 916       , lir_move
 917       , lir_convert
 918       , lir_alloc_object
 919       , lir_monaddr
 920       , lir_roundfp
 921       , lir_safepoint
 922       , lir_pack64
 923       , lir_unpack64
 924       , lir_unwind
 925   , end_op1
 926   , begin_op2
 927       , lir_cmp
 928       , lir_cmp_l2i
</pre>
<hr />
<pre>
2215   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2216   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2217   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2218 
2219   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2220   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2221 
2222   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2223     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2224   }
2225 
2226   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2227                     LIR_OprList* arguments, CodeEmitInfo* info) {
2228     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2229   }
2230 
2231   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2232   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
2233   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info);
2234 
<span class="line-removed">2235   void set_24bit_fpu()                                               { append(new LIR_Op0(lir_24bit_FPU )); }</span>
<span class="line-removed">2236   void restore_fpu()                                                 { append(new LIR_Op0(lir_reset_FPU )); }</span>
2237   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2238 
2239   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2240 
2241   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2242 
2243   void fpop_raw()                                { append(new LIR_Op0(lir_fpop_raw)); }
2244 
2245   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2246   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);
2247 
2248   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2249                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2250                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
2251                   ciMethod* profiled_method, int profiled_bci);
2252   // MethodData* profiling
2253   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2254     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2255   }
2256   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
</pre>
</td>
<td>
<hr />
<pre>
 871 class    LIR_OpTypeCheck;
 872 class    LIR_OpCompareAndSwap;
 873 class    LIR_OpProfileCall;
 874 class    LIR_OpProfileType;
 875 #ifdef ASSERT
 876 class    LIR_OpAssert;
 877 #endif
 878 
 879 // LIR operation codes
 880 enum LIR_Code {
 881     lir_none
 882   , begin_op0
 883       , lir_word_align
 884       , lir_label
 885       , lir_nop
 886       , lir_backwardbranch_target
 887       , lir_std_entry
 888       , lir_osr_entry
 889       , lir_build_frame
 890       , lir_fpop_raw


 891       , lir_breakpoint
 892       , lir_rtcall
 893       , lir_membar
 894       , lir_membar_acquire
 895       , lir_membar_release
 896       , lir_membar_loadload
 897       , lir_membar_storestore
 898       , lir_membar_loadstore
 899       , lir_membar_storeload
 900       , lir_get_thread
 901       , lir_on_spin_wait
 902   , end_op0
 903   , begin_op1
 904       , lir_fxch
 905       , lir_fld

 906       , lir_push
 907       , lir_pop
 908       , lir_null_check
 909       , lir_return
 910       , lir_leal
 911       , lir_branch
 912       , lir_cond_float_branch
 913       , lir_move
 914       , lir_convert
 915       , lir_alloc_object
 916       , lir_monaddr
 917       , lir_roundfp
 918       , lir_safepoint
 919       , lir_pack64
 920       , lir_unpack64
 921       , lir_unwind
 922   , end_op1
 923   , begin_op2
 924       , lir_cmp
 925       , lir_cmp_l2i
</pre>
<hr />
<pre>
2212   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2213   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2214   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2215 
2216   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2217   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2218 
2219   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2220     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2221   }
2222 
2223   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2224                     LIR_OprList* arguments, CodeEmitInfo* info) {
2225     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2226   }
2227 
2228   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2229   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
2230   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info);
2231 


2232   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2233 
2234   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2235 
2236   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2237 
2238   void fpop_raw()                                { append(new LIR_Op0(lir_fpop_raw)); }
2239 
2240   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2241   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);
2242 
2243   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2244                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2245                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
2246                   ciMethod* profiled_method, int profiled_bci);
2247   // MethodData* profiling
2248   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2249     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2250   }
2251   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
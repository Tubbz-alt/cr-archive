<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;

  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-removed">  42 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;

  45 
  46 class BlockListBuilder {
  47  private:
  48   Compilation* _compilation;
  49   IRScope*     _scope;
  50 
  51   BlockList    _blocks;                // internal list of all blocks
  52   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  53 
  54   // fields used by mark_loops
  55   ResourceBitMap _active;              // for iteration of control flow graph
  56   ResourceBitMap _visited;             // for iteration of control flow graph
  57   intArray       _loop_map;            // caches the information if a block is contained in a loop
  58   int            _next_loop_index;     // next free loop number
  59   int            _next_block_number;   // for reverse postorder numbering of blocks
  60 
  61   // accessors
  62   Compilation*  compilation() const              { return _compilation; }
  63   IRScope*      scope() const                    { return _scope; }
  64   ciMethod*     method() const                   { return scope()-&gt;method(); }
</pre>
<hr />
<pre>
 590     if (con) {
 591       switch (con-&gt;type()-&gt;tag()) {
 592         case intTag:    return con-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 593         case longTag:   return con-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0;
 594         case floatTag:  return jint_cast(con-&gt;type()-&gt;as_FloatConstant()-&gt;value()) == 0;
 595         case doubleTag: return jlong_cast(con-&gt;type()-&gt;as_DoubleConstant()-&gt;value()) == jlong_cast(0);
 596         case objectTag: return con-&gt;type() == objectNull;
 597         default:  ShouldNotReachHere();
 598       }
 599     }
 600     return false;
 601   }
 602 
 603 
 604   // return either the actual value of a load or the load itself
 605   Value load(LoadField* load) {
 606     if (!EliminateFieldAccess) {
 607       return load;
 608     }
 609 
<span class="line-modified"> 610     if (RoundFPResults &amp;&amp; UseSSE &lt; 2 &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {</span>
<span class="line-modified"> 611       // can&#39;t skip load since value might get rounded as a side effect</span>
<span class="line-modified"> 612       return load;</span>






 613     }
 614 
 615     ciField* field = load-&gt;field();
 616     Value object   = load-&gt;obj();
 617     if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
 618       int offset = field-&gt;offset();
 619       Value result = NULL;
 620       int index = _newobjects.find(object);
 621       if (index != -1) {
 622         result = _fields.at(index)-&gt;at(field);
 623       } else if (_objects.at_grow(offset, NULL) == object) {
 624         result = _values.at(field);
 625       }
 626       if (result != NULL) {
 627 #ifndef PRODUCT
 628         if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 629           tty-&gt;print_cr(&quot;Eliminated load: &quot;);
 630           load-&gt;print_line();
 631         }
 632 #endif
</pre>
<hr />
<pre>
1450     }
1451   }
1452 
1453   if (needs_check) {
1454     // Perform the registration of finalizable objects.
1455     ValueStack* state_before = copy_state_for_exception();
1456     load_local(objectType, 0);
1457     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1458                                state()-&gt;pop_arguments(1),
1459                                true, state_before, true));
1460   }
1461 }
1462 
1463 
1464 void GraphBuilder::method_return(Value x, bool ignore_return) {
1465   if (RegisterFinalizersAtInit &amp;&amp;
1466       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1467     call_register_finalizer();
1468   }
1469 

1470   bool need_mem_bar = false;
1471   if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
<span class="line-modified">1472       (scope()-&gt;wrote_final() || (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields())</span>
<span class="line-modified">1473                               || (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile())</span>
<span class="line-modified">1474      )){</span>
1475     need_mem_bar = true;
1476   }
1477 
1478   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1479   switch (bt) {
1480     case T_BYTE:
1481     {
1482       Value shift = append(new Constant(new IntConstant(24)));
1483       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1484       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1485       break;
1486     }
1487     case T_SHORT:
1488     {
1489       Value shift = append(new Constant(new IntConstant(16)));
1490       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1491       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1492       break;
1493     }
1494     case T_CHAR:
</pre>
<hr />
<pre>
1689         Value mask = append(new Constant(new IntConstant(1)));
1690         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1691       }
1692       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1693       break;
1694     }
1695     case Bytecodes::_getfield: {
1696       // Check for compile-time constants, i.e., trusted final non-static fields.
1697       Value constant = NULL;
1698       obj = apop();
1699       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1700       if (field-&gt;is_constant() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1701         ciObject* const_oop = obj_type-&gt;constant_value();
1702         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1703           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1704           if (field_value.is_valid()) {
1705             constant = make_constant(field_value, field);
1706             // For CallSite objects add a dependency for invalidation of the optimization.
1707             if (field-&gt;is_call_site_target()) {
1708               ciCallSite* call_site = const_oop-&gt;as_call_site();
<span class="line-modified">1709               if (!call_site-&gt;is_constant_call_site()) {</span>
1710                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1711                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1712               }
1713             }
1714           }
1715         }
1716       }
1717       if (constant != NULL) {
1718         push(type, append(constant));
1719       } else {
1720         if (state_before == NULL) {
1721           state_before = copy_state_for_exception();
1722         }
1723         LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
1724         Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
1725         if (replacement != load) {
1726           assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);

















1727           push(type, replacement);
1728         } else {
1729           push(type, append(load));
1730         }
1731       }
1732       break;
1733     }
1734     case Bytecodes::_putfield: {
1735       Value val = pop(type);
1736       obj = apop();
1737       if (state_before == NULL) {
1738         state_before = copy_state_for_exception();
1739       }
1740       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1741         Value mask = append(new Constant(new IntConstant(1)));
1742         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1743       }
1744       StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1745       if (!needs_patching) store = _memory-&gt;store(store);
1746       if (store != NULL) {
</pre>
<hr />
<pre>
1940     if ((code == Bytecodes::_invokevirtual &amp;&amp; callee_holder-&gt;is_initialized()) ||
1941         (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_initialized() &amp;&amp; !actual_recv-&gt;is_interface())) {
1942       // Use CHA on the receiver to select a more precise method.
1943       cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
1944     } else if (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_loaded() &amp;&amp; receiver != NULL) {
1945       assert(callee_holder-&gt;is_interface(), &quot;invokeinterface to non interface?&quot;);
1946       // If there is only one implementor of this interface then we
1947       // may be able bind this invoke directly to the implementing
1948       // klass but we need both a dependence on the single interface
1949       // and on the method we bind to.  Additionally since all we know
1950       // about the receiver type is the it&#39;s supposed to implement the
1951       // interface we have to insert a check that it&#39;s the class we
1952       // expect.  Interface types are not checked by the verifier so
1953       // they are roughly equivalent to Object.
1954       // The number of implementors for declared_interface is less or
1955       // equal to the number of implementors for target-&gt;holder() so
1956       // if number of implementors of target-&gt;holder() == 1 then
1957       // number of implementors for decl_interface is 0 or 1. If
1958       // it&#39;s 0 then no class implements decl_interface and there&#39;s
1959       // no point in inlining.
<span class="line-removed">1960       ciInstanceKlass* singleton = NULL;</span>
1961       ciInstanceKlass* declared_interface = callee_holder;
<span class="line-modified">1962       if (declared_interface-&gt;nof_implementors() == 1 &amp;&amp;</span>
<span class="line-modified">1963           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */) {</span>
<span class="line-modified">1964         singleton = declared_interface-&gt;implementor();</span>
<span class="line-modified">1965         assert(singleton != NULL &amp;&amp; singleton != declared_interface, &quot;&quot;);</span>
1966         cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
1967         if (cha_monomorphic_target != NULL) {
1968           if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
1969             // If CHA is able to bind this invoke then update the class
1970             // to match that class, otherwise klass will refer to the
1971             // interface.
1972             klass = cha_monomorphic_target-&gt;holder();
1973             actual_recv = declared_interface;
1974 
1975             // insert a check it&#39;s really the expected class.
1976             CheckCast* c = new CheckCast(klass, receiver, copy_state_for_exception());
1977             c-&gt;set_incompatible_class_change_check();
1978             c-&gt;set_direct_compare(klass-&gt;is_final());
1979             // pass the result of the checkcast so that the compiler has
1980             // more accurate type info in the inlinee
1981             better_receiver = append_split(c);
1982           } else {
1983             cha_monomorphic_target = NULL; // subtype check against Object is useless
1984           }
1985         }
1986       }
1987     }
1988   }
1989 
1990   if (cha_monomorphic_target != NULL) {

1991     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
<span class="line-modified">1992     if (!target-&gt;is_final_method() &amp;&amp; !target-&gt;is_private()) {</span>
1993       // If we inlined because CHA revealed only a single target method,
1994       // then we are dependent on that target method not getting overridden
1995       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
1996       // dest_method here, as opposed to the actual receiver, which may
1997       // falsely lead us to believe that the receiver is final or private.
1998       dependency_recorder()-&gt;assert_unique_concrete_method(actual_recv, cha_monomorphic_target);
1999     }
2000     code = Bytecodes::_invokespecial;
2001   }
2002 
2003   // check if we could do inlining
2004   if (!PatchALot &amp;&amp; Inline &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2005       (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
2006       &amp;&amp; !patch_for_appendix) {
2007     // callee is known =&gt; check if we have static binding
2008     if (code == Bytecodes::_invokestatic  ||
2009         code == Bytecodes::_invokespecial ||
2010         (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method()) ||
2011         code == Bytecodes::_invokedynamic) {
2012       ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;
</pre>
<hr />
<pre>
2237   int i = dimensions;
2238   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2239   // create array
2240   NewArray* n = new NewMultiArray(klass, dims, state_before);
2241   apush(append_split(n));
2242 }
2243 
2244 
2245 void GraphBuilder::throw_op(int bci) {
2246   // We require that the debug info for a Throw be the &quot;state before&quot;
2247   // the Throw (i.e., exception oop is still on TOS)
2248   ValueStack* state_before = copy_state_before_with_bci(bci);
2249   Throw* t = new Throw(apop(), state_before);
2250   // operand stack not needed after a throw
2251   state()-&gt;truncate_stack(0);
2252   append_with_bci(t, bci);
2253 }
2254 
2255 
2256 Value GraphBuilder::round_fp(Value fp_value) {
<span class="line-modified">2257   // no rounding needed if SSE2 is used</span>
<span class="line-modified">2258   if (RoundFPResults &amp;&amp; UseSSE &lt; 2) {</span>
<span class="line-modified">2259     // Must currently insert rounding node for doubleword values that</span>
<span class="line-modified">2260     // are results of expressions (i.e., not loads from memory or</span>
<span class="line-modified">2261     // constants)</span>
<span class="line-modified">2262     if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;</span>
<span class="line-modified">2263         fp_value-&gt;as_Constant() == NULL &amp;&amp;</span>
<span class="line-modified">2264         fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding</span>
<span class="line-modified">2265         fp_value-&gt;as_RoundFP() == NULL) {</span>
<span class="line-modified">2266       return append(new RoundFP(fp_value));</span>



2267     }



2268   }
2269   return fp_value;
2270 }
2271 
2272 
2273 Instruction* GraphBuilder::append_with_bci(Instruction* instr, int bci) {
2274   Canonicalizer canon(compilation(), instr, bci);
2275   Instruction* i1 = canon.canonical();
2276   if (i1-&gt;is_linked() || !i1-&gt;can_be_linked()) {
2277     // Canonicalizer returned an instruction which was already
2278     // appended so simply return it.
2279     return i1;
2280   }
2281 
2282   if (UseLocalValueNumbering) {
2283     // Lookup the instruction in the ValueMap and add it to the map if
2284     // it&#39;s not found.
2285     Instruction* i2 = vmap()-&gt;find_insert(i1);
2286     if (i2 != i1) {
2287       // found an entry in the value map, so just return it.
</pre>
<hr />
<pre>
2572     phi-&gt;set_subst(subst);
2573 
2574 #ifndef PRODUCT
2575     if (PrintPhiFunctions) {
2576       tty-&gt;print_cr(&quot;simplified phi function %c%d to %c%d (Block B%d)&quot;, phi-&gt;type()-&gt;tchar(), phi-&gt;id(), subst-&gt;type()-&gt;tchar(), subst-&gt;id(), phi-&gt;block()-&gt;block_id());
2577     }
2578 #endif
2579 
2580     return subst;
2581   }
2582 }
2583 
2584 
2585 void PhiSimplifier::block_do(BlockBegin* b) {
2586   for_each_phi_fun(b, phi,
2587     simplify(phi);
2588   );
2589 
2590 #ifdef ASSERT
2591   for_each_phi_fun(b, phi,
<span class="line-modified">2592                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi, &quot;missed trivial simplification&quot;);</span>
2593   );
2594 
2595   ValueStack* state = b-&gt;state()-&gt;caller_state();
2596   for_each_state_value(state, value,
2597     Phi* phi = value-&gt;as_Phi();
2598     assert(phi == NULL || phi-&gt;block() != b, &quot;must not have phi function to simplify in caller state&quot;);
2599   );
2600 #endif
2601 }
2602 
2603 // This method is called after all blocks are filled with HIR instructions
2604 // It eliminates all Phi functions of the form x = [y, y] and x = [y, x]
2605 void GraphBuilder::eliminate_redundant_phis(BlockBegin* start) {
2606   PhiSimplifier simplifier(start);
2607 }
2608 
2609 
2610 void GraphBuilder::connect_to_end(BlockBegin* beg) {
2611   // setup iteration
2612   kill_all();
</pre>
<hr />
<pre>
3150 }
3151 
3152 
3153 ValueStack* GraphBuilder::state_at_entry() {
3154   ValueStack* state = new ValueStack(scope(), NULL);
3155 
3156   // Set up locals for receiver
3157   int idx = 0;
3158   if (!method()-&gt;is_static()) {
3159     // we should always see the receiver
3160     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx, true));
3161     idx = 1;
3162   }
3163 
3164   // Set up locals for incoming arguments
3165   ciSignature* sig = method()-&gt;signature();
3166   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3167     ciType* type = sig-&gt;type_at(i);
3168     BasicType basic_type = type-&gt;basic_type();
3169     // don&#39;t allow T_ARRAY to propagate into locals types
<span class="line-modified">3170     if (basic_type == T_ARRAY) basic_type = T_OBJECT;</span>
3171     ValueType* vt = as_ValueType(basic_type);
3172     state-&gt;store_local(idx, new Local(type, vt, idx, false));
3173     idx += type-&gt;size();
3174   }
3175 
3176   // lock synchronized method
3177   if (method()-&gt;is_synchronized()) {
3178     state-&gt;lock(NULL);
3179   }
3180 
3181   return state;
3182 }
3183 
3184 
3185 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3186   : _scope_data(NULL)
3187   , _compilation(compilation)
3188   , _memory(new MemoryBuffer())
3189   , _inline_bailout_msg(NULL)
3190   , _instruction_count(0)
</pre>
<hr />
<pre>
3731   _last = orig_last;
3732 }
3733 
3734 
3735 bool GraphBuilder::try_inline_full(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3736   assert(!callee-&gt;is_native(), &quot;callee must not be native&quot;);
3737   if (CompilationPolicy::policy()-&gt;should_not_inline(compilation()-&gt;env(), callee)) {
3738     INLINE_BAILOUT(&quot;inlining prohibited by policy&quot;);
3739   }
3740   // first perform tests of things it&#39;s not possible to inline
3741   if (callee-&gt;has_exception_handlers() &amp;&amp;
3742       !InlineMethodsWithExceptionHandlers) INLINE_BAILOUT(&quot;callee has exception handlers&quot;);
3743   if (callee-&gt;is_synchronized() &amp;&amp;
3744       !InlineSynchronizedMethods         ) INLINE_BAILOUT(&quot;callee is synchronized&quot;);
3745   if (!callee-&gt;holder()-&gt;is_initialized()) INLINE_BAILOUT(&quot;callee&#39;s klass not initialized yet&quot;);
3746   if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
3747 
3748   // Proper inlining of methods with jsrs requires a little more work.
3749   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
3750 
<span class="line-modified">3751   // When SSE2 is used on intel, then no special handling is needed</span>
<span class="line-modified">3752   // for strictfp because the enum-constant is fixed at compile time,</span>
<span class="line-modified">3753   // the check for UseSSE2 is needed here</span>
<span class="line-modified">3754   if (strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt; 2 &amp;&amp; method()-&gt;is_strict() != callee-&gt;is_strict()) {</span>
<span class="line-modified">3755     INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);</span>






3756   }
3757 
3758   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
3759     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
3760   }
3761 
3762   // now perform tests that are based on flag settings
3763   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
3764   if (callee-&gt;force_inline() || inlinee_by_directive) {
3765     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
3766     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3767 
3768     const char* msg = &quot;&quot;;
3769     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
3770     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
3771     print_inlining(callee, msg);
3772   } else {
3773     // use heuristic controls on inlining
3774     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
3775     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3776     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
3777 
3778     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
3779     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
3780         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3781       // Throwable constructor call
3782       IRScope* top = scope();
3783       while (top-&gt;caller() != NULL) {
3784         top = top-&gt;caller();
3785       }
3786       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3787         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
3788       }
3789     }
3790 
3791     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
3792       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
3793     }
3794     // printing
<span class="line-modified">3795     print_inlining(callee);</span>
3796   }
3797 
3798   // NOTE: Bailouts from this point on, which occur at the
3799   // GraphBuilder level, do not cause bailout just of the inlining but
3800   // in fact of the entire compilation.
3801 
3802   BlockBegin* orig_block = block();
3803 
3804   const bool is_invokedynamic = bc == Bytecodes::_invokedynamic;
3805   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);
3806 
3807   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
3808   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);
3809 
3810   // Insert null check if necessary
3811   Value recv = NULL;
3812   if (has_receiver) {
3813     // note: null check must happen even if first instruction of callee does
3814     //       an implicit null check since the callee is in a different scope
3815     //       and we must make sure exception handling does the right thing
</pre>
<hr />
<pre>
4297   assert(caller != NULL, &quot;invariant&quot;);
4298   assert(callee != NULL, &quot;invariant&quot;);
4299   assert(event != NULL, &quot;invariant&quot;);
4300   assert(event-&gt;should_commit(), &quot;invariant&quot;);
4301   JfrStructCalleeMethod callee_struct;
4302   callee_struct.set_type(callee-&gt;holder()-&gt;name()-&gt;as_utf8());
4303   callee_struct.set_name(callee-&gt;name()-&gt;as_utf8());
4304   callee_struct.set_descriptor(callee-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
4305   event-&gt;set_compileId(compile_id);
4306   event-&gt;set_message(msg);
4307   event-&gt;set_succeeded(success);
4308   event-&gt;set_bci(bci);
4309   event-&gt;set_caller(caller-&gt;get_Method());
4310   event-&gt;set_callee(callee_struct);
4311   event-&gt;commit();
4312 }
4313 
4314 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4315   CompileLog* log = compilation()-&gt;log();
4316   if (log != NULL) {

4317     if (success) {
<span class="line-modified">4318       if (msg != NULL)</span>
<span class="line-removed">4319         log-&gt;inline_success(msg);</span>
<span class="line-removed">4320       else</span>
<span class="line-removed">4321         log-&gt;inline_success(&quot;receiver is statically known&quot;);</span>
4322     } else {
<span class="line-modified">4323       if (msg != NULL)</span>
<span class="line-removed">4324         log-&gt;inline_fail(msg);</span>
<span class="line-removed">4325       else</span>
<span class="line-removed">4326         log-&gt;inline_fail(&quot;reason unknown&quot;);</span>
4327     }
4328   }
4329   EventCompilerInlining event;
4330   if (event.should_commit()) {
4331     post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);
4332   }
4333 
4334   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4335 
4336   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4337     return;
4338   }
4339   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4340   if (success &amp;&amp; CIPrintMethodCodes) {
4341     callee-&gt;print_codes();
4342   }
4343 }
4344 
4345 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4346   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">  36 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;interpreter/bytecode.hpp&quot;
  39 #include &quot;jfr/jfrEvents.hpp&quot;
  40 #include &quot;memory/resourceArea.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;

  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;
<span class="line-added">  45 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  46 
  47 class BlockListBuilder {
  48  private:
  49   Compilation* _compilation;
  50   IRScope*     _scope;
  51 
  52   BlockList    _blocks;                // internal list of all blocks
  53   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  54 
  55   // fields used by mark_loops
  56   ResourceBitMap _active;              // for iteration of control flow graph
  57   ResourceBitMap _visited;             // for iteration of control flow graph
  58   intArray       _loop_map;            // caches the information if a block is contained in a loop
  59   int            _next_loop_index;     // next free loop number
  60   int            _next_block_number;   // for reverse postorder numbering of blocks
  61 
  62   // accessors
  63   Compilation*  compilation() const              { return _compilation; }
  64   IRScope*      scope() const                    { return _scope; }
  65   ciMethod*     method() const                   { return scope()-&gt;method(); }
</pre>
<hr />
<pre>
 591     if (con) {
 592       switch (con-&gt;type()-&gt;tag()) {
 593         case intTag:    return con-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 594         case longTag:   return con-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0;
 595         case floatTag:  return jint_cast(con-&gt;type()-&gt;as_FloatConstant()-&gt;value()) == 0;
 596         case doubleTag: return jlong_cast(con-&gt;type()-&gt;as_DoubleConstant()-&gt;value()) == jlong_cast(0);
 597         case objectTag: return con-&gt;type() == objectNull;
 598         default:  ShouldNotReachHere();
 599       }
 600     }
 601     return false;
 602   }
 603 
 604 
 605   // return either the actual value of a load or the load itself
 606   Value load(LoadField* load) {
 607     if (!EliminateFieldAccess) {
 608       return load;
 609     }
 610 
<span class="line-modified"> 611     if (strict_fp_requires_explicit_rounding &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {</span>
<span class="line-modified"> 612 #ifdef IA32</span>
<span class="line-modified"> 613       if (UseSSE &lt; 2) {</span>
<span class="line-added"> 614         // can&#39;t skip load since value might get rounded as a side effect</span>
<span class="line-added"> 615         return load;</span>
<span class="line-added"> 616       }</span>
<span class="line-added"> 617 #else</span>
<span class="line-added"> 618       Unimplemented();</span>
<span class="line-added"> 619 #endif // IA32</span>
 620     }
 621 
 622     ciField* field = load-&gt;field();
 623     Value object   = load-&gt;obj();
 624     if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
 625       int offset = field-&gt;offset();
 626       Value result = NULL;
 627       int index = _newobjects.find(object);
 628       if (index != -1) {
 629         result = _fields.at(index)-&gt;at(field);
 630       } else if (_objects.at_grow(offset, NULL) == object) {
 631         result = _values.at(field);
 632       }
 633       if (result != NULL) {
 634 #ifndef PRODUCT
 635         if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 636           tty-&gt;print_cr(&quot;Eliminated load: &quot;);
 637           load-&gt;print_line();
 638         }
 639 #endif
</pre>
<hr />
<pre>
1457     }
1458   }
1459 
1460   if (needs_check) {
1461     // Perform the registration of finalizable objects.
1462     ValueStack* state_before = copy_state_for_exception();
1463     load_local(objectType, 0);
1464     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1465                                state()-&gt;pop_arguments(1),
1466                                true, state_before, true));
1467   }
1468 }
1469 
1470 
1471 void GraphBuilder::method_return(Value x, bool ignore_return) {
1472   if (RegisterFinalizersAtInit &amp;&amp;
1473       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1474     call_register_finalizer();
1475   }
1476 
<span class="line-added">1477   // The conditions for a memory barrier are described in Parse::do_exits().</span>
1478   bool need_mem_bar = false;
1479   if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
<span class="line-modified">1480        (scope()-&gt;wrote_final() ||</span>
<span class="line-modified">1481          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||</span>
<span class="line-modified">1482          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {</span>
1483     need_mem_bar = true;
1484   }
1485 
1486   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1487   switch (bt) {
1488     case T_BYTE:
1489     {
1490       Value shift = append(new Constant(new IntConstant(24)));
1491       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1492       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1493       break;
1494     }
1495     case T_SHORT:
1496     {
1497       Value shift = append(new Constant(new IntConstant(16)));
1498       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1499       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1500       break;
1501     }
1502     case T_CHAR:
</pre>
<hr />
<pre>
1697         Value mask = append(new Constant(new IntConstant(1)));
1698         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1699       }
1700       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1701       break;
1702     }
1703     case Bytecodes::_getfield: {
1704       // Check for compile-time constants, i.e., trusted final non-static fields.
1705       Value constant = NULL;
1706       obj = apop();
1707       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1708       if (field-&gt;is_constant() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1709         ciObject* const_oop = obj_type-&gt;constant_value();
1710         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1711           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1712           if (field_value.is_valid()) {
1713             constant = make_constant(field_value, field);
1714             // For CallSite objects add a dependency for invalidation of the optimization.
1715             if (field-&gt;is_call_site_target()) {
1716               ciCallSite* call_site = const_oop-&gt;as_call_site();
<span class="line-modified">1717               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {</span>
1718                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1719                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1720               }
1721             }
1722           }
1723         }
1724       }
1725       if (constant != NULL) {
1726         push(type, append(constant));
1727       } else {
1728         if (state_before == NULL) {
1729           state_before = copy_state_for_exception();
1730         }
1731         LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
1732         Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
1733         if (replacement != load) {
1734           assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);
<span class="line-added">1735           // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="line-added">1736           // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="line-added">1737           BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-added">1738           switch (bt) {</span>
<span class="line-added">1739           case T_BOOLEAN:</span>
<span class="line-added">1740           case T_BYTE:</span>
<span class="line-added">1741             replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="line-added">1742             break;</span>
<span class="line-added">1743           case T_CHAR:</span>
<span class="line-added">1744             replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="line-added">1745             break;</span>
<span class="line-added">1746           case T_SHORT:</span>
<span class="line-added">1747             replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="line-added">1748             break;</span>
<span class="line-added">1749           default:</span>
<span class="line-added">1750             break;</span>
<span class="line-added">1751           }</span>
1752           push(type, replacement);
1753         } else {
1754           push(type, append(load));
1755         }
1756       }
1757       break;
1758     }
1759     case Bytecodes::_putfield: {
1760       Value val = pop(type);
1761       obj = apop();
1762       if (state_before == NULL) {
1763         state_before = copy_state_for_exception();
1764       }
1765       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1766         Value mask = append(new Constant(new IntConstant(1)));
1767         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1768       }
1769       StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1770       if (!needs_patching) store = _memory-&gt;store(store);
1771       if (store != NULL) {
</pre>
<hr />
<pre>
1965     if ((code == Bytecodes::_invokevirtual &amp;&amp; callee_holder-&gt;is_initialized()) ||
1966         (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_initialized() &amp;&amp; !actual_recv-&gt;is_interface())) {
1967       // Use CHA on the receiver to select a more precise method.
1968       cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
1969     } else if (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_loaded() &amp;&amp; receiver != NULL) {
1970       assert(callee_holder-&gt;is_interface(), &quot;invokeinterface to non interface?&quot;);
1971       // If there is only one implementor of this interface then we
1972       // may be able bind this invoke directly to the implementing
1973       // klass but we need both a dependence on the single interface
1974       // and on the method we bind to.  Additionally since all we know
1975       // about the receiver type is the it&#39;s supposed to implement the
1976       // interface we have to insert a check that it&#39;s the class we
1977       // expect.  Interface types are not checked by the verifier so
1978       // they are roughly equivalent to Object.
1979       // The number of implementors for declared_interface is less or
1980       // equal to the number of implementors for target-&gt;holder() so
1981       // if number of implementors of target-&gt;holder() == 1 then
1982       // number of implementors for decl_interface is 0 or 1. If
1983       // it&#39;s 0 then no class implements decl_interface and there&#39;s
1984       // no point in inlining.

1985       ciInstanceKlass* declared_interface = callee_holder;
<span class="line-modified">1986       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();</span>
<span class="line-modified">1987       if (singleton != NULL &amp;&amp;</span>
<span class="line-modified">1988           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */ ) {</span>
<span class="line-modified">1989         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);</span>
1990         cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
1991         if (cha_monomorphic_target != NULL) {
1992           if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
1993             // If CHA is able to bind this invoke then update the class
1994             // to match that class, otherwise klass will refer to the
1995             // interface.
1996             klass = cha_monomorphic_target-&gt;holder();
1997             actual_recv = declared_interface;
1998 
1999             // insert a check it&#39;s really the expected class.
2000             CheckCast* c = new CheckCast(klass, receiver, copy_state_for_exception());
2001             c-&gt;set_incompatible_class_change_check();
2002             c-&gt;set_direct_compare(klass-&gt;is_final());
2003             // pass the result of the checkcast so that the compiler has
2004             // more accurate type info in the inlinee
2005             better_receiver = append_split(c);
2006           } else {
2007             cha_monomorphic_target = NULL; // subtype check against Object is useless
2008           }
2009         }
2010       }
2011     }
2012   }
2013 
2014   if (cha_monomorphic_target != NULL) {
<span class="line-added">2015     assert(!target-&gt;can_be_statically_bound() || target == cha_monomorphic_target, &quot;&quot;);</span>
2016     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
<span class="line-modified">2017     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_recv)) {</span>
2018       // If we inlined because CHA revealed only a single target method,
2019       // then we are dependent on that target method not getting overridden
2020       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
2021       // dest_method here, as opposed to the actual receiver, which may
2022       // falsely lead us to believe that the receiver is final or private.
2023       dependency_recorder()-&gt;assert_unique_concrete_method(actual_recv, cha_monomorphic_target);
2024     }
2025     code = Bytecodes::_invokespecial;
2026   }
2027 
2028   // check if we could do inlining
2029   if (!PatchALot &amp;&amp; Inline &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2030       (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
2031       &amp;&amp; !patch_for_appendix) {
2032     // callee is known =&gt; check if we have static binding
2033     if (code == Bytecodes::_invokestatic  ||
2034         code == Bytecodes::_invokespecial ||
2035         (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method()) ||
2036         code == Bytecodes::_invokedynamic) {
2037       ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;
</pre>
<hr />
<pre>
2262   int i = dimensions;
2263   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2264   // create array
2265   NewArray* n = new NewMultiArray(klass, dims, state_before);
2266   apush(append_split(n));
2267 }
2268 
2269 
2270 void GraphBuilder::throw_op(int bci) {
2271   // We require that the debug info for a Throw be the &quot;state before&quot;
2272   // the Throw (i.e., exception oop is still on TOS)
2273   ValueStack* state_before = copy_state_before_with_bci(bci);
2274   Throw* t = new Throw(apop(), state_before);
2275   // operand stack not needed after a throw
2276   state()-&gt;truncate_stack(0);
2277   append_with_bci(t, bci);
2278 }
2279 
2280 
2281 Value GraphBuilder::round_fp(Value fp_value) {
<span class="line-modified">2282   if (strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified">2283 #ifdef IA32</span>
<span class="line-modified">2284     // no rounding needed if SSE2 is used</span>
<span class="line-modified">2285     if (UseSSE &lt; 2) {</span>
<span class="line-modified">2286       // Must currently insert rounding node for doubleword values that</span>
<span class="line-modified">2287       // are results of expressions (i.e., not loads from memory or</span>
<span class="line-modified">2288       // constants)</span>
<span class="line-modified">2289       if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;</span>
<span class="line-modified">2290           fp_value-&gt;as_Constant() == NULL &amp;&amp;</span>
<span class="line-modified">2291           fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding</span>
<span class="line-added">2292           fp_value-&gt;as_RoundFP() == NULL) {</span>
<span class="line-added">2293         return append(new RoundFP(fp_value));</span>
<span class="line-added">2294       }</span>
2295     }
<span class="line-added">2296 #else</span>
<span class="line-added">2297     Unimplemented();</span>
<span class="line-added">2298 #endif // IA32</span>
2299   }
2300   return fp_value;
2301 }
2302 
2303 
2304 Instruction* GraphBuilder::append_with_bci(Instruction* instr, int bci) {
2305   Canonicalizer canon(compilation(), instr, bci);
2306   Instruction* i1 = canon.canonical();
2307   if (i1-&gt;is_linked() || !i1-&gt;can_be_linked()) {
2308     // Canonicalizer returned an instruction which was already
2309     // appended so simply return it.
2310     return i1;
2311   }
2312 
2313   if (UseLocalValueNumbering) {
2314     // Lookup the instruction in the ValueMap and add it to the map if
2315     // it&#39;s not found.
2316     Instruction* i2 = vmap()-&gt;find_insert(i1);
2317     if (i2 != i1) {
2318       // found an entry in the value map, so just return it.
</pre>
<hr />
<pre>
2603     phi-&gt;set_subst(subst);
2604 
2605 #ifndef PRODUCT
2606     if (PrintPhiFunctions) {
2607       tty-&gt;print_cr(&quot;simplified phi function %c%d to %c%d (Block B%d)&quot;, phi-&gt;type()-&gt;tchar(), phi-&gt;id(), subst-&gt;type()-&gt;tchar(), subst-&gt;id(), phi-&gt;block()-&gt;block_id());
2608     }
2609 #endif
2610 
2611     return subst;
2612   }
2613 }
2614 
2615 
2616 void PhiSimplifier::block_do(BlockBegin* b) {
2617   for_each_phi_fun(b, phi,
2618     simplify(phi);
2619   );
2620 
2621 #ifdef ASSERT
2622   for_each_phi_fun(b, phi,
<span class="line-modified">2623                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi || phi-&gt;is_illegal(), &quot;missed trivial simplification&quot;);</span>
2624   );
2625 
2626   ValueStack* state = b-&gt;state()-&gt;caller_state();
2627   for_each_state_value(state, value,
2628     Phi* phi = value-&gt;as_Phi();
2629     assert(phi == NULL || phi-&gt;block() != b, &quot;must not have phi function to simplify in caller state&quot;);
2630   );
2631 #endif
2632 }
2633 
2634 // This method is called after all blocks are filled with HIR instructions
2635 // It eliminates all Phi functions of the form x = [y, y] and x = [y, x]
2636 void GraphBuilder::eliminate_redundant_phis(BlockBegin* start) {
2637   PhiSimplifier simplifier(start);
2638 }
2639 
2640 
2641 void GraphBuilder::connect_to_end(BlockBegin* beg) {
2642   // setup iteration
2643   kill_all();
</pre>
<hr />
<pre>
3181 }
3182 
3183 
3184 ValueStack* GraphBuilder::state_at_entry() {
3185   ValueStack* state = new ValueStack(scope(), NULL);
3186 
3187   // Set up locals for receiver
3188   int idx = 0;
3189   if (!method()-&gt;is_static()) {
3190     // we should always see the receiver
3191     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx, true));
3192     idx = 1;
3193   }
3194 
3195   // Set up locals for incoming arguments
3196   ciSignature* sig = method()-&gt;signature();
3197   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3198     ciType* type = sig-&gt;type_at(i);
3199     BasicType basic_type = type-&gt;basic_type();
3200     // don&#39;t allow T_ARRAY to propagate into locals types
<span class="line-modified">3201     if (is_reference_type(basic_type)) basic_type = T_OBJECT;</span>
3202     ValueType* vt = as_ValueType(basic_type);
3203     state-&gt;store_local(idx, new Local(type, vt, idx, false));
3204     idx += type-&gt;size();
3205   }
3206 
3207   // lock synchronized method
3208   if (method()-&gt;is_synchronized()) {
3209     state-&gt;lock(NULL);
3210   }
3211 
3212   return state;
3213 }
3214 
3215 
3216 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3217   : _scope_data(NULL)
3218   , _compilation(compilation)
3219   , _memory(new MemoryBuffer())
3220   , _inline_bailout_msg(NULL)
3221   , _instruction_count(0)
</pre>
<hr />
<pre>
3762   _last = orig_last;
3763 }
3764 
3765 
3766 bool GraphBuilder::try_inline_full(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3767   assert(!callee-&gt;is_native(), &quot;callee must not be native&quot;);
3768   if (CompilationPolicy::policy()-&gt;should_not_inline(compilation()-&gt;env(), callee)) {
3769     INLINE_BAILOUT(&quot;inlining prohibited by policy&quot;);
3770   }
3771   // first perform tests of things it&#39;s not possible to inline
3772   if (callee-&gt;has_exception_handlers() &amp;&amp;
3773       !InlineMethodsWithExceptionHandlers) INLINE_BAILOUT(&quot;callee has exception handlers&quot;);
3774   if (callee-&gt;is_synchronized() &amp;&amp;
3775       !InlineSynchronizedMethods         ) INLINE_BAILOUT(&quot;callee is synchronized&quot;);
3776   if (!callee-&gt;holder()-&gt;is_initialized()) INLINE_BAILOUT(&quot;callee&#39;s klass not initialized yet&quot;);
3777   if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
3778 
3779   // Proper inlining of methods with jsrs requires a little more work.
3780   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
3781 
<span class="line-modified">3782   if (strict_fp_requires_explicit_rounding &amp;&amp;</span>
<span class="line-modified">3783       method()-&gt;is_strict() != callee-&gt;is_strict()) {</span>
<span class="line-modified">3784 #ifdef IA32</span>
<span class="line-modified">3785     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).</span>
<span class="line-modified">3786     // When SSE2 is present, no special handling is needed.</span>
<span class="line-added">3787     if (UseSSE &lt; 2) {</span>
<span class="line-added">3788       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);</span>
<span class="line-added">3789     }</span>
<span class="line-added">3790 #else</span>
<span class="line-added">3791     Unimplemented();</span>
<span class="line-added">3792 #endif // IA32</span>
3793   }
3794 
3795   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
3796     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
3797   }
3798 
3799   // now perform tests that are based on flag settings
3800   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
3801   if (callee-&gt;force_inline() || inlinee_by_directive) {
3802     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
3803     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3804 
3805     const char* msg = &quot;&quot;;
3806     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
3807     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
3808     print_inlining(callee, msg);
3809   } else {
3810     // use heuristic controls on inlining
3811     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
3812     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3813     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
3814 
3815     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
3816     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
3817         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3818       // Throwable constructor call
3819       IRScope* top = scope();
3820       while (top-&gt;caller() != NULL) {
3821         top = top-&gt;caller();
3822       }
3823       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3824         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
3825       }
3826     }
3827 
3828     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
3829       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
3830     }
3831     // printing
<span class="line-modified">3832     print_inlining(callee, &quot;inline&quot;, /*success*/ true);</span>
3833   }
3834 
3835   // NOTE: Bailouts from this point on, which occur at the
3836   // GraphBuilder level, do not cause bailout just of the inlining but
3837   // in fact of the entire compilation.
3838 
3839   BlockBegin* orig_block = block();
3840 
3841   const bool is_invokedynamic = bc == Bytecodes::_invokedynamic;
3842   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);
3843 
3844   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
3845   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);
3846 
3847   // Insert null check if necessary
3848   Value recv = NULL;
3849   if (has_receiver) {
3850     // note: null check must happen even if first instruction of callee does
3851     //       an implicit null check since the callee is in a different scope
3852     //       and we must make sure exception handling does the right thing
</pre>
<hr />
<pre>
4334   assert(caller != NULL, &quot;invariant&quot;);
4335   assert(callee != NULL, &quot;invariant&quot;);
4336   assert(event != NULL, &quot;invariant&quot;);
4337   assert(event-&gt;should_commit(), &quot;invariant&quot;);
4338   JfrStructCalleeMethod callee_struct;
4339   callee_struct.set_type(callee-&gt;holder()-&gt;name()-&gt;as_utf8());
4340   callee_struct.set_name(callee-&gt;name()-&gt;as_utf8());
4341   callee_struct.set_descriptor(callee-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
4342   event-&gt;set_compileId(compile_id);
4343   event-&gt;set_message(msg);
4344   event-&gt;set_succeeded(success);
4345   event-&gt;set_bci(bci);
4346   event-&gt;set_caller(caller-&gt;get_Method());
4347   event-&gt;set_callee(callee_struct);
4348   event-&gt;commit();
4349 }
4350 
4351 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4352   CompileLog* log = compilation()-&gt;log();
4353   if (log != NULL) {
<span class="line-added">4354     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);</span>
4355     if (success) {
<span class="line-modified">4356       log-&gt;inline_success(msg);</span>



4357     } else {
<span class="line-modified">4358       log-&gt;inline_fail(msg);</span>



4359     }
4360   }
4361   EventCompilerInlining event;
4362   if (event.should_commit()) {
4363     post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);
4364   }
4365 
4366   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4367 
4368   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4369     return;
4370   }
4371   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4372   if (success &amp;&amp; CIPrintMethodCodes) {
4373     callee-&gt;print_codes();
4374   }
4375 }
4376 
4377 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4378   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_ValueStack.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_IR.hpp&quot;
 27 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 28 #include &quot;c1/c1_ValueStack.hpp&quot;
 29 
 30 
 31 // Implementation of ValueStack
 32 
 33 ValueStack::ValueStack(IRScope* scope, ValueStack* caller_state)
 34 : _scope(scope)
 35 , _caller_state(caller_state)
 36 , _bci(-99)
 37 , _kind(Parsing)
 38 , _locals(scope-&gt;method()-&gt;max_locals(), scope-&gt;method()-&gt;max_locals(), NULL)
 39 , _stack(scope-&gt;method()-&gt;max_stack())
 40 , _locks(NULL)
 41 {
 42   verify();
 43 }
 44 
 45 
 46 ValueStack::ValueStack(ValueStack* copy_from, Kind kind, int bci)
 47   : _scope(copy_from-&gt;scope())
 48   , _caller_state(copy_from-&gt;caller_state())
 49   , _bci(bci)
 50   , _kind(kind)
 51   , _locals()
 52   , _stack()
 53   , _locks(copy_from-&gt;locks_size() == 0 ? NULL : new Values(copy_from-&gt;locks_size()))
 54 {
 55   assert(kind != EmptyExceptionState || !Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;need locals&quot;);
 56   if (kind != EmptyExceptionState) {
 57     // only allocate space if we need to copy the locals-array
 58     _locals = Values(copy_from-&gt;locals_size());
 59     _locals.appendAll(&amp;copy_from-&gt;_locals);
 60   }
 61 
 62   if (kind != ExceptionState &amp;&amp; kind != EmptyExceptionState) {
 63     if (kind == Parsing) {
 64       // stack will be modified, so reserve enough space to avoid resizing
 65       _stack = Values(scope()-&gt;method()-&gt;max_stack());
 66     } else {
 67       // stack will not be modified, so do not waste space
 68       _stack = Values(copy_from-&gt;stack_size());
 69     }
 70     _stack.appendAll(&amp;copy_from-&gt;_stack);
 71   }
 72 
 73   if (copy_from-&gt;locks_size() &gt; 0) {
 74     _locks-&gt;appendAll(copy_from-&gt;_locks);
 75   }
 76 
 77   verify();
 78 }
 79 
 80 
 81 bool ValueStack::is_same(ValueStack* s) {
 82   if (scope() != s-&gt;scope()) return false;
 83   if (caller_state() != s-&gt;caller_state()) return false;
 84 
 85   if (locals_size() != s-&gt;locals_size()) return false;
 86   if (stack_size() != s-&gt;stack_size()) return false;
 87   if (locks_size() != s-&gt;locks_size()) return false;
 88 
 89   // compare each stack element with the corresponding stack element of s
 90   int index;
 91   Value value;
 92   for_each_stack_value(this, index, value) {
 93     if (value-&gt;type()-&gt;tag() != s-&gt;stack_at(index)-&gt;type()-&gt;tag()) return false;
 94   }
 95   for (int i = 0; i &lt; locks_size(); i++) {
 96     value = lock_at(i);
 97     if (value != NULL &amp;&amp; value != s-&gt;lock_at(i)) {
 98       return false;
 99     }
100   }
101   return true;
102 }
103 
104 void ValueStack::clear_locals() {
105   for (int i = _locals.length() - 1; i &gt;= 0; i--) {
106     _locals.at_put(i, NULL);
107   }
108 }
109 
110 
111 void ValueStack::pin_stack_for_linear_scan() {
112   for_each_state_value(this, v,
113     if (v-&gt;as_Constant() == NULL &amp;&amp; v-&gt;as_Local() == NULL) {
114       v-&gt;pin(Instruction::PinStackForStateSplit);
115     }
116   );
117 }
118 
119 
120 // apply function to all values of a list; factored out from values_do(f)
121 void ValueStack::apply(const Values&amp; list, ValueVisitor* f) {
122   for (int i = 0; i &lt; list.length(); i++) {
123     Value* va = list.adr_at(i);
124     Value v0 = *va;
125     if (v0 != NULL &amp;&amp; !v0-&gt;type()-&gt;is_illegal()) {
126       f-&gt;visit(va);
127 #ifdef ASSERT
128       Value v1 = *va;
129       assert(v1-&gt;type()-&gt;is_illegal() || v0-&gt;type()-&gt;tag() == v1-&gt;type()-&gt;tag(), &quot;types must match&quot;);
130       assert(!v1-&gt;type()-&gt;is_double_word() || list.at(i + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
131 #endif
132       if (v0-&gt;type()-&gt;is_double_word()) i++;
133     }
134   }
135 }
136 
137 
138 void ValueStack::values_do(ValueVisitor* f) {
139   ValueStack* state = this;
140   for_each_state(state) {
141     apply(state-&gt;_locals, f);
142     apply(state-&gt;_stack, f);
143     if (state-&gt;_locks != NULL) {
144       apply(*state-&gt;_locks, f);
145     }
146   }
147 }
148 
149 
150 Values* ValueStack::pop_arguments(int argument_size) {
151   assert(stack_size() &gt;= argument_size, &quot;stack too small or too many arguments&quot;);
152   int base = stack_size() - argument_size;
153   Values* args = new Values(argument_size);
154   for (int i = base; i &lt; stack_size();) args-&gt;push(stack_at_inc(i));
155   truncate_stack(base);
156   return args;
157 }
158 
159 
160 int ValueStack::total_locks_size() const {
161   int num_locks = 0;
162   const ValueStack* state = this;
163   for_each_state(state) {
164     num_locks += state-&gt;locks_size();
165   }
166   return num_locks;
167 }
168 
169 int ValueStack::lock(Value obj) {
170   if (_locks == NULL) {
171     _locks = new Values();
172   }
173   _locks-&gt;push(obj);
174   int num_locks = total_locks_size();
175   scope()-&gt;set_min_number_of_locks(num_locks);
176   return num_locks - 1;
177 }
178 
179 
180 int ValueStack::unlock() {
181   assert(locks_size() &gt; 0, &quot;sanity&quot;);
182   _locks-&gt;pop();
183   return total_locks_size();
184 }
185 
186 
187 void ValueStack::setup_phi_for_stack(BlockBegin* b, int index) {
188   assert(stack_at(index)-&gt;as_Phi() == NULL || stack_at(index)-&gt;as_Phi()-&gt;block() != b, &quot;phi function already created&quot;);
189 
190   ValueType* t = stack_at(index)-&gt;type();
191   Value phi = new Phi(t, b, -index - 1);
192   _stack.at_put(index, phi);
193 
194   assert(!t-&gt;is_double_word() || _stack.at(index + 1) == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
195 }
196 
197 void ValueStack::setup_phi_for_local(BlockBegin* b, int index) {
198   assert(local_at(index)-&gt;as_Phi() == NULL || local_at(index)-&gt;as_Phi()-&gt;block() != b, &quot;phi function already created&quot;);
199 
200   ValueType* t = local_at(index)-&gt;type();
201   Value phi = new Phi(t, b, index);
202   store_local(index, phi);
203 }
204 
205 #ifndef PRODUCT
206 
207 void ValueStack::print() {
208   scope()-&gt;method()-&gt;print_name();
209   tty-&gt;cr();
210   if (stack_is_empty()) {
211     tty-&gt;print_cr(&quot;empty stack&quot;);
212   } else {
213     InstructionPrinter ip;
214     for (int i = 0; i &lt; stack_size();) {
215       Value t = stack_at_inc(i);
216       tty-&gt;print(&quot;%2d  &quot;, i);
217       tty-&gt;print(&quot;%c%d &quot;, t-&gt;type()-&gt;tchar(), t-&gt;id());
218       ip.print_instr(t);
219       tty-&gt;cr();
220     }
221   }
222   if (!no_active_locks()) {
223     InstructionPrinter ip;
224     for (int i = 0; i &lt; locks_size(); i++) {
225       Value t = lock_at(i);
226       tty-&gt;print(&quot;lock %2d  &quot;, i);
227       if (t == NULL) {
228         tty-&gt;print(&quot;this&quot;);
229       } else {
230         tty-&gt;print(&quot;%c%d &quot;, t-&gt;type()-&gt;tchar(), t-&gt;id());
231         ip.print_instr(t);
232       }
233       tty-&gt;cr();
234     }
235   }
236   if (locals_size() &gt; 0) {
237     InstructionPrinter ip;
238     for (int i = 0; i &lt; locals_size();) {
239       Value l = _locals.at(i);
240       tty-&gt;print(&quot;local %d &quot;, i);
241       if (l == NULL) {
242         tty-&gt;print(&quot;null&quot;);
243         i ++;
244       } else {
245         tty-&gt;print(&quot;%c%d &quot;, l-&gt;type()-&gt;tchar(), l-&gt;id());
246         ip.print_instr(l);
247         if (l-&gt;type()-&gt;is_illegal() || l-&gt;type()-&gt;is_single_word()) i ++; else i += 2;
248       }
249       tty-&gt;cr();
250     }
251   }
252 
253   if (caller_state() != NULL) {
254     caller_state()-&gt;print();
255   }
256 }
257 
258 
259 void ValueStack::verify() {
260   assert(scope() != NULL, &quot;scope must exist&quot;);
261   if (caller_state() != NULL) {
262     assert(caller_state()-&gt;scope() == scope()-&gt;caller(), &quot;invalid caller scope&quot;);
263     caller_state()-&gt;verify();
264   }
265 
266   if (kind() == Parsing) {
267     assert(bci() == -99, &quot;bci not defined during parsing&quot;);
268   } else {
269     assert(bci() &gt;= -1, &quot;bci out of range&quot;);
270     assert(bci() &lt; scope()-&gt;method()-&gt;code_size(), &quot;bci out of range&quot;);
271     assert(bci() == SynchronizationEntryBCI || Bytecodes::is_defined(scope()-&gt;method()-&gt;java_code_at_bci(bci())), &quot;make sure bci points at a real bytecode&quot;);
272     assert(scope()-&gt;method()-&gt;liveness_at_bci(bci()).is_valid(), &quot;liveness at bci must be valid&quot;);
273   }
274 
275   int i;
276   for (i = 0; i &lt; stack_size(); i++) {
277     Value v = _stack.at(i);
278     if (v == NULL) {
279       assert(_stack.at(i - 1)-&gt;type()-&gt;is_double_word(), &quot;only hi-words are NULL on stack&quot;);
280     } else if (v-&gt;type()-&gt;is_double_word()) {
281       assert(_stack.at(i + 1) == NULL, &quot;hi-word must be NULL&quot;);
282     }
283   }
284 
285   for (i = 0; i &lt; locals_size(); i++) {
286     Value v = _locals.at(i);
287     if (v != NULL &amp;&amp; v-&gt;type()-&gt;is_double_word()) {
288       assert(_locals.at(i + 1) == NULL, &quot;hi-word must be NULL&quot;);
289     }
290   }
291 
292   for_each_state_value(this, v,
293     assert(v != NULL, &quot;just test if state-iteration succeeds&quot;);
294   );
295 }
296 #endif // PRODUCT
    </pre>
  </body>
</html>
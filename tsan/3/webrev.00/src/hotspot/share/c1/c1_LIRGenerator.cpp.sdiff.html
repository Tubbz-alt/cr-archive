<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciObjArray.hpp&quot;
  36 #include &quot;ci/ciUtilities.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;

  39 #include &quot;runtime/arguments.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/vm_version.hpp&quot;
  43 #include &quot;utilities/bitMap.inline.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;

  45 
  46 #ifdef ASSERT
  47 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  48 #else
  49 #define __ gen()-&gt;lir()-&gt;
  50 #endif
  51 
  52 #ifndef PATCHED_ADDR
  53 #define PATCHED_ADDR  (max_jint)
  54 #endif
  55 
  56 void PhiResolverState::reset() {
  57   _virtual_operands.clear();
  58   _other_operands.clear();
  59   _vreg_table.clear();
  60 }
  61 
  62 
  63 //--------------------------------------------------------------
  64 // PhiResolver
</pre>
<hr />
<pre>
 881   } else if (src_pos == dst_pos || is_constant_zero(dst_pos)) {
 882     // src and dest positions are the same, or dst is zero so assume
 883     // nonoverlapping copy.
 884     flags &amp;= ~LIR_OpArrayCopy::overlapping;
 885   }
 886 
 887   if (src == dst) {
 888     // moving within a single array so no type checks are needed
 889     if (flags &amp; LIR_OpArrayCopy::type_check) {
 890       flags &amp;= ~LIR_OpArrayCopy::type_check;
 891     }
 892   }
 893   *flagsp = flags;
 894   *expected_typep = (ciArrayKlass*)expected_type;
 895 }
 896 
 897 
 898 LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
 899   assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
 900 
<span class="line-modified"> 901   if (RoundFPResults &amp;&amp; UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {</span>
<span class="line-modified"> 902     LIR_Opr result = new_register(T_FLOAT);</span>
<span class="line-modified"> 903     set_vreg_flag(result, must_start_in_memory);</span>
<span class="line-modified"> 904     assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);</span>
<span class="line-modified"> 905     assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);</span>
<span class="line-modified"> 906     __ roundfp(opr, LIR_OprFact::illegalOpr, result);</span>
<span class="line-modified"> 907     return result;</span>






 908   }
 909   return opr;
 910 }
 911 
 912 
 913 LIR_Opr LIRGenerator::force_to_spill(LIR_Opr value, BasicType t) {
 914   assert(type2size[t] == type2size[value-&gt;type()],
 915          &quot;size mismatch: t=%s, value-&gt;type()=%s&quot;, type2name(t), type2name(value-&gt;type()));
 916   if (!value-&gt;is_register()) {
 917     // force into a register
 918     LIR_Opr r = new_register(value-&gt;type());
 919     __ move(value, r);
 920     value = r;
 921   }
 922 
 923   // create a spill location
 924   LIR_Opr tmp = new_register(t);
 925   set_vreg_flag(tmp, LIRGenerator::must_start_in_memory);
 926 
 927   // move from register to spill
</pre>
<hr />
<pre>
1283   // mirror = ((OopHandle)mirror)-&gt;resolve();
1284   access_load(IN_NATIVE, T_OBJECT,
1285               LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), result);
1286 }
1287 
1288 // java.lang.Class::isPrimitive()
1289 void LIRGenerator::do_isPrimitive(Intrinsic* x) {
1290   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1291 
1292   LIRItem rcvr(x-&gt;argument_at(0), this);
1293   rcvr.load_item();
1294   LIR_Opr temp = new_register(T_METADATA);
1295   LIR_Opr result = rlock_result(x);
1296 
1297   CodeEmitInfo* info = NULL;
1298   if (x-&gt;needs_null_check()) {
1299     info = state_for(x);
1300   }
1301 
1302   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);
<span class="line-modified">1303   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::intConst(0));</span>
1304   __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
1305 }
1306 
1307 
1308 // Example: Thread.currentThread()
1309 void LIRGenerator::do_currentThread(Intrinsic* x) {
1310   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
1311   LIR_Opr reg = rlock_result(x);
1312   __ move_wide(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_OBJECT), reg);
1313 }
1314 
1315 
1316 void LIRGenerator::do_RegisterFinalizer(Intrinsic* x) {
1317   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1318   LIRItem receiver(x-&gt;argument_at(0), this);
1319 
1320   receiver.load_item();
1321   BasicTypeList signature;
1322   signature.append(T_OBJECT); // receiver
1323   LIR_OprList* args = new LIR_OprList();
</pre>
<hr />
<pre>
1529     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
1530     __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
1531   }
1532 
1533   DecoratorSet decorators = IN_HEAP;
1534   if (is_volatile) {
1535     decorators |= MO_SEQ_CST;
1536   }
1537   if (needs_patching) {
1538     decorators |= C1_NEEDS_PATCHING;
1539   }
1540 
1541   access_store_at(decorators, field_type, object, LIR_OprFact::intConst(x-&gt;offset()),
1542                   value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);
1543 }
1544 
1545 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1546   assert(x-&gt;is_pinned(),&quot;&quot;);
1547   bool needs_range_check = x-&gt;compute_needs_range_check();
1548   bool use_length = x-&gt;length() != NULL;
<span class="line-modified">1549   bool obj_store = x-&gt;elt_type() == T_ARRAY || x-&gt;elt_type() == T_OBJECT;</span>
1550   bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||
1551                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||
1552                                          x-&gt;should_profile());
1553 
1554   LIRItem array(x-&gt;array(), this);
1555   LIRItem index(x-&gt;index(), this);
1556   LIRItem value(x-&gt;value(), this);
1557   LIRItem length(this);
1558 
1559   array.load_item();
1560   index.load_nonconstant();
1561 
1562   if (use_length &amp;&amp; needs_range_check) {
1563     length.set_instruction(x-&gt;length());
1564     length.load_item();
1565 
1566   }
1567   if (needs_store_check || x-&gt;check_boolean()) {
1568     value.load_item();
1569   } else {
</pre>
<hr />
<pre>
1933   }
1934 
1935   if (compilation()-&gt;env()-&gt;jvmti_can_post_on_exceptions()) {
1936     // we need to go through the exception lookup path to get JVMTI
1937     // notification done
1938     unwind = false;
1939   }
1940 
1941   // move exception oop into fixed register
1942   __ move(exception_opr, exceptionOopOpr());
1943 
1944   if (unwind) {
1945     __ unwind_exception(exceptionOopOpr());
1946   } else {
1947     __ throw_exception(exceptionPcOpr(), exceptionOopOpr(), info);
1948   }
1949 }
1950 
1951 
1952 void LIRGenerator::do_RoundFP(RoundFP* x) {


1953   LIRItem input(x-&gt;input(), this);
1954   input.load_item();
1955   LIR_Opr input_opr = input.result();
1956   assert(input_opr-&gt;is_register(), &quot;why round if value is not in a register?&quot;);
1957   assert(input_opr-&gt;is_single_fpu() || input_opr-&gt;is_double_fpu(), &quot;input should be floating-point value&quot;);
1958   if (input_opr-&gt;is_single_fpu()) {
1959     set_result(x, round_item(input_opr)); // This code path not currently taken
1960   } else {
1961     LIR_Opr result = new_register(T_DOUBLE);
1962     set_vreg_flag(result, must_start_in_memory);
1963     __ roundfp(input_opr, LIR_OprFact::illegalOpr, result);
1964     set_result(x, result);
1965   }
1966 }
1967 
1968 // Here UnsafeGetRaw may have x-&gt;base() and x-&gt;index() be int or long
1969 // on both 64 and 32 bits. Expecting x-&gt;base() to be always long on 64bit.
1970 void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {
1971   LIRItem base(x-&gt;base(), this);
1972   LIRItem idx(this);
</pre>
<hr />
<pre>
2146   __ move(value.result(), addr);
2147 }
2148 
2149 
2150 void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {
2151   BasicType type = x-&gt;basic_type();
2152   LIRItem src(x-&gt;object(), this);
2153   LIRItem off(x-&gt;offset(), this);
2154 
2155   off.load_item();
2156   src.load_item();
2157 
2158   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
2159 
2160   if (x-&gt;is_volatile()) {
2161     decorators |= MO_SEQ_CST;
2162   }
2163   if (type == T_BOOLEAN) {
2164     decorators |= C1_MASK_BOOLEAN;
2165   }
<span class="line-modified">2166   if (type == T_ARRAY || type == T_OBJECT) {</span>
2167     decorators |= ON_UNKNOWN_OOP_REF;
2168   }
2169 
2170   LIR_Opr result = rlock_result(x, type);
2171   access_load_at(decorators, type,
2172                  src, off.result(), result);
2173 }
2174 
2175 
2176 void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {
2177   BasicType type = x-&gt;basic_type();
2178   LIRItem src(x-&gt;object(), this);
2179   LIRItem off(x-&gt;offset(), this);
2180   LIRItem data(x-&gt;value(), this);
2181 
2182   src.load_item();
2183   if (type == T_BOOLEAN || type == T_BYTE) {
2184     data.load_byte_item();
2185   } else {
2186     data.load_item();
2187   }
2188   off.load_item();
2189 
2190   set_no_result(x);
2191 
2192   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
<span class="line-modified">2193   if (type == T_ARRAY || type == T_OBJECT) {</span>
2194     decorators |= ON_UNKNOWN_OOP_REF;
2195   }
2196   if (x-&gt;is_volatile()) {
2197     decorators |= MO_SEQ_CST;
2198   }
2199   access_store_at(decorators, type, src, off.result(), data.result());
2200 }
2201 
2202 void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
2203   BasicType type = x-&gt;basic_type();
2204   LIRItem src(x-&gt;object(), this);
2205   LIRItem off(x-&gt;offset(), this);
2206   LIRItem value(x-&gt;value(), this);
2207 
2208   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
2209 
<span class="line-modified">2210   if (type == T_ARRAY || type == T_OBJECT) {</span>
2211     decorators |= ON_UNKNOWN_OOP_REF;
2212   }
2213 
2214   LIR_Opr result;
2215   if (x-&gt;is_add()) {
2216     result = access_atomic_add_at(decorators, type, src, off, value);
2217   } else {
2218     result = access_atomic_xchg_at(decorators, type, src, off, value);
2219   }
2220   set_result(x, result);
2221 }
2222 
2223 void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
2224   int lng = x-&gt;length();
2225 
2226   for (int i = 0; i &lt; lng; i++) {
<span class="line-modified">2227     SwitchRange* one_range = x-&gt;at(i);</span>
2228     int low_key = one_range-&gt;low_key();
2229     int high_key = one_range-&gt;high_key();
2230     BlockBegin* dest = one_range-&gt;sux();
2231     if (low_key == high_key) {
2232       __ cmp(lir_cond_equal, value, low_key);
2233       __ branch(lir_cond_equal, T_INT, dest);
2234     } else if (high_key - low_key == 1) {
2235       __ cmp(lir_cond_equal, value, low_key);
2236       __ branch(lir_cond_equal, T_INT, dest);
2237       __ cmp(lir_cond_equal, value, high_key);
2238       __ branch(lir_cond_equal, T_INT, dest);
2239     } else {
2240       LabelObj* L = new LabelObj();
2241       __ cmp(lir_cond_less, value, low_key);
2242       __ branch(lir_cond_less, T_INT, L-&gt;label());
2243       __ cmp(lir_cond_lessEqual, value, high_key);
2244       __ branch(lir_cond_lessEqual, T_INT, dest);
2245       __ branch_destination(L-&gt;label());
2246     }
2247   }
2248   __ jump(default_sux);
2249 }
2250 
2251 
2252 SwitchRangeArray* LIRGenerator::create_lookup_ranges(TableSwitch* x) {
2253   SwitchRangeList* res = new SwitchRangeList();
2254   int len = x-&gt;length();
2255   if (len &gt; 0) {
2256     BlockBegin* sux = x-&gt;sux_at(0);
2257     int key = x-&gt;lo_key();
2258     BlockBegin* default_sux = x-&gt;default_sux();
<span class="line-modified">2259     SwitchRange* range = new SwitchRange(key, sux);</span>
2260     for (int i = 0; i &lt; len; i++, key++) {
2261       BlockBegin* new_sux = x-&gt;sux_at(i);
2262       if (sux == new_sux) {
2263         // still in same range
2264         range-&gt;set_high_key(key);
2265       } else {
2266         // skip tests which explicitly dispatch to the default
2267         if (sux != default_sux) {
2268           res-&gt;append(range);
2269         }
<span class="line-modified">2270         range = new SwitchRange(key, new_sux);</span>
2271       }
2272       sux = new_sux;
2273     }
2274     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2275   }
2276   return res;
2277 }
2278 
2279 
2280 // we expect the keys to be sorted by increasing value
2281 SwitchRangeArray* LIRGenerator::create_lookup_ranges(LookupSwitch* x) {
2282   SwitchRangeList* res = new SwitchRangeList();
2283   int len = x-&gt;length();
2284   if (len &gt; 0) {
2285     BlockBegin* default_sux = x-&gt;default_sux();
2286     int key = x-&gt;key_at(0);
2287     BlockBegin* sux = x-&gt;sux_at(0);
<span class="line-modified">2288     SwitchRange* range = new SwitchRange(key, sux);</span>
2289     for (int i = 1; i &lt; len; i++) {
2290       int new_key = x-&gt;key_at(i);
2291       BlockBegin* new_sux = x-&gt;sux_at(i);
2292       if (key+1 == new_key &amp;&amp; sux == new_sux) {
2293         // still in same range
2294         range-&gt;set_high_key(new_key);
2295       } else {
2296         // skip tests which explicitly dispatch to the default
2297         if (range-&gt;sux() != default_sux) {
2298           res-&gt;append(range);
2299         }
<span class="line-modified">2300         range = new SwitchRange(new_key, new_sux);</span>
2301       }
2302       key = new_key;
2303       sux = new_sux;
2304     }
2305     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2306   }
2307   return res;
2308 }
2309 
2310 
2311 void LIRGenerator::do_TableSwitch(TableSwitch* x) {
2312   LIRItem tag(x-&gt;tag(), this);
2313   tag.load_item();
2314   set_no_result(x);
2315 
2316   if (x-&gt;is_safepoint()) {
2317     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2318   }
2319 
2320   // move values into phi locations
</pre>
<hr />
<pre>
2583   __ profile_type(new LIR_Address(mdp, md_offset, T_METADATA),
2584                   value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);
2585   return result;
2586 }
2587 
2588 // profile parameters on entry to the root of the compilation
2589 void LIRGenerator::profile_parameters(Base* x) {
2590   if (compilation()-&gt;profile_parameters()) {
2591     CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
2592     ciMethodData* md = scope()-&gt;method()-&gt;method_data_or_null();
2593     assert(md != NULL, &quot;Sanity&quot;);
2594 
2595     if (md-&gt;parameters_type_data() != NULL) {
2596       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
2597       ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
2598       LIR_Opr mdp = LIR_OprFact::illegalOpr;
2599       for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
2600         LIR_Opr src = args-&gt;at(i);
2601         assert(!src-&gt;is_illegal(), &quot;check&quot;);
2602         BasicType t = src-&gt;type();
<span class="line-modified">2603         if (t == T_OBJECT || t == T_ARRAY) {</span>
2604           intptr_t profiled_k = parameters-&gt;type(j);
2605           Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
2606           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
2607                                         in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
2608                                         profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
2609           // If the profile is known statically set it once for all and do not emit any code
2610           if (exact != NULL) {
2611             md-&gt;set_parameter_type(j, exact);
2612           }
2613           j++;
2614         }
2615         java_index += type2size[t];
2616       }
2617     }
2618   }
2619 }
2620 
2621 void LIRGenerator::do_Base(Base* x) {
2622   __ std_entry(LIR_OprFact::illegalOpr);
2623   // Emit moves from physical registers / stack slots to virtual registers
</pre>
<hr />
<pre>
3262   }
3263 }
3264 
3265 void LIRGenerator::do_ProfileInvoke(ProfileInvoke* x) {
3266   // We can safely ignore accessors here, since c2 will inline them anyway,
3267   // accessors are also always mature.
3268   if (!x-&gt;inlinee()-&gt;is_accessor()) {
3269     CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
3270     // Notify the runtime very infrequently only to take care of counter overflows
3271     int freq_log = Tier23InlineeNotifyFreqLog;
3272     double scale;
3273     if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3274       freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3275     }
3276     increment_event_counter_impl(info, x-&gt;inlinee(), LIR_OprFact::intConst(InvocationCounter::count_increment), right_n_bits(freq_log), InvocationEntryBci, false, true);
3277   }
3278 }
3279 
3280 void LIRGenerator::increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci) {
3281   if (compilation()-&gt;count_backedges()) {






3282     __ cmp(cond, left, right);

3283     LIR_Opr step = new_register(T_INT);
3284     LIR_Opr plus_one = LIR_OprFact::intConst(InvocationCounter::count_increment);
3285     LIR_Opr zero = LIR_OprFact::intConst(0);
3286     __ cmove(cond,
3287         (left_bci &lt; bci) ? plus_one : zero,
3288         (right_bci &lt; bci) ? plus_one : zero,
3289         step, left-&gt;type());
3290     increment_backedge_counter(info, step, bci);
3291   }
3292 }
3293 
3294 
3295 void LIRGenerator::increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge) {
3296   int freq_log = 0;
3297   int level = compilation()-&gt;env()-&gt;comp_level();
3298   if (level == CompLevel_limited_profile) {
3299     freq_log = (backedge ? Tier2BackedgeNotifyFreqLog : Tier2InvokeNotifyFreqLog);
3300   } else if (level == CompLevel_full_profile) {
3301     freq_log = (backedge ? Tier3BackedgeNotifyFreqLog : Tier3InvokeNotifyFreqLog);
3302   } else {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciObjArray.hpp&quot;
  36 #include &quot;ci/ciUtilities.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
<span class="line-added">  39 #include &quot;oops/klass.inline.hpp&quot;</span>
  40 #include &quot;runtime/arguments.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;
  45 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  46 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  47 
  48 #ifdef ASSERT
  49 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  50 #else
  51 #define __ gen()-&gt;lir()-&gt;
  52 #endif
  53 
  54 #ifndef PATCHED_ADDR
  55 #define PATCHED_ADDR  (max_jint)
  56 #endif
  57 
  58 void PhiResolverState::reset() {
  59   _virtual_operands.clear();
  60   _other_operands.clear();
  61   _vreg_table.clear();
  62 }
  63 
  64 
  65 //--------------------------------------------------------------
  66 // PhiResolver
</pre>
<hr />
<pre>
 883   } else if (src_pos == dst_pos || is_constant_zero(dst_pos)) {
 884     // src and dest positions are the same, or dst is zero so assume
 885     // nonoverlapping copy.
 886     flags &amp;= ~LIR_OpArrayCopy::overlapping;
 887   }
 888 
 889   if (src == dst) {
 890     // moving within a single array so no type checks are needed
 891     if (flags &amp; LIR_OpArrayCopy::type_check) {
 892       flags &amp;= ~LIR_OpArrayCopy::type_check;
 893     }
 894   }
 895   *flagsp = flags;
 896   *expected_typep = (ciArrayKlass*)expected_type;
 897 }
 898 
 899 
 900 LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
 901   assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
 902 
<span class="line-modified"> 903   if (strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified"> 904 #ifdef IA32</span>
<span class="line-modified"> 905     if (UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {</span>
<span class="line-modified"> 906       LIR_Opr result = new_register(T_FLOAT);</span>
<span class="line-modified"> 907       set_vreg_flag(result, must_start_in_memory);</span>
<span class="line-modified"> 908       assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);</span>
<span class="line-modified"> 909       assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);</span>
<span class="line-added"> 910       __ roundfp(opr, LIR_OprFact::illegalOpr, result);</span>
<span class="line-added"> 911       return result;</span>
<span class="line-added"> 912     }</span>
<span class="line-added"> 913 #else</span>
<span class="line-added"> 914     Unimplemented();</span>
<span class="line-added"> 915 #endif // IA32</span>
 916   }
 917   return opr;
 918 }
 919 
 920 
 921 LIR_Opr LIRGenerator::force_to_spill(LIR_Opr value, BasicType t) {
 922   assert(type2size[t] == type2size[value-&gt;type()],
 923          &quot;size mismatch: t=%s, value-&gt;type()=%s&quot;, type2name(t), type2name(value-&gt;type()));
 924   if (!value-&gt;is_register()) {
 925     // force into a register
 926     LIR_Opr r = new_register(value-&gt;type());
 927     __ move(value, r);
 928     value = r;
 929   }
 930 
 931   // create a spill location
 932   LIR_Opr tmp = new_register(t);
 933   set_vreg_flag(tmp, LIRGenerator::must_start_in_memory);
 934 
 935   // move from register to spill
</pre>
<hr />
<pre>
1291   // mirror = ((OopHandle)mirror)-&gt;resolve();
1292   access_load(IN_NATIVE, T_OBJECT,
1293               LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), result);
1294 }
1295 
1296 // java.lang.Class::isPrimitive()
1297 void LIRGenerator::do_isPrimitive(Intrinsic* x) {
1298   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1299 
1300   LIRItem rcvr(x-&gt;argument_at(0), this);
1301   rcvr.load_item();
1302   LIR_Opr temp = new_register(T_METADATA);
1303   LIR_Opr result = rlock_result(x);
1304 
1305   CodeEmitInfo* info = NULL;
1306   if (x-&gt;needs_null_check()) {
1307     info = state_for(x);
1308   }
1309 
1310   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);
<span class="line-modified">1311   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));</span>
1312   __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
1313 }
1314 
1315 
1316 // Example: Thread.currentThread()
1317 void LIRGenerator::do_currentThread(Intrinsic* x) {
1318   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
1319   LIR_Opr reg = rlock_result(x);
1320   __ move_wide(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_OBJECT), reg);
1321 }
1322 
1323 
1324 void LIRGenerator::do_RegisterFinalizer(Intrinsic* x) {
1325   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1326   LIRItem receiver(x-&gt;argument_at(0), this);
1327 
1328   receiver.load_item();
1329   BasicTypeList signature;
1330   signature.append(T_OBJECT); // receiver
1331   LIR_OprList* args = new LIR_OprList();
</pre>
<hr />
<pre>
1537     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
1538     __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
1539   }
1540 
1541   DecoratorSet decorators = IN_HEAP;
1542   if (is_volatile) {
1543     decorators |= MO_SEQ_CST;
1544   }
1545   if (needs_patching) {
1546     decorators |= C1_NEEDS_PATCHING;
1547   }
1548 
1549   access_store_at(decorators, field_type, object, LIR_OprFact::intConst(x-&gt;offset()),
1550                   value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);
1551 }
1552 
1553 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1554   assert(x-&gt;is_pinned(),&quot;&quot;);
1555   bool needs_range_check = x-&gt;compute_needs_range_check();
1556   bool use_length = x-&gt;length() != NULL;
<span class="line-modified">1557   bool obj_store = is_reference_type(x-&gt;elt_type());</span>
1558   bool needs_store_check = obj_store &amp;&amp; (x-&gt;value()-&gt;as_Constant() == NULL ||
1559                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object() ||
1560                                          x-&gt;should_profile());
1561 
1562   LIRItem array(x-&gt;array(), this);
1563   LIRItem index(x-&gt;index(), this);
1564   LIRItem value(x-&gt;value(), this);
1565   LIRItem length(this);
1566 
1567   array.load_item();
1568   index.load_nonconstant();
1569 
1570   if (use_length &amp;&amp; needs_range_check) {
1571     length.set_instruction(x-&gt;length());
1572     length.load_item();
1573 
1574   }
1575   if (needs_store_check || x-&gt;check_boolean()) {
1576     value.load_item();
1577   } else {
</pre>
<hr />
<pre>
1941   }
1942 
1943   if (compilation()-&gt;env()-&gt;jvmti_can_post_on_exceptions()) {
1944     // we need to go through the exception lookup path to get JVMTI
1945     // notification done
1946     unwind = false;
1947   }
1948 
1949   // move exception oop into fixed register
1950   __ move(exception_opr, exceptionOopOpr());
1951 
1952   if (unwind) {
1953     __ unwind_exception(exceptionOopOpr());
1954   } else {
1955     __ throw_exception(exceptionPcOpr(), exceptionOopOpr(), info);
1956   }
1957 }
1958 
1959 
1960 void LIRGenerator::do_RoundFP(RoundFP* x) {
<span class="line-added">1961   assert(strict_fp_requires_explicit_rounding, &quot;not required&quot;);</span>
<span class="line-added">1962 </span>
1963   LIRItem input(x-&gt;input(), this);
1964   input.load_item();
1965   LIR_Opr input_opr = input.result();
1966   assert(input_opr-&gt;is_register(), &quot;why round if value is not in a register?&quot;);
1967   assert(input_opr-&gt;is_single_fpu() || input_opr-&gt;is_double_fpu(), &quot;input should be floating-point value&quot;);
1968   if (input_opr-&gt;is_single_fpu()) {
1969     set_result(x, round_item(input_opr)); // This code path not currently taken
1970   } else {
1971     LIR_Opr result = new_register(T_DOUBLE);
1972     set_vreg_flag(result, must_start_in_memory);
1973     __ roundfp(input_opr, LIR_OprFact::illegalOpr, result);
1974     set_result(x, result);
1975   }
1976 }
1977 
1978 // Here UnsafeGetRaw may have x-&gt;base() and x-&gt;index() be int or long
1979 // on both 64 and 32 bits. Expecting x-&gt;base() to be always long on 64bit.
1980 void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {
1981   LIRItem base(x-&gt;base(), this);
1982   LIRItem idx(this);
</pre>
<hr />
<pre>
2156   __ move(value.result(), addr);
2157 }
2158 
2159 
2160 void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {
2161   BasicType type = x-&gt;basic_type();
2162   LIRItem src(x-&gt;object(), this);
2163   LIRItem off(x-&gt;offset(), this);
2164 
2165   off.load_item();
2166   src.load_item();
2167 
2168   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
2169 
2170   if (x-&gt;is_volatile()) {
2171     decorators |= MO_SEQ_CST;
2172   }
2173   if (type == T_BOOLEAN) {
2174     decorators |= C1_MASK_BOOLEAN;
2175   }
<span class="line-modified">2176   if (is_reference_type(type)) {</span>
2177     decorators |= ON_UNKNOWN_OOP_REF;
2178   }
2179 
2180   LIR_Opr result = rlock_result(x, type);
2181   access_load_at(decorators, type,
2182                  src, off.result(), result);
2183 }
2184 
2185 
2186 void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {
2187   BasicType type = x-&gt;basic_type();
2188   LIRItem src(x-&gt;object(), this);
2189   LIRItem off(x-&gt;offset(), this);
2190   LIRItem data(x-&gt;value(), this);
2191 
2192   src.load_item();
2193   if (type == T_BOOLEAN || type == T_BYTE) {
2194     data.load_byte_item();
2195   } else {
2196     data.load_item();
2197   }
2198   off.load_item();
2199 
2200   set_no_result(x);
2201 
2202   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
<span class="line-modified">2203   if (is_reference_type(type)) {</span>
2204     decorators |= ON_UNKNOWN_OOP_REF;
2205   }
2206   if (x-&gt;is_volatile()) {
2207     decorators |= MO_SEQ_CST;
2208   }
2209   access_store_at(decorators, type, src, off.result(), data.result());
2210 }
2211 
2212 void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
2213   BasicType type = x-&gt;basic_type();
2214   LIRItem src(x-&gt;object(), this);
2215   LIRItem off(x-&gt;offset(), this);
2216   LIRItem value(x-&gt;value(), this);
2217 
2218   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
2219 
<span class="line-modified">2220   if (is_reference_type(type)) {</span>
2221     decorators |= ON_UNKNOWN_OOP_REF;
2222   }
2223 
2224   LIR_Opr result;
2225   if (x-&gt;is_add()) {
2226     result = access_atomic_add_at(decorators, type, src, off, value);
2227   } else {
2228     result = access_atomic_xchg_at(decorators, type, src, off, value);
2229   }
2230   set_result(x, result);
2231 }
2232 
2233 void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
2234   int lng = x-&gt;length();
2235 
2236   for (int i = 0; i &lt; lng; i++) {
<span class="line-modified">2237     C1SwitchRange* one_range = x-&gt;at(i);</span>
2238     int low_key = one_range-&gt;low_key();
2239     int high_key = one_range-&gt;high_key();
2240     BlockBegin* dest = one_range-&gt;sux();
2241     if (low_key == high_key) {
2242       __ cmp(lir_cond_equal, value, low_key);
2243       __ branch(lir_cond_equal, T_INT, dest);
2244     } else if (high_key - low_key == 1) {
2245       __ cmp(lir_cond_equal, value, low_key);
2246       __ branch(lir_cond_equal, T_INT, dest);
2247       __ cmp(lir_cond_equal, value, high_key);
2248       __ branch(lir_cond_equal, T_INT, dest);
2249     } else {
2250       LabelObj* L = new LabelObj();
2251       __ cmp(lir_cond_less, value, low_key);
2252       __ branch(lir_cond_less, T_INT, L-&gt;label());
2253       __ cmp(lir_cond_lessEqual, value, high_key);
2254       __ branch(lir_cond_lessEqual, T_INT, dest);
2255       __ branch_destination(L-&gt;label());
2256     }
2257   }
2258   __ jump(default_sux);
2259 }
2260 
2261 
2262 SwitchRangeArray* LIRGenerator::create_lookup_ranges(TableSwitch* x) {
2263   SwitchRangeList* res = new SwitchRangeList();
2264   int len = x-&gt;length();
2265   if (len &gt; 0) {
2266     BlockBegin* sux = x-&gt;sux_at(0);
2267     int key = x-&gt;lo_key();
2268     BlockBegin* default_sux = x-&gt;default_sux();
<span class="line-modified">2269     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
2270     for (int i = 0; i &lt; len; i++, key++) {
2271       BlockBegin* new_sux = x-&gt;sux_at(i);
2272       if (sux == new_sux) {
2273         // still in same range
2274         range-&gt;set_high_key(key);
2275       } else {
2276         // skip tests which explicitly dispatch to the default
2277         if (sux != default_sux) {
2278           res-&gt;append(range);
2279         }
<span class="line-modified">2280         range = new C1SwitchRange(key, new_sux);</span>
2281       }
2282       sux = new_sux;
2283     }
2284     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2285   }
2286   return res;
2287 }
2288 
2289 
2290 // we expect the keys to be sorted by increasing value
2291 SwitchRangeArray* LIRGenerator::create_lookup_ranges(LookupSwitch* x) {
2292   SwitchRangeList* res = new SwitchRangeList();
2293   int len = x-&gt;length();
2294   if (len &gt; 0) {
2295     BlockBegin* default_sux = x-&gt;default_sux();
2296     int key = x-&gt;key_at(0);
2297     BlockBegin* sux = x-&gt;sux_at(0);
<span class="line-modified">2298     C1SwitchRange* range = new C1SwitchRange(key, sux);</span>
2299     for (int i = 1; i &lt; len; i++) {
2300       int new_key = x-&gt;key_at(i);
2301       BlockBegin* new_sux = x-&gt;sux_at(i);
2302       if (key+1 == new_key &amp;&amp; sux == new_sux) {
2303         // still in same range
2304         range-&gt;set_high_key(new_key);
2305       } else {
2306         // skip tests which explicitly dispatch to the default
2307         if (range-&gt;sux() != default_sux) {
2308           res-&gt;append(range);
2309         }
<span class="line-modified">2310         range = new C1SwitchRange(new_key, new_sux);</span>
2311       }
2312       key = new_key;
2313       sux = new_sux;
2314     }
2315     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2316   }
2317   return res;
2318 }
2319 
2320 
2321 void LIRGenerator::do_TableSwitch(TableSwitch* x) {
2322   LIRItem tag(x-&gt;tag(), this);
2323   tag.load_item();
2324   set_no_result(x);
2325 
2326   if (x-&gt;is_safepoint()) {
2327     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2328   }
2329 
2330   // move values into phi locations
</pre>
<hr />
<pre>
2593   __ profile_type(new LIR_Address(mdp, md_offset, T_METADATA),
2594                   value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);
2595   return result;
2596 }
2597 
2598 // profile parameters on entry to the root of the compilation
2599 void LIRGenerator::profile_parameters(Base* x) {
2600   if (compilation()-&gt;profile_parameters()) {
2601     CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
2602     ciMethodData* md = scope()-&gt;method()-&gt;method_data_or_null();
2603     assert(md != NULL, &quot;Sanity&quot;);
2604 
2605     if (md-&gt;parameters_type_data() != NULL) {
2606       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
2607       ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
2608       LIR_Opr mdp = LIR_OprFact::illegalOpr;
2609       for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
2610         LIR_Opr src = args-&gt;at(i);
2611         assert(!src-&gt;is_illegal(), &quot;check&quot;);
2612         BasicType t = src-&gt;type();
<span class="line-modified">2613         if (is_reference_type(t)) {</span>
2614           intptr_t profiled_k = parameters-&gt;type(j);
2615           Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
2616           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
2617                                         in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
2618                                         profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
2619           // If the profile is known statically set it once for all and do not emit any code
2620           if (exact != NULL) {
2621             md-&gt;set_parameter_type(j, exact);
2622           }
2623           j++;
2624         }
2625         java_index += type2size[t];
2626       }
2627     }
2628   }
2629 }
2630 
2631 void LIRGenerator::do_Base(Base* x) {
2632   __ std_entry(LIR_OprFact::illegalOpr);
2633   // Emit moves from physical registers / stack slots to virtual registers
</pre>
<hr />
<pre>
3272   }
3273 }
3274 
3275 void LIRGenerator::do_ProfileInvoke(ProfileInvoke* x) {
3276   // We can safely ignore accessors here, since c2 will inline them anyway,
3277   // accessors are also always mature.
3278   if (!x-&gt;inlinee()-&gt;is_accessor()) {
3279     CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
3280     // Notify the runtime very infrequently only to take care of counter overflows
3281     int freq_log = Tier23InlineeNotifyFreqLog;
3282     double scale;
3283     if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3284       freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3285     }
3286     increment_event_counter_impl(info, x-&gt;inlinee(), LIR_OprFact::intConst(InvocationCounter::count_increment), right_n_bits(freq_log), InvocationEntryBci, false, true);
3287   }
3288 }
3289 
3290 void LIRGenerator::increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci) {
3291   if (compilation()-&gt;count_backedges()) {
<span class="line-added">3292 #if defined(X86) &amp;&amp; !defined(_LP64)</span>
<span class="line-added">3293     // BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.</span>
<span class="line-added">3294     LIR_Opr left_copy = new_register(left-&gt;type());</span>
<span class="line-added">3295     __ move(left, left_copy);</span>
<span class="line-added">3296     __ cmp(cond, left_copy, right);</span>
<span class="line-added">3297 #else</span>
3298     __ cmp(cond, left, right);
<span class="line-added">3299 #endif</span>
3300     LIR_Opr step = new_register(T_INT);
3301     LIR_Opr plus_one = LIR_OprFact::intConst(InvocationCounter::count_increment);
3302     LIR_Opr zero = LIR_OprFact::intConst(0);
3303     __ cmove(cond,
3304         (left_bci &lt; bci) ? plus_one : zero,
3305         (right_bci &lt; bci) ? plus_one : zero,
3306         step, left-&gt;type());
3307     increment_backedge_counter(info, step, bci);
3308   }
3309 }
3310 
3311 
3312 void LIRGenerator::increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge) {
3313   int freq_log = 0;
3314   int level = compilation()-&gt;env()-&gt;comp_level();
3315   if (level == CompLevel_limited_profile) {
3316     freq_log = (backedge ? Tier2BackedgeNotifyFreqLog : Tier2InvokeNotifyFreqLog);
3317   } else if (level == CompLevel_full_profile) {
3318     freq_log = (backedge ? Tier3BackedgeNotifyFreqLog : Tier3InvokeNotifyFreqLog);
3319   } else {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Compilation.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_COMPILATION_HPP
 26 #define SHARE_C1_C1_COMPILATION_HPP
 27 
 28 #include &quot;ci/ciEnv.hpp&quot;
 29 #include &quot;ci/ciMethodData.hpp&quot;
 30 #include &quot;code/exceptionHandlerTable.hpp&quot;
 31 #include &quot;compiler/compilerDirectives.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;runtime/deoptimization.hpp&quot;
 34 
 35 class CompilationResourceObj;
 36 class XHandlers;
 37 class ExceptionInfo;
 38 class DebugInformationRecorder;
 39 class FrameMap;
 40 class IR;
 41 class IRScope;
 42 class Instruction;
 43 class LinearScan;
 44 class OopMap;
 45 class LIR_Emitter;
 46 class LIR_Assembler;
 47 class CodeEmitInfo;
 48 class ciEnv;
 49 class ciMethod;
 50 class ValueStack;
 51 class LIR_OprDesc;
 52 class C1_MacroAssembler;
 53 class CFGPrinter;
 54 class CFGPrinterOutput;
 55 typedef LIR_OprDesc* LIR_Opr;
 56 
 57 typedef GrowableArray&lt;BasicType&gt; BasicTypeArray;
 58 typedef GrowableArray&lt;BasicType&gt; BasicTypeList;
 59 typedef GrowableArray&lt;ExceptionInfo*&gt; ExceptionInfoList;
 60 
 61 class Compilation: public StackObj {
 62   friend class CompilationResourceObj;
 63  private:
 64   // compilation specifics
 65   Arena* _arena;
 66   int _next_id;
 67   int _next_block_id;
 68   AbstractCompiler*  _compiler;
 69   DirectiveSet*      _directive;
 70   ciEnv*             _env;
 71   CompileLog*        _log;
 72   ciMethod*          _method;
 73   int                _osr_bci;
 74   IR*                _hir;
 75   int                _max_spills;
 76   FrameMap*          _frame_map;
 77   C1_MacroAssembler* _masm;
 78   bool               _has_exception_handlers;
 79   bool               _has_fpu_code;
 80   bool               _has_unsafe_access;
 81   bool               _would_profile;
 82   bool               _has_method_handle_invokes;  // True if this method has MethodHandle invokes.
 83   bool               _has_reserved_stack_access;
 84   const char*        _bailout_msg;
 85   ExceptionInfoList* _exception_info_list;
 86   ExceptionHandlerTable _exception_handler_table;
 87   ImplicitExceptionTable _implicit_exception_table;
 88   LinearScan*        _allocator;
 89   CodeOffsets        _offsets;
 90   CodeBuffer         _code;
 91   bool               _has_access_indexed;
 92   int                _interpreter_frame_size; // Stack space needed in case of a deoptimization
 93 
 94   // compilation helpers
 95   void initialize();
 96   void build_hir();
 97   void emit_lir();
 98 
 99   void emit_code_epilog(LIR_Assembler* assembler);
100   int  emit_code_body();
101 
102   int  compile_java_method();
103   void install_code(int frame_size);
104   void compile_method();
105 
106   void generate_exception_handler_table();
107 
108   ExceptionInfoList* exception_info_list() const { return _exception_info_list; }
109   ExceptionHandlerTable* exception_handler_table() { return &amp;_exception_handler_table; }
110 
111   LinearScan* allocator()                          { return _allocator;      }
112   void        set_allocator(LinearScan* allocator) { _allocator = allocator; }
113 
114   Instruction*       _current_instruction;       // the instruction currently being processed
115 #ifndef PRODUCT
116   Instruction*       _last_instruction_printed;  // the last instruction printed during traversal
117   CFGPrinterOutput*  _cfg_printer_output;
118 #endif // PRODUCT
119 
120  public:
121   // creation
122   Compilation(AbstractCompiler* compiler, ciEnv* env, ciMethod* method,
123               int osr_bci, BufferBlob* buffer_blob, DirectiveSet* directive);
124   ~Compilation();
125 
126 
127   static Compilation* current() {
128     return (Compilation*) ciEnv::current()-&gt;compiler_data();
129   }
130 
131   // accessors
132   ciEnv* env() const                             { return _env; }
133   DirectiveSet* directive() const                { return _directive; }
134   CompileLog* log() const                        { return _log; }
135   AbstractCompiler* compiler() const             { return _compiler; }
136   bool has_exception_handlers() const            { return _has_exception_handlers; }
137   bool has_fpu_code() const                      { return _has_fpu_code; }
138   bool has_unsafe_access() const                 { return _has_unsafe_access; }
139   int max_vector_size() const                    { return 0; }
140   ciMethod* method() const                       { return _method; }
141   int osr_bci() const                            { return _osr_bci; }
142   bool is_osr_compile() const                    { return osr_bci() &gt;= 0; }
143   IR* hir() const                                { return _hir; }
144   int max_spills() const                         { return _max_spills; }
145   FrameMap* frame_map() const                    { return _frame_map; }
146   CodeBuffer* code()                             { return &amp;_code; }
147   C1_MacroAssembler* masm() const                { return _masm; }
148   CodeOffsets* offsets()                         { return &amp;_offsets; }
149   Arena* arena()                                 { return _arena; }
150   bool has_access_indexed()                      { return _has_access_indexed; }
151 
152   // Instruction ids
153   int get_next_id()                              { return _next_id++; }
154   int number_of_instructions() const             { return _next_id; }
155 
156   // BlockBegin ids
157   int get_next_block_id()                        { return _next_block_id++; }
158   int number_of_blocks() const                   { return _next_block_id; }
159 
160   // setters
161   void set_has_exception_handlers(bool f)        { _has_exception_handlers = f; }
162   void set_has_fpu_code(bool f)                  { _has_fpu_code = f; }
163   void set_has_unsafe_access(bool f)             { _has_unsafe_access = f; }
164   void set_would_profile(bool f)                 { _would_profile = f; }
165   void set_has_access_indexed(bool f)            { _has_access_indexed = f; }
166   // Add a set of exception handlers covering the given PC offset
167   void add_exception_handlers_for_pco(int pco, XHandlers* exception_handlers);
168   // Statistics gathering
169   void notice_inlined_method(ciMethod* method);
170 
171   // JSR 292
172   bool     has_method_handle_invokes() const { return _has_method_handle_invokes;     }
173   void set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
174 
175   bool     has_reserved_stack_access() const { return _has_reserved_stack_access; }
176   void set_has_reserved_stack_access(bool z) { _has_reserved_stack_access = z; }
177 
178   DebugInformationRecorder* debug_info_recorder() const; // = _env-&gt;debug_info();
179   Dependencies* dependency_recorder() const; // = _env-&gt;dependencies()
180   ImplicitExceptionTable* implicit_exception_table()     { return &amp;_implicit_exception_table; }
181 
182   Instruction* current_instruction() const       { return _current_instruction; }
183   Instruction* set_current_instruction(Instruction* instr) {
184     Instruction* previous = _current_instruction;
185     _current_instruction = instr;
186     return previous;
187   }
188 
189 #ifndef PRODUCT
190   void maybe_print_current_instruction();
191   CFGPrinterOutput* cfg_printer_output() {
192     guarantee(_cfg_printer_output != NULL, &quot;CFG printer output not initialized&quot;);
193     return _cfg_printer_output;
194   }
195 #endif // PRODUCT
196 
197   // error handling
198   void bailout(const char* msg);
199   bool bailed_out() const                        { return _bailout_msg != NULL; }
200   const char* bailout_msg() const                { return _bailout_msg; }
201 
202   static int desired_max_code_buffer_size() {
203     return (int)NMethodSizeLimit;  // default 64K
204   }
205   static int desired_max_constant_size() {
206     return desired_max_code_buffer_size() / 10;
207   }
208 
209   static bool setup_code_buffer(CodeBuffer* cb, int call_stub_estimate);
210 
211   // timers
212   static void print_timers();
213 
214 #ifndef PRODUCT
215   // debugging support.
216   // produces a file named c1compileonly in the current directory with
217   // directives to compile only the current method and it&#39;s inlines.
218   // The file can be passed to the command line option -XX:Flags=&lt;filename&gt;
219   void compile_only_this_method();
220   void compile_only_this_scope(outputStream* st, IRScope* scope);
221   void exclude_this_method();
222 #endif // PRODUCT
223 
224   bool is_profiling() {
225     return env()-&gt;comp_level() == CompLevel_full_profile ||
226            env()-&gt;comp_level() == CompLevel_limited_profile;
227   }
228   bool count_invocations() { return is_profiling(); }
229   bool count_backedges()   { return is_profiling(); }
230 
231   // Helpers for generation of profile information
232   bool profile_branches() {
233     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
234       C1UpdateMethodData &amp;&amp; C1ProfileBranches;
235   }
236   bool profile_calls() {
237     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
238       C1UpdateMethodData &amp;&amp; C1ProfileCalls;
239   }
240   bool profile_inlined_calls() {
241     return profile_calls() &amp;&amp; C1ProfileInlinedCalls;
242   }
243   bool profile_checkcasts() {
244     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
245       C1UpdateMethodData &amp;&amp; C1ProfileCheckcasts;
246   }
247   bool profile_parameters() {
248     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
249       C1UpdateMethodData &amp;&amp; MethodData::profile_parameters();
250   }
251   bool profile_arguments() {
252     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
253       C1UpdateMethodData &amp;&amp; MethodData::profile_arguments();
254   }
255   bool profile_return() {
256     return env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp;
257       C1UpdateMethodData &amp;&amp; MethodData::profile_return();
258   }
259   bool age_code() const {
260     return _method-&gt;profile_aging();
261   }
262 
263   // will compilation make optimistic assumptions that might lead to
264   // deoptimization and that the runtime will account for?
265   bool is_optimistic() const                             {
266     return !TieredCompilation &amp;&amp;
267       (RangeCheckElimination || UseLoopInvariantCodeMotion) &amp;&amp;
268       method()-&gt;method_data()-&gt;trap_count(Deoptimization::Reason_none) == 0;
269   }
270 
271   ciKlass* cha_exact_type(ciType* type);
272 
273   // Dump inlining replay data to the stream.
274   void dump_inline_data(outputStream* out) { /* do nothing now */ }
275 
276   // How much stack space would the interpreter need in case of a
277   // deoptimization (worst case)
278   void update_interpreter_frame_size(int size) {
279     if (_interpreter_frame_size &lt; size) {
280       _interpreter_frame_size = size;
281     }
282   }
283 
284   int interpreter_frame_size() const {
285     return _interpreter_frame_size;
286   }
287 };
288 
289 
290 // Macro definitions for unified bailout-support
291 // The methods bailout() and bailed_out() are present in all classes
292 // that might bailout, but forward all calls to Compilation
293 #define BAILOUT(msg)               { bailout(msg); return;              }
294 #define BAILOUT_(msg, res)         { bailout(msg); return res;          }
295 
296 #define CHECK_BAILOUT()            { if (bailed_out()) return;          }
297 #define CHECK_BAILOUT_(res)        { if (bailed_out()) return res;      }
298 
<a name="1" id="anc1"></a>




299 
300 class InstructionMark: public StackObj {
301  private:
302   Compilation* _compilation;
303   Instruction*  _previous;
304 
305  public:
306   InstructionMark(Compilation* compilation, Instruction* instr) {
307     _compilation = compilation;
308     _previous = _compilation-&gt;set_current_instruction(instr);
309   }
310   ~InstructionMark() {
311     _compilation-&gt;set_current_instruction(_previous);
312   }
313 };
314 
315 
316 //----------------------------------------------------------------------
317 // Base class for objects allocated by the compiler in the compilation arena
318 class CompilationResourceObj ALLOCATION_SUPER_CLASS_SPEC {
319  public:
320   void* operator new(size_t size) throw() { return Compilation::current()-&gt;arena()-&gt;Amalloc(size); }
321   void* operator new(size_t size, Arena* arena) throw() {
322     return arena-&gt;Amalloc(size);
323   }
324   void  operator delete(void* p) {} // nothing to do
325 };
326 
327 
328 //----------------------------------------------------------------------
329 // Class for aggregating exception handler information.
330 
331 // Effectively extends XHandlers class with PC offset of
332 // potentially exception-throwing instruction.
333 // This class is used at the end of the compilation to build the
334 // ExceptionHandlerTable.
335 class ExceptionInfo: public CompilationResourceObj {
336  private:
337   int             _pco;                // PC of potentially exception-throwing instruction
338   XHandlers*      _exception_handlers; // flat list of exception handlers covering this PC
339 
340  public:
341   ExceptionInfo(int pco, XHandlers* exception_handlers)
342     : _pco(pco)
343     , _exception_handlers(exception_handlers)
344   { }
345 
346   int pco()                                      { return _pco; }
347   XHandlers* exception_handlers()                { return _exception_handlers; }
348 };
349 
350 #endif // SHARE_C1_C1_COMPILATION_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
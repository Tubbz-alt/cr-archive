<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRAssembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/assembler.inline.hpp&quot;
 27 #include &quot;c1/c1_Compilation.hpp&quot;
 28 #include &quot;c1/c1_Instruction.hpp&quot;
 29 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 31 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 32 #include &quot;c1/c1_ValueStack.hpp&quot;
 33 #include &quot;ci/ciInstance.hpp&quot;
 34 #include &quot;gc/shared/barrierSet.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
 36 
 37 void LIR_Assembler::patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info) {
 38   // We must have enough patching space so that call can be inserted.
 39   // We cannot use fat nops here, since the concurrent code rewrite may transiently
 40   // create the illegal instruction sequence.
 41   while ((intx) _masm-&gt;pc() - (intx) patch-&gt;pc_start() &lt; NativeGeneralJump::instruction_size) {
 42     _masm-&gt;nop();
 43   }
 44   patch-&gt;install(_masm, patch_code, obj, info);
 45   append_code_stub(patch);
 46 
 47 #ifdef ASSERT
 48   Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
 49   if (patch-&gt;id() == PatchingStub::access_field_id) {
 50     switch (code) {
 51       case Bytecodes::_putstatic:
 52       case Bytecodes::_getstatic:
 53       case Bytecodes::_putfield:
 54       case Bytecodes::_getfield:
 55         break;
 56       default:
 57         ShouldNotReachHere();
 58     }
 59   } else if (patch-&gt;id() == PatchingStub::load_klass_id) {
 60     switch (code) {
 61       case Bytecodes::_new:
 62       case Bytecodes::_anewarray:
 63       case Bytecodes::_multianewarray:
 64       case Bytecodes::_instanceof:
 65       case Bytecodes::_checkcast:
 66         break;
 67       default:
 68         ShouldNotReachHere();
 69     }
 70   } else if (patch-&gt;id() == PatchingStub::load_mirror_id) {
 71     switch (code) {
 72       case Bytecodes::_putstatic:
 73       case Bytecodes::_getstatic:
 74       case Bytecodes::_ldc:
 75       case Bytecodes::_ldc_w:
 76         break;
 77       default:
 78         ShouldNotReachHere();
 79     }
 80   } else if (patch-&gt;id() == PatchingStub::load_appendix_id) {
 81     Bytecodes::Code bc_raw = info-&gt;scope()-&gt;method()-&gt;raw_code_at_bci(info-&gt;stack()-&gt;bci());
 82     assert(Bytecodes::has_optional_appendix(bc_raw), &quot;unexpected appendix resolution&quot;);
 83   } else {
 84     ShouldNotReachHere();
 85   }
 86 #endif
 87 }
 88 
 89 PatchingStub::PatchID LIR_Assembler::patching_id(CodeEmitInfo* info) {
 90   IRScope* scope = info-&gt;scope();
 91   Bytecodes::Code bc_raw = scope-&gt;method()-&gt;raw_code_at_bci(info-&gt;stack()-&gt;bci());
 92   if (Bytecodes::has_optional_appendix(bc_raw)) {
 93     return PatchingStub::load_appendix_id;
 94   }
 95   return PatchingStub::load_mirror_id;
 96 }
 97 
 98 //---------------------------------------------------------------
 99 
100 
101 LIR_Assembler::LIR_Assembler(Compilation* c):
102    _masm(c-&gt;masm())
103  , _bs(BarrierSet::barrier_set())
104  , _compilation(c)
105  , _frame_map(c-&gt;frame_map())
106  , _current_block(NULL)
107  , _pending_non_safepoint(NULL)
108  , _pending_non_safepoint_offset(0)
109 {
110   _slow_case_stubs = new CodeStubList();
111 }
112 
113 
114 LIR_Assembler::~LIR_Assembler() {
115   // The unwind handler label may be unnbound if this destructor is invoked because of a bail-out.
116   // Reset it here to avoid an assertion.
117   _unwind_handler_entry.reset();
118 }
119 
120 
121 void LIR_Assembler::check_codespace() {
122   CodeSection* cs = _masm-&gt;code_section();
123   if (cs-&gt;remaining() &lt; (int)(NOT_LP64(1*K)LP64_ONLY(2*K))) {
124     BAILOUT(&quot;CodeBuffer overflow&quot;);
125   }
126 }
127 
128 
129 void LIR_Assembler::append_code_stub(CodeStub* stub) {
130   _slow_case_stubs-&gt;append(stub);
131 }
132 
133 void LIR_Assembler::emit_stubs(CodeStubList* stub_list) {
134   for (int m = 0; m &lt; stub_list-&gt;length(); m++) {
135     CodeStub* s = stub_list-&gt;at(m);
136 
137     check_codespace();
138     CHECK_BAILOUT();
139 
140 #ifndef PRODUCT
141     if (CommentedAssembly) {
142       stringStream st;
143       s-&gt;print_name(&amp;st);
144       st.print(&quot; slow case&quot;);
145       _masm-&gt;block_comment(st.as_string());
146     }
147 #endif
148     s-&gt;emit_code(this);
149 #ifdef ASSERT
150     s-&gt;assert_no_unbound_labels();
151 #endif
152   }
153 }
154 
155 
156 void LIR_Assembler::emit_slow_case_stubs() {
157   emit_stubs(_slow_case_stubs);
158 }
159 
160 
161 bool LIR_Assembler::needs_icache(ciMethod* method) const {
162   return !method-&gt;is_static();
163 }
164 
<a name="1" id="anc1"></a>


165 
166 int LIR_Assembler::code_offset() const {
167   return _masm-&gt;offset();
168 }
169 
170 
171 address LIR_Assembler::pc() const {
172   return _masm-&gt;pc();
173 }
174 
175 // To bang the stack of this compiled method we use the stack size
176 // that the interpreter would need in case of a deoptimization. This
177 // removes the need to bang the stack in the deoptimization blob which
178 // in turn simplifies stack overflow handling.
179 int LIR_Assembler::bang_size_in_bytes() const {
180   return MAX2(initial_frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _compilation-&gt;interpreter_frame_size());
181 }
182 
183 void LIR_Assembler::emit_exception_entries(ExceptionInfoList* info_list) {
184   for (int i = 0; i &lt; info_list-&gt;length(); i++) {
185     XHandlers* handlers = info_list-&gt;at(i)-&gt;exception_handlers();
186 
187     for (int j = 0; j &lt; handlers-&gt;length(); j++) {
188       XHandler* handler = handlers-&gt;handler_at(j);
189       assert(handler-&gt;lir_op_id() != -1, &quot;handler not processed by LinearScan&quot;);
190       assert(handler-&gt;entry_code() == NULL ||
191              handler-&gt;entry_code()-&gt;instructions_list()-&gt;last()-&gt;code() == lir_branch ||
192              handler-&gt;entry_code()-&gt;instructions_list()-&gt;last()-&gt;code() == lir_delay_slot, &quot;last operation must be branch&quot;);
193 
194       if (handler-&gt;entry_pco() == -1) {
195         // entry code not emitted yet
196         if (handler-&gt;entry_code() != NULL &amp;&amp; handler-&gt;entry_code()-&gt;instructions_list()-&gt;length() &gt; 1) {
197           handler-&gt;set_entry_pco(code_offset());
198           if (CommentedAssembly) {
199             _masm-&gt;block_comment(&quot;Exception adapter block&quot;);
200           }
201           emit_lir_list(handler-&gt;entry_code());
202         } else {
203           handler-&gt;set_entry_pco(handler-&gt;entry_block()-&gt;exception_handler_pco());
204         }
205 
206         assert(handler-&gt;entry_pco() != -1, &quot;must be set now&quot;);
207       }
208     }
209   }
210 }
211 
212 
213 void LIR_Assembler::emit_code(BlockList* hir) {
214   if (PrintLIR) {
215     print_LIR(hir);
216   }
217 
218   int n = hir-&gt;length();
219   for (int i = 0; i &lt; n; i++) {
220     emit_block(hir-&gt;at(i));
221     CHECK_BAILOUT();
222   }
223 
224   flush_debug_info(code_offset());
225 
226   DEBUG_ONLY(check_no_unbound_labels());
227 }
228 
229 
230 void LIR_Assembler::emit_block(BlockBegin* block) {
231   if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
232     align_backward_branch_target();
233   }
234 
235   // if this block is the start of an exception handler, record the
236   // PC offset of the first instruction for later construction of
237   // the ExceptionHandlerTable
238   if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
239     block-&gt;set_exception_handler_pco(code_offset());
240   }
241 
242 #ifndef PRODUCT
243   if (PrintLIRWithAssembly) {
244     // don&#39;t print Phi&#39;s
245     InstructionPrinter ip(false);
246     block-&gt;print(ip);
247   }
248 #endif /* PRODUCT */
249 
250   assert(block-&gt;lir() != NULL, &quot;must have LIR&quot;);
251   X86_ONLY(assert(_masm-&gt;rsp_offset() == 0, &quot;frame size should be fixed&quot;));
252 
253 #ifndef PRODUCT
254   if (CommentedAssembly) {
255     stringStream st;
256     st.print_cr(&quot; block B%d [%d, %d]&quot;, block-&gt;block_id(), block-&gt;bci(), block-&gt;end()-&gt;printable_bci());
257     _masm-&gt;block_comment(st.as_string());
258   }
259 #endif
260 
261   emit_lir_list(block-&gt;lir());
262 
263   X86_ONLY(assert(_masm-&gt;rsp_offset() == 0, &quot;frame size should be fixed&quot;));
264 }
265 
266 
267 void LIR_Assembler::emit_lir_list(LIR_List* list) {
268   peephole(list);
269 
270   int n = list-&gt;length();
271   for (int i = 0; i &lt; n; i++) {
272     LIR_Op* op = list-&gt;at(i);
273 
274     check_codespace();
275     CHECK_BAILOUT();
276 
277 #ifndef PRODUCT
278     if (CommentedAssembly) {
279       // Don&#39;t record out every op since that&#39;s too verbose.  Print
280       // branches since they include block and stub names.  Also print
281       // patching moves since they generate funny looking code.
282       if (op-&gt;code() == lir_branch ||
283           (op-&gt;code() == lir_move &amp;&amp; op-&gt;as_Op1()-&gt;patch_code() != lir_patch_none) ||
284           (op-&gt;code() == lir_leal &amp;&amp; op-&gt;as_Op1()-&gt;patch_code() != lir_patch_none)) {
285         stringStream st;
286         op-&gt;print_on(&amp;st);
287         _masm-&gt;block_comment(st.as_string());
288       }
289     }
290     if (PrintLIRWithAssembly) {
291       // print out the LIR operation followed by the resulting assembly
292       list-&gt;at(i)-&gt;print(); tty-&gt;cr();
293     }
294 #endif /* PRODUCT */
295 
296     op-&gt;emit_code(this);
297 
298     if (compilation()-&gt;debug_info_recorder()-&gt;recording_non_safepoints()) {
299       process_debug_info(op);
300     }
301 
302 #ifndef PRODUCT
303     if (PrintLIRWithAssembly) {
304       _masm-&gt;code()-&gt;decode();
305     }
306 #endif /* PRODUCT */
307   }
308 }
309 
310 #ifdef ASSERT
311 void LIR_Assembler::check_no_unbound_labels() {
312   CHECK_BAILOUT();
313 
314   for (int i = 0; i &lt; _branch_target_blocks.length() - 1; i++) {
315     if (!_branch_target_blocks.at(i)-&gt;label()-&gt;is_bound()) {
316       tty-&gt;print_cr(&quot;label of block B%d is not bound&quot;, _branch_target_blocks.at(i)-&gt;block_id());
317       assert(false, &quot;unbound label&quot;);
318     }
319   }
320 }
321 #endif
322 
323 //----------------------------------debug info--------------------------------
324 
325 
326 void LIR_Assembler::add_debug_info_for_branch(CodeEmitInfo* info) {
327   int pc_offset = code_offset();
328   flush_debug_info(pc_offset);
329   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
330   if (info-&gt;exception_handlers() != NULL) {
331     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
332   }
333 }
334 
335 
336 void LIR_Assembler::add_call_info(int pc_offset, CodeEmitInfo* cinfo) {
337   flush_debug_info(pc_offset);
338   cinfo-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
339   if (cinfo-&gt;exception_handlers() != NULL) {
340     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, cinfo-&gt;exception_handlers());
341   }
342 }
343 
344 static ValueStack* debug_info(Instruction* ins) {
345   StateSplit* ss = ins-&gt;as_StateSplit();
346   if (ss != NULL) return ss-&gt;state();
347   return ins-&gt;state_before();
348 }
349 
350 void LIR_Assembler::process_debug_info(LIR_Op* op) {
351   Instruction* src = op-&gt;source();
352   if (src == NULL)  return;
353   int pc_offset = code_offset();
354   if (_pending_non_safepoint == src) {
355     _pending_non_safepoint_offset = pc_offset;
356     return;
357   }
358   ValueStack* vstack = debug_info(src);
359   if (vstack == NULL)  return;
360   if (_pending_non_safepoint != NULL) {
361     // Got some old debug info.  Get rid of it.
362     if (debug_info(_pending_non_safepoint) == vstack) {
363       _pending_non_safepoint_offset = pc_offset;
364       return;
365     }
366     if (_pending_non_safepoint_offset &lt; pc_offset) {
367       record_non_safepoint_debug_info();
368     }
369     _pending_non_safepoint = NULL;
370   }
371   // Remember the debug info.
372   if (pc_offset &gt; compilation()-&gt;debug_info_recorder()-&gt;last_pc_offset()) {
373     _pending_non_safepoint = src;
374     _pending_non_safepoint_offset = pc_offset;
375   }
376 }
377 
378 // Index caller states in s, where 0 is the oldest, 1 its callee, etc.
379 // Return NULL if n is too large.
380 // Returns the caller_bci for the next-younger state, also.
381 static ValueStack* nth_oldest(ValueStack* s, int n, int&amp; bci_result) {
382   ValueStack* t = s;
383   for (int i = 0; i &lt; n; i++) {
384     if (t == NULL)  break;
385     t = t-&gt;caller_state();
386   }
387   if (t == NULL)  return NULL;
388   for (;;) {
389     ValueStack* tc = t-&gt;caller_state();
390     if (tc == NULL)  return s;
391     t = tc;
392     bci_result = tc-&gt;bci();
393     s = s-&gt;caller_state();
394   }
395 }
396 
397 void LIR_Assembler::record_non_safepoint_debug_info() {
398   int         pc_offset = _pending_non_safepoint_offset;
399   ValueStack* vstack    = debug_info(_pending_non_safepoint);
400   int         bci       = vstack-&gt;bci();
401 
402   DebugInformationRecorder* debug_info = compilation()-&gt;debug_info_recorder();
403   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
404 
405   debug_info-&gt;add_non_safepoint(pc_offset);
406 
407   // Visit scopes from oldest to youngest.
408   for (int n = 0; ; n++) {
409     int s_bci = bci;
410     ValueStack* s = nth_oldest(vstack, n, s_bci);
411     if (s == NULL)  break;
412     IRScope* scope = s-&gt;scope();
413     //Always pass false for reexecute since these ScopeDescs are never used for deopt
414     methodHandle null_mh;
415     debug_info-&gt;describe_scope(pc_offset, null_mh, scope-&gt;method(), s-&gt;bci(), false/*reexecute*/);
416   }
417 
418   debug_info-&gt;end_non_safepoint(pc_offset);
419 }
420 
421 
422 ImplicitNullCheckStub* LIR_Assembler::add_debug_info_for_null_check_here(CodeEmitInfo* cinfo) {
423   return add_debug_info_for_null_check(code_offset(), cinfo);
424 }
425 
426 ImplicitNullCheckStub* LIR_Assembler::add_debug_info_for_null_check(int pc_offset, CodeEmitInfo* cinfo) {
427   ImplicitNullCheckStub* stub = new ImplicitNullCheckStub(pc_offset, cinfo);
428   append_code_stub(stub);
429   return stub;
430 }
431 
432 void LIR_Assembler::add_debug_info_for_div0_here(CodeEmitInfo* info) {
433   add_debug_info_for_div0(code_offset(), info);
434 }
435 
436 void LIR_Assembler::add_debug_info_for_div0(int pc_offset, CodeEmitInfo* cinfo) {
437   DivByZeroStub* stub = new DivByZeroStub(pc_offset, cinfo);
438   append_code_stub(stub);
439 }
440 
441 void LIR_Assembler::emit_rtcall(LIR_OpRTCall* op) {
442   rt_call(op-&gt;result_opr(), op-&gt;addr(), op-&gt;arguments(), op-&gt;tmp(), op-&gt;info());
443 }
444 
445 
446 void LIR_Assembler::emit_call(LIR_OpJavaCall* op) {
447   verify_oop_map(op-&gt;info());
448 
449   // must align calls sites, otherwise they can&#39;t be updated atomically
450   align_call(op-&gt;code());
451 
452   // emit the static call stub stuff out of line
453   emit_static_call_stub();
454   CHECK_BAILOUT();
455 
456   switch (op-&gt;code()) {
457   case lir_static_call:
458   case lir_dynamic_call:
459     call(op, relocInfo::static_call_type);
460     break;
461   case lir_optvirtual_call:
462     call(op, relocInfo::opt_virtual_call_type);
463     break;
464   case lir_icvirtual_call:
465     ic_call(op);
466     break;
467   case lir_virtual_call:
468     vtable_call(op);
469     break;
470   default:
471     fatal(&quot;unexpected op code: %s&quot;, op-&gt;name());
472     break;
473   }
474 
475   // JSR 292
476   // Record if this method has MethodHandle invokes.
477   if (op-&gt;is_method_handle_invoke()) {
478     compilation()-&gt;set_has_method_handle_invokes(true);
479   }
480 
<a name="2" id="anc2"></a><span class="line-modified">481 #if defined(X86) &amp;&amp; defined(TIERED)</span>
482   // C2 leave fpu stack dirty clean it
483   if (UseSSE &lt; 2) {
484     int i;
485     for ( i = 1; i &lt;= 7 ; i++ ) {
486       ffree(i);
487     }
488     if (!op-&gt;result_opr()-&gt;is_float_kind()) {
489       ffree(0);
490     }
491   }
492 #endif // X86 &amp;&amp; TIERED
493 }
494 
495 
496 void LIR_Assembler::emit_opLabel(LIR_OpLabel* op) {
497   _masm-&gt;bind (*(op-&gt;label()));
498 }
499 
500 
501 void LIR_Assembler::emit_op1(LIR_Op1* op) {
502   switch (op-&gt;code()) {
503     case lir_move:
504       if (op-&gt;move_kind() == lir_move_volatile) {
505         assert(op-&gt;patch_code() == lir_patch_none, &quot;can&#39;t patch volatiles&quot;);
506         volatile_move_op(op-&gt;in_opr(), op-&gt;result_opr(), op-&gt;type(), op-&gt;info());
507       } else {
508         move_op(op-&gt;in_opr(), op-&gt;result_opr(), op-&gt;type(),
509                 op-&gt;patch_code(), op-&gt;info(), op-&gt;pop_fpu_stack(),
510                 op-&gt;move_kind() == lir_move_unaligned,
511                 op-&gt;move_kind() == lir_move_wide);
512       }
513       break;
514 
515     case lir_roundfp: {
516       LIR_OpRoundFP* round_op = op-&gt;as_OpRoundFP();
517       roundfp_op(round_op-&gt;in_opr(), round_op-&gt;tmp(), round_op-&gt;result_opr(), round_op-&gt;pop_fpu_stack());
518       break;
519     }
520 
521     case lir_return:
522       return_op(op-&gt;in_opr());
523       break;
524 
525     case lir_safepoint:
526       if (compilation()-&gt;debug_info_recorder()-&gt;last_pc_offset() == code_offset()) {
527         _masm-&gt;nop();
528       }
529       safepoint_poll(op-&gt;in_opr(), op-&gt;info());
530       break;
531 
<a name="3" id="anc3"></a>
532     case lir_fxch:
533       fxch(op-&gt;in_opr()-&gt;as_jint());
534       break;
535 
536     case lir_fld:
537       fld(op-&gt;in_opr()-&gt;as_jint());
538       break;
<a name="4" id="anc4"></a><span class="line-modified">539 </span>
<span class="line-removed">540     case lir_ffree:</span>
<span class="line-removed">541       ffree(op-&gt;in_opr()-&gt;as_jint());</span>
<span class="line-removed">542       break;</span>
543 
544     case lir_branch:
545       break;
546 
547     case lir_push:
548       push(op-&gt;in_opr());
549       break;
550 
551     case lir_pop:
552       pop(op-&gt;in_opr());
553       break;
554 
555     case lir_leal:
556       leal(op-&gt;in_opr(), op-&gt;result_opr(), op-&gt;patch_code(), op-&gt;info());
557       break;
558 
559     case lir_null_check: {
560       ImplicitNullCheckStub* stub = add_debug_info_for_null_check_here(op-&gt;info());
561 
562       if (op-&gt;in_opr()-&gt;is_single_cpu()) {
563         _masm-&gt;null_check(op-&gt;in_opr()-&gt;as_register(), stub-&gt;entry());
564       } else {
565         Unimplemented();
566       }
567       break;
568     }
569 
570     case lir_monaddr:
571       monitor_address(op-&gt;in_opr()-&gt;as_constant_ptr()-&gt;as_jint(), op-&gt;result_opr());
572       break;
573 
574 #ifdef SPARC
575     case lir_pack64:
576       pack64(op-&gt;in_opr(), op-&gt;result_opr());
577       break;
578 
579     case lir_unpack64:
580       unpack64(op-&gt;in_opr(), op-&gt;result_opr());
581       break;
582 #endif
583 
584     case lir_unwind:
585       unwind_op(op-&gt;in_opr());
586       break;
587 
588     default:
589       Unimplemented();
590       break;
591   }
592 }
593 
594 
595 void LIR_Assembler::emit_op0(LIR_Op0* op) {
596   switch (op-&gt;code()) {
597     case lir_word_align: {
598       _masm-&gt;align(BytesPerWord);
599       break;
600     }
601 
602     case lir_nop:
603       assert(op-&gt;info() == NULL, &quot;not supported&quot;);
604       _masm-&gt;nop();
605       break;
606 
607     case lir_label:
608       Unimplemented();
609       break;
610 
611     case lir_build_frame:
612       build_frame();
613       break;
614 
615     case lir_std_entry:
616       // init offsets
617       offsets()-&gt;set_value(CodeOffsets::OSR_Entry, _masm-&gt;offset());
618       _masm-&gt;align(CodeEntryAlignment);
619       if (needs_icache(compilation()-&gt;method())) {
620         check_icache();
621       }
622       offsets()-&gt;set_value(CodeOffsets::Verified_Entry, _masm-&gt;offset());
623       _masm-&gt;verified_entry();
<a name="5" id="anc5"></a>


624       build_frame();
625       offsets()-&gt;set_value(CodeOffsets::Frame_Complete, _masm-&gt;offset());
626       break;
627 
628     case lir_osr_entry:
629       offsets()-&gt;set_value(CodeOffsets::OSR_Entry, _masm-&gt;offset());
630       osr_entry();
631       break;
632 
<a name="6" id="anc6"></a><span class="line-modified">633     case lir_24bit_FPU:</span>
<span class="line-modified">634       set_24bit_FPU();</span>
<span class="line-modified">635       break;</span>
<span class="line-removed">636 </span>
<span class="line-removed">637     case lir_reset_FPU:</span>
<span class="line-removed">638       reset_FPU();</span>
639       break;
<a name="7" id="anc7"></a>
640 
641     case lir_breakpoint:
642       breakpoint();
643       break;
644 
<a name="8" id="anc8"></a><span class="line-removed">645     case lir_fpop_raw:</span>
<span class="line-removed">646       fpop();</span>
<span class="line-removed">647       break;</span>
<span class="line-removed">648 </span>
649     case lir_membar:
650       membar();
651       break;
652 
653     case lir_membar_acquire:
654       membar_acquire();
655       break;
656 
657     case lir_membar_release:
658       membar_release();
659       break;
660 
661     case lir_membar_loadload:
662       membar_loadload();
663       break;
664 
665     case lir_membar_storestore:
666       membar_storestore();
667       break;
668 
669     case lir_membar_loadstore:
670       membar_loadstore();
671       break;
672 
673     case lir_membar_storeload:
674       membar_storeload();
675       break;
676 
677     case lir_get_thread:
678       get_thread(op-&gt;result_opr());
679       break;
680 
681     case lir_on_spin_wait:
682       on_spin_wait();
683       break;
684 
685     default:
686       ShouldNotReachHere();
687       break;
688   }
689 }
690 
691 
692 void LIR_Assembler::emit_op2(LIR_Op2* op) {
693   switch (op-&gt;code()) {
694     case lir_cmp:
695       if (op-&gt;info() != NULL) {
696         assert(op-&gt;in_opr1()-&gt;is_address() || op-&gt;in_opr2()-&gt;is_address(),
697                &quot;shouldn&#39;t be codeemitinfo for non-address operands&quot;);
698         add_debug_info_for_null_check_here(op-&gt;info()); // exception possible
699       }
700       comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
701       break;
702 
703     case lir_cmp_l2i:
704     case lir_cmp_fd2i:
705     case lir_ucmp_fd2i:
706       comp_fl2i(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;result_opr(), op);
707       break;
708 
709     case lir_cmove:
710       cmove(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;result_opr(), op-&gt;type());
711       break;
712 
713     case lir_shl:
714     case lir_shr:
715     case lir_ushr:
716       if (op-&gt;in_opr2()-&gt;is_constant()) {
717         shift_op(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint(), op-&gt;result_opr());
718       } else {
719         shift_op(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;result_opr(), op-&gt;tmp1_opr());
720       }
721       break;
722 
723     case lir_add:
724     case lir_sub:
725     case lir_mul:
726     case lir_mul_strictfp:
727     case lir_div:
728     case lir_div_strictfp:
729     case lir_rem:
730       assert(op-&gt;fpu_pop_count() &lt; 2, &quot;&quot;);
731       arith_op(
732         op-&gt;code(),
733         op-&gt;in_opr1(),
734         op-&gt;in_opr2(),
735         op-&gt;result_opr(),
736         op-&gt;info(),
737         op-&gt;fpu_pop_count() == 1);
738       break;
739 
740     case lir_abs:
741     case lir_sqrt:
742     case lir_tan:
743     case lir_log10:
744       intrinsic_op(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;result_opr(), op);
745       break;
746 
747     case lir_neg:
748       negate(op-&gt;in_opr1(), op-&gt;result_opr(), op-&gt;in_opr2());
749       break;
750 
751     case lir_logic_and:
752     case lir_logic_or:
753     case lir_logic_xor:
754       logic_op(
755         op-&gt;code(),
756         op-&gt;in_opr1(),
757         op-&gt;in_opr2(),
758         op-&gt;result_opr());
759       break;
760 
761     case lir_throw:
762       throw_op(op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;info());
763       break;
764 
765     case lir_xadd:
766     case lir_xchg:
767       atomic_op(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;result_opr(), op-&gt;tmp1_opr());
768       break;
769 
770     default:
771       Unimplemented();
772       break;
773   }
774 }
775 
776 
777 void LIR_Assembler::build_frame() {
778   _masm-&gt;build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
779 }
780 
781 
782 void LIR_Assembler::roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack) {
<a name="9" id="anc9"></a>
783   assert((src-&gt;is_single_fpu() &amp;&amp; dest-&gt;is_single_stack()) ||
784          (src-&gt;is_double_fpu() &amp;&amp; dest-&gt;is_double_stack()),
785          &quot;round_fp: rounds register -&gt; stack location&quot;);
786 
787   reg2stack (src, dest, src-&gt;type(), pop_fpu_stack);
788 }
789 
790 
791 void LIR_Assembler::move_op(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool unaligned, bool wide) {
792   if (src-&gt;is_register()) {
793     if (dest-&gt;is_register()) {
794       assert(patch_code == lir_patch_none &amp;&amp; info == NULL, &quot;no patching and info allowed here&quot;);
795       reg2reg(src,  dest);
796     } else if (dest-&gt;is_stack()) {
797       assert(patch_code == lir_patch_none &amp;&amp; info == NULL, &quot;no patching and info allowed here&quot;);
798       reg2stack(src, dest, type, pop_fpu_stack);
799     } else if (dest-&gt;is_address()) {
800       reg2mem(src, dest, type, patch_code, info, pop_fpu_stack, wide, unaligned);
801     } else {
802       ShouldNotReachHere();
803     }
804 
805   } else if (src-&gt;is_stack()) {
806     assert(patch_code == lir_patch_none &amp;&amp; info == NULL, &quot;no patching and info allowed here&quot;);
807     if (dest-&gt;is_register()) {
808       stack2reg(src, dest, type);
809     } else if (dest-&gt;is_stack()) {
810       stack2stack(src, dest, type);
811     } else {
812       ShouldNotReachHere();
813     }
814 
815   } else if (src-&gt;is_constant()) {
816     if (dest-&gt;is_register()) {
817       const2reg(src, dest, patch_code, info); // patching is possible
818     } else if (dest-&gt;is_stack()) {
819       assert(patch_code == lir_patch_none &amp;&amp; info == NULL, &quot;no patching and info allowed here&quot;);
820       const2stack(src, dest);
821     } else if (dest-&gt;is_address()) {
822       assert(patch_code == lir_patch_none, &quot;no patching allowed here&quot;);
823       const2mem(src, dest, type, info, wide);
824     } else {
825       ShouldNotReachHere();
826     }
827 
828   } else if (src-&gt;is_address()) {
829     mem2reg(src, dest, type, patch_code, info, wide, unaligned);
830 
831   } else {
832     ShouldNotReachHere();
833   }
834 }
835 
836 
837 void LIR_Assembler::verify_oop_map(CodeEmitInfo* info) {
838 #ifndef PRODUCT
839   if (VerifyOops) {
840     OopMapStream s(info-&gt;oop_map());
841     while (!s.is_done()) {
842       OopMapValue v = s.current();
843       if (v.is_oop()) {
844         VMReg r = v.reg();
845         if (!r-&gt;is_stack()) {
846           stringStream st;
847           st.print(&quot;bad oop %s at %d&quot;, r-&gt;as_Register()-&gt;name(), _masm-&gt;offset());
848 #ifdef SPARC
849           _masm-&gt;_verify_oop(r-&gt;as_Register(), os::strdup(st.as_string(), mtCompiler), __FILE__, __LINE__);
850 #else
851           _masm-&gt;verify_oop(r-&gt;as_Register());
852 #endif
853         } else {
854           _masm-&gt;verify_stack_oop(r-&gt;reg2stack() * VMRegImpl::stack_slot_size);
855         }
856       }
857       check_codespace();
858       CHECK_BAILOUT();
859 
860       s.next();
861     }
862   }
863 #endif
864 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
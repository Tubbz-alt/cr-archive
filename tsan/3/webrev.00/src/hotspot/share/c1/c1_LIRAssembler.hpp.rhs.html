<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRAssembler.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_LIRASSEMBLER_HPP
 26 #define SHARE_C1_C1_LIRASSEMBLER_HPP
 27 
 28 #include &quot;c1/c1_CodeStubs.hpp&quot;
 29 #include &quot;ci/ciMethodData.hpp&quot;
 30 #include &quot;oops/methodData.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 class Compilation;
 34 class ScopeValue;
 35 class BarrierSet;
 36 
 37 class LIR_Assembler: public CompilationResourceObj {
 38  private:
 39   C1_MacroAssembler* _masm;
 40   CodeStubList*      _slow_case_stubs;
 41   BarrierSet*        _bs;
 42 
 43   Compilation*       _compilation;
 44   FrameMap*          _frame_map;
 45   BlockBegin*        _current_block;
 46 
 47   Instruction*       _pending_non_safepoint;
 48   int                _pending_non_safepoint_offset;
 49 
 50   Label              _unwind_handler_entry;
 51 
 52 #ifdef ASSERT
 53   BlockList          _branch_target_blocks;
 54   void check_no_unbound_labels();
 55 #endif
 56 
 57   FrameMap* frame_map() const { return _frame_map; }
 58 
 59   void set_current_block(BlockBegin* b) { _current_block = b; }
 60   BlockBegin* current_block() const { return _current_block; }
 61 
 62   // non-safepoint debug info management
 63   void flush_debug_info(int before_pc_offset) {
 64     if (_pending_non_safepoint != NULL) {
 65       if (_pending_non_safepoint_offset &lt; before_pc_offset)
 66         record_non_safepoint_debug_info();
 67       _pending_non_safepoint = NULL;
 68     }
 69   }
 70   void process_debug_info(LIR_Op* op);
 71   void record_non_safepoint_debug_info();
 72 
 73   // unified bailout support
 74   void bailout(const char* msg) const { compilation()-&gt;bailout(msg); }
 75   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
 76 
 77   // code emission patterns and accessors
 78   void check_codespace();
 79   bool needs_icache(ciMethod* method) const;
 80 
 81   // returns offset of icache check
 82   int check_icache();
 83 
<a name="1" id="anc1"></a><span class="line-added"> 84   bool needs_clinit_barrier_on_entry(ciMethod* method) const;</span>
<span class="line-added"> 85   void clinit_barrier(ciMethod* method);</span>
<span class="line-added"> 86 </span>
 87   void jobject2reg(jobject o, Register reg);
 88   void jobject2reg_with_patching(Register reg, CodeEmitInfo* info);
 89 
 90   void metadata2reg(Metadata* o, Register reg);
 91   void klass2reg_with_patching(Register reg, CodeEmitInfo* info);
 92 
 93   void emit_stubs(CodeStubList* stub_list);
 94 
 95   // addresses
 96   Address as_Address(LIR_Address* addr);
 97   Address as_Address_lo(LIR_Address* addr);
 98   Address as_Address_hi(LIR_Address* addr);
 99 
100   // debug information
101   void add_call_info(int pc_offset, CodeEmitInfo* cinfo);
102   void add_debug_info_for_branch(CodeEmitInfo* info);
103   void add_debug_info_for_div0(int pc_offset, CodeEmitInfo* cinfo);
104   void add_debug_info_for_div0_here(CodeEmitInfo* info);
105   ImplicitNullCheckStub* add_debug_info_for_null_check(int pc_offset, CodeEmitInfo* cinfo);
106   ImplicitNullCheckStub* add_debug_info_for_null_check_here(CodeEmitInfo* info);
107 
<a name="2" id="anc2"></a>






108   void breakpoint();
109   void push(LIR_Opr opr);
110   void pop(LIR_Opr opr);
111 
112   // patching
113   void append_patching_stub(PatchingStub* stub);
114   void patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info);
115 
116   void comp_op(LIR_Condition condition, LIR_Opr src, LIR_Opr result, LIR_Op2* op);
117 
118   PatchingStub::PatchID patching_id(CodeEmitInfo* info);
119 
120  public:
121   LIR_Assembler(Compilation* c);
122   ~LIR_Assembler();
123   C1_MacroAssembler* masm() const                { return _masm; }
124   Compilation* compilation() const               { return _compilation; }
125   ciMethod* method() const                       { return compilation()-&gt;method(); }
126 
127   CodeOffsets* offsets() const                   { return _compilation-&gt;offsets(); }
128   int code_offset() const;
129   address pc() const;
130 
131   int  initial_frame_size_in_bytes() const;
132   int  bang_size_in_bytes() const;
133 
134   // test for constants which can be encoded directly in instructions
135   static bool is_small_constant(LIR_Opr opr);
136 
137   static LIR_Opr receiverOpr();
138   static LIR_Opr osrBufferPointer();
139 
140   // stubs
141   void emit_slow_case_stubs();
142   void emit_static_call_stub();
143   void append_code_stub(CodeStub* op);
144   void add_call_info_here(CodeEmitInfo* info)                              { add_call_info(code_offset(), info); }
145 
146   // code patterns
147   int  emit_exception_handler();
148   int  emit_unwind_handler();
149   void emit_exception_entries(ExceptionInfoList* info_list);
150   int  emit_deopt_handler();
151 
152   void emit_code(BlockList* hir);
153   void emit_block(BlockBegin* block);
154   void emit_lir_list(LIR_List* list);
155 
156   // any last minute peephole optimizations are performed here.  In
157   // particular sparc uses this for delay slot filling.
158   void peephole(LIR_List* list);
159 
160   void return_op(LIR_Opr result);
161 
162   // returns offset of poll instruction
163   int safepoint_poll(LIR_Opr result, CodeEmitInfo* info);
164 
165   void const2reg  (LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info);
166   void const2stack(LIR_Opr src, LIR_Opr dest);
167   void const2mem  (LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide);
168   void reg2stack  (LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack);
169   void reg2reg    (LIR_Opr src, LIR_Opr dest);
170   void reg2mem    (LIR_Opr src, LIR_Opr dest, BasicType type,
171                    LIR_PatchCode patch_code, CodeEmitInfo* info,
172                    bool pop_fpu_stack, bool wide, bool unaligned);
173   void stack2reg  (LIR_Opr src, LIR_Opr dest, BasicType type);
174   void stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type);
175   void mem2reg    (LIR_Opr src, LIR_Opr dest, BasicType type,
176                    LIR_PatchCode patch_code,
177                    CodeEmitInfo* info, bool wide, bool unaligned);
178 
179   void shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp);
180   void shift_op(LIR_Code code, LIR_Opr left, jint  count, LIR_Opr dest);
181 
182   void move_regs(Register from_reg, Register to_reg);
183   void swap_reg(Register a, Register b);
184 
185   void emit_op0(LIR_Op0* op);
186   void emit_op1(LIR_Op1* op);
187   void emit_op2(LIR_Op2* op);
188   void emit_op3(LIR_Op3* op);
189   void emit_opBranch(LIR_OpBranch* op);
190   void emit_opLabel(LIR_OpLabel* op);
191   void emit_arraycopy(LIR_OpArrayCopy* op);
192   void emit_updatecrc32(LIR_OpUpdateCRC32* op);
193   void emit_opConvert(LIR_OpConvert* op);
194   void emit_alloc_obj(LIR_OpAllocObj* op);
195   void emit_alloc_array(LIR_OpAllocArray* op);
196   void emit_opTypeCheck(LIR_OpTypeCheck* op);
197   void emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null);
198   void emit_compare_and_swap(LIR_OpCompareAndSwap* op);
199   void emit_lock(LIR_OpLock* op);
200   void emit_call(LIR_OpJavaCall* op);
201   void emit_rtcall(LIR_OpRTCall* op);
202   void emit_profile_call(LIR_OpProfileCall* op);
203   void emit_profile_type(LIR_OpProfileType* op);
204   void emit_delay(LIR_OpDelay* op);
205 
206   void arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack);
207   void arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info);
208   void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);
209 #ifdef ASSERT
210   void emit_assert(LIR_OpAssert* op);
211 #endif
212 
213   void logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest);
214 
215   void roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack);
216   void move_op(LIR_Opr src, LIR_Opr result, BasicType type,
217                LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool unaligned, bool wide);
218   void volatile_move_op(LIR_Opr src, LIR_Opr result, BasicType type, CodeEmitInfo* info);
219   void comp_mem_op(LIR_Opr src, LIR_Opr result, BasicType type, CodeEmitInfo* info);  // info set for null exceptions
220   void comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr result, LIR_Op2* op);
221   void cmove(LIR_Condition code, LIR_Opr left, LIR_Opr right, LIR_Opr result, BasicType type);
222 
223   void call(        LIR_OpJavaCall* op, relocInfo::relocType rtype);
224   void ic_call(     LIR_OpJavaCall* op);
225   void vtable_call( LIR_OpJavaCall* op);
226 
227   void osr_entry();
228 
229   void build_frame();
230 
231   void throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info);
232   void unwind_op(LIR_Opr exceptionOop);
233   void monitor_address(int monitor_ix, LIR_Opr dst);
234 
235   void align_backward_branch_target();
236   void align_call(LIR_Code code);
237 
238   void negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp = LIR_OprFact::illegalOpr);
239   void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL);
240 
241   void rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info);
242 
243   void membar();
244   void membar_acquire();
245   void membar_release();
246   void membar_loadload();
247   void membar_storestore();
248   void membar_loadstore();
249   void membar_storeload();
250   void on_spin_wait();
251   void get_thread(LIR_Opr result);
252 
253   void verify_oop_map(CodeEmitInfo* info);
254 
255   void atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp);
256 
257 #include CPU_HEADER(c1_LIRAssembler)
258 
259  public:
260 
261   static int call_stub_size() {
262     if (UseAOT) {
263       return _call_stub_size + _call_aot_stub_size;
264     } else {
265       return _call_stub_size;
266     }
267   }
268 
269   static int exception_handler_size() {
270     return _exception_handler_size;
271   }
272 
273   static int deopt_handler_size() {
274     return _deopt_handler_size;
275   }
276 };
277 
278 #endif // SHARE_C1_C1_LIRASSEMBLER_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
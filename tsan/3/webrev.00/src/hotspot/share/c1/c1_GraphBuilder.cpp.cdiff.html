<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,19 ***</span>
  #include &quot;ci/ciCallSite.hpp&quot;
  #include &quot;ci/ciField.hpp&quot;
  #include &quot;ci/ciKlass.hpp&quot;
  #include &quot;ci/ciMemberName.hpp&quot;
  #include &quot;ci/ciUtilities.inline.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  
  class BlockListBuilder {
   private:
    Compilation* _compilation;
    IRScope*     _scope;
<span class="line-new-header">--- 31,20 ---</span>
  #include &quot;ci/ciCallSite.hpp&quot;
  #include &quot;ci/ciField.hpp&quot;
  #include &quot;ci/ciKlass.hpp&quot;
  #include &quot;ci/ciMemberName.hpp&quot;
  #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  class BlockListBuilder {
   private:
    Compilation* _compilation;
    IRScope*     _scope;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,13 ***</span>
    Value load(LoadField* load) {
      if (!EliminateFieldAccess) {
        return load;
      }
  
<span class="line-modified">!     if (RoundFPResults &amp;&amp; UseSSE &lt; 2 &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {</span>
<span class="line-modified">!       // can&#39;t skip load since value might get rounded as a side effect</span>
<span class="line-modified">!       return load;</span>
      }
  
      ciField* field = load-&gt;field();
      Value object   = load-&gt;obj();
      if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
<span class="line-new-header">--- 606,19 ---</span>
    Value load(LoadField* load) {
      if (!EliminateFieldAccess) {
        return load;
      }
  
<span class="line-modified">!     if (strict_fp_requires_explicit_rounding &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {</span>
<span class="line-modified">! #ifdef IA32</span>
<span class="line-modified">!       if (UseSSE &lt; 2) {</span>
<span class="line-added">+         // can&#39;t skip load since value might get rounded as a side effect</span>
<span class="line-added">+         return load;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #else</span>
<span class="line-added">+       Unimplemented();</span>
<span class="line-added">+ #endif // IA32</span>
      }
  
      ciField* field = load-&gt;field();
      Value object   = load-&gt;obj();
      if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1465,15 ***</span>
    if (RegisterFinalizersAtInit &amp;&amp;
        method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
      call_register_finalizer();
    }
  
    bool need_mem_bar = false;
    if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
<span class="line-modified">!       (scope()-&gt;wrote_final() || (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields())</span>
<span class="line-modified">!                               || (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile())</span>
<span class="line-modified">!      )){</span>
      need_mem_bar = true;
    }
  
    BasicType bt = method()-&gt;return_type()-&gt;basic_type();
    switch (bt) {
<span class="line-new-header">--- 1472,16 ---</span>
    if (RegisterFinalizersAtInit &amp;&amp;
        method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
      call_register_finalizer();
    }
  
<span class="line-added">+   // The conditions for a memory barrier are described in Parse::do_exits().</span>
    bool need_mem_bar = false;
    if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
<span class="line-modified">!        (scope()-&gt;wrote_final() ||</span>
<span class="line-modified">!          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||</span>
<span class="line-modified">!          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {</span>
      need_mem_bar = true;
    }
  
    BasicType bt = method()-&gt;return_type()-&gt;basic_type();
    switch (bt) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1704,11 ***</span>
            if (field_value.is_valid()) {
              constant = make_constant(field_value, field);
              // For CallSite objects add a dependency for invalidation of the optimization.
              if (field-&gt;is_call_site_target()) {
                ciCallSite* call_site = const_oop-&gt;as_call_site();
<span class="line-modified">!               if (!call_site-&gt;is_constant_call_site()) {</span>
                  ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
                  dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
                }
              }
            }
<span class="line-new-header">--- 1712,11 ---</span>
            if (field_value.is_valid()) {
              constant = make_constant(field_value, field);
              // For CallSite objects add a dependency for invalidation of the optimization.
              if (field-&gt;is_call_site_target()) {
                ciCallSite* call_site = const_oop-&gt;as_call_site();
<span class="line-modified">!               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {</span>
                  ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
                  dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
                }
              }
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1722,10 ***</span>
<span class="line-new-header">--- 1730,27 ---</span>
          }
          LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
          Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
          if (replacement != load) {
            assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);
<span class="line-added">+           // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="line-added">+           // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="line-added">+           BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-added">+           switch (bt) {</span>
<span class="line-added">+           case T_BOOLEAN:</span>
<span class="line-added">+           case T_BYTE:</span>
<span class="line-added">+             replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           case T_CHAR:</span>
<span class="line-added">+             replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           case T_SHORT:</span>
<span class="line-added">+             replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           default:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           }</span>
            push(type, replacement);
          } else {
            push(type, append(load));
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1955,16 ***</span>
        // equal to the number of implementors for target-&gt;holder() so
        // if number of implementors of target-&gt;holder() == 1 then
        // number of implementors for decl_interface is 0 or 1. If
        // it&#39;s 0 then no class implements decl_interface and there&#39;s
        // no point in inlining.
<span class="line-removed">-       ciInstanceKlass* singleton = NULL;</span>
        ciInstanceKlass* declared_interface = callee_holder;
<span class="line-modified">!       if (declared_interface-&gt;nof_implementors() == 1 &amp;&amp;</span>
<span class="line-modified">!           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */) {</span>
<span class="line-modified">!         singleton = declared_interface-&gt;implementor();</span>
<span class="line-modified">!         assert(singleton != NULL &amp;&amp; singleton != declared_interface, &quot;&quot;);</span>
          cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
          if (cha_monomorphic_target != NULL) {
            if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
              // If CHA is able to bind this invoke then update the class
              // to match that class, otherwise klass will refer to the
<span class="line-new-header">--- 1980,15 ---</span>
        // equal to the number of implementors for target-&gt;holder() so
        // if number of implementors of target-&gt;holder() == 1 then
        // number of implementors for decl_interface is 0 or 1. If
        // it&#39;s 0 then no class implements decl_interface and there&#39;s
        // no point in inlining.
        ciInstanceKlass* declared_interface = callee_holder;
<span class="line-modified">!       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();</span>
<span class="line-modified">!       if (singleton != NULL &amp;&amp;</span>
<span class="line-modified">!           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */ ) {</span>
<span class="line-modified">!         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);</span>
          cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
          if (cha_monomorphic_target != NULL) {
            if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
              // If CHA is able to bind this invoke then update the class
              // to match that class, otherwise klass will refer to the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1986,12 ***</span>
        }
      }
    }
  
    if (cha_monomorphic_target != NULL) {
      assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
<span class="line-modified">!     if (!target-&gt;is_final_method() &amp;&amp; !target-&gt;is_private()) {</span>
        // If we inlined because CHA revealed only a single target method,
        // then we are dependent on that target method not getting overridden
        // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
        // dest_method here, as opposed to the actual receiver, which may
        // falsely lead us to believe that the receiver is final or private.
<span class="line-new-header">--- 2010,13 ---</span>
        }
      }
    }
  
    if (cha_monomorphic_target != NULL) {
<span class="line-added">+     assert(!target-&gt;can_be_statically_bound() || target == cha_monomorphic_target, &quot;&quot;);</span>
      assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
<span class="line-modified">!     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_recv)) {</span>
        // If we inlined because CHA revealed only a single target method,
        // then we are dependent on that target method not getting overridden
        // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
        // dest_method here, as opposed to the actual receiver, which may
        // falsely lead us to believe that the receiver is final or private.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,21 ***</span>
    append_with_bci(t, bci);
  }
  
  
  Value GraphBuilder::round_fp(Value fp_value) {
<span class="line-modified">!   // no rounding needed if SSE2 is used</span>
<span class="line-modified">!   if (RoundFPResults &amp;&amp; UseSSE &lt; 2) {</span>
<span class="line-modified">!     // Must currently insert rounding node for doubleword values that</span>
<span class="line-modified">!     // are results of expressions (i.e., not loads from memory or</span>
<span class="line-modified">!     // constants)</span>
<span class="line-modified">!     if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;</span>
<span class="line-modified">!         fp_value-&gt;as_Constant() == NULL &amp;&amp;</span>
<span class="line-modified">!         fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding</span>
<span class="line-modified">!         fp_value-&gt;as_RoundFP() == NULL) {</span>
<span class="line-modified">!       return append(new RoundFP(fp_value));</span>
      }
    }
    return fp_value;
  }
  
  
<span class="line-new-header">--- 2277,27 ---</span>
    append_with_bci(t, bci);
  }
  
  
  Value GraphBuilder::round_fp(Value fp_value) {
<span class="line-modified">!   if (strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified">! #ifdef IA32</span>
<span class="line-modified">!     // no rounding needed if SSE2 is used</span>
<span class="line-modified">!     if (UseSSE &lt; 2) {</span>
<span class="line-modified">!       // Must currently insert rounding node for doubleword values that</span>
<span class="line-modified">!       // are results of expressions (i.e., not loads from memory or</span>
<span class="line-modified">!       // constants)</span>
<span class="line-modified">!       if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;</span>
<span class="line-modified">!           fp_value-&gt;as_Constant() == NULL &amp;&amp;</span>
<span class="line-modified">!           fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding</span>
<span class="line-added">+           fp_value-&gt;as_RoundFP() == NULL) {</span>
<span class="line-added">+         return append(new RoundFP(fp_value));</span>
<span class="line-added">+       }</span>
      }
<span class="line-added">+ #else</span>
<span class="line-added">+     Unimplemented();</span>
<span class="line-added">+ #endif // IA32</span>
    }
    return fp_value;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2587,11 ***</span>
      simplify(phi);
    );
  
  #ifdef ASSERT
    for_each_phi_fun(b, phi,
<span class="line-modified">!                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi, &quot;missed trivial simplification&quot;);</span>
    );
  
    ValueStack* state = b-&gt;state()-&gt;caller_state();
    for_each_state_value(state, value,
      Phi* phi = value-&gt;as_Phi();
<span class="line-new-header">--- 2618,11 ---</span>
      simplify(phi);
    );
  
  #ifdef ASSERT
    for_each_phi_fun(b, phi,
<span class="line-modified">!                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi || phi-&gt;is_illegal(), &quot;missed trivial simplification&quot;);</span>
    );
  
    ValueStack* state = b-&gt;state()-&gt;caller_state();
    for_each_state_value(state, value,
      Phi* phi = value-&gt;as_Phi();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3165,11 ***</span>
    ciSignature* sig = method()-&gt;signature();
    for (int i = 0; i &lt; sig-&gt;count(); i++) {
      ciType* type = sig-&gt;type_at(i);
      BasicType basic_type = type-&gt;basic_type();
      // don&#39;t allow T_ARRAY to propagate into locals types
<span class="line-modified">!     if (basic_type == T_ARRAY) basic_type = T_OBJECT;</span>
      ValueType* vt = as_ValueType(basic_type);
      state-&gt;store_local(idx, new Local(type, vt, idx, false));
      idx += type-&gt;size();
    }
  
<span class="line-new-header">--- 3196,11 ---</span>
    ciSignature* sig = method()-&gt;signature();
    for (int i = 0; i &lt; sig-&gt;count(); i++) {
      ciType* type = sig-&gt;type_at(i);
      BasicType basic_type = type-&gt;basic_type();
      // don&#39;t allow T_ARRAY to propagate into locals types
<span class="line-modified">!     if (is_reference_type(basic_type)) basic_type = T_OBJECT;</span>
      ValueType* vt = as_ValueType(basic_type);
      state-&gt;store_local(idx, new Local(type, vt, idx, false));
      idx += type-&gt;size();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3746,15 ***</span>
    if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
  
    // Proper inlining of methods with jsrs requires a little more work.
    if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
  
<span class="line-modified">!   // When SSE2 is used on intel, then no special handling is needed</span>
<span class="line-modified">!   // for strictfp because the enum-constant is fixed at compile time,</span>
<span class="line-modified">!   // the check for UseSSE2 is needed here</span>
<span class="line-modified">!   if (strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt; 2 &amp;&amp; method()-&gt;is_strict() != callee-&gt;is_strict()) {</span>
<span class="line-modified">!     INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);</span>
    }
  
    if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
      INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
    }
<span class="line-new-header">--- 3777,21 ---</span>
    if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
  
    // Proper inlining of methods with jsrs requires a little more work.
    if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
  
<span class="line-modified">!   if (strict_fp_requires_explicit_rounding &amp;&amp;</span>
<span class="line-modified">!       method()-&gt;is_strict() != callee-&gt;is_strict()) {</span>
<span class="line-modified">! #ifdef IA32</span>
<span class="line-modified">!     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).</span>
<span class="line-modified">!     // When SSE2 is present, no special handling is needed.</span>
<span class="line-added">+     if (UseSSE &lt; 2) {</span>
<span class="line-added">+       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     Unimplemented();</span>
<span class="line-added">+ #endif // IA32</span>
    }
  
    if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
      INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3790,11 ***</span>
  
      if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
        INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
      }
      // printing
<span class="line-modified">!     print_inlining(callee);</span>
    }
  
    // NOTE: Bailouts from this point on, which occur at the
    // GraphBuilder level, do not cause bailout just of the inlining but
    // in fact of the entire compilation.
<span class="line-new-header">--- 3827,11 ---</span>
  
      if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
        INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
      }
      // printing
<span class="line-modified">!     print_inlining(callee, &quot;inline&quot;, /*success*/ true);</span>
    }
  
    // NOTE: Bailouts from this point on, which occur at the
    // GraphBuilder level, do not cause bailout just of the inlining but
    // in fact of the entire compilation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4312,20 ***</span>
  }
  
  void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
    CompileLog* log = compilation()-&gt;log();
    if (log != NULL) {
      if (success) {
<span class="line-modified">!       if (msg != NULL)</span>
<span class="line-removed">-         log-&gt;inline_success(msg);</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         log-&gt;inline_success(&quot;receiver is statically known&quot;);</span>
      } else {
<span class="line-modified">!       if (msg != NULL)</span>
<span class="line-removed">-         log-&gt;inline_fail(msg);</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         log-&gt;inline_fail(&quot;reason unknown&quot;);</span>
      }
    }
    EventCompilerInlining event;
    if (event.should_commit()) {
      post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);
<span class="line-new-header">--- 4349,15 ---</span>
  }
  
  void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
    CompileLog* log = compilation()-&gt;log();
    if (log != NULL) {
<span class="line-added">+     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);</span>
      if (success) {
<span class="line-modified">!       log-&gt;inline_success(msg);</span>
      } else {
<span class="line-modified">!       log-&gt;inline_fail(msg);</span>
      }
    }
    EventCompilerInlining event;
    if (event.should_commit()) {
      post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);
</pre>
<center><a href="c1_FrameMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
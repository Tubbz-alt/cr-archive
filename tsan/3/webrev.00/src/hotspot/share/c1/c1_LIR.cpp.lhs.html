<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 Register LIR_OprDesc::as_register() const {
  34   return FrameMap::cpu_rnr2reg(cpu_regnr());
  35 }
  36 
  37 Register LIR_OprDesc::as_register_lo() const {
  38   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  39 }
  40 
  41 Register LIR_OprDesc::as_register_hi() const {
  42   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  43 }
  44 
  45 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  46 
  47 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  48   ValueTag tag = type-&gt;tag();
  49   switch (tag) {
  50   case metaDataTag : {
  51     ClassConstant* c = type-&gt;as_ClassConstant();
  52     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_loaded()) {
  53       return LIR_OprFact::metadataConst(NULL);
  54     } else if (c != NULL) {
  55       return LIR_OprFact::metadataConst(c-&gt;value()-&gt;constant_encoding());
  56     } else {
  57       MethodConstant* m = type-&gt;as_MethodConstant();
  58       assert (m != NULL, &quot;not a class or a method?&quot;);
  59       return LIR_OprFact::metadataConst(m-&gt;value()-&gt;constant_encoding());
  60     }
  61   }
  62   case objectTag : {
  63       return LIR_OprFact::oopConst(type-&gt;as_ObjectType()-&gt;encoding());
  64     }
  65   case addressTag: return LIR_OprFact::addressConst(type-&gt;as_AddressConstant()-&gt;value());
  66   case intTag    : return LIR_OprFact::intConst(type-&gt;as_IntConstant()-&gt;value());
  67   case floatTag  : return LIR_OprFact::floatConst(type-&gt;as_FloatConstant()-&gt;value());
  68   case longTag   : return LIR_OprFact::longConst(type-&gt;as_LongConstant()-&gt;value());
  69   case doubleTag : return LIR_OprFact::doubleConst(type-&gt;as_DoubleConstant()-&gt;value());
  70   default: ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  71   }
  72 }
  73 
  74 
  75 LIR_Opr LIR_OprFact::dummy_value_type(ValueType* type) {
  76   switch (type-&gt;tag()) {
  77     case objectTag: return LIR_OprFact::oopConst(NULL);
  78     case addressTag:return LIR_OprFact::addressConst(0);
  79     case intTag:    return LIR_OprFact::intConst(0);
  80     case floatTag:  return LIR_OprFact::floatConst(0.0);
  81     case longTag:   return LIR_OprFact::longConst(0);
  82     case doubleTag: return LIR_OprFact::doubleConst(0.0);
  83     default:        ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  84   }
  85   return illegalOpr;
  86 }
  87 
  88 
  89 
  90 //---------------------------------------------------
  91 
  92 
  93 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  94   int elem_size = type2aelembytes(type);
  95   switch (elem_size) {
  96   case 1: return LIR_Address::times_1;
  97   case 2: return LIR_Address::times_2;
  98   case 4: return LIR_Address::times_4;
  99   case 8: return LIR_Address::times_8;
 100   }
 101   ShouldNotReachHere();
 102   return LIR_Address::times_1;
 103 }
 104 
 105 //---------------------------------------------------
 106 
 107 char LIR_OprDesc::type_char(BasicType t) {
 108   switch (t) {
 109     case T_ARRAY:
 110       t = T_OBJECT;
 111     case T_BOOLEAN:
 112     case T_CHAR:
 113     case T_FLOAT:
 114     case T_DOUBLE:
 115     case T_BYTE:
 116     case T_SHORT:
 117     case T_INT:
 118     case T_LONG:
 119     case T_OBJECT:
 120     case T_ADDRESS:
 121     case T_VOID:
 122       return ::type2char(t);
 123     case T_METADATA:
 124       return &#39;M&#39;;
 125     case T_ILLEGAL:
 126       return &#39;?&#39;;
 127 
 128     default:
 129       ShouldNotReachHere();
 130       return &#39;?&#39;;
 131   }
 132 }
 133 
 134 #ifndef PRODUCT
 135 void LIR_OprDesc::validate_type() const {
 136 
 137 #ifdef ASSERT
 138   if (!is_pointer() &amp;&amp; !is_illegal()) {
 139     OprKind kindfield = kind_field(); // Factored out because of compiler bug, see 8002160
 140     switch (as_BasicType(type_field())) {
 141     case T_LONG:
 142       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 143              size_field() == double_size, &quot;must match&quot;);
 144       break;
 145     case T_FLOAT:
 146       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 147       assert((kindfield == fpu_register || kindfield == stack_value
 148              ARM_ONLY(|| kindfield == cpu_register)
 149              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 150              size_field() == single_size, &quot;must match&quot;);
 151       break;
 152     case T_DOUBLE:
 153       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 154       assert((kindfield == fpu_register || kindfield == stack_value
 155              ARM_ONLY(|| kindfield == cpu_register)
 156              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 157              size_field() == double_size, &quot;must match&quot;);
 158       break;
 159     case T_BOOLEAN:
 160     case T_CHAR:
 161     case T_BYTE:
 162     case T_SHORT:
 163     case T_INT:
 164     case T_ADDRESS:
 165     case T_OBJECT:
 166     case T_METADATA:
 167     case T_ARRAY:
 168       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 169              size_field() == single_size, &quot;must match&quot;);
 170       break;
 171 
 172     case T_ILLEGAL:
 173       // XXX TKR also means unknown right now
 174       // assert(is_illegal(), &quot;must match&quot;);
 175       break;
 176 
 177     default:
 178       ShouldNotReachHere();
 179     }
 180   }
 181 #endif
 182 
 183 }
 184 #endif // PRODUCT
 185 
 186 
 187 bool LIR_OprDesc::is_oop() const {
 188   if (is_pointer()) {
 189     return pointer()-&gt;is_oop_pointer();
 190   } else {
 191     OprType t= type_field();
 192     assert(t != unknown_type, &quot;not set&quot;);
 193     return t == object_type;
 194   }
 195 }
 196 
 197 
 198 
 199 void LIR_Op2::verify() const {
 200 #ifdef ASSERT
 201   switch (code()) {
 202     case lir_cmove:
 203     case lir_xchg:
 204       break;
 205 
 206     default:
 207       assert(!result_opr()-&gt;is_register() || !result_opr()-&gt;is_oop_register(),
 208              &quot;can&#39;t produce oops from arith&quot;);
 209   }
 210 
 211   if (TwoOperandLIRForm) {
 212 
 213 #ifdef ASSERT
 214     bool threeOperandForm = false;
 215 #ifdef S390
 216     // There are 3 operand shifts on S390 (see LIR_Assembler::shift_op()).
 217     threeOperandForm =
 218       code() == lir_shl ||
 219       ((code() == lir_shr || code() == lir_ushr) &amp;&amp; (result_opr()-&gt;is_double_cpu() || in_opr1()-&gt;type() == T_OBJECT));
 220 #endif
 221 #endif
 222 
 223     switch (code()) {
 224     case lir_add:
 225     case lir_sub:
 226     case lir_mul:
 227     case lir_mul_strictfp:
 228     case lir_div:
 229     case lir_div_strictfp:
 230     case lir_rem:
 231     case lir_logic_and:
 232     case lir_logic_or:
 233     case lir_logic_xor:
 234     case lir_shl:
 235     case lir_shr:
 236       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 237       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 238       break;
 239 
 240     // special handling for lir_ushr because of write barriers
 241     case lir_ushr:
 242       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 243       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 244       break;
 245 
 246     default:
 247       break;
 248     }
 249   }
 250 #endif
 251 }
 252 
 253 
 254 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block)
 255   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 256   , _cond(cond)
 257   , _type(type)
 258   , _label(block-&gt;label())
 259   , _block(block)
 260   , _ublock(NULL)
 261   , _stub(NULL) {
 262 }
 263 
 264 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub) :
 265   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 266   , _cond(cond)
 267   , _type(type)
 268   , _label(stub-&gt;entry())
 269   , _block(NULL)
 270   , _ublock(NULL)
 271   , _stub(stub) {
 272 }
 273 
 274 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock)
 275   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 276   , _cond(cond)
 277   , _type(type)
 278   , _label(block-&gt;label())
 279   , _block(block)
 280   , _ublock(ublock)
 281   , _stub(NULL)
 282 {
 283 }
 284 
 285 void LIR_OpBranch::change_block(BlockBegin* b) {
 286   assert(_block != NULL, &quot;must have old block&quot;);
 287   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 288 
 289   _block = b;
 290   _label = b-&gt;label();
 291 }
 292 
 293 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 294   assert(_ublock != NULL, &quot;must have old block&quot;);
 295   _ublock = b;
 296 }
 297 
 298 void LIR_OpBranch::negate_cond() {
 299   switch (_cond) {
 300     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 301     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 302     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 303     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 304     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 305     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 306     default: ShouldNotReachHere();
 307   }
 308 }
 309 
 310 
 311 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 312                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 313                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
 314                                  CodeStub* stub)
 315 
 316   : LIR_Op(code, result, NULL)
 317   , _object(object)
 318   , _array(LIR_OprFact::illegalOpr)
 319   , _klass(klass)
 320   , _tmp1(tmp1)
 321   , _tmp2(tmp2)
 322   , _tmp3(tmp3)
 323   , _fast_check(fast_check)
 324   , _info_for_patch(info_for_patch)
 325   , _info_for_exception(info_for_exception)
 326   , _stub(stub)
 327   , _profiled_method(NULL)
 328   , _profiled_bci(-1)
 329   , _should_profile(false)
 330 {
 331   if (code == lir_checkcast) {
 332     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 333   } else if (code == lir_instanceof) {
 334     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 335   } else {
 336     ShouldNotReachHere();
 337   }
 338 }
 339 
 340 
 341 
 342 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 343   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 344   , _object(object)
 345   , _array(array)
 346   , _klass(NULL)
 347   , _tmp1(tmp1)
 348   , _tmp2(tmp2)
 349   , _tmp3(tmp3)
 350   , _fast_check(false)
 351   , _info_for_patch(NULL)
 352   , _info_for_exception(info_for_exception)
 353   , _stub(NULL)
 354   , _profiled_method(NULL)
 355   , _profiled_bci(-1)
 356   , _should_profile(false)
 357 {
 358   if (code == lir_store_check) {
 359     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 360     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 361   } else {
 362     ShouldNotReachHere();
 363   }
 364 }
 365 
 366 
 367 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 368                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 369   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 370   , _src(src)
 371   , _src_pos(src_pos)
 372   , _dst(dst)
 373   , _dst_pos(dst_pos)
 374   , _length(length)
 375   , _tmp(tmp)
 376   , _expected_type(expected_type)
 377   , _flags(flags) {
 378   _stub = new ArrayCopyStub(this);
 379 }
 380 
 381 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 382   : LIR_Op(lir_updatecrc32, res, NULL)
 383   , _crc(crc)
 384   , _val(val) {
 385 }
 386 
 387 //-------------------verify--------------------------
 388 
 389 void LIR_Op1::verify() const {
 390   switch(code()) {
 391   case lir_move:
 392     assert(in_opr()-&gt;is_valid() &amp;&amp; result_opr()-&gt;is_valid(), &quot;must be&quot;);
 393     break;
 394   case lir_null_check:
 395     assert(in_opr()-&gt;is_register(), &quot;must be&quot;);
 396     break;
 397   case lir_return:
 398     assert(in_opr()-&gt;is_register() || in_opr()-&gt;is_illegal(), &quot;must be&quot;);
 399     break;
 400   default:
 401     break;
 402   }
 403 }
 404 
 405 void LIR_OpRTCall::verify() const {
 406   assert(strcmp(Runtime1::name_for_address(addr()), &quot;&lt;unknown function&gt;&quot;) != 0, &quot;unknown function&quot;);
 407 }
 408 
 409 //-------------------visits--------------------------
 410 
 411 // complete rework of LIR instruction visitor.
 412 // The virtual call for each instruction type is replaced by a big
 413 // switch that adds the operands for each instruction
 414 
 415 void LIR_OpVisitState::visit(LIR_Op* op) {
 416   // copy information from the LIR_Op
 417   reset();
 418   set_op(op);
 419 
 420   switch (op-&gt;code()) {
 421 
 422 // LIR_Op0
 423     case lir_word_align:               // result and info always invalid
 424     case lir_backwardbranch_target:    // result and info always invalid
 425     case lir_build_frame:              // result and info always invalid
 426     case lir_fpop_raw:                 // result and info always invalid
<a name="1" id="anc1"></a><span class="line-removed"> 427     case lir_24bit_FPU:                // result and info always invalid</span>
<span class="line-removed"> 428     case lir_reset_FPU:                // result and info always invalid</span>
 429     case lir_breakpoint:               // result and info always invalid
 430     case lir_membar:                   // result and info always invalid
 431     case lir_membar_acquire:           // result and info always invalid
 432     case lir_membar_release:           // result and info always invalid
 433     case lir_membar_loadload:          // result and info always invalid
 434     case lir_membar_storestore:        // result and info always invalid
 435     case lir_membar_loadstore:         // result and info always invalid
 436     case lir_membar_storeload:         // result and info always invalid
 437     case lir_on_spin_wait:
 438     {
 439       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 440       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 441       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 442       break;
 443     }
 444 
 445     case lir_nop:                      // may have info, result always invalid
 446     case lir_std_entry:                // may have result, info always invalid
 447     case lir_osr_entry:                // may have result, info always invalid
 448     case lir_get_thread:               // may have result, info always invalid
 449     {
 450       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 451       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 452       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 453       break;
 454     }
 455 
 456 
 457 // LIR_OpLabel
 458     case lir_label:                    // result and info always invalid
 459     {
 460       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 461       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 462       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 463       break;
 464     }
 465 
 466 
 467 // LIR_Op1
 468     case lir_fxch:           // input always valid, result and info always invalid
 469     case lir_fld:            // input always valid, result and info always invalid
<a name="2" id="anc2"></a><span class="line-removed"> 470     case lir_ffree:          // input always valid, result and info always invalid</span>
 471     case lir_push:           // input always valid, result and info always invalid
 472     case lir_pop:            // input always valid, result and info always invalid
 473     case lir_return:         // input always valid, result and info always invalid
 474     case lir_leal:           // input and result always valid, info always invalid
 475     case lir_monaddr:        // input and result always valid, info always invalid
 476     case lir_null_check:     // input and info always valid, result always invalid
 477     case lir_move:           // input and result always valid, may have info
 478     case lir_pack64:         // input and result always valid
 479     case lir_unpack64:       // input and result always valid
 480     {
 481       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 482       LIR_Op1* op1 = (LIR_Op1*)op;
 483 
 484       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 485       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 486       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 487 
 488       break;
 489     }
 490 
 491     case lir_safepoint:
 492     {
 493       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 494       LIR_Op1* op1 = (LIR_Op1*)op;
 495 
 496       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 497       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 498       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 499 
 500       break;
 501     }
 502 
 503 // LIR_OpConvert;
 504     case lir_convert:        // input and result always valid, info always invalid
 505     {
 506       assert(op-&gt;as_OpConvert() != NULL, &quot;must be&quot;);
 507       LIR_OpConvert* opConvert = (LIR_OpConvert*)op;
 508 
 509       assert(opConvert-&gt;_info == NULL, &quot;must be&quot;);
 510       if (opConvert-&gt;_opr-&gt;is_valid())       do_input(opConvert-&gt;_opr);
 511       if (opConvert-&gt;_result-&gt;is_valid())    do_output(opConvert-&gt;_result);
 512 #ifdef PPC32
 513       if (opConvert-&gt;_tmp1-&gt;is_valid())      do_temp(opConvert-&gt;_tmp1);
 514       if (opConvert-&gt;_tmp2-&gt;is_valid())      do_temp(opConvert-&gt;_tmp2);
 515 #endif
 516       do_stub(opConvert-&gt;_stub);
 517 
 518       break;
 519     }
 520 
 521 // LIR_OpBranch;
 522     case lir_branch:                   // may have info, input and result register always invalid
 523     case lir_cond_float_branch:        // may have info, input and result register always invalid
 524     {
 525       assert(op-&gt;as_OpBranch() != NULL, &quot;must be&quot;);
 526       LIR_OpBranch* opBranch = (LIR_OpBranch*)op;
 527 
 528       if (opBranch-&gt;_info != NULL)     do_info(opBranch-&gt;_info);
 529       assert(opBranch-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 530       if (opBranch-&gt;_stub != NULL)     opBranch-&gt;stub()-&gt;visit(this);
 531 
 532       break;
 533     }
 534 
 535 
 536 // LIR_OpAllocObj
 537     case lir_alloc_object:
 538     {
 539       assert(op-&gt;as_OpAllocObj() != NULL, &quot;must be&quot;);
 540       LIR_OpAllocObj* opAllocObj = (LIR_OpAllocObj*)op;
 541 
 542       if (opAllocObj-&gt;_info)                     do_info(opAllocObj-&gt;_info);
 543       if (opAllocObj-&gt;_opr-&gt;is_valid()) {        do_input(opAllocObj-&gt;_opr);
 544                                                  do_temp(opAllocObj-&gt;_opr);
 545                                         }
 546       if (opAllocObj-&gt;_tmp1-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp1);
 547       if (opAllocObj-&gt;_tmp2-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp2);
 548       if (opAllocObj-&gt;_tmp3-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp3);
 549       if (opAllocObj-&gt;_tmp4-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp4);
 550       if (opAllocObj-&gt;_result-&gt;is_valid())       do_output(opAllocObj-&gt;_result);
 551                                                  do_stub(opAllocObj-&gt;_stub);
 552       break;
 553     }
 554 
 555 
 556 // LIR_OpRoundFP;
 557     case lir_roundfp: {
 558       assert(op-&gt;as_OpRoundFP() != NULL, &quot;must be&quot;);
 559       LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;
 560 
 561       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 562       assert(opRoundFP-&gt;_tmp-&gt;is_illegal(), &quot;not used&quot;);
 563       do_input(opRoundFP-&gt;_opr);
 564       do_output(opRoundFP-&gt;_result);
 565 
 566       break;
 567     }
 568 
 569 
 570 // LIR_Op2
 571     case lir_cmp:
 572     case lir_cmp_l2i:
 573     case lir_ucmp_fd2i:
 574     case lir_cmp_fd2i:
 575     case lir_add:
 576     case lir_sub:
 577     case lir_mul:
 578     case lir_div:
 579     case lir_rem:
 580     case lir_sqrt:
 581     case lir_abs:
 582     case lir_neg:
 583     case lir_logic_and:
 584     case lir_logic_or:
 585     case lir_logic_xor:
 586     case lir_shl:
 587     case lir_shr:
 588     case lir_ushr:
 589     case lir_xadd:
 590     case lir_xchg:
 591     case lir_assert:
 592     {
 593       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 594       LIR_Op2* op2 = (LIR_Op2*)op;
 595       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 596              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 597 
 598       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 599       if (op2-&gt;_opr1-&gt;is_valid())         do_input(op2-&gt;_opr1);
 600       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2);
 601       if (op2-&gt;_tmp1-&gt;is_valid())         do_temp(op2-&gt;_tmp1);
 602       if (op2-&gt;_result-&gt;is_valid())       do_output(op2-&gt;_result);
 603       if (op-&gt;code() == lir_xchg || op-&gt;code() == lir_xadd) {
 604         // on ARM and PPC, return value is loaded first so could
 605         // destroy inputs. On other platforms that implement those
 606         // (x86, sparc), the extra constrainsts are harmless.
 607         if (op2-&gt;_opr1-&gt;is_valid())       do_temp(op2-&gt;_opr1);
 608         if (op2-&gt;_opr2-&gt;is_valid())       do_temp(op2-&gt;_opr2);
 609       }
 610 
 611       break;
 612     }
 613 
 614     // special handling for cmove: right input operand must not be equal
 615     // to the result operand, otherwise the backend fails
 616     case lir_cmove:
 617     {
 618       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 619       LIR_Op2* op2 = (LIR_Op2*)op;
 620 
 621       assert(op2-&gt;_info == NULL &amp;&amp; op2-&gt;_tmp1-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp;
 622              op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 623       assert(op2-&gt;_opr1-&gt;is_valid() &amp;&amp; op2-&gt;_opr2-&gt;is_valid() &amp;&amp; op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 624 
 625       do_input(op2-&gt;_opr1);
 626       do_input(op2-&gt;_opr2);
 627       do_temp(op2-&gt;_opr2);
 628       do_output(op2-&gt;_result);
 629 
 630       break;
 631     }
 632 
 633     // vspecial handling for strict operations: register input operands
 634     // as temp to guarantee that they do not overlap with other
 635     // registers
 636     case lir_mul_strictfp:
 637     case lir_div_strictfp:
 638     {
 639       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 640       LIR_Op2* op2 = (LIR_Op2*)op;
 641 
 642       assert(op2-&gt;_info == NULL, &quot;not used&quot;);
 643       assert(op2-&gt;_opr1-&gt;is_valid(), &quot;used&quot;);
 644       assert(op2-&gt;_opr2-&gt;is_valid(), &quot;used&quot;);
 645       assert(op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 646       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 647              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 648 
 649       do_input(op2-&gt;_opr1); do_temp(op2-&gt;_opr1);
 650       do_input(op2-&gt;_opr2); do_temp(op2-&gt;_opr2);
 651       if (op2-&gt;_tmp1-&gt;is_valid()) do_temp(op2-&gt;_tmp1);
 652       do_output(op2-&gt;_result);
 653 
 654       break;
 655     }
 656 
 657     case lir_throw: {
 658       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 659       LIR_Op2* op2 = (LIR_Op2*)op;
 660 
 661       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 662       if (op2-&gt;_opr1-&gt;is_valid())         do_temp(op2-&gt;_opr1);
 663       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2); // exception object is input parameter
 664       assert(op2-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 665       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 666              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 667 
 668       break;
 669     }
 670 
 671     case lir_unwind: {
 672       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 673       LIR_Op1* op1 = (LIR_Op1*)op;
 674 
 675       assert(op1-&gt;_info == NULL, &quot;no info&quot;);
 676       assert(op1-&gt;_opr-&gt;is_valid(), &quot;exception oop&quot;);         do_input(op1-&gt;_opr);
 677       assert(op1-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 678 
 679       break;
 680     }
 681 
 682 // LIR_Op3
 683     case lir_idiv:
 684     case lir_irem: {
 685       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 686       LIR_Op3* op3= (LIR_Op3*)op;
 687 
 688       if (op3-&gt;_info)                     do_info(op3-&gt;_info);
 689       if (op3-&gt;_opr1-&gt;is_valid())         do_input(op3-&gt;_opr1);
 690 
 691       // second operand is input and temp, so ensure that second operand
 692       // and third operand get not the same register
 693       if (op3-&gt;_opr2-&gt;is_valid())         do_input(op3-&gt;_opr2);
 694       if (op3-&gt;_opr2-&gt;is_valid())         do_temp(op3-&gt;_opr2);
 695       if (op3-&gt;_opr3-&gt;is_valid())         do_temp(op3-&gt;_opr3);
 696 
 697       if (op3-&gt;_result-&gt;is_valid())       do_output(op3-&gt;_result);
 698 
 699       break;
 700     }
 701 
 702     case lir_fmad:
 703     case lir_fmaf: {
 704       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 705       LIR_Op3* op3= (LIR_Op3*)op;
 706       assert(op3-&gt;_info == NULL, &quot;no info&quot;);
 707       do_input(op3-&gt;_opr1);
 708       do_input(op3-&gt;_opr2);
 709       do_input(op3-&gt;_opr3);
 710       do_output(op3-&gt;_result);
 711       break;
 712     }
 713 
 714 // LIR_OpJavaCall
 715     case lir_static_call:
 716     case lir_optvirtual_call:
 717     case lir_icvirtual_call:
 718     case lir_virtual_call:
 719     case lir_dynamic_call: {
 720       LIR_OpJavaCall* opJavaCall = op-&gt;as_OpJavaCall();
 721       assert(opJavaCall != NULL, &quot;must be&quot;);
 722 
 723       if (opJavaCall-&gt;_receiver-&gt;is_valid())     do_input(opJavaCall-&gt;_receiver);
 724 
 725       // only visit register parameters
 726       int n = opJavaCall-&gt;_arguments-&gt;length();
 727       for (int i = opJavaCall-&gt;_receiver-&gt;is_valid() ? 1 : 0; i &lt; n; i++) {
 728         if (!opJavaCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 729           do_input(*opJavaCall-&gt;_arguments-&gt;adr_at(i));
 730         }
 731       }
 732 
 733       if (opJavaCall-&gt;_info)                     do_info(opJavaCall-&gt;_info);
 734       if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &amp;&amp;
 735           opJavaCall-&gt;is_method_handle_invoke()) {
 736         opJavaCall-&gt;_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();
 737         do_temp(opJavaCall-&gt;_method_handle_invoke_SP_save_opr);
 738       }
 739       do_call();
 740       if (opJavaCall-&gt;_result-&gt;is_valid())       do_output(opJavaCall-&gt;_result);
 741 
 742       break;
 743     }
 744 
 745 
 746 // LIR_OpRTCall
 747     case lir_rtcall: {
 748       assert(op-&gt;as_OpRTCall() != NULL, &quot;must be&quot;);
 749       LIR_OpRTCall* opRTCall = (LIR_OpRTCall*)op;
 750 
 751       // only visit register parameters
 752       int n = opRTCall-&gt;_arguments-&gt;length();
 753       for (int i = 0; i &lt; n; i++) {
 754         if (!opRTCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 755           do_input(*opRTCall-&gt;_arguments-&gt;adr_at(i));
 756         }
 757       }
 758       if (opRTCall-&gt;_info)                     do_info(opRTCall-&gt;_info);
 759       if (opRTCall-&gt;_tmp-&gt;is_valid())          do_temp(opRTCall-&gt;_tmp);
 760       do_call();
 761       if (opRTCall-&gt;_result-&gt;is_valid())       do_output(opRTCall-&gt;_result);
 762 
 763       break;
 764     }
 765 
 766 
 767 // LIR_OpArrayCopy
 768     case lir_arraycopy: {
 769       assert(op-&gt;as_OpArrayCopy() != NULL, &quot;must be&quot;);
 770       LIR_OpArrayCopy* opArrayCopy = (LIR_OpArrayCopy*)op;
 771 
 772       assert(opArrayCopy-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 773       assert(opArrayCopy-&gt;_src-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_src);     do_temp(opArrayCopy-&gt;_src);
 774       assert(opArrayCopy-&gt;_src_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_src_pos); do_temp(opArrayCopy-&gt;_src_pos);
 775       assert(opArrayCopy-&gt;_dst-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_dst);     do_temp(opArrayCopy-&gt;_dst);
 776       assert(opArrayCopy-&gt;_dst_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_dst_pos); do_temp(opArrayCopy-&gt;_dst_pos);
 777       assert(opArrayCopy-&gt;_length-&gt;is_valid(), &quot;used&quot;);       do_input(opArrayCopy-&gt;_length);  do_temp(opArrayCopy-&gt;_length);
 778       assert(opArrayCopy-&gt;_tmp-&gt;is_valid(), &quot;used&quot;);          do_temp(opArrayCopy-&gt;_tmp);
 779       if (opArrayCopy-&gt;_info)                     do_info(opArrayCopy-&gt;_info);
 780 
 781       // the implementation of arraycopy always has a call into the runtime
 782       do_call();
 783 
 784       break;
 785     }
 786 
 787 
 788 // LIR_OpUpdateCRC32
 789     case lir_updatecrc32: {
 790       assert(op-&gt;as_OpUpdateCRC32() != NULL, &quot;must be&quot;);
 791       LIR_OpUpdateCRC32* opUp = (LIR_OpUpdateCRC32*)op;
 792 
 793       assert(opUp-&gt;_crc-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_crc);     do_temp(opUp-&gt;_crc);
 794       assert(opUp-&gt;_val-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_val);     do_temp(opUp-&gt;_val);
 795       assert(opUp-&gt;_result-&gt;is_valid(), &quot;used&quot;);       do_output(opUp-&gt;_result);
 796       assert(opUp-&gt;_info == NULL, &quot;no info for LIR_OpUpdateCRC32&quot;);
 797 
 798       break;
 799     }
 800 
 801 
 802 // LIR_OpLock
 803     case lir_lock:
 804     case lir_unlock: {
 805       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 806       LIR_OpLock* opLock = (LIR_OpLock*)op;
 807 
 808       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 809 
 810       // TODO: check if these operands really have to be temp
 811       // (or if input is sufficient). This may have influence on the oop map!
 812       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 813       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 814       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 815 
 816       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 817       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 818 
 819       do_stub(opLock-&gt;_stub);
 820 
 821       break;
 822     }
 823 
 824 
 825 // LIR_OpDelay
 826     case lir_delay_slot: {
 827       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 828       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 829 
 830       visit(opDelay-&gt;delay_op());
 831       break;
 832     }
 833 
 834 // LIR_OpTypeCheck
 835     case lir_instanceof:
 836     case lir_checkcast:
 837     case lir_store_check: {
 838       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 839       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 840 
 841       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 842       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 843       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 844       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 845         do_temp(opTypeCheck-&gt;_object);
 846       }
 847       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 848       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 849       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 850       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 851       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 852                                                   do_stub(opTypeCheck-&gt;_stub);
 853       break;
 854     }
 855 
 856 // LIR_OpCompareAndSwap
 857     case lir_cas_long:
 858     case lir_cas_obj:
 859     case lir_cas_int: {
 860       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 861       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 862 
 863       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 864       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 865       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 866       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 867                                                       do_input(opCompareAndSwap-&gt;_addr);
 868                                                       do_temp(opCompareAndSwap-&gt;_addr);
 869                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 870                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 871                                                       do_input(opCompareAndSwap-&gt;_new_value);
 872                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 873       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 874       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 875       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
 876 
 877       break;
 878     }
 879 
 880 
 881 // LIR_OpAllocArray;
 882     case lir_alloc_array: {
 883       assert(op-&gt;as_OpAllocArray() != NULL, &quot;must be&quot;);
 884       LIR_OpAllocArray* opAllocArray = (LIR_OpAllocArray*)op;
 885 
 886       if (opAllocArray-&gt;_info)                        do_info(opAllocArray-&gt;_info);
 887       if (opAllocArray-&gt;_klass-&gt;is_valid())           do_input(opAllocArray-&gt;_klass); do_temp(opAllocArray-&gt;_klass);
 888       if (opAllocArray-&gt;_len-&gt;is_valid())             do_input(opAllocArray-&gt;_len);   do_temp(opAllocArray-&gt;_len);
 889       if (opAllocArray-&gt;_tmp1-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp1);
 890       if (opAllocArray-&gt;_tmp2-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp2);
 891       if (opAllocArray-&gt;_tmp3-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp3);
 892       if (opAllocArray-&gt;_tmp4-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp4);
 893       if (opAllocArray-&gt;_result-&gt;is_valid())          do_output(opAllocArray-&gt;_result);
 894                                                       do_stub(opAllocArray-&gt;_stub);
 895       break;
 896     }
 897 
 898 // LIR_OpProfileCall:
 899     case lir_profile_call: {
 900       assert(op-&gt;as_OpProfileCall() != NULL, &quot;must be&quot;);
 901       LIR_OpProfileCall* opProfileCall = (LIR_OpProfileCall*)op;
 902 
 903       if (opProfileCall-&gt;_recv-&gt;is_valid())              do_temp(opProfileCall-&gt;_recv);
 904       assert(opProfileCall-&gt;_mdo-&gt;is_valid(), &quot;used&quot;);   do_temp(opProfileCall-&gt;_mdo);
 905       assert(opProfileCall-&gt;_tmp1-&gt;is_valid(), &quot;used&quot;);  do_temp(opProfileCall-&gt;_tmp1);
 906       break;
 907     }
 908 
 909 // LIR_OpProfileType:
 910     case lir_profile_type: {
 911       assert(op-&gt;as_OpProfileType() != NULL, &quot;must be&quot;);
 912       LIR_OpProfileType* opProfileType = (LIR_OpProfileType*)op;
 913 
 914       do_input(opProfileType-&gt;_mdp); do_temp(opProfileType-&gt;_mdp);
 915       do_input(opProfileType-&gt;_obj);
 916       do_temp(opProfileType-&gt;_tmp);
 917       break;
 918     }
 919   default:
 920     op-&gt;visit(this);
 921   }
 922 }
 923 
 924 void LIR_Op::visit(LIR_OpVisitState* state) {
 925   ShouldNotReachHere();
 926 }
 927 
 928 void LIR_OpVisitState::do_stub(CodeStub* stub) {
 929   if (stub != NULL) {
 930     stub-&gt;visit(this);
 931   }
 932 }
 933 
 934 XHandlers* LIR_OpVisitState::all_xhandler() {
 935   XHandlers* result = NULL;
 936 
 937   int i;
 938   for (i = 0; i &lt; info_count(); i++) {
 939     if (info_at(i)-&gt;exception_handlers() != NULL) {
 940       result = info_at(i)-&gt;exception_handlers();
 941       break;
 942     }
 943   }
 944 
 945 #ifdef ASSERT
 946   for (i = 0; i &lt; info_count(); i++) {
 947     assert(info_at(i)-&gt;exception_handlers() == NULL ||
 948            info_at(i)-&gt;exception_handlers() == result,
 949            &quot;only one xhandler list allowed per LIR-operation&quot;);
 950   }
 951 #endif
 952 
 953   if (result != NULL) {
 954     return result;
 955   } else {
 956     return new XHandlers();
 957   }
 958 
 959   return result;
 960 }
 961 
 962 
 963 #ifdef ASSERT
 964 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
 965   visit(op);
 966 
 967   return opr_count(inputMode) == 0 &amp;&amp;
 968          opr_count(outputMode) == 0 &amp;&amp;
 969          opr_count(tempMode) == 0 &amp;&amp;
 970          info_count() == 0 &amp;&amp;
 971          !has_call() &amp;&amp;
 972          !has_slow_case();
 973 }
 974 #endif
 975 
 976 //---------------------------------------------------
 977 
 978 
 979 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
 980   masm-&gt;emit_call(this);
 981 }
 982 
 983 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
 984   masm-&gt;emit_rtcall(this);
 985 }
 986 
 987 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
 988   masm-&gt;emit_opLabel(this);
 989 }
 990 
 991 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
 992   masm-&gt;emit_arraycopy(this);
 993   masm-&gt;append_code_stub(stub());
 994 }
 995 
 996 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
 997   masm-&gt;emit_updatecrc32(this);
 998 }
 999 
1000 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1001   masm-&gt;emit_op0(this);
1002 }
1003 
1004 void LIR_Op1::emit_code(LIR_Assembler* masm) {
1005   masm-&gt;emit_op1(this);
1006 }
1007 
1008 void LIR_OpAllocObj::emit_code(LIR_Assembler* masm) {
1009   masm-&gt;emit_alloc_obj(this);
1010   masm-&gt;append_code_stub(stub());
1011 }
1012 
1013 void LIR_OpBranch::emit_code(LIR_Assembler* masm) {
1014   masm-&gt;emit_opBranch(this);
1015   if (stub()) {
1016     masm-&gt;append_code_stub(stub());
1017   }
1018 }
1019 
1020 void LIR_OpConvert::emit_code(LIR_Assembler* masm) {
1021   masm-&gt;emit_opConvert(this);
1022   if (stub() != NULL) {
1023     masm-&gt;append_code_stub(stub());
1024   }
1025 }
1026 
1027 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1028   masm-&gt;emit_op2(this);
1029 }
1030 
1031 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1032   masm-&gt;emit_alloc_array(this);
1033   masm-&gt;append_code_stub(stub());
1034 }
1035 
1036 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1037   masm-&gt;emit_opTypeCheck(this);
1038   if (stub()) {
1039     masm-&gt;append_code_stub(stub());
1040   }
1041 }
1042 
1043 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1044   masm-&gt;emit_compare_and_swap(this);
1045 }
1046 
1047 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1048   masm-&gt;emit_op3(this);
1049 }
1050 
1051 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1052   masm-&gt;emit_lock(this);
1053   if (stub()) {
1054     masm-&gt;append_code_stub(stub());
1055   }
1056 }
1057 
1058 #ifdef ASSERT
1059 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1060   masm-&gt;emit_assert(this);
1061 }
1062 #endif
1063 
1064 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1065   masm-&gt;emit_delay(this);
1066 }
1067 
1068 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1069   masm-&gt;emit_profile_call(this);
1070 }
1071 
1072 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1073   masm-&gt;emit_profile_type(this);
1074 }
1075 
1076 // LIR_List
1077 LIR_List::LIR_List(Compilation* compilation, BlockBegin* block)
1078   : _operations(8)
1079   , _compilation(compilation)
1080 #ifndef PRODUCT
1081   , _block(block)
1082 #endif
1083 #ifdef ASSERT
1084   , _file(NULL)
1085   , _line(0)
1086 #endif
1087 { }
1088 
1089 
1090 #ifdef ASSERT
1091 void LIR_List::set_file_and_line(const char * file, int line) {
1092   const char * f = strrchr(file, &#39;/&#39;);
1093   if (f == NULL) f = strrchr(file, &#39;\\&#39;);
1094   if (f == NULL) {
1095     f = file;
1096   } else {
1097     f++;
1098   }
1099   _file = f;
1100   _line = line;
1101 }
1102 #endif
1103 
1104 
1105 void LIR_List::append(LIR_InsertionBuffer* buffer) {
1106   assert(this == buffer-&gt;lir_list(), &quot;wrong lir list&quot;);
1107   const int n = _operations.length();
1108 
1109   if (buffer-&gt;number_of_ops() &gt; 0) {
1110     // increase size of instructions list
1111     _operations.at_grow(n + buffer-&gt;number_of_ops() - 1, NULL);
1112     // insert ops from buffer into instructions list
1113     int op_index = buffer-&gt;number_of_ops() - 1;
1114     int ip_index = buffer-&gt;number_of_insertion_points() - 1;
1115     int from_index = n - 1;
1116     int to_index = _operations.length() - 1;
1117     for (; ip_index &gt;= 0; ip_index --) {
1118       int index = buffer-&gt;index_at(ip_index);
1119       // make room after insertion point
1120       while (index &lt; from_index) {
1121         _operations.at_put(to_index --, _operations.at(from_index --));
1122       }
1123       // insert ops from buffer
1124       for (int i = buffer-&gt;count_at(ip_index); i &gt; 0; i --) {
1125         _operations.at_put(to_index --, buffer-&gt;op_at(op_index --));
1126       }
1127     }
1128   }
1129 
1130   buffer-&gt;finish();
1131 }
1132 
1133 
1134 void LIR_List::oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info) {
1135   assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;);
1136   append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),  reg, T_OBJECT, lir_patch_normal, info));
1137 }
1138 
1139 void LIR_List::klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info) {
1140   assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;);
1141   append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg, T_METADATA, lir_patch_normal, info));
1142 }
1143 
1144 void LIR_List::load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1145   append(new LIR_Op1(
1146             lir_move,
1147             LIR_OprFact::address(addr),
1148             src,
1149             addr-&gt;type(),
1150             patch_code,
1151             info));
1152 }
1153 
1154 
1155 void LIR_List::volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1156   append(new LIR_Op1(
1157             lir_move,
1158             LIR_OprFact::address(address),
1159             dst,
1160             address-&gt;type(),
1161             patch_code,
1162             info, lir_move_volatile));
1163 }
1164 
1165 void LIR_List::volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1166   append(new LIR_Op1(
1167             lir_move,
1168             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1169             dst,
1170             type,
1171             patch_code,
1172             info, lir_move_volatile));
1173 }
1174 
1175 
1176 void LIR_List::store_mem_int(jint v, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1177   append(new LIR_Op1(
1178             lir_move,
1179             LIR_OprFact::intConst(v),
1180             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1181             type,
1182             patch_code,
1183             info));
1184 }
1185 
1186 
1187 void LIR_List::store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1188   append(new LIR_Op1(
1189             lir_move,
1190             LIR_OprFact::oopConst(o),
1191             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1192             type,
1193             patch_code,
1194             info));
1195 }
1196 
1197 
1198 void LIR_List::store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1199   append(new LIR_Op1(
1200             lir_move,
1201             src,
1202             LIR_OprFact::address(addr),
1203             addr-&gt;type(),
1204             patch_code,
1205             info));
1206 }
1207 
1208 
1209 void LIR_List::volatile_store_mem_reg(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1210   append(new LIR_Op1(
1211             lir_move,
1212             src,
1213             LIR_OprFact::address(addr),
1214             addr-&gt;type(),
1215             patch_code,
1216             info,
1217             lir_move_volatile));
1218 }
1219 
1220 void LIR_List::volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1221   append(new LIR_Op1(
1222             lir_move,
1223             src,
1224             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1225             type,
1226             patch_code,
1227             info, lir_move_volatile));
1228 }
1229 
1230 
1231 void LIR_List::idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1232   append(new LIR_Op3(
1233                     lir_idiv,
1234                     left,
1235                     right,
1236                     tmp,
1237                     res,
1238                     info));
1239 }
1240 
1241 
1242 void LIR_List::idiv(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1243   append(new LIR_Op3(
1244                     lir_idiv,
1245                     left,
1246                     LIR_OprFact::intConst(right),
1247                     tmp,
1248                     res,
1249                     info));
1250 }
1251 
1252 
1253 void LIR_List::irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1254   append(new LIR_Op3(
1255                     lir_irem,
1256                     left,
1257                     right,
1258                     tmp,
1259                     res,
1260                     info));
1261 }
1262 
1263 
1264 void LIR_List::irem(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1265   append(new LIR_Op3(
1266                     lir_irem,
1267                     left,
1268                     LIR_OprFact::intConst(right),
1269                     tmp,
1270                     res,
1271                     info));
1272 }
1273 
1274 
1275 void LIR_List::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
1276   append(new LIR_Op2(
1277                     lir_cmp,
1278                     condition,
1279                     LIR_OprFact::address(new LIR_Address(base, disp, T_INT)),
1280                     LIR_OprFact::intConst(c),
1281                     info));
1282 }
1283 
1284 
1285 void LIR_List::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info) {
1286   append(new LIR_Op2(
1287                     lir_cmp,
1288                     condition,
1289                     reg,
1290                     LIR_OprFact::address(addr),
1291                     info));
1292 }
1293 
1294 void LIR_List::allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1295                                int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub) {
1296   append(new LIR_OpAllocObj(
1297                            klass,
1298                            dst,
1299                            t1,
1300                            t2,
1301                            t3,
1302                            t4,
1303                            header_size,
1304                            object_size,
1305                            init_check,
1306                            stub));
1307 }
1308 
1309 void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {
1310   append(new LIR_OpAllocArray(
1311                            klass,
1312                            len,
1313                            dst,
1314                            t1,
1315                            t2,
1316                            t3,
1317                            t4,
1318                            type,
1319                            stub));
1320 }
1321 
1322 void LIR_List::shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1323  append(new LIR_Op2(
1324                     lir_shl,
1325                     value,
1326                     count,
1327                     dst,
1328                     tmp));
1329 }
1330 
1331 void LIR_List::shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1332  append(new LIR_Op2(
1333                     lir_shr,
1334                     value,
1335                     count,
1336                     dst,
1337                     tmp));
1338 }
1339 
1340 
1341 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1342  append(new LIR_Op2(
1343                     lir_ushr,
1344                     value,
1345                     count,
1346                     dst,
1347                     tmp));
1348 }
1349 
1350 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1351   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1352                      left,
1353                      right,
1354                      dst));
1355 }
1356 
1357 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {
1358   append(new LIR_OpLock(
1359                     lir_lock,
1360                     hdr,
1361                     obj,
1362                     lock,
1363                     scratch,
1364                     stub,
1365                     info));
1366 }
1367 
1368 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1369   append(new LIR_OpLock(
1370                     lir_unlock,
1371                     hdr,
1372                     obj,
1373                     lock,
1374                     scratch,
1375                     stub,
1376                     NULL));
1377 }
1378 
1379 
1380 void check_LIR() {
1381   // cannot do the proper checking as PRODUCT and other modes return different results
1382   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1383 }
1384 
1385 
1386 
1387 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1388                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1389                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
1390                           ciMethod* profiled_method, int profiled_bci) {
1391   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1392                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);
1393   if (profiled_method != NULL) {
1394     c-&gt;set_profiled_method(profiled_method);
1395     c-&gt;set_profiled_bci(profiled_bci);
1396     c-&gt;set_should_profile(true);
1397   }
1398   append(c);
1399 }
1400 
1401 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1402   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1403   if (profiled_method != NULL) {
1404     c-&gt;set_profiled_method(profiled_method);
1405     c-&gt;set_profiled_bci(profiled_bci);
1406     c-&gt;set_should_profile(true);
1407   }
1408   append(c);
1409 }
1410 
1411 
1412 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1413                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1414   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1415   if (profiled_method != NULL) {
1416     c-&gt;set_profiled_method(profiled_method);
1417     c-&gt;set_profiled_bci(profiled_bci);
1418     c-&gt;set_should_profile(true);
1419   }
1420   append(c);
1421 }
1422 
1423 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1424   if (deoptimize_on_null) {
1425     // Emit an explicit null check and deoptimize if opr is null
1426     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1427     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1428     branch(lir_cond_equal, T_OBJECT, deopt);
1429   } else {
1430     // Emit an implicit null check
1431     append(new LIR_Op1(lir_null_check, opr, info));
1432   }
1433 }
1434 
1435 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1436                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1437   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1438 }
1439 
1440 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1441                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1442   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1443 }
1444 
1445 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1446                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1447   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1448 }
1449 
1450 
1451 #ifdef PRODUCT
1452 
1453 void print_LIR(BlockList* blocks) {
1454 }
1455 
1456 #else
1457 // LIR_OprDesc
1458 void LIR_OprDesc::print() const {
1459   print(tty);
1460 }
1461 
1462 void LIR_OprDesc::print(outputStream* out) const {
1463   if (is_illegal()) {
1464     return;
1465   }
1466 
1467   out-&gt;print(&quot;[&quot;);
1468   if (is_pointer()) {
1469     pointer()-&gt;print_value_on(out);
1470   } else if (is_single_stack()) {
1471     out-&gt;print(&quot;stack:%d&quot;, single_stack_ix());
1472   } else if (is_double_stack()) {
1473     out-&gt;print(&quot;dbl_stack:%d&quot;,double_stack_ix());
1474   } else if (is_virtual()) {
1475     out-&gt;print(&quot;R%d&quot;, vreg_number());
1476   } else if (is_single_cpu()) {
1477     out-&gt;print(&quot;%s&quot;, as_register()-&gt;name());
1478   } else if (is_double_cpu()) {
1479     out-&gt;print(&quot;%s&quot;, as_register_hi()-&gt;name());
1480     out-&gt;print(&quot;%s&quot;, as_register_lo()-&gt;name());
1481 #if defined(X86)
1482   } else if (is_single_xmm()) {
1483     out-&gt;print(&quot;%s&quot;, as_xmm_float_reg()-&gt;name());
1484   } else if (is_double_xmm()) {
1485     out-&gt;print(&quot;%s&quot;, as_xmm_double_reg()-&gt;name());
1486   } else if (is_single_fpu()) {
1487     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1488   } else if (is_double_fpu()) {
1489     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1490 #elif defined(AARCH64)
1491   } else if (is_single_fpu()) {
1492     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1493   } else if (is_double_fpu()) {
1494     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1495 #elif defined(ARM)
1496   } else if (is_single_fpu()) {
1497     out-&gt;print(&quot;s%d&quot;, fpu_regnr());
1498   } else if (is_double_fpu()) {
1499     out-&gt;print(&quot;d%d&quot;, fpu_regnrLo() &gt;&gt; 1);
1500 #else
1501   } else if (is_single_fpu()) {
1502     out-&gt;print(&quot;%s&quot;, as_float_reg()-&gt;name());
1503   } else if (is_double_fpu()) {
1504     out-&gt;print(&quot;%s&quot;, as_double_reg()-&gt;name());
1505 #endif
1506 
1507   } else if (is_illegal()) {
1508     out-&gt;print(&quot;-&quot;);
1509   } else {
1510     out-&gt;print(&quot;Unknown Operand&quot;);
1511   }
1512   if (!is_illegal()) {
1513     out-&gt;print(&quot;|%c&quot;, type_char());
1514   }
1515   if (is_register() &amp;&amp; is_last_use()) {
1516     out-&gt;print(&quot;(last_use)&quot;);
1517   }
1518   out-&gt;print(&quot;]&quot;);
1519 }
1520 
1521 
1522 // LIR_Address
1523 void LIR_Const::print_value_on(outputStream* out) const {
1524   switch (type()) {
1525     case T_ADDRESS:out-&gt;print(&quot;address:%d&quot;,as_jint());          break;
1526     case T_INT:    out-&gt;print(&quot;int:%d&quot;,   as_jint());           break;
1527     case T_LONG:   out-&gt;print(&quot;lng:&quot; JLONG_FORMAT, as_jlong()); break;
1528     case T_FLOAT:  out-&gt;print(&quot;flt:%f&quot;,   as_jfloat());         break;
1529     case T_DOUBLE: out-&gt;print(&quot;dbl:%f&quot;,   as_jdouble());        break;
1530     case T_OBJECT: out-&gt;print(&quot;obj:&quot; INTPTR_FORMAT, p2i(as_jobject()));        break;
1531     case T_METADATA: out-&gt;print(&quot;metadata:&quot; INTPTR_FORMAT, p2i(as_metadata()));break;
1532     default:       out-&gt;print(&quot;%3d:0x&quot; UINT64_FORMAT_X, type(), (uint64_t)as_jlong()); break;
1533   }
1534 }
1535 
1536 // LIR_Address
1537 void LIR_Address::print_value_on(outputStream* out) const {
1538   out-&gt;print(&quot;Base:&quot;); _base-&gt;print(out);
1539   if (!_index-&gt;is_illegal()) {
1540     out-&gt;print(&quot; Index:&quot;); _index-&gt;print(out);
1541     switch (scale()) {
1542     case times_1: break;
1543     case times_2: out-&gt;print(&quot; * 2&quot;); break;
1544     case times_4: out-&gt;print(&quot; * 4&quot;); break;
1545     case times_8: out-&gt;print(&quot; * 8&quot;); break;
1546     }
1547   }
1548   out-&gt;print(&quot; Disp: &quot; INTX_FORMAT, _disp);
1549 }
1550 
1551 // debug output of block header without InstructionPrinter
1552 //       (because phi functions are not necessary for LIR)
1553 static void print_block(BlockBegin* x) {
1554   // print block id
1555   BlockEnd* end = x-&gt;end();
1556   tty-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
1557 
1558   // print flags
1559   if (x-&gt;is_set(BlockBegin::std_entry_flag))               tty-&gt;print(&quot;std &quot;);
1560   if (x-&gt;is_set(BlockBegin::osr_entry_flag))               tty-&gt;print(&quot;osr &quot;);
1561   if (x-&gt;is_set(BlockBegin::exception_entry_flag))         tty-&gt;print(&quot;ex &quot;);
1562   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag))        tty-&gt;print(&quot;jsr &quot;);
1563   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag))  tty-&gt;print(&quot;bb &quot;);
1564   if (x-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) tty-&gt;print(&quot;lh &quot;);
1565   if (x-&gt;is_set(BlockBegin::linear_scan_loop_end_flag))    tty-&gt;print(&quot;le &quot;);
1566 
1567   // print block bci range
1568   tty-&gt;print(&quot;[%d, %d] &quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
1569 
1570   // print predecessors and successors
1571   if (x-&gt;number_of_preds() &gt; 0) {
1572     tty-&gt;print(&quot;preds: &quot;);
1573     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
1574       tty-&gt;print(&quot;B%d &quot;, x-&gt;pred_at(i)-&gt;block_id());
1575     }
1576   }
1577 
1578   if (x-&gt;number_of_sux() &gt; 0) {
1579     tty-&gt;print(&quot;sux: &quot;);
1580     for (int i = 0; i &lt; x-&gt;number_of_sux(); i ++) {
1581       tty-&gt;print(&quot;B%d &quot;, x-&gt;sux_at(i)-&gt;block_id());
1582     }
1583   }
1584 
1585   // print exception handlers
1586   if (x-&gt;number_of_exception_handlers() &gt; 0) {
1587     tty-&gt;print(&quot;xhandler: &quot;);
1588     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
1589       tty-&gt;print(&quot;B%d &quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
1590     }
1591   }
1592 
1593   tty-&gt;cr();
1594 }
1595 
1596 void print_LIR(BlockList* blocks) {
1597   tty-&gt;print_cr(&quot;LIR:&quot;);
1598   int i;
1599   for (i = 0; i &lt; blocks-&gt;length(); i++) {
1600     BlockBegin* bb = blocks-&gt;at(i);
1601     print_block(bb);
1602     tty-&gt;print(&quot;__id_Instruction___________________________________________&quot;); tty-&gt;cr();
1603     bb-&gt;lir()-&gt;print_instructions();
1604   }
1605 }
1606 
1607 void LIR_List::print_instructions() {
1608   for (int i = 0; i &lt; _operations.length(); i++) {
1609     _operations.at(i)-&gt;print(); tty-&gt;cr();
1610   }
1611   tty-&gt;cr();
1612 }
1613 
1614 // LIR_Ops printing routines
1615 // LIR_Op
1616 void LIR_Op::print_on(outputStream* out) const {
1617   if (id() != -1 || PrintCFGToFile) {
1618     out-&gt;print(&quot;%4d &quot;, id());
1619   } else {
1620     out-&gt;print(&quot;     &quot;);
1621   }
1622   out-&gt;print(&quot;%s &quot;, name());
1623   print_instr(out);
1624   if (info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info()-&gt;stack()-&gt;bci());
1625 #ifdef ASSERT
1626   if (Verbose &amp;&amp; _file != NULL) {
1627     out-&gt;print(&quot; (%s:%d)&quot;, _file, _line);
1628   }
1629 #endif
1630 }
1631 
1632 const char * LIR_Op::name() const {
1633   const char* s = NULL;
1634   switch(code()) {
1635      // LIR_Op0
1636      case lir_membar:                s = &quot;membar&quot;;        break;
1637      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1638      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1639      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1640      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1641      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1642      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1643      case lir_word_align:            s = &quot;word_align&quot;;    break;
1644      case lir_label:                 s = &quot;label&quot;;         break;
1645      case lir_nop:                   s = &quot;nop&quot;;           break;
1646      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1647      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1648      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1649      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1650      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1651      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
<a name="3" id="anc3"></a><span class="line-removed">1652      case lir_24bit_FPU:             s = &quot;24bit_FPU&quot;;     break;</span>
<span class="line-removed">1653      case lir_reset_FPU:             s = &quot;reset_FPU&quot;;     break;</span>
1654      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1655      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1656      // LIR_Op1
1657      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1658      case lir_fld:                   s = &quot;fld&quot;;           break;
<a name="4" id="anc4"></a><span class="line-removed">1659      case lir_ffree:                 s = &quot;ffree&quot;;         break;</span>
1660      case lir_push:                  s = &quot;push&quot;;          break;
1661      case lir_pop:                   s = &quot;pop&quot;;           break;
1662      case lir_null_check:            s = &quot;null_check&quot;;    break;
1663      case lir_return:                s = &quot;return&quot;;        break;
1664      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1665      case lir_leal:                  s = &quot;leal&quot;;          break;
1666      case lir_branch:                s = &quot;branch&quot;;        break;
1667      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1668      case lir_move:                  s = &quot;move&quot;;          break;
1669      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1670      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1671      case lir_throw:                 s = &quot;throw&quot;;         break;
1672      case lir_unwind:                s = &quot;unwind&quot;;        break;
1673      case lir_convert:               s = &quot;convert&quot;;       break;
1674      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1675      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1676      case lir_pack64:                s = &quot;pack64&quot;;        break;
1677      case lir_unpack64:              s = &quot;unpack64&quot;;      break;
1678      // LIR_Op2
1679      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1680      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1681      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1682      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1683      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1684      case lir_add:                   s = &quot;add&quot;;           break;
1685      case lir_sub:                   s = &quot;sub&quot;;           break;
1686      case lir_mul:                   s = &quot;mul&quot;;           break;
1687      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1688      case lir_div:                   s = &quot;div&quot;;           break;
1689      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1690      case lir_rem:                   s = &quot;rem&quot;;           break;
1691      case lir_abs:                   s = &quot;abs&quot;;           break;
1692      case lir_neg:                   s = &quot;neg&quot;;           break;
1693      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1694      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1695      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1696      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1697      case lir_shl:                   s = &quot;shift_left&quot;;    break;
1698      case lir_shr:                   s = &quot;shift_right&quot;;   break;
1699      case lir_ushr:                  s = &quot;ushift_right&quot;;  break;
1700      case lir_alloc_array:           s = &quot;alloc_array&quot;;   break;
1701      case lir_xadd:                  s = &quot;xadd&quot;;          break;
1702      case lir_xchg:                  s = &quot;xchg&quot;;          break;
1703      // LIR_Op3
1704      case lir_idiv:                  s = &quot;idiv&quot;;          break;
1705      case lir_irem:                  s = &quot;irem&quot;;          break;
1706      case lir_fmad:                  s = &quot;fmad&quot;;          break;
1707      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1708      // LIR_OpJavaCall
1709      case lir_static_call:           s = &quot;static&quot;;        break;
1710      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1711      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1712      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1713      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1714      // LIR_OpArrayCopy
1715      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1716      // LIR_OpUpdateCRC32
1717      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1718      // LIR_OpLock
1719      case lir_lock:                  s = &quot;lock&quot;;          break;
1720      case lir_unlock:                s = &quot;unlock&quot;;        break;
1721      // LIR_OpDelay
1722      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1723      // LIR_OpTypeCheck
1724      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1725      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1726      case lir_store_check:           s = &quot;store_check&quot;;   break;
1727      // LIR_OpCompareAndSwap
1728      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1729      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1730      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1731      // LIR_OpProfileCall
1732      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1733      // LIR_OpProfileType
1734      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1735      // LIR_OpAssert
1736 #ifdef ASSERT
1737      case lir_assert:                s = &quot;assert&quot;;        break;
1738 #endif
1739      case lir_none:                  ShouldNotReachHere();break;
1740     default:                         s = &quot;illegal_op&quot;;    break;
1741   }
1742   return s;
1743 }
1744 
1745 // LIR_OpJavaCall
1746 void LIR_OpJavaCall::print_instr(outputStream* out) const {
1747   out-&gt;print(&quot;call: &quot;);
1748   out-&gt;print(&quot;[addr: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(address()));
1749   if (receiver()-&gt;is_valid()) {
1750     out-&gt;print(&quot; [recv: &quot;);   receiver()-&gt;print(out);   out-&gt;print(&quot;]&quot;);
1751   }
1752   if (result_opr()-&gt;is_valid()) {
1753     out-&gt;print(&quot; [result: &quot;); result_opr()-&gt;print(out); out-&gt;print(&quot;]&quot;);
1754   }
1755 }
1756 
1757 // LIR_OpLabel
1758 void LIR_OpLabel::print_instr(outputStream* out) const {
1759   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(_label));
1760 }
1761 
1762 // LIR_OpArrayCopy
1763 void LIR_OpArrayCopy::print_instr(outputStream* out) const {
1764   src()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1765   src_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1766   dst()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1767   dst_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1768   length()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1769   tmp()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1770 }
1771 
1772 // LIR_OpUpdateCRC32
1773 void LIR_OpUpdateCRC32::print_instr(outputStream* out) const {
1774   crc()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1775   val()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1776   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1777 }
1778 
1779 // LIR_OpCompareAndSwap
1780 void LIR_OpCompareAndSwap::print_instr(outputStream* out) const {
1781   addr()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1782   cmp_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1783   new_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1784   tmp1()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1785   tmp2()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1786 
1787 }
1788 
1789 // LIR_Op0
1790 void LIR_Op0::print_instr(outputStream* out) const {
1791   result_opr()-&gt;print(out);
1792 }
1793 
1794 // LIR_Op1
1795 const char * LIR_Op1::name() const {
1796   if (code() == lir_move) {
1797     switch (move_kind()) {
1798     case lir_move_normal:
1799       return &quot;move&quot;;
1800     case lir_move_unaligned:
1801       return &quot;unaligned move&quot;;
1802     case lir_move_volatile:
1803       return &quot;volatile_move&quot;;
1804     case lir_move_wide:
1805       return &quot;wide_move&quot;;
1806     default:
1807       ShouldNotReachHere();
1808     return &quot;illegal_op&quot;;
1809     }
1810   } else {
1811     return LIR_Op::name();
1812   }
1813 }
1814 
1815 
1816 void LIR_Op1::print_instr(outputStream* out) const {
1817   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1818   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1819   print_patch_code(out, patch_code());
1820 }
1821 
1822 
1823 // LIR_Op1
1824 void LIR_OpRTCall::print_instr(outputStream* out) const {
1825   intx a = (intx)addr();
1826   out-&gt;print(&quot;%s&quot;, Runtime1::name_for_address(addr()));
1827   out-&gt;print(&quot; &quot;);
1828   tmp()-&gt;print(out);
1829 }
1830 
1831 void LIR_Op1::print_patch_code(outputStream* out, LIR_PatchCode code) {
1832   switch(code) {
1833     case lir_patch_none:                                 break;
1834     case lir_patch_low:    out-&gt;print(&quot;[patch_low]&quot;);    break;
1835     case lir_patch_high:   out-&gt;print(&quot;[patch_high]&quot;);   break;
1836     case lir_patch_normal: out-&gt;print(&quot;[patch_normal]&quot;); break;
1837     default: ShouldNotReachHere();
1838   }
1839 }
1840 
1841 // LIR_OpBranch
1842 void LIR_OpBranch::print_instr(outputStream* out) const {
1843   print_condition(out, cond());             out-&gt;print(&quot; &quot;);
1844   if (block() != NULL) {
1845     out-&gt;print(&quot;[B%d] &quot;, block()-&gt;block_id());
1846   } else if (stub() != NULL) {
1847     out-&gt;print(&quot;[&quot;);
1848     stub()-&gt;print_name(out);
1849     out-&gt;print(&quot;: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()));
1850     if (stub()-&gt;info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, stub()-&gt;info()-&gt;stack()-&gt;bci());
1851   } else {
1852     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;] &quot;, p2i(label()));
1853   }
1854   if (ublock() != NULL) {
1855     out-&gt;print(&quot;unordered: [B%d] &quot;, ublock()-&gt;block_id());
1856   }
1857 }
1858 
1859 void LIR_Op::print_condition(outputStream* out, LIR_Condition cond) {
1860   switch(cond) {
1861     case lir_cond_equal:           out-&gt;print(&quot;[EQ]&quot;);      break;
1862     case lir_cond_notEqual:        out-&gt;print(&quot;[NE]&quot;);      break;
1863     case lir_cond_less:            out-&gt;print(&quot;[LT]&quot;);      break;
1864     case lir_cond_lessEqual:       out-&gt;print(&quot;[LE]&quot;);      break;
1865     case lir_cond_greaterEqual:    out-&gt;print(&quot;[GE]&quot;);      break;
1866     case lir_cond_greater:         out-&gt;print(&quot;[GT]&quot;);      break;
1867     case lir_cond_belowEqual:      out-&gt;print(&quot;[BE]&quot;);      break;
1868     case lir_cond_aboveEqual:      out-&gt;print(&quot;[AE]&quot;);      break;
1869     case lir_cond_always:          out-&gt;print(&quot;[AL]&quot;);      break;
1870     default:                       out-&gt;print(&quot;[%d]&quot;,cond); break;
1871   }
1872 }
1873 
1874 // LIR_OpConvert
1875 void LIR_OpConvert::print_instr(outputStream* out) const {
1876   print_bytecode(out, bytecode());
1877   in_opr()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1878   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1879 #ifdef PPC32
1880   if(tmp1()-&gt;is_valid()) {
1881     tmp1()-&gt;print(out); out-&gt;print(&quot; &quot;);
1882     tmp2()-&gt;print(out); out-&gt;print(&quot; &quot;);
1883   }
1884 #endif
1885 }
1886 
1887 void LIR_OpConvert::print_bytecode(outputStream* out, Bytecodes::Code code) {
1888   switch(code) {
1889     case Bytecodes::_d2f: out-&gt;print(&quot;[d2f] &quot;); break;
1890     case Bytecodes::_d2i: out-&gt;print(&quot;[d2i] &quot;); break;
1891     case Bytecodes::_d2l: out-&gt;print(&quot;[d2l] &quot;); break;
1892     case Bytecodes::_f2d: out-&gt;print(&quot;[f2d] &quot;); break;
1893     case Bytecodes::_f2i: out-&gt;print(&quot;[f2i] &quot;); break;
1894     case Bytecodes::_f2l: out-&gt;print(&quot;[f2l] &quot;); break;
1895     case Bytecodes::_i2b: out-&gt;print(&quot;[i2b] &quot;); break;
1896     case Bytecodes::_i2c: out-&gt;print(&quot;[i2c] &quot;); break;
1897     case Bytecodes::_i2d: out-&gt;print(&quot;[i2d] &quot;); break;
1898     case Bytecodes::_i2f: out-&gt;print(&quot;[i2f] &quot;); break;
1899     case Bytecodes::_i2l: out-&gt;print(&quot;[i2l] &quot;); break;
1900     case Bytecodes::_i2s: out-&gt;print(&quot;[i2s] &quot;); break;
1901     case Bytecodes::_l2i: out-&gt;print(&quot;[l2i] &quot;); break;
1902     case Bytecodes::_l2f: out-&gt;print(&quot;[l2f] &quot;); break;
1903     case Bytecodes::_l2d: out-&gt;print(&quot;[l2d] &quot;); break;
1904     default:
1905       out-&gt;print(&quot;[?%d]&quot;,code);
1906     break;
1907   }
1908 }
1909 
1910 void LIR_OpAllocObj::print_instr(outputStream* out) const {
1911   klass()-&gt;print(out);                      out-&gt;print(&quot; &quot;);
1912   obj()-&gt;print(out);                        out-&gt;print(&quot; &quot;);
1913   tmp1()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1914   tmp2()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1915   tmp3()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1916   tmp4()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1917   out-&gt;print(&quot;[hdr:%d]&quot;, header_size()); out-&gt;print(&quot; &quot;);
1918   out-&gt;print(&quot;[obj:%d]&quot;, object_size()); out-&gt;print(&quot; &quot;);
1919   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1920 }
1921 
1922 void LIR_OpRoundFP::print_instr(outputStream* out) const {
1923   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1924   tmp()-&gt;print(out);        out-&gt;print(&quot; &quot;);
1925   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1926 }
1927 
1928 // LIR_Op2
1929 void LIR_Op2::print_instr(outputStream* out) const {
1930   if (code() == lir_cmove || code() == lir_cmp) {
1931     print_condition(out, condition());         out-&gt;print(&quot; &quot;);
1932   }
1933   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1934   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1935   if (tmp1_opr()-&gt;is_valid()) { tmp1_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1936   if (tmp2_opr()-&gt;is_valid()) { tmp2_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1937   if (tmp3_opr()-&gt;is_valid()) { tmp3_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1938   if (tmp4_opr()-&gt;is_valid()) { tmp4_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1939   if (tmp5_opr()-&gt;is_valid()) { tmp5_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1940   result_opr()-&gt;print(out);
1941 }
1942 
1943 void LIR_OpAllocArray::print_instr(outputStream* out) const {
1944   klass()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
1945   len()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
1946   obj()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
1947   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1948   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1949   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1950   tmp4()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1951   out-&gt;print(&quot;[type:0x%x]&quot;, type());     out-&gt;print(&quot; &quot;);
1952   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1953 }
1954 
1955 
1956 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
1957   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1958   if (code() == lir_store_check) {
1959     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
1960   }
1961   if (code() != lir_store_check) {
1962     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
1963     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
1964   }
1965   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1966   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1967   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1968   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1969   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
1970 }
1971 
1972 
1973 // LIR_Op3
1974 void LIR_Op3::print_instr(outputStream* out) const {
1975   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1976   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1977   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1978   result_opr()-&gt;print(out);
1979 }
1980 
1981 
1982 void LIR_OpLock::print_instr(outputStream* out) const {
1983   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1984   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1985   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1986   if (_scratch-&gt;is_valid()) {
1987     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
1988   }
1989   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1990 }
1991 
1992 #ifdef ASSERT
1993 void LIR_OpAssert::print_instr(outputStream* out) const {
1994   print_condition(out, condition()); out-&gt;print(&quot; &quot;);
1995   in_opr1()-&gt;print(out);             out-&gt;print(&quot; &quot;);
1996   in_opr2()-&gt;print(out);             out-&gt;print(&quot;, \&quot;&quot;);
1997   out-&gt;print(&quot;%s&quot;, msg());          out-&gt;print(&quot;\&quot;&quot;);
1998 }
1999 #endif
2000 
2001 
2002 void LIR_OpDelay::print_instr(outputStream* out) const {
2003   _op-&gt;print_on(out);
2004 }
2005 
2006 
2007 // LIR_OpProfileCall
2008 void LIR_OpProfileCall::print_instr(outputStream* out) const {
2009   profiled_method()-&gt;name()-&gt;print_symbol_on(out);
2010   out-&gt;print(&quot;.&quot;);
2011   profiled_method()-&gt;holder()-&gt;name()-&gt;print_symbol_on(out);
2012   out-&gt;print(&quot; @ %d &quot;, profiled_bci());
2013   mdo()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2014   recv()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2015   tmp1()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2016 }
2017 
2018 // LIR_OpProfileType
2019 void LIR_OpProfileType::print_instr(outputStream* out) const {
2020   out-&gt;print(&quot;exact = &quot;);
2021   if  (exact_klass() == NULL) {
2022     out-&gt;print(&quot;unknown&quot;);
2023   } else {
2024     exact_klass()-&gt;print_name_on(out);
2025   }
2026   out-&gt;print(&quot; current = &quot;); ciTypeEntries::print_ciklass(out, current_klass());
2027   out-&gt;print(&quot; &quot;);
2028   mdp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2029   obj()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2030   tmp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2031 }
2032 
2033 #endif // PRODUCT
2034 
2035 // Implementation of LIR_InsertionBuffer
2036 
2037 void LIR_InsertionBuffer::append(int index, LIR_Op* op) {
2038   assert(_index_and_count.length() % 2 == 0, &quot;must have a count for each index&quot;);
2039 
2040   int i = number_of_insertion_points() - 1;
2041   if (i &lt; 0 || index_at(i) &lt; index) {
2042     append_new(index, 1);
2043   } else {
2044     assert(index_at(i) == index, &quot;can append LIR_Ops in ascending order only&quot;);
2045     assert(count_at(i) &gt; 0, &quot;check&quot;);
2046     set_count_at(i, count_at(i) + 1);
2047   }
2048   _ops.push(op);
2049 
2050   DEBUG_ONLY(verify());
2051 }
2052 
2053 #ifdef ASSERT
2054 void LIR_InsertionBuffer::verify() {
2055   int sum = 0;
2056   int prev_idx = -1;
2057 
2058   for (int i = 0; i &lt; number_of_insertion_points(); i++) {
2059     assert(prev_idx &lt; index_at(i), &quot;index must be ordered ascending&quot;);
2060     sum += count_at(i);
2061   }
2062   assert(sum == number_of_ops(), &quot;wrong total sum&quot;);
2063 }
2064 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
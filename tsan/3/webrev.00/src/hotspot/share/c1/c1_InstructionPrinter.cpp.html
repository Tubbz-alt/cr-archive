<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_InstructionPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 27 #include &quot;c1/c1_ValueStack.hpp&quot;
 28 #include &quot;ci/ciArray.hpp&quot;
 29 #include &quot;ci/ciInstance.hpp&quot;
 30 #include &quot;ci/ciObject.hpp&quot;
 31 
 32 
 33 #ifndef PRODUCT
 34 
 35 const char* InstructionPrinter::basic_type_name(BasicType type) {
 36   const char* n = type2name(type);
 37   if (n == NULL || type &gt; T_VOID) {
 38     return &quot;???&quot;;
 39   }
 40   return n;
 41 }
 42 
 43 
 44 const char* InstructionPrinter::cond_name(If::Condition cond) {
 45   switch (cond) {
 46     case If::eql: return &quot;==&quot;;
 47     case If::neq: return &quot;!=&quot;;
 48     case If::lss: return &quot;&lt;&quot;;
 49     case If::leq: return &quot;&lt;=&quot;;
 50     case If::gtr: return &quot;&gt;&quot;;
 51     case If::geq: return &quot;&gt;=&quot;;
 52     case If::aeq: return &quot;|&gt;=|&quot;;
 53     case If::beq: return &quot;|&lt;=|&quot;;
 54     default:
 55       ShouldNotReachHere();
 56       return NULL;
 57   }
 58 }
 59 
 60 
 61 const char* InstructionPrinter::op_name(Bytecodes::Code op) {
 62   switch (op) {
 63     // arithmetic ops
 64     case Bytecodes::_iadd : // fall through
 65     case Bytecodes::_ladd : // fall through
 66     case Bytecodes::_fadd : // fall through
 67     case Bytecodes::_dadd : return &quot;+&quot;;
 68     case Bytecodes::_isub : // fall through
 69     case Bytecodes::_lsub : // fall through
 70     case Bytecodes::_fsub : // fall through
 71     case Bytecodes::_dsub : return &quot;-&quot;;
 72     case Bytecodes::_imul : // fall through
 73     case Bytecodes::_lmul : // fall through
 74     case Bytecodes::_fmul : // fall through
 75     case Bytecodes::_dmul : return &quot;*&quot;;
 76     case Bytecodes::_idiv : // fall through
 77     case Bytecodes::_ldiv : // fall through
 78     case Bytecodes::_fdiv : // fall through
 79     case Bytecodes::_ddiv : return &quot;/&quot;;
 80     case Bytecodes::_irem : // fall through
 81     case Bytecodes::_lrem : // fall through
 82     case Bytecodes::_frem : // fall through
 83     case Bytecodes::_drem : return &quot;%&quot;;
 84     // shift ops
 85     case Bytecodes::_ishl : // fall through
 86     case Bytecodes::_lshl : return &quot;&lt;&lt;&quot;;
 87     case Bytecodes::_ishr : // fall through
 88     case Bytecodes::_lshr : return &quot;&gt;&gt;&quot;;
 89     case Bytecodes::_iushr: // fall through
 90     case Bytecodes::_lushr: return &quot;&gt;&gt;&gt;&quot;;
 91     // logic ops
 92     case Bytecodes::_iand : // fall through
 93     case Bytecodes::_land : return &quot;&amp;&quot;;
 94     case Bytecodes::_ior  : // fall through
 95     case Bytecodes::_lor  : return &quot;|&quot;;
 96     case Bytecodes::_ixor : // fall through
 97     case Bytecodes::_lxor : return &quot;^&quot;;
 98     default               : return Bytecodes::name(op);
 99   }
100 }
101 
102 
103 bool InstructionPrinter::is_illegal_phi(Value v) {
104   Phi* phi = v ? v-&gt;as_Phi() : NULL;
105   if (phi &amp;&amp; phi-&gt;is_illegal()) {
106     return true;
107   }
108   return false;
109 }
110 
111 
112 bool InstructionPrinter::is_phi_of_block(Value v, BlockBegin* b) {
113   Phi* phi = v ? v-&gt;as_Phi() : NULL;
114   return phi &amp;&amp; phi-&gt;block() == b;
115 }
116 
117 
118 void InstructionPrinter::print_klass(ciKlass* klass) {
119   klass-&gt;name()-&gt;print_symbol_on(output());
120 }
121 
122 
123 void InstructionPrinter::print_object(Value obj) {
124   ValueType* type = obj-&gt;type();
125   if (type-&gt;as_ObjectConstant() != NULL) {
126     ciObject* value = type-&gt;as_ObjectConstant()-&gt;value();
127     if (value-&gt;is_null_object()) {
128       output()-&gt;print(&quot;null&quot;);
129     } else if (!value-&gt;is_loaded()) {
130       output()-&gt;print(&quot;&lt;unloaded object &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(value));
131     } else {
132       output()-&gt;print(&quot;&lt;object &quot; INTPTR_FORMAT &quot; klass=&quot;, p2i(value-&gt;constant_encoding()));
133       print_klass(value-&gt;klass());
134       output()-&gt;print(&quot;&gt;&quot;);
135     }
136   } else if (type-&gt;as_InstanceConstant() != NULL) {
137     ciInstance* value = type-&gt;as_InstanceConstant()-&gt;value();
138     if (value-&gt;is_loaded()) {
139       output()-&gt;print(&quot;&lt;instance &quot; INTPTR_FORMAT &quot; klass=&quot;, p2i(value-&gt;constant_encoding()));
140       print_klass(value-&gt;klass());
141       output()-&gt;print(&quot;&gt;&quot;);
142     } else {
143       output()-&gt;print(&quot;&lt;unloaded instance &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(value));
144     }
145   } else if (type-&gt;as_ArrayConstant() != NULL) {
146     output()-&gt;print(&quot;&lt;array &quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(type-&gt;as_ArrayConstant()-&gt;value()-&gt;constant_encoding()));
147   } else if (type-&gt;as_ClassConstant() != NULL) {
148     ciInstanceKlass* klass = type-&gt;as_ClassConstant()-&gt;value();
149     if (!klass-&gt;is_loaded()) {
150       output()-&gt;print(&quot;&lt;unloaded&gt; &quot;);
151     }
152     output()-&gt;print(&quot;class &quot;);
153     print_klass(klass);
154   } else if (type-&gt;as_MethodConstant() != NULL) {
155     ciMethod* m = type-&gt;as_MethodConstant()-&gt;value();
156     output()-&gt;print(&quot;&lt;method %s.%s&gt;&quot;, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
157   } else {
158     output()-&gt;print(&quot;???&quot;);
159   }
160 }
161 
162 
163 void InstructionPrinter::print_temp(Value value) {
164   output()-&gt;print(&quot;%c%d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id());
165 }
166 
167 
168 void InstructionPrinter::print_field(AccessField* field) {
169   print_value(field-&gt;obj());
170   output()-&gt;print(&quot;._%d&quot;, field-&gt;offset());
171 }
172 
173 
174 void InstructionPrinter::print_indexed(AccessIndexed* indexed) {
175   print_value(indexed-&gt;array());
176   output()-&gt;put(&#39;[&#39;);
177   print_value(indexed-&gt;index());
178   output()-&gt;put(&#39;]&#39;);
179   if (indexed-&gt;length() != NULL) {
180     output()-&gt;put(&#39;(&#39;);
181     print_value(indexed-&gt;length());
182     output()-&gt;put(&#39;)&#39;);
183   }
184 }
185 
186 
187 void InstructionPrinter::print_monitor(AccessMonitor* monitor) {
188   output()-&gt;print(&quot;monitor[%d](&quot;, monitor-&gt;monitor_no());
189   print_value(monitor-&gt;obj());
190   output()-&gt;put(&#39;)&#39;);
191 }
192 
193 
194 void InstructionPrinter::print_op2(Op2* instr) {
195   print_value(instr-&gt;x());
196   output()-&gt;print(&quot; %s &quot;, op_name(instr-&gt;op()));
197   print_value(instr-&gt;y());
198 }
199 
200 
201 void InstructionPrinter::print_value(Value value) {
202   if (value == NULL) {
203     output()-&gt;print(&quot;NULL&quot;);
204   } else {
205     print_temp(value);
206   }
207 }
208 
209 
210 void InstructionPrinter::print_instr(Instruction* instr) {
211   instr-&gt;visit(this);
212 }
213 
214 
215 void InstructionPrinter::print_stack(ValueStack* stack) {
216   int start_position = output()-&gt;position();
217   if (stack-&gt;stack_is_empty()) {
218     output()-&gt;print(&quot;empty stack&quot;);
219   } else {
220     output()-&gt;print(&quot;stack [&quot;);
221     for (int i = 0; i &lt; stack-&gt;stack_size();) {
222       if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
223       output()-&gt;print(&quot;%d:&quot;, i);
224       Value value = stack-&gt;stack_at_inc(i);
225       print_value(value);
226       Phi* phi = value-&gt;as_Phi();
227       if (phi != NULL) {
228         if (phi-&gt;operand()-&gt;is_valid()) {
229           output()-&gt;print(&quot; &quot;);
230           phi-&gt;operand()-&gt;print(output());
231         }
232       }
233     }
234     output()-&gt;put(&#39;]&#39;);
235   }
236   if (!stack-&gt;no_active_locks()) {
237     // print out the lines on the line below this
238     // one at the same indentation level.
239     output()-&gt;cr();
240     fill_to(start_position, &#39; &#39;);
241     output()-&gt;print(&quot;locks [&quot;);
242     for (int i = i = 0; i &lt; stack-&gt;locks_size(); i++) {
243       Value t = stack-&gt;lock_at(i);
244       if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
245       output()-&gt;print(&quot;%d:&quot;, i);
246       if (t == NULL) {
247         // synchronized methods push null on the lock stack
248         output()-&gt;print(&quot;this&quot;);
249       } else {
250         print_value(t);
251       }
252     }
253     output()-&gt;print(&quot;]&quot;);
254   }
255 }
256 
257 
258 void InstructionPrinter::print_inline_level(BlockBegin* block) {
259   output()-&gt;print_cr(&quot;inlining depth %d&quot;, block-&gt;scope()-&gt;level());
260 }
261 
262 
263 void InstructionPrinter::print_unsafe_op(UnsafeOp* op, const char* name) {
264   output()-&gt;print(&quot;%s&quot;, name);
265   output()-&gt;print(&quot;.(&quot;);
266 }
267 
268 void InstructionPrinter::print_unsafe_raw_op(UnsafeRawOp* op, const char* name) {
269   print_unsafe_op(op, name);
270   output()-&gt;print(&quot;base &quot;);
271   print_value(op-&gt;base());
272   if (op-&gt;has_index()) {
273     output()-&gt;print(&quot;, index &quot;); print_value(op-&gt;index());
274     output()-&gt;print(&quot;, log2_scale %d&quot;, op-&gt;log2_scale());
275   }
276 }
277 
278 
279 void InstructionPrinter::print_unsafe_object_op(UnsafeObjectOp* op, const char* name) {
280   print_unsafe_op(op, name);
281   print_value(op-&gt;object());
282   output()-&gt;print(&quot;, &quot;);
283   print_value(op-&gt;offset());
284 }
285 
286 
287 void InstructionPrinter::print_phi(int i, Value v, BlockBegin* b) {
288   Phi* phi = v-&gt;as_Phi();
289   output()-&gt;print(&quot;%2d  &quot;, i);
290   print_value(v);
291   // print phi operands
292   if (phi &amp;&amp; phi-&gt;block() == b) {
293     output()-&gt;print(&quot; [&quot;);
294     for (int j = 0; j &lt; phi-&gt;operand_count(); j ++) {
295       output()-&gt;print(&quot; &quot;);
296       Value opd = phi-&gt;operand_at(j);
297       if (opd) print_value(opd);
298       else output()-&gt;print(&quot;NULL&quot;);
299     }
300     output()-&gt;print(&quot;] &quot;);
301   }
302   print_alias(v);
303 }
304 
305 
306 void InstructionPrinter::print_alias(Value v) {
307   if (v != v-&gt;subst()) {
308     output()-&gt;print(&quot;alias &quot;); print_value(v-&gt;subst());
309   }
310 }
311 
312 
313 void InstructionPrinter::fill_to(int pos, char filler) {
314   while (output()-&gt;position() &lt; pos) output()-&gt;put(filler);
315 }
316 
317 
318 void InstructionPrinter::print_head() {
319   const char filler = &#39;_&#39;;
320   fill_to(bci_pos  , filler); output()-&gt;print(&quot;bci&quot;  );
321   fill_to(use_pos  , filler); output()-&gt;print(&quot;use&quot;  );
322   fill_to(temp_pos , filler); output()-&gt;print(&quot;tid&quot;  );
323   fill_to(instr_pos, filler); output()-&gt;print(&quot;instr&quot;);
324   fill_to(end_pos  , filler);
325   output()-&gt;cr();
326 }
327 
328 
329 void InstructionPrinter::print_line(Instruction* instr) {
330   // print instruction data on one line
331   if (instr-&gt;is_pinned()) output()-&gt;put(&#39;.&#39;);
332   if (instr-&gt;has_printable_bci()) {
333     fill_to(bci_pos  ); output()-&gt;print(&quot;%d&quot;, instr-&gt;printable_bci());
334   }
335   fill_to(use_pos  ); output()-&gt;print(&quot;%d&quot;, instr-&gt;use_count());
336   fill_to(temp_pos ); print_temp(instr);
337   fill_to(instr_pos); print_instr(instr);
338   output()-&gt;cr();
339   // add a line for StateSplit instructions w/ non-empty stacks
340   // (make it robust so we can print incomplete instructions)
341   StateSplit* split = instr-&gt;as_StateSplit();
342   if (split != NULL &amp;&amp; split-&gt;state() != NULL &amp;&amp; !split-&gt;state()-&gt;stack_is_empty()) {
343     fill_to(instr_pos); print_stack(split-&gt;state());
344     output()-&gt;cr();
345   }
346 }
347 
348 
349 void InstructionPrinter::do_Phi(Phi* x) {
350   output()-&gt;print(&quot;phi function&quot;);  // make that more detailed later
351   if (x-&gt;is_illegal())
352     output()-&gt;print(&quot; (illegal)&quot;);
353 }
354 
355 
356 void InstructionPrinter::do_Local(Local* x) {
357   output()-&gt;print(&quot;local[index %d]&quot;, x-&gt;java_index());
358 }
359 
360 
361 void InstructionPrinter::do_Constant(Constant* x) {
362   ValueType* t = x-&gt;type();
363   switch (t-&gt;tag()) {
364     case intTag    : output()-&gt;print(&quot;%d&quot;  , t-&gt;as_IntConstant   ()-&gt;value());    break;
365     case longTag   : output()-&gt;print(JLONG_FORMAT, t-&gt;as_LongConstant()-&gt;value()); output()-&gt;print(&quot;L&quot;); break;
366     case floatTag  : output()-&gt;print(&quot;%g&quot;  , t-&gt;as_FloatConstant ()-&gt;value());    break;
367     case doubleTag : output()-&gt;print(&quot;%gD&quot; , t-&gt;as_DoubleConstant()-&gt;value());    break;
368     case objectTag : print_object(x);                                        break;
369     case addressTag: output()-&gt;print(&quot;bci:%d&quot;, t-&gt;as_AddressConstant()-&gt;value()); break;
370     default        : output()-&gt;print(&quot;???&quot;);                                      break;
371   }
372 }
373 
374 
375 void InstructionPrinter::do_LoadField(LoadField* x) {
376   print_field(x);
377   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;field()-&gt;type()-&gt;basic_type()));
378   output()-&gt;print(&quot; %s&quot;, x-&gt;field()-&gt;name()-&gt;as_utf8());
379 }
380 
381 
382 void InstructionPrinter::do_StoreField(StoreField* x) {
383   print_field(x);
384   output()-&gt;print(&quot; := &quot;);
385   print_value(x-&gt;value());
386   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;field()-&gt;type()-&gt;basic_type()));
387   output()-&gt;print(&quot; %s&quot;, x-&gt;field()-&gt;name()-&gt;as_utf8());
388 }
389 
390 
391 void InstructionPrinter::do_ArrayLength(ArrayLength* x) {
392   print_value(x-&gt;array());
393   output()-&gt;print(&quot;.length&quot;);
394 }
395 
396 
397 void InstructionPrinter::do_LoadIndexed(LoadIndexed* x) {
398   print_indexed(x);
399   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;elt_type()));
400   if (x-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) {
401     output()-&gt;print(&quot; [rc]&quot;);
402   }
403 }
404 
405 
406 void InstructionPrinter::do_StoreIndexed(StoreIndexed* x) {
407   print_indexed(x);
408   output()-&gt;print(&quot; := &quot;);
409   print_value(x-&gt;value());
410   output()-&gt;print(&quot; (%c)&quot;, type2char(x-&gt;elt_type()));
411   if (x-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) {
412     output()-&gt;print(&quot; [rc]&quot;);
413   }
414 }
415 
416 void InstructionPrinter::do_NegateOp(NegateOp* x) {
417   output()-&gt;put(&#39;-&#39;);
418   print_value(x-&gt;x());
419 }
420 
421 
422 void InstructionPrinter::do_ArithmeticOp(ArithmeticOp* x) {
423   print_op2(x);
424 }
425 
426 
427 void InstructionPrinter::do_ShiftOp(ShiftOp* x) {
428   print_op2(x);
429 }
430 
431 
432 void InstructionPrinter::do_LogicOp(LogicOp* x) {
433   print_op2(x);
434 }
435 
436 
437 void InstructionPrinter::do_CompareOp(CompareOp* x) {
438   print_op2(x);
439 }
440 
441 
442 void InstructionPrinter::do_IfOp(IfOp* x) {
443   print_value(x-&gt;x());
444   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
445   print_value(x-&gt;y());
446   output()-&gt;print(&quot; ? &quot;);
447   print_value(x-&gt;tval());
448   output()-&gt;print(&quot; : &quot;);
449   print_value(x-&gt;fval());
450 }
451 
452 
453 void InstructionPrinter::do_Convert(Convert* x) {
454   output()-&gt;print(&quot;%s(&quot;, Bytecodes::name(x-&gt;op()));
455   print_value(x-&gt;value());
456   output()-&gt;put(&#39;)&#39;);
457 }
458 
459 
460 void InstructionPrinter::do_NullCheck(NullCheck* x) {
461   output()-&gt;print(&quot;null_check(&quot;);
462   print_value(x-&gt;obj());
463   output()-&gt;put(&#39;)&#39;);
464   if (!x-&gt;can_trap()) {
465     output()-&gt;print(&quot; (eliminated)&quot;);
466   }
467 }
468 
469 
470 void InstructionPrinter::do_TypeCast(TypeCast* x) {
471   output()-&gt;print(&quot;type_cast(&quot;);
472   print_value(x-&gt;obj());
473   output()-&gt;print(&quot;) &quot;);
474   if (x-&gt;declared_type()-&gt;is_klass())
475     print_klass(x-&gt;declared_type()-&gt;as_klass());
476   else
477     output()-&gt;print(&quot;%s&quot;, type2name(x-&gt;declared_type()-&gt;basic_type()));
478 }
479 
480 
481 void InstructionPrinter::do_Invoke(Invoke* x) {
482   if (x-&gt;receiver() != NULL) {
483     print_value(x-&gt;receiver());
484     output()-&gt;print(&quot;.&quot;);
485   }
486 
487   output()-&gt;print(&quot;%s(&quot;, Bytecodes::name(x-&gt;code()));
488   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
489     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
490     print_value(x-&gt;argument_at(i));
491   }
492   output()-&gt;print_cr(&quot;)&quot;);
493   fill_to(instr_pos);
494   output()-&gt;print(&quot;%s.%s%s&quot;,
495              x-&gt;target()-&gt;holder()-&gt;name()-&gt;as_utf8(),
496              x-&gt;target()-&gt;name()-&gt;as_utf8(),
497              x-&gt;target()-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
498 }
499 
500 
501 void InstructionPrinter::do_NewInstance(NewInstance* x) {
502   output()-&gt;print(&quot;new instance &quot;);
503   print_klass(x-&gt;klass());
504 }
505 
506 
507 void InstructionPrinter::do_NewTypeArray(NewTypeArray* x) {
508   output()-&gt;print(&quot;new %s array [&quot;, basic_type_name(x-&gt;elt_type()));
509   print_value(x-&gt;length());
510   output()-&gt;put(&#39;]&#39;);
511 }
512 
513 
514 void InstructionPrinter::do_NewObjectArray(NewObjectArray* x) {
515   output()-&gt;print(&quot;new object array [&quot;);
516   print_value(x-&gt;length());
517   output()-&gt;print(&quot;] &quot;);
518   print_klass(x-&gt;klass());
519 }
520 
521 
522 void InstructionPrinter::do_NewMultiArray(NewMultiArray* x) {
523   output()-&gt;print(&quot;new multi array [&quot;);
524   Values* dims = x-&gt;dims();
525   for (int i = 0; i &lt; dims-&gt;length(); i++) {
526     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
527     print_value(dims-&gt;at(i));
528   }
529   output()-&gt;print(&quot;] &quot;);
530   print_klass(x-&gt;klass());
531 }
532 
533 
534 void InstructionPrinter::do_MonitorEnter(MonitorEnter* x) {
535   output()-&gt;print(&quot;enter &quot;);
536   print_monitor(x);
537 }
538 
539 
540 void InstructionPrinter::do_MonitorExit(MonitorExit* x) {
541   output()-&gt;print(&quot;exit &quot;);
542   print_monitor(x);
543 }
544 
545 
546 void InstructionPrinter::do_Intrinsic(Intrinsic* x) {
547   const char* name = vmIntrinsics::name_at(x-&gt;id());
548   if (name[0] == &#39;_&#39;)  name++;  // strip leading bug from _hashCode, etc.
549   const char* kname = vmSymbols::name_for(vmIntrinsics::class_for(x-&gt;id()));
550   if (strchr(name, &#39;_&#39;) == NULL) {
551     kname = NULL;
552   } else {
553     const char* kptr = strrchr(kname, &#39;/&#39;);
554     if (kptr != NULL)  kname = kptr + 1;
555   }
556   if (kname == NULL)
557     output()-&gt;print(&quot;%s(&quot;, name);
558   else
559     output()-&gt;print(&quot;%s.%s(&quot;, kname, name);
560   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
561     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
562     print_value(x-&gt;argument_at(i));
563   }
564   output()-&gt;put(&#39;)&#39;);
565 }
566 
567 
568 void InstructionPrinter::do_BlockBegin(BlockBegin* x) {
569   // print block id
570   BlockEnd* end = x-&gt;end();
571   output()-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
572 
573   // print flags
574   bool printed_flag = false;
575   if (x-&gt;is_set(BlockBegin::std_entry_flag)) {
576     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
577     output()-&gt;print(&quot;S&quot;); printed_flag = true;
578   }
579   if (x-&gt;is_set(BlockBegin::osr_entry_flag)) {
580     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
581     output()-&gt;print(&quot;O&quot;); printed_flag = true;
582   }
583   if (x-&gt;is_set(BlockBegin::exception_entry_flag)) {
584     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
585     output()-&gt;print(&quot;E&quot;); printed_flag = true;
586   }
587   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
588     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
589     output()-&gt;print(&quot;s&quot;); printed_flag = true;
590   }
591   if (x-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
592     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
593     output()-&gt;print(&quot;LH&quot;); printed_flag = true;
594   }
595   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
596     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
597     output()-&gt;print(&quot;b&quot;); printed_flag = true;
598   }
599   if (x-&gt;is_set(BlockBegin::was_visited_flag)) {
600     if (!printed_flag) output()-&gt;print(&quot;(&quot;);
601     output()-&gt;print(&quot;V&quot;); printed_flag = true;
602   }
603   if (printed_flag) output()-&gt;print(&quot;) &quot;);
604 
605   // print block bci range
606   output()-&gt;print(&quot;[%d, %d]&quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
607 
608   // print block successors
609   if (end != NULL &amp;&amp; end-&gt;number_of_sux() &gt; 0) {
610     output()-&gt;print(&quot; -&gt;&quot;);
611     for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
612       output()-&gt;print(&quot; B%d&quot;, end-&gt;sux_at(i)-&gt;block_id());
613     }
614   }
615   // print exception handlers
616   if (x-&gt;number_of_exception_handlers() &gt; 0) {
617     output()-&gt;print(&quot; (xhandlers &quot;);
618     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
619       if (i &gt; 0) output()-&gt;print(&quot; &quot;);
620       output()-&gt;print(&quot;B%d&quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
621     }
622     output()-&gt;put(&#39;)&#39;);
623   }
624 
625   // print dominator block
626   if (x-&gt;dominator() != NULL) {
627     output()-&gt;print(&quot; dom B%d&quot;, x-&gt;dominator()-&gt;block_id());
628   }
629 
630   // print predecessors and successors
631   if (x-&gt;successors()-&gt;length() &gt; 0) {
632     output()-&gt;print(&quot; sux:&quot;);
633     for (int i = 0; i &lt; x-&gt;successors()-&gt;length(); i ++) {
634       output()-&gt;print(&quot; B%d&quot;, x-&gt;successors()-&gt;at(i)-&gt;block_id());
635     }
636   }
637 
638   if (x-&gt;number_of_preds() &gt; 0) {
639     output()-&gt;print(&quot; pred:&quot;);
640     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
641       output()-&gt;print(&quot; B%d&quot;, x-&gt;pred_at(i)-&gt;block_id());
642     }
643   }
644 
645   if (!_print_phis) {
646     return;
647   }
648 
649   // print phi functions
650   bool has_phis_in_locals = false;
651   bool has_phis_on_stack = false;
652 
653   if (x-&gt;end() &amp;&amp; x-&gt;end()-&gt;state()) {
654     ValueStack* state = x-&gt;state();
655 
656     int i = 0;
657     while (!has_phis_on_stack &amp;&amp; i &lt; state-&gt;stack_size()) {
658       Value v = state-&gt;stack_at_inc(i);
659       has_phis_on_stack = is_phi_of_block(v, x);
660     }
661 
662     do {
663       for (i = 0; !has_phis_in_locals &amp;&amp; i &lt; state-&gt;locals_size();) {
664         Value v = state-&gt;local_at(i);
665         has_phis_in_locals = is_phi_of_block(v, x);
666         // also ignore illegal HiWords
667         if (v &amp;&amp; !v-&gt;type()-&gt;is_illegal()) i += v-&gt;type()-&gt;size(); else i ++;
668       }
669       state = state-&gt;caller_state();
670     } while (state != NULL);
671 
672   }
673 
674   // print values in locals
675   if (has_phis_in_locals) {
676     output()-&gt;cr(); output()-&gt;print_cr(&quot;Locals:&quot;);
677 
678     ValueStack* state = x-&gt;state();
679     do {
680       for (int i = 0; i &lt; state-&gt;locals_size();) {
681         Value v = state-&gt;local_at(i);
682         if (v) {
683           print_phi(i, v, x); output()-&gt;cr();
684           // also ignore illegal HiWords
685           i += (v-&gt;type()-&gt;is_illegal() ? 1 : v-&gt;type()-&gt;size());
686         } else {
687           i ++;
688         }
689       }
690       output()-&gt;cr();
691       state = state-&gt;caller_state();
692     } while (state != NULL);
693   }
694 
695   // print values on stack
696   if (has_phis_on_stack) {
697     output()-&gt;print_cr(&quot;Stack:&quot;);
698     int i = 0;
699     while (i &lt; x-&gt;state()-&gt;stack_size()) {
700       int o = i;
701       Value v = x-&gt;state()-&gt;stack_at_inc(i);
702       if (v) {
703         print_phi(o, v, x); output()-&gt;cr();
704       }
705     }
706   }
707 }
708 
709 
710 void InstructionPrinter::do_CheckCast(CheckCast* x) {
711   output()-&gt;print(&quot;checkcast(&quot;);
712   print_value(x-&gt;obj());
713   output()-&gt;print(&quot;) &quot;);
714   print_klass(x-&gt;klass());
715 }
716 
717 
718 void InstructionPrinter::do_InstanceOf(InstanceOf* x) {
719   output()-&gt;print(&quot;instanceof(&quot;);
720   print_value(x-&gt;obj());
721   output()-&gt;print(&quot;) &quot;);
722   print_klass(x-&gt;klass());
723 }
724 
725 
726 void InstructionPrinter::do_Goto(Goto* x) {
727   output()-&gt;print(&quot;goto B%d&quot;, x-&gt;default_sux()-&gt;block_id());
728   if (x-&gt;is_safepoint()) output()-&gt;print(&quot; (safepoint)&quot;);
729 }
730 
731 
732 void InstructionPrinter::do_If(If* x) {
733   output()-&gt;print(&quot;if &quot;);
734   print_value(x-&gt;x());
735   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
736   print_value(x-&gt;y());
737   output()-&gt;print(&quot; then B%d else B%d&quot;, x-&gt;sux_at(0)-&gt;block_id(), x-&gt;sux_at(1)-&gt;block_id());
738   if (x-&gt;is_safepoint()) output()-&gt;print(&quot; (safepoint)&quot;);
739 }
740 
741 
742 void InstructionPrinter::do_IfInstanceOf(IfInstanceOf* x) {
743   output()-&gt;print(&quot;&lt;IfInstanceOf&gt;&quot;);
744 }
745 
746 
747 void InstructionPrinter::do_TableSwitch(TableSwitch* x) {
748   output()-&gt;print(&quot;tableswitch &quot;);
749   if (x-&gt;is_safepoint()) output()-&gt;print(&quot;(safepoint) &quot;);
750   print_value(x-&gt;tag());
751   output()-&gt;cr();
752   int l = x-&gt;length();
753   for (int i = 0; i &lt; l; i++) {
754     fill_to(instr_pos);
755     output()-&gt;print_cr(&quot;case %5d: B%d&quot;, x-&gt;lo_key() + i, x-&gt;sux_at(i)-&gt;block_id());
756   }
757   fill_to(instr_pos);
758   output()-&gt;print(&quot;default   : B%d&quot;, x-&gt;default_sux()-&gt;block_id());
759 }
760 
761 
762 void InstructionPrinter::do_LookupSwitch(LookupSwitch* x) {
763   output()-&gt;print(&quot;lookupswitch &quot;);
764   if (x-&gt;is_safepoint()) output()-&gt;print(&quot;(safepoint) &quot;);
765   print_value(x-&gt;tag());
766   output()-&gt;cr();
767   int l = x-&gt;length();
768   for (int i = 0; i &lt; l; i++) {
769     fill_to(instr_pos);
770     output()-&gt;print_cr(&quot;case %5d: B%d&quot;, x-&gt;key_at(i), x-&gt;sux_at(i)-&gt;block_id());
771   }
772   fill_to(instr_pos);
773   output()-&gt;print(&quot;default   : B%d&quot;, x-&gt;default_sux()-&gt;block_id());
774 }
775 
776 
777 void InstructionPrinter::do_Return(Return* x) {
778   if (x-&gt;result() == NULL) {
779     output()-&gt;print(&quot;return&quot;);
780   } else {
781     output()-&gt;print(&quot;%creturn &quot;, x-&gt;type()-&gt;tchar());
782     print_value(x-&gt;result());
783   }
784 }
785 
786 
787 void InstructionPrinter::do_Throw(Throw* x) {
788   output()-&gt;print(&quot;throw &quot;);
789   print_value(x-&gt;exception());
790 }
791 
792 
793 void InstructionPrinter::do_Base(Base* x) {
794   output()-&gt;print(&quot;std entry B%d&quot;, x-&gt;std_entry()-&gt;block_id());
795   if (x-&gt;number_of_sux() &gt; 1) {
796     output()-&gt;print(&quot; osr entry B%d&quot;, x-&gt;osr_entry()-&gt;block_id());
797   }
798 }
799 
800 
801 void InstructionPrinter::do_OsrEntry(OsrEntry* x) {
802   output()-&gt;print(&quot;osr entry&quot;);
803 }
804 
805 
806 void InstructionPrinter::do_ExceptionObject(ExceptionObject* x) {
807   output()-&gt;print(&quot;incoming exception&quot;);
808 }
809 
810 
811 void InstructionPrinter::do_RoundFP(RoundFP* x) {
812   output()-&gt;print(&quot;round_fp &quot;);
813   print_value(x-&gt;input());
814 }
815 
816 
817 void InstructionPrinter::do_UnsafeGetRaw(UnsafeGetRaw* x) {
818   print_unsafe_raw_op(x, &quot;UnsafeGetRaw&quot;);
819   output()-&gt;put(&#39;)&#39;);
820 }
821 
822 
823 void InstructionPrinter::do_UnsafePutRaw(UnsafePutRaw* x) {
824   print_unsafe_raw_op(x, &quot;UnsafePutRaw&quot;);
825   output()-&gt;print(&quot;, value &quot;);
826   print_value(x-&gt;value());
827   output()-&gt;put(&#39;)&#39;);
828 }
829 
830 
831 void InstructionPrinter::do_UnsafeGetObject(UnsafeGetObject* x) {
832   print_unsafe_object_op(x, &quot;UnsafeGetObject&quot;);
833   output()-&gt;put(&#39;)&#39;);
834 }
835 
836 
837 void InstructionPrinter::do_UnsafePutObject(UnsafePutObject* x) {
838   print_unsafe_object_op(x, &quot;UnsafePutObject&quot;);
839   output()-&gt;print(&quot;, value &quot;);
840   print_value(x-&gt;value());
841   output()-&gt;put(&#39;)&#39;);
842 }
843 
844 void InstructionPrinter::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
845   print_unsafe_object_op(x, x-&gt;is_add()?&quot;UnsafeGetAndSetObject (add)&quot;:&quot;UnsafeGetAndSetObject&quot;);
846   output()-&gt;print(&quot;, value &quot;);
847   print_value(x-&gt;value());
848   output()-&gt;put(&#39;)&#39;);
849 }
850 
851 void InstructionPrinter::do_RangeCheckPredicate(RangeCheckPredicate* x) {
852 
853   if (x-&gt;x() != NULL &amp;&amp; x-&gt;y() != NULL) {
854     output()-&gt;print(&quot;if &quot;);
855     print_value(x-&gt;x());
856     output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
857     print_value(x-&gt;y());
858     output()-&gt;print(&quot; then deoptimize!&quot;);
859   } else {
860     output()-&gt;print(&quot;always deoptimize!&quot;);
861   }
862 }
863 
864 #ifdef ASSERT
865 void InstructionPrinter::do_Assert(Assert* x) {
866   output()-&gt;print(&quot;assert &quot;);
867   print_value(x-&gt;x());
868   output()-&gt;print(&quot; %s &quot;, cond_name(x-&gt;cond()));
869   print_value(x-&gt;y());
870 }
871 #endif
872 
873 void InstructionPrinter::do_ProfileCall(ProfileCall* x) {
874   output()-&gt;print(&quot;profile &quot;);
875   print_value(x-&gt;recv());
876   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;method()-&gt;name()-&gt;as_utf8());
877   if (x-&gt;known_holder() != NULL) {
878     output()-&gt;print(&quot;, &quot;);
879     print_klass(x-&gt;known_holder());
880     output()-&gt;print(&quot; &quot;);
881   }
882   for (int i = 0; i &lt; x-&gt;nb_profiled_args(); i++) {
883     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
884     print_value(x-&gt;profiled_arg_at(i));
885     if (x-&gt;arg_needs_null_check(i)) {
886       output()-&gt;print(&quot; [NC]&quot;);
887     }
888   }
889   output()-&gt;put(&#39;)&#39;);
890 }
891 
892 void InstructionPrinter::do_ProfileReturnType(ProfileReturnType* x) {
893   output()-&gt;print(&quot;profile ret type &quot;);
894   print_value(x-&gt;ret());
895   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;method()-&gt;name()-&gt;as_utf8());
896   output()-&gt;put(&#39;)&#39;);
897 }
898 void InstructionPrinter::do_ProfileInvoke(ProfileInvoke* x) {
899   output()-&gt;print(&quot;profile_invoke &quot;);
900   output()-&gt;print(&quot; %s.%s&quot;, x-&gt;inlinee()-&gt;holder()-&gt;name()-&gt;as_utf8(), x-&gt;inlinee()-&gt;name()-&gt;as_utf8());
901   output()-&gt;put(&#39;)&#39;);
902 
903 }
904 
905 void InstructionPrinter::do_RuntimeCall(RuntimeCall* x) {
906   output()-&gt;print(&quot;call_rt %s(&quot;, x-&gt;entry_name());
907   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
908     if (i &gt; 0) output()-&gt;print(&quot;, &quot;);
909     print_value(x-&gt;argument_at(i));
910   }
911   output()-&gt;put(&#39;)&#39;);
912 }
913 
914 void InstructionPrinter::do_MemBar(MemBar* x) {
915   LIR_Code code = x-&gt;code();
916   switch (code) {
917   case lir_membar_acquire   : output()-&gt;print(&quot;membar_acquire&quot;); break;
918   case lir_membar_release   : output()-&gt;print(&quot;membar_release&quot;); break;
919   case lir_membar           : output()-&gt;print(&quot;membar&quot;); break;
920   case lir_membar_loadload  : output()-&gt;print(&quot;membar_loadload&quot;); break;
921   case lir_membar_storestore: output()-&gt;print(&quot;membar_storestore&quot;); break;
922   case lir_membar_loadstore : output()-&gt;print(&quot;membar_loadstore&quot;); break;
923   case lir_membar_storeload : output()-&gt;print(&quot;membar_storeload&quot;); break;
924   default                   : ShouldNotReachHere(); break;
925   }
926 }
927 
928 #endif // PRODUCT
    </pre>
  </body>
</html>
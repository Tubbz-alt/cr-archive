<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_LIRAssembler.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_C1_C1_LIRASSEMBLER_HPP
 26 #define SHARE_C1_C1_LIRASSEMBLER_HPP
 27 
 28 #include &quot;c1/c1_CodeStubs.hpp&quot;
 29 #include &quot;ci/ciMethodData.hpp&quot;
 30 #include &quot;oops/methodData.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 class Compilation;
 34 class ScopeValue;
 35 class BarrierSet;
 36 
 37 class LIR_Assembler: public CompilationResourceObj {
 38  private:
 39   C1_MacroAssembler* _masm;
 40   CodeStubList*      _slow_case_stubs;
 41   BarrierSet*        _bs;
 42 
 43   Compilation*       _compilation;
 44   FrameMap*          _frame_map;
 45   BlockBegin*        _current_block;
 46 
 47   Instruction*       _pending_non_safepoint;
 48   int                _pending_non_safepoint_offset;
 49 
 50   Label              _unwind_handler_entry;
 51 
 52 #ifdef ASSERT
 53   BlockList          _branch_target_blocks;
 54   void check_no_unbound_labels();
 55 #endif
 56 
 57   FrameMap* frame_map() const { return _frame_map; }
 58 
 59   void set_current_block(BlockBegin* b) { _current_block = b; }
 60   BlockBegin* current_block() const { return _current_block; }
 61 
 62   // non-safepoint debug info management
 63   void flush_debug_info(int before_pc_offset) {
 64     if (_pending_non_safepoint != NULL) {
 65       if (_pending_non_safepoint_offset &lt; before_pc_offset)
 66         record_non_safepoint_debug_info();
 67       _pending_non_safepoint = NULL;
 68     }
 69   }
 70   void process_debug_info(LIR_Op* op);
 71   void record_non_safepoint_debug_info();
 72 
 73   // unified bailout support
 74   void bailout(const char* msg) const { compilation()-&gt;bailout(msg); }
 75   bool bailed_out() const                        { return compilation()-&gt;bailed_out(); }
 76 
 77   // code emission patterns and accessors
 78   void check_codespace();
 79   bool needs_icache(ciMethod* method) const;
 80 
 81   // returns offset of icache check
 82   int check_icache();
 83 
 84   void jobject2reg(jobject o, Register reg);
 85   void jobject2reg_with_patching(Register reg, CodeEmitInfo* info);
 86 
 87   void metadata2reg(Metadata* o, Register reg);
 88   void klass2reg_with_patching(Register reg, CodeEmitInfo* info);
 89 
 90   void emit_stubs(CodeStubList* stub_list);
 91 
 92   // addresses
 93   Address as_Address(LIR_Address* addr);
 94   Address as_Address_lo(LIR_Address* addr);
 95   Address as_Address_hi(LIR_Address* addr);
 96 
 97   // debug information
 98   void add_call_info(int pc_offset, CodeEmitInfo* cinfo);
 99   void add_debug_info_for_branch(CodeEmitInfo* info);
100   void add_debug_info_for_div0(int pc_offset, CodeEmitInfo* cinfo);
101   void add_debug_info_for_div0_here(CodeEmitInfo* info);
102   ImplicitNullCheckStub* add_debug_info_for_null_check(int pc_offset, CodeEmitInfo* cinfo);
103   ImplicitNullCheckStub* add_debug_info_for_null_check_here(CodeEmitInfo* info);
104 
105   void set_24bit_FPU();
106   void reset_FPU();
107   void fpop();
108   void fxch(int i);
109   void fld(int i);
110   void ffree(int i);
111 
112   void breakpoint();
113   void push(LIR_Opr opr);
114   void pop(LIR_Opr opr);
115 
116   // patching
117   void append_patching_stub(PatchingStub* stub);
118   void patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info);
119 
120   void comp_op(LIR_Condition condition, LIR_Opr src, LIR_Opr result, LIR_Op2* op);
121 
122   PatchingStub::PatchID patching_id(CodeEmitInfo* info);
123 
124  public:
125   LIR_Assembler(Compilation* c);
126   ~LIR_Assembler();
127   C1_MacroAssembler* masm() const                { return _masm; }
128   Compilation* compilation() const               { return _compilation; }
129   ciMethod* method() const                       { return compilation()-&gt;method(); }
130 
131   CodeOffsets* offsets() const                   { return _compilation-&gt;offsets(); }
132   int code_offset() const;
133   address pc() const;
134 
135   int  initial_frame_size_in_bytes() const;
136   int  bang_size_in_bytes() const;
137 
138   // test for constants which can be encoded directly in instructions
139   static bool is_small_constant(LIR_Opr opr);
140 
141   static LIR_Opr receiverOpr();
142   static LIR_Opr osrBufferPointer();
143 
144   // stubs
145   void emit_slow_case_stubs();
146   void emit_static_call_stub();
147   void append_code_stub(CodeStub* op);
148   void add_call_info_here(CodeEmitInfo* info)                              { add_call_info(code_offset(), info); }
149 
150   // code patterns
151   int  emit_exception_handler();
152   int  emit_unwind_handler();
153   void emit_exception_entries(ExceptionInfoList* info_list);
154   int  emit_deopt_handler();
155 
156   void emit_code(BlockList* hir);
157   void emit_block(BlockBegin* block);
158   void emit_lir_list(LIR_List* list);
159 
160   // any last minute peephole optimizations are performed here.  In
161   // particular sparc uses this for delay slot filling.
162   void peephole(LIR_List* list);
163 
164   void return_op(LIR_Opr result);
165 
166   // returns offset of poll instruction
167   int safepoint_poll(LIR_Opr result, CodeEmitInfo* info);
168 
169   void const2reg  (LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info);
170   void const2stack(LIR_Opr src, LIR_Opr dest);
171   void const2mem  (LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide);
172   void reg2stack  (LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack);
173   void reg2reg    (LIR_Opr src, LIR_Opr dest);
174   void reg2mem    (LIR_Opr src, LIR_Opr dest, BasicType type,
175                    LIR_PatchCode patch_code, CodeEmitInfo* info,
176                    bool pop_fpu_stack, bool wide, bool unaligned);
177   void stack2reg  (LIR_Opr src, LIR_Opr dest, BasicType type);
178   void stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type);
179   void mem2reg    (LIR_Opr src, LIR_Opr dest, BasicType type,
180                    LIR_PatchCode patch_code,
181                    CodeEmitInfo* info, bool wide, bool unaligned);
182 
183   void shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp);
184   void shift_op(LIR_Code code, LIR_Opr left, jint  count, LIR_Opr dest);
185 
186   void move_regs(Register from_reg, Register to_reg);
187   void swap_reg(Register a, Register b);
188 
189   void emit_op0(LIR_Op0* op);
190   void emit_op1(LIR_Op1* op);
191   void emit_op2(LIR_Op2* op);
192   void emit_op3(LIR_Op3* op);
193   void emit_opBranch(LIR_OpBranch* op);
194   void emit_opLabel(LIR_OpLabel* op);
195   void emit_arraycopy(LIR_OpArrayCopy* op);
196   void emit_updatecrc32(LIR_OpUpdateCRC32* op);
197   void emit_opConvert(LIR_OpConvert* op);
198   void emit_alloc_obj(LIR_OpAllocObj* op);
199   void emit_alloc_array(LIR_OpAllocArray* op);
200   void emit_opTypeCheck(LIR_OpTypeCheck* op);
201   void emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null);
202   void emit_compare_and_swap(LIR_OpCompareAndSwap* op);
203   void emit_lock(LIR_OpLock* op);
204   void emit_call(LIR_OpJavaCall* op);
205   void emit_rtcall(LIR_OpRTCall* op);
206   void emit_profile_call(LIR_OpProfileCall* op);
207   void emit_profile_type(LIR_OpProfileType* op);
208   void emit_delay(LIR_OpDelay* op);
209 
210   void arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack);
211   void arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info);
212   void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);
213 #ifdef ASSERT
214   void emit_assert(LIR_OpAssert* op);
215 #endif
216 
217   void logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest);
218 
219   void roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack);
220   void move_op(LIR_Opr src, LIR_Opr result, BasicType type,
221                LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool unaligned, bool wide);
222   void volatile_move_op(LIR_Opr src, LIR_Opr result, BasicType type, CodeEmitInfo* info);
223   void comp_mem_op(LIR_Opr src, LIR_Opr result, BasicType type, CodeEmitInfo* info);  // info set for null exceptions
224   void comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr result, LIR_Op2* op);
225   void cmove(LIR_Condition code, LIR_Opr left, LIR_Opr right, LIR_Opr result, BasicType type);
226 
227   void call(        LIR_OpJavaCall* op, relocInfo::relocType rtype);
228   void ic_call(     LIR_OpJavaCall* op);
229   void vtable_call( LIR_OpJavaCall* op);
230 
231   void osr_entry();
232 
233   void build_frame();
234 
235   void throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info);
236   void unwind_op(LIR_Opr exceptionOop);
237   void monitor_address(int monitor_ix, LIR_Opr dst);
238 
239   void align_backward_branch_target();
240   void align_call(LIR_Code code);
241 
242   void negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp = LIR_OprFact::illegalOpr);
243   void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL);
244 
245   void rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info);
246 
247   void membar();
248   void membar_acquire();
249   void membar_release();
250   void membar_loadload();
251   void membar_storestore();
252   void membar_loadstore();
253   void membar_storeload();
254   void on_spin_wait();
255   void get_thread(LIR_Opr result);
256 
257   void verify_oop_map(CodeEmitInfo* info);
258 
259   void atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp);
260 
261 #include CPU_HEADER(c1_LIRAssembler)
262 
263  public:
264 
265   static int call_stub_size() {
266     if (UseAOT) {
267       return _call_stub_size + _call_aot_stub_size;
268     } else {
269       return _call_stub_size;
270     }
271   }
272 
273   static int exception_handler_size() {
274     return _exception_handler_size;
275   }
276 
277   static int deopt_handler_size() {
278     return _deopt_handler_size;
279   }
280 };
281 
282 #endif // SHARE_C1_C1_LIRASSEMBLER_HPP
    </pre>
  </body>
</html>
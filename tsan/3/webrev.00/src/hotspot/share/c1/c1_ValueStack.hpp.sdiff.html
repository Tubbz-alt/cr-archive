<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_ValueStack.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_ValueStack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_ValueStack.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48   Values   _locals;                              // the locals
 49   Values   _stack;                               // the expression stack
 50   Values*  _locks;                               // the monitor stack (holding the locked values)
 51 
 52   Value check(ValueTag tag, Value t) {
 53     assert(tag == t-&gt;type()-&gt;tag() || tag == objectTag &amp;&amp; t-&gt;type()-&gt;tag() == addressTag, &quot;types must correspond&quot;);
 54     return t;
 55   }
 56 
 57   Value check(ValueTag tag, Value t, Value h) {
 58     assert(h == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
 59     return check(tag, t);
 60   }
 61 
 62   // helper routine
 63   static void apply(const Values&amp; list, ValueVisitor* f);
 64 
 65   // for simplified copying
 66   ValueStack(ValueStack* copy_from, Kind kind, int bci);
 67 


 68  public:
 69   // creation
 70   ValueStack(IRScope* scope, ValueStack* caller_state);
 71 
 72   ValueStack* copy()                             { return new ValueStack(this, _kind, _bci); }
 73   ValueStack* copy(Kind new_kind, int new_bci)   { return new ValueStack(this, new_kind, new_bci); }
 74   ValueStack* copy_for_parsing()                 { return new ValueStack(this, Parsing, -99); }
 75 
 76   void set_caller_state(ValueStack* s)           {
 77     assert(kind() == EmptyExceptionState ||
 78            (Compilation::current()-&gt;env()-&gt;should_retain_local_variables() &amp;&amp; kind() == ExceptionState),
 79            &quot;only EmptyExceptionStates can be modified&quot;);
 80     _caller_state = s;
 81   }
 82 
 83   bool is_same(ValueStack* s);                   // returns true if this &amp; s&#39;s types match (w/o checking locals)
 84 
 85   // accessors
 86   IRScope* scope() const                         { return _scope; }
 87   ValueStack* caller_state() const               { return _caller_state; }
</pre>
</td>
<td>
<hr />
<pre>
 48   Values   _locals;                              // the locals
 49   Values   _stack;                               // the expression stack
 50   Values*  _locks;                               // the monitor stack (holding the locked values)
 51 
 52   Value check(ValueTag tag, Value t) {
 53     assert(tag == t-&gt;type()-&gt;tag() || tag == objectTag &amp;&amp; t-&gt;type()-&gt;tag() == addressTag, &quot;types must correspond&quot;);
 54     return t;
 55   }
 56 
 57   Value check(ValueTag tag, Value t, Value h) {
 58     assert(h == NULL, &quot;hi-word of doubleword value must be NULL&quot;);
 59     return check(tag, t);
 60   }
 61 
 62   // helper routine
 63   static void apply(const Values&amp; list, ValueVisitor* f);
 64 
 65   // for simplified copying
 66   ValueStack(ValueStack* copy_from, Kind kind, int bci);
 67 
<span class="line-added"> 68   int locals_size_for_copy(Kind kind) const;</span>
<span class="line-added"> 69   int stack_size_for_copy(Kind kind) const;</span>
 70  public:
 71   // creation
 72   ValueStack(IRScope* scope, ValueStack* caller_state);
 73 
 74   ValueStack* copy()                             { return new ValueStack(this, _kind, _bci); }
 75   ValueStack* copy(Kind new_kind, int new_bci)   { return new ValueStack(this, new_kind, new_bci); }
 76   ValueStack* copy_for_parsing()                 { return new ValueStack(this, Parsing, -99); }
 77 
 78   void set_caller_state(ValueStack* s)           {
 79     assert(kind() == EmptyExceptionState ||
 80            (Compilation::current()-&gt;env()-&gt;should_retain_local_variables() &amp;&amp; kind() == ExceptionState),
 81            &quot;only EmptyExceptionStates can be modified&quot;);
 82     _caller_state = s;
 83   }
 84 
 85   bool is_same(ValueStack* s);                   // returns true if this &amp; s&#39;s types match (w/o checking locals)
 86 
 87   // accessors
 88   IRScope* scope() const                         { return _scope; }
 89   ValueStack* caller_state() const               { return _caller_state; }
</pre>
</td>
</tr>
</table>
<center><a href="c1_ValueStack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Optimizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LinearScan.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_RangeCheckElimination.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Optimizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 349       BlockBegin* sux = end-&gt;default_sux();
 350       if (sux-&gt;number_of_preds() == 1 &amp;&amp; !sux-&gt;is_entry_block() &amp;&amp; !end-&gt;is_safepoint()) {
 351         // merge the two blocks
 352 
 353 #ifdef ASSERT
 354         // verify that state at the end of block and at the beginning of sux are equal
 355         // no phi functions must be present at beginning of sux
 356         ValueStack* sux_state = sux-&gt;state();
 357         ValueStack* end_state = end-&gt;state();
 358 
 359         assert(end_state-&gt;scope() == sux_state-&gt;scope(), &quot;scopes must match&quot;);
 360         assert(end_state-&gt;stack_size() == sux_state-&gt;stack_size(), &quot;stack not equal&quot;);
 361         assert(end_state-&gt;locals_size() == sux_state-&gt;locals_size(), &quot;locals not equal&quot;);
 362 
 363         int index;
 364         Value sux_value;
 365         for_each_stack_value(sux_state, index, sux_value) {
 366           assert(sux_value == end_state-&gt;stack_at(index), &quot;stack not equal&quot;);
 367         }
 368         for_each_local_value(sux_state, index, sux_value) {


 369           assert(sux_value == end_state-&gt;local_at(index), &quot;locals not equal&quot;);
 370         }
 371         assert(sux_state-&gt;caller_state() == end_state-&gt;caller_state(), &quot;caller not equal&quot;);
 372 #endif
 373 
 374         // find instruction before end &amp; append first instruction of sux block
 375         Instruction* prev = end-&gt;prev();
 376         Instruction* next = sux-&gt;next();
 377         assert(prev-&gt;as_BlockEnd() == NULL, &quot;must not be a BlockEnd&quot;);
 378         prev-&gt;set_next(next);
 379         prev-&gt;fixup_block_pointers();
 380         sux-&gt;disconnect_from_graph();
 381         block-&gt;set_end(sux-&gt;end());
 382         // add exception handlers of deleted block, if any
 383         for (int k = 0; k &lt; sux-&gt;number_of_exception_handlers(); k++) {
 384           BlockBegin* xhandler = sux-&gt;exception_handler_at(k);
 385           block-&gt;add_exception_handler(xhandler);
 386 
 387           // also substitute predecessor of exception handler
 388           assert(xhandler-&gt;is_predecessor(sux), &quot;missing predecessor&quot;);
</pre>
<hr />
<pre>
 851     }
 852   }
 853 }
 854 
 855 
 856 void NullCheckEliminator::iterate(BlockBegin* block) {
 857   work_list()-&gt;push(block);
 858   iterate_all();
 859 }
 860 
 861 void NullCheckEliminator::handle_AccessField(AccessField* x) {
 862   if (x-&gt;is_static()) {
 863     if (x-&gt;as_LoadField() != NULL) {
 864       // If the field is a non-null static final object field (as is
 865       // often the case for sun.misc.Unsafe), put this LoadField into
 866       // the non-null map
 867       ciField* field = x-&gt;field();
 868       if (field-&gt;is_constant()) {
 869         ciConstant field_val = field-&gt;constant_value();
 870         BasicType field_type = field_val.basic_type();
<span class="line-modified"> 871         if (field_type == T_OBJECT || field_type == T_ARRAY) {</span>
 872           ciObject* obj_val = field_val.as_object();
 873           if (!obj_val-&gt;is_null_object()) {
 874             if (PrintNullCheckElimination) {
 875               tty-&gt;print_cr(&quot;AccessField %d proven non-null by static final non-null oop check&quot;,
 876                             x-&gt;id());
 877             }
 878             set_put(x);
 879           }
 880         }
 881       }
 882     }
 883     // Be conservative
 884     clear_last_explicit_null_check();
 885     return;
 886   }
 887 
 888   Value obj = x-&gt;obj();
 889   if (set_contains(obj)) {
 890     // Value is non-null =&gt; update AccessField
 891     if (last_explicit_null_check_obj() == obj &amp;&amp; !x-&gt;needs_patching()) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 349       BlockBegin* sux = end-&gt;default_sux();
 350       if (sux-&gt;number_of_preds() == 1 &amp;&amp; !sux-&gt;is_entry_block() &amp;&amp; !end-&gt;is_safepoint()) {
 351         // merge the two blocks
 352 
 353 #ifdef ASSERT
 354         // verify that state at the end of block and at the beginning of sux are equal
 355         // no phi functions must be present at beginning of sux
 356         ValueStack* sux_state = sux-&gt;state();
 357         ValueStack* end_state = end-&gt;state();
 358 
 359         assert(end_state-&gt;scope() == sux_state-&gt;scope(), &quot;scopes must match&quot;);
 360         assert(end_state-&gt;stack_size() == sux_state-&gt;stack_size(), &quot;stack not equal&quot;);
 361         assert(end_state-&gt;locals_size() == sux_state-&gt;locals_size(), &quot;locals not equal&quot;);
 362 
 363         int index;
 364         Value sux_value;
 365         for_each_stack_value(sux_state, index, sux_value) {
 366           assert(sux_value == end_state-&gt;stack_at(index), &quot;stack not equal&quot;);
 367         }
 368         for_each_local_value(sux_state, index, sux_value) {
<span class="line-added"> 369           Phi* sux_phi = sux_value-&gt;as_Phi();</span>
<span class="line-added"> 370           if (sux_phi != NULL &amp;&amp; sux_phi-&gt;is_illegal()) continue;</span>
 371           assert(sux_value == end_state-&gt;local_at(index), &quot;locals not equal&quot;);
 372         }
 373         assert(sux_state-&gt;caller_state() == end_state-&gt;caller_state(), &quot;caller not equal&quot;);
 374 #endif
 375 
 376         // find instruction before end &amp; append first instruction of sux block
 377         Instruction* prev = end-&gt;prev();
 378         Instruction* next = sux-&gt;next();
 379         assert(prev-&gt;as_BlockEnd() == NULL, &quot;must not be a BlockEnd&quot;);
 380         prev-&gt;set_next(next);
 381         prev-&gt;fixup_block_pointers();
 382         sux-&gt;disconnect_from_graph();
 383         block-&gt;set_end(sux-&gt;end());
 384         // add exception handlers of deleted block, if any
 385         for (int k = 0; k &lt; sux-&gt;number_of_exception_handlers(); k++) {
 386           BlockBegin* xhandler = sux-&gt;exception_handler_at(k);
 387           block-&gt;add_exception_handler(xhandler);
 388 
 389           // also substitute predecessor of exception handler
 390           assert(xhandler-&gt;is_predecessor(sux), &quot;missing predecessor&quot;);
</pre>
<hr />
<pre>
 853     }
 854   }
 855 }
 856 
 857 
 858 void NullCheckEliminator::iterate(BlockBegin* block) {
 859   work_list()-&gt;push(block);
 860   iterate_all();
 861 }
 862 
 863 void NullCheckEliminator::handle_AccessField(AccessField* x) {
 864   if (x-&gt;is_static()) {
 865     if (x-&gt;as_LoadField() != NULL) {
 866       // If the field is a non-null static final object field (as is
 867       // often the case for sun.misc.Unsafe), put this LoadField into
 868       // the non-null map
 869       ciField* field = x-&gt;field();
 870       if (field-&gt;is_constant()) {
 871         ciConstant field_val = field-&gt;constant_value();
 872         BasicType field_type = field_val.basic_type();
<span class="line-modified"> 873         if (is_reference_type(field_type)) {</span>
 874           ciObject* obj_val = field_val.as_object();
 875           if (!obj_val-&gt;is_null_object()) {
 876             if (PrintNullCheckElimination) {
 877               tty-&gt;print_cr(&quot;AccessField %d proven non-null by static final non-null oop check&quot;,
 878                             x-&gt;id());
 879             }
 880             set_put(x);
 881           }
 882         }
 883       }
 884     }
 885     // Be conservative
 886     clear_last_explicit_null_check();
 887     return;
 888   }
 889 
 890   Value obj = x-&gt;obj();
 891   if (set_contains(obj)) {
 892     // Value is non-null =&gt; update AccessField
 893     if (last_explicit_null_check_obj() == obj &amp;&amp; !x-&gt;needs_patching()) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LinearScan.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_RangeCheckElimination.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
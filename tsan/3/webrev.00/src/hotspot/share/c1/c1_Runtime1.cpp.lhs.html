<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Runtime1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/codeBuffer.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Defs.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;classfile/systemDictionary.hpp&quot;
  34 #include &quot;classfile/vmSymbols.hpp&quot;
  35 #include &quot;code/codeBlob.hpp&quot;
  36 #include &quot;code/compiledIC.hpp&quot;
  37 #include &quot;code/pcDesc.hpp&quot;
  38 #include &quot;code/scopeDesc.hpp&quot;
  39 #include &quot;code/vtableStubs.hpp&quot;
<a name="2" id="anc2"></a>
  40 #include &quot;compiler/disassembler.hpp&quot;
  41 #include &quot;gc/shared/barrierSet.hpp&quot;
  42 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  43 #include &quot;gc/shared/collectedHeap.hpp&quot;
  44 #include &quot;interpreter/bytecode.hpp&quot;
  45 #include &quot;interpreter/interpreter.hpp&quot;
  46 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  47 #include &quot;logging/log.hpp&quot;
  48 #include &quot;memory/allocation.inline.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/objArrayOop.inline.hpp&quot;
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/biasedLocking.hpp&quot;
<a name="4" id="anc4"></a><span class="line-removed">  57 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  58 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  59 #include &quot;runtime/frame.inline.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/javaCalls.hpp&quot;
  63 #include &quot;runtime/sharedRuntime.hpp&quot;
  64 #include &quot;runtime/threadCritical.hpp&quot;
  65 #include &quot;runtime/vframe.inline.hpp&quot;
  66 #include &quot;runtime/vframeArray.hpp&quot;
  67 #include &quot;runtime/vm_version.hpp&quot;
  68 #include &quot;utilities/copy.hpp&quot;
  69 #include &quot;utilities/events.hpp&quot;
  70 
  71 
  72 // Implementation of StubAssembler
  73 
  74 StubAssembler::StubAssembler(CodeBuffer* code, const char * name, int stub_id) : C1_MacroAssembler(code) {
  75   _name = name;
  76   _must_gc_arguments = false;
  77   _frame_size = no_frame_size;
  78   _num_rt_args = 0;
  79   _stub_id = stub_id;
  80 }
  81 
  82 
  83 void StubAssembler::set_info(const char* name, bool must_gc_arguments) {
  84   _name = name;
  85   _must_gc_arguments = must_gc_arguments;
  86 }
  87 
  88 
  89 void StubAssembler::set_frame_size(int size) {
  90   if (_frame_size == no_frame_size) {
  91     _frame_size = size;
  92   }
  93   assert(_frame_size == size, &quot;can&#39;t change the frame size&quot;);
  94 }
  95 
  96 
  97 void StubAssembler::set_num_rt_args(int args) {
  98   if (_num_rt_args == 0) {
  99     _num_rt_args = args;
 100   }
 101   assert(_num_rt_args == args, &quot;can&#39;t change the number of args&quot;);
 102 }
 103 
 104 // Implementation of Runtime1
 105 
 106 CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];
 107 const char *Runtime1::_blob_names[] = {
 108   RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)
 109 };
 110 
 111 #ifndef PRODUCT
 112 // statistics
 113 int Runtime1::_generic_arraycopy_cnt = 0;
 114 int Runtime1::_generic_arraycopystub_cnt = 0;
 115 int Runtime1::_arraycopy_slowcase_cnt = 0;
 116 int Runtime1::_arraycopy_checkcast_cnt = 0;
 117 int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
 118 int Runtime1::_new_type_array_slowcase_cnt = 0;
 119 int Runtime1::_new_object_array_slowcase_cnt = 0;
 120 int Runtime1::_new_instance_slowcase_cnt = 0;
 121 int Runtime1::_new_multi_array_slowcase_cnt = 0;
 122 int Runtime1::_monitorenter_slowcase_cnt = 0;
 123 int Runtime1::_monitorexit_slowcase_cnt = 0;
 124 int Runtime1::_patch_code_slowcase_cnt = 0;
 125 int Runtime1::_throw_range_check_exception_count = 0;
 126 int Runtime1::_throw_index_exception_count = 0;
 127 int Runtime1::_throw_div0_exception_count = 0;
 128 int Runtime1::_throw_null_pointer_exception_count = 0;
 129 int Runtime1::_throw_class_cast_exception_count = 0;
 130 int Runtime1::_throw_incompatible_class_change_error_count = 0;
 131 int Runtime1::_throw_array_store_exception_count = 0;
 132 int Runtime1::_throw_count = 0;
 133 
 134 static int _byte_arraycopy_stub_cnt = 0;
 135 static int _short_arraycopy_stub_cnt = 0;
 136 static int _int_arraycopy_stub_cnt = 0;
 137 static int _long_arraycopy_stub_cnt = 0;
 138 static int _oop_arraycopy_stub_cnt = 0;
 139 
 140 address Runtime1::arraycopy_count_address(BasicType type) {
 141   switch (type) {
 142   case T_BOOLEAN:
 143   case T_BYTE:   return (address)&amp;_byte_arraycopy_stub_cnt;
 144   case T_CHAR:
 145   case T_SHORT:  return (address)&amp;_short_arraycopy_stub_cnt;
 146   case T_FLOAT:
 147   case T_INT:    return (address)&amp;_int_arraycopy_stub_cnt;
 148   case T_DOUBLE:
 149   case T_LONG:   return (address)&amp;_long_arraycopy_stub_cnt;
 150   case T_ARRAY:
 151   case T_OBJECT: return (address)&amp;_oop_arraycopy_stub_cnt;
 152   default:
 153     ShouldNotReachHere();
 154     return NULL;
 155   }
 156 }
 157 
 158 
 159 #endif
 160 
 161 // Simple helper to see if the caller of a runtime stub which
 162 // entered the VM has been deoptimized
 163 
 164 static bool caller_is_deopted() {
 165   JavaThread* thread = JavaThread::current();
 166   RegisterMap reg_map(thread, false);
 167   frame runtime_frame = thread-&gt;last_frame();
 168   frame caller_frame = runtime_frame.sender(&amp;reg_map);
 169   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
 170   return caller_frame.is_deoptimized_frame();
 171 }
 172 
 173 // Stress deoptimization
 174 static void deopt_caller() {
 175   if ( !caller_is_deopted()) {
 176     JavaThread* thread = JavaThread::current();
 177     RegisterMap reg_map(thread, false);
 178     frame runtime_frame = thread-&gt;last_frame();
 179     frame caller_frame = runtime_frame.sender(&amp;reg_map);
 180     Deoptimization::deoptimize_frame(thread, caller_frame.id());
 181     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
 182   }
 183 }
 184 
 185 class StubIDStubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {
 186  private:
 187   Runtime1::StubID _id;
 188  public:
 189   StubIDStubAssemblerCodeGenClosure(Runtime1::StubID id) : _id(id) {}
 190   virtual OopMapSet* generate_code(StubAssembler* sasm) {
 191     return Runtime1::generate_code_for(_id, sasm);
 192   }
 193 };
 194 
 195 CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, int stub_id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {
 196   ResourceMark rm;
 197   // create code buffer for code storage
 198   CodeBuffer code(buffer_blob);
 199 
 200   OopMapSet* oop_maps;
 201   int frame_size;
 202   bool must_gc_arguments;
 203 
 204   Compilation::setup_code_buffer(&amp;code, 0);
 205 
 206   // create assembler for code generation
 207   StubAssembler* sasm = new StubAssembler(&amp;code, name, stub_id);
 208   // generate code for runtime stub
 209   oop_maps = cl-&gt;generate_code(sasm);
 210   assert(oop_maps == NULL || sasm-&gt;frame_size() != no_frame_size,
 211          &quot;if stub has an oop map it must have a valid frame size&quot;);
 212   assert(!expect_oop_map || oop_maps != NULL, &quot;must have an oopmap&quot;);
 213 
 214   // align so printing shows nop&#39;s instead of random code at the end (SimpleStubs are aligned)
 215   sasm-&gt;align(BytesPerWord);
 216   // make sure all code is in code buffer
 217   sasm-&gt;flush();
 218 
 219   frame_size = sasm-&gt;frame_size();
 220   must_gc_arguments = sasm-&gt;must_gc_arguments();
 221   // create blob - distinguish a few special cases
 222   CodeBlob* blob = RuntimeStub::new_runtime_stub(name,
 223                                                  &amp;code,
 224                                                  CodeOffsets::frame_never_safe,
 225                                                  frame_size,
 226                                                  oop_maps,
 227                                                  must_gc_arguments);
 228   assert(blob != NULL, &quot;blob must exist&quot;);
 229   return blob;
 230 }
 231 
 232 void Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {
 233   assert(0 &lt;= id &amp;&amp; id &lt; number_of_ids, &quot;illegal stub id&quot;);
 234   bool expect_oop_map = true;
 235 #ifdef ASSERT
 236   // Make sure that stubs that need oopmaps have them
 237   switch (id) {
 238     // These stubs don&#39;t need to have an oopmap
 239   case dtrace_object_alloc_id:
 240   case slow_subtype_check_id:
 241   case fpu2long_stub_id:
 242   case unwind_exception_id:
 243   case counter_overflow_id:
 244 #if defined(SPARC) || defined(PPC32)
 245   case handle_exception_nofpu_id:  // Unused on sparc
 246 #endif
 247     expect_oop_map = false;
 248     break;
 249   default:
 250     break;
 251   }
 252 #endif
 253   StubIDStubAssemblerCodeGenClosure cl(id);
 254   CodeBlob* blob = generate_blob(buffer_blob, id, name_for(id), expect_oop_map, &amp;cl);
 255   // install blob
 256   _blobs[id] = blob;
 257 }
 258 
 259 void Runtime1::initialize(BufferBlob* blob) {
 260   // platform-dependent initialization
 261   initialize_pd();
 262   // generate stubs
 263   for (int id = 0; id &lt; number_of_ids; id++) generate_blob_for(blob, (StubID)id);
 264   // printing
 265 #ifndef PRODUCT
 266   if (PrintSimpleStubs) {
 267     ResourceMark rm;
 268     for (int id = 0; id &lt; number_of_ids; id++) {
 269       _blobs[id]-&gt;print();
 270       if (_blobs[id]-&gt;oop_maps() != NULL) {
 271         _blobs[id]-&gt;oop_maps()-&gt;print();
 272       }
 273     }
 274   }
 275 #endif
 276   BarrierSetC1* bs = BarrierSet::barrier_set()-&gt;barrier_set_c1();
 277   bs-&gt;generate_c1_runtime_stubs(blob);
 278 }
 279 
 280 CodeBlob* Runtime1::blob_for(StubID id) {
 281   assert(0 &lt;= id &amp;&amp; id &lt; number_of_ids, &quot;illegal stub id&quot;);
 282   return _blobs[id];
 283 }
 284 
 285 
 286 const char* Runtime1::name_for(StubID id) {
 287   assert(0 &lt;= id &amp;&amp; id &lt; number_of_ids, &quot;illegal stub id&quot;);
 288   return _blob_names[id];
 289 }
 290 
 291 const char* Runtime1::name_for_address(address entry) {
 292   for (int id = 0; id &lt; number_of_ids; id++) {
 293     if (entry == entry_for((StubID)id)) return name_for((StubID)id);
 294   }
 295 
<a name="5" id="anc5"></a>





 296 #define FUNCTION_CASE(a, f) \
 297   if ((intptr_t)a == CAST_FROM_FN_PTR(intptr_t, f))  return #f
 298 
 299   FUNCTION_CASE(entry, os::javaTimeMillis);
 300   FUNCTION_CASE(entry, os::javaTimeNanos);
 301   FUNCTION_CASE(entry, SharedRuntime::OSR_migration_end);
 302   FUNCTION_CASE(entry, SharedRuntime::d2f);
 303   FUNCTION_CASE(entry, SharedRuntime::d2i);
 304   FUNCTION_CASE(entry, SharedRuntime::d2l);
 305   FUNCTION_CASE(entry, SharedRuntime::dcos);
 306   FUNCTION_CASE(entry, SharedRuntime::dexp);
 307   FUNCTION_CASE(entry, SharedRuntime::dlog);
 308   FUNCTION_CASE(entry, SharedRuntime::dlog10);
 309   FUNCTION_CASE(entry, SharedRuntime::dpow);
 310   FUNCTION_CASE(entry, SharedRuntime::drem);
 311   FUNCTION_CASE(entry, SharedRuntime::dsin);
 312   FUNCTION_CASE(entry, SharedRuntime::dtan);
 313   FUNCTION_CASE(entry, SharedRuntime::f2i);
 314   FUNCTION_CASE(entry, SharedRuntime::f2l);
 315   FUNCTION_CASE(entry, SharedRuntime::frem);
 316   FUNCTION_CASE(entry, SharedRuntime::l2d);
 317   FUNCTION_CASE(entry, SharedRuntime::l2f);
 318   FUNCTION_CASE(entry, SharedRuntime::ldiv);
 319   FUNCTION_CASE(entry, SharedRuntime::lmul);
 320   FUNCTION_CASE(entry, SharedRuntime::lrem);
 321   FUNCTION_CASE(entry, SharedRuntime::lrem);
 322   FUNCTION_CASE(entry, SharedRuntime::dtrace_method_entry);
 323   FUNCTION_CASE(entry, SharedRuntime::dtrace_method_exit);
 324   FUNCTION_CASE(entry, is_instance_of);
 325   FUNCTION_CASE(entry, trace_block_entry);
 326 #ifdef JFR_HAVE_INTRINSICS
 327   FUNCTION_CASE(entry, JFR_TIME_FUNCTION);
 328 #endif
 329   FUNCTION_CASE(entry, StubRoutines::updateBytesCRC32());
 330   FUNCTION_CASE(entry, StubRoutines::updateBytesCRC32C());
 331   FUNCTION_CASE(entry, StubRoutines::vectorizedMismatch());
 332   FUNCTION_CASE(entry, StubRoutines::dexp());
 333   FUNCTION_CASE(entry, StubRoutines::dlog());
 334   FUNCTION_CASE(entry, StubRoutines::dlog10());
 335   FUNCTION_CASE(entry, StubRoutines::dpow());
 336   FUNCTION_CASE(entry, StubRoutines::dsin());
 337   FUNCTION_CASE(entry, StubRoutines::dcos());
 338   FUNCTION_CASE(entry, StubRoutines::dtan());
 339 
 340 #undef FUNCTION_CASE
 341 
 342   // Soft float adds more runtime names.
 343   return pd_name_for_address(entry);
 344 }
 345 
 346 
 347 JRT_ENTRY(void, Runtime1::new_instance(JavaThread* thread, Klass* klass))
 348   NOT_PRODUCT(_new_instance_slowcase_cnt++;)
 349 
 350   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 351   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 352   InstanceKlass* h = InstanceKlass::cast(klass);
 353   h-&gt;check_valid_for_instantiation(true, CHECK);
 354   // make sure klass is initialized
 355   h-&gt;initialize(CHECK);
 356   // allocate instance and return via TLS
 357   oop obj = h-&gt;allocate_instance(CHECK);
 358   thread-&gt;set_vm_result(obj);
 359 JRT_END
 360 
 361 
 362 JRT_ENTRY(void, Runtime1::new_type_array(JavaThread* thread, Klass* klass, jint length))
 363   NOT_PRODUCT(_new_type_array_slowcase_cnt++;)
 364   // Note: no handle for klass needed since they are not used
 365   //       anymore after new_typeArray() and no GC can happen before.
 366   //       (This may have to change if this code changes!)
 367   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 368   BasicType elt_type = TypeArrayKlass::cast(klass)-&gt;element_type();
 369   oop obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 370   thread-&gt;set_vm_result(obj);
 371   // This is pretty rare but this runtime patch is stressful to deoptimization
 372   // if we deoptimize here so force a deopt to stress the path.
 373   if (DeoptimizeALot) {
 374     deopt_caller();
 375   }
 376 
 377 JRT_END
 378 
 379 
 380 JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))
 381   NOT_PRODUCT(_new_object_array_slowcase_cnt++;)
 382 
 383   // Note: no handle for klass needed since they are not used
 384   //       anymore after new_objArray() and no GC can happen before.
 385   //       (This may have to change if this code changes!)
 386   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 387   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 388   Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 389   objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 390   thread-&gt;set_vm_result(obj);
 391   // This is pretty rare but this runtime patch is stressful to deoptimization
 392   // if we deoptimize here so force a deopt to stress the path.
 393   if (DeoptimizeALot) {
 394     deopt_caller();
 395   }
 396 JRT_END
 397 
 398 
 399 JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 400   NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)
 401 
 402   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 403   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 404   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 405   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 406   thread-&gt;set_vm_result(obj);
 407 JRT_END
 408 
 409 
 410 JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))
 411   tty-&gt;print_cr(&quot;Runtime1::entry_for(%d) returned unimplemented entry point&quot;, id);
 412 JRT_END
 413 
 414 
 415 JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
 416   ResourceMark rm(thread);
 417   const char* klass_name = obj-&gt;klass()-&gt;external_name();
 418   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
 419 JRT_END
 420 
 421 
 422 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 423 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
 424 // method) method oop is passed as an argument. In order to do that it is embedded in the code as
 425 // a constant.
 426 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
 427   nmethod* osr_nm = NULL;
 428   methodHandle method(THREAD, m);
 429 
 430   RegisterMap map(THREAD, false);
 431   frame fr =  THREAD-&gt;last_frame().sender(&amp;map);
 432   nmethod* nm = (nmethod*) fr.cb();
 433   assert(nm!= NULL &amp;&amp; nm-&gt;is_nmethod(), &quot;Sanity check&quot;);
 434   methodHandle enclosing_method(THREAD, nm-&gt;method());
 435 
 436   CompLevel level = (CompLevel)nm-&gt;comp_level();
 437   int bci = InvocationEntryBci;
 438   if (branch_bci != InvocationEntryBci) {
 439     // Compute destination bci
 440     address pc = method()-&gt;code_base() + branch_bci;
 441     Bytecodes::Code branch = Bytecodes::code_at(method(), pc);
 442     int offset = 0;
 443     switch (branch) {
 444       case Bytecodes::_if_icmplt: case Bytecodes::_iflt:
 445       case Bytecodes::_if_icmpgt: case Bytecodes::_ifgt:
 446       case Bytecodes::_if_icmple: case Bytecodes::_ifle:
 447       case Bytecodes::_if_icmpge: case Bytecodes::_ifge:
 448       case Bytecodes::_if_icmpeq: case Bytecodes::_if_acmpeq: case Bytecodes::_ifeq:
 449       case Bytecodes::_if_icmpne: case Bytecodes::_if_acmpne: case Bytecodes::_ifne:
 450       case Bytecodes::_ifnull: case Bytecodes::_ifnonnull: case Bytecodes::_goto:
 451         offset = (int16_t)Bytes::get_Java_u2(pc + 1);
 452         break;
 453       case Bytecodes::_goto_w:
 454         offset = Bytes::get_Java_u4(pc + 1);
 455         break;
 456       default: ;
 457     }
 458     bci = branch_bci + offset;
 459   }
 460   assert(!HAS_PENDING_EXCEPTION, &quot;Should not have any exceptions pending&quot;);
 461   osr_nm = CompilationPolicy::policy()-&gt;event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);
 462   assert(!HAS_PENDING_EXCEPTION, &quot;Event handler should not throw any exceptions&quot;);
 463   return osr_nm;
 464 }
 465 
 466 JRT_BLOCK_ENTRY(address, Runtime1::counter_overflow(JavaThread* thread, int bci, Method* method))
 467   nmethod* osr_nm;
 468   JRT_BLOCK
 469     osr_nm = counter_overflow_helper(thread, bci, method);
 470     if (osr_nm != NULL) {
 471       RegisterMap map(thread, false);
 472       frame fr =  thread-&gt;last_frame().sender(&amp;map);
 473       Deoptimization::deoptimize_frame(thread, fr.id());
 474     }
 475   JRT_BLOCK_END
 476   return NULL;
 477 JRT_END
 478 
 479 extern void vm_exit(int code);
 480 
 481 // Enter this method from compiled code handler below. This is where we transition
 482 // to VM mode. This is done as a helper routine so that the method called directly
 483 // from compiled code does not have to transition to VM. This allows the entry
 484 // method to see if the nmethod that we have just looked up a handler for has
 485 // been deoptimized while we were in the vm. This simplifies the assembly code
 486 // cpu directories.
 487 //
 488 // We are entering here from exception stub (via the entry method below)
 489 // If there is a compiled exception handler in this method, we will continue there;
 490 // otherwise we will unwind the stack and continue at the caller of top frame method
 491 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 492 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 493 // check to see if the handler we are going to return is now in a nmethod that has
 494 // been deoptimized. If that is the case we return the deopt blob
 495 // unpack_with_exception entry instead. This makes life for the exception blob easier
 496 // because making that same check and diverting is painful from assembly language.
 497 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, nmethod*&amp; nm))
 498   // Reset method handle flag.
 499   thread-&gt;set_is_method_handle_return(false);
 500 
 501   Handle exception(thread, ex);
 502   nm = CodeCache::find_nmethod(pc);
 503   assert(nm != NULL, &quot;this is not an nmethod&quot;);
 504   // Adjust the pc as needed/
 505   if (nm-&gt;is_deopt_pc(pc)) {
 506     RegisterMap map(thread, false);
 507     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 508     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
 509     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
 510     pc = exception_frame.pc();
 511   }
 512 #ifdef ASSERT
 513   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
 514   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 515   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 516     if (ExitVMOnVerifyError) vm_exit(-1);
 517     ShouldNotReachHere();
 518   }
 519 #endif
 520 
 521   // Check the stack guard pages and reenable them if necessary and there is
 522   // enough space on the stack to do so.  Use fast exceptions only if the guard
 523   // pages are enabled.
 524   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 525   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 526 
 527   if (JvmtiExport::can_post_on_exceptions()) {
 528     // To ensure correct notification of exception catches and throws
 529     // we have to deoptimize here.  If we attempted to notify the
 530     // catches and throws during this exception lookup it&#39;s possible
 531     // we could deoptimize on the way out of the VM and end back in
 532     // the interpreter at the throw site.  This would result in double
 533     // notifications since the interpreter would also notify about
 534     // these same catches and throws as it unwound the frame.
 535 
 536     RegisterMap reg_map(thread);
 537     frame stub_frame = thread-&gt;last_frame();
 538     frame caller_frame = stub_frame.sender(&amp;reg_map);
 539 
 540     // We don&#39;t really want to deoptimize the nmethod itself since we
 541     // can actually continue in the exception handler ourselves but I
 542     // don&#39;t see an easy way to have the desired effect.
 543     Deoptimization::deoptimize_frame(thread, caller_frame.id());
 544     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
 545 
 546     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 547   }
 548 
 549   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 550   if (guard_pages_enabled) {
 551     address fast_continuation = nm-&gt;handler_for_exception_and_pc(exception, pc);
 552     if (fast_continuation != NULL) {
 553       // Set flag if return address is a method handle call site.
 554       thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(pc));
 555       return fast_continuation;
 556     }
 557   }
 558 
 559   // If the stack guard pages are enabled, check whether there is a handler in
 560   // the current method.  Otherwise (guard pages disabled), force an unwind and
 561   // skip the exception cache update (i.e., just leave continuation==NULL).
 562   address continuation = NULL;
 563   if (guard_pages_enabled) {
 564 
 565     // New exception handling mechanism can support inlined methods
 566     // with exception handlers since the mappings are from PC to PC
 567 
 568     // debugging support
 569     // tracing
 570     if (log_is_enabled(Info, exceptions)) {
 571       ResourceMark rm;
 572       stringStream tempst;
 573       assert(nm-&gt;method() != NULL, &quot;Unexpected NULL method()&quot;);
 574       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
 575                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
 576                    nm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<a name="6" id="anc6"></a><span class="line-modified"> 577       Exceptions::log_exception(exception, tempst);</span>
 578     }
 579     // for AbortVMOnException flag
 580     Exceptions::debug_check_abort(exception);
 581 
 582     // Clear out the exception oop and pc since looking up an
 583     // exception handler can cause class loading, which might throw an
 584     // exception and those fields are expected to be clear during
 585     // normal bytecode execution.
 586     thread-&gt;clear_exception_oop_and_pc();
 587 
 588     bool recursive_exception = false;
 589     continuation = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, false, false, recursive_exception);
 590     // If an exception was thrown during exception dispatch, the exception oop may have changed
 591     thread-&gt;set_exception_oop(exception());
 592     thread-&gt;set_exception_pc(pc);
 593 
 594     // the exception cache is used only by non-implicit exceptions
 595     // Update the exception cache only when there didn&#39;t happen
 596     // another exception during the computation of the compiled
 597     // exception handler. Checking for exception oop equality is not
 598     // sufficient because some exceptions are pre-allocated and reused.
 599     if (continuation != NULL &amp;&amp; !recursive_exception) {
 600       nm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 601     }
 602   }
 603 
 604   thread-&gt;set_vm_result(exception());
 605   // Set flag if return address is a method handle call site.
 606   thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(pc));
 607 
 608   if (log_is_enabled(Info, exceptions)) {
 609     ResourceMark rm;
 610     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
 611                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
 612                          p2i(thread), p2i(continuation), p2i(pc));
 613   }
 614 
 615   return continuation;
 616 JRT_END
 617 
 618 // Enter this method from compiled code only if there is a Java exception handler
 619 // in the method handling the exception.
 620 // We are entering here from exception stub. We don&#39;t do a normal VM transition here.
 621 // We do it in a helper. This is so we can check to see if the nmethod we have just
 622 // searched for an exception handler has been deoptimized in the meantime.
 623 address Runtime1::exception_handler_for_pc(JavaThread* thread) {
 624   oop exception = thread-&gt;exception_oop();
 625   address pc = thread-&gt;exception_pc();
 626   // Still in Java mode
 627   DEBUG_ONLY(ResetNoHandleMark rnhm);
 628   nmethod* nm = NULL;
 629   address continuation = NULL;
 630   {
 631     // Enter VM mode by calling the helper
 632     ResetNoHandleMark rnhm;
 633     continuation = exception_handler_for_pc_helper(thread, exception, pc, nm);
 634   }
 635   // Back in JAVA, use no oops DON&#39;T safepoint
 636 
 637   // Now check to see if the nmethod we were called from is now deoptimized.
 638   // If so we must return to the deopt blob and deoptimize the nmethod
 639   if (nm != NULL &amp;&amp; caller_is_deopted()) {
 640     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 641   }
 642 
 643   assert(continuation != NULL, &quot;no handler found&quot;);
 644   return continuation;
 645 }
 646 
 647 
 648 JRT_ENTRY(void, Runtime1::throw_range_check_exception(JavaThread* thread, int index, arrayOopDesc* a))
 649   NOT_PRODUCT(_throw_range_check_exception_count++;)
 650   const int len = 35;
 651   assert(len &lt; strlen(&quot;Index %d out of bounds for length %d&quot;), &quot;Must allocate more space for message.&quot;);
 652   char message[2 * jintAsStringSize + len];
 653   sprintf(message, &quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
 654   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), message);
 655 JRT_END
 656 
 657 
 658 JRT_ENTRY(void, Runtime1::throw_index_exception(JavaThread* thread, int index))
 659   NOT_PRODUCT(_throw_index_exception_count++;)
 660   char message[16];
 661   sprintf(message, &quot;%d&quot;, index);
 662   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IndexOutOfBoundsException(), message);
 663 JRT_END
 664 
 665 
 666 JRT_ENTRY(void, Runtime1::throw_div0_exception(JavaThread* thread))
 667   NOT_PRODUCT(_throw_div0_exception_count++;)
 668   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), &quot;/ by zero&quot;);
 669 JRT_END
 670 
 671 
 672 JRT_ENTRY(void, Runtime1::throw_null_pointer_exception(JavaThread* thread))
 673   NOT_PRODUCT(_throw_null_pointer_exception_count++;)
 674   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 675 JRT_END
 676 
 677 
 678 JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))
 679   NOT_PRODUCT(_throw_class_cast_exception_count++;)
 680   ResourceMark rm(thread);
 681   char* message = SharedRuntime::generate_class_cast_message(
 682     thread, object-&gt;klass());
 683   SharedRuntime::throw_and_post_jvmti_exception(
 684     thread, vmSymbols::java_lang_ClassCastException(), message);
 685 JRT_END
 686 
 687 
 688 JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))
 689   NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)
 690   ResourceMark rm(thread);
 691   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());
 692 JRT_END
 693 
 694 
 695 JRT_ENTRY_NO_ASYNC(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
 696   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
 697   if (PrintBiasedLockingStatistics) {
 698     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 699   }
 700   Handle h_obj(thread, obj);
<a name="7" id="anc7"></a><span class="line-modified"> 701   if (UseBiasedLocking) {</span>
<span class="line-modified"> 702     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="line-removed"> 703     ObjectSynchronizer::fast_enter(h_obj, lock-&gt;lock(), true, CHECK);</span>
<span class="line-removed"> 704   } else {</span>
<span class="line-removed"> 705     if (UseFastLocking) {</span>
<span class="line-removed"> 706       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed"> 707       assert(obj == lock-&gt;obj(), &quot;must match&quot;);</span>
<span class="line-removed"> 708       ObjectSynchronizer::slow_enter(h_obj, lock-&gt;lock(), THREAD);</span>
<span class="line-removed"> 709     } else {</span>
<span class="line-removed"> 710       lock-&gt;set_obj(obj);</span>
<span class="line-removed"> 711       ObjectSynchronizer::fast_enter(h_obj, lock-&gt;lock(), false, THREAD);</span>
<span class="line-removed"> 712     }</span>
 713   }
<a name="8" id="anc8"></a>

 714 JRT_END
 715 
 716 
 717 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
 718   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
 719   assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
 720   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 721   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
 722   EXCEPTION_MARK;
 723 
 724   oop obj = lock-&gt;obj();
 725   assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 726   if (UseFastLocking) {</span>
<span class="line-removed"> 727     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed"> 728     ObjectSynchronizer::slow_exit(obj, lock-&gt;lock(), THREAD);</span>
<span class="line-removed"> 729   } else {</span>
<span class="line-removed"> 730     ObjectSynchronizer::fast_exit(obj, lock-&gt;lock(), THREAD);</span>
<span class="line-removed"> 731   }</span>
 732 JRT_END
 733 
 734 // Cf. OptoRuntime::deoptimize_caller_frame
 735 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
 736   // Called from within the owner thread, so no need for safepoint
 737   RegisterMap reg_map(thread, false);
 738   frame stub_frame = thread-&gt;last_frame();
 739   assert(stub_frame.is_runtime_frame(), &quot;Sanity check&quot;);
 740   frame caller_frame = stub_frame.sender(&amp;reg_map);
 741   nmethod* nm = caller_frame.cb()-&gt;as_nmethod_or_null();
 742   assert(nm != NULL, &quot;Sanity check&quot;);
 743   methodHandle method(thread, nm-&gt;method());
 744   assert(nm == CodeCache::find_nmethod(caller_frame.pc()), &quot;Should be the same&quot;);
 745   Deoptimization::DeoptAction action = Deoptimization::trap_request_action(trap_request);
 746   Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
 747 
 748   if (action == Deoptimization::Action_make_not_entrant) {
 749     if (nm-&gt;make_not_entrant()) {
 750       if (reason == Deoptimization::Reason_tenured) {
 751         MethodData* trap_mdo = Deoptimization::get_method_data(thread, method, true /*create_if_missing*/);
 752         if (trap_mdo != NULL) {
 753           trap_mdo-&gt;inc_tenure_traps();
 754         }
 755       }
 756     }
 757   }
 758 
 759   // Deoptimize the caller frame.
 760   Deoptimization::deoptimize_frame(thread, caller_frame.id());
 761   // Return to the now deoptimized frame.
 762 JRT_END
 763 
 764 
 765 #ifndef DEOPTIMIZE_WHEN_PATCHING
 766 
 767 static Klass* resolve_field_return_klass(const methodHandle&amp; caller, int bci, TRAPS) {
 768   Bytecode_field field_access(caller, bci);
 769   // This can be static or non-static field access
 770   Bytecodes::Code code       = field_access.code();
 771 
 772   // We must load class, initialize class and resolve the field
 773   fieldDescriptor result; // initialize class if needed
 774   constantPoolHandle constants(THREAD, caller-&gt;constants());
 775   LinkResolver::resolve_field_access(result, constants, field_access.index(), caller, Bytecodes::java_code(code), CHECK_NULL);
 776   return result.field_holder();
 777 }
 778 
 779 
 780 //
 781 // This routine patches sites where a class wasn&#39;t loaded or
 782 // initialized at the time the code was generated.  It handles
 783 // references to classes, fields and forcing of initialization.  Most
 784 // of the cases are straightforward and involving simply forcing
 785 // resolution of a class, rewriting the instruction stream with the
 786 // needed constant and replacing the call in this function with the
 787 // patched code.  The case for static field is more complicated since
 788 // the thread which is in the process of initializing a class can
 789 // access it&#39;s static fields but other threads can&#39;t so the code
 790 // either has to deoptimize when this case is detected or execute a
 791 // check that the current thread is the initializing thread.  The
 792 // current
 793 //
 794 // Patches basically look like this:
 795 //
 796 //
 797 // patch_site: jmp patch stub     ;; will be patched
 798 // continue:   ...
 799 //             ...
 800 //             ...
 801 //             ...
 802 //
 803 // They have a stub which looks like this:
 804 //
 805 //             ;; patch body
 806 //             movl &lt;const&gt;, reg           (for class constants)
 807 //        &lt;or&gt; movl [reg1 + &lt;const&gt;], reg  (for field offsets)
 808 //        &lt;or&gt; movl reg, [reg1 + &lt;const&gt;]  (for field offsets)
 809 //             &lt;being_init offset&gt; &lt;bytes to copy&gt; &lt;bytes to skip&gt;
 810 // patch_stub: call Runtime1::patch_code (through a runtime stub)
 811 //             jmp patch_site
 812 //
 813 //
 814 // A normal patch is done by rewriting the patch body, usually a move,
 815 // and then copying it into place over top of the jmp instruction
 816 // being careful to flush caches and doing it in an MP-safe way.  The
 817 // constants following the patch body are used to find various pieces
 818 // of the patch relative to the call site for Runtime1::patch_code.
 819 // The case for getstatic and putstatic is more complicated because
 820 // getstatic and putstatic have special semantics when executing while
 821 // the class is being initialized.  getstatic/putstatic on a class
 822 // which is being_initialized may be executed by the initializing
 823 // thread but other threads have to block when they execute it.  This
 824 // is accomplished in compiled code by executing a test of the current
 825 // thread against the initializing thread of the class.  It&#39;s emitted
 826 // as boilerplate in their stub which allows the patched code to be
 827 // executed before it&#39;s copied back into the main body of the nmethod.
 828 //
 829 // being_init: get_thread(&lt;tmp reg&gt;
 830 //             cmpl [reg1 + &lt;init_thread_offset&gt;], &lt;tmp reg&gt;
 831 //             jne patch_stub
 832 //             movl [reg1 + &lt;const&gt;], reg  (for field offsets)  &lt;or&gt;
 833 //             movl reg, [reg1 + &lt;const&gt;]  (for field offsets)
 834 //             jmp continue
 835 //             &lt;being_init offset&gt; &lt;bytes to copy&gt; &lt;bytes to skip&gt;
 836 // patch_stub: jmp Runtim1::patch_code (through a runtime stub)
 837 //             jmp patch_site
 838 //
 839 // If the class is being initialized the patch body is rewritten and
 840 // the patch site is rewritten to jump to being_init, instead of
 841 // patch_stub.  Whenever this code is executed it checks the current
 842 // thread against the intializing thread so other threads will enter
 843 // the runtime and end up blocked waiting the class to finish
 844 // initializing inside the calls to resolve_field below.  The
 845 // initializing class will continue on it&#39;s way.  Once the class is
 846 // fully_initialized, the intializing_thread of the class becomes
 847 // NULL, so the next thread to execute this code will fail the test,
 848 // call into patch_code and complete the patching process by copying
 849 // the patch body back into the main part of the nmethod and resume
 850 // executing.
 851 
 852 // NB:
 853 //
 854 // Patchable instruction sequences inherently exhibit race conditions,
 855 // where thread A is patching an instruction at the same time thread B
 856 // is executing it.  The algorithms we use ensure that any observation
 857 // that B can make on any intermediate states during A&#39;s patching will
 858 // always end up with a correct outcome.  This is easiest if there are
 859 // few or no intermediate states.  (Some inline caches have two
 860 // related instructions that must be patched in tandem.  For those,
 861 // intermediate states seem to be unavoidable, but we will get the
 862 // right answer from all possible observation orders.)
 863 //
 864 // When patching the entry instruction at the head of a method, or a
 865 // linkable call instruction inside of a method, we try very hard to
 866 // use a patch sequence which executes as a single memory transaction.
 867 // This means, in practice, that when thread A patches an instruction,
 868 // it should patch a 32-bit or 64-bit word that somehow overlaps the
 869 // instruction or is contained in it.  We believe that memory hardware
 870 // will never break up such a word write, if it is naturally aligned
 871 // for the word being written.  We also know that some CPUs work very
 872 // hard to create atomic updates even of naturally unaligned words,
 873 // but we don&#39;t want to bet the farm on this always working.
 874 //
 875 // Therefore, if there is any chance of a race condition, we try to
 876 // patch only naturally aligned words, as single, full-word writes.
 877 
 878 JRT_ENTRY(void, Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id ))
 879   NOT_PRODUCT(_patch_code_slowcase_cnt++;)
 880 
 881   ResourceMark rm(thread);
 882   RegisterMap reg_map(thread, false);
 883   frame runtime_frame = thread-&gt;last_frame();
 884   frame caller_frame = runtime_frame.sender(&amp;reg_map);
 885 
 886   // last java frame on stack
 887   vframeStream vfst(thread, true);
 888   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
 889 
 890   methodHandle caller_method(THREAD, vfst.method());
 891   // Note that caller_method-&gt;code() may not be same as caller_code because of OSR&#39;s
 892   // Note also that in the presence of inlining it is not guaranteed
 893   // that caller_method() == caller_code-&gt;method()
 894 
 895   int bci = vfst.bci();
 896   Bytecodes::Code code = caller_method()-&gt;java_code_at(bci);
 897 
 898   // this is used by assertions in the access_field_patching_id
 899   BasicType patch_field_type = T_ILLEGAL;
 900   bool deoptimize_for_volatile = false;
 901   bool deoptimize_for_atomic = false;
 902   int patch_field_offset = -1;
 903   Klass* init_klass = NULL; // klass needed by load_klass_patching code
 904   Klass* load_klass = NULL; // klass needed by load_klass_patching code
 905   Handle mirror(THREAD, NULL);                    // oop needed by load_mirror_patching code
 906   Handle appendix(THREAD, NULL);                  // oop needed by appendix_patching code
 907   bool load_klass_or_mirror_patch_id =
 908     (stub_id == Runtime1::load_klass_patching_id || stub_id == Runtime1::load_mirror_patching_id);
 909 
 910   if (stub_id == Runtime1::access_field_patching_id) {
 911 
 912     Bytecode_field field_access(caller_method, bci);
 913     fieldDescriptor result; // initialize class if needed
 914     Bytecodes::Code code = field_access.code();
 915     constantPoolHandle constants(THREAD, caller_method-&gt;constants());
 916     LinkResolver::resolve_field_access(result, constants, field_access.index(), caller_method, Bytecodes::java_code(code), CHECK);
 917     patch_field_offset = result.offset();
 918 
 919     // If we&#39;re patching a field which is volatile then at compile it
 920     // must not have been know to be volatile, so the generated code
 921     // isn&#39;t correct for a volatile reference.  The nmethod has to be
 922     // deoptimized so that the code can be regenerated correctly.
 923     // This check is only needed for access_field_patching since this
 924     // is the path for patching field offsets.  load_klass is only
 925     // used for patching references to oops which don&#39;t need special
 926     // handling in the volatile case.
 927 
 928     deoptimize_for_volatile = result.access_flags().is_volatile();
 929 
 930     // If we are patching a field which should be atomic, then
 931     // the generated code is not correct either, force deoptimizing.
 932     // We need to only cover T_LONG and T_DOUBLE fields, as we can
 933     // break access atomicity only for them.
 934 
 935     // Strictly speaking, the deoptimization on 64-bit platforms
 936     // is unnecessary, and T_LONG stores on 32-bit platforms need
 937     // to be handled by special patching code when AlwaysAtomicAccesses
 938     // becomes product feature. At this point, we are still going
 939     // for the deoptimization for consistency against volatile
 940     // accesses.
 941 
 942     patch_field_type = result.field_type();
 943     deoptimize_for_atomic = (AlwaysAtomicAccesses &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG));
 944 
 945   } else if (load_klass_or_mirror_patch_id) {
 946     Klass* k = NULL;
 947     switch (code) {
 948       case Bytecodes::_putstatic:
 949       case Bytecodes::_getstatic:
 950         { Klass* klass = resolve_field_return_klass(caller_method, bci, CHECK);
 951           init_klass = klass;
 952           mirror = Handle(THREAD, klass-&gt;java_mirror());
 953         }
 954         break;
 955       case Bytecodes::_new:
 956         { Bytecode_new bnew(caller_method(), caller_method-&gt;bcp_from(bci));
 957           k = caller_method-&gt;constants()-&gt;klass_at(bnew.index(), CHECK);
 958         }
 959         break;
 960       case Bytecodes::_multianewarray:
 961         { Bytecode_multianewarray mna(caller_method(), caller_method-&gt;bcp_from(bci));
 962           k = caller_method-&gt;constants()-&gt;klass_at(mna.index(), CHECK);
 963         }
 964         break;
 965       case Bytecodes::_instanceof:
 966         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
 967           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
 968         }
 969         break;
 970       case Bytecodes::_checkcast:
 971         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
 972           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
 973         }
 974         break;
 975       case Bytecodes::_anewarray:
 976         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
 977           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
 978           k = ek-&gt;array_klass(CHECK);
 979         }
 980         break;
 981       case Bytecodes::_ldc:
 982       case Bytecodes::_ldc_w:
 983         {
 984           Bytecode_loadconstant cc(caller_method, bci);
 985           oop m = cc.resolve_constant(CHECK);
 986           mirror = Handle(THREAD, m);
 987         }
 988         break;
 989       default: fatal(&quot;unexpected bytecode for load_klass_or_mirror_patch_id&quot;);
 990     }
 991     load_klass = k;
 992   } else if (stub_id == load_appendix_patching_id) {
 993     Bytecode_invoke bytecode(caller_method, bci);
 994     Bytecodes::Code bc = bytecode.invoke_code();
 995 
 996     CallInfo info;
 997     constantPoolHandle pool(thread, caller_method-&gt;constants());
 998     int index = bytecode.index();
 999     LinkResolver::resolve_invoke(info, Handle(), pool, index, bc, CHECK);
1000     switch (bc) {
1001       case Bytecodes::_invokehandle: {
1002         int cache_index = ConstantPool::decode_cpcache_index(index, true);
1003         assert(cache_index &gt;= 0 &amp;&amp; cache_index &lt; pool-&gt;cache()-&gt;length(), &quot;unexpected cache index&quot;);
1004         ConstantPoolCacheEntry* cpce = pool-&gt;cache()-&gt;entry_at(cache_index);
1005         cpce-&gt;set_method_handle(pool, info);
1006         appendix = Handle(THREAD, cpce-&gt;appendix_if_resolved(pool)); // just in case somebody already resolved the entry
1007         break;
1008       }
1009       case Bytecodes::_invokedynamic: {
1010         ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(index);
1011         cpce-&gt;set_dynamic_call(pool, info);
1012         appendix = Handle(THREAD, cpce-&gt;appendix_if_resolved(pool)); // just in case somebody already resolved the entry
1013         break;
1014       }
1015       default: fatal(&quot;unexpected bytecode for load_appendix_patching_id&quot;);
1016     }
1017   } else {
1018     ShouldNotReachHere();
1019   }
1020 
1021   if (deoptimize_for_volatile || deoptimize_for_atomic) {
1022     // At compile time we assumed the field wasn&#39;t volatile/atomic but after
1023     // loading it turns out it was volatile/atomic so we have to throw the
1024     // compiled code out and let it be regenerated.
1025     if (TracePatching) {
1026       if (deoptimize_for_volatile) {
1027         tty-&gt;print_cr(&quot;Deoptimizing for patching volatile field reference&quot;);
1028       }
1029       if (deoptimize_for_atomic) {
1030         tty-&gt;print_cr(&quot;Deoptimizing for patching atomic field reference&quot;);
1031       }
1032     }
1033 
1034     // It&#39;s possible the nmethod was invalidated in the last
1035     // safepoint, but if it&#39;s still alive then make it not_entrant.
1036     nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
1037     if (nm != NULL) {
1038       nm-&gt;make_not_entrant();
1039     }
1040 
1041     Deoptimization::deoptimize_frame(thread, caller_frame.id());
1042 
1043     // Return to the now deoptimized frame.
1044   }
1045 
1046   // Now copy code back
1047 
1048   {
<a name="10" id="anc10"></a><span class="line-modified">1049     MutexLockerEx ml_patch (Patching_lock, Mutex::_no_safepoint_check_flag);</span>
1050     //
1051     // Deoptimization may have happened while we waited for the lock.
1052     // In that case we don&#39;t bother to do any patching we just return
1053     // and let the deopt happen
1054     if (!caller_is_deopted()) {
1055       NativeGeneralJump* jump = nativeGeneralJump_at(caller_frame.pc());
1056       address instr_pc = jump-&gt;jump_destination();
1057       NativeInstruction* ni = nativeInstruction_at(instr_pc);
1058       if (ni-&gt;is_jump() ) {
1059         // the jump has not been patched yet
1060         // The jump destination is slow case and therefore not part of the stubs
1061         // (stubs are only for StaticCalls)
1062 
1063         // format of buffer
1064         //    ....
1065         //    instr byte 0     &lt;-- copy_buff
1066         //    instr byte 1
1067         //    ..
1068         //    instr byte n-1
1069         //      n
1070         //    ....             &lt;-- call destination
1071 
1072         address stub_location = caller_frame.pc() + PatchingStub::patch_info_offset();
1073         unsigned char* byte_count = (unsigned char*) (stub_location - 1);
1074         unsigned char* byte_skip = (unsigned char*) (stub_location - 2);
1075         unsigned char* being_initialized_entry_offset = (unsigned char*) (stub_location - 3);
1076         address copy_buff = stub_location - *byte_skip - *byte_count;
1077         address being_initialized_entry = stub_location - *being_initialized_entry_offset;
1078         if (TracePatching) {
1079           ttyLocker ttyl;
1080           tty-&gt;print_cr(&quot; Patching %s at bci %d at address &quot; INTPTR_FORMAT &quot;  (%s)&quot;, Bytecodes::name(code), bci,
1081                         p2i(instr_pc), (stub_id == Runtime1::access_field_patching_id) ? &quot;field&quot; : &quot;klass&quot;);
1082           nmethod* caller_code = CodeCache::find_nmethod(caller_frame.pc());
1083           assert(caller_code != NULL, &quot;nmethod not found&quot;);
1084 
1085           // NOTE we use pc() not original_pc() because we already know they are
1086           // identical otherwise we&#39;d have never entered this block of code
1087 
1088           const ImmutableOopMap* map = caller_code-&gt;oop_map_for_return_address(caller_frame.pc());
1089           assert(map != NULL, &quot;null check&quot;);
1090           map-&gt;print();
1091           tty-&gt;cr();
1092 
1093           Disassembler::decode(copy_buff, copy_buff + *byte_count, tty);
1094         }
1095         // depending on the code below, do_patch says whether to copy the patch body back into the nmethod
1096         bool do_patch = true;
1097         if (stub_id == Runtime1::access_field_patching_id) {
1098           // The offset may not be correct if the class was not loaded at code generation time.
1099           // Set it now.
1100           NativeMovRegMem* n_move = nativeMovRegMem_at(copy_buff);
1101           assert(n_move-&gt;offset() == 0 || (n_move-&gt;offset() == 4 &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG)), &quot;illegal offset for type&quot;);
1102           assert(patch_field_offset &gt;= 0, &quot;illegal offset&quot;);
1103           n_move-&gt;add_offset_in_bytes(patch_field_offset);
1104         } else if (load_klass_or_mirror_patch_id) {
1105           // If a getstatic or putstatic is referencing a klass which
1106           // isn&#39;t fully initialized, the patch body isn&#39;t copied into
1107           // place until initialization is complete.  In this case the
1108           // patch site is setup so that any threads besides the
1109           // initializing thread are forced to come into the VM and
1110           // block.
1111           do_patch = (code != Bytecodes::_getstatic &amp;&amp; code != Bytecodes::_putstatic) ||
1112                      InstanceKlass::cast(init_klass)-&gt;is_initialized();
1113           NativeGeneralJump* jump = nativeGeneralJump_at(instr_pc);
1114           if (jump-&gt;jump_destination() == being_initialized_entry) {
1115             assert(do_patch == true, &quot;initialization must be complete at this point&quot;);
1116           } else {
1117             // patch the instruction &lt;move reg, klass&gt;
1118             NativeMovConstReg* n_copy = nativeMovConstReg_at(copy_buff);
1119 
1120             assert(n_copy-&gt;data() == 0 ||
1121                    n_copy-&gt;data() == (intptr_t)Universe::non_oop_word(),
1122                    &quot;illegal init value&quot;);
1123             if (stub_id == Runtime1::load_klass_patching_id) {
1124               assert(load_klass != NULL, &quot;klass not set&quot;);
1125               n_copy-&gt;set_data((intx) (load_klass));
1126             } else {
1127               assert(mirror() != NULL, &quot;klass not set&quot;);
1128               // Don&#39;t need a G1 pre-barrier here since we assert above that data isn&#39;t an oop.
1129               n_copy-&gt;set_data(cast_from_oop&lt;intx&gt;(mirror()));
1130             }
1131 
1132             if (TracePatching) {
1133               Disassembler::decode(copy_buff, copy_buff + *byte_count, tty);
1134             }
1135           }
1136         } else if (stub_id == Runtime1::load_appendix_patching_id) {
1137           NativeMovConstReg* n_copy = nativeMovConstReg_at(copy_buff);
1138           assert(n_copy-&gt;data() == 0 ||
1139                  n_copy-&gt;data() == (intptr_t)Universe::non_oop_word(),
1140                  &quot;illegal init value&quot;);
1141           n_copy-&gt;set_data(cast_from_oop&lt;intx&gt;(appendix()));
1142 
1143           if (TracePatching) {
1144             Disassembler::decode(copy_buff, copy_buff + *byte_count, tty);
1145           }
1146         } else {
1147           ShouldNotReachHere();
1148         }
1149 
1150 #if defined(SPARC) || defined(PPC32)
1151         if (load_klass_or_mirror_patch_id ||
1152             stub_id == Runtime1::load_appendix_patching_id) {
1153           // Update the location in the nmethod with the proper
1154           // metadata.  When the code was generated, a NULL was stuffed
1155           // in the metadata table and that table needs to be update to
1156           // have the right value.  On intel the value is kept
1157           // directly in the instruction instead of in the metadata
1158           // table, so set_data above effectively updated the value.
1159           nmethod* nm = CodeCache::find_nmethod(instr_pc);
1160           assert(nm != NULL, &quot;invalid nmethod_pc&quot;);
1161           RelocIterator mds(nm, copy_buff, copy_buff + 1);
1162           bool found = false;
1163           while (mds.next() &amp;&amp; !found) {
1164             if (mds.type() == relocInfo::oop_type) {
1165               assert(stub_id == Runtime1::load_mirror_patching_id ||
1166                      stub_id == Runtime1::load_appendix_patching_id, &quot;wrong stub id&quot;);
1167               oop_Relocation* r = mds.oop_reloc();
1168               oop* oop_adr = r-&gt;oop_addr();
1169               *oop_adr = stub_id == Runtime1::load_mirror_patching_id ? mirror() : appendix();
1170               r-&gt;fix_oop_relocation();
1171               found = true;
1172             } else if (mds.type() == relocInfo::metadata_type) {
1173               assert(stub_id == Runtime1::load_klass_patching_id, &quot;wrong stub id&quot;);
1174               metadata_Relocation* r = mds.metadata_reloc();
1175               Metadata** metadata_adr = r-&gt;metadata_addr();
1176               *metadata_adr = load_klass;
1177               r-&gt;fix_metadata_relocation();
1178               found = true;
1179             }
1180           }
1181           assert(found, &quot;the metadata must exist!&quot;);
1182         }
1183 #endif
1184         if (do_patch) {
1185           // replace instructions
1186           // first replace the tail, then the call
1187 #ifdef ARM
1188           if((load_klass_or_mirror_patch_id ||
1189               stub_id == Runtime1::load_appendix_patching_id) &amp;&amp;
1190               nativeMovConstReg_at(copy_buff)-&gt;is_pc_relative()) {
1191             nmethod* nm = CodeCache::find_nmethod(instr_pc);
1192             address addr = NULL;
1193             assert(nm != NULL, &quot;invalid nmethod_pc&quot;);
1194             RelocIterator mds(nm, copy_buff, copy_buff + 1);
1195             while (mds.next()) {
1196               if (mds.type() == relocInfo::oop_type) {
1197                 assert(stub_id == Runtime1::load_mirror_patching_id ||
1198                        stub_id == Runtime1::load_appendix_patching_id, &quot;wrong stub id&quot;);
1199                 oop_Relocation* r = mds.oop_reloc();
1200                 addr = (address)r-&gt;oop_addr();
1201                 break;
1202               } else if (mds.type() == relocInfo::metadata_type) {
1203                 assert(stub_id == Runtime1::load_klass_patching_id, &quot;wrong stub id&quot;);
1204                 metadata_Relocation* r = mds.metadata_reloc();
1205                 addr = (address)r-&gt;metadata_addr();
1206                 break;
1207               }
1208             }
1209             assert(addr != NULL, &quot;metadata relocation must exist&quot;);
1210             copy_buff -= *byte_count;
1211             NativeMovConstReg* n_copy2 = nativeMovConstReg_at(copy_buff);
1212             n_copy2-&gt;set_pc_relative_offset(addr, instr_pc);
1213           }
1214 #endif
1215 
1216           for (int i = NativeGeneralJump::instruction_size; i &lt; *byte_count; i++) {
1217             address ptr = copy_buff + i;
1218             int a_byte = (*ptr) &amp; 0xFF;
1219             address dst = instr_pc + i;
1220             *(unsigned char*)dst = (unsigned char) a_byte;
1221           }
1222           ICache::invalidate_range(instr_pc, *byte_count);
1223           NativeGeneralJump::replace_mt_safe(instr_pc, copy_buff);
1224 
1225           if (load_klass_or_mirror_patch_id ||
1226               stub_id == Runtime1::load_appendix_patching_id) {
1227             relocInfo::relocType rtype =
1228               (stub_id == Runtime1::load_klass_patching_id) ?
1229                                    relocInfo::metadata_type :
1230                                    relocInfo::oop_type;
1231             // update relocInfo to metadata
1232             nmethod* nm = CodeCache::find_nmethod(instr_pc);
1233             assert(nm != NULL, &quot;invalid nmethod_pc&quot;);
1234 
1235             // The old patch site is now a move instruction so update
1236             // the reloc info so that it will get updated during
1237             // future GCs.
1238             RelocIterator iter(nm, (address)instr_pc, (address)(instr_pc + 1));
1239             relocInfo::change_reloc_info_for_address(&amp;iter, (address) instr_pc,
1240                                                      relocInfo::none, rtype);
1241 #ifdef SPARC
1242             // Sparc takes two relocations for an metadata so update the second one.
1243             address instr_pc2 = instr_pc + NativeMovConstReg::add_offset;
1244             RelocIterator iter2(nm, instr_pc2, instr_pc2 + 1);
1245             relocInfo::change_reloc_info_for_address(&amp;iter2, (address) instr_pc2,
1246                                                      relocInfo::none, rtype);
1247 #endif
1248 #ifdef PPC32
1249           { address instr_pc2 = instr_pc + NativeMovConstReg::lo_offset;
1250             RelocIterator iter2(nm, instr_pc2, instr_pc2 + 1);
1251             relocInfo::change_reloc_info_for_address(&amp;iter2, (address) instr_pc2,
1252                                                      relocInfo::none, rtype);
1253           }
1254 #endif
1255           }
1256 
1257         } else {
1258           ICache::invalidate_range(copy_buff, *byte_count);
1259           NativeGeneralJump::insert_unconditional(instr_pc, being_initialized_entry);
1260         }
1261       }
1262     }
1263   }
1264 
1265   // If we are patching in a non-perm oop, make sure the nmethod
1266   // is on the right list.
1267   {
<a name="11" id="anc11"></a><span class="line-modified">1268     MutexLockerEx ml_code (CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1269     nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
1270     guarantee(nm != NULL, &quot;only nmethods can contain non-perm oops&quot;);
1271 
1272     // Since we&#39;ve patched some oops in the nmethod,
1273     // (re)register it with the heap.
1274     Universe::heap()-&gt;register_nmethod(nm);
1275   }
1276 JRT_END
1277 
1278 #else // DEOPTIMIZE_WHEN_PATCHING
1279 
1280 JRT_ENTRY(void, Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id ))
1281   RegisterMap reg_map(thread, false);
1282 
1283   NOT_PRODUCT(_patch_code_slowcase_cnt++;)
1284   if (TracePatching) {
1285     tty-&gt;print_cr(&quot;Deoptimizing because patch is needed&quot;);
1286   }
1287 
1288   frame runtime_frame = thread-&gt;last_frame();
1289   frame caller_frame = runtime_frame.sender(&amp;reg_map);
1290 
1291   // It&#39;s possible the nmethod was invalidated in the last
1292   // safepoint, but if it&#39;s still alive then make it not_entrant.
1293   nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
1294   if (nm != NULL) {
1295     nm-&gt;make_not_entrant();
1296   }
1297 
1298   Deoptimization::deoptimize_frame(thread, caller_frame.id());
1299 
1300   // Return to the now deoptimized frame.
1301 JRT_END
1302 
1303 #endif // DEOPTIMIZE_WHEN_PATCHING
1304 
1305 //
1306 // Entry point for compiled code. We want to patch a nmethod.
1307 // We don&#39;t do a normal VM transition here because we want to
1308 // know after the patching is complete and any safepoint(s) are taken
1309 // if the calling nmethod was deoptimized. We do this by calling a
1310 // helper method which does the normal VM transition and when it
1311 // completes we can check for deoptimization. This simplifies the
1312 // assembly code in the cpu directories.
1313 //
1314 int Runtime1::move_klass_patching(JavaThread* thread) {
1315 //
1316 // NOTE: we are still in Java
1317 //
1318   Thread* THREAD = thread;
1319   debug_only(NoHandleMark nhm;)
1320   {
1321     // Enter VM mode
1322 
1323     ResetNoHandleMark rnhm;
1324     patch_code(thread, load_klass_patching_id);
1325   }
1326   // Back in JAVA, use no oops DON&#39;T safepoint
1327 
1328   // Return true if calling code is deoptimized
1329 
1330   return caller_is_deopted();
1331 }
1332 
1333 int Runtime1::move_mirror_patching(JavaThread* thread) {
1334 //
1335 // NOTE: we are still in Java
1336 //
1337   Thread* THREAD = thread;
1338   debug_only(NoHandleMark nhm;)
1339   {
1340     // Enter VM mode
1341 
1342     ResetNoHandleMark rnhm;
1343     patch_code(thread, load_mirror_patching_id);
1344   }
1345   // Back in JAVA, use no oops DON&#39;T safepoint
1346 
1347   // Return true if calling code is deoptimized
1348 
1349   return caller_is_deopted();
1350 }
1351 
1352 int Runtime1::move_appendix_patching(JavaThread* thread) {
1353 //
1354 // NOTE: we are still in Java
1355 //
1356   Thread* THREAD = thread;
1357   debug_only(NoHandleMark nhm;)
1358   {
1359     // Enter VM mode
1360 
1361     ResetNoHandleMark rnhm;
1362     patch_code(thread, load_appendix_patching_id);
1363   }
1364   // Back in JAVA, use no oops DON&#39;T safepoint
1365 
1366   // Return true if calling code is deoptimized
1367 
1368   return caller_is_deopted();
1369 }
1370 //
1371 // Entry point for compiled code. We want to patch a nmethod.
1372 // We don&#39;t do a normal VM transition here because we want to
1373 // know after the patching is complete and any safepoint(s) are taken
1374 // if the calling nmethod was deoptimized. We do this by calling a
1375 // helper method which does the normal VM transition and when it
1376 // completes we can check for deoptimization. This simplifies the
1377 // assembly code in the cpu directories.
1378 //
1379 
1380 int Runtime1::access_field_patching(JavaThread* thread) {
1381 //
1382 // NOTE: we are still in Java
1383 //
1384   Thread* THREAD = thread;
1385   debug_only(NoHandleMark nhm;)
1386   {
1387     // Enter VM mode
1388 
1389     ResetNoHandleMark rnhm;
1390     patch_code(thread, access_field_patching_id);
1391   }
1392   // Back in JAVA, use no oops DON&#39;T safepoint
1393 
1394   // Return true if calling code is deoptimized
1395 
1396   return caller_is_deopted();
1397 JRT_END
1398 
1399 
1400 JRT_LEAF(void, Runtime1::trace_block_entry(jint block_id))
1401   // for now we just print out the block id
1402   tty-&gt;print(&quot;%d &quot;, block_id);
1403 JRT_END
1404 
1405 
1406 JRT_LEAF(int, Runtime1::is_instance_of(oopDesc* mirror, oopDesc* obj))
1407   // had to return int instead of bool, otherwise there may be a mismatch
1408   // between the C calling convention and the Java one.
1409   // e.g., on x86, GCC may clear only %al when returning a bool false, but
1410   // JVM takes the whole %eax as the return value, which may misinterpret
1411   // the return value as a boolean true.
1412 
1413   assert(mirror != NULL, &quot;should null-check on mirror before calling&quot;);
1414   Klass* k = java_lang_Class::as_Klass(mirror);
1415   return (k != NULL &amp;&amp; obj != NULL &amp;&amp; obj-&gt;is_a(k)) ? 1 : 0;
1416 JRT_END
1417 
1418 JRT_ENTRY(void, Runtime1::predicate_failed_trap(JavaThread* thread))
1419   ResourceMark rm;
1420 
1421   assert(!TieredCompilation, &quot;incompatible with tiered compilation&quot;);
1422 
1423   RegisterMap reg_map(thread, false);
1424   frame runtime_frame = thread-&gt;last_frame();
1425   frame caller_frame = runtime_frame.sender(&amp;reg_map);
1426 
1427   nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
1428   assert (nm != NULL, &quot;no more nmethod?&quot;);
1429   nm-&gt;make_not_entrant();
1430 
<a name="12" id="anc12"></a><span class="line-modified">1431   methodHandle m(nm-&gt;method());</span>
1432   MethodData* mdo = m-&gt;method_data();
1433 
1434   if (mdo == NULL &amp;&amp; !HAS_PENDING_EXCEPTION) {
1435     // Build an MDO.  Ignore errors like OutOfMemory;
1436     // that simply means we won&#39;t have an MDO to update.
1437     Method::build_interpreter_method_data(m, THREAD);
1438     if (HAS_PENDING_EXCEPTION) {
1439       assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
1440       CLEAR_PENDING_EXCEPTION;
1441     }
1442     mdo = m-&gt;method_data();
1443   }
1444 
1445   if (mdo != NULL) {
1446     mdo-&gt;inc_trap_count(Deoptimization::Reason_none);
1447   }
1448 
1449   if (TracePredicateFailedTraps) {
1450     stringStream ss1, ss2;
1451     vframeStream vfst(thread);
<a name="13" id="anc13"></a><span class="line-modified">1452     methodHandle inlinee = methodHandle(vfst.method());</span>
1453     inlinee-&gt;print_short_name(&amp;ss1);
1454     m-&gt;print_short_name(&amp;ss2);
1455     tty-&gt;print_cr(&quot;Predicate failed trap in method %s at bci %d inlined in %s at pc &quot; INTPTR_FORMAT, ss1.as_string(), vfst.bci(), ss2.as_string(), p2i(caller_frame.pc()));
1456   }
1457 
1458 
1459   Deoptimization::deoptimize_frame(thread, caller_frame.id());
1460 
1461 JRT_END
1462 
1463 #ifndef PRODUCT
1464 void Runtime1::print_statistics() {
1465   tty-&gt;print_cr(&quot;C1 Runtime statistics:&quot;);
1466   tty-&gt;print_cr(&quot; _resolve_invoke_virtual_cnt:     %d&quot;, SharedRuntime::_resolve_virtual_ctr);
1467   tty-&gt;print_cr(&quot; _resolve_invoke_opt_virtual_cnt: %d&quot;, SharedRuntime::_resolve_opt_virtual_ctr);
1468   tty-&gt;print_cr(&quot; _resolve_invoke_static_cnt:      %d&quot;, SharedRuntime::_resolve_static_ctr);
1469   tty-&gt;print_cr(&quot; _handle_wrong_method_cnt:        %d&quot;, SharedRuntime::_wrong_method_ctr);
1470   tty-&gt;print_cr(&quot; _ic_miss_cnt:                    %d&quot;, SharedRuntime::_ic_miss_ctr);
1471   tty-&gt;print_cr(&quot; _generic_arraycopy_cnt:          %d&quot;, _generic_arraycopy_cnt);
1472   tty-&gt;print_cr(&quot; _generic_arraycopystub_cnt:      %d&quot;, _generic_arraycopystub_cnt);
1473   tty-&gt;print_cr(&quot; _byte_arraycopy_cnt:             %d&quot;, _byte_arraycopy_stub_cnt);
1474   tty-&gt;print_cr(&quot; _short_arraycopy_cnt:            %d&quot;, _short_arraycopy_stub_cnt);
1475   tty-&gt;print_cr(&quot; _int_arraycopy_cnt:              %d&quot;, _int_arraycopy_stub_cnt);
1476   tty-&gt;print_cr(&quot; _long_arraycopy_cnt:             %d&quot;, _long_arraycopy_stub_cnt);
1477   tty-&gt;print_cr(&quot; _oop_arraycopy_cnt:              %d&quot;, _oop_arraycopy_stub_cnt);
1478   tty-&gt;print_cr(&quot; _arraycopy_slowcase_cnt:         %d&quot;, _arraycopy_slowcase_cnt);
1479   tty-&gt;print_cr(&quot; _arraycopy_checkcast_cnt:        %d&quot;, _arraycopy_checkcast_cnt);
1480   tty-&gt;print_cr(&quot; _arraycopy_checkcast_attempt_cnt:%d&quot;, _arraycopy_checkcast_attempt_cnt);
1481 
1482   tty-&gt;print_cr(&quot; _new_type_array_slowcase_cnt:    %d&quot;, _new_type_array_slowcase_cnt);
1483   tty-&gt;print_cr(&quot; _new_object_array_slowcase_cnt:  %d&quot;, _new_object_array_slowcase_cnt);
1484   tty-&gt;print_cr(&quot; _new_instance_slowcase_cnt:      %d&quot;, _new_instance_slowcase_cnt);
1485   tty-&gt;print_cr(&quot; _new_multi_array_slowcase_cnt:   %d&quot;, _new_multi_array_slowcase_cnt);
1486   tty-&gt;print_cr(&quot; _monitorenter_slowcase_cnt:      %d&quot;, _monitorenter_slowcase_cnt);
1487   tty-&gt;print_cr(&quot; _monitorexit_slowcase_cnt:       %d&quot;, _monitorexit_slowcase_cnt);
1488   tty-&gt;print_cr(&quot; _patch_code_slowcase_cnt:        %d&quot;, _patch_code_slowcase_cnt);
1489 
1490   tty-&gt;print_cr(&quot; _throw_range_check_exception_count:            %d:&quot;, _throw_range_check_exception_count);
1491   tty-&gt;print_cr(&quot; _throw_index_exception_count:                  %d:&quot;, _throw_index_exception_count);
1492   tty-&gt;print_cr(&quot; _throw_div0_exception_count:                   %d:&quot;, _throw_div0_exception_count);
1493   tty-&gt;print_cr(&quot; _throw_null_pointer_exception_count:           %d:&quot;, _throw_null_pointer_exception_count);
1494   tty-&gt;print_cr(&quot; _throw_class_cast_exception_count:             %d:&quot;, _throw_class_cast_exception_count);
1495   tty-&gt;print_cr(&quot; _throw_incompatible_class_change_error_count:  %d:&quot;, _throw_incompatible_class_change_error_count);
1496   tty-&gt;print_cr(&quot; _throw_array_store_exception_count:            %d:&quot;, _throw_array_store_exception_count);
1497   tty-&gt;print_cr(&quot; _throw_count:                                  %d:&quot;, _throw_count);
1498 
1499   SharedRuntime::print_ic_miss_histogram();
1500   tty-&gt;cr();
1501 }
1502 #endif // PRODUCT
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_InstructionPrinter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 407 }
 408 
 409 //-------------------visits--------------------------
 410 
 411 // complete rework of LIR instruction visitor.
 412 // The virtual call for each instruction type is replaced by a big
 413 // switch that adds the operands for each instruction
 414 
 415 void LIR_OpVisitState::visit(LIR_Op* op) {
 416   // copy information from the LIR_Op
 417   reset();
 418   set_op(op);
 419 
 420   switch (op-&gt;code()) {
 421 
 422 // LIR_Op0
 423     case lir_word_align:               // result and info always invalid
 424     case lir_backwardbranch_target:    // result and info always invalid
 425     case lir_build_frame:              // result and info always invalid
 426     case lir_fpop_raw:                 // result and info always invalid
<span class="line-removed"> 427     case lir_24bit_FPU:                // result and info always invalid</span>
<span class="line-removed"> 428     case lir_reset_FPU:                // result and info always invalid</span>
 429     case lir_breakpoint:               // result and info always invalid
 430     case lir_membar:                   // result and info always invalid
 431     case lir_membar_acquire:           // result and info always invalid
 432     case lir_membar_release:           // result and info always invalid
 433     case lir_membar_loadload:          // result and info always invalid
 434     case lir_membar_storestore:        // result and info always invalid
 435     case lir_membar_loadstore:         // result and info always invalid
 436     case lir_membar_storeload:         // result and info always invalid
 437     case lir_on_spin_wait:
 438     {
 439       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 440       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 441       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 442       break;
 443     }
 444 
 445     case lir_nop:                      // may have info, result always invalid
 446     case lir_std_entry:                // may have result, info always invalid
 447     case lir_osr_entry:                // may have result, info always invalid
 448     case lir_get_thread:               // may have result, info always invalid
</pre>
<hr />
<pre>
 450       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 451       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 452       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 453       break;
 454     }
 455 
 456 
 457 // LIR_OpLabel
 458     case lir_label:                    // result and info always invalid
 459     {
 460       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 461       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 462       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 463       break;
 464     }
 465 
 466 
 467 // LIR_Op1
 468     case lir_fxch:           // input always valid, result and info always invalid
 469     case lir_fld:            // input always valid, result and info always invalid
<span class="line-removed"> 470     case lir_ffree:          // input always valid, result and info always invalid</span>
 471     case lir_push:           // input always valid, result and info always invalid
 472     case lir_pop:            // input always valid, result and info always invalid
 473     case lir_return:         // input always valid, result and info always invalid
 474     case lir_leal:           // input and result always valid, info always invalid
 475     case lir_monaddr:        // input and result always valid, info always invalid
 476     case lir_null_check:     // input and info always valid, result always invalid
 477     case lir_move:           // input and result always valid, may have info
 478     case lir_pack64:         // input and result always valid
 479     case lir_unpack64:       // input and result always valid
 480     {
 481       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 482       LIR_Op1* op1 = (LIR_Op1*)op;
 483 
 484       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 485       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 486       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 487 
 488       break;
 489     }
 490 
</pre>
<hr />
<pre>
1632 const char * LIR_Op::name() const {
1633   const char* s = NULL;
1634   switch(code()) {
1635      // LIR_Op0
1636      case lir_membar:                s = &quot;membar&quot;;        break;
1637      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1638      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1639      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1640      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1641      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1642      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1643      case lir_word_align:            s = &quot;word_align&quot;;    break;
1644      case lir_label:                 s = &quot;label&quot;;         break;
1645      case lir_nop:                   s = &quot;nop&quot;;           break;
1646      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1647      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1648      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1649      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1650      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1651      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
<span class="line-removed">1652      case lir_24bit_FPU:             s = &quot;24bit_FPU&quot;;     break;</span>
<span class="line-removed">1653      case lir_reset_FPU:             s = &quot;reset_FPU&quot;;     break;</span>
1654      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1655      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1656      // LIR_Op1
1657      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1658      case lir_fld:                   s = &quot;fld&quot;;           break;
<span class="line-removed">1659      case lir_ffree:                 s = &quot;ffree&quot;;         break;</span>
1660      case lir_push:                  s = &quot;push&quot;;          break;
1661      case lir_pop:                   s = &quot;pop&quot;;           break;
1662      case lir_null_check:            s = &quot;null_check&quot;;    break;
1663      case lir_return:                s = &quot;return&quot;;        break;
1664      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1665      case lir_leal:                  s = &quot;leal&quot;;          break;
1666      case lir_branch:                s = &quot;branch&quot;;        break;
1667      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1668      case lir_move:                  s = &quot;move&quot;;          break;
1669      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1670      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1671      case lir_throw:                 s = &quot;throw&quot;;         break;
1672      case lir_unwind:                s = &quot;unwind&quot;;        break;
1673      case lir_convert:               s = &quot;convert&quot;;       break;
1674      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1675      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1676      case lir_pack64:                s = &quot;pack64&quot;;        break;
1677      case lir_unpack64:              s = &quot;unpack64&quot;;      break;
1678      // LIR_Op2
1679      case lir_cmp:                   s = &quot;cmp&quot;;           break;
</pre>
</td>
<td>
<hr />
<pre>
 407 }
 408 
 409 //-------------------visits--------------------------
 410 
 411 // complete rework of LIR instruction visitor.
 412 // The virtual call for each instruction type is replaced by a big
 413 // switch that adds the operands for each instruction
 414 
 415 void LIR_OpVisitState::visit(LIR_Op* op) {
 416   // copy information from the LIR_Op
 417   reset();
 418   set_op(op);
 419 
 420   switch (op-&gt;code()) {
 421 
 422 // LIR_Op0
 423     case lir_word_align:               // result and info always invalid
 424     case lir_backwardbranch_target:    // result and info always invalid
 425     case lir_build_frame:              // result and info always invalid
 426     case lir_fpop_raw:                 // result and info always invalid


 427     case lir_breakpoint:               // result and info always invalid
 428     case lir_membar:                   // result and info always invalid
 429     case lir_membar_acquire:           // result and info always invalid
 430     case lir_membar_release:           // result and info always invalid
 431     case lir_membar_loadload:          // result and info always invalid
 432     case lir_membar_storestore:        // result and info always invalid
 433     case lir_membar_loadstore:         // result and info always invalid
 434     case lir_membar_storeload:         // result and info always invalid
 435     case lir_on_spin_wait:
 436     {
 437       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 438       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 439       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 440       break;
 441     }
 442 
 443     case lir_nop:                      // may have info, result always invalid
 444     case lir_std_entry:                // may have result, info always invalid
 445     case lir_osr_entry:                // may have result, info always invalid
 446     case lir_get_thread:               // may have result, info always invalid
</pre>
<hr />
<pre>
 448       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 449       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 450       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 451       break;
 452     }
 453 
 454 
 455 // LIR_OpLabel
 456     case lir_label:                    // result and info always invalid
 457     {
 458       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 459       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 460       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 461       break;
 462     }
 463 
 464 
 465 // LIR_Op1
 466     case lir_fxch:           // input always valid, result and info always invalid
 467     case lir_fld:            // input always valid, result and info always invalid

 468     case lir_push:           // input always valid, result and info always invalid
 469     case lir_pop:            // input always valid, result and info always invalid
 470     case lir_return:         // input always valid, result and info always invalid
 471     case lir_leal:           // input and result always valid, info always invalid
 472     case lir_monaddr:        // input and result always valid, info always invalid
 473     case lir_null_check:     // input and info always valid, result always invalid
 474     case lir_move:           // input and result always valid, may have info
 475     case lir_pack64:         // input and result always valid
 476     case lir_unpack64:       // input and result always valid
 477     {
 478       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 479       LIR_Op1* op1 = (LIR_Op1*)op;
 480 
 481       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 482       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 483       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 484 
 485       break;
 486     }
 487 
</pre>
<hr />
<pre>
1629 const char * LIR_Op::name() const {
1630   const char* s = NULL;
1631   switch(code()) {
1632      // LIR_Op0
1633      case lir_membar:                s = &quot;membar&quot;;        break;
1634      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1635      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1636      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1637      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1638      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1639      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1640      case lir_word_align:            s = &quot;word_align&quot;;    break;
1641      case lir_label:                 s = &quot;label&quot;;         break;
1642      case lir_nop:                   s = &quot;nop&quot;;           break;
1643      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1644      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1645      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1646      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1647      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1648      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;


1649      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1650      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1651      // LIR_Op1
1652      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1653      case lir_fld:                   s = &quot;fld&quot;;           break;

1654      case lir_push:                  s = &quot;push&quot;;          break;
1655      case lir_pop:                   s = &quot;pop&quot;;           break;
1656      case lir_null_check:            s = &quot;null_check&quot;;    break;
1657      case lir_return:                s = &quot;return&quot;;        break;
1658      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1659      case lir_leal:                  s = &quot;leal&quot;;          break;
1660      case lir_branch:                s = &quot;branch&quot;;        break;
1661      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1662      case lir_move:                  s = &quot;move&quot;;          break;
1663      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1664      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1665      case lir_throw:                 s = &quot;throw&quot;;         break;
1666      case lir_unwind:                s = &quot;unwind&quot;;        break;
1667      case lir_convert:               s = &quot;convert&quot;;       break;
1668      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1669      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1670      case lir_pack64:                s = &quot;pack64&quot;;        break;
1671      case lir_unpack64:              s = &quot;unpack64&quot;;      break;
1672      // LIR_Op2
1673      case lir_cmp:                   s = &quot;cmp&quot;;           break;
</pre>
</td>
</tr>
</table>
<center><a href="c1_InstructionPrinter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>